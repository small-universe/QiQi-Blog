{
  "version": "https://jsonfeed.org/version/1.1",
  "title": "七七部落",
  "home_page_url": "http://qiqi.dreamagain.top/",
  "feed_url": "http://qiqi.dreamagain.top/feed.json",
  "description": "Actions speak louder than words.",
  "author": {
    "name": "南辞"
  },
  "items": [
    {
      "title": "关于我",
      "url": "http://qiqi.dreamagain.top/about/intro/",
      "id": "http://qiqi.dreamagain.top/about/intro/",
      "content_html": "<h2 id=\"自我介绍\"> 自我介绍</h2>\n<ul>\n<li>笔名: 南辞</li>\n<li>性别: 男</li>\n<li>年龄: 22</li>\n<li>爱好: 编程</li>\n</ul>\n<h2 id=\"联系方式\"> 联系方式</h2>\n<p>qq：1715261428</p>\n<p>邮箱：18846770224@163.com</p>\n<p>希望能在圈子里认识更多朋友。欢迎大家留言交流。</p>\n<h2 id=\"友情链接\"> 友情链接</h2>\n",
      "date_modified": "2021-02-08T17:34:42.000Z",
      "authors": [
        {
          "name": "南辞"
        }
      ],
      "tags": []
    },
    {
      "title": "关于本站",
      "url": "http://qiqi.dreamagain.top/about/site/",
      "id": "http://qiqi.dreamagain.top/about/site/",
      "content_html": "<h2 id=\"网站介绍\"> 网站介绍</h2>\n<p>网站使用 <a href=\"https://v1.vuepress.vuejs.org/zh/guide/\" target=\"_blank\" rel=\"noopener noreferrer\">VuePress</a> 建站工具构建，主题使用 <a href=\"https://github.com/Mister-Hope/vuepress-theme-hope/\" target=\"_blank\" rel=\"noopener noreferrer\">vuepress-theme-hope</a></p>\n<h2 id=\"仓库链接\"> 仓库链接</h2>\n<ul>\n<li><a href=\"https://github.com/small-universe/QiQi-Blog\" target=\"_blank\" rel=\"noopener noreferrer\"><strong>QiQi-Blog</strong></a></li>\n</ul>\n<h2 id=\"免责声明\"> 免责声明</h2>\n<ul>\n<li>本站内容均用于个人学习，有转载或参考的博客文章都已在每篇博客中声明，若有侵权请联系删除！</li>\n</ul>\n",
      "date_modified": "2021-02-07T05:08:56.000Z",
      "authors": [
        {
          "name": "南辞"
        }
      ],
      "tags": []
    },
    {
      "title": "Home",
      "url": "http://qiqi.dreamagain.top/blog/",
      "id": "http://qiqi.dreamagain.top/blog/",
      "content_html": "",
      "date_modified": "2021-02-08T17:34:42.000Z",
      "authors": [
        {
          "name": "南辞"
        }
      ],
      "tags": []
    },
    {
      "title": "目录导航",
      "url": "http://qiqi.dreamagain.top/content/",
      "id": "http://qiqi.dreamagain.top/content/",
      "summary": "<blockquote>\n<p><img src=\"https://img.shields.io/badge/%E4%B8%83%E4%B8%83%E5%8D%9A%E5%AE%A2-%E7%9B%AE%E5%BD%95%E5%AF%BC%E8%88%AA-blue.svg\" alt=\"img\"></p>\n</blockquote>\n",
      "content_html": "<blockquote>\n<p><img src=\"https://img.shields.io/badge/%E4%B8%83%E4%B8%83%E5%8D%9A%E5%AE%A2-%E7%9B%AE%E5%BD%95%E5%AF%BC%E8%88%AA-blue.svg\" alt=\"img\"></p>\n</blockquote>\n\n<h2 id=\"项目结构\"> 项目结构</h2>\n<blockquote>\n<div><pre><code>.\n├──.github\n|   └── workflows\n|       └── deploy-github.yml(github action 用于持续部署)\n|\n├── src\n│   ├── .vuepress \n│   │   ├── config \n|   |   |   ├── sideBar (侧边栏)\n|   |   |   |   ├── backend\n|   |   |   |   ├── frontend\n|   |   |   |   ├── interview\n|   |   |   |   ├── software\n|   |   |   |   └── index.js\n|   |   |   |\n|   |   |   ├── navBar.js (导航栏)\n|   |   |   └── private.js (私人设置，可在.gitignore中设置不加入版本管理)\n│   │   |\n│   │   ├── public (引用图片资源目录约定使用&quot;/&quot;为public目录)\n|   |   |   └── assets\n|   |   |       ├── icon\n|   |   |       └── img\n|   |   |\n│   │   ├── styles (自定义主题的一些样式)\n│   │   │   ├── base.styl\n│   │   │   ├── index.styl\n│   │   │   └── palette.styl\n|   |   |\n│   │   └── config.js (项目的配置)\n│   │ \n│   ├── about\n|   |   ├── intro.md\n|   |   └── site.md\n|   |  \n│   ├── guide\n|   |   ├── markdown.md\n│   │   └── template.md\n|   |\n│   ├── interview\n|   |   ├── Java208\n│   │   └── readme.md\n|   |\n│   ├── program\n|   |   ├── backend\n│   │   └── readme.md\n|   |\n│   ├── blog.md (博客首页)\n│   ├── content.md (目录导航)\n│   └── readme.md (部落主页)\n|   \n├── .gitignore\n├── deploy.sh (手动部署脚本)\n├── package.json\n└── package-lock.json\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br></div></div></blockquote>\n<h2 id=\"快速导航\"> 快速导航</h2>\n<p>侧边栏显示即为一级目录，点击查看相关内容</p>\n",
      "image": "https://img.shields.io/badge/七七博客-目录导航-blue.svg",
      "date_modified": "2021-02-08T17:34:42.000Z",
      "authors": [
        {
          "name": "南辞"
        }
      ],
      "tags": [
        "目录"
      ]
    },
    {
      "title": "Markdown指南",
      "url": "http://qiqi.dreamagain.top/guide/markdown/",
      "id": "http://qiqi.dreamagain.top/guide/markdown/",
      "summary": "<blockquote>\n<p><code>vuepress-theme-hope</code> 通过内置 <a href=\"https://vuepress-md-enhance.mrhope.site\" target=\"_blank\" rel=\"noopener noreferrer\">md-enhance</a>，在 Markdown 中启用了更多的语法与新功能。</p>\n</blockquote>\n",
      "content_html": "<blockquote>\n<p><code>vuepress-theme-hope</code> 通过内置 <a href=\"https://vuepress-md-enhance.mrhope.site\" target=\"_blank\" rel=\"noopener noreferrer\">md-enhance</a>，在 Markdown 中启用了更多的语法与新功能。</p>\n</blockquote>\n\n<h2 id=\"一键启用\"> 一键启用</h2>\n<p>你可以设置 <code>themeconfig.mdEnhance.enableAll</code> 启用 <a href=\"https://vuepress-md-enhance.mrhope.site\" target=\"_blank\" rel=\"noopener noreferrer\">md-enhance</a> 插件的所有功能。</p>\n<div><div><br><br><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><br><br><br></div><pre><code>module<span>.</span>exports <span>=</span> <span>{</span>\n    themeConfig<span>:</span> <span>{</span>\n        mdEnhance<span>:</span> <span>{</span>\n            enableAll<span>:</span> <span>true</span><span>,</span>\n        <span>}</span><span>,</span>\n    <span>}</span><span>,</span>\n<span>}</span><span>;</span>\n</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h2 id=\"新增的更多语法\"> 新增的更多语法</h2>\n<h3 id=\"上下角标\"> 上下角标</h3>\n<p>19<sup>th</sup> H<sub>2</sub>O</p>\n<details><summary>代码</summary>\n<div><pre><code>19^th^ H<span><span>~</span><span>2</span><span>~</span></span>O\n</code></pre>\n<div><span>1</span><br></div></div></details>\n<ul>\n<li><a href=\"https://vuepress-theme.mrhope.site/zh/guide/feature/markdown/sup-sub/\" target=\"_blank\" rel=\"noopener noreferrer\">点击查看</a></li>\n</ul>\n<h3 id=\"自定义对齐\"> 自定义对齐</h3>\n<div>\n<p>我是居中的</p>\n</div>\n<div>\n<p>我在右对齐</p>\n</div>\n<details><summary>代码</summary>\n<div><pre><code>::: center\n我是居中的\n:::\n\n::: right\n我在右对齐\n:::\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div></details>\n<ul>\n<li><a href=\"https://vuepress-theme.mrhope.site/zh/guide/feature/markdown/align/\" target=\"_blank\" rel=\"noopener noreferrer\">点击查看</a></li>\n</ul>\n<h3 id=\"脚注\"> 脚注</h3>\n<p>此文字有脚注<sup></sup>.</p>\n<details><summary>代码</summary>\n<div><pre><code>此文字有脚注[^first].\n\n<span><span>[</span><span>^first</span><span>]</span><span>:</span> 这是脚注内容</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div></details>\n<ul>\n<li><a href=\"https://vuepress-theme.mrhope.site/zh/guide/feature/markdown/footnote/\" target=\"_blank\" rel=\"noopener noreferrer\">点击查看</a></li>\n</ul>\n<h3 id=\"标记\"> 标记</h3>\n<p>你可以标记 <mark>重要的内容</mark> 。</p>\n<details><summary>代码</summary>\n<div><pre><code>你可以标记 ==重要的内容== 。\n</code></pre>\n<div><span>1</span><br></div></div></details>\n<ul>\n<li><a href=\"https://vuepress-theme.mrhope.site/zh/guide/feature/markdown/mark/\" target=\"_blank\" rel=\"noopener noreferrer\">点击查看</a></li>\n</ul>\n<h3 id=\"流程图\"> 流程图</h3>\n<i>Not supported content</i><details><summary>代码</summary>\n<div><pre><code>@flowstart\ncond=>condition: Process?\nprocess=>operation: Process\ne=>end: End\n\ncond(yes)->process->e\ncond(no)->e\n@flowend\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div></details>\n<ul>\n<li><a href=\"https://vuepress-theme.mrhope.site/zh/guide/feature/markdown/flowchart/\" target=\"_blank\" rel=\"noopener noreferrer\">点击查看</a></li>\n</ul>\n<h3 id=\"tex-语法\"> Tex 语法</h3>\n<p class='katex-block'><span><span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:2.40003em;vertical-align:-0.95003em;\"></span><span><span></span><span><span><span><span style=\"height:1.37144em;\"><span style=\"top:-2.314em;\"><span style=\"height:3em;\"></span><span><span style=\"margin-right:0.05556em;\">∂</span><span><span style=\"margin-right:0.03588em;\">ω</span><span><span><span><span style=\"height:0.590392em;\"><span style=\"top:-2.9890000000000003em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span style=\"margin-right:0.02778em;\">r</span></span></span></span></span></span></span></span></span></span><span style=\"top:-3.23em;\"><span style=\"height:3em;\"></span><span style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span style=\"height:3em;\"></span><span><span><span style=\"margin-right:0.05556em;\">∂</span><span><span><span><span style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span style=\"margin-right:0.02778em;\">r</span></span></span></span></span></span></span></span></span></span></span><span>​</span></span><span><span style=\"height:0.686em;\"><span></span></span></span></span></span><span></span></span><span style=\"margin-right:0.16666666666666666em;\"></span><span><span style=\"top:0em;\"><span>(</span></span><span><span></span><span><span><span><span style=\"height:1.341392em;\"><span style=\"top:-2.314em;\"><span style=\"height:3em;\"></span><span><span style=\"margin-right:0.03588em;\">ω</span></span></span><span style=\"top:-3.23em;\"><span style=\"height:3em;\"></span><span style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span style=\"height:3em;\"></span><span><span><span style=\"margin-right:0.03588em;\">y</span><span><span><span><span style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span><span style=\"margin-right:0.03588em;\">ω</span></span></span></span></span></span></span></span></span></span></span></span><span>​</span></span><span><span style=\"height:0.686em;\"><span></span></span></span></span></span><span></span></span><span style=\"top:0em;\"><span>)</span></span></span><span style=\"margin-right:0.2777777777777778em;\"></span><span>=</span><span style=\"margin-right:0.2777777777777778em;\"></span></span><span><span style=\"height:3.027669em;vertical-align:-1.277669em;\"></span><span><span style=\"top:0em;\"><span>(</span></span><span><span></span><span><span><span><span style=\"height:1.341392em;\"><span style=\"top:-2.314em;\"><span style=\"height:3em;\"></span><span><span style=\"margin-right:0.03588em;\">ω</span></span></span><span style=\"top:-3.23em;\"><span style=\"height:3em;\"></span><span style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span style=\"height:3em;\"></span><span><span><span style=\"margin-right:0.03588em;\">y</span><span><span><span><span style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span><span style=\"margin-right:0.03588em;\">ω</span></span></span></span></span></span></span></span></span></span></span></span><span>​</span></span><span><span style=\"height:0.686em;\"><span></span></span></span></span></span><span></span></span><span style=\"top:0em;\"><span>)</span></span></span><span style=\"margin-right:0.16666666666666666em;\"></span><span><span style=\"top:0em;\"><span>{</span></span><span>(</span><span>lo<span style=\"margin-right:0.01389em;\">g</span></span><span style=\"margin-right:0.16666666666666666em;\"></span><span style=\"margin-right:0.03588em;\">y</span><span><span>)</span><span><span><span><span style=\"height:0.7143919999999999em;\"><span style=\"top:-3.113em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span style=\"margin-right:0.02778em;\">r</span></span></span></span></span></span></span></span><span style=\"margin-right:0.2222222222222222em;\"></span><span>+</span><span style=\"margin-right:0.2222222222222222em;\"></span><span><span><span><span style=\"height:1.6513970000000002em;\"><span style=\"top:-1.872331em;margin-left:0em;\"><span style=\"height:3.05em;\"></span><span><span><span>i</span><span>=</span><span>1</span></span></span></span><span style=\"top:-3.050005em;\"><span style=\"height:3.05em;\"></span><span><span>∑</span></span></span><span style=\"top:-4.3000050000000005em;margin-left:0em;\"><span style=\"height:3.05em;\"></span><span><span style=\"margin-right:0.02778em;\">r</span></span></span></span><span>​</span></span><span><span style=\"height:1.277669em;\"><span></span></span></span></span></span><span style=\"margin-right:0.16666666666666666em;\"></span><span><span></span><span><span><span><span style=\"height:1.5016639999999999em;\"><span style=\"top:-2.314em;\"><span style=\"height:3em;\"></span><span><span><span style=\"margin-right:0.03588em;\">ω</span><span><span><span><span style=\"height:0.750664em;\"><span style=\"top:-2.9890000000000003em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span>i</span></span></span></span></span></span></span></span></span></span><span style=\"top:-3.23em;\"><span style=\"height:3em;\"></span><span style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span style=\"height:3em;\"></span><span><span>(</span><span>−</span><span>1</span><span><span>)</span><span><span><span><span style=\"height:0.824664em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span>i</span></span></span></span></span></span></span></span><span style=\"margin-right:0.02778em;\">r</span><span style=\"margin-right:0.16666666666666666em;\"></span><span>⋯</span><span style=\"margin-right:0.16666666666666666em;\"></span><span>(</span><span style=\"margin-right:0.02778em;\">r</span><span style=\"margin-right:0.2222222222222222em;\"></span><span>−</span><span style=\"margin-right:0.2222222222222222em;\"></span><span>i</span><span style=\"margin-right:0.2222222222222222em;\"></span><span>+</span><span style=\"margin-right:0.2222222222222222em;\"></span><span>1</span><span>)</span><span>(</span><span>lo<span style=\"margin-right:0.01389em;\">g</span></span><span style=\"margin-right:0.16666666666666666em;\"></span><span style=\"margin-right:0.03588em;\">y</span><span><span>)</span><span><span><span><span style=\"height:0.824664em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span><span style=\"margin-right:0.02778em;\">r</span><span>−</span><span>i</span></span></span></span></span></span></span></span></span></span></span></span><span>​</span></span><span><span style=\"height:0.686em;\"><span></span></span></span></span></span><span></span></span><span style=\"top:0em;\"><span>}</span></span></span></span></span></span></span></p>\n<details><summary>代码</summary>\n<div><pre><code>$$\n\\frac {\\partial^r} {\\partial \\omega^r} \\left(\\frac {y^{\\omega}} {\\omega}\\right)\n= \\left(\\frac {y^{\\omega}} {\\omega}\\right) \\left\\{(\\log y)^r + \\sum_{i=1}^r \\frac {(-1)^i r \\cdots (r-i+1) (\\log y)^{r-i}} {\\omega^i} \\right\\}\n$$\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div></details>\n<ul>\n<li><a href=\"https://vuepress-theme.mrhope.site/zh/guide/feature/markdown/tex/\" target=\"_blank\" rel=\"noopener noreferrer\">点击查看</a></li>\n</ul>\n<h3 id=\"代码案例\"> 代码案例</h3>\n\n          <div\n            id=\"code-demo-40b08364\"\n           \n  \n data-title=\"%E4%B8%80%E4%B8%AA%E6%99%AE%E9%80%9A%20Demo\"\n\n            data-code=\"%7B%22html%22%3A%22%3Ch1%3EMr.Hope%3C%2Fh1%3E%5Cn%3Cp%3E%3Cspan%20id%3D%5C%22very%5C%22%3E%E5%8D%81%E5%88%86%3C%2Fspan%3E%20%E5%B8%85%3C%2Fp%3E%5Cn%22%2C%22js%22%3A%22document.querySelector(%5C%22%23very%5C%22).addEventListener(%5C%22click%5C%22%2C%20()%20%3D%3E%20%7B%5Cn%20%20%20%20alert(%5C%22%E5%8D%81%E5%88%86%E5%B8%85%5C%22)%3B%5Cn%7D)%3B%5Cn%22%2C%22css%22%3A%22span%20%7B%5Cn%20%20%20%20color%3A%20red%3B%5Cn%7D%5Cn%22%7D\"\n          >\n              <div>\n                \n              </div>\n              <div>\n                <div>\n<div><pre><code><span><span><span>&lt;</span>h1</span><span>></span></span>Mr.Hope<span><span><span>&lt;/</span>h1</span><span>></span></span>\n<span><span><span>&lt;</span>p</span><span>></span></span><span><span><span>&lt;</span>span</span> <span>id</span><span><span>=</span><span>\"</span>very<span>\"</span></span><span>></span></span>十分<span><span><span>&lt;/</span>span</span><span>></span></span> 帅<span><span><span>&lt;/</span>p</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><div><pre><code>document<span>.</span><span>querySelector</span><span>(</span><span>\"#very\"</span><span>)</span><span>.</span><span>addEventListener</span><span>(</span><span>\"click\"</span><span>,</span> <span>(</span><span>)</span> <span>=></span> <span>{</span>\n    <span>alert</span><span>(</span><span>\"十分帅\"</span><span>)</span><span>;</span>\n<span>}</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><div><pre><code><span>span</span> <span>{</span>\n    <span>color</span><span>:</span> red<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div>\n            </div>\n          </div>\n          \n        </div>\n<details><summary>代码</summary>\n<div><pre><code>::: demo 一个普通 Demo\n\n​```html\n<span><span><span>&lt;</span>h1</span><span>></span></span>Mr.Hope<span><span><span>&lt;/</span>h1</span><span>></span></span>\n<span><span><span>&lt;</span>p</span><span>></span></span><span><span><span>&lt;</span>span</span> <span>id</span><span><span>=</span><span>\"</span>very<span>\"</span></span><span>></span></span>十分<span><span><span>&lt;/</span>span</span><span>></span></span> 帅<span><span><span>&lt;/</span>p</span><span>></span></span>\n<span><span>```</span>\n<span>\n```js\ndocument.querySelector(\"#very\").addEventListener(\"click\", () => {\n  alert(\"十分帅\");\n});</span>\n<span>```</span></span>\n\n<span><span>```</span><span>css</span>\n<span><span>span</span> <span>{</span>\n  <span>color</span><span>:</span> red<span>;</span>\n<span>}</span></span>\n<span>```</span></span>\n\n:::\n\n\n\n:::: details 代码\n\n<span><span>```</span><span>`md</span>\n<span>::: demo [react] 一个 React Demo\n\n​```js\nexport default class App extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { message: \"十分帅\" };\n  }\n  render() {\n    return (\n      <span><span><span>&lt;</span>div</span> <span>className</span><span><span>=</span><span>\"</span>box-react<span>\"</span></span><span>></span></span>\n        Mr.Hope <span><span><span>&lt;</span>span</span><span>></span></span>{this.state.message}<span><span><span>&lt;/</span>span</span><span>></span></span>\n      <span><span><span>&lt;/</span>div</span><span>></span></span>\n    );\n  }\n}</span>\n<span>```</span></span>\n\n<span><span>```</span><span>css</span>\n<span><span>.box-react span</span> <span>{</span>\n  <span>color</span><span>:</span> red<span>;</span>\n<span>}</span></span>\n<span>```</span></span>\n\n:::\n\n\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br></div></div></details>\n\n          <div\n            id=\"code-demo-a8b6364c\"\n           \n  data-type=\"vue\"\n data-title=\"%E4%B8%80%E4%B8%AA%20Vue%20Demo\"\n\n            data-code=\"%7B%22%22%3A%22%5Cn%22%7D\"\n          >\n              <div>\n                \n              </div>\n              <div>\n                <div>\n<p>​```vue\n<template>\n<div>\nMr.Hope <span>{{ message }}</span>\n</div>\n</template>\n<script>\nexport default {\ndata: () =&gt; ({ message: &quot;十分帅&quot; }),\n};\n</script>\n<style>\n.box-vue span {\ncolor: red;\n}\n</style></p>\n<div><pre><code>\n</code></pre>\n<div><span>1</span><br></div></div>\n            </div>\n          </div>\n          \n        </div>\n<details><summary>代码</summary>\n<div><pre><code>::: demo [vue] 一个 Vue Demo\n\n​```vue\n<span><span><span>&lt;</span>template</span><span>></span></span>\n  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>\"</span>box-vue<span>\"</span></span><span>></span></span>\n    Mr.Hope <span><span><span>&lt;</span>span</span><span>></span></span>{{ message }}<span><span><span>&lt;/</span>span</span><span>></span></span>\n  <span><span><span>&lt;/</span>div</span><span>></span></span>\n<span><span><span>&lt;/</span>template</span><span>></span></span>\n<span><span><span>&lt;</span>script</span><span>></span></span><span><span>\n<span>export</span> <span>default</span> <span>{</span>\n  <span>data</span><span>:</span> <span>(</span><span>)</span> <span>=></span> <span>(</span><span>{</span> message<span>:</span> <span>\"十分帅\"</span> <span>}</span><span>)</span><span>,</span>\n<span>}</span><span>;</span>\n</span></span><span><span><span>&lt;/</span>script</span><span>></span></span>\n<span><span><span>&lt;</span>style</span><span>></span></span><span><span>\n<span>.box-vue span</span> <span>{</span>\n  <span>color</span><span>:</span> red<span>;</span>\n<span>}</span>\n</span></span><span><span><span>&lt;/</span>style</span><span>></span></span>\n```\n\n:::\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div></details>\n\n          <div\n            id=\"code-demo-4ad68778\"\n           \n  \n data-title=\"%E4%B8%80%E4%B8%AA%E6%99%AE%E9%80%9A%20Demo\"\n\n            data-code=\"%7B%22%22%3A%22%5Cn%60%60%60ts%5Cnconst%20message%3A%20string%20%3D%20%5C%22Mr.Hope%5C%22%3B%5Cn%5Cndocument.querySelector(%5C%22h1%5C%22).innerHTML%20%3D%20message%3B%5Cn%22%2C%22scss%22%3A%22h1%20%7B%5Cn%20%20font-style%3A%20italic%3B%5Cn%5Cn%20%20%2B%20p%20%7B%5Cn%20%20%20%20color%3A%20red%3B%5Cn%20%20%7D%5Cn%7D%5Cn%22%7D\"\n          >\n              <div>\n                \n              </div>\n              <div>\n                <div>\n<p>​```md</p>\n<h1 id=\"标题\"> 标题</h1>\n<p>十分帅</p>\n<div><pre><code>\n```ts\nconst message: string = &quot;Mr.Hope&quot;;\n\ndocument.querySelector(&quot;h1&quot;).innerHTML = message;\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><div><pre><code><span>h1 </span><span>{</span>\n  <span>font-style</span><span>:</span> italic<span>;</span>\n\n  <span>+ p </span><span>{</span>\n    <span>color</span><span>:</span> red<span>;</span>\n  <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div>\n            </div>\n          </div>\n          \n        </div>\n<details><summary>代码</summary>\n<div><pre><code>::: demo 一个普通 Demo\n\n​```md\n<span><span>#</span> 标题</span>\n\n十分帅\n<span><span>```</span>\n<span>\n```ts\nconst message: string = \"Mr.Hope\";\n\ndocument.querySelector(\"h1\").innerHTML = message;</span>\n<span>```</span></span>\n\n<span><span>```</span><span>scss</span>\n<span><span>h1 </span><span>{</span>\n  <span>font-style</span><span>:</span> italic<span>;</span>\n\n  <span>+ p </span><span>{</span>\n    <span>color</span><span>:</span> red<span>;</span>\n  <span>}</span>\n<span>}</span></span>\n<span>```</span></span>\n\n:::\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div></details>\n<ul>\n<li><a href=\"https://vuepress-theme.mrhope.site/zh/guide/feature/markdown/demo/\" target=\"_blank\" rel=\"noopener noreferrer\">点击查看</a></li>\n</ul>\n<h3 id=\"幻灯片\"> 幻灯片</h3>\n<i>Not supported content</i><details><summary>代码</summary>\n<div><pre><code>@slidestart\n\n<span><span>##</span> 幻灯片 1</span>\n\n一个有文字和 <span>[<span>链接</span>](<span>https://mrhope.site</span>)</span> 的段落\n\n<span>---</span>\n\n<span><span>##</span> 幻灯片 2</span>\n\n<span>-</span> 列表 1\n<span>-</span> 列表 2\n\n<span>---</span>\n\n<span><span>##</span> 幻灯片 3.1</span>\n\n​```js\nconst a = 1;\n```\n\n--\n\n<span><span>##</span> 幻灯片 3.2</span>\n\n$$\nJ(\\theta_0,\\theta_1) = \\sum_{i=0}\n$$\n\n@slideend\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br></div></div></details>\n<ul>\n<li><a href=\"https://vuepress-theme.mrhope.site/zh/guide/feature/markdown/presentation/\" target=\"_blank\" rel=\"noopener noreferrer\">点击查看</a></li>\n</ul>\n<h2 id=\"其他语法\"> 其他语法</h2>\n<div><p>自定义标题</p>\n<p>信息容器</p>\n</div>\n<div><p>自定义标题</p>\n<p>提示容器</p>\n</div>\n<div><p>自定义标题</p>\n<p>警告容器</p>\n</div>\n<div><p>自定义标题</p>\n<p>危险容器</p>\n</div>\n<details><summary>自定义标题</summary>\n<p>详情容器</p>\n</details>\n<details><summary>代码</summary>\n<p>​```md</p>\n<div><p>自定义标题</p>\n<p>信息容器</p>\n</div>\n<div><p>自定义标题</p>\n<p>提示容器</p>\n</div>\n<div><p>自定义标题</p>\n<p>警告容器</p>\n</div>\n<div><p>自定义标题</p>\n<p>危险容器</p>\n</div>\n<details><summary>自定义标题</summary>\n<p>详情容器</p>\n</details>\n<div><pre><code>\n</code></pre>\n<div><span>1</span><br></div></div></details>\n<hr>\n<section>\n<ol>\n<li id=\"fn1\"><p>这是脚注内容 </p>\n</li>\n</ol>\n</section>\n",
      "date_modified": "2021-02-08T17:34:42.000Z",
      "authors": [
        {
          "name": "南辞"
        }
      ],
      "tags": [
        "使用指南"
      ]
    },
    {
      "title": "指南",
      "url": "http://qiqi.dreamagain.top/guide/",
      "id": "http://qiqi.dreamagain.top/guide/",
      "content_html": "<h2 id=\"目录\"> 目录</h2>\n<ul>\n<li><a href=\"./markdown.html\">Markdown指南</a></li>\n<li><a href=\"./template.html\">页面模板</a></li>\n</ul>\n",
      "date_modified": "2021-02-08T17:34:42.000Z",
      "authors": [
        {
          "name": "南辞"
        }
      ],
      "tags": [
        "使用指南"
      ]
    },
    {
      "title": "页面配置模板",
      "url": "http://qiqi.dreamagain.top/guide/template/",
      "id": "http://qiqi.dreamagain.top/guide/template/",
      "summary": "模板",
      "content_html": "<blockquote>\n<div><pre><code><span><span>---</span>\n<span>########## 页面信息配置 ############\n# 这是页面的图标\nicon: page\n# 这是文章的标题\ntitle: 博文参考模板\n# 设置当前页面内容描述\ndescription: 模板\n# 设置作者\nauthor: 南辞\n# 是否原创\noriginal: true\n# 设置写作时间\ntime: 2021-01-01\n# 一个页面只能有一个分类\ncategory: 使用指南\n# 一个页面可以有多个标签\ntag:\n    - 页面配置\n# 设置当前文章是否在列表中置顶。当填入数字时，数字越大，排名越靠前\nsticky: 1\n# 是否将该文章添加至文章列表中\narticle: true\n# 是否将该文章添加至文章列表中\ntimeline: false\n# 设置当前文章的密码\npassword: 123\n# 设置当前页面的预览图(分享图)\nimages: \"/images/1.jpg\"\n\n\n########## 页面显示配置 ###########\n# 默认显示信息\npageInfo:['author', 'visitor', 'time', 'category', 'tag', 'readtime']\n# 当前页面是否显示浏览量\nvisitor: true\n# 当前页面是否开启路径导航\nbreadcrumb: true\n# 当前页面是否开启路径导航图标\nbreadcrumbIcon: true\n# 是否禁用导航栏,false会禁用\nnavbar: true\n# 页面的侧边栏配置选项，支持 false 或 auto\nsidebar: 'auto'\n# 该页面的侧边栏渲染深度\nsidebarDepth: 4\n# 当前页面是否开启评论功能\ncomment: true\n# 页脚,想要移除默认的页脚内容，设置为 '';如果你想使用默认页脚，设置为 true\nfooter: true\n# 页面的自定义布局名称\nlayout: \"\"</span>\n<span>---</span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br></div></div></blockquote>\n",
      "date_published": "2020-12-27T00:00:00.000Z",
      "date_modified": "2021-02-07T05:08:56.000Z",
      "authors": [
        {
          "name": "南辞"
        }
      ],
      "tags": [
        "使用指南"
      ]
    },
    {
      "title": "Java必备208道面试题",
      "url": "http://qiqi.dreamagain.top/interview/Java208/",
      "id": "http://qiqi.dreamagain.top/interview/Java208/",
      "summary": "<div><p>声明</p>\n<p>此份面试题来自知乎<a href=\"https://www.zhihu.com/question/27858692/answer/787505434\" target=\"_blank\" rel=\"noopener noreferrer\">java经验总结</a> ，原文参考答案比较浅显且部分有误，目前已对部分参考答案进行订正、补充。</p>\n<p>提示：此份面试题在学完相关基础后食用效果最佳，可以快速查缺补漏，加深对知识的理解。切忌死记硬背，编程重在理解思想和代码编写</p>\n</div>\n",
      "content_html": "<div><p>声明</p>\n<p>此份面试题来自知乎<a href=\"https://www.zhihu.com/question/27858692/answer/787505434\" target=\"_blank\" rel=\"noopener noreferrer\">java经验总结</a> ，原文参考答案比较浅显且部分有误，目前已对部分参考答案进行订正、补充。</p>\n<p>提示：此份面试题在学完相关基础后食用效果最佳，可以快速查缺补漏，加深对知识的理解。切忌死记硬背，编程重在理解思想和代码编写</p>\n</div>\n\n<h2 id=\"一-面试题模块介绍\"> 一. 面试题模块介绍</h2>\n<p>这份面试题，包含的内容了十九了模块：Java 基础、容器、多线程、反射、对象拷贝、Java Web 模块、异常、网络、设计模式、Spring/Spring MVC、Spring Boot/Spring Cloud、Hibernate、Mybatis、RabbitMQ、Kafka、Zookeeper、MySql、Redis、JVM 。如下图所示：</p>\n<img src=\"./assets/java-00.png\"  />\n<p>可能对于初学者不需要看后面的框架和 JVM 模块的知识，读者朋友们可根据自己的情况，选择对应的模块进行阅读。</p>\n<h2 id=\"二-适宜阅读人群\"> 二. 适宜阅读人群</h2>\n<ul>\n<li>需要面试的初/中/高级 java 程序员</li>\n<li>想要查漏补缺的人</li>\n<li>想要不断完善和扩充自己 java 技术栈的人</li>\n<li>java 面试官</li>\n</ul>\n<h2 id=\"三-具体面试题\"> 三. 具体面试题</h2>\n<div><p>(一)、Java基础</p>\n<br/>\n</div>\n<p>1.JDK和JRE有什么区别?</p>\n<p>2.==和equals的区别是什么?</p>\n<p>3.两个对象的 hashCode()相同，则equals()也一定为true，对吗?</p>\n<p>4.final在java中有什么作用?</p>\n<p>5.java中的 Math.round(-1.5)等于多少?</p>\n<p>6.String 属于基础的数据类型吗?</p>\n<p>7.java 中操作字符串都有哪些类?它们之间有什么区别?</p>\n<p>8.String str=&quot;i&quot;与String str=new String(&quot;i&quot;)一样吗?</p>\n<p>9.如何将字符串反转?</p>\n<p>10.String类的常用方法都有那些?</p>\n<p>11.抽象类必须要有抽象方法吗?</p>\n<p>12.普通类和抽象类有哪些区别?</p>\n<p>13.抽象类能使用final 修饰吗?</p>\n<p>14.接口和抽象类有什么区别?</p>\n<p>15.java中IO流分为几种?</p>\n<p>16.BIO、NIO、AIO有什么区别</p>\n<p>17.Files的常用方法有哪些？</p>\n<div>\n<p><a href=\"./模块01—Java基础.html\">参考答案</a></p>\n</div>\n<hr>\n<div><p>（二）、容器</p>\n<br/>\n</div>\n<p>18.java容器都有哪些?</p>\n<p>19.Collection和Collections有什么区别?</p>\n<p>20.List、Set、Map 之间的区别是什么?</p>\n<p>21.HashMap和Hashtable有什么区别?</p>\n<p>22.如何决定使用HashMap还是TreeMap?</p>\n<p>23.说一下HashMap 的实现原理?</p>\n<p>24.说一下 HashSet 的实现原理?</p>\n<p>25.ArrayList和LinkedList的区别是什么?</p>\n<p>26.如何实现数组和List 之间的转换?</p>\n<p>27.ArrayList和Vector 的区别是什么?</p>\n<p>28.Array和ArrayList有何区别?</p>\n<p>29.在 Queue 中 poll()和remove()有什么区别?</p>\n<p>30.哪些集合类是线程安全的?</p>\n<p>31.迭代器lterator 是什么?</p>\n<p>32.lterator怎么使用?有什么特点?</p>\n<p>33.lterator和Listlterator有什么区别?</p>\n<p>34.怎么确保一个集合不能被修改？</p>\n<div>\n<p><a href=\"./模块02—Java集合.html\">参考答案</a></p>\n</div>\n<hr>\n<div><p>（三）、多线程</p>\n<br/>\n</div>\n<p>35.并行和并发有什么区别?</p>\n<p>36.线程和进程的区别?</p>\n<p>37.守护线程是什么?</p>\n<p>38.创建线程有哪几种方式?</p>\n<p>39.说一下runnable和callable有什么区别?</p>\n<p>40.线程有哪些状态?</p>\n<p>41.sleep()和wait()有什么区别?</p>\n<p>42.notify()和 notifyAll)有什么区别?</p>\n<p>43.线程的run()和start()有什么区别?</p>\n<p>44.创建线程池有哪几种方式?</p>\n<p>45.线程池都有哪些状态?</p>\n<p>46.线程池中 submit()和execute()方法有什么区别?</p>\n<p>47.在java程序中怎么保证多线程的运行安全?</p>\n<p>48.多线程锁的升级原理是什么?</p>\n<p>49.什么是死锁?</p>\n<p>50.怎么防止死锁?</p>\n<p>51.ThreadLocal是什么?有哪些使用场景?</p>\n<p>52.说一下synchronized底层实现原理?</p>\n<p>53.synchronized和volatile 的区别是什么?</p>\n<p>54.synchronized和Lock有什么区别?</p>\n<p>55.synchronized和ReentrantLock区别是什么?</p>\n<p>56.说一下atomic 的原理?</p>\n<hr>\n<div><p>（四）、反射</p>\n<br/>\n</div>\n<p>57.什么是反射?</p>\n<p>58.什么是java序列化?什么情况下需要序列化?</p>\n<p>59.动态代理是什么?有哪些应用?</p>\n<p>60.怎么实现动态代理?</p>\n<hr>\n<div><p>（五）、对象拷贝</p>\n<br/>\n</div>\n<p>61.为什么要使用克隆?</p>\n<p>62.如何实现对象克隆?</p>\n<p>63.深拷贝和浅拷贝区别是什么?</p>\n<hr>\n<div><p>（六）、Java Web</p>\n<br/>\n</div>\n<p>64.jsp和servlet有什么区别?</p>\n<p>65.jsp有哪些内置对象?作用分别是什么?</p>\n<p>66.说一下jsp的4种作用域?</p>\n<p>67.session和cookie有什么区别?</p>\n<p>68.说一下 session的工作原理?</p>\n<p>69.如果客户端禁止 cookie 能实现session 还能用吗?</p>\n<p>70.spring mvc和struts 的区别是什么?</p>\n<p>71.如何避免 sql注入?</p>\n<p>72.什么是XSS攻击,如何避免?</p>\n<p>73.什么是CSRF攻击，如何避免?</p>\n<hr>\n<div><p>（七）、异常</p>\n<br/>\n</div>\n<p>74.throw和throws 的区别?</p>\n<p>75.final、finally、finalize有什么区别?</p>\n<p>76.try-catch-finally 中哪个部分可以省略?</p>\n<p>77.try-catch-finally中，如果catch 中 return 了, finally还会执行吗?78.常见的异常类有哪些?</p>\n<hr>\n<div><p>（八）、网络</p>\n<br/>\n</div>\n<p>79.http响应码301和302代表的是什么?有什么区别?</p>\n<p>80.forward和redirect的区别?</p>\n<p>81.简述tcp和udp的区别?</p>\n<p>82.tcp为什么要三次握手，两次不行吗?为什么?</p>\n<p>83.说一下 tcp粘包是怎么产生的?</p>\n<p>84.OSl的七层模型都有哪些?</p>\n<p>85.get和post请求有哪些区别?</p>\n<p>86.如何实现跨域?</p>\n<p>87.说一下JSONP 实现原理?</p>\n<hr>\n<div><p>（九）、设计模式</p>\n<br/>\n</div>\n<p>88.说一下你熟悉的设计模式?</p>\n<p>89.简单工厂和抽象工厂有什么区别?</p>\n<hr>\n<div><p>（十）.Spring/Spring MVC</p>\n<br/>\n</div>\n<p>90.为什么要使用spring?</p>\n<p>91.解释一下什么是aop?</p>\n<p>9⒉.解释一下什么是ioc?</p>\n<p>93.spring有哪些主要模块?</p>\n<p>94.spring 常用的注入方式有哪些?</p>\n<p>95.spring 中的 bean是线程安全的吗?</p>\n<p>96.spring支持几种bean的作用域?</p>\n<p>97.spring自动装配bean有哪些方式?</p>\n<p>98.spring事务实现方式有哪些?</p>\n<p>99.说一下spring 的事务隔离?</p>\n<p>100.说一下spring mvc运行流程?</p>\n<p>101.spring mvc有哪些组件?</p>\n<p>102.@RequestMapping 的作用是什么?</p>\n<p>103.@Autowired的作用是什么?</p>\n<hr>\n<div><p>（十一）、Spring Boot/Spring Cloud</p>\n<br/>\n</div>\n<p>104.什么是spring boot?</p>\n<p>105.为什么要用spring boot?</p>\n<p>106.spring boot核心配置文件是什么?</p>\n<p>107.spring boot配置文件有哪几种类型?它们有什么区别?</p>\n<p>108.spring boot有哪些方式可以实现热部署?</p>\n<p>109.jpa和hibernate有什么区别?</p>\n<p>110.什么是 spring cloud?</p>\n<p>111.spring cloud 断路器的作用是什么?</p>\n<p>112.spring cloud的核心组件有哪些?</p>\n<hr>\n<div><p>（十二）、Hibernate</p>\n<br/>\n</div>\n<p>113.为什么要使用hibernate?</p>\n<p>114.什么是 ORM框架?</p>\n<p>115.hibernate 中如何在控制台查看打印的sql语句?</p>\n<p>116.hibernate有几种查询方式?</p>\n<p>117.hibernate 实体类可以被定义为final 吗?</p>\n<p>118.在hibernate中使用Integer和int做映射有什么区别?</p>\n<p>119.hibernate是如何工作的?</p>\n<p>120.get()和load()的区别?</p>\n<p>121.说一下 hibernate 的缓存机制?</p>\n<p>122.hibernate对象有哪些状态?</p>\n<p>123.在 hibernate 中 getCurrentSession和openSession的区别是什么?</p>\n<p>124.hibernate 实体类必须要有无参构造函数吗?为什么?</p>\n<hr>\n<div><p>（十三）、Mybatis</p>\n<br/>\n</div>\n<p>125.mybatis 中#{和$0的区别是什么?</p>\n<p>126.mybatis有几种分页方式?</p>\n<p>127.RowBounds是一次性查询全部结果吗?为什么?</p>\n<p>128.mybatis逻辑分页和物理分页的区别是什么?</p>\n<p>129.mybatis 是否支持延迟加载?延迟加载的原理是什么?</p>\n<p>130.说一下mybatis的一级缓存和二级缓存?</p>\n<p>131.mybatis 和 hibernate的区别有哪些?</p>\n<p>132.mybatis有哪些执行器(Executor) ?</p>\n<p>133.mybatis分页插件的实现原理是什么?</p>\n<p>134.mybatis 如何编写一个自定义插件?</p>\n<hr>\n<div><p>（十四）、RabbitMQ</p>\n<br/>\n</div>\n<p>135.rabbitmq的使用场景有哪些?</p>\n<p>136.rabbitmq有哪些重要的角色?</p>\n<p>137.rabbitmq有哪些重要的组件?</p>\n<p>138.rabbitmq中 vhost的作用是什么?</p>\n<p>139.rabbitmq的消息是怎么发送的?</p>\n<p>140.rabbitmq怎么保证消息的稳定性?</p>\n<p>141.rabbitmq怎么避免消息丢失?</p>\n<p>142.要保证消息持久化成功的条件有哪些?</p>\n<p>143.rabbitmq持久化有什么缺点?</p>\n<p>144.rabbitmq有几种广播类型?</p>\n<p>145.rabbitmq怎么实现延迟消息队列?</p>\n<p>146.rabbitmq集群有什么用?</p>\n<p>147.rabbitmq节点的类型有哪些?</p>\n<p>148.rabbitmq集群搭建需要注意哪些问题?</p>\n<p>149.rabbitmq每个节点是其他节点的完整拷贝吗?为什么?</p>\n<p>150.rabbitmq集群中唯—一个磁盘节点崩溃了会发生什么情况?</p>\n<hr>\n<div><p>（十五）、Kafka</p>\n<br/>\n</div>\n<p>152.kafka可以脱离zookeeper单独使用吗?为什么?</p>\n<p>153.kafka有几种数据保留的策略?</p>\n<p>154.kafka同时设置了7天和10G清除数据，到第五天的时候消息达到了10G，这个时候 kafka将如何处理?</p>\n<p>155.什么情况会导致kafka运行变慢?</p>\n<p>156.使用kafka集群需要注意什么?</p>\n<hr>\n<div><p>（十六）、Zookeeper</p>\n<br/>\n</div>\n<p>157.zookeeper是什么?</p>\n<p>158.zookeeper都有哪些功能?</p>\n<p>159.zookeeper有几种部署模式?</p>\n<p>160.zookeeper怎么保证主从节点的状态同步?</p>\n<p>161.集群中为什么要有主节点?</p>\n<p>162.集群中有3台服务器，其中一个节点宕机，这个时候zookeeper还可以使用吗?</p>\n<p>163.说一下zookeeper的通知机制?</p>\n<hr>\n<div><p>（十七）.MySQL</p>\n<br/>\n</div>\n<p>164.数据库的三范式是什么?</p>\n<p>165.一张自增表里面总共有7条数据，删除了最后⒉条数据，重启 mysql数据库，又插入了一条数据，此时id是几?</p>\n<p>166.如何获取当前数据库版本?</p>\n<p>167.说一下ACID是什么?</p>\n<p>168.char和varchar 的区别是什么?</p>\n<p>169.float和double的区别是什么?</p>\n<p>170.mysql 的内连接、左连接、右连接有什么区别?</p>\n<p>171.mysql索引是怎么实现的?</p>\n<p>172.怎么验证 mysql的索引是否满足需求?</p>\n<p>173.说一下数据库的事务隔离?</p>\n<p>174.说一下mysql常用的引擎?</p>\n<p>175.说一下mysql的行锁和表锁?</p>\n<p>176.说一下乐观锁和悲观锁?</p>\n<p>177.mysql问题排查都有哪些手段?</p>\n<p>178.如何做mysql的性能优化?</p>\n<hr>\n<div><p>（十八）、Redis</p>\n<br/>\n</div>\n<p>179.redis是什么?都有哪些使用场景?</p>\n<p>180.redis有哪些功能?</p>\n<p>181.redis和 memecache有什么区别?</p>\n<p>182.redis为什么是单线程的?</p>\n<p>183.什么是缓存穿透?怎么解决?</p>\n<p>184.redis支持的数据类型有哪些?</p>\n<p>185.redis支持的java客户端都有哪些?</p>\n<p>186.jedis和redisson有哪些区别?</p>\n<p>187.怎么保证缓存和数据库数据的一致性?</p>\n<p>188.redis持久化有几种方式?</p>\n<p>189.redis 怎么实现分布式锁?</p>\n<p>190.redis分布式锁有什么缺陷?</p>\n<p>191.redis如何做内存优化?</p>\n<p>192.redis淘汰策略有哪些?</p>\n<p>193.redis 常见的性能问题有哪些?该如何解决?</p>\n<hr>\n<div><p>（十九）、JVM</p>\n<br/>\n</div>\n<p>194.说一下 jvm的主要组成部分?及其作用?</p>\n<p>195.说一下 jvm运行时数据区?</p>\n<p>196.说一下堆栈的区别?</p>\n<p>197.队列和栈是什么?有什么区别?</p>\n<p>198.什么是双亲委派模型?</p>\n<p>199.说一下类加载的执行过程?</p>\n<p>200.怎么判断对象是否可以被回收?</p>\n<p>201.java中都有哪些引用类型?</p>\n<p>202.说一下 jvm有哪些垃圾回收算法?</p>\n<p>203.说一下 jvm有哪些垃圾回收器?</p>\n<p>204.详细介绍一下 CMS垃圾回收器?</p>\n<p>205.新生代垃圾回收器和老生代垃圾回收器都有哪些?有什么区别?</p>\n<p>206.简述分代垃圾回收器是怎么工作的?</p>\n<p>207.说一下jvm调优的工具?</p>\n<p>208.常用的jvm调优的参数都有哪些?</p>\n",
      "date_modified": "2021-02-07T05:08:56.000Z",
      "authors": [
        {
          "name": "南辞"
        }
      ],
      "tags": []
    },
    {
      "title": "模块01-Java基础",
      "url": "http://qiqi.dreamagain.top/interview/Java208/%E6%A8%A1%E5%9D%9701%E2%80%94Java%E5%9F%BA%E7%A1%80/",
      "id": "http://qiqi.dreamagain.top/interview/Java208/%E6%A8%A1%E5%9D%9701%E2%80%94Java%E5%9F%BA%E7%A1%80/",
      "content_html": "<h2 id=\"问题\"> 问题：</h2>\n<p>1.JDK和JRE有什么区别?</p>\n<p>2.==和equals的区别是什么?</p>\n<p>3.两个对象的 hashCode()相同，则equals()也一定为true，对吗?</p>\n<p>4.final在java中有什么作用?</p>\n<p>5.java中的 Math.round(-1.5)等于多少?</p>\n<p>6.String 属于基础的数据类型吗?</p>\n<p>7.java 中操作字符串都有哪些类?它们之间有什么区别?</p>\n<p>8.String str=&quot;i&quot;与String str=new String(&quot;i&quot;)一样吗?</p>\n<p>9.如何将字符串反转?</p>\n<p>10.String类的常用方法都有那些?</p>\n<p>11.抽象类必须要有抽象方法吗?</p>\n<p>12.普通类和抽象类有哪些区别?</p>\n<p>13.抽象类能使用final 修饰吗?</p>\n<p>14.接口和抽象类有什么区别?</p>\n<ol start=\"15\">\n<li>java中IO流分为几种?</li>\n</ol>\n<p>16.BIO、NIO、AIO有什么区别</p>\n<p>17.Files的常用方法有哪些？</p>\n<h2 id=\"答案\"> 答案：</h2>\n<blockquote>\n<h3 id=\"_1-jdk和jre有什么区别\"> 1.JDK和JRE有什么区别?</h3>\n</blockquote>\n<ul>\n<li>JDK：Java Development Kit 的简称，java 开发工具包，提供了 java 的开发环境和运行环境。</li>\n<li>JRE：Java Runtime Environment 的简称，java 运行环境，为 java 的运行提供了所需环境。</li>\n</ul>\n<p>具体来说 JDK 其实包含了 JRE，同时还包含了编译 java 源码的编译器 javac，还包含了很多 java 程序调试和分析的工具。</p>\n<p>简单来说：如果你需要运行 java 程序，只需安装 JRE 就可以了，如果你需要编写 java 程序，需要安装 JDK。</p>\n<blockquote>\n<h3 id=\"_2-和equals的区别是什么\"> 2.==和equals的区别是什么?</h3>\n</blockquote>\n<p><strong>① == 解读</strong></p>\n<p>对于基本类型和引用类型 == 的作用效果是不同的，如下所示：</p>\n<ul>\n<li>基本类型：比较的是值是否相同；</li>\n<li>引用类型：比较的是引用是否相同；</li>\n</ul>\n<p>代码示例：</p>\n<div><pre><code><span>String</span> x <span>=</span> <span>\"string\"</span><span>;</span>\n<span>String</span> y <span>=</span> <span>\"string\"</span><span>;</span>\n<span>String</span> z <span>=</span> <span>new</span> <span>String</span><span>(</span><span>\"string\"</span><span>)</span><span>;</span>\n<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>x<span>==</span>y<span>)</span><span>;</span> <span>// true</span>\n<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>x<span>==</span>z<span>)</span><span>;</span> <span>// false</span>\n<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>x<span>.</span><span>equals</span><span>(</span>y<span>)</span><span>)</span><span>;</span> <span>// true</span>\n<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>x<span>.</span><span>equals</span><span>(</span>z<span>)</span><span>)</span><span>;</span> <span>// true</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>代码解读：因为 x 和 y 指向的是同一个引用，所以 == 也是 true，而 new String()方法则重新<strong>在堆区</strong>中开辟了内存空间，所以 == 结果为 false，而 equals 比较的一直是值，所以结果都为 true。</p>\n<p><strong>② equals 解读</strong></p>\n<p>equals 本质上就是 ==，只不过 String 和 Integer 等重写了 equals 方法，把它变成了值比较。看下面的代码就明白了。</p>\n<p>首先来看默认情况下 equals 比较一个有相同值的对象，代码如下：</p>\n<div><pre><code><span>class</span> <span>Cat</span> <span>{</span>\n    <span>public</span> <span>Cat</span><span>(</span><span>String</span> name<span>)</span> <span>{</span>\n        <span>this</span><span>.</span>name <span>=</span> name<span>;</span>\n    <span>}</span>\n\n    <span>private</span> <span>String</span> name<span>;</span>\n\n    <span>public</span> <span>String</span> <span>getName</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> name<span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>void</span> <span>setName</span><span>(</span><span>String</span> name<span>)</span> <span>{</span>\n        <span>this</span><span>.</span>name <span>=</span> name<span>;</span>\n    <span>}</span>\n<span>}</span>\n\n<span>Cat</span> c1 <span>=</span> <span>new</span> <span>Cat</span><span>(</span><span>\"王磊\"</span><span>)</span><span>;</span>\n<span>Cat</span> c2 <span>=</span> <span>new</span> <span>Cat</span><span>(</span><span>\"王磊\"</span><span>)</span><span>;</span>\n<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>c1<span>.</span><span>equals</span><span>(</span>c2<span>)</span><span>)</span><span>;</span> <span>// false</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><p>输出结果出乎我们的意料，竟然是 false？这是怎么回事，看了 equals 源码就知道了，源码如下：</p>\n<div><pre><code><span>public</span> <span>boolean</span> <span>equals</span><span>(</span><span>Object</span> obj<span>)</span> <span>{</span>\n    <span>return</span> <span>(</span><span>this</span> <span>==</span> obj<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>原来 equals 本质上就是 ==。</p>\n<p>那问题来了，<strong>两个相同值的 String 对象，为什么返回的是 true</strong>？代码如下：</p>\n<div><pre><code><span>String</span> s1 <span>=</span> <span>new</span> <span>String</span><span>(</span><span>\"老王\"</span><span>)</span><span>;</span>\n<span>String</span> s2 <span>=</span> <span>new</span> <span>String</span><span>(</span><span>\"老王\"</span><span>)</span><span>;</span>\n<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>s1<span>.</span><span>equals</span><span>(</span>s2<span>)</span><span>)</span><span>;</span> <span>// true</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>同样的，当我们进入 String 的 equals 方法，找到了答案，代码如下：</p>\n<div><pre><code><span>public</span> <span>boolean</span> <span>equals</span><span>(</span><span>Object</span> anObject<span>)</span> <span>{</span>\n    <span>//判断是否是同一个对象</span>\n    <span>if</span> <span>(</span><span>this</span> <span>==</span> anObject<span>)</span> <span>{</span>\n        <span>return</span> <span>true</span><span>;</span>\n    <span>}</span>\n    <span>//不是同一个对象才进行值比较</span>\n    <span>//判断是不是String类型</span>\n    <span>if</span> <span>(</span>anObject <span>instanceof</span> <span>String</span><span>)</span> <span>{</span>\n        <span>String</span> anotherString <span>=</span> <span>(</span><span>String</span><span>)</span>anObject<span>;</span>\n        <span>int</span> n <span>=</span> value<span>.</span>length<span>;</span>\n        <span>//字符串长度比较</span>\n        <span>if</span> <span>(</span>n <span>==</span> anotherString<span>.</span>value<span>.</span>length<span>)</span> <span>{</span>\n            <span>char</span> v1<span>[</span><span>]</span> <span>=</span> value<span>;</span>\n            <span>char</span> v2<span>[</span><span>]</span> <span>=</span> anotherString<span>.</span>value<span>;</span>\n            <span>int</span> i <span>=</span> <span>0</span><span>;</span>\n            <span>//两个字符数组一一进行字符比较</span>\n            <span>while</span> <span>(</span>n<span>--</span> <span>!=</span> <span>0</span><span>)</span> <span>{</span>\n                <span>if</span> <span>(</span>v1<span>[</span>i<span>]</span> <span>!=</span> v2<span>[</span>i<span>]</span><span>)</span>\n                    <span>return</span> <span>false</span><span>;</span>\n                i<span>++</span><span>;</span>\n            <span>}</span>\n            <span>return</span> <span>true</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n    <span>//不是String类型的比较直接返回false</span>\n    <span>return</span> <span>false</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div><p>原来是 <strong>String 重写了 Object 的 equals 方法</strong>，把<strong>引用比较改成了值比较</strong>。</p>\n<p><strong>总结</strong> ：</p>\n<ul>\n<li>\n<p>== 对于基本类型来说是值比较，对于引用类型来说是比较的是引用；</p>\n</li>\n<li>\n<p>而 equals 默认情况下是引用比较，只是很多类重新了 equals 方法，比如 String、Integer 等把它变成了值比较，所以一般情况下 equals 比较的是值是否相等。</p>\n</li>\n</ul>\n<blockquote>\n<h3 id=\"_3-两个对象的-hashcode-相同-则equals-也一定为true-对吗\"> 3.两个对象的 hashCode()相同，则equals()也一定为true，对吗?</h3>\n</blockquote>\n<p>不对，两个对象的 hashCode()相同，equals()不一定 true。</p>\n<p>代码示例：</p>\n<div><pre><code>String str1 = &quot;通话&quot;;\nString str2 = &quot;重地&quot;;\nSystem.out.println(String.format(&quot;str1：%d | str2：%d&quot;, str1.hashCode(),str2.hashCode()));\nSystem.out.println(str1.equals(str2));\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>执行的结果：</p>\n<p>str1：1179395 | str2：1179395</p>\n<p>false</p>\n<p>代码解读：很显然“通话”和“重地”的 hashCode() 相同，然而 equals() 则为 false，因为在散列表中，hashCode()相等即两个键值对的哈</p>\n<p>希值相等，然而哈希值相等，并不一定能得出键值对相等。</p>\n<blockquote>\n<h3 id=\"_4-final在java中有什么作用\"> 4.final在java中有什么作用?</h3>\n</blockquote>\n<ul>\n<li>\n<p>final 修饰的类叫最终类，该类不能被继承。</p>\n</li>\n<li>\n<p>final 修饰的方法不能被重写。</p>\n</li>\n<li>\n<p>final 修饰的变量叫常量，常量必须初始化，初始化之后值就不能被修改。</p>\n</li>\n</ul>\n<blockquote>\n<h3 id=\"_5-java中的-math-round-1-5-等于多少\"> 5.java中的 Math.round(-1.5)等于多少?</h3>\n</blockquote>\n<p>等于 -1，因为在数轴上取值时，中间值（0.5）向右取整，所以正 0.5 是往上取整，负 0.5 是直接舍弃。</p>\n<blockquote>\n<h3 id=\"_6-string-属于基础的数据类型吗\"> 6.String 属于基础的数据类型吗?</h3>\n</blockquote>\n<p>String 不属于基础类型，基础类型有 8 种：byte、short、int、long、float、double、boolean、char，而 String 属于对象。</p>\n<p>这8种基本数据类型对应的存储字节数：1  2  4  8  4  8  1  2</p>\n<blockquote>\n<h3 id=\"_7-java-中操作字符串都有哪些类-它们之间有什么区别\"> 7.java 中操作字符串都有哪些类?它们之间有什么区别?</h3>\n</blockquote>\n<p>操作字符串的类有：String、StringBuffer、StringBuilder。</p>\n<p><strong>String 和 StringBuffer、StringBuilder 的区别:</strong></p>\n<ul>\n<li>\n<p>String 声明的是不可变的对象，每次操作都会生成新的 String 对象，然后将指针指向新的 String 对象，</p>\n</li>\n<li>\n<p>而 StringBuffer、StringBuilder 可以在原有对象的基础上进行操作，所以在经常改变字符串内容的情况下最好不要使用 String。</p>\n</li>\n</ul>\n<p><strong>StringBuffer 和 StringBuilder 最大的区别：</strong></p>\n<ul>\n<li>\n<p>StringBuffer 是线程安全的，而 StringBuilder 是非线程安全的，</p>\n</li>\n<li>\n<p>但 StringBuilder 的性能却高于 StringBuffer，所以在单线程环境下推荐使用 StringBuilder，多线程环境下推荐使用 StringBuffer。</p>\n</li>\n</ul>\n<blockquote>\n<h3 id=\"_8-string-str-i-与string-str-new-string-i-一样吗\"> 8.String str=&quot;i&quot;与String str=new String(&quot;i&quot;)一样吗?</h3>\n</blockquote>\n<p>不一样，因为内存的分配方式不一样。</p>\n<ul>\n<li>\n<p>String str=&quot;i&quot;的方式，java 虚拟机会将其分配到常量池中；</p>\n</li>\n<li>\n<p>而 String str=new String(&quot;i&quot;) 则会被分到堆内存中。</p>\n</li>\n</ul>\n<blockquote>\n<h3 id=\"_9-如何将字符串反转\"> 9.如何将字符串反转?</h3>\n</blockquote>\n<p>使用 StringBuilder 或者 stringBuffer 的 reverse() 方法。当然也可以使用字符数组进行逆置</p>\n<p>示例代码：</p>\n<div><pre><code><span>// StringBuffer reverse</span>\n<span>StringBuffer</span> stringBuffer <span>=</span> <span>new</span> <span>StringBuffer</span><span>(</span><span>)</span><span>;</span>\nstringBuffer<span>.</span><span>append</span><span>(</span><span>\"abcdefg\"</span><span>)</span><span>;</span>\n<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>stringBuffer<span>.</span><span>reverse</span><span>(</span><span>)</span><span>)</span><span>;</span> <span>// gfedcba</span>\n<span>// StringBuilder reverse</span>\n<span>StringBuilder</span> stringBuilder <span>=</span> <span>new</span> <span>StringBuilder</span><span>(</span><span>)</span><span>;</span>\nstringBuilder<span>.</span><span>append</span><span>(</span><span>\"abcdefg\"</span><span>)</span><span>;</span>\n<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>stringBuilder<span>.</span><span>reverse</span><span>(</span><span>)</span><span>)</span><span>;</span> <span>// gfedcba</span>\n<span>// 字符数组</span>\n<span>public</span> <span>static</span> <span>String</span> <span>reverse</span><span>(</span><span>String</span> str<span>)</span><span>{</span>\n        <span>if</span> <span>(</span>str<span>==</span><span>null</span><span>||</span>str<span>.</span><span>length</span><span>(</span><span>)</span><span>==</span><span>0</span><span>||</span>str<span>.</span><span>length</span><span>(</span><span>)</span><span>==</span><span>1</span><span>)</span><span>{</span>\n            <span>return</span> str<span>;</span>\n        <span>}</span>\n        <span>char</span><span>[</span><span>]</span> chars <span>=</span> str<span>.</span><span>toCharArray</span><span>(</span><span>)</span><span>;</span>\n        <span>int</span> i <span>=</span> str<span>.</span><span>length</span><span>(</span><span>)</span><span>;</span>\n        <span>int</span> j <span>=</span> <span>0</span><span>;</span>\n        <span>while</span> <span>(</span>j<span>&lt;</span>i<span>)</span><span>{</span>\n            <span>char</span> tmp <span>=</span> chars<span>[</span>i<span>-</span><span>1</span><span>]</span><span>;</span>\n            chars<span>[</span>i<span>-</span><span>1</span><span>]</span> <span>=</span> chars<span>[</span>j<span>]</span><span>;</span>\n            chars<span>[</span>j<span>]</span> <span>=</span> tmp<span>;</span>\n\n            j<span>++</span><span>;</span>\n            i<span>--</span><span>;</span>\n        <span>}</span>\n        str <span>=</span> <span>new</span> <span>String</span><span>(</span>chars<span>)</span><span>;</span>\n         <span>return</span> str<span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div><blockquote>\n<h3 id=\"_10-string类的常用方法都有那些\"> 10.String类的常用方法都有那些?</h3>\n</blockquote>\n<ul>\n<li>\n<p>indexOf()：返回指定字符的索引。</p>\n</li>\n<li>\n<p>charAt()：返回指定索引处的字符。</p>\n</li>\n<li>\n<p>replace()：字符串替换。</p>\n</li>\n<li>\n<p>trim()：去除字符串两端空白。</p>\n</li>\n<li>\n<p>split()：分割字符串，返回一个分割后的字符串数组。</p>\n</li>\n<li>\n<p>getBytes()：返回字符串的 byte 类型数组。</p>\n</li>\n<li>\n<p>length()：返回字符串长度。</p>\n</li>\n<li>\n<p>toLowerCase()：将字符串转成小写字母。</p>\n</li>\n<li>\n<p>toUpperCase()：将字符串转成大写字符。</p>\n</li>\n<li>\n<p>toCharArray()：转为字符数组</p>\n</li>\n<li>\n<p>substring()：截取字符串。</p>\n</li>\n<li>\n<p>equals()：字符串比较。</p>\n</li>\n</ul>\n<blockquote>\n<h3 id=\"_11-抽象类必须要有抽象方法吗\"> 11.抽象类必须要有抽象方法吗?</h3>\n</blockquote>\n<p>不需要，抽象类不一定非要有抽象方法。</p>\n<p>示例代码：</p>\n<div><pre><code><span>abstract</span> <span>class</span> <span>Cat</span> <span>{</span>\n    <span>public</span> <span>static</span> <span>void</span> <span>sayHi</span><span>(</span><span>)</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"hi~\"</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>上面代码，抽象类并没有抽象方法但完全可以正常运行。</p>\n<blockquote>\n<h3 id=\"_12-普通类和抽象类有哪些区别\"> 12.普通类和抽象类有哪些区别?</h3>\n</blockquote>\n<ul>\n<li>普通类不能包含抽象方法，抽象类可以包含抽象方法。</li>\n<li>抽象类不能直接实例化，普通类可以直接实例化。</li>\n</ul>\n<blockquote>\n<h3 id=\"_13-抽象类能使用final-修饰吗\"> 13.抽象类能使用final 修饰吗?</h3>\n</blockquote>\n<p>不能，定义抽象类就是让其他类继承的，如果定义为 final 该类就不能被继承，这样彼此就会产生矛盾，所以 final 不能修饰抽象类，</p>\n<p>如果在抽象类上加final关键字，编辑器也会提示错误信息：</p>\n<blockquote>\n<h3 id=\"_14-接口和抽象类有什么区别\"> 14.接口和抽象类有什么区别?</h3>\n</blockquote>\n<ul>\n<li>实现：抽象类的子类使用 extends 来继承；接口必须使用 implements 来实现接口。</li>\n<li>构造函数：抽象类可以有构造函数；接口不能有。</li>\n<li>main 方法：抽象类可以有 main 方法，并且我们能运行它；接口不能有 main 方法。</li>\n<li>实现数量：类可以实现很多个接口；但是只能继承一个抽象类。</li>\n<li>访问修饰符：接口中的方法默认使用 public 修饰；抽象类中的方法可以是任意访问修饰符。</li>\n</ul>\n<blockquote>\n<h3 id=\"_15-java中io流分为几种\"> 15.java中IO流分为几种?</h3>\n</blockquote>\n<p>按功能来分：输入流（input）、输出流（output）。</p>\n<p>按类型来分：字节流和字符流。</p>\n<p>字节流和字符流的区别是：字节流按 8 位传输以字节为单位输入输出数据，字符流按 16 位传输以字符为单位输入输出数据。</p>\n<blockquote>\n<h3 id=\"_16-bio、nio、aio有什么区别\"> 16.BIO、NIO、AIO有什么区别</h3>\n</blockquote>\n<ul>\n<li>BIO：Block IO 同步阻塞式 IO，就是我们平常使用的传统 IO，它的特点是模式简单使用方便，并发处理能力低。</li>\n<li>NIO：New IO 同步非阻塞 IO，是传统 IO 的升级，客户端和服务器端通过 Channel（通道）通讯，实现了多路复用。</li>\n<li>AIO：Asynchronous IO 是 NIO 的升级，也叫 NIO2，实现了异步非堵塞 IO ，异步 IO 的操作基于<strong>事件和回调机制</strong>。</li>\n</ul>\n<blockquote>\n<h3 id=\"_17-files的常用方法有哪些\"> 17.Files的常用方法有哪些？</h3>\n</blockquote>\n<ul>\n<li>Files.exists()：检测文件路径是否存在。</li>\n<li>Files.createFile()：创建文件。</li>\n<li>Files.createDirectory()：创建文件夹。</li>\n<li>Files.delete()：删除一个文件或目录。</li>\n<li>Files.copy()：复制文件。</li>\n<li>Files.move()：移动文件。</li>\n<li>Files.size()：查看文件个数。</li>\n<li>Files.read()：读取文件。</li>\n<li>Files.write()：写入文件。</li>\n</ul>\n",
      "date_modified": "2021-02-08T17:34:42.000Z",
      "authors": [
        {
          "name": "南辞"
        }
      ],
      "tags": []
    },
    {
      "title": "模块02-Java集合（容器）",
      "url": "http://qiqi.dreamagain.top/interview/Java208/%E6%A8%A1%E5%9D%9702%E2%80%94Java%E9%9B%86%E5%90%88/",
      "id": "http://qiqi.dreamagain.top/interview/Java208/%E6%A8%A1%E5%9D%9702%E2%80%94Java%E9%9B%86%E5%90%88/",
      "content_html": "<h2 id=\"问题\"> 问题：</h2>\n<p>18.java容器都有哪些?</p>\n<p>19.Collection和Collections有什么区别?</p>\n<p>20.List、Set、Map 之间的区别是什么?</p>\n<p>21.HashMap和Hashtable有什么区别?</p>\n<p>22.如何决定使用HashMap还是TreeMap?</p>\n<p>23.说一下HashMap 的实现原理?</p>\n<p>24.说一下 HashSet 的实现原理?</p>\n<p>25.ArrayList和LinkedList的区别是什么?</p>\n<p>26.如何实现数组和List 之间的转换?</p>\n<p>27.ArrayList和Vector 的区别是什么?</p>\n<p>28.Array和ArrayList有何区别?</p>\n<p>29.在 Queue 中 poll()和remove()有什么区别?</p>\n<p>30.哪些集合类是线程安全的?</p>\n<p>31.迭代器lterator 是什么?</p>\n<p>32.lterator怎么使用?有什么特点?</p>\n<p>33.lterator和Listlterator有什么区别?</p>\n<p>34.怎么确保一个集合不能被修改？</p>\n<h2 id=\"答案\"> 答案：</h2>\n<h3 id=\"_18-java容器都有哪些\"> 18.java容器都有哪些?</h3>\n<p><img src=\"./assets/java-03.png\" alt=\"\"></p>\n<h3 id=\"_19-collection和collections有什么区别\"> 19.Collection和Collections有什么区别?</h3>\n<ul>\n<li>java.util.Collection 是一个集合接口（集合类的一个顶级接口）。它提供了对集合对象进行基本操作的通用接口方法。Collection接口在Java 类库中有很多具体的实现。Collection接口的意义是为各种具体的集合提供了最大化的统一操作方式，其直接继承接口有List与Set。</li>\n<li>Collections则是集合类的一个工具类/帮助类，其中提供了一系列静态方法，用于对集合中元素进行排序、搜索以及线程安全等各种操作。</li>\n</ul>\n<h3 id=\"_20-list、set、map-之间的区别是什么\"> 20.List、Set、Map 之间的区别是什么?</h3>\n<img src=\"./assets/java-04.png\" style=\"zoom:80%;\" />\n<h3 id=\"_21-hashmap和hashtable有什么区别\"> 21.HashMap和Hashtable有什么区别?</h3>\n<ul>\n<li>hashMap去掉了Hashtable 的contains方法，但是加上了containsValue（）和containsKey（）方法。</li>\n<li>Hashtable同步的，而HashMap是非同步的，效率上比Hashtable要高。</li>\n<li>hashMap允许空键值，而Hashtable不允许。</li>\n</ul>\n<h3 id=\"_22-如何决定使用hashmap还是treemap\"> 22.如何决定使用HashMap还是TreeMap?</h3>\n<p>对于在Map中插入、删除和定位元素这类操作，HashMap是最好的选择。</p>\n<p>然而，假如你需要对一个有序的key集合进行遍历，TreeMap是更好的选择。基于你的collection的大小，也许向HashMap中添加元素</p>\n<p>会更快，将map换为TreeMap进行有序key的遍历。</p>\n<h3 id=\"_23-说一下hashmap-的实现原理\"> 23.说一下HashMap 的实现原理?</h3>\n<p><strong>HashMap概述：</strong> HashMap是基于哈希表的Map接口的非同步实现。此实现提供所有可选的映射操作，并允许使用null值和null键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。</p>\n<p><strong>HashMap的数据结构：</strong> 在java编程语言中，最基本的结构就是两种，一个是数组，另外一个是模拟指针（引用），所有的数据结构都可以用这两个基本结构来构造的，HashMap也不例外。HashMap实际上是一个“链表散列”的数据结构，即数组和链表的结合体。</p>\n<p>当我们往HashMap中put元素时,首先根据key的hashcode重新计算hash值,根据hash值得到这个元素在数组中的位置(下标),如果该数组在该位置上已经存放了其他元素,那么在这个位置上的元素将以链表的形式存放,新加入的放在链头,最先加入的放入链尾.如果数组中该位置没有元素,就直接将该元素放到数组的该位置上。</p>\n<p>需要注意Jdk 1.8中对HashMap的实现做了优化,当链表中的节点数据超过<strong>八个</strong>之后,该链表会转为<strong>红黑树</strong>来提高查询效率,从原来的O(n)到O(logn)</p>\n<h3 id=\"_24-说一下-hashset-的实现原理\"> 24.说一下 HashSet 的实现原理?</h3>\n<ul>\n<li>\n<p>HashSet底层由HashMap实现</p>\n</li>\n<li>\n<p>HashSet的值存放于HashMap的key上</p>\n</li>\n<li>\n<p>HashMap的value统一为PRESENT</p>\n</li>\n</ul>\n<h3 id=\"_25-arraylist和linkedlist的区别是什么\"> 25.ArrayList和LinkedList的区别是什么?</h3>\n<p>最明显的区别是 ArrrayList底层的数据结构是数组，支持随机访问，而 LinkedList 的底层数据结构是双向循环链表，不支持随机访问。</p>\n<p>使用下标访问一个元素，ArrayList 的时间复杂度是 O(1)，而 LinkedList 是 O(n)。</p>\n<h3 id=\"_26-如何实现数组和list-之间的转换\"> 26.如何实现数组和List 之间的转换?</h3>\n<ul>\n<li>\n<p>List转换成为数组：调用ArrayList的toArray方法。</p>\n</li>\n<li>\n<p>数组转换成为List：调用Arrays的asList方法。</p>\n</li>\n</ul>\n<h3 id=\"_27-arraylist和vector-的区别是什么\"> 27.ArrayList和Vector 的区别是什么?</h3>\n<ul>\n<li>\n<p>Vector是同步的，而ArrayList不是。然而，如果你寻求在迭代的时候对列表进行改变，你应该使用CopyOnWriteArrayList。</p>\n</li>\n<li>\n<p>ArrayList比Vector快，Vecto它因为有同步，不会过载。 ArrayList在多线程情况下可能会出现ConcurrentModificationException。</p>\n</li>\n<li>\n<p>ArrayList更加通用，因为我们可以使用Collections工具类轻易地获取同步列表和只读列表。</p>\n</li>\n</ul>\n<h3 id=\"_28-array和arraylist有何区别\"> 28.Array和ArrayList有何区别?</h3>\n<ul>\n<li>\n<p>Array可以容纳基本类型和对象，而ArrayList只能容纳对象。</p>\n</li>\n<li>\n<p>Array是指定大小的，而ArrayList大小是固定的。</p>\n</li>\n<li>\n<p>Array没有提供ArrayList那么多功能，比如addAll、removeAll和iterator等。</p>\n</li>\n</ul>\n<h3 id=\"_29-在-queue-中-poll-和remove-有什么区别\"> 29.在 Queue 中 poll()和remove()有什么区别?</h3>\n<p>poll() 和 remove() 都是从队列中取出一个元素，但是 poll() 在获取元素失败的时候会返回空，但是 remove() 失败的时候会抛出异常。</p>\n<h3 id=\"_30-哪些集合类是线程安全的\"> 30.哪些集合类是线程安全的?</h3>\n<ul>\n<li>\n<p>Vector：就比ArrayList多了个同步化机制（线程安全），因为效率较低，现在已经不太建议使用。在web应用中，特别是前台页面，往往效率（页面响应速度）是优先考虑的。</p>\n</li>\n<li>\n<p>statck：堆栈类，先进后出。</p>\n</li>\n<li>\n<p>Hashtable：就比HashMap多了个线程安全。</p>\n</li>\n<li>\n<p>Enumeration：枚举，相当于迭代器。</p>\n</li>\n</ul>\n<h3 id=\"_31-迭代器lterator-是什么\"> 31.迭代器lterator 是什么?</h3>\n<p>迭代器是一种设计模式，它是一个对象，它可以遍历并选择序列中的对象，而开发人员不需要了解该序列的底层结构。迭代器通常被称</p>\n<p>为“轻量级”对象，因为创建它的代价小。</p>\n<h3 id=\"_32-lterator怎么使用-有什么特点\"> 32.lterator怎么使用?有什么特点?</h3>\n<p>Java中的Iterator功能比较简单，并且只能单向移动：</p>\n<p>(1) 使用方法iterator()要求容器返回一个Iterator。第一次调用Iterator的next()方法时，它返回序列的第一个元素。注意：iterator()方法是java.lang.Iterable接口,被Collection继承。</p>\n<p>(2) 使用next()获得序列中的下一个元素。</p>\n<p>(3) 使用hasNext()检查序列中是否还有元素。</p>\n<p>(4) 使用remove()将迭代器新返回的元素删除。</p>\n<p>Iterator是Java迭代器最简单的实现，为List设计的ListIterator具有更多的功能，它可以从两个方向遍历List，也可以从List中插入和删除元素。</p>\n<h3 id=\"_33-lterator和listlterator有什么区别\"> 33.lterator和Listlterator有什么区别?</h3>\n<ul>\n<li>Iterator可用来遍历Set和List集合，但是ListIterator只能用来遍历List。</li>\n<li>Iterator对集合只能是前向遍历，ListIterator既可以前向也可以后向。</li>\n<li>ListIterator实现了Iterator接口，并包含其他的功能，比如：增加元素，替换元素，获取前一个和后一个元素的索引，等等。</li>\n</ul>\n<h3 id=\"_34-怎么确保一个集合不能被修改\"> 34.怎么确保一个集合不能被修改？</h3>\n<p>可以使用 Collections. unmodifiableCollection(Collection c) 方法来创建一个只读集合，这样改变集合的任何操作都会抛出 Java. lang.</p>\n<p>UnsupportedOperationException 异常。</p>\n<p>示例代码如下：</p>\n<div><pre><code><span>List</span><span><span>&lt;</span><span>String</span><span>></span></span> list <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>\nlist<span>.</span> <span>add</span><span>(</span><span>\"A\"</span><span>)</span><span>;</span>\n<span>Collection</span><span><span>&lt;</span><span>String</span><span>></span></span> unmlist <span>=</span> <span>Collections</span><span>.</span> <span>unmodifiableCollection</span><span>(</span>list<span>)</span><span>;</span>\nunmlist<span>.</span> <span>add</span><span>(</span><span>\"B\"</span><span>)</span><span>;</span> <span>// 运行时此行报错</span>\n<span>System</span><span>.</span> out<span>.</span> <span>println</span><span>(</span>list<span>.</span><span>size</span><span>(</span><span>)</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div>",
      "date_modified": "2021-02-07T05:08:56.000Z",
      "authors": [
        {
          "name": "南辞"
        }
      ],
      "tags": []
    },
    {
      "title": "模块03-Java多线程",
      "url": "http://qiqi.dreamagain.top/interview/Java208/%E6%A8%A1%E5%9D%9703%E2%80%94%E5%A4%9A%E7%BA%BF%E7%A8%8B/",
      "id": "http://qiqi.dreamagain.top/interview/Java208/%E6%A8%A1%E5%9D%9703%E2%80%94%E5%A4%9A%E7%BA%BF%E7%A8%8B/",
      "content_html": "<h2 id=\"问题\"> 问题：</h2>\n<p>35.并行和并发有什么区别?</p>\n<p>36.线程和进程的区别?</p>\n<p>37.守护线程是什么?</p>\n<p>38.创建线程有哪几种方式?</p>\n<p>39.说一下runnable和callable有什么区别?</p>\n<p>40.线程有哪些状态?</p>\n<p>41.sleep()和wait()有什么区别?</p>\n<p>42.notify()和 notifyAll)有什么区别?</p>\n<p>43.线程的run()和start()有什么区别?</p>\n<p>44.创建线程池有哪几种方式?</p>\n<p>45.线程池都有哪些状态?</p>\n<p>46.线程池中 submit()和execute()方法有什么区别?</p>\n<p>47.在java程序中怎么保证多线程的运行安全?</p>\n<p>48.多线程锁的升级原理是什么?</p>\n<p>49.什么是死锁?</p>\n<p>50.怎么防止死锁?</p>\n<p>51.ThreadLocal是什么?有哪些使用场景?</p>\n<p>52.说一下synchronized底层实现原理?</p>\n<p>53.synchronized和volatile 的区别是什么?</p>\n<p>54.synchronized和Lock有什么区别?</p>\n<p>55.synchronized和ReentrantLock区别是什么?</p>\n<p>56.说一下atomic 的原理?</p>\n<h3 id=\"答案\"> 答案：</h3>\n<h3 id=\"_35-并行和并发有什么区别\"> 35.并行和并发有什么区别?</h3>\n<ul>\n<li>并行是指两个或者多个事件在同一时刻发生；而并发是指两个或多个事件在同一时间间隔发生。</li>\n<li>并行是在不同实体上的多个事件，并发是在同一实体上的多个事件。</li>\n<li>在一台处理器上“同时”处理多个任务；在多台处理器上同时处理多个任务。如hadoop分布式集群。</li>\n</ul>\n<p>所以并发编程的目标是充分的利用处理器的每一个核，以达到最高的处理性能。</p>\n<h3 id=\"_36-线程和进程的区别\"> 36.线程和进程的区别?</h3>\n<p>简而言之，进程是程序运行和资源分配的基本单位，一个程序至少有一个进程，一个进程至少有一个线程。</p>\n<p>进程在执行过程中拥有独立的内存单元，而多个线程共享内存资源，减少切换次数，从而效率更高。</p>\n<p>线程是进程的一个实体，是cpu调度和分派的基本单位，是比程序更小的能独立运行的基本单位。</p>\n<p>同一进程中的多个线程之间可以并发执行。</p>\n<h3 id=\"_37-守护线程是什么\"> 37.守护线程是什么?</h3>\n<p>守护线程（即daemon thread），是个服务线程，准确地来说就是服务其他的线程。</p>\n<h3 id=\"_38-创建线程有哪几种方式\"> 38.创建线程有哪几种方式?</h3>\n<p>①. 继承Thread类创建线程类</p>\n<ul>\n<li>定义Thread类的子类，并重写该类的run方法，该run方法的方法体就代表了线程要完成的任务。因此把run()方法称为执行体。</li>\n<li>创建Thread子类的实例，即创建了线程对象。</li>\n<li>调用线程对象的start()方法来启动该线程。</li>\n</ul>\n<p>②. 通过Runnable接口创建线程类</p>\n<ul>\n<li>定义runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体同样是该线程的线程执行体。</li>\n<li>创建 Runnable实现类的实例，并依此实例作为Thread的target来创建Thread对象，该Thread对象才是真正的线程对象。</li>\n<li>调用线程对象的start()方法来启动该线程。</li>\n</ul>\n<p>③. 通过Callable和Future创建线程</p>\n<ul>\n<li>创建Callable接口的实现类，并实现call()方法，该call()方法将作为线程执行体，并且有返回值。</li>\n<li>创建Callable实现类的实例，使用FutureTask类来包装Callable对象，该FutureTask对象封装了该Callable对象的call()方法的返回值。</li>\n<li>使用FutureTask对象作为Thread对象的target创建并启动新线程。</li>\n<li>调用FutureTask对象的get()方法来获得子线程执行结束后的返回值。</li>\n</ul>\n<h3 id=\"_39-说一下runnable和callable有什么区别\"> 39.说一下runnable和callable有什么区别?</h3>\n<p>有点深的问题了，也看出一个Java程序员学习知识的广度。</p>\n<ul>\n<li>Runnable接口中的run()方法的返回值是void，它做的事情只是纯粹地去执行run()方法中的代码而已；</li>\n<li>Callable接口中的call()方法是有返回值的，是一个泛型，和Future、FutureTask配合可以用来<strong>获取异步执行的结果</strong>。</li>\n</ul>\n<h3 id=\"_40-线程有哪些状态\"> 40.线程有哪些状态?</h3>\n<p>线程通常都有五种状态，创建、就绪、运行、阻塞和死亡。</p>\n<ul>\n<li>创建状态。在生成线程对象，并没有调用该对象的start方法，这是线程处于创建状态。</li>\n<li>就绪状态。当调用了线程对象的start方法之后，该线程就进入了就绪状态，但是此时线程调度程序还没有把该线程设置为当前线程，此时处于就绪状态。在线程运行之后，从等待或者睡眠中回来之后，也会处于就绪状态。</li>\n<li>运行状态。线程调度程序将处于就绪状态的线程设置为当前线程，此时线程就进入了运行状态，开始运行run函数当中的代码。</li>\n<li>阻塞状态。线程正在运行的时候，被暂停，通常是为了等待某个时间的发生(比如说某项资源就绪)之后再继续运行。sleep,suspend，wait等方法都可以导致线程阻塞。</li>\n<li>死亡状态。如果一个线程的run方法执行结束或者调用stop方法后，该线程就会死亡。对于已经死亡的线程，无法再使用start方法令其进入就绪</li>\n</ul>\n<h3 id=\"_41-sleep-和wait-有什么区别\"> 41.sleep()和wait()有什么区别?</h3>\n<ul>\n<li>\n<p>sleep()：方法是线程类（Thread）的静态方法，让调用线程进入睡眠状态，让出执行机会给其他线程，等到休眠时间结束后，线程进入就绪状态和其他线程一起竞争cpu的执行时间。</p>\n</li>\n<li>\n<p>因为sleep() 是static静态的方法，他不能改变对象的机锁，当一个synchronized块中调用了sleep() 方法，线程虽然进入休眠，但是对象的机锁没有被释放，其他线程依然无法访问这个对象。</p>\n</li>\n<li>\n<p>wait()：wait()是Object类的方法，当一个线程执行到wait方法时，它就进入到一个和该对象相关的等待池，同时释放对象的机锁，使得其他线程能够访问，可以通过notify，notifyAll方法来唤醒等待的线程</p>\n</li>\n</ul>\n<h3 id=\"_42-notify-和-notifyall-有什么区别\"> 42.notify()和 notifyAll)有什么区别?</h3>\n<ul>\n<li>如果线程调用了对象的 wait()方法，那么线程便会处于该对象的等待池中，等待池中的线程不会去竞争该对象的锁。</li>\n<li>当有线程调用了对象的 notifyAll()方法（唤醒所有 wait 线程）或 notify()方法（只随机唤醒一个 wait 线程），被唤醒的的线程便会进入该对象的锁池中，锁池中的线程会去竞争该对象锁。也就是说，调用了notify后只要一个线程会由等待池进入锁池，而notifyAll会将该对象等待池内的所有线程移动到锁池中，等待锁竞争。</li>\n<li>优先级高的线程竞争到对象锁的概率大，假若某线程没有竞争到该对象锁，它还会留在锁池中，唯有线程再次调用 wait()方法，它才会重新回到等待池中。而竞争到对象锁的线程则继续往下执行，直到执行完了 synchronized 代码块，它会释放掉该对象锁，这时锁池中的线程会继续竞争该对象锁。</li>\n</ul>\n<h3 id=\"_43-线程的run-和start-有什么区别\"> 43.线程的run()和start()有什么区别?</h3>\n<ul>\n<li>\n<p>每个线程都是通过某个特定Thread对象所对应的方法run()来完成其操作的，方法run()称为线程体。通过调用Thread类的start()方法来启动一个线程。</p>\n</li>\n<li>\n<p>start()方法来启动一个线程，真正实现了多线程运行。这时无需等待run方法体代码执行完毕，可以直接继续执行下面的代码； 这时此线程是处于就绪状态， 并没有运行。 然后通过此Thread类调用方法run()来完成其运行状态， 这里方法run()称为线程体，它包含了要执行的这个线程的内容， run方法运行结束， 此线程终止。然后CPU再调度其它线程。</p>\n</li>\n<li>\n<p>run()方法是在本线程里的，只是线程里的一个函数,而不是多线程的。 如果直接调用run(),其实就相当于是调用了一个普通函数而已，直接待用run()方法必须等待run()方法执行完毕才能执行下面的代码，所以执行路径还是只有一条，根本就没有线程的特征，所以在多线程执行时要使用start()方法而不是run()方法。</p>\n</li>\n</ul>\n<h3 id=\"_44-创建线程池有哪几种方式\"> 44.创建线程池有哪几种方式?</h3>\n<p><strong>①. newFixedThreadPool(int nThreads)</strong></p>\n<p>创建一个固定长度的线程池，每当提交一个任务就创建一个线程，直到达到线程池的最大数量，这时线程规模将不再变化，当线程发生未预期的错误而结束时，线程池会补充一个新的线程。</p>\n<p><strong>②. newCachedThreadPool()</strong></p>\n<p>创建一个可缓存的线程池，如果线程池的规模超过了处理需求，将自动回收空闲线程，而当需求增加时，则可以自动添加新线程，线程池的规模不存在任何限制。</p>\n<p><strong>③. newSingleThreadExecutor()</strong></p>\n<p>这是一个单线程的Executor，它创建单个工作线程来执行任务，如果这个线程异常结束，会创建一个新的来替代它；它的特点是能确保依照任务在队列中的顺序来串行执行。</p>\n<p><strong>④. newScheduledThreadPool(int corePoolSize)</strong></p>\n<p>创建了一个固定长度的线程池，而且以延迟或定时的方式来执行任务，类似于Timer。</p>\n<h3 id=\"_45-线程池都有哪些状态\"> 45.线程池都有哪些状态?</h3>\n<p>线程池有5种状态：Running、ShutDown、Stop、Tidying、Terminated。</p>\n<p>线程池各个状态切换框架图：</p>\n<p><img src=\"./assets/java-01.png\" alt=\"\"></p>\n<h3 id=\"_46-线程池中-submit-和execute-方法有什么区别\"> 46.线程池中 submit()和execute()方法有什么区别?</h3>\n<ul>\n<li>接收的参数不一样</li>\n<li>submit有返回值，而execute没有</li>\n<li>submit方便Exception处理</li>\n</ul>\n<h3 id=\"_47-在java程序中怎么保证多线程的运行安全\"> 47.在java程序中怎么保证多线程的运行安全?</h3>\n<p>线程安全在三个方面体现：</p>\n<ul>\n<li>原子性：提供互斥访问，同一时刻只能有一个线程对数据进行操作，（atomic,synchronized）；</li>\n<li>可见性：一个线程对主内存的修改可以及时地被其他线程看到，（synchronized,volatile）；</li>\n<li>有序性：一个线程观察其他线程中的指令执行顺序，由于指令重排序，该观察结果一般杂乱无序，（happens-before原则）。</li>\n</ul>\n<h3 id=\"_48-多线程锁的升级原理是什么\"> 48.多线程锁的升级原理是什么?</h3>\n<p>在Java中，锁共有4种状态，级别从低到高依次为：无状态锁，偏向锁，轻量级锁和重量级锁状态，这几个状态会随着竞争情况逐渐升</p>\n<p>级。锁可以升级但不能降级。</p>\n<p>锁升级的图示过程：</p>\n<p><img src=\"./assets/java-02.png\" alt=\"\"></p>\n<h3 id=\"_49-什么是死锁\"> 49.什么是死锁?</h3>\n<p>死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无</p>\n<p>法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。是操作系统层面的一个错误，是</p>\n<p>进程死锁的简称，最早在 1965 年由 Dijkstra 在研究银行家算法时提出的，它是计算机操作系统乃至整个并发程序设计领域最难处理的</p>\n<p>问题之一。</p>\n<h3 id=\"_50-怎么防止死锁\"> 50.怎么防止死锁?</h3>\n<p>死锁的四个必要条件：</p>\n<ul>\n<li>**互斥条件：**进程对所分配到的资源不允许其他进程进行访问，若其他进程访问该资源，只能等待，直至占有该资源的进程使用完成后释放该资源</li>\n<li>**请求和保持条件：**进程获得一定的资源之后，又对其他资源发出请求，但是该资源可能被其他进程占有，此事请求阻塞，但又对自己获得的资源保持不放</li>\n<li>**不可剥夺条件：**是指进程已获得的资源，在未完成使用之前，不可被剥夺，只能在使用完后自己释放</li>\n<li>**环路等待条件：**是指进程发生死锁后，若干进程之间形成一种头尾相接的循环等待资源关系</li>\n</ul>\n<p>这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之 一不满足，就不会发生死锁。</p>\n<p>理解了死锁的原因，尤其是产生死锁的四个必要条件，就可以最大可能地避免、预防和 解除死锁。</p>\n<p>所以，在系统设计、进程调度等方面注意如何不让这四个必要条件成立，如何确 定资源的合理分配算法，避免进程永久占据系统资源。</p>\n<p>此外，也要防止进程在处于等待状态的情况下占用资源。因此，对资源的分配要给予合理的规划。</p>\n<h3 id=\"_51-threadlocal是什么-有哪些使用场景\"> 51.ThreadLocal是什么?有哪些使用场景?</h3>\n<p>线程局部变量是局限于线程内部的变量，属于线程自身所有，不在多个线程间共享。Java提供ThreadLocal类来支持线程局部变量，是</p>\n<p>一种实现线程安全的方式。但是在管理环境下（如 web 服务器）使用线程局部变量的时候要特别小心，在这种情况下，工作线程的生</p>\n<p>命周期比任何应用变量的生命周期都要长。任何线程局部变量一旦在工作完成后没有释放，Java 应用就存在内存泄露的风险。</p>\n<h3 id=\"_52-说一下synchronized底层实现原理\"> 52.说一下synchronized底层实现原理?</h3>\n<p>synchronized可以保证方法或者代码块在运行时，同一时刻只有一个方法可以进入到临界区，同时它还可以保证共享变量的内存可见性。</p>\n<p>Java中每一个对象都可以作为锁，这是synchronized实现同步的基础：</p>\n<ul>\n<li>普通同步方法，锁是当前实例对象</li>\n<li>静态同步方法，锁是当前类的class对象</li>\n<li>同步方法块，锁是括号里面的对象</li>\n</ul>\n<h3 id=\"_53-synchronized和volatile-的区别是什么\"> 53.synchronized和volatile 的区别是什么?</h3>\n<ul>\n<li>volatile本质是在告诉jvm当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取； synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。</li>\n<li>volatile仅能使用在变量级别；synchronized则可以使用在变量、方法、和类级别的。</li>\n<li>volatile仅能实现变量的修改可见性，不能保证原子性；而synchronized则可以保证变量的修改可见性和原子性。</li>\n<li>volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞。</li>\n<li>volatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化。</li>\n</ul>\n<h3 id=\"_54-synchronized和lock有什么区别\"> 54.synchronized和Lock有什么区别?</h3>\n<ul>\n<li>首先synchronized是java内置关键字，在jvm层面，Lock是个java类；</li>\n<li>synchronized无法判断是否获取锁的状态，Lock可以判断是否获取到锁；</li>\n<li>synchronized会自动释放锁(a 线程执行完同步代码会释放锁 ；b 线程执行过程中发生异常会释放锁)，Lock需在finally中手工释放锁（unlock()方法释放锁），否则容易造成线程死锁；</li>\n<li>用synchronized关键字的两个线程1和线程2，如果当前线程1获得锁，线程2线程等待。如果线程1阻塞，线程2则会一直等待下去，而Lock锁就不一定会等待下去，如果尝试获取不到锁，线程可以不用一直等待就结束了；</li>\n<li>synchronized的锁可重入、不可中断、非公平，而Lock锁可重入、可判断、可公平（两者皆可）；</li>\n<li>Lock锁适合大量同步的代码的同步问题，synchronized锁适合代码少量的同步问题。</li>\n</ul>\n<h3 id=\"_55-synchronized和reentrantlock区别是什么\"> 55.synchronized和ReentrantLock区别是什么?</h3>\n<p>synchronized是和if、else、for、while一样的关键字，ReentrantLock是类，这是二者的本质区别。既然ReentrantLock是类，那么它</p>\n<p>就提供了比synchronized更多更灵活的特性，可以被继承、可以有方法、可以有各种各样的类变量，ReentrantLock比synchronized的</p>\n<p>扩展性体现在几点上：</p>\n<ul>\n<li>ReentrantLock可以对获取锁的等待时间进行设置，这样就避免了死锁</li>\n<li>ReentrantLock可以获取各种锁的信息</li>\n<li>ReentrantLock可以灵活地实现多路通知</li>\n</ul>\n<p>另外，二者的锁机制其实也是不一样的:ReentrantLock底层调用的是Unsafe的park方法加锁，synchronized操作的应该是对象头中mark word。</p>\n<h3 id=\"_56-说一下atomic-的原理\"> 56.说一下atomic 的原理?</h3>\n<p>Atomic包中的类基本的特性就是在多线程环境下，当有多个线程同时对单个（包括基本类型及引用类型）变量进行操作时，具有排他</p>\n<p>性，即当多个线程同时对该变量的值进行更新时，仅有一个线程能成功，而未成功的线程可以像自旋锁一样，继续尝试，一直等到执行</p>\n<p>成功。</p>\n<p>Atomic系列的类中的核心方法都会调用unsafe类中的几个本地方法。我们需要先知道一个东西就是Unsafe类，全名为：</p>\n<p>sun.misc.Unsafe，这个类包含了大量的对C代码的操作，包括很多直接内存分配以及原子操作的调用，而它之所以标记为非安全的，是</p>\n<p>告诉你这个里面大量的方法调用都会存在安全隐患，需要小心使用，否则会导致严重的后果，例如在通过unsafe分配内存的时候，如果</p>\n<p>自己指定某些区域可能会导致一些类似C++一样的指针越界到其他进程的问题。</p>\n",
      "date_modified": "2021-02-07T05:08:56.000Z",
      "authors": [
        {
          "name": "南辞"
        }
      ],
      "tags": []
    },
    {
      "title": "模块04-Java反射",
      "url": "http://qiqi.dreamagain.top/interview/Java208/%E6%A8%A1%E5%9D%9704%E2%80%94%E5%8F%8D%E5%B0%84/",
      "id": "http://qiqi.dreamagain.top/interview/Java208/%E6%A8%A1%E5%9D%9704%E2%80%94%E5%8F%8D%E5%B0%84/",
      "content_html": "<h2 id=\"问题\"> 问题：</h2>\n<p>57.什么是反射?</p>\n<p>58.什么是java序列化?什么情况下需要序列化?</p>\n<p>59.动态代理是什么?有哪些应用?</p>\n<p>60.怎么实现动态代理?</p>\n<h2 id=\"答案\"> 答案：</h2>\n<h3 id=\"_57-什么是反射\"> 57.什么是反射?</h3>\n<p>反射主要是指程序可以访问、检测和修改它本身状态或行为的一种能力</p>\n<p><strong>Java反射：</strong></p>\n<p>在Java运行时环境中，对于任意一个类，能否知道这个类有哪些属性和方法？对于任意一个对象，能否调用它的任意一个方法</p>\n<p>Java反射机制主要提供了以下功能：</p>\n<ul>\n<li>在运行时判断任意一个对象所属的类。</li>\n<li>在运行时构造任意一个类的对象。</li>\n<li>在运行时判断任意一个类所具有的成员变量和方法。</li>\n<li>在运行时调用任意一个对象的方法。</li>\n</ul>\n<h3 id=\"_58-什么是java序列化-什么情况下需要序列化\"> 58.什么是java序列化?什么情况下需要序列化?</h3>\n<p>简单说就是为了保存在内存中的各种对象的状态（也就是实例变量，不是方法），并且可以把保存的对象状态再读出来。虽然你可以用</p>\n<p>你自己的各种各样的方法来保存object states，但是Java给你提供一种应该比你自己好的保存对象状态的机制，那就是序列化。</p>\n<p><strong>什么情况下需要序列化：</strong></p>\n<ol>\n<li>当你想把的内存中的对象状态保存到一个文件中或者数据库中时候；</li>\n<li>当你想用<strong>套接字</strong>在网络上传送对象的时候；</li>\n<li>当你想通过<strong>RMI</strong>传输对象的时候；</li>\n</ol>\n<h3 id=\"_59-动态代理是什么-有哪些应用\"> 59.动态代理是什么?有哪些应用?</h3>\n<p>动态代理：</p>\n<p>当想要给实现了某个接口的类中的方法，加一些额外的处理。比如说加日志，加事务等。可以给这个类创建一个代理，故名思议就是创建一个新的类，这个类不仅包含原来类方法的功能，而且还在原来的基础上添加了额外处理的新类。这个代理类并不是定义好的，是动态生成的。具有解耦意义，灵活，扩展性强。</p>\n<p>动态代理的应用：</p>\n<ul>\n<li>Spring的AOP</li>\n<li>加事务</li>\n<li>加权限</li>\n<li>加日志</li>\n</ul>\n<h3 id=\"_60-怎么实现动态代理\"> 60.怎么实现动态代理?</h3>\n<ul>\n<li>\n<p>首先必须定义一个接口，还要有一个InvocationHandler(将实现接口的类的对象传递给它)处理类。</p>\n</li>\n<li>\n<p>再有一个工具类Proxy(习惯性将其称为代理类，因为调用他的newInstance()可以产生代理对象,其实他只是一个产生代理对象的工具类）。</p>\n</li>\n<li>\n<p>利用到InvocationHandler，拼接代理类源码，将其编译生成代理类的二进制码，利用加载器加载，并将其实例化产生代理对象，最后返回。</p>\n</li>\n</ul>\n",
      "date_modified": "2021-02-07T05:08:56.000Z",
      "authors": [
        {
          "name": "南辞"
        }
      ],
      "tags": []
    },
    {
      "title": "模块05-Java对象拷贝",
      "url": "http://qiqi.dreamagain.top/interview/Java208/%E6%A8%A1%E5%9D%9705%E2%80%94%E5%AF%B9%E8%B1%A1%E6%8B%B7%E8%B4%9D/",
      "id": "http://qiqi.dreamagain.top/interview/Java208/%E6%A8%A1%E5%9D%9705%E2%80%94%E5%AF%B9%E8%B1%A1%E6%8B%B7%E8%B4%9D/",
      "content_html": "<h2 id=\"问题\"> 问题：</h2>\n<p>61.为什么要使用克隆?</p>\n<p>62.如何实现对象克隆?</p>\n<p>63.深拷贝和浅拷贝区别是什么?</p>\n<h2 id=\"答案\"> 答案：</h2>\n<h3 id=\"_61-为什么要使用克隆\"> 61.为什么要使用克隆?</h3>\n<p>想对一个对象进行处理，又想保留原有的数据进行接下来的操作，就需要克隆了，Java语言中克隆针对的是类的实例。</p>\n<h3 id=\"_62-如何实现对象克隆\"> 62.如何实现对象克隆?</h3>\n<p>有两种方式：</p>\n<p>1). 实现Cloneable接口并重写Object类中的clone()方法；</p>\n<p>2). 实现Serializable接口，通过对象的序列化和反序列化实现克隆，可以实现真正的深度克隆，代码如下：</p>\n<div><pre><code>\n<span>import</span> <span>java<span>.</span>io<span>.</span></span><span>ByteArrayInputStream</span><span>;</span>\n<span>import</span> <span>java<span>.</span>io<span>.</span></span><span>ByteArrayOutputStream</span><span>;</span>\n<span>import</span> <span>java<span>.</span>io<span>.</span></span><span>ObjectInputStream</span><span>;</span>\n<span>import</span> <span>java<span>.</span>io<span>.</span></span><span>ObjectOutputStream</span><span>;</span>\n<span>import</span> <span>java<span>.</span>io<span>.</span></span><span>Serializable</span><span>;</span>\n\n<span>public</span> <span>class</span> <span>MyUtil</span> <span>{</span>\n\n    <span>private</span> <span>MyUtil</span><span>(</span><span>)</span> <span>{</span>\n        <span>throw</span> <span>new</span> <span>AssertionError</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>@SuppressWarnings</span><span>(</span><span>\"unchecked\"</span><span>)</span>\n    <span>public</span> <span>static</span> <span><span>&lt;</span><span>T</span> <span>extends</span> <span>Serializable</span><span>></span></span> <span>T</span> <span>clone</span><span>(</span><span>T</span> obj<span>)</span> \n                                  <span>throws</span> <span>Exception</span> <span>{</span>\n        <span>ByteArrayOutputStream</span> bout <span>=</span> <span>new</span> <span>ByteArrayOutputStream</span><span>(</span><span>)</span><span>;</span>\n        <span>ObjectOutputStream</span> oos <span>=</span> <span>new</span> <span>ObjectOutputStream</span><span>(</span>bout<span>)</span><span>;</span>\n        oos<span>.</span><span>writeObject</span><span>(</span>obj<span>)</span><span>;</span>\n\n        <span>ByteArrayInputStream</span> bin <span>=</span> \n                    <span>new</span> <span>ByteArrayInputStream</span><span>(</span>bout<span>.</span><span>toByteArray</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>ObjectInputStream</span> ois <span>=</span> <span>new</span> <span>ObjectInputStream</span><span>(</span>bin<span>)</span><span>;</span>\n        <span>return</span> <span>(</span><span>T</span><span>)</span> ois<span>.</span><span>readObject</span><span>(</span><span>)</span><span>;</span>\n\n        <span>// 说明：调用ByteArrayInputStream</span>\n        <span>//或ByteArrayOutputStream对象的close方法没有任何意义</span>\n        <span>// 这两个基于内存的流只要垃圾回收器清理对象就能够释放资源，</span>\n        <span>//这一点不同于对外部资源（如文件流）的释放</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br></div></div><p>下面是测试代码：</p>\n<div><pre><code>\n<span>import</span> <span>java<span>.</span>io<span>.</span></span><span>Serializable</span><span>;</span>\n\n<span>/**\n * 人类\n * @author nnngu\n *\n */</span>\n<span>class</span> <span>Person</span> <span>implements</span> <span>Serializable</span> <span>{</span>\n    <span>private</span> <span>static</span> <span>final</span> <span>long</span> serialVersionUID \n                              <span>=</span> <span>-</span><span>9102017020286042305L</span><span>;</span>\n\n    <span>private</span> <span>String</span> name<span>;</span>    <span>// 姓名</span>\n    <span>private</span> <span>int</span> age<span>;</span>        <span>// 年龄</span>\n    <span>private</span> <span>Car</span> car<span>;</span>        <span>// 座驾</span>\n\n    <span>public</span> <span>Person</span><span>(</span><span>String</span> name<span>,</span> <span>int</span> age<span>,</span> <span>Car</span> car<span>)</span> <span>{</span>\n        <span>this</span><span>.</span>name <span>=</span> name<span>;</span>\n        <span>this</span><span>.</span>age <span>=</span> age<span>;</span>\n        <span>this</span><span>.</span>car <span>=</span> car<span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>String</span> <span>getName</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> name<span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>void</span> <span>setName</span><span>(</span><span>String</span> name<span>)</span> <span>{</span>\n        <span>this</span><span>.</span>name <span>=</span> name<span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>int</span> <span>getAge</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> age<span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>void</span> <span>setAge</span><span>(</span><span>int</span> age<span>)</span> <span>{</span>\n        <span>this</span><span>.</span>age <span>=</span> age<span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>Car</span> <span>getCar</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> car<span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>void</span> <span>setCar</span><span>(</span><span>Car</span> car<span>)</span> <span>{</span>\n        <span>this</span><span>.</span>car <span>=</span> car<span>;</span>\n    <span>}</span>\n\n    <span>@Override</span>\n    <span>public</span> <span>String</span> <span>toString</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> <span>\"Person [name=\"</span> <span>+</span> name <span>+</span> \"<span>,</span>\n                       age<span>=</span><span>\" + age + \"</span><span>,</span> car<span>=</span><span>\" + car + \"</span><span>]</span>\"<span>;</span>\n    <span>}</span>\n\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br></div></div><div><pre><code>\n<span>/**\n * 小汽车类\n * @author nnngu\n *\n */</span>\n<span>class</span> <span>Car</span> <span>implements</span> <span>Serializable</span> <span>{</span>\n    <span>private</span> <span>static</span> <span>final</span> <span>long</span> serialVersionUID \n                                <span>=</span> <span>-</span><span>5713945027627603702L</span><span>;</span>\n\n    <span>private</span> <span>String</span> brand<span>;</span>       <span>// 品牌</span>\n    <span>private</span> <span>int</span> maxSpeed<span>;</span>       <span>// 最高时速</span>\n\n    <span>public</span> <span>Car</span><span>(</span><span>String</span> brand<span>,</span> <span>int</span> maxSpeed<span>)</span> <span>{</span>\n        <span>this</span><span>.</span>brand <span>=</span> brand<span>;</span>\n        <span>this</span><span>.</span>maxSpeed <span>=</span> maxSpeed<span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>String</span> <span>getBrand</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> brand<span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>void</span> <span>setBrand</span><span>(</span><span>String</span> brand<span>)</span> <span>{</span>\n        <span>this</span><span>.</span>brand <span>=</span> brand<span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>int</span> <span>getMaxSpeed</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> maxSpeed<span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>void</span> <span>setMaxSpeed</span><span>(</span><span>int</span> maxSpeed<span>)</span> <span>{</span>\n        <span>this</span><span>.</span>maxSpeed <span>=</span> maxSpeed<span>;</span>\n    <span>}</span>\n\n    <span>@Override</span>\n    <span>public</span> <span>String</span> <span>toString</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> <span>\"Car [brand=\"</span> <span>+</span> brand <span>+</span> \"<span>,</span> \n                      maxSpeed<span>=</span><span>\" + maxSpeed + \"</span><span>]</span>\"<span>;</span>\n    <span>}</span>\n\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br></div></div><div><pre><code>\n<span>class</span> <span>CloneTest</span> <span>{</span>\n\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n        <span>try</span> <span>{</span>\n            <span>Person</span> p1 <span>=</span> <span>new</span> <span>Person</span><span>(</span><span>\"郭靖\"</span><span>,</span> <span>33</span><span>,</span> \n                              <span>new</span> <span>Car</span><span>(</span><span>\"Benz\"</span><span>,</span> <span>300</span><span>)</span><span>)</span><span>;</span>\n            <span>Person</span> p2 <span>=</span> <span>MyUtil</span><span>.</span><span>clone</span><span>(</span>p1<span>)</span><span>;</span>   <span>// 深度克隆</span>\n            p2<span>.</span><span>getCar</span><span>(</span><span>)</span><span>.</span><span>setBrand</span><span>(</span><span>\"BYD\"</span><span>)</span><span>;</span>\n            <span>// 修改克隆的Person对象p2关联的汽车对象的品牌属性</span>\n            <span>// 原来的Person对象p1关联的汽车不会受到任何影响</span>\n            <span>// 因为在克隆Person对象时其关联的汽车对象也被克隆了</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>p1<span>)</span><span>;</span>\n        <span>}</span> <span>catch</span> <span>(</span><span>Exception</span> e<span>)</span> <span>{</span>\n            e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><p>注意：基于序列化和反序列化实现的克隆不仅仅是深度克隆，更重要的是通过泛型限定，可以检查出要克隆的对象是否支持序列化，这</p>\n<p>项检查是编译器完成的，不是在运行时抛出异常，这种是方案明显优于使用Object类的clone方法克隆对象。让问题在编译的时候暴露</p>\n<p>出来总是好过把问题留到运行时。</p>\n<h3 id=\"_63-深拷贝和浅拷贝区别是什么\"> 63.深拷贝和浅拷贝区别是什么?</h3>\n<ul>\n<li>浅拷贝只是复制了对象的引用地址，两个对象指向同一个内存地址，所以修改其中任意的值，另一个值都会随之变化，这就是浅拷贝（例：assign()）</li>\n<li>深拷贝是将对象及值复制过来，两个对象修改其中任意的值另一个值不会改变，这就是深拷贝（例：JSON.parse()和JSON.stringify()，但是此方法无法复制函数类型）</li>\n</ul>\n",
      "date_modified": "2021-02-07T05:08:56.000Z",
      "authors": [
        {
          "name": "南辞"
        }
      ],
      "tags": []
    },
    {
      "title": "模块06—Java Web",
      "url": "http://qiqi.dreamagain.top/interview/Java208/%E6%A8%A1%E5%9D%9706%E2%80%94Java%20Web/",
      "id": "http://qiqi.dreamagain.top/interview/Java208/%E6%A8%A1%E5%9D%9706%E2%80%94Java%20Web/",
      "content_html": "<h2 id=\"问题\"> 问题：</h2>\n<p>64.jsp和servlet有什么区别?</p>\n<p>65.jsp有哪些内置对象?作用分别是什么?</p>\n<p>66.说一下jsp的4种作用域?</p>\n<p>67.session和cookie有什么区别?</p>\n<p>68.说一下 session的工作原理?</p>\n<p>69.如果客户端禁止 cookie 能实现session 还能用吗?</p>\n<p>70.spring mvc和struts 的区别是什么?</p>\n<p>71.如何避免 sql注入?</p>\n<p>72.什么是XSS攻击,如何避免?</p>\n<p>73.什么是CSRF攻击，如何避免?</p>\n<h2 id=\"答案\"> 答案：</h2>\n<h3 id=\"_64-jsp和servlet有什么区别\"> 64.jsp和servlet有什么区别?</h3>\n<ol>\n<li>jsp经编译后就变成了Servlet.（JSP的本质就是Servlet，JVM只能识别java的类，不能识别JSP的代码，Web容器将JSP的代码编译成JVM能够识别的java类）</li>\n<li>jsp更擅长表现于页面显示，servlet更擅长于逻辑控制。</li>\n<li>Servlet中没有内置对象，Jsp中的内置对象都是必须通过HttpServletRequest对象，HttpServletResponse对象以及HttpServlet对象得到。</li>\n<li>Jsp是Servlet的一种简化，使用Jsp只需要完成程序员需要输出到客户端的内容，Jsp中的Java脚本如何镶嵌到一个类中，由Jsp容器完成。而Servlet则是个完整的Java类，这个类的Service方法用于生成对客户端的响应。</li>\n</ol>\n<h3 id=\"_65-jsp有哪些内置对象-作用分别是什么\"> 65.jsp有哪些内置对象?作用分别是什么?</h3>\n<p>JSP有9个内置对象：</p>\n<ul>\n<li>request：封装客户端的请求，其中包含来自GET或POST请求的参数；</li>\n<li>response：封装服务器对客户端的响应；</li>\n<li>pageContext：通过该对象可以获取其他对象；</li>\n<li>session：封装用户会话的对象；</li>\n<li>application：封装服务器运行环境的对象；</li>\n<li>out：输出服务器响应的输出流对象；</li>\n<li>config：Web应用的配置对象；</li>\n<li>page：JSP页面本身（相当于Java程序中的this）；</li>\n<li>exception：封装页面抛出异常的对象。</li>\n</ul>\n<h3 id=\"_66-说一下jsp的4种作用域\"> 66.说一下jsp的4种作用域?</h3>\n<p>JSP中的四种作用域包括page、request、session和application，具体来说：</p>\n<ul>\n<li><strong>page</strong>代表与一个页面相关的对象和属性。</li>\n<li><strong>request</strong>代表与Web客户机发出的一个请求相关的对象和属性。一个请求可能跨越多个页面，涉及多个Web组件；需要在页面显示的临时数据可以置于此作用域。</li>\n<li><strong>session</strong>代表与某个用户与服务器建立的一次会话相关的对象和属性。跟某个用户相关的数据应该放在用户自己的session中。</li>\n<li><strong>application</strong>代表与整个Web应用程序相关的对象和属性，它实质上是跨越整个Web应用程序，包括多个页面、请求和会话的一个全局作用域。</li>\n</ul>\n<h3 id=\"_67-session和cookie有什么区别\"> 67.session和cookie有什么区别?</h3>\n<ul>\n<li>\n<p>由于HTTP协议是无状态的协议，所以服务端需要记录用户的状态时，就需要用某种机制来识具体的用户，这个机制就是Session.典型的场景比如购物车，当你点击下单按钮时，由于HTTP协议无状态，所以并不知道是哪个用户操作的，所以服务端要为特定的用户创建了特定的Session，用于标识这个用户，并且跟踪用户，这样才知道购物车里面有几本书。这个Session是保存在服务端的，有一个唯一标识。在服务端保存Session的方法很多，内存、数据库、文件都有。集群的时候也要考虑Session的转移，在大型的网站，一般会有专门的Session服务器集群，用来保存用户会话，这个时候 Session 信息都是放在内存的，使用一些缓存服务比如Memcached之类的来放 Session。</p>\n</li>\n<li>\n<p>思考一下服务端如何识别特定的客户？这个时候Cookie就登场了。每次HTTP请求的时候，客户端都会发送相应的Cookie信息到服务端。实际上大多数的应用都是用 Cookie 来实现Session跟踪的，第一次创建Session的时候，服务端会在HTTP协议中告诉客户端，需要在 Cookie 里面记录一个Session ID，以后每次请求把这个会话ID发送到服务器，我就知道你是谁了。有人问，如果客户端的浏览器禁用了 Cookie 怎么办？一般这种情况下，会使用一种叫做<strong>URL重写</strong>的技术来进行会话跟踪，即每次HTTP交互，URL后面都会被附加上一个诸如 <strong>sid=xxxxx 这样的参数</strong>，服务端据此来识别用户。</p>\n</li>\n<li>\n<p>Cookie其实还可以用在一些方便用户的场景下，设想你某次登陆过一个网站，下次登录的时候不想再次输入账号了，怎么办？这个信息可以写到Cookie里面，访问网站的时候，网站页面的脚本可以读取这个信息，就自动帮你把用户名给填了，能够方便一下用户。这也是Cookie名称的由来，给用户的一点甜头。所以，总结一下：Session是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中；Cookie是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现Session的一种方式。</p>\n</li>\n</ul>\n<h3 id=\"_68-说一下-session的工作原理\"> 68.说一下 session的工作原理?</h3>\n<p>其实session是一个存在服务器上的类似于一个散列表格的文件。里面存有我们需要的信息，在我们需要用的时候可以从里面取出来。</p>\n<p>类似于一个大号的map吧，里面的键存储的是用户的sessionid，用户向服务器发送请求的时候会带上这个sessionid。这时就可以从中</p>\n<p>取出对应的值了。</p>\n<h3 id=\"_69-如果客户端禁止-cookie-能实现session-还能用吗\"> 69.如果客户端禁止 cookie 能实现session 还能用吗?</h3>\n<p>Cookie与 Session，一般认为是两个独立的东西，Session采用的是在服务器端保持状态的方案，而Cookie采用的是在客户端保持状态</p>\n<p>的方案。但为什么禁用Cookie就不能得到Session呢？因为Session是用Session ID来确定当前对话所对应的服务器Session，而Session</p>\n<p>ID是通过Cookie来传递的，禁用Cookie相当于失去了Session ID，也就得不到Session了。</p>\n<p>假定用户关闭Cookie的情况下使用Session，其实现途径有以下几种：</p>\n<ol>\n<li>设置php.ini配置文件中的“session.use_trans_sid = 1”，或者编译时打开“--enable-trans-sid”选项，让PHP自动跨页传递Session ID。</li>\n<li>手动通过URL传值、隐藏表单传递Session ID。</li>\n<li>用文件、数据库等形式保存Session ID，在跨页过程中手动调用。</li>\n</ol>\n<h3 id=\"_70-springmvc和struts-的区别是什么\"> 70.SpringMVC和struts 的区别是什么?</h3>\n<ul>\n<li><strong>拦截机制的不同</strong></li>\n</ul>\n<p>Struts2是类级别的拦截，每次请求就会创建一个Action，和Spring整合时Struts2的ActionBean注入作用域是原型模式prototype，然后通过setter，getter把request数据注入到属性。Struts2中，一个Action对应一个request，response上下文，在接收参数时，可以通过属性接收，这说明属性参数是让多个方法共享的。Struts2中Action的一个方法可以对应一个url，而其类属性却被所有方法共享，这也就无法用注解或其他方式标识其所属方法了，只能设计为多例。</p>\n<p>SpringMVC是方法级别的拦截，一个方法对应一个Request上下文，所以方法直接基本上是独立的，独享request，response数据。而每个方法同时又和一个url对应，参数的传递是直接注入到方法中的，是方法所独有的。处理结果通过ModeMap返回给框架。在Spring整合时，SpringMVC的Controller Bean默认单例模式Singleton，所以默认对所有的请求，只会创建一个Controller，又因为没有共享的属性，所以是线程安全的，如果要改变默认的作用域，需要添加@Scope注解修改。</p>\n<p>Struts2有自己的拦截Interceptor机制，SpringMVC这是用的是独立的AOP方式，这样导致Struts2的配置文件量还是比SpringMVC大。</p>\n<ul>\n<li><strong>底层框架的不同</strong></li>\n</ul>\n<p>Struts2采用Filter（StrutsPrepareAndExecuteFilter）实现，SpringMVC（DispatcherServlet）则采用Servlet实现。Filter在容器启动之后即初始化；服务停止以后销毁，晚于Servlet。Servlet在是在调用时初始化，先于Filter调用，服务停止后销毁。</p>\n<ul>\n<li>\n<h3 id=\"性能方面\"> <strong>性能方面</strong></h3>\n</li>\n</ul>\n<p>Struts2是类级别的拦截，每次请求对应实例一个新的Action，需要加载所有的属性值注入，SpringMVC实现了零配置，由于SpringMVC基于方法的拦截，有加载一次单例模式bean注入。所以，SpringMVC开发效率和性能高于Struts2。</p>\n<ul>\n<li>\n<h3 id=\"配置方面\"> <strong>配置方面</strong></h3>\n</li>\n</ul>\n<p>Spring MVC和Spring是无缝的。从这个项目的管理和安全上也比Struts2高。</p>\n<h3 id=\"_71-如何避免-sql注入\"> 71.如何避免 sql注入?</h3>\n<ol>\n<li>PreparedStatement（简单又有效的方法）</li>\n<li>使用正则表达式过滤传入的参数</li>\n<li>字符串过滤</li>\n<li>JSP中调用该函数检查是否包函非法字符</li>\n<li>JSP页面判断代码</li>\n</ol>\n<h3 id=\"_72-什么是xss攻击-如何避免\"> 72.什么是XSS攻击,如何避免?</h3>\n<p>XSS攻击又称CSS,全称Cross Site Script （跨站脚本攻击），其原理是攻击者向有XSS漏洞的网站中输入恶意的 HTML 代码，当用户浏览</p>\n<p>该网站时，这段 HTML 代码会自动执行，从而达到攻击的目的。XSS 攻击类似于 SQL 注入攻击，SQL注入攻击中以SQL语句作为用户输</p>\n<p>入，从而达到查询/修改/删除数据的目的，而在xss攻击中，通过插入恶意脚本，实现对用户游览器的控制，获取用户的一些信息。 XSS</p>\n<p>是 Web 程序中常见的漏洞，XSS 属于被动式且用于客户端的攻击方式。</p>\n<p>XSS防范的总体思路是：<strong>对输入(和URL参数)进行过滤，对输出进行编码</strong>。</p>\n<h3 id=\"_73-什么是csrf攻击-如何避免\"> 73.什么是CSRF攻击，如何避免?</h3>\n<p>CSRF（Cross-site request forgery）也被称为 one-click attack或者 session riding，中文全称是叫<strong>跨站请求伪造</strong>。一般来说，攻击者通过伪造用户的浏览器的请求，向访问一个用户自己曾经认证访问过的网站发送出去，使目标网站接收并误以为是用户的真实操作而去执行命令。常用于盗取账号、转账、发送虚假消息等。攻击者利用网站对请求的验证漏洞而实现这样的攻击行为，网站能够确认请求来源于用户的浏览器，却不能验证请求是否源于用户的真实意愿下的操作行为。</p>\n<p><strong>如何避免：</strong></p>\n<ol>\n<li>\n<p>验证 HTTP Referer 字段</p>\n<p>HTTP头中的Referer字段记录了该 HTTP 请求的来源地址。在通常情况下，访问一个安全受限页面的请求来自于同一个网站，而如果黑客要对其实施 CSRF攻击，他一般只能在他自己的网站构造请求。因此，可以通过验证Referer值来防御CSRF 攻击。</p>\n</li>\n<li>\n<p>使用验证码</p>\n<p>关键操作页面加上验证码，后台收到请求后通过判断验证码可以防御CSRF。但这种方法对用户不太友好。</p>\n</li>\n<li>\n<p>在请求地址中添加token并验证</p>\n<p>CSRF 攻击之所以能够成功，是因为黑客可以完全<strong>伪造用户的请求</strong>，该请求中所有的用户验证信息都是存在于cookie中，因此黑客可以在不知道这些验证信息的情况下直接利用用户自己的cookie 来通过安全验证。要抵御 CSRF，关键在于在请求中放入黑客所不能伪造的信息，并且该信息不存在于 cookie 之中。</p>\n<p>可以在 HTTP 请求<strong>中以参数的形式加入一个随机产生的 token</strong>，并在服务器端建立一个拦截器来验证这个 token，如果请求中没有token或者 token 内容不正确，则认为可能是 CSRF 攻击而拒绝该请求。这种方法要比检查 Referer 要安全一些，token 可以在用户登陆后产生并放于session之中，然后在每次请求时把token 从 session 中拿出，与请求中的 token 进行比对，但这种方法的难点在于如何把 token 以参数的形式加入请求。\n对于 GET 请求，token 将附在请求地址之后，这样 URL 就变成 http://url?csrftoken=tokenvalue。\n而对于 POST 请求来说，要在 form 的最后加上 <input type=\"hidden\" name=\"csrftoken\" value=\"tokenvalue\"/>，这样就把token以参数的形式加入请求了。</p>\n</li>\n<li>\n<p>在HTTP 头中自定义属性并验证</p>\n<p>这种方法也是使用 token 并进行验证，和上一种方法不同的是，这里并不是把 token 以参数的形式置于 HTTP 请求之中，而是把它放到 HTTP 头中自定义的属性里。</p>\n<p>通过 XMLHttpRequest 这个类，可以一次性给所有该类请求加上 csrftoken 这个 HTTP 头属性，并把 token 值放入其中。这样解决了上种方法在请求中加入 token 的不便，同时，通过 XMLHttpRequest 请求的地址不会被记录到浏览器的地址栏，也不用担心 token 会透过 Referer 泄露到其他网站中去。</p>\n</li>\n</ol>\n",
      "date_modified": "2021-02-07T05:08:56.000Z",
      "authors": [
        {
          "name": "南辞"
        }
      ],
      "tags": []
    },
    {
      "title": "模块07—Java异常",
      "url": "http://qiqi.dreamagain.top/interview/Java208/%E6%A8%A1%E5%9D%9707%E2%80%94%E5%BC%82%E5%B8%B8/",
      "id": "http://qiqi.dreamagain.top/interview/Java208/%E6%A8%A1%E5%9D%9707%E2%80%94%E5%BC%82%E5%B8%B8/",
      "content_html": "<h2 id=\"问题\"> 问题：</h2>\n<p>74.throw和throws 的区别?</p>\n<p>75.final、finally、finalize有什么区别?</p>\n<p>76.try-catch-finally 中哪个部分可以省略?</p>\n<p>77.try-catch-finally中，如果catch 中 return 了, finally还会执行吗?</p>\n<p>78.常见的异常类有哪些?</p>\n<h2 id=\"答案\"> 答案:</h2>\n<h3 id=\"_74-throw和throws-的区别\"> 74.throw和throws 的区别?</h3>\n<p>throws是用来声明一个方法可能抛出的所有异常信息，throws是将异常声明但是不处理，而是将异常往上传，谁调用我就交给谁处</p>\n<p>理。而throw则是指抛出的一个具体的异常类型。</p>\n<h3 id=\"_75-final、finally、finalize有什么区别\"> 75.final、finally、finalize有什么区别?</h3>\n<ul>\n<li>final可以修饰类、变量、方法，修饰类表示该类不能被继承、修饰方法表示该方法不能被重写、修饰变量表示该变量是一个常量不能被重新赋值。</li>\n<li>finally一般作用在try-catch代码块中，在处理异常的时候，通常我们将一定要执行的代码方法finally代码块中，表示不管是否出现异常，该代码块都会执行，一般用来存放一些关闭资源的代码。</li>\n<li>finalize是一个方法，属于Object类的一个方法，而Object类是所有类的父类，该方法一般由垃圾回收器来调用，当我们调用System的gc()方法的时候，由垃圾回收器调用finalize(),回收垃圾。</li>\n</ul>\n<h3 id=\"_76-try-catch-finally-中哪个部分可以省略\"> 76.try-catch-finally 中哪个部分可以省略?</h3>\n<p>catch 可以省略</p>\n<p><strong>原因：</strong></p>\n<p>更为严格的说法其实是：try只适合处理运行时异常，try+catch适合处理运行时异常+普通异常。也就是说，如果你只用try去处理普通异常却不加以catch处理，编译是通不过的，因为编译器硬性规定，普通异常如果选择捕获，则必须用catch显示声明以便进一步处理。而运行时异常在编译时没有如此规定，所以catch可以省略，你加上catch编译器也觉得无可厚非。</p>\n<p>理论上，编译器看任何代码都不顺眼，都觉得可能有潜在的问题，所以你即使对所有代码加上try，代码在运行期时也只不过是在正常运行的基础上加一层皮。但是你一旦对一段代码加上try，就等于显示地承诺编译器，对这段代码可能抛出的异常进行捕获而非向上抛出处理。如果是普通异常，编译器要求必须用catch捕获以便进一步处理；如果运行时异常，捕获然后丢弃并且+finally扫尾处理，或者加上catch捕获以便进一步处理。</p>\n<p>至于加上finally，则是在不管有没捕获异常，都要进行的“扫尾”处理。</p>\n<h3 id=\"_77-try-catch-finally中-如果catch-中-return-了-finally还会执行吗\"> 77.try-catch-finally中，如果catch 中 return 了, finally还会执行吗?</h3>\n<p>会执行，在 return 前执行。</p>\n<div><pre><code><span>/*\n * java面试题--如果catch里面有return语句，finally里面的代码还会执行吗？\n */</span>\n<span>public</span> <span>class</span> <span>FinallyDemo2</span> <span>{</span>\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>getInt</span><span>(</span><span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>static</span> <span>int</span> <span>getInt</span><span>(</span><span>)</span> <span>{</span>\n        <span>int</span> a <span>=</span> <span>10</span><span>;</span>\n        <span>try</span> <span>{</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>a <span>/</span> <span>0</span><span>)</span><span>;</span>\n            a <span>=</span> <span>20</span><span>;</span>\n        <span>}</span> <span>catch</span> <span>(</span><span>ArithmeticException</span> e<span>)</span> <span>{</span>\n            a <span>=</span> <span>30</span><span>;</span>\n            <span>return</span> a<span>;</span>\n            <span>/*\n             * return a 在程序执行到这一步的时候，这里不是return a 而是 return 30；这个返回路径就形成了\n             * 但是呢，它发现后面还有finally，所以继续执行finally的内容，a=40\n             * 再次回到以前的路径,继续走return 30，形成返回路径之后，这里的a就不是a变量了，而是常量30\n             */</span>\n        <span>}</span> <span>finally</span> <span>{</span>\n            a <span>=</span> <span>40</span><span>;</span>\n        <span>}</span>\n\n<span>//      return a;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br></div></div><p>执行结果：30</p>\n<p><strong>代码示例2：</strong></p>\n<div><pre><code>\n<span>package</span> <span>com<span>.</span>java_02</span><span>;</span>\n\n<span>/*\n * java面试题--如果catch里面有return语句，finally里面的代码还会执行吗？\n */</span>\n<span>public</span> <span>class</span> <span>FinallyDemo2</span> <span>{</span>\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>getInt</span><span>(</span><span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>static</span> <span>int</span> <span>getInt</span><span>(</span><span>)</span> <span>{</span>\n        <span>int</span> a <span>=</span> <span>10</span><span>;</span>\n        <span>try</span> <span>{</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>a <span>/</span> <span>0</span><span>)</span><span>;</span>\n            a <span>=</span> <span>20</span><span>;</span>\n        <span>}</span> <span>catch</span> <span>(</span><span>ArithmeticException</span> e<span>)</span> <span>{</span>\n            a <span>=</span> <span>30</span><span>;</span>\n            <span>return</span> a<span>;</span>\n            <span>/*\n             * return a 在程序执行到这一步的时候，这里不是return a 而是 return 30；这个返回路径就形成了\n             * 但是呢，它发现后面还有finally，所以继续执行finally的内容，a=40\n             * 再次回到以前的路径,继续走return 30，形成返回路径之后，这里的a就不是a变量了，而是常量30\n             */</span>\n        <span>}</span> <span>finally</span> <span>{</span>\n            a <span>=</span> <span>40</span><span>;</span>\n            <span>return</span> a<span>;</span> <span>//如果这样，就又重新形成了一条返回路径，由于只能通过1个return返回，所以这里直接返回40</span>\n        <span>}</span>\n\n<span>//      return a;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br></div></div><p>执行结果：40</p>\n<h3 id=\"_78-常见的异常类有哪些\"> 78.常见的异常类有哪些?</h3>\n<ul>\n<li>NullPointerException：当应用程序试图访问空对象时，则抛出该异常。</li>\n<li>SQLException：提供关于数据库访问错误或其他错误信息的异常。</li>\n<li>IndexOutOfBoundsException：指示某排序索引（例如对数组、字符串或向量的排序）超出范围时抛出。</li>\n<li>NumberFormatException：当应用程序试图将字符串转换成一种数值类型，但该字符串不能转换为适当格式时，抛出该异常。</li>\n<li>FileNotFoundException：当试图打开指定路径名表示的文件失败时，抛出此异常。</li>\n<li>IOException：当发生某种I/O异常时，抛出此异常。此类是失败或中断的I/O操作生成的异常的通用类。</li>\n<li>ClassCastException：当试图将对象强制转换为不是实例的子类时，抛出该异常。</li>\n<li>ArrayStoreException：试图将错误类型的对象存储到一个对象数组时抛出的异常。</li>\n<li>IllegalArgumentException：抛出的异常表明向方法传递了一个不合法或不正确的参数。</li>\n<li>ArithmeticException：当出现异常的运算条件时，抛出此异常。例如，一个整数“除以零”时，抛出此类的一个实例。</li>\n<li>NegativeArraySizeException：如果应用程序试图创建大小为负的数组，则抛出该异常。</li>\n<li>NoSuchMethodException：无法找到某一特定方法时，抛出该异常。</li>\n<li>SecurityException：由安全管理器抛出的异常，指示存在安全侵犯。</li>\n<li>UnsupportedOperationException：当不支持请求的操作时，抛出该异常。</li>\n<li>RuntimeExceptionRuntimeException：是那些可能在Java虚拟机正常运行期间抛出的异常的超类。</li>\n</ul>\n",
      "date_modified": "2021-02-07T05:08:56.000Z",
      "authors": [
        {
          "name": "南辞"
        }
      ],
      "tags": []
    },
    {
      "title": "模块08—网络",
      "url": "http://qiqi.dreamagain.top/interview/Java208/%E6%A8%A1%E5%9D%9708%E2%80%94%E7%BD%91%E7%BB%9C/",
      "id": "http://qiqi.dreamagain.top/interview/Java208/%E6%A8%A1%E5%9D%9708%E2%80%94%E7%BD%91%E7%BB%9C/",
      "content_html": "<h2 id=\"问题\"> 问题：</h2>\n<p>79.http响应码301和302代表的是什么?有什么区别?</p>\n<p>80.forward和redirect的区别?</p>\n<p>81.简述tcp和udp的区别?</p>\n<p>82.tcp为什么要三次握手，两次不行吗?为什么?</p>\n<p>83.说一下 tcp粘包是怎么产生的?</p>\n<p>84.OSl的七层模型都有哪些?</p>\n<p>85.get和post请求有哪些区别?</p>\n<p>86.如何实现跨域?</p>\n<p>87.说一下JSONP 实现原理?</p>\n<h2 id=\"答案\"> 答案：</h2>\n<h3 id=\"_79-http响应码301和302代表的是什么-有什么区别\"> 79.http响应码301和302代表的是什么?有什么区别?</h3>\n<p>301，302 都是HTTP状态的编码，都代表着某个URL发生了转移。</p>\n<p><strong>区别：</strong></p>\n<ul>\n<li>\n<p>301 redirect: 301 代表永久性转移(Permanently Moved)。</p>\n</li>\n<li>\n<p>302 redirect: 302 代表暂时性转移(Temporarily Moved )。</p>\n</li>\n</ul>\n<h3 id=\"_80-forward和redirect的区别\"> 80.forward和redirect的区别?</h3>\n<p>Forward和Redirect代表了两种请求转发方式：直接转发和间接转发。</p>\n<p><strong>直接转发方式（Forward）</strong>，客户端和浏览器只发出一次请求，Servlet、HTML、JSP或其它信息资源，由第二个信息资源响应该请求，在请求对象request中，保存的对象对于每个信息资源是共享的。</p>\n<p>**间接转发方式（Redirect）**实际是两次HTTP请求，服务器端在响应第一次请求的时候，让浏览器再向另外一个URL发出请求，从而达到转发的目的。</p>\n<p><strong>举个通俗的例子：</strong></p>\n<p>直接转发就相当于：“A找B借钱，B说没有，B去找C借，借到借不到都会把消息传递给A”；</p>\n<p>间接转发就相当于：&quot;A找B借钱，B说没有，让A去找C借&quot;。</p>\n<h3 id=\"_81-简述tcp和udp的区别\"> 81.简述TCP和UDP的区别?</h3>\n<ul>\n<li>TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接。</li>\n<li>TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付。</li>\n<li>TCP通过校验和，重传控制，序号标识，滑动窗口、确认应答实现可靠传输。如丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。</li>\n<li>UDP具有较好的实时性，工作效率比TCP高，适用于对高速传输和实时性有较高的通信或广播通信。</li>\n<li>每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信。</li>\n<li>TCP对系统资源要求较多，UDP对系统资源要求较少。</li>\n</ul>\n<h3 id=\"_82-tcp为什么要三次握手-两次不行吗-为什么\"> 82.TCP为什么要三次握手，两次不行吗?为什么?</h3>\n<p>为了实现可靠数据传输， TCP 协议的通信双方， 都必须维护一个序列号， 以标识发送出去的数据包中， 哪些是已经被对方收到的。</p>\n<p>三次握手的过程即是通信双方相互告知序列号起始值， 并确认对方已经收到了序列号起始值的必经步骤。</p>\n<p>如果只是两次握手， 至多只有连接发起方的起始序列号能被确认， 另一方选择的序列号则得不到确认。</p>\n<h3 id=\"_83-说一下-tcp粘包是怎么产生的\"> 83.说一下 TCP粘包是怎么产生的?</h3>\n<p><strong>①. 发送方产生粘包</strong></p>\n<p>采用TCP协议传输数据的客户端与服务器经常是保持一个长连接的状态（一次连接发一次数据不存在粘包），双方在连接不断开的情况下，可以一直传输数据；但当发送的数据包过于小的时候，那么TCP协议默认的会启用Nagle算法，将这些较小的数据包进行合并发送（缓冲区数据发送是一个堆压的过程）；这个合并过程就是在发送缓冲区中进行的，也就是说数据发送出来它已经是粘包的状态了。</p>\n<blockquote>\n<p><img src=\"./assets/image-20210110112812920.png\" alt=\"\"></p>\n</blockquote>\n<p><strong>②. 接收方产生粘包</strong></p>\n<p>接收方采用TCP协议接收数据时的过程是这样的：数据到底接收方，从网络模型的下方传递至传输层，传输层的TCP协议处理是将其放置接收缓冲区，然后由应用层来主动获取（C语言用recv、read等函数）；这时会出现一个问题，就是我们在程序中调用的读取数据函数不能及时的把缓冲区中的数据拿出来，而下一个数据又到来并有一部分放入的缓冲区末尾，等我们读取数据时就是一个粘包。（放数据的速度 &gt; 应用层拿数据速度）</p>\n<blockquote>\n<p><img src=\"./assets/image-20210110113226253.png\" alt=\"\"></p>\n</blockquote>\n<h3 id=\"_84-osl的七层模型都有哪些\"> 84.OSl的七层模型都有哪些?</h3>\n<p><strong>物联网淑慧示用</strong></p>\n<ol>\n<li>应用层：网络服务与最终用户的一个接口。</li>\n<li>表示层：数据的表示、安全、压缩。</li>\n<li>会话层：建立、管理、终止会话。</li>\n<li>传输层：定义传输数据的协议端口号，以及流控和差错校验。</li>\n<li>网络层：进行逻辑地址寻址，实现不同网络之间的路径选择。</li>\n<li>数据链路层：建立逻辑连接、进行硬件地址寻址、差错校验等功能。</li>\n<li>物理层：建立、维护、断开物理连接。</li>\n</ol>\n<h3 id=\"_85-get和post请求有哪些区别\"> 85.get和post请求有哪些区别?</h3>\n<ul>\n<li>GET在浏览器回退时是无害的，而POST会再次提交请求。</li>\n<li>GET产生的URL地址可以被Bookmark，而POST不可以。</li>\n<li>GET请求会被浏览器主动cache，而POST不会，除非手动设置。</li>\n<li>GET请求只能进行url编码，而POST支持多种编码方式。</li>\n<li>GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。</li>\n<li>GET请求在URL中传送的参数是有长度限制的，而POST么有。</li>\n<li>对参数的数据类型，GET只接受ASCII字符，而POST没有限制。</li>\n<li>GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。</li>\n<li>GET参数通过URL传递，POST放在Request body中。</li>\n</ul>\n<h3 id=\"_86-如何实现跨域\"> 86.如何实现跨域?</h3>\n<h4 id=\"方式一-图片ping或script标签跨域\"> 方式一：图片ping或script标签跨域</h4>\n<p><strong>图片ping</strong>常用于跟踪用户点击页面或动态广告曝光次数。 <strong>script标签</strong>可以得到从其他来源数据，这也是JSONP依赖的根据。</p>\n<h4 id=\"方式二-jsonp跨域\"> 方式二：JSONP跨域</h4>\n<p>JSONP（JSON with Padding）是数据格式JSON的一种“使用模式”，可以让网页从别的网域要数据。根据 XmlHttpRequest 对象受到同源策略的影响，而利用 <code>&lt;script&gt;</code>元素的这个开放策略，网页可以得到从其他来源动态产生的JSON数据，而这种使用模式就是所谓的 JSONP。用JSONP抓到的数据并不是JSON，而是任意的JavaScript，用 JavaScript解释器运行而不是用JSON解析器解析。所有通过Chrome查看所有JSONP发送的Get请求都是js类型，而非XHR。</p>\n<h4 id=\"方式三-cors\"> 方式三：CORS</h4>\n<p>Cross-Origin Resource Sharing（CORS）跨域资源共享是一份浏览器技术的规范，提供了 Web 服务从不同域传来沙盒脚本的方法，以避开浏览器的同源策略，确保安全的跨域数据传输。现代浏览器使用CORS在API容器如XMLHttpRequest来减少HTTP请求的风险来源。与 JSONP 不同，CORS 除了 GET 要求方法以外也支持其他的 HTTP 要求。服务器一般需要增加如下响应头的一种或几种：</p>\n<div><pre><code>Access-Control-Allow-Origin: *\nAccess-Control-Allow-Methods: POST, GET, OPTIONS\nAccess-Control-Allow-Headers: X-PINGOTHER, Content-Type\nAccess-Control-Max-Age: 86400\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>跨域请求默认不会携带Cookie信息，如果需要携带，请配置下述参数：</p>\n<div><pre><code>\"Access-Control-Allow-Credentials\": true\n// Ajax设置\n\"withCredentials\": true\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h4 id=\"方式四-window-name-iframe\"> 方式四：window.name+iframe</h4>\n<p><code>window.name</code>通过在iframe（一般动态创建）中加载跨域HTML文件来起作用。然后，HTML文件将传递给请求者的字符串内容赋值<code>window.name</code>。然后，请求者可以检索<code>window.name</code>值作为响应。</p>\n<ul>\n<li>iframe标签的跨域能力；</li>\n<li><code>window.name</code>属性值在文档刷新后依旧存在的能力（且最大允许2M左右）。</li>\n</ul>\n<p>每个iframe都有包裹它的window，而这个window是top window的子窗口。contentWindow属性返回<code>&lt;iframe&gt;</code>元素的Window对象。你可以使用这个Window对象来访问iframe的文档及其内部DOM。</p>\n<div><pre><code><span>&lt;!-- \n 下述用端口 \n 10000表示：domainA\n 10001表示：domainB\n--></span>\n\n<span>&lt;!-- localhost:10000 --></span>\n<span><span><span>&lt;</span>script</span><span>></span></span><span><span>\n  <span>var</span> iframe <span>=</span> document<span>.</span><span>createElement</span><span>(</span><span>'iframe'</span><span>)</span><span>;</span>\n  iframe<span>.</span>style<span>.</span>display <span>=</span> <span>'none'</span><span>;</span> <span>// 隐藏</span>\n\n  <span>var</span> state <span>=</span> <span>0</span><span>;</span> <span>// 防止页面无限刷新</span>\n  iframe<span>.</span><span>onload</span> <span>=</span> <span>function</span><span>(</span><span>)</span> <span>{</span>\n      <span>if</span><span>(</span>state <span>===</span> <span>1</span><span>)</span> <span>{</span>\n          console<span>.</span><span>log</span><span>(</span><span>JSON</span><span>.</span><span>parse</span><span>(</span>iframe<span>.</span>contentWindow<span>.</span>name<span>)</span><span>)</span><span>;</span>\n          <span>// 清除创建的iframe</span>\n          iframe<span>.</span>contentWindow<span>.</span>document<span>.</span><span>write</span><span>(</span><span>''</span><span>)</span><span>;</span>\n          iframe<span>.</span>contentWindow<span>.</span><span>close</span><span>(</span><span>)</span><span>;</span>\n          document<span>.</span>body<span>.</span><span>removeChild</span><span>(</span>iframe<span>)</span><span>;</span>\n      <span>}</span> <span>else</span> <span>if</span><span>(</span>state <span>===</span> <span>0</span><span>)</span> <span>{</span>\n          state <span>=</span> <span>1</span><span>;</span>\n          <span>// 加载完成，指向当前域，防止错误(proxy.html为空白页面)</span>\n          <span>// Blocked a frame with origin \"http://localhost:10000\" from accessing a cross-origin frame.</span>\n          iframe<span>.</span>contentWindow<span>.</span>location <span>=</span> <span>'http://localhost:10000/proxy.html'</span><span>;</span>\n      <span>}</span>\n  <span>}</span><span>;</span>\n\n  iframe<span>.</span>src <span>=</span> <span>'http://localhost:10001'</span><span>;</span>\n  document<span>.</span>body<span>.</span><span>appendChild</span><span>(</span>iframe<span>)</span><span>;</span>\n</span></span><span><span><span>&lt;/</span>script</span><span>></span></span>\n\n<span>&lt;!-- localhost:10001 --></span>\n<span><span>&lt;!</span><span>DOCTYPE</span> <span>html</span><span>></span></span>\n...\n<span><span><span>&lt;</span>script</span><span>></span></span><span><span>\n  window<span>.</span>name <span>=</span> <span>JSON</span><span>.</span><span>stringify</span><span>(</span><span>{</span>a<span>:</span> <span>1</span><span>,</span> b<span>:</span> <span>2</span><span>}</span><span>)</span><span>;</span>\n</span></span><span><span><span>&lt;/</span>script</span><span>></span></span>\n<span><span><span>&lt;/</span>html</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br></div></div><h4 id=\"方式五-window-postmessage\"> 方式五：window.postMessage()</h4>\n<p>HTML5新特性，可以用来向其他所有的 window 对象发送消息。需要注意的是我们必须要保证所有的脚本执行完才发送 MessageEvent，如果在函数执行的过程中调用了它，就会让后面的函数超时无法执行。</p>\n<p>下述代码实现了跨域存储localStorage</p>\n<div><pre><code><span>&lt;!-- \n 下述用端口 \n 10000表示：domainA\n 10001表示：domainB\n--></span>\n\n<span>&lt;!-- localhost:10000 --></span>\n<span><span><span>&lt;</span>iframe</span> <span>src</span><span><span>=</span><span>\"</span>http://localhost:10001/msg.html<span>\"</span></span> <span>name</span><span><span>=</span><span>\"</span>myPostMessage<span>\"</span></span> <span><span>style</span><span><span>=</span><span>\"</span><span><span>display</span><span>:</span>none<span>;</span></span><span>\"</span></span></span><span>></span></span>\n<span><span><span>&lt;/</span>iframe</span><span>></span></span>\n\n<span><span><span>&lt;</span>script</span><span>></span></span><span><span>\n  <span>function</span> <span>main</span><span>(</span><span>)</span> <span>{</span>\n      <span>LSsetItem</span><span>(</span><span>'test'</span><span>,</span> <span>'Test: '</span> <span>+</span> <span>new</span> <span>Date</span><span>(</span><span>)</span><span>)</span><span>;</span>\n      <span>LSgetItem</span><span>(</span><span>'test'</span><span>,</span> <span>function</span><span>(</span><span>value</span><span>)</span> <span>{</span>\n          console<span>.</span><span>log</span><span>(</span><span>'value: '</span> <span>+</span> value<span>)</span><span>;</span>\n      <span>}</span><span>)</span><span>;</span>\n      <span>LSremoveItem</span><span>(</span><span>'test'</span><span>)</span><span>;</span>\n  <span>}</span>\n\n  <span>var</span> callbacks <span>=</span> <span>{</span><span>}</span><span>;</span>\n  window<span>.</span><span>addEventListener</span><span>(</span><span>'message'</span><span>,</span> <span>function</span><span>(</span><span>event</span><span>)</span> <span>{</span>\n      <span>if</span> <span>(</span>event<span>.</span>source <span>===</span> frames<span>[</span><span>'myPostMessage'</span><span>]</span><span>)</span> <span>{</span>\n          console<span>.</span><span>log</span><span>(</span>event<span>)</span>\n          <span>var</span> data <span>=</span> <span><span>/</span><span>^#localStorage#(\\d+)(null)?#([\\S\\s]*)</span><span>/</span></span><span>.</span><span>exec</span><span>(</span>event<span>.</span>data<span>)</span><span>;</span>\n          <span>if</span> <span>(</span>data<span>)</span> <span>{</span>\n              <span>if</span> <span>(</span>callbacks<span>[</span>data<span>[</span><span>1</span><span>]</span><span>]</span><span>)</span> <span>{</span>\n                  callbacks<span>[</span>data<span>[</span><span>1</span><span>]</span><span>]</span><span>(</span>data<span>[</span><span>2</span><span>]</span> <span>===</span> <span>'null'</span> <span>?</span> <span>null</span> <span>:</span> data<span>[</span><span>3</span><span>]</span><span>)</span><span>;</span>\n              <span>}</span>\n              <span>delete</span> callbacks<span>[</span>data<span>[</span><span>1</span><span>]</span><span>]</span><span>;</span>\n          <span>}</span>\n      <span>}</span>\n  <span>}</span><span>,</span> <span>false</span><span>)</span><span>;</span>\n\n  <span>var</span> domain <span>=</span> <span>'*'</span><span>;</span>\n  <span>// 增加</span>\n  <span>function</span> <span>LSsetItem</span><span>(</span><span>key<span>,</span> value</span><span>)</span> <span>{</span>\n      <span>var</span> obj <span>=</span> <span>{</span>\n          setItem<span>:</span> key<span>,</span>\n          value<span>:</span> value\n      <span>}</span><span>;</span>\n      frames<span>[</span><span>'myPostMessage'</span><span>]</span><span>.</span><span>postMessage</span><span>(</span><span>JSON</span><span>.</span><span>stringify</span><span>(</span>obj<span>)</span><span>,</span> domain<span>)</span><span>;</span>\n  <span>}</span>\n  <span>// 获取</span>\n  <span>function</span> <span>LSgetItem</span><span>(</span><span>key<span>,</span> callback</span><span>)</span> <span>{</span>\n      <span>var</span> identifier <span>=</span> <span>new</span> <span>Date</span><span>(</span><span>)</span><span>.</span><span>getTime</span><span>(</span><span>)</span><span>;</span>\n      <span>var</span> obj <span>=</span> <span>{</span>\n          identifier<span>:</span> identifier<span>,</span>\n          getItem<span>:</span> key\n      <span>}</span><span>;</span>\n      callbacks<span>[</span>identifier<span>]</span> <span>=</span> callback<span>;</span>\n      frames<span>[</span><span>'myPostMessage'</span><span>]</span><span>.</span><span>postMessage</span><span>(</span><span>JSON</span><span>.</span><span>stringify</span><span>(</span>obj<span>)</span><span>,</span> domain<span>)</span><span>;</span>\n  <span>}</span>\n  <span>// 删除</span>\n  <span>function</span> <span>LSremoveItem</span><span>(</span><span>key</span><span>)</span> <span>{</span>\n      <span>var</span> obj <span>=</span> <span>{</span>\n          removeItem<span>:</span> key\n      <span>}</span><span>;</span>\n      frames<span>[</span><span>'myPostMessage'</span><span>]</span><span>.</span><span>postMessage</span><span>(</span><span>JSON</span><span>.</span><span>stringify</span><span>(</span>obj<span>)</span><span>,</span> domain<span>)</span><span>;</span>\n  <span>}</span>\n</span></span><span><span><span>&lt;/</span>script</span><span>></span></span>\n\n<span>&lt;!-- localhost:10001 --></span>\n<span><span><span>&lt;</span>script</span><span>></span></span><span><span>\n  window<span>.</span><span>addEventListener</span><span>(</span><span>'message'</span><span>,</span> <span>function</span><span>(</span><span>event</span><span>)</span> <span>{</span>\n    console<span>.</span><span>log</span><span>(</span><span>'Receiver debugging'</span><span>,</span> event<span>)</span><span>;</span>\n    <span>if</span> <span>(</span>event<span>.</span>origin <span>==</span> <span>'http://localhost:10000'</span><span>)</span> <span>{</span>\n      <span>var</span> data <span>=</span> <span>JSON</span><span>.</span><span>parse</span><span>(</span>event<span>.</span>data<span>)</span><span>;</span>\n      <span>if</span> <span>(</span><span>'setItem'</span> <span>in</span> data<span>)</span> <span>{</span>\n        localStorage<span>.</span><span>setItem</span><span>(</span>data<span>.</span>setItem<span>,</span> data<span>.</span>value<span>)</span><span>;</span>\n      <span>}</span> <span>else</span> <span>if</span> <span>(</span><span>'getItem'</span> <span>in</span> data<span>)</span> <span>{</span>\n        <span>var</span> gotItem <span>=</span> localStorage<span>.</span><span>getItem</span><span>(</span>data<span>.</span>getItem<span>)</span><span>;</span>\n        event<span>.</span>source<span>.</span><span>postMessage</span><span>(</span>\n          <span>'#localStorage#'</span> <span>+</span> data<span>.</span>identifier <span>+</span>\n          <span>(</span>gotItem <span>===</span> <span>null</span> <span>?</span> <span>'null#'</span> <span>:</span> <span>'#'</span> <span>+</span> gotItem<span>)</span><span>,</span>\n          event<span>.</span>origin\n        <span>)</span><span>;</span>\n      <span>}</span> <span>else</span> <span>if</span> <span>(</span><span>'removeItem'</span> <span>in</span> data<span>)</span> <span>{</span>\n        localStorage<span>.</span><span>removeItem</span><span>(</span>data<span>.</span>removeItem<span>)</span><span>;</span>\n      <span>}</span>\n    <span>}</span>\n  <span>}</span><span>,</span> <span>false</span><span>)</span><span>;</span>\n</span></span><span><span><span>&lt;/</span>script</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br></div></div><p>注意Safari一下，会报错：</p>\n<p><strong>Blocked a frame with origin “http://localhost:10001” from accessing a frame with origin “http://localhost:10000“. Protocols, domains, and ports must match.</strong></p>\n<p>避免该错误，可以在Safari浏览器中勾选开发菜单==&gt;停用跨域限制。或者只能使用服务器端转存的方式实现，因为Safari浏览器默认只支持CORS跨域请求。</p>\n<h4 id=\"方式六-修改document-domain跨子域\"> 方式六：修改document.domain跨子域</h4>\n<p>前提条件：这两个域名必须属于同一个基础域名!而且所用的协议，端口都要一致，否则无法利用document.domain进行跨域，所以只能跨子域</p>\n<p>在根域范围内，允许把domain属性的值设置为它的上一级域。例如，在”aaa.xxx.com”域内，可以把domain设置为 “xxx.com” 但不能设置为 “xxx.org” 或者”com”。</p>\n<p>现在存在两个域名aaa.xxx.com和bbb.xxx.com。在aaa下嵌入bbb的页面，由于其document.name不一致，无法在aaa下操作bbb的js。可以在aaa和bbb下通过js将document.name = 'xxx.com';设置一致，来达到互相访问的作用。</p>\n<h4 id=\"方式七-websocket\"> 方式七：WebSocket</h4>\n<p>WebSocket protocol 是HTML5一种新的协议。它实现了浏览器与服务器全双工通信，同时允许跨域通讯，是server push技术的一种很棒的实现。相关文章，请查看：WebSocket、WebSocket-SockJS</p>\n<p>需要注意：WebSocket对象不支持DOM 2级事件侦听器，必须使用DOM 0级语法分别定义各个事件。</p>\n<h4 id=\"方式八-代理\"> 方式八：代理</h4>\n<p>同源策略是针对浏览器端进行的限制，可以通过服务器端来解决该问题</p>\n<p>DomainA客户端（浏览器） ==&gt; DomainA服务器 ==&gt; DomainB服务器 ==&gt; DomainA客户端（浏览器）</p>\n<h3 id=\"_87-说一下jsonp-实现原理\"> 87.说一下JSONP 实现原理?</h3>\n<p>jsonp 即 json+padding，动态创建script标签，利用script标签的src属性可以获取任何域下的js脚本，通过这个特性(也可以说漏洞)，服务器端不在返回json格式，而是返回一段调用某个函数的js代码，在src中进行了调用，这样实现了跨域。</p>\n",
      "date_modified": "2021-02-07T05:08:56.000Z",
      "authors": [
        {
          "name": "南辞"
        }
      ],
      "tags": []
    },
    {
      "title": "模块09—设计模式",
      "url": "http://qiqi.dreamagain.top/interview/Java208/%E6%A8%A1%E5%9D%9709%E2%80%94%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/",
      "id": "http://qiqi.dreamagain.top/interview/Java208/%E6%A8%A1%E5%9D%9709%E2%80%94%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/",
      "content_html": "<h2 id=\"问题\"> 问题：</h2>\n<p>88.说一下你熟悉的设计模式?</p>\n<p>89.简单工厂和抽象工厂有什么区别?</p>\n<h2 id=\"答案\"> 答案：</h2>\n<h3 id=\"_88-说一下你熟悉的设计模式\"> 88.说一下你熟悉的设计模式?</h3>\n<h4 id=\"_1、单例模式\"> 1、单例模式</h4>\n<p>简单点说，就是一个应用程序中，某个类的实例对象只有一个，你没有办法去new，因为构造器是被private修饰的，一般通过getInstance()的方法来获取它们的实例。</p>\n<p>getInstance()的返回值是一个对象的引用，并不是一个新的实例，所以不要错误的理解成多个对象。单例模式实现起来也很容易，直接看demo吧</p>\n<p><strong>① 懒汉式法（线程不安全）</strong></p>\n<div><pre><code><span>public</span> <span>class</span> <span>Singleton</span> <span>{</span>\n\n<span>private</span> <span>static</span> <span>Singleton</span> singleton<span>;</span>\n\n<span>private</span> <span>Singleton</span><span>(</span><span>)</span> <span>{</span>\n<span>}</span>\n\n<span>public</span> <span>static</span> <span>Singleton</span> <span>getInstance</span><span>(</span><span>)</span> <span>{</span>\n <span>if</span> <span>(</span>singleton <span>==</span> <span>null</span><span>)</span> <span>{</span>\n  singleton <span>=</span> <span>new</span> <span>Singleton</span><span>(</span><span>)</span><span>;</span>\n <span>}</span>\n <span>return</span> singleton<span>;</span>\n<span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p><strong>② 懒汉式写法（线程安全）</strong></p>\n<div><pre><code><span>public</span> <span>class</span> <span>Singleton</span> <span>{</span>  \n   <span>private</span> <span>static</span> <span>Singleton</span> instance<span>;</span>  \n   <span>private</span> <span>Singleton</span> <span>(</span><span>)</span><span>{</span><span>}</span>  \n   <span>public</span> <span>static</span> <span>synchronized</span> <span>Singleton</span> <span>getInstance</span><span>(</span><span>)</span> <span>{</span>  \n   <span>if</span> <span>(</span>instance <span>==</span> <span>null</span><span>)</span> <span>{</span>  \n       instance <span>=</span> <span>new</span> <span>Singleton</span><span>(</span><span>)</span><span>;</span>  \n   <span>}</span>  \n   <span>return</span> instance<span>;</span>  \n   <span>}</span>  \n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p><strong>③ 饿汉式写法</strong></p>\n<div><pre><code><span>public</span> <span>class</span> <span>Singleton</span> <span>{</span>  \n \n    <span>private</span> <span>static</span> <span>Singleton</span> instance <span>=</span> <span>new</span> <span>Singleton</span><span>(</span><span>)</span><span>;</span>  \n \n    <span>private</span> <span>Singleton</span> <span>(</span><span>)</span><span>{</span><span>}</span>  \n  \n    <span>public</span> <span>static</span> <span>Singleton</span> <span>getInstance</span><span>(</span><span>)</span> <span>{</span>  \n  \t\t\t<span>return</span> instance<span>;</span>  \n   <span>}</span>  \n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p><strong>④ 静态内部类</strong></p>\n<div><pre><code><span>public</span> <span>class</span> <span>Singleton</span> <span>{</span>  \n    <span>private</span> <span>Singleton</span> <span>(</span><span>)</span><span>{</span><span>}</span>  \n  \n    <span>private</span> <span>static</span> <span>class</span> <span>SingletonHolder</span> <span>{</span>  \n   \t\t<span>private</span> <span>static</span> <span>final</span> <span>Singleton</span> INSTANCE <span>=</span> <span>new</span> <span>Singleton</span><span>(</span><span>)</span><span>;</span>  \n   <span>}</span>  \n   \n    <span>public</span> <span>static</span> <span>final</span> <span>Singleton</span> <span>getInstance</span><span>(</span><span>)</span> <span>{</span>  \n        <span>return</span> <span>SingletonHolder</span><span>.</span>INSTANCE<span>;</span>  \n   <span>}</span>  \n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p><strong>⑤ 枚举</strong></p>\n<div><pre><code><span>public</span> <span>enum</span> <span>Singleton</span> <span>{</span>  \n   INSTANCE<span>;</span>  \n   <span>public</span> <span>void</span> <span>whateverMethod</span><span>(</span><span>)</span> <span>{</span>  \n   <span>}</span>  \n<span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>这种方式是Effective Java作者Josh Bloch 提倡的方式，它不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象，可谓是很坚强的壁垒啊，不过，个人认为由于1.5中才加入enum特性，用这种方式写不免让人感觉生疏。</p>\n<p><strong>⑥ 双重校验锁</strong></p>\n<div><pre><code><span>public</span> <span>class</span> <span>Singleton</span> <span>{</span>  \n   <span>private</span> <span>volatile</span> <span>static</span> <span>Singleton</span> singleton<span>;</span>  \n   <span>private</span> <span>Singleton</span> <span>(</span><span>)</span><span>{</span><span>}</span>  \n   <span>public</span> <span>static</span> <span>Singleton</span> <span>getSingleton</span><span>(</span><span>)</span> <span>{</span>  \n   <span>if</span> <span>(</span>singleton <span>==</span> <span>null</span><span>)</span> <span>{</span>  \n       <span>synchronized</span> <span>(</span><span>Singleton</span><span>.</span><span>class</span><span>)</span> <span>{</span>  \n       <span>if</span> <span>(</span>singleton <span>==</span> <span>null</span><span>)</span> <span>{</span>  \n           singleton <span>=</span> <span>new</span> <span>Singleton</span><span>(</span><span>)</span><span>;</span>  \n       <span>}</span>  \n       <span>}</span>  \n   <span>}</span>  \n   <span>return</span> singleton<span>;</span>  \n   <span>}</span>  \n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p><strong>总结</strong>：我个人比较喜欢静态内部类写法和饿汉式写法，其实这两种写法能够应付绝大多数情况了。其他写法也可以选择，主要还是看业务需求吧。</p>\n<h4 id=\"_2、观察者模式\"> 2、观察者模式</h4>\n<p>对象间一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。</p>\n<p><img src=\"./assets/image-20210110121411458.png\" alt=\"image-20210110121411458\"></p>\n<p>看不懂图的人端着小板凳到这里来，给你举个栗子：假设有三个人，小美（女，22），小王和小李。小美很漂亮，小王和小李是两个程</p>\n<p>序猿，时刻关注着小美的一举一动。有一天，小美说了一句：“谁来陪我打游戏啊。”这句话被小王和小李听到了，结果乐坏了，蹭蹭</p>\n<p>蹭，没一会儿，小王就冲到小美家门口了，在这里，小美是被观察者，小王和小李是观察者，被观察者发出一条信息，然后观察者们进</p>\n<p>行相应的处理，看代码：</p>\n<div><pre><code><span>public</span> <span>interface</span> <span>Person</span> <span>{</span>\n   <span>//小王和小李通过这个接口可以接收到小美发过来的消息</span>\n   <span>void</span> <span>getMessage</span><span>(</span><span>String</span> s<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>这个接口相当于小王和小李的电话号码，小美发送通知的时候就会拨打getMessage这个电话，拨打电话就是调用接口，看不懂没关</p>\n<p>系，先往下看</p>\n<div><pre><code><span>public</span> <span>class</span> <span>LaoWang</span> <span>implements</span> <span>Person</span> <span>{</span>\n\n   <span>private</span> <span>String</span> name <span>=</span> <span>\"小王\"</span><span>;</span>\n\n   <span>public</span> <span>LaoWang</span><span>(</span><span>)</span> <span>{</span>\n   <span>}</span>\n\n   <span>@Override</span>\n   <span>public</span> <span>void</span> <span>getMessage</span><span>(</span><span>String</span> s<span>)</span> <span>{</span>\n       <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>name <span>+</span> <span>\"接到了小美打过来的电话，电话内容是：\"</span> <span>+</span> s<span>)</span><span>;</span>\n   <span>}</span>\n\n<span>}</span>\n\n<span>public</span> <span>class</span> <span>LaoLi</span> <span>implements</span> <span>Person</span> <span>{</span>\n\n   <span>private</span> <span>String</span> name <span>=</span> <span>\"小李\"</span><span>;</span>\n\n   <span>public</span> <span>LaoLi</span><span>(</span><span>)</span> <span>{</span>\n   <span>}</span>\n\n   <span>@Override</span>\n   <span>public</span> <span>void</span> <span>getMessage</span><span>(</span><span>String</span> s<span>)</span> <span>{</span>\n       <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>name <span>+</span> <span>\"接到了小美打过来的电话，电话内容是：->\"</span> <span>+</span> s<span>)</span><span>;</span>\n   <span>}</span>\n\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div><p>代码很简单，我们再看看小美的代码：</p>\n<div><pre><code><span>public</span> <span>class</span> <span>XiaoMei</span> <span>{</span>\n   <span>List</span><span><span>&lt;</span><span>Person</span><span>></span></span> list <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>Person</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n    <span>public</span> <span>XiaoMei</span><span>(</span><span>)</span><span>{</span>\n    <span>}</span>\n\n    <span>public</span> <span>void</span> <span>addPerson</span><span>(</span><span>Person</span> person<span>)</span><span>{</span>\n        list<span>.</span><span>add</span><span>(</span>person<span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>//遍历list，把自己的通知发送给所有暗恋自己的人</span>\n    <span>public</span> <span>void</span> <span>notifyPerson</span><span>(</span><span>)</span> <span>{</span>\n        <span>for</span><span>(</span><span>Person</span> person<span>:</span>list<span>)</span><span>{</span>\n            person<span>.</span><span>getMessage</span><span>(</span><span>\"你们过来吧，谁先过来谁就能陪我一起玩儿游戏!\"</span><span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>我们写一个测试类来看一下结果对不对</p>\n<div><pre><code><span>public</span> <span>class</span> <span>Test</span> <span>{</span>\n   <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n\n       <span>XiaoMei</span> xiao_mei <span>=</span> <span>new</span> <span>XiaoMei</span><span>(</span><span>)</span><span>;</span>\n       <span>LaoWang</span> lao_wang <span>=</span> <span>new</span> <span>LaoWang</span><span>(</span><span>)</span><span>;</span>\n       <span>LaoLi</span> lao_li <span>=</span> <span>new</span> <span>LaoLi</span><span>(</span><span>)</span><span>;</span>\n\n       <span>//小王和小李在小美那里都注册了一下</span>\n       xiao_mei<span>.</span><span>addPerson</span><span>(</span>lao_wang<span>)</span><span>;</span>\n       xiao_mei<span>.</span><span>addPerson</span><span>(</span>lao_li<span>)</span><span>;</span>\n\n       <span>//小美向小王和小李发送通知</span>\n       xiao_mei<span>.</span><span>notifyPerson</span><span>(</span><span>)</span><span>;</span>\n   <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><h4 id=\"_3、装饰者模式\"> 3、装饰者模式</h4>\n<p>对已有的业务逻辑进一步的封装，使其增加额外的功能，如Java中的IO流就使用了装饰者模式，用户在使用的时候，可以任意组装，达</p>\n<p>到自己想要的效果。 举个栗子，我想吃三明治，首先我需要一根大大的香肠，我喜欢吃奶油，在香肠上面加一点奶油，再放一点蔬菜，</p>\n<p>最后再用两片面包夹一下，很丰盛的一顿午饭，营养又健康。那我们应该怎么来写代码呢？ 首先，我们需要写一个Food类，让其他所</p>\n<p>有食物都来继承这个类，看代码：</p>\n<div><pre><code><span>public</span> <span>class</span> <span>Food</span> <span>{</span>\n\n   <span>private</span> <span>String</span> food_name<span>;</span>\n\n   <span>public</span> <span>Food</span><span>(</span><span>)</span> <span>{</span>\n   <span>}</span>\n\n   <span>public</span> <span>Food</span><span>(</span><span>String</span> food_name<span>)</span> <span>{</span>\n       <span>this</span><span>.</span>food_name <span>=</span> food_name<span>;</span>\n   <span>}</span>\n\n   <span>public</span> <span>String</span> <span>make</span><span>(</span><span>)</span> <span>{</span>\n       <span>return</span> food_name<span>;</span>\n   <span>}</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>代码很简单，然后我们写几个子类继承它：</p>\n<div><pre><code><span>//面包类</span>\n<span>public</span> <span>class</span> <span>Bread</span> <span>extends</span> <span>Food</span> <span>{</span>\n\n   <span>private</span> <span>Food</span> basic_food<span>;</span>\n\n   <span>public</span> <span>Bread</span><span>(</span><span>Food</span> basic_food<span>)</span> <span>{</span>\n       <span>this</span><span>.</span>basic_food <span>=</span> basic_food<span>;</span>\n   <span>}</span>\n\n   <span>public</span> <span>String</span> <span>make</span><span>(</span><span>)</span> <span>{</span>\n       <span>return</span> basic_food<span>.</span><span>make</span><span>(</span><span>)</span><span>+</span><span>\"+面包\"</span><span>;</span>\n   <span>}</span>\n<span>}</span>\n\n<span>//奶油类</span>\n<span>public</span> <span>class</span> <span>Cream</span> <span>extends</span> <span>Food</span> <span>{</span>\n\n   <span>private</span> <span>Food</span> basic_food<span>;</span>\n\n   <span>public</span> <span>Cream</span><span>(</span><span>Food</span> basic_food<span>)</span> <span>{</span>\n       <span>this</span><span>.</span>basic_food <span>=</span> basic_food<span>;</span>\n   <span>}</span>\n\n   <span>public</span> <span>String</span> <span>make</span><span>(</span><span>)</span> <span>{</span>\n       <span>return</span> basic_food<span>.</span><span>make</span><span>(</span><span>)</span><span>+</span><span>\"+奶油\"</span><span>;</span>\n   <span>}</span>\n<span>}</span>\n\n<span>//蔬菜类</span>\n<span>public</span> <span>class</span> <span>Vegetable</span> <span>extends</span> <span>Food</span> <span>{</span>\n\n   <span>private</span> <span>Food</span> basic_food<span>;</span>\n\n   <span>public</span> <span>Vegetable</span><span>(</span><span>Food</span> basic_food<span>)</span> <span>{</span>\n       <span>this</span><span>.</span>basic_food <span>=</span> basic_food<span>;</span>\n   <span>}</span>\n\n   <span>public</span> <span>String</span> <span>make</span><span>(</span><span>)</span> <span>{</span>\n       <span>return</span> basic_food<span>.</span><span>make</span><span>(</span><span>)</span><span>+</span><span>\"+蔬菜\"</span><span>;</span>\n   <span>}</span>\n\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br></div></div><p>这几个类都是差不多的，构造方法传入一个Food类型的参数，然后在make方法中加入一些自己的逻辑，如果你还是看不懂为什么这么</p>\n<p>写，不急，你看看我的Test类是怎么写的，一看你就明白了</p>\n<div><pre><code><span>public</span> <span>class</span> <span>Test</span> <span>{</span>\n   <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n       <span>Food</span> food <span>=</span> <span>new</span> <span>Bread</span><span>(</span><span>new</span> <span>Vegetable</span><span>(</span><span>new</span> <span>Cream</span><span>(</span><span>new</span> <span>Food</span><span>(</span><span>\"香肠\"</span><span>)</span><span>)</span><span>)</span><span>)</span><span>;</span>\n       <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>food<span>.</span><span>make</span><span>(</span><span>)</span><span>)</span><span>;</span>\n   <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>看到没有，一层一层封装，我们从里往外看：最里面我new了一个香肠，在香肠的外面我包裹了一层奶油，在奶油的外面我又加了一层</p>\n<p>蔬菜，最外面我放的是面包，是不是很形象，哈哈~ 这个设计模式简直跟现实生活中一摸一样，看懂了吗？ 我们看看运行结果吧</p>\n<p><img src=\"./assets/image-20210110122635076.png\" alt=\"image-20210110122635076\"></p>\n<p>一个三明治就做好了～</p>\n<h4 id=\"_4、适配器模式\"> 4、适配器模式</h4>\n<p>将两种完全不同的事物联系到一起，就像现实生活中的变压器。假设一个手机充电器需要的电压是20V，但是正常的电压是220V，这时</p>\n<p>候就需要一个变压器，将220V的电压转换成20V的电压，这样，变压器就将20V的电压和手机联系起来了。</p>\n<div><pre><code><span>public</span> <span>class</span> <span>Test</span> <span>{</span>\n   <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n       <span>Phone</span> phone <span>=</span> <span>new</span> <span>Phone</span><span>(</span><span>)</span><span>;</span>\n       <span>VoltageAdapter</span> adapter <span>=</span> <span>new</span> <span>VoltageAdapter</span><span>(</span><span>)</span><span>;</span>\n       phone<span>.</span><span>setAdapter</span><span>(</span>adapter<span>)</span><span>;</span>\n       phone<span>.</span><span>charge</span><span>(</span><span>)</span><span>;</span>\n   <span>}</span>\n<span>}</span>\n\n<span>// 手机类</span>\n<span>class</span> <span>Phone</span> <span>{</span>\n\n   <span>public</span> <span>static</span> <span>final</span> <span>int</span> <span>V</span> <span>=</span> <span>220</span><span>;</span><span>// 正常电压220v，是一个常量</span>\n\n   <span>private</span> <span>VoltageAdapter</span> adapter<span>;</span>\n\n   <span>// 充电</span>\n   <span>public</span> <span>void</span> <span>charge</span><span>(</span><span>)</span> <span>{</span>\n       adapter<span>.</span><span>changeVoltage</span><span>(</span><span>)</span><span>;</span>\n   <span>}</span>\n\n   <span>public</span> <span>void</span> <span>setAdapter</span><span>(</span><span>VoltageAdapter</span> adapter<span>)</span> <span>{</span>\n       <span>this</span><span>.</span>adapter <span>=</span> adapter<span>;</span>\n   <span>}</span>\n<span>}</span>\n\n<span>// 变压器</span>\n<span>class</span> <span>VoltageAdapter</span> <span>{</span>\n   <span>// 改变电压的功能</span>\n   <span>public</span> <span>void</span> <span>changeVoltage</span><span>(</span><span>)</span> <span>{</span>\n       <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"正在充电...\"</span><span>)</span><span>;</span>\n       <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"原始电压：\"</span> <span>+</span> <span>Phone<span>.</span>V</span> <span>+</span> <span>\"V\"</span><span>)</span><span>;</span>\n       <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"经过变压器转换之后的电压:\"</span> <span>+</span> <span>(</span><span>Phone<span>.</span>V</span> <span>-</span> <span>200</span><span>)</span> <span>+</span> <span>\"V\"</span><span>)</span><span>;</span>\n   <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br></div></div><p><img src=\"./assets/image-20210110123230431.png\" alt=\"image-20210110123230431\"></p>\n<h4 id=\"_5、工厂模式\"> 5、工厂模式</h4>\n<p>**① 简单工厂模式：**一个抽象的接口，多个抽象接口的实现类，一个工厂类，用来实例化抽象的接口</p>\n<div><pre><code><span>// 抽象产品类</span>\n<span>abstract</span> <span>class</span> <span>Car</span> <span>{</span>\n   <span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span><span>;</span>\n\n   <span>public</span> <span>void</span> <span>stop</span><span>(</span><span>)</span><span>;</span>\n<span>}</span>\n\n<span>// 具体实现类</span>\n<span>class</span> <span>Benz</span> <span>implements</span> <span>Car</span> <span>{</span>\n   <span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span> <span>{</span>\n       <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"Benz开始启动了。。。。。\"</span><span>)</span><span>;</span>\n   <span>}</span>\n\n   <span>public</span> <span>void</span> <span>stop</span><span>(</span><span>)</span> <span>{</span>\n       <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"Benz停车了。。。。。\"</span><span>)</span><span>;</span>\n   <span>}</span>\n<span>}</span>\n\n<span>class</span> <span>Ford</span> <span>implements</span> <span>Car</span> <span>{</span>\n   <span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span> <span>{</span>\n       <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"Ford开始启动了。。。\"</span><span>)</span><span>;</span>\n   <span>}</span>\n\n   <span>public</span> <span>void</span> <span>stop</span><span>(</span><span>)</span> <span>{</span>\n       <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"Ford停车了。。。。\"</span><span>)</span><span>;</span>\n   <span>}</span>\n<span>}</span>\n\n<span>// 工厂类</span>\n<span>class</span> <span>Factory</span> <span>{</span>\n   <span>public</span> <span>static</span> <span>Car</span> <span>getCarInstance</span><span>(</span><span>String</span> type<span>)</span> <span>{</span>\n       <span>Car</span> c <span>=</span> <span>null</span><span>;</span>\n       <span>if</span> <span>(</span><span>\"Benz\"</span><span>.</span><span>equals</span><span>(</span>type<span>)</span><span>)</span> <span>{</span>\n           c <span>=</span> <span>new</span> <span>Benz</span><span>(</span><span>)</span><span>;</span>\n       <span>}</span>\n       <span>if</span> <span>(</span><span>\"Ford\"</span><span>.</span><span>equals</span><span>(</span>type<span>)</span><span>)</span> <span>{</span>\n           c <span>=</span> <span>new</span> <span>Ford</span><span>(</span><span>)</span><span>;</span>\n       <span>}</span>\n       <span>return</span> c<span>;</span>\n   <span>}</span>\n<span>}</span>\n\n<span>public</span> <span>class</span> <span>Test</span> <span>{</span>\n\n   <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n       <span>Car</span> c <span>=</span> <span>Factory</span><span>.</span><span>getCarInstance</span><span>(</span><span>\"Benz\"</span><span>)</span><span>;</span>\n       <span>if</span> <span>(</span>c <span>!=</span> <span>null</span><span>)</span> <span>{</span>\n           c<span>.</span><span>run</span><span>(</span><span>)</span><span>;</span>\n           c<span>.</span><span>stop</span><span>(</span><span>)</span><span>;</span>\n       <span>}</span> <span>else</span> <span>{</span>\n           <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"造不了这种汽车。。。\"</span><span>)</span><span>;</span>\n       <span>}</span>\n\n   <span>}</span>\n\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br></div></div><p>**② 工厂方法模式：**有四个角色，抽象工厂模式，具体工厂模式，抽象产品模式，具体产品模式。不再是由一个工厂类去实例化</p>\n<p>具体的产品，而是由抽象工厂的子类去实例化产品</p>\n<div><pre><code><span>// 抽象产品角色</span>\n<span>public</span> <span>interface</span> <span>Moveable</span> <span>{</span>\n   <span>void</span> <span>run</span><span>(</span><span>)</span><span>;</span>\n<span>}</span>\n\n<span>// 具体产品角色</span>\n<span>public</span> <span>class</span> <span>Plane</span> <span>implements</span> <span>Moveable</span> <span>{</span>\n   <span>@Override</span>\n   <span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span> <span>{</span>\n       <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"plane....\"</span><span>)</span><span>;</span>\n   <span>}</span>\n<span>}</span>\n\n<span>public</span> <span>class</span> <span>Broom</span> <span>implements</span> <span>Moveable</span> <span>{</span>\n   <span>@Override</span>\n   <span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span> <span>{</span>\n       <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"broom.....\"</span><span>)</span><span>;</span>\n   <span>}</span>\n<span>}</span>\n\n<span>// 抽象工厂</span>\n<span>public</span> <span>abstract</span> <span>class</span> <span>VehicleFactory</span> <span>{</span>\n   <span>abstract</span> <span>Moveable</span> <span>create</span><span>(</span><span>)</span><span>;</span>\n<span>}</span>\n\n<span>// 具体工厂</span>\n<span>public</span> <span>class</span> <span>PlaneFactory</span> <span>extends</span> <span>VehicleFactory</span> <span>{</span>\n   <span>public</span> <span>Moveable</span> <span>create</span><span>(</span><span>)</span> <span>{</span>\n       <span>return</span> <span>new</span> <span>Plane</span><span>(</span><span>)</span><span>;</span>\n   <span>}</span>\n<span>}</span>\n\n<span>public</span> <span>class</span> <span>BroomFactory</span> <span>extends</span> <span>VehicleFactory</span> <span>{</span>\n   <span>public</span> <span>Moveable</span> <span>create</span><span>(</span><span>)</span> <span>{</span>\n       <span>return</span> <span>new</span> <span>Broom</span><span>(</span><span>)</span><span>;</span>\n   <span>}</span>\n<span>}</span>\n\n<span>// 测试类</span>\n<span>public</span> <span>class</span> <span>Test</span> <span>{</span>\n   <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n       <span>VehicleFactory</span> factory <span>=</span> <span>new</span> <span>BroomFactory</span><span>(</span><span>)</span><span>;</span>\n       <span>Moveable</span> m <span>=</span> factory<span>.</span><span>create</span><span>(</span><span>)</span><span>;</span>\n       m<span>.</span><span>run</span><span>(</span><span>)</span><span>;</span>\n   <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br></div></div><p>**③ 抽象工厂模式：**与工厂方法模式不同的是，工厂方法模式中的工厂只生产单一的产品，而抽象工厂模式中的工厂生产多个产</p>\n<p>品</p>\n<div><pre><code><span>//抽象工厂类</span>\n<span>public</span> <span>abstract</span> <span>class</span> <span>AbstractFactory</span> <span>{</span>\n   <span>public</span> <span>abstract</span> <span>Vehicle</span> <span>createVehicle</span><span>(</span><span>)</span><span>;</span>\n   <span>public</span> <span>abstract</span> <span>Weapon</span> <span>createWeapon</span><span>(</span><span>)</span><span>;</span>\n   <span>public</span> <span>abstract</span> <span>Food</span> <span>createFood</span><span>(</span><span>)</span><span>;</span>\n<span>}</span>\n<span>//具体工厂类，其中Food,Vehicle，Weapon是抽象类，</span>\n<span>public</span> <span>class</span> <span>DefaultFactory</span> <span>extends</span> <span>AbstractFactory</span><span>{</span>\n   <span>@Override</span>\n   <span>public</span> <span>Food</span> <span>createFood</span><span>(</span><span>)</span> <span>{</span>\n       <span>return</span> <span>new</span> <span>Apple</span><span>(</span><span>)</span><span>;</span>\n   <span>}</span>\n   <span>@Override</span>\n   <span>public</span> <span>Vehicle</span> <span>createVehicle</span><span>(</span><span>)</span> <span>{</span>\n       <span>return</span> <span>new</span> <span>Car</span><span>(</span><span>)</span><span>;</span>\n   <span>}</span>\n   <span>@Override</span>\n   <span>public</span> <span>Weapon</span> <span>createWeapon</span><span>(</span><span>)</span> <span>{</span>\n       <span>return</span> <span>new</span> <span>AK47</span><span>(</span><span>)</span><span>;</span>\n   <span>}</span>\n<span>}</span>\n<span>//测试类</span>\n<span>public</span> <span>class</span> <span>Test</span> <span>{</span>\n   <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n       <span>AbstractFactory</span> f <span>=</span> <span>new</span> <span>DefaultFactory</span><span>(</span><span>)</span><span>;</span>\n       <span>Vehicle</span> v <span>=</span> f<span>.</span><span>createVehicle</span><span>(</span><span>)</span><span>;</span>\n       v<span>.</span><span>run</span><span>(</span><span>)</span><span>;</span>\n       <span>Weapon</span> w <span>=</span> f<span>.</span><span>createWeapon</span><span>(</span><span>)</span><span>;</span>\n       w<span>.</span><span>shoot</span><span>(</span><span>)</span><span>;</span>\n       <span>Food</span> a <span>=</span> f<span>.</span><span>createFood</span><span>(</span><span>)</span><span>;</span>\n       a<span>.</span><span>printName</span><span>(</span><span>)</span><span>;</span>\n   <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br></div></div><h4 id=\"_6、代理模式-proxy\"> 6、代理模式（proxy）</h4>\n<p>代理模式有两种，静态代理和动态代理。</p>\n<p><strong>静态代理：</strong></p>\n<p>到了一定的年龄，我们就要结婚，结婚是一件很麻烦的事情，（包括那些被父母催婚的）。有钱的家庭可能会找司仪来主持婚礼，显得</p>\n<p>热闹，洋气～好了，现在婚庆公司的生意来了，我们只需要给钱，婚庆公司就会帮我们安排一整套结婚的流程。整个流程大概是这样</p>\n<p>的：家里人催婚-&gt;男女双方家庭商定结婚的黄道即日-&gt;找一家靠谱的婚庆公司-&gt;在约定的时间举行结婚仪式-&gt;结婚完毕</p>\n<p>婚庆公司打算怎么安排婚礼的节目，在婚礼完毕以后婚庆公司会做什么，我们一概不知。。。别担心，不是黑中介，我们只要把钱给人</p>\n<p>家，人家会把事情给我们做好。所以，这里的婚庆公司相当于代理角色，现在明白什么是代理角色了吧。</p>\n<p>代理接口代码：</p>\n<div><pre><code><span>//代理接口</span>\n<span>public</span> <span>interface</span> <span>ProxyInterface</span> <span>{</span>\n<span>//需要代理的是结婚这件事，如果还有其他事情需要代理，比如吃饭睡觉上厕所，也可以写</span>\n<span>void</span> <span>marry</span><span>(</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>婚庆公司的代码:</p>\n<div><pre><code><span>public</span> <span>class</span> <span>WeddingCompany</span> <span>implements</span> <span>ProxyInterface</span> <span>{</span>\n\n<span>private</span> <span>ProxyInterface</span> proxyInterface<span>;</span>\n\n<span>public</span> <span>WeddingCompany</span><span>(</span><span>ProxyInterface</span> proxyInterface<span>)</span> <span>{</span>\n <span>this</span><span>.</span>proxyInterface <span>=</span> proxyInterface<span>;</span>\n<span>}</span>\n\n<span>@Override</span>\n<span>public</span> <span>void</span> <span>marry</span><span>(</span><span>)</span> <span>{</span>\n <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"我们是婚庆公司的\"</span><span>)</span><span>;</span>\n <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"我们在做结婚前的准备工作\"</span><span>)</span><span>;</span>\n <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"节目彩排...\"</span><span>)</span><span>;</span>\n <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"礼物购买...\"</span><span>)</span><span>;</span>\n <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"工作人员分工...\"</span><span>)</span><span>;</span>\n <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"可以开始结婚了\"</span><span>)</span><span>;</span>\n proxyInterface<span>.</span><span>marry</span><span>(</span><span>)</span><span>;</span>\n <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"结婚完毕，我们需要做后续处理，你们可以回家了，其余的事情我们公司来做\"</span><span>)</span><span>;</span>\n<span>}</span>\n\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><p>看到没有，婚庆公司需要做的事情很多，我们再看看结婚家庭的代码:</p>\n<div><pre><code><span>public</span> <span>class</span> <span>NormalHome</span> <span>implements</span> <span>ProxyInterface</span><span>{</span>\n\n    <span>@Override</span>\n    <span>public</span> <span>void</span> <span>marry</span><span>(</span><span>)</span> <span>{</span>\n     \t<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"我们结婚啦～\"</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>这个已经很明显了，结婚家庭只需要结婚，而婚庆公司要包揽一切，前前后后的事情都是婚庆公司来做，听说现在婚庆公司很赚钱的，</p>\n<p>这就是原因，干的活多，能不赚钱吗？</p>\n<p>来看看测试类代码：</p>\n<div><pre><code><span>public</span> <span>class</span> <span>Test</span> <span>{</span>\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n         <span>ProxyInterface</span> proxyInterface <span>=</span> <span>new</span> <span>WeddingCompany</span><span>(</span><span>new</span> <span>NormalHome</span><span>(</span><span>)</span><span>)</span><span>;</span>\n         proxyInterface<span>.</span><span>marry</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p><img src=\"./assets/image-20210110124934337.png\" alt=\"image-20210110124934337\"></p>\n<blockquote>\n<h3 id=\"_89-简单工厂和抽象工厂有什么区别\"> 89.简单工厂和抽象工厂有什么区别?</h3>\n</blockquote>\n<p><strong>简单工厂模式</strong>：</p>\n<p>这个模式本身很简单而且使用在业务较简单的情况下。一般用于小项目或者具体产品很少扩展的情况（这样工厂类才不用经常更改）。</p>\n<p>它由三种角色组成：</p>\n<ul>\n<li>工厂类角色：这是本模式的核心，含有一定的商业逻辑和判断逻辑，根据逻辑不同，产生具体的工厂产品。如例子中的Driver类。</li>\n<li>抽象产品角色：它一般是具体产品继承的父类或者实现的接口。由接口或者抽象类来实现。如例中的Car接口。</li>\n<li>具体产品角色：工厂类所创建的对象就是此角色的实例。在java中由一个具体类实现，如例子中的Benz、Bmw类。</li>\n</ul>\n<p>用类图来清晰的表示下的它们之间的关系：</p>\n<p><img src=\"./assets/image-20210110125152216.png\" alt=\"image-20210110125152216\"></p>\n<p><strong>抽象工厂模式：</strong></p>\n<p>先来认识下什么是产品族： 位于不同产品等级结构中，功能相关联的产品组成的家族。</p>\n<p><img src=\"./assets/image-20210110125238563.png\" alt=\"image-20210110125238563\"></p>\n<p>图中的BmwCar和BenzCar就是两个产品树（产品层次结构）；而如图所示的BenzSportsCar和BmwSportsCar就是一个产品族。他们都可以放到跑车家族中，因此功能有所关联。同理BmwBussinessCar和BenzBusinessCar也是一个产品族。</p>\n<p><strong>可以这么说，它和工厂方法模式的区别就在于需要创建对象的复杂程度上。而且抽象工厂模式是三个里面最为抽象、最具一般性的。抽象工厂模式的用意为：给客户端提供一个接口，可以创建多个产品族中的产品对象。</strong></p>\n<p>而且使用抽象工厂模式还要满足一下条件：</p>\n<ol>\n<li>系统中有多个产品族，而系统一次只可能消费其中一族产品</li>\n<li>同属于同一个产品族的产品以其使用。</li>\n</ol>\n<p>来看看抽象工厂模式的各个角色（和工厂方法的如出一辙）：</p>\n<ul>\n<li>抽象工厂角色： 这是工厂方法模式的核心，它与应用程序无关。是具体工厂角色必须实现的接口或者必须继承的父类。在java中它由抽象类或者接口来实现。</li>\n<li>具体工厂角色：它含有和具体业务逻辑有关的代码。由应用程序调用以创建对应的具体产品的对象。在java中它由具体的类来实现。</li>\n<li>抽象产品角色：它是具体产品继承的父类或者是实现的接口。在java中一般有抽象类或者接口来实现。</li>\n<li>具体产品角色：具体工厂角色所创建的对象就是此角色的实例。在java中由具体的类来实现。</li>\n</ul>\n",
      "date_modified": "2021-02-07T05:08:56.000Z",
      "authors": [
        {
          "name": "南辞"
        }
      ],
      "tags": []
    },
    {
      "title": "模块10—Spring/Spring MVC",
      "url": "http://qiqi.dreamagain.top/interview/Java208/%E6%A8%A1%E5%9D%9710%E2%80%94SpringSpring%20MVC/",
      "id": "http://qiqi.dreamagain.top/interview/Java208/%E6%A8%A1%E5%9D%9710%E2%80%94SpringSpring%20MVC/",
      "content_html": "<h2 id=\"问题\"> 问题：</h2>\n<p>90.为什么要使用Spring?</p>\n<p>91.解释一下什么是AOP?</p>\n<p>92.解释一下什么是IoC?</p>\n<p>93.Spring有哪些主要模块?</p>\n<p>94.Spring 常用的注入方式有哪些?</p>\n<p>95.Spring 中的 bean是线程安全的吗?</p>\n<p>96.Spring支持几种bean的作用域?</p>\n<p>97.Spring自动装配bean有哪些方式?</p>\n<p>98.Spring事务实现方式有哪些?</p>\n<p>99.说一下Spring 的事务隔离?</p>\n<p>100.说一下Spring MVC运行流程?</p>\n<p>101.Spring MVC有哪些组件?</p>\n<p>102.@RequestMapping 的作用是什么?</p>\n<p>103.@Autowired的作用是什么?</p>\n<h2 id=\"答案\"> 答案：</h2>\n<h3 id=\"_90-为什么要使用spring\"> 90.为什么要使用Spring?</h3>\n<p><strong>1.简介</strong></p>\n<ul>\n<li>目的：解决企业应用开发的复杂性</li>\n<li>功能：使用基本的JavaBean代替EJB，并提供了更多的企业应用功能</li>\n<li>范围：任何Java应用</li>\n</ul>\n<p>简单来说，Spring是一个轻量级的控制反转(IoC)和面向切面(AOP)的容器框架。</p>\n<p><strong>2.轻量</strong></p>\n<p>从大小与开销两方面而言Spring都是轻量的。完整的Spring框架可以在一个大小只有1MB多的 jar文件里发布。并且Spring所需的处理</p>\n<p>开销也是微不足道的。此外，Spring是非侵入式的：典型地，Spring应用中的对象不依赖于Spring的特定类。</p>\n<p><strong>3.控制反转</strong></p>\n<p>Spring通过一种称作控制反转（IoC）的技术促进了松耦合。当应用了IoC，一个对象依赖的其它对象会通过被动的方式传递进来，而不</p>\n<p>是这个对象自己创建或者查找依赖对象。你可以认为IoC与JNDI相反——不是对象从容器中查找依赖，而是容器在对象初始化时不等对</p>\n<p>象请求就主动将依赖传递给它。</p>\n<p><strong>4.面向切面</strong></p>\n<p>Spring提供了面向切面编程的丰富支持，允许通过分离应用的业务逻辑与系统级服务（例如审计（auditing）和事务（transaction）管</p>\n<p>理）进行内聚性的开发。应用对象只实现它们应该做的——完成业务逻辑——仅此而已。它们并不负责（甚至是意识）其它的系统级关</p>\n<p>注点，例如日志或事务支持。</p>\n<p><strong>5.容器</strong></p>\n<p>Spring包含并管理应用对象的配置和生命周期，在这个意义上它是一种容器，你可以配置你的每个bean如何被创建——基于一个可配置</p>\n<p>原型（prototype），你的bean可以创建一个单独的实例或者每次需要时都生成一个新的实例——以及它们是如何相互关联的。然而，</p>\n<p>Spring不应该被混同于传统的重量级的EJB容器，它们经常是庞大与笨重的，难以使用。</p>\n<p><strong>6.框架</strong></p>\n<p>Spring可以将简单的组件配置、组合成为复杂的应用。在Spring中，应用对象被声明式地组合，典型地是在一个XML文件里。Spring也</p>\n<p>提供了很多基础功能（事务管理、持久化框架集成等等），将应用逻辑的开发留给了你。所有Spring的这些特征使你能够编写更干净、</p>\n<p>更可管理、并且更易于测试的代码。它们也为Spring中的各种模块提供了基础支持。</p>\n<h3 id=\"_91-解释一下什么是aop\"> 91.解释一下什么是AOP?</h3>\n<p>AOP（Aspect-Oriented Programming，面向方面编程），可以说是OOP（Object-Oriented Programing，面向对象编程）的补充和完善。OOP引入封装、继承和多态性等概念来建立一种对象层次结构，用以模拟公共行为的一个集合。当我们需要为分散的对象引入公共行为的时候，OOP则显得无能为力。也就是说，OOP允许你定义从上到下的关系，但并不适合定义从左到右的关系。例如日志功能。日志代码往往水平地散布在所有对象层次中，而与它所散布到的对象的核心功能毫无关系。对于其他类型的代码，如安全性、异常处理和透明的持续性也是如此。这种散布在各处的无关的代码被称为横切（cross-cutting）代码，在OOP设计中，它导致了大量代码的重复，而不利于各个模块的重用。</p>\n<p>而AOP技术则恰恰相反，它利用一种称为“横切”的技术，剖解开封装的对象内部，并将那些影响了多个类的公共行为封装到一个可重用模块，并将其名为“Aspect”，即方面。所谓“方面”，简单地说，就是将那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可操作性和可维护性。AOP代表的是一个横向的关系，如果说“对象”是一个空心的圆柱体，其中封装的是对象的属性和行为；那么面向方面编程的方法，就仿佛一把利刃，将这些空心圆柱体剖开，以获得其内部的消息。而剖开的切面，也就是所谓的“方面”了。然后它又以巧夺天功的妙手将这些剖开的切面复原，不留痕迹。</p>\n<p>使用“横切”技术，AOP把软件系统分为两个部分：核心关注点和横切关注点。业务处理的主要流程是核心关注点，与之关系不大的部分是横切关注点。横切关注点的一个特点是，他们经常发生在核心关注点的多处，而各处都基本相似。比如权限认证、日志、事务处理。Aop 的作用在于分离系统中的各种关注点，将核心关注点和横切关注点分离开来。正如Avanade公司的高级方案构架师Adam Magee所说，AOP的核心思想就是“将应用程序中的商业逻辑同对其提供支持的通用服务进行分离。”</p>\n<h3 id=\"_92-解释一下什么是ioc\"> 92.解释一下什么是IoC?</h3>\n<p>IOC是Inversion of Control的缩写，多数书籍翻译成“控制反转”。</p>\n<p>1996年，Michael Mattson在一篇有关探讨面向对象框架的文章中，首先提出了IOC 这个概念。对于面向对象设计及编程的基本思想，前面我们已经讲了很多了，不再赘述，简单来说就是把复杂系统分解成相互合作的对象，这些对象类通过封装以后，内部实现对外部是透明的，从而降低了解决问题的复杂度，而且可以灵活地被重用和扩展。</p>\n<p>IOC理论提出的观点大体是这样的：借助于“第三方”实现具有依赖关系的对象之间的解耦。如下图：</p>\n<p><img src=\"./assets/java-05.png\" alt=\"\"></p>\n<p>大家看到了吧，由于引进了中间位置的“第三方”，也就是IOC容器，使得A、B、C、D这4个对象没有了耦合关系，齿轮之间的传动全部依靠“第三方”了，全部对象的控制权全部上缴给“第三方”IOC容器，所以，IOC容器成了整个系统的关键核心，它起到了一种类似“粘合剂”的作用，把系统中的所有对象粘合在一起发挥作用，如果没有这个“粘合剂”，对象与对象之间会彼此失去联系，这就是有人把IOC容器比喻成“粘合剂”的由来。</p>\n<p>我们再来做个试验：把上图中间的IOC容器拿掉，然后再来看看这套系统：</p>\n<p><img src=\"./assets/java-06.png\" alt=\"\"></p>\n<p>我们现在看到的画面，就是我们要实现整个系统所需要完成的全部内容。这时候，A、B、C、D这4个对象之间已经没有了耦合关系，彼</p>\n<p>此毫无联系，这样的话，当你在实现A的时候，根本无须再去考虑B、C和D了，对象之间的依赖关系已经降低到了最低程度。所以，如</p>\n<p>果真能实现IOC容器，对于系统开发而言，这将是一件多么美好的事情，参与开发的每一成员只要实现自己的类就可以了，跟别人没有</p>\n<p>任何关系！</p>\n<p><strong>我们再来看看，控制反转(IOC)到底为什么要起这么个名字？我们来对比一下：</strong></p>\n<p>软件系统在没有引入IOC容器之前，如图1所示，对象A依赖于对象B，那么对象A在初始化或者运行到某一点的时候，自己必须主动去创建对象B或者使用已经创建的对象B。无论是创建还是使用对象B，控制权都在自己手上。</p>\n<p>软件系统在引入IOC容器之后，这种情形就完全改变了，如图3所示，由于IOC容器的加入，对象A与对象B之间失去了直接联系，所以，当对象A运行到需要对象B的时候，IOC容器会主动创建一个对象B注入到对象A需要的地方。</p>\n<p>通过前后的对比，我们不难看出来：对象A获得依赖对象B的过程,由主动行为变为了被动行为，控制权颠倒过来了，这就是“控制反转”这个名称的由来。</p>\n<h3 id=\"_93-spring有哪些主要模块\"> 93.Spring有哪些主要模块?</h3>\n<p>Spring框架至今已集成了20多个模块。这些模块主要被分如下图所示的核心容器、数据访问/集成,、Web、AOP（面向切面编程）、工</p>\n<p>具、消息和测试模块。</p>\n<p><img src=\"./assets/java-07.png\" alt=\"\"></p>\n<h3 id=\"_94-spring-常用的注入方式有哪些\"> 94.Spring 常用的注入方式有哪些?</h3>\n<p>Spring通过DI（依赖注入）实现IOC（控制反转），常用的注入方式主要有三种：</p>\n<ol>\n<li>构造方法注入</li>\n<li>setter注入</li>\n<li>基于注解的注入</li>\n</ol>\n<h3 id=\"_95-spring-中的-bean是线程安全的吗\"> 95.Spring 中的 bean是线程安全的吗?</h3>\n<p>Spring容器中的Bean是否线程安全，容器本身并没有提供Bean的线程安全策略，因此可以说spring容器中的Bean本身不具备线程安全</p>\n<p>的特性，但是具体还是要结合具体scope的Bean去研究。</p>\n<h3 id=\"_96-spring支持几种bean的作用域\"> 96.Spring支持几种bean的作用域?</h3>\n<p>当通过spring容器创建一个Bean实例时，不仅可以完成Bean实例的实例化，还可以为Bean指定特定的作用域。Spring支持如下5种作用域：</p>\n<ul>\n<li>**singleton：**单例模式，在整个Spring IoC容器中，使用singleton定义的Bean将只有一个实例</li>\n<li>**prototype：**原型模式，每次通过容器的getBean方法获取prototype定义的Bean时，都将产生一个新的Bean实例</li>\n<li>**request：**对于每次HTTP请求，使用request定义的Bean都将产生一个新实例，即每次HTTP请求将会产生不同的Bean实例。只有在Web应用中使用Spring时，该作用域才有效</li>\n<li>**session：**对于每次HTTP Session，使用session定义的Bean豆浆产生一个新实例。同样只有在Web应用中使用Spring时，该作用域才有效</li>\n<li>**globalsession：**每个全局的HTTP Session，使用session定义的Bean都将产生一个新实例。典型情况下，仅在使用portlet context的时候有效。同样只有在Web应用中使用Spring时，该作用域才有效</li>\n</ul>\n<p>其中比较常用的是singleton和prototype两种作用域。对于singleton作用域的Bean，每次请求该Bean都将获得相同的实例。容器负责跟踪Bean实例的状态，负责维护Bean实例的生命周期行为；如果一个Bean被设置成prototype作用域，程序每次请求该id的Bean，Spring都会新建一个Bean实例，然后返回给程序。在这种情况下，Spring容器仅仅使用new 关键字创建Bean实例，一旦创建成功，容器不在跟踪实例，也不会维护Bean实例的状态。</p>\n<p>如果不指定Bean的作用域，Spring默认使用singleton作用域。Java在创建Java实例时，需要进行内存申请；销毁实例时，需要完成垃圾回收，这些工作都会导致系统开销的增加。因此，prototype作用域Bean的创建、销毁代价比较大。而singleton作用域的Bean实例一旦创建成功，可以重复使用。因此，除非必要，否则尽量避免将Bean被设置成prototype作用域。</p>\n<h3 id=\"_97-spring自动装配bean有哪些方式\"> 97.Spring自动装配bean有哪些方式?</h3>\n<p>Spring容器负责创建应用程序中的bean同时通过ID来协调这些对象之间的关系。作为开发人员，我们需要告诉Spring要创建哪些bean并且如何将其装配到一起。</p>\n<p>spring中bean装配有两种方式：</p>\n<ul>\n<li>隐式的bean发现机制和自动装配</li>\n<li>在java代码或者XML中进行显示配置</li>\n</ul>\n<p>当然这些方式也可以配合使用。</p>\n<h3 id=\"_98-spring事务实现方式有哪些\"> 98.Spring事务实现方式有哪些?</h3>\n<ol>\n<li>编程式事务管理对基于 POJO 的应用来说是唯一选择。我们需要在代码中调用beginTransaction()、commit()、rollback()等事务管理相关的方法，这就是编程式事务管理。</li>\n<li>基于 TransactionProxyFactoryBean 的声明式事务管理</li>\n<li>基于 @Transactional 的声明式事务管理</li>\n<li>基于 Aspectj AOP 配置事务</li>\n</ol>\n<h3 id=\"_99-说一下spring-的事务隔离\"> 99.说一下Spring 的事务隔离?</h3>\n<p>事务隔离级别指的是一个事务对数据的修改与另一个并行的事务的隔离程度，当多个事务同时访问相同数据时，如果没有采取必要的隔离机制，就可能发生以下问题：</p>\n<ul>\n<li>脏读：一个事务读到另一个事务未提交的更新数据。</li>\n<li>幻读：例如第一个事务对一个表中的数据进行了修改，比如这种修改涉及到表中的“全部数据行”。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入“一行新数据”。那么，以后就会发生操作第一个事务的用户发现表中还存在没有修改的数据行，就好象发生了幻觉一样。</li>\n<li>不可重复读：比方说在同一个事务中先后执行两条一模一样的select语句，期间在此次事务中没有执行过任何DDL语句，但先后得到的结果不一致，这就是不可重复读。</li>\n</ul>\n<h3 id=\"_100-说一下spring-mvc运行流程\"> 100.说一下Spring MVC运行流程?</h3>\n<p><strong>Spring MVC运行流程图：</strong></p>\n<p><img src=\"./assets/java-08.png\" alt=\"\"></p>\n<p><strong>Spring运行流程描述：</strong></p>\n<ol>\n<li>\n<p>用户向服务器发送请求，请求被Spring 前端控制Servelt DispatcherServlet捕获；</p>\n</li>\n<li>\n<p>DispatcherServlet对请求URL进行解析，得到请求资源标识符（URI）。然后根据该URI，调用HandlerMapping获得该Handler配置的所有相关的对象（包括Handler对象以及Handler对象对应的拦截器），最后以HandlerExecutionChain对象的形式返回；</p>\n</li>\n<li>\n<p>DispatcherServlet 根据获得的Handler，选择一个合适的HandlerAdapter；（附注：如果成功获得HandlerAdapter后，此时将开始执行拦截器的preHandler(...)方法）</p>\n</li>\n<li>\n<p>提取Request中的模型数据，填充Handler入参，开始执行Handler（Controller)。 在填充Handler的入参过程中，根据你的配置，Spring将帮你做一些额外的工作：</p>\n<ul>\n<li>HttpMessageConveter： 将请求消息（如Json、xml等数据）转换成一个对象，将对象转换为指定的响应信息</li>\n<li>数据转换：对请求消息进行数据转换。如String转换成Integer、Double等</li>\n<li>数据根式化：对请求消息进行数据格式化。 如将字符串转换成格式化数字或格式化日期等</li>\n<li>数据验证： 验证数据的有效性（长度、格式等），验证结果存储到BindingResult或Error中</li>\n</ul>\n</li>\n<li>\n<p>Handler执行完成后，向DispatcherServlet 返回一个ModelAndView对象；</p>\n</li>\n<li>\n<p>根据返回的ModelAndView，选择一个适合的ViewResolver（必须是已经注册到Spring容器中的ViewResolver)返回给DispatcherServlet ；</p>\n</li>\n<li>\n<p>ViewResolver 结合Model和View，来渲染视图；</p>\n</li>\n<li>\n<p>将渲染结果返回给客户端。</p>\n</li>\n</ol>\n<h3 id=\"_101-spring-mvc有哪些组件\"> 101.Spring MVC有哪些组件?</h3>\n<p>Spring MVC的核心组件：</p>\n<ol>\n<li>DispatcherServlet：中央控制器，把请求给转发到具体的控制类</li>\n<li>Controller：具体处理请求的控制器</li>\n<li>HandlerMapping：映射处理器，负责映射中央处理器转发给controller时的映射策略</li>\n<li>ModelAndView：服务层返回的数据和视图层的封装类</li>\n<li>ViewResolver：视图解析器，解析具体的视图</li>\n<li>Interceptors ：拦截器，负责拦截我们定义的请求然后做处理工作</li>\n</ol>\n<h3 id=\"_102-requestmapping-的作用是什么\"> 102.@RequestMapping 的作用是什么?</h3>\n<p>RequestMapping是一个用来处理请求地址映射的注解，可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。</p>\n<p>RequestMapping注解有六个属性，下面我们把它分成三类进行说明。</p>\n<p><strong>value， method：</strong></p>\n<ul>\n<li>value：指定请求的实际地址，指定的地址可以是URI Template 模式（后面将会说明）；</li>\n<li>method：指定请求的method类型， GET、POST、PUT、DELETE等；</li>\n</ul>\n<p><strong>consumes，produces</strong></p>\n<ul>\n<li>consumes：指定处理请求的提交内容类型（Content-Type），例如application/json, text/html；</li>\n<li>produces：指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回；</li>\n</ul>\n<p><strong>params，headers</strong></p>\n<ul>\n<li>params： 指定request中必须包含某些参数值是，才让该方法处理。</li>\n<li>headers：指定request中必须包含某些指定的header值，才能让该方法处理请求。</li>\n</ul>\n<h3 id=\"_103-autowired的作用是什么\"> 103.@Autowired的作用是什么?</h3>\n<p>@Autowired 是一个注解，它可以对类成员变量、方法及构造函数进行标注，让 spring 完成 bean 自动装配的工作。</p>\n<p>@Autowired 默认是按照类去匹配，配合 @Qualifier 指定按照名称去装配 bean。</p>\n<p>常见用法</p>\n<div><pre><code><span>import</span> <span>org<span>.</span>springframework<span>.</span>beans<span>.</span>factory<span>.</span>annotation<span>.</span></span><span>Autowired</span><span>;</span>\n<span>import</span> <span>org<span>.</span>springframework<span>.</span>stereotype<span>.</span></span><span>Controller</span><span>;</span>\n \n<span>import</span> <span>blog<span>.</span>service<span>.</span></span><span>ArticleService</span><span>;</span>\n<span>import</span> <span>blog<span>.</span>service<span>.</span></span><span>TagService</span><span>;</span>\n<span>import</span> <span>blog<span>.</span>service<span>.</span></span><span>TypeService</span><span>;</span>\n \n<span>@Controller</span>\n<span>public</span> <span>class</span> <span>TestController</span> <span>{</span>\n \n\t<span>//成员属性字段使用 @Autowired，无需字段的 set 方法</span>\n\t<span>@Autowired</span>\n\t<span>private</span> <span>TypeService</span> typeService<span>;</span>\n\t\n\t\n\t<span>//set 方法使用 @Autowired</span>\n\t<span>private</span> <span>ArticleService</span> articleService<span>;</span>\n\t<span>@Autowired</span>\n\t<span>public</span> <span>void</span> <span>setArticleService</span><span>(</span><span>ArticleService</span> articleService<span>)</span> <span>{</span>\n\t\t<span>this</span><span>.</span>articleService <span>=</span> articleService<span>;</span>\n\t<span>}</span>\n \n\t<span>//构造方法使用 @Autowired</span>\n\t<span>private</span> <span>TagService</span> tagService<span>;</span>\n\t<span>@Autowired</span>\n\t<span>public</span> <span>TestController</span><span>(</span><span>TagService</span> tagService<span>)</span> <span>{</span>\n\t\t<span>this</span><span>.</span>tagService <span>=</span> tagService<span>;</span> \n\t<span>}</span>\n\t\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br></div></div>",
      "date_modified": "2021-02-07T05:08:56.000Z",
      "authors": [
        {
          "name": "南辞"
        }
      ],
      "tags": []
    },
    {
      "title": "模块11—Spring Boot/Spring Cloud",
      "url": "http://qiqi.dreamagain.top/interview/Java208/%E6%A8%A1%E5%9D%9711%E2%80%94Spring%20BootSpring%20Cloud/",
      "id": "http://qiqi.dreamagain.top/interview/Java208/%E6%A8%A1%E5%9D%9711%E2%80%94Spring%20BootSpring%20Cloud/",
      "content_html": "<h2 id=\"问题\"> 问题：</h2>\n<p>104.什么是Spring Boot?</p>\n<p>105.为什么要用Spring Boot?</p>\n<p>106.Spring Boot核心配置文件是什么?</p>\n<p>107.Spring Boot配置文件有哪几种类型?它们有什么区别?</p>\n<p>108.Spring Boot有哪些方式可以实现热部署?</p>\n<p>109.jpa和hibernate有什么区别?</p>\n<p>110.什么是 Spring Cloud?</p>\n<p>111.Spring Cloud 断路器的作用是什么?</p>\n<p>112.Spring Cloud的核心组件有哪些?</p>\n<h2 id=\"答案\"> 答案：</h2>\n<h3 id=\"_104-什么是spring-boot\"> 104.什么是Spring Boot?</h3>\n<p>在Spring框架这个大家族中，产生了很多衍生框架，比如 Spring、SpringMvc框架等，Spring的核心内容在于控制反转(IOC)和依赖注入(DI),所谓控制反转并非是一种技术，而是一种思想，在操作方面是指在spring配置文件中创建<bean>，依赖注入即为由spring容器为应用程序的某个对象提供资源，比如 引用对象、常量数据等。</p>\n<p>Spring Boot是一个框架，一种全新的编程规范，他的产生简化了框架的使用，所谓简化是指简化了Spring众多框架中所需的大量且繁琐的配置文件，所以 Spring Boot是一个服务于框架的框架，服务范围是简化配置文件。</p>\n<h3 id=\"_105-为什么要用spring-boot\"> 105.为什么要用Spring Boot?</h3>\n<ul>\n<li>Spring Boot使编码变简单</li>\n<li>Spring Boot使配置变简单</li>\n<li>Spring Boot使部署变简单</li>\n<li>Spring Boot使监控变简单</li>\n<li>Spring的不足</li>\n</ul>\n<h3 id=\"_106-spring-boot核心配置文件是什么\"> 106.Spring Boot核心配置文件是什么?</h3>\n<p>Spring Boot提供了两种常用的配置文件：</p>\n<ul>\n<li>properties文件</li>\n<li>yml文件</li>\n</ul>\n<h3 id=\"_107-spring-boot配置文件有哪几种类型-它们有什么区别\"> 107.Spring Boot配置文件有哪几种类型?它们有什么区别?</h3>\n<p>Spring Boot提供了两种常用的配置文件，分别是properties文件和yml文件。</p>\n<p>相对于properties文件而言，yml文件更年轻，也有很多的坑。可谓成也萧何败萧何，</p>\n<p>yml通过空格来确定层级关系，使配置文件结构跟清晰，但也会因为微不足道的空格而破坏了层级关系。</p>\n<h3 id=\"_108-spring-boot有哪些方式可以实现热部署\"> 108.Spring Boot有哪些方式可以实现热部署?</h3>\n<p>SpringBoot热部署实现有两种方式：</p>\n<p><strong>①. 使用spring loaded</strong></p>\n<p>在项目的pom.xml中添加如下代码：</p>\n<div><pre><code><span><span><span>&lt;</span>build</span><span>></span></span>\n    <span><span><span>&lt;</span>plugins</span><span>></span></span>\n        <span><span><span>&lt;</span>plugin</span><span>></span></span>\n            <span>&lt;!-- Spring Boot编译插件--></span>\n            <span><span><span>&lt;</span>groupId</span><span>></span></span>org.springframework.boot<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n            <span><span><span>&lt;</span>artifactId</span><span>></span></span>spring-boot-maven-plugin<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n            <span><span><span>&lt;</span>dependencies</span><span>></span></span>\n                <span>&lt;!-- Spring热部署 --></span>\n                <span>&lt;!-- 该依赖在此处下载不下来，可以放置在build标签外部下载完成后再粘贴进plugin中 --></span>\n                <span><span><span>&lt;</span>dependency</span><span>></span></span>\n                    <span><span><span>&lt;</span>groupId</span><span>></span></span>org.springframework<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n                    <span><span><span>&lt;</span>artifactId</span><span>></span></span>springloaded<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n                    <span><span><span>&lt;</span>version</span><span>></span></span>1.2.6.RELEASE<span><span><span>&lt;/</span>version</span><span>></span></span>\n                <span><span><span>&lt;/</span>dependency</span><span>></span></span>\n            <span><span><span>&lt;/</span>dependencies</span><span>></span></span>\n        <span><span><span>&lt;/</span>plugin</span><span>></span></span>\n    <span><span><span>&lt;/</span>plugins</span><span>></span></span>\n<span><span><span>&lt;/</span>build</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><p>添加完毕后需要使用mvn指令运行：</p>\n<p>首先找到IDEA中的Edit configurations ,然后进行如下操作：（点击左上角的&quot;+&quot;,然后选择maven将出现右侧面板，在红色划线部位输入</p>\n<p>如图所示指令，你可以为该指令命名(此处命名为MvnSpringBootRun)）</p>\n<img src=\"./assets/java-09.png\" style=\"zoom:80%;\" />\n<p>点击保存将会在IDEA项目运行部位出现，点击绿色箭头运行即可</p>\n<p><img src=\"./assets/java-10.png\" alt=\"\"></p>\n<p><strong>②. 使用spring-boot-devtools</strong></p>\n<p>在项目的pom文件中添加依赖：</p>\n<div><pre><code><span>&lt;!--热部署jar--></span>\n<span><span><span>&lt;</span>dependency</span><span>></span></span>\n    <span><span><span>&lt;</span>groupId</span><span>></span></span>org.springframework.boot<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n    <span><span><span>&lt;</span>artifactId</span><span>></span></span>spring-boot-devtools<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n<span><span><span>&lt;/</span>dependency</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>然后：使用 shift+ctrl+alt+&quot;/&quot; （IDEA中的快捷键） 选择&quot;Registry&quot; 然后勾选 compiler.automake.allow.when.app.running</p>\n<h3 id=\"_109jpa和hibernate有什么区别\"> 109JPA和Hibernate有什么区别?</h3>\n<ul>\n<li>JPA Java Persistence API，是Java EE 5的标准ORM接口，也是Ejb3规范的一部分。</li>\n<li>Hibernate，当今很流行的ORM框架，是JPA的一个实现，但是其功能是JPA的超集。</li>\n<li>JPA和Hibernate之间的关系，可以简单的理解为JPA是标准接口，Hibernate是实现。那么Hibernate是如何实现与JPA的这种关系的呢。Hibernate主要是通过三个组件来实现的，及hibernate-annotation、hibernate-entitymanager和hibernate-core。</li>\n<li>hibernate-annotation是Hibernate支持annotation方式配置的基础，它包括了标准的JPA annotation以及Hibernate自身特殊功能的annotation。</li>\n<li>hibernate-core是Hibernate的核心实现，提供了Hibernate所有的核心功能。</li>\n<li>hibernate-entitymanager实现了标准的JPA，可以把它看成hibernate-core和JPA之间的适配器，它并不直接提供ORM的功能，而是对hibernate-core进行封装，使得Hibernate符合JPA的规范。</li>\n</ul>\n<h3 id=\"_110-什么是-spring-cloud\"> 110.什么是 Spring Cloud?</h3>\n<p>从字面理解，Spring Cloud 就是致力于分布式系统、云服务的框架。</p>\n<p>Spring Cloud 是整个 Spring 家族中新的成员，是最近云服务火爆的必然产物。</p>\n<p>Spring Cloud 为开发人员提供了快速构建分布式系统中一些常见模式的工具，例如：</p>\n<ul>\n<li>配置管理</li>\n<li>服务注册与发现</li>\n<li>断路器</li>\n<li>智能路由</li>\n<li>服务间调用</li>\n<li>负载均衡</li>\n<li>微代理</li>\n<li>控制总线</li>\n<li>一次性令牌</li>\n<li>全局锁</li>\n<li>领导选举</li>\n<li>分布式会话</li>\n<li>集群状态</li>\n<li>分布式消息</li>\n<li>……</li>\n</ul>\n<p>使用 Spring Cloud 开发人员可以开箱即用的实现这些模式的服务和应用程序。这些服务可以任何环境下运行，包括分布式环境，也包括开发人员自己的笔记本电脑以及各种托管平台。</p>\n<h3 id=\"_111-spring-cloud-断路器的作用是什么\"> 111.Spring Cloud 断路器的作用是什么?</h3>\n<p>在Spring Cloud中使用了Hystrix 来实现断路器的功能，断路器可以防止一个应用程序多次试图执行一个操作，即很可能失败，允许它继续而不等待故障恢复或者浪费 CPU 周期，而它确定该故障是持久的。断路器模式也使应用程序能够检测故障是否已经解决，如果问题似乎已经得到纠正，应用程序可以尝试调用操作。</p>\n<p>断路器增加了稳定性和灵活性，以一个系统，提供稳定性，而系统从故障中恢复，并尽量减少此故障的对性能的影响。它可以帮助快速地拒绝对一个操作，即很可能失败，而不是等待操作超时（或者不返回）的请求，以保持系统的响应时间。如果断路器提高每次改变状态的时间的事件，该信息可以被用来监测由断路器保护系统的部件的健康状况，或以提醒管理员当断路器跳闸，以在打开状态。</p>\n<h3 id=\"_112-spring-cloud的核心组件有哪些\"> 112.Spring Cloud的核心组件有哪些?</h3>\n<p><strong>①. 服务发现——Netflix Eureka</strong></p>\n<p>一个RESTful服务，用来定位运行在AWS地区（Region）中的中间层服务。由两个组件组成：Eureka服务器和Eureka客户端。Eureka服务器用作服务注册服务器。Eureka客户端是一个java客户端，用来简化与服务器的交互、作为轮询负载均衡器，并提供服务的故障切换支持。Netflix在其生产环境中使用的是另外的客户端，它提供基于流量、资源利用率以及出错状态的加权负载均衡。</p>\n<p><strong>②. 客服端负载均衡——Netflix Ribbon</strong></p>\n<p>Ribbon，主要提供客户侧的软件负载均衡算法。Ribbon客户端组件提供一系列完善的配置选项，比如连接超时、重试、重试算法等。Ribbon内置可插拔、可定制的负载均衡组件。</p>\n<p><strong>③. 断路器——Netflix Hystrix</strong></p>\n<p>断路器可以防止一个应用程序多次试图执行一个操作，即很可能失败，允许它继续而不等待故障恢复或者浪费 CPU 周期，而它确定该故障是持久的。断路器模式也使应用程序能够检测故障是否已经解决。如果问题似乎已经得到纠正，应用程序可以尝试调用操作。</p>\n<p><strong>④. 服务网关——Netflix Zuul</strong></p>\n<p>类似nginx，反向代理的功能，不过netflix自己增加了一些配合其他组件的特性。</p>\n<p><strong>⑤. 分布式配置——Spring Cloud Config</strong></p>\n<p>这个还是静态的，得配合Spring Cloud Bus实现动态的配置更新。</p>\n",
      "date_modified": "2021-02-07T05:08:56.000Z",
      "authors": [
        {
          "name": "南辞"
        }
      ],
      "tags": []
    },
    {
      "title": "模块12—Hibernate",
      "url": "http://qiqi.dreamagain.top/interview/Java208/%E6%A8%A1%E5%9D%9712%E2%80%94Hibernate/",
      "id": "http://qiqi.dreamagain.top/interview/Java208/%E6%A8%A1%E5%9D%9712%E2%80%94Hibernate/",
      "content_html": "<h2 id=\"问题\"> 问题：</h2>\n<p>113.为什么要使用Hibernate?</p>\n<p>114.什么是 ORM框架?</p>\n<p>115.Hibernate 中如何在控制台查看打印的sql语句?</p>\n<p>116.Hibernate有几种查询方式?</p>\n<p>117.Hibernate 实体类可以被定义为final 吗?</p>\n<p>118.在Hibernate中使用Integer和int做映射有什么区别?</p>\n<p>119.Hibernate是如何工作的?</p>\n<p>120.get()和load()的区别?</p>\n<p>121.说一下 Hibernate 的缓存机制?</p>\n<p>122.Hibernate对象有哪些状态?</p>\n<p>123.在 Hibernate 中 getCurrentSession和openSession的区别是什么?</p>\n<p>124.Hibernate 实体类必须要有无参构造函数吗?为什么?</p>\n<h2 id=\"答案\"> 答案：</h2>\n<h3 id=\"_113-为什么要使用hibernate\"> 113.为什么要使用Hibernate?</h3>\n<ul>\n<li>\n<p>对JDBC访问数据库的代码做了封装，大大简化了数据访问层繁琐的重复性代码。</p>\n</li>\n<li>\n<p>Hibernate是一个基于JDBC的主流持久化框架，是一个优秀的ORM实现。他很大程度的简化DAO层的编码工作</p>\n</li>\n<li>\n<p>Hibernate使用Java反射机制，而不是字节码增强程序来实现透明性。</p>\n</li>\n<li>\n<p>Hibernate的性能非常好，因为它是个轻量级框架。映射的灵活性很出色。它支持各种关系数据库，从一对一到多对多的各种复杂关系。</p>\n</li>\n</ul>\n<h3 id=\"_114-什么是-orm框架\"> 114.什么是 ORM框架?</h3>\n<p>对象-关系映射（Object-Relational Mapping，简称ORM），面向对象的开发方法是当今企业级应用开发环境中的主流开发方法，关系数据库是企业级应用环境中永久存放数据的主流数据存储系统。</p>\n<p>对象和关系数据是业务实体的两种表现形式，业务实体在内存中表现为对象，在数据库中表现为关系数据。内存中的对象之间存在关联和继承关系，而在数据库中，关系数据无法直接表达多对多关联和继承关系。因此，对象-关系映射(ORM)系统一般以中间件的形式存在，主要实现程序对象到关系数据库数据的映射。</p>\n<h3 id=\"_115-hibernate-中如何在控制台查看打印的sql语句\"> 115.Hibernate 中如何在控制台查看打印的sql语句?</h3>\n<p>参考：blog.csdn.net/Randy_Wang_/article/details/79460306</p>\n<h3 id=\"_116-hibernate有几种查询方式\"> 116.Hibernate有几种查询方式?</h3>\n<ul>\n<li>hql查询</li>\n<li>sql查询</li>\n<li>条件查询</li>\n</ul>\n<div><pre><code>\nhql查询，sql查询，条件查询\n\nHQL<span>:</span>  <span>Hibernate</span> <span>Query</span> <span>Language</span><span>.</span> 面向对象的写法<span>:</span>\n<span>Query</span> query <span>=</span> session<span>.</span><span>createQuery</span><span>(</span><span>\"from Customer where name = ?\"</span><span>)</span><span>;</span>\nquery<span>.</span><span>setParameter</span><span>(</span><span>0</span><span>,</span> <span>\"苍老师\"</span><span>)</span><span>;</span>\n<span>Query</span><span>.</span><span>list</span><span>(</span><span>)</span><span>;</span>\n\n\n\nQBC<span>:</span>  <span>Query</span> <span>By</span> <span>Criteria</span><span>.</span><span>(</span>条件查询<span>)</span>\n<span>Criteria</span> criteria <span>=</span> session<span>.</span><span>createCriteria</span><span>(</span><span>Customer</span><span>.</span><span>class</span><span>)</span><span>;</span>\ncriteria<span>.</span><span>add</span><span>(</span><span>Restrictions</span><span>.</span><span>eq</span><span>(</span><span>\"name\"</span><span>,</span> <span>\"花姐\"</span><span>)</span><span>)</span><span>;</span>\n<span>List</span><span><span>&lt;</span><span>Customer</span><span>></span></span> list <span>=</span> criteria<span>.</span><span>list</span><span>(</span><span>)</span><span>;</span>\n\n\n\nSQL<span>:</span>\n<span>SQLQuery</span> query <span>=</span> session<span>.</span><span>createSQLQuery</span><span>(</span><span>\"select * from customer\"</span><span>)</span><span>;</span>\n<span>List</span><span>&lt;</span><span>Object</span><span>[</span><span>]</span><span>></span> list <span>=</span> query<span>.</span><span>list</span><span>(</span><span>)</span><span>;</span>\n\n<span>SQLQuery</span> query <span>=</span> session<span>.</span><span>createSQLQuery</span><span>(</span><span>\"select * from customer\"</span><span>)</span><span>;</span>\nquery<span>.</span><span>addEntity</span><span>(</span><span>Customer</span><span>.</span><span>class</span><span>)</span><span>;</span>\n<span>List</span><span><span>&lt;</span><span>Customer</span><span>></span></span> list <span>=</span> query<span>.</span><span>list</span><span>(</span><span>)</span><span>;</span>\n\n\n\n<span>Hql</span>： 具体分类\n<span>1</span>、 属性查询 <span>2</span>、 参数查询、命名参数查询 <span>3</span>、 关联查询 <span>4</span>、 分页查询 <span>5</span>、 统计函数\n\n\n\nHQL和SQL的区别\n\nHQL是面向对象查询操作的，SQL是结构化查询语言 是面向数据库表结构的\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br></div></div><h3 id=\"_117-hibernate-实体类可以被定义为final-吗\"> 117.Hibernate 实体类可以被定义为final 吗?</h3>\n<p>可以将Hibernate的实体类定义为final类，但这种做法并不好。因为Hibernate会使用代理模式在延迟关联的情况下提高性能，如果你把</p>\n<p>实体类定义成final类之后，因为 Java不允许对final类进行扩展，所以Hibernate就无法再使用代理了，如此一来就限制了使用可以提升</p>\n<p>性能的手段。不过，如果你的持久化类实现了一个接口而且在该接口中声明了所有定义于实体类中的所有public的方法轮到话，你就能</p>\n<p>够避免出现前面所说的不利后果。</p>\n<h3 id=\"_118-在hibernate中使用integer和int做映射有什么区别\"> 118.在Hibernate中使用Integer和int做映射有什么区别?</h3>\n<p>在Hibernate中，如果将OID定义为Integer类型，那么Hibernate就可以根据其值是否为null而判断一个对象是否是临时的，如果将OID</p>\n<p>定义为了int类型，还需要在hbm映射文件中设置其unsaved-value属性为0。</p>\n<h3 id=\"_119-hibernate是如何工作的\"> 119.Hibernate是如何工作的?</h3>\n<p>hibernate工作原理：</p>\n<ol>\n<li>通过Configuration config = new Configuration().configure();//读取并解析hibernate.cfg.xml配置文件</li>\n<li>由hibernate.cfg.xml中的<mapping resource=\"com/xx/User.hbm.xml\"/>读取并解析映射信息</li>\n<li>通过SessionFactory sf = config.buildSessionFactory();//创建SessionFactory</li>\n<li>Session session = sf.openSession();//打开Sesssion</li>\n<li>Transaction tx = session.beginTransaction();//创建并启动事务Transation</li>\n<li>persistent operate操作数据，持久化操作</li>\n<li>tx.commit();//提交事务</li>\n<li>关闭Session</li>\n<li>关闭SesstionFactory</li>\n</ol>\n<h3 id=\"_120-get-和load-的区别\"> 120.get()和load()的区别?</h3>\n<ul>\n<li>load() 没有使用对象的其他属性的时候，没有SQL  延迟加载</li>\n<li>get() 没有使用对象的其他属性的时候，也生成了SQL  立即加载</li>\n</ul>\n<h3 id=\"_121-说一下-hibernate-的缓存机制\"> 121.说一下 Hibernate 的缓存机制?</h3>\n<p>Hibernate中的缓存分为一级缓存和二级缓存。</p>\n<p>一级缓存就是 Session 级别的缓存，在事务范围内有效是,内置的不能被卸载。二级缓存是 SesionFactory级别的缓存，从应用启动到应用结束有效。是可选的，默认没有二级缓存，需要手动开启。保存数据库后，缓存在内存中保存一份，如果更新了数据库就要同步更新。</p>\n<p>什么样的数据适合存放到第二级缓存中？</p>\n<ul>\n<li>很少被修改的数据  帖子的最后回复时间</li>\n<li>经常被查询的数据  电商的地点</li>\n<li>不是很重要的数据，允许出现偶尔并发的数据</li>\n<li>不会被并发访问的数据</li>\n<li>常量数据</li>\n</ul>\n<p>**扩展：**Hibernate的二级缓存默认是不支持分布式缓存的。使用 memcahe,redis等中央缓存来代替二级缓存。</p>\n<h3 id=\"_122-hibernate对象有哪些状态\"> 122.Hibernate对象有哪些状态?</h3>\n<p>Hibernate里对象有三种状态：</p>\n<ol>\n<li>Transient（瞬时）：对象刚new出来，还没设id，设了其他值。</li>\n<li>Persistent（持久）：调用了save()、saveOrUpdate()，就变成Persistent，有id。</li>\n<li>Detached（脱管）：当session  close()完之后，变成Detached。</li>\n</ol>\n<p><img src=\"C:%5CUsers%5CMr%20Yang%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210110165420322.png\" alt=\"image-20210110165420322\"></p>\n<h3 id=\"_123-在-hibernate-中-getcurrentsession和opensession的区别是什么\"> 123.在 Hibernate 中 getCurrentSession和openSession的区别是什么?</h3>\n<p>openSession 从字面上可以看得出来，是打开一个新的session对象，而且每次使用都是打开一个新的session，假如连续使用多次，则获得的session不是同一个对象，并且使用完需要调用close方法关闭session。</p>\n<p>getCurrentSession ，从字面上可以看得出来，是获取当前上下文一个session对象，当第一次使用此方法时，会自动产生一个session对象，并且连续使用多次时，得到的session都是同一个对象，这就是与openSession的区别之一，简单而言，getCurrentSession 就是：如果有已经使用的，用旧的，如果没有，建新的。</p>\n<p>注意：在实际开发中，往往使用getCurrentSession多，因为一般是处理同一个事务（即是使用一个数据库的情况），所以在一般情况下比较少使用openSession或者说openSession是比较老旧的一套接口了。</p>\n<h3 id=\"_124-hibernate-实体类必须要有无参构造函数吗-为什么\"> 124.Hibernate 实体类必须要有无参构造函数吗?为什么?</h3>\n<p>必须，因为hibernate框架会调用这个默认构造方法来构造实例对象，即Class类的newInstance方法，这个方法就是通过调用默认构造方法来创建实例对象的。</p>\n<p>另外再提醒一点，如果你没有提供任何构造方法，虚拟机会自动提供默认构造方法（无参构造器），但是如果你提供了其他有参数的构造方法的话，虚拟机就不再为你提供默认构造方法，这时必须手动把无参构造器写在代码里，否则new Xxxx()是会报错的，所以默认的构造方法不是必须的，只在有多个构造方法时才是必须的，这里“必须”指的是“必须手动写出来”。</p>\n",
      "date_modified": "2021-02-07T05:08:56.000Z",
      "authors": [
        {
          "name": "南辞"
        }
      ],
      "tags": []
    },
    {
      "title": "模块13—MyBatis",
      "url": "http://qiqi.dreamagain.top/interview/Java208/%E6%A8%A1%E5%9D%9713%E2%80%94MyBatis/",
      "id": "http://qiqi.dreamagain.top/interview/Java208/%E6%A8%A1%E5%9D%9713%E2%80%94MyBatis/",
      "content_html": "<h2 id=\"问题\"> 问题：</h2>\n<p>125.MyBatis 中#{和$0的区别是什么?</p>\n<p>126.MyBatis有几种分页方式?</p>\n<p>127.RowBounds是一次性查询全部结果吗?为什么?</p>\n<p>128.MyBatis逻辑分页和物理分页的区别是什么?</p>\n<p>129.MyBatis 是否支持延迟加载?延迟加载的原理是什么?</p>\n<p>130.说一下MyBatis的一级缓存和二级缓存?</p>\n<p>131.MyBatis 和 hibernate的区别有哪些?</p>\n<p>132.MyBatis有哪些执行器(Executor) ?</p>\n<p>133.MyBatis分页插件的实现原理是什么?</p>\n<p>134.MyBatis 如何编写一个自定义插件?</p>\n<h2 id=\"答案\"> 答案：</h2>\n<h3 id=\"_125-mybatis-中-和-的区别是什么\"> 125.MyBatis 中#{}和${}的区别是什么?</h3>\n<ul>\n<li>#{}是预编译处理，${}是字符串替换；</li>\n<li>MyBatis在处理#{}时，会将sql中的#{}替换为?号，调用PreparedStatement的set方法来赋值；</li>\n<li>MyBatis在处理<span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.68333em;vertical-align:0em;\"></span><span></span><span>时</span><span>，</span><span>就</span><span>是</span><span>把</span></span></span></span>{}替换成变量的值；</li>\n<li>使用**#{}可以有效的防止SQL注入**，提高系统安全性。</li>\n</ul>\n<h3 id=\"_126-mybatis有几种分页方式\"> 126.MyBatis有几种分页方式?</h3>\n<ol>\n<li>数组分页</li>\n<li>sql分页</li>\n<li>拦截器分页</li>\n<li>RowBounds分页</li>\n</ol>\n<h3 id=\"_127-rowbounds是一次性查询全部结果吗-为什么\"> 127.RowBounds是一次性查询全部结果吗?为什么?</h3>\n<p>RowBounds 表面是在“所有”数据中检索数据，其实并非是一次性查询出所有数据，因为 MyBatis 是对 jdbc 的封装，在 jdbc 驱动中有</p>\n<p>一个 Fetch Size 的配置，它规定了每次最多从数据库查询多少条数据，假如你要查询更多数据，它会在你执行 next()的时候，去查询更</p>\n<p>多的数据。就好比你去自动取款机取 10000 元，但取款机每次最多能取 2500 元，所以你要取 4 次才能把钱取完。只是对于 jdbc 来</p>\n<p>说，当你调用 next()的时候会自动帮你完成查询工作。这样做的好处可以有效的防止内存溢出。</p>\n<p>Fetch Size 官方相关文档：http://t. cn/EfSE2g3</p>\n<h3 id=\"_128-mybatis逻辑分页和物理分页的区别是什么\"> 128.MyBatis逻辑分页和物理分页的区别是什么?</h3>\n<ul>\n<li>物理分页速度上并不一定快于逻辑分页，逻辑分页速度上也并不一定快于物理分页。</li>\n<li>物理分页总是优于逻辑分页：没有必要将属于数据库端的压力加诸到应用端来，就算速度上存在优势,然而其它性能上的优点足以弥补这个缺点。</li>\n</ul>\n<h3 id=\"_129-mybatis-是否支持延迟加载-延迟加载的原理是什么\"> 129.MyBatis 是否支持延迟加载?延迟加载的原理是什么?</h3>\n<p>MyBatis仅支持association关联对象和collection关联集合对象的延迟加载，association指的就是一对一，collection指的就是一对多查</p>\n<p>询。在MyBatis配置文件中，可以配置是否启用延迟加载lazyLoadingEnabled=true|false。</p>\n<p>它的<strong>原理是：</strong></p>\n<ol>\n<li>使用<strong>CGLIB</strong>创建目标对象的<strong>代理对象</strong>，当调用目标方法时，进入拦截器方法，比如调用a.getB().getName()，</li>\n<li>拦截器invoke()方法发现a.getB()是null值，那么就会单独发送事先保存好的查询关联B对象的sql，把B查询上来，然后调用a.setB(b)，于是a的对象b属性就有值了，</li>\n<li>接着完成a.getB().getName()方法的调用。这就是延迟加载的基本原理。</li>\n</ol>\n<p>当然了，不光是MyBatis，几乎所有的包括Hibernate，支持延迟加载的原理都是一样的。</p>\n<h3 id=\"_130-说一下mybatis的一级缓存和二级缓存\"> 130.说一下MyBatis的一级缓存和二级缓存?</h3>\n<p><strong>一级缓存:</strong> 基于 PerpetualCache 的 HashMap 本地缓存，其存储作用域为 Session，当 Session flush 或 close 之后，该 Session 中的所有 Cache 就将清空，默认打开一级缓存。</p>\n<p>二级缓存与一级缓存其机制相同，默认也是采用 PerpetualCache，HashMap 存储，不同在于其存储作用域为 Mapper(Namespace)，并且可自定义存储源，如 Ehcache。默认不打开二级缓存，要开启二级缓存，使用二级缓存属性类需要实现Serializable序列化接口(可用来保存对象的状态),可在它的映射文件中配置<cache/> ；</p>\n<p>对于缓存数据更新机制，当某一个作用域(一级缓存 Session/二级缓存Namespaces)的进行了C/U/D 操作后，默认该作用域下所有 select 中的缓存将被 clear。</p>\n<h3 id=\"_131-mybatis-和-hibernate的区别有哪些\"> 131.MyBatis 和 Hibernate的区别有哪些?</h3>\n<p>（1）Mybatis和hibernate不同，它不完全是一个ORM框架，因为MyBatis需要程序员自己编写Sql语句。</p>\n<p>（2）Mybatis直接编写原生态sql，可以严格控制sql执行性能，灵活度高，非常适合对关系数据模型要求不高的软件开发，因为这类软</p>\n<p>件需求变化频繁，一但需求变化要求迅速输出成果。但是灵活的前提是mybatis无法做到数据库无关性，如果需要实现支持多种数据库</p>\n<p>的软件，则需要自定义多套sql映射文件，工作量大。</p>\n<p>（3）Hibernate对象/关系映射能力强，数据库无关性好，对于关系模型要求高的软件，如果用Hibernate开发可以节省很多代码，提高</p>\n<p>效率。</p>\n<h3 id=\"_132-mybatis有哪些执行器-executor\"> 132.MyBatis有哪些执行器(Executor) ?</h3>\n<p><strong>Mybatis有三种基本的执行器（Executor）：</strong></p>\n<ol>\n<li><strong>SimpleExecutor</strong>：每执行一次update或select，就开启一个Statement对象，用完立刻关闭Statement对象。</li>\n<li><strong>ReuseExecutor</strong>：执行update或select，以sql作为key查找Statement对象，存在就使用，不存在就创建，用完后，不关闭Statement对象，而是放置于Map内，供下一次使用。简言之，就是重复使用Statement对象。</li>\n<li><strong>BatchExecutor</strong>：执行update（没有select，JDBC批处理不支持select），将所有sql都添加到批处理中（addBatch()），等待统一执行（executeBatch()），它缓存了多个Statement对象，每个Statement对象都是addBatch()完毕后，等待逐一执行executeBatch()批处理。与JDBC批处理相同。</li>\n</ol>\n<h3 id=\"_133-mybatis分页插件的实现原理是什么\"> 133.MyBatis分页插件的实现原理是什么?</h3>\n<p>分页插件的基本原理是使用Mybatis提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的sql，然后重写sql，根据</p>\n<p>dialect方言，添加对应的物理分页语句和物理分页参数。</p>\n<h3 id=\"_134-mybatis-如何编写一个自定义插件\"> 134.MyBatis 如何编写一个自定义插件?</h3>\n<p>转自：blog.csdn.net/qq_30051265/article/details/80266434</p>\n<p>Mybatis自定义插件针对MyBatis四大对象（Executor、StatementHandler 、ParameterHandler 、ResultSetHandler ）进行拦截，具体拦截方式为：</p>\n<ul>\n<li>Executor：拦截执行器的方法(log记录)</li>\n<li>StatementHandler ：拦截Sql语法构建的处理</li>\n<li>ParameterHandler ：拦截参数的处理</li>\n<li>ResultSetHandler ：拦截结果集的处理</li>\n</ul>\n<p>Mybatis自定义插件必须实现Interceptor接口：</p>\n<div><pre><code>\n<span>public</span> <span>interface</span> <span>Interceptor</span> <span>{</span>\n    <span>Object</span> <span>intercept</span><span>(</span><span>Invocation</span> invocation<span>)</span> <span>throws</span> <span>Throwable</span><span>;</span>\n    <span>Object</span> <span>plugin</span><span>(</span><span>Object</span> target<span>)</span><span>;</span>\n    <span>void</span> <span>setProperties</span><span>(</span><span>Properties</span> properties<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>intercept方法：拦截器具体处理逻辑方法</p>\n<p>plugin方法：根据签名signatureMap生成动态代理对象</p>\n<p>setProperties方法：设置Properties属性</p>\n<p>自定义插件demo：</p>\n<div><pre><code>\n<span>// ExamplePlugin.java</span>\n<span>@Intercepts</span><span>(</span><span>{</span><span>@Signature</span><span>(</span>\n  type<span>=</span> <span>Executor</span><span>.</span><span>class</span><span>,</span>\n  method <span>=</span> <span>\"update\"</span><span>,</span>\n  args <span>=</span> <span>{</span><span>MappedStatement</span><span>.</span><span>class</span><span>,</span><span>Object</span><span>.</span><span>class</span><span>}</span><span>)</span><span>}</span><span>)</span>\n<span>public</span> <span>class</span> <span>ExamplePlugin</span> <span>implements</span> <span>Interceptor</span> <span>{</span>\n  <span>public</span> <span>Object</span> <span>intercept</span><span>(</span><span>Invocation</span> invocation<span>)</span> <span>throws</span> <span>Throwable</span> <span>{</span>\n  <span>Object</span> target <span>=</span> invocation<span>.</span><span>getTarget</span><span>(</span><span>)</span><span>;</span> <span>//被代理对象</span>\n  <span>Method</span> method <span>=</span> invocation<span>.</span><span>getMethod</span><span>(</span><span>)</span><span>;</span> <span>//代理方法</span>\n  <span>Object</span><span>[</span><span>]</span> args <span>=</span> invocation<span>.</span><span>getArgs</span><span>(</span><span>)</span><span>;</span> <span>//方法参数</span>\n  <span>// do something ...... 方法拦截前执行代码块</span>\n  <span>Object</span> result <span>=</span> invocation<span>.</span><span>proceed</span><span>(</span><span>)</span><span>;</span>\n  <span>// do something .......方法拦截后执行代码块</span>\n  <span>return</span> result<span>;</span>\n  <span>}</span>\n  <span>public</span> <span>Object</span> <span>plugin</span><span>(</span><span>Object</span> target<span>)</span> <span>{</span>\n    <span>return</span> <span>Plugin</span><span>.</span><span>wrap</span><span>(</span>target<span>,</span> <span>this</span><span>)</span><span>;</span>\n  <span>}</span>\n  <span>public</span> <span>void</span> <span>setProperties</span><span>(</span><span>Properties</span> properties<span>)</span> <span>{</span>\n  <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><p>一个@Intercepts可以配置多个@Signature，@Signature中的参数定义如下：</p>\n<ul>\n<li>type：表示拦截的类，这里是Executor的实现类；</li>\n<li>method：表示拦截的方法，这里是拦截Executor的update方法；</li>\n<li>args：表示方法参数。</li>\n</ul>\n",
      "date_modified": "2021-02-07T05:08:56.000Z",
      "authors": [
        {
          "name": "南辞"
        }
      ],
      "tags": []
    },
    {
      "title": "模块14—RabbitMQ",
      "url": "http://qiqi.dreamagain.top/interview/Java208/%E6%A8%A1%E5%9D%9714%E2%80%94RabbitMQ/",
      "id": "http://qiqi.dreamagain.top/interview/Java208/%E6%A8%A1%E5%9D%9714%E2%80%94RabbitMQ/",
      "content_html": "<h2 id=\"问题\"> 问题：</h2>\n<p>135.RabbitMQ的使用场景有哪些?</p>\n<p>136.RabbitMQ有哪些重要的角色?</p>\n<p>137.RabbitMQ有哪些重要的组件?</p>\n<p>138.RabbitMQ中 vhost的作用是什么?</p>\n<p>139.RabbitMQ的消息是怎么发送的?</p>\n<p>140.RabbitMQ怎么保证消息的稳定性?</p>\n<p>141.RabbitMQ怎么避免消息丢失?</p>\n<p>142.要保证消息持久化成功的条件有哪些?</p>\n<p>143.RabbitMQ持久化有什么缺点?</p>\n<p>144.RabbitMQ有几种广播类型?</p>\n<p>145.RabbitMQ怎么实现延迟消息队列?</p>\n<p>146.RabbitMQ集群有什么用?</p>\n<p>147.RabbitMQ节点的类型有哪些?</p>\n<p>148.RabbitMQ集群搭建需要注意哪些问题?</p>\n<p>149.RabbitMQ每个节点是其他节点的完整拷贝吗?为什么?</p>\n<p>150.RabbitMQ集群中唯—一个磁盘节点崩溃了会发生什么情况?</p>\n<h2 id=\"答案\"> 答案：</h2>\n<h3 id=\"_135-rabbitmq的使用场景有哪些\"> 135.RabbitMQ的使用场景有哪些?</h3>\n<h3 id=\"_136-rabbitmq有哪些重要的角色\"> 136.RabbitMQ有哪些重要的角色?</h3>\n<h3 id=\"_137-rabbitmq有哪些重要的组件\"> 137.RabbitMQ有哪些重要的组件?</h3>\n<h3 id=\"_138-rabbitmq中-vhost的作用是什么\"> 138.RabbitMQ中 vhost的作用是什么?</h3>\n<h3 id=\"_139-rabbitmq的消息是怎么发送的\"> 139.RabbitMQ的消息是怎么发送的?</h3>\n<h3 id=\"_140-rabbitmq怎么保证消息的稳定性\"> 140.RabbitMQ怎么保证消息的稳定性?</h3>\n<h3 id=\"_141-rabbitmq怎么避免消息丢失\"> 141.RabbitMQ怎么避免消息丢失?</h3>\n<h3 id=\"_142-要保证消息持久化成功的条件有哪些\"> 142.要保证消息持久化成功的条件有哪些?</h3>\n<h3 id=\"_143-rabbitmq持久化有什么缺点\"> 143.RabbitMQ持久化有什么缺点?</h3>\n<h3 id=\"_144-rabbitmq有几种广播类型\"> 144.RabbitMQ有几种广播类型?</h3>\n<h3 id=\"_145-rabbitmq怎么实现延迟消息队列\"> 145.RabbitMQ怎么实现延迟消息队列?</h3>\n<h3 id=\"_146-rabbitmq集群有什么用\"> 146.RabbitMQ集群有什么用?</h3>\n<h3 id=\"_147-rabbitmq节点的类型有哪些\"> 147.RabbitMQ节点的类型有哪些?</h3>\n<h3 id=\"_148-rabbitmq集群搭建需要注意哪些问题\"> 148.RabbitMQ集群搭建需要注意哪些问题?</h3>\n<h3 id=\"_149-rabbitmq每个节点是其他节点的完整拷贝吗-为什么\"> 149.RabbitMQ每个节点是其他节点的完整拷贝吗?为什么?</h3>\n<h3 id=\"_150-rabbitmq集群中唯-一个磁盘节点崩溃了会发生什么情况\"> 150.RabbitMQ集群中唯—一个磁盘节点崩溃了会发生什么情况?</h3>\n",
      "date_modified": "2021-02-07T05:08:56.000Z",
      "authors": [
        {
          "name": "南辞"
        }
      ],
      "tags": []
    },
    {
      "title": "模块15—Kafka",
      "url": "http://qiqi.dreamagain.top/interview/Java208/%E6%A8%A1%E5%9D%9715%E2%80%94Kafka/",
      "id": "http://qiqi.dreamagain.top/interview/Java208/%E6%A8%A1%E5%9D%9715%E2%80%94Kafka/",
      "content_html": "<h2 id=\"问题\"> 问题：</h2>\n<p>152.kafka可以脱离zookeeper单独使用吗?为什么?</p>\n<p>153.kafka有几种数据保留的策略?</p>\n<p>154.kafka同时设置了7天和10G清除数据，到第五天的时候消息达到了10G，这个时候 kafka将如何处理?</p>\n<p>155.什么情况会导致kafka运行变慢?</p>\n<p>156.使用kafka集群需要注意什么?</p>\n<h2 id=\"答案\"> 答案：</h2>\n<h3 id=\"_152-kafka可以脱离zookeeper单独使用吗-为什么\"> 152.kafka可以脱离zookeeper单独使用吗?为什么?</h3>\n<h3 id=\"_153-kafka有几种数据保留的策略\"> 153.kafka有几种数据保留的策略?</h3>\n<h3 id=\"_154-kafka同时设置了7天和10g清除数据-到第五天的时候消息达到了10g-这个时候-kafka将如何处理\"> 154.kafka同时设置了7天和10G清除数据，到第五天的时候消息达到了10G，这个时候 kafka将如何处理?</h3>\n<h3 id=\"_155-什么情况会导致kafka运行变慢\"> 155.什么情况会导致kafka运行变慢?</h3>\n<h3 id=\"_156-使用kafka集群需要注意什么\"> 156.使用kafka集群需要注意什么?</h3>\n",
      "date_modified": "2021-02-07T05:08:56.000Z",
      "authors": [
        {
          "name": "南辞"
        }
      ],
      "tags": []
    },
    {
      "title": "模块16—Zookeeper",
      "url": "http://qiqi.dreamagain.top/interview/Java208/%E6%A8%A1%E5%9D%9716%E2%80%94Zookeeper/",
      "id": "http://qiqi.dreamagain.top/interview/Java208/%E6%A8%A1%E5%9D%9716%E2%80%94Zookeeper/",
      "content_html": "<h2 id=\"问题\"> 问题：</h2>\n<p>157.zookeeper是什么?</p>\n<p>158.zookeeper都有哪些功能?</p>\n<p>159.zookeeper有几种部署模式?</p>\n<p>160.zookeeper怎么保证主从节点的状态同步?</p>\n<p>161.集群中为什么要有主节点?</p>\n<p>162.集群中有3台服务器，其中一个节点宕机，这个时候zookeeper还可以使用吗?</p>\n<p>163.说一下zookeeper的通知机制?</p>\n<h2 id=\"答案\"> 答案：</h2>\n<h3 id=\"_157-zookeeper是什么\"> 157.zookeeper是什么?</h3>\n<h3 id=\"_158-zookeeper都有哪些功能\"> 158.zookeeper都有哪些功能?</h3>\n<h3 id=\"_159-zookeeper有几种部署模式\"> 159.zookeeper有几种部署模式?</h3>\n<h3 id=\"_160-zookeeper怎么保证主从节点的状态同步\"> 160.zookeeper怎么保证主从节点的状态同步?</h3>\n<h3 id=\"_161-集群中为什么要有主节点\"> 161.集群中为什么要有主节点?</h3>\n<h3 id=\"_162-集群中有3台服务器-其中一个节点宕机-这个时候zookeeper还可以使用吗\"> 162.集群中有3台服务器，其中一个节点宕机，这个时候zookeeper还可以使用吗?</h3>\n<h3 id=\"_163-说一下zookeeper的通知机制\"> 163.说一下zookeeper的通知机制?</h3>\n",
      "date_modified": "2021-02-07T05:08:56.000Z",
      "authors": [
        {
          "name": "南辞"
        }
      ],
      "tags": []
    },
    {
      "title": "模块17—MySQL",
      "url": "http://qiqi.dreamagain.top/interview/Java208/%E6%A8%A1%E5%9D%9717%E2%80%94MySQL/",
      "id": "http://qiqi.dreamagain.top/interview/Java208/%E6%A8%A1%E5%9D%9717%E2%80%94MySQL/",
      "content_html": "<h2 id=\"问题\"> 问题：</h2>\n<p>164.数据库的三范式是什么?</p>\n<p>165.一张自增表里面总共有17条数据，删除了最后⒉条数据，重启 MySQL数据库，又插入了一条数据，此时id是几?</p>\n<p>166.如何获取当前数据库版本?</p>\n<p>167.说一下ACID是什么?</p>\n<p>168.char和varchar 的区别是什么?</p>\n<p>169.float和double的区别是什么?</p>\n<p>170.MySQL 的内连接、左连接、右连接有什么区别?</p>\n<p>171.MySQL索引是怎么实现的?</p>\n<p>172.怎么验证 MySQL的索引是否满足需求?</p>\n<p>173.说一下数据库的事务隔离?</p>\n<p>174.说一下MySQL常用的引擎?</p>\n<p>175.说一下MySQL的行锁和表锁?</p>\n<p>176.说一下乐观锁和悲观锁?</p>\n<p>177.MySQL问题排查都有哪些手段?</p>\n<p>178.如何做MySQL的性能优化?</p>\n<h2 id=\"答案\"> 答案:</h2>\n<h3 id=\"_164-数据库的三范式是什么\"> 164.数据库的三范式是什么?</h3>\n<ul>\n<li>第一范式：强调的是列的原子性，即数据库表的每一列都是不可分割的原子数据项。</li>\n<li>第二范式：要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性。</li>\n<li>第三范式：任何非主属性不依赖于其它非主属性。</li>\n</ul>\n<h3 id=\"_165-一张自增表里面总共有17条数据-删除了最后2-条数据-重启-mysql数据库-又插入了一条数据-此时id是几\"> 165.一张自增表里面总共有17条数据，删除了最后⒉条数据，重启 MySQL数据库，又插入了一条数据，此时id是几?</h3>\n<ul>\n<li>表类型如果是 MyISAM ，那 id 就是 18。</li>\n<li>表类型如果是 InnoDB，那 id 就是 15。</li>\n</ul>\n<p>InnoDB 表只会把自增主键的最大 id 记录在内存中，所以重启之后会导致最大 id 丢失。</p>\n<h3 id=\"_166-如何获取当前数据库版本\"> 166.如何获取当前数据库版本?</h3>\n<p>使用 select version() 获取当前 MySQL 数据库版本。</p>\n<h3 id=\"_167-说一下acid是什么\"> 167.说一下ACID是什么?</h3>\n<ul>\n<li>Atomicity（原子性）：一个事务（transaction）中的所有操作，或者全部完成，或者全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被恢复（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。即，事务不可分割、不可约简。</li>\n<li>Consistency（一致性）：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设约束、触发器、级联回滚等。</li>\n<li>Isolation（隔离性）：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。</li>\n<li>Durability（持久性）：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</li>\n</ul>\n<h3 id=\"_168-char和varchar-的区别是什么\"> 168.char和varchar 的区别是什么?</h3>\n<p>char(n) ：固定长度类型，比如订阅 char(10)，当你输入&quot;abc&quot;三个字符的时候，它们占的空间还是 10 个字节，其他 7 个是空字节。</p>\n<p>char 优点：效率高；缺点：占用空间；适用场景：存储密码的 md5 值，固定长度的，使用 char 非常合适。</p>\n<p>varchar(n) ：可变长度，存储的值是每个值占用的字节再加上一个用来记录其长度的字节的长度。</p>\n<p>所以，从空间上考虑 varchar 比较合适；从效率上考虑 char 比较合适，二者使用需要权衡。</p>\n<h3 id=\"_169-float和double的区别是什么\"> 169.float和double的区别是什么?</h3>\n<p><strong>1、变量类型不同</strong></p>\n<p>float属于单精度型浮点数据。</p>\n<p>double属于双精度型浮点数据。</p>\n<p><img src=\"./assets/java-11.png\" alt=\"\"></p>\n<p>一个浮点数由三部分组成：符号位S、指数部分E（阶码）以及尾数部分M。</p>\n<ul>\n<li>\n<p>单精度浮点数(float)总共用32位来表示浮点数，其中尾数用23位存储，加上小数点前有一位隐藏的1(IEEE754规约数表示法)，2^(23+1) = 16777216。因为 10^7 &lt; 16777216 &lt; 10^8，所以说单精度浮点数的有效位数是7位。考虑到第7位可能的四舍五入问题，所以单精度最少有6位有效数字（最小尺寸）。</p>\n</li>\n<li>\n<p>同样地：双精度浮点数(double)总共用64位来表示浮点数，其中尾数用52位存储，   2^(52+1) = 9007199254740992，10^16 &lt; 9007199254740992 &lt; 10^17，所以双精度的有效位数是16位。同样四舍五入，最少15位。</p>\n</li>\n</ul>\n<p><strong>2、指数范围不同</strong></p>\n<p>float的指数范围为-127~128。</p>\n<p>double而double的指数范围为-1023~1024</p>\n<p><strong>3、表达式指数位不同</strong></p>\n<p>float的表达式为1bit（符号位）+8bits（指数位）+23bits（尾数位）</p>\n<p>double的表达式为1bit（符号位）+ 11bits（指数位）+ 52bits（尾数位）</p>\n<p><strong>4、占用内存空间不同</strong></p>\n<p>float占4个字节（32位）内存空间，其数值范围为3.4E-38～3.4E+38。</p>\n<p>double占8 个字节（64位）内存空间，其数值范围为1.7E-308～1.7E+308。</p>\n<p><strong>5、有效位数不同</strong></p>\n<p>单精度浮点数的有效位数是7位。</p>\n<p>双精度浮点数的有效位数是16位。</p>\n<p>单精度最少有6位有效数字（最小尺寸）。</p>\n<p>双精度的有效位数最少15位</p>\n<h3 id=\"_170-mysql-的内连接、左连接、右连接有什么区别\"> 170.MySQL 的内连接、左连接、右连接有什么区别?</h3>\n<p>内连接关键字：inner join；左连接：left join；右连接：right join。</p>\n<p>内连接是把匹配的关联数据显示出来；左连接是左边的表全部显示出来，右边的表显示出符合条件的数据；右连接正好相反。</p>\n<h3 id=\"_171-mysql索引是怎么实现的\"> 171.MySQL索引是怎么实现的?</h3>\n<p>索引是满足某种特定查找算法的数据结构，而这些数据结构会以某种方式指向数据，从而实现高效查找数据。</p>\n<p>具体来说 MySQL 中的索引，不同的数据引擎实现有所不同，但目前主流的数据库引擎的索引都是 B+ 树实现的，B+ 树的搜索效率，可</p>\n<p>以到达二分法的性能，找到数据区域之后就找到了完整的数据结构了，所以性能也是更好的。</p>\n<h3 id=\"_172-怎么验证-mysql的索引是否满足需求\"> 172.怎么验证 MySQL的索引是否满足需求?</h3>\n<p>使用 explain 查看 SQL 是如何执行查询语句的，从而分析你的索引是否满足需求。</p>\n<p>explain 语法：explain select * from table where type=1。</p>\n<h3 id=\"_173-说一下数据库的事务隔离\"> 173.说一下数据库的事务隔离?</h3>\n<p>MySQL 的事务隔离是在 MySQL. ini 配置文件里添加的，在文件的最后添加：transaction-isolation = REPEATABLE-READ</p>\n<p>可用的配置值：READ-UNCOMMITTED、READ-COMMITTED、REPEATABLE-READ、SERIALIZABLE。</p>\n<ul>\n<li>READ-UNCOMMITTED：未提交读，最低隔离级别、事务未提交前，就可被其他事务读取（会出现幻读、脏读、不可重复读）。</li>\n<li>READ-COMMITTED：提交读，一个事务提交后才能被其他事务读取到（会造成幻读、不可重复读）。</li>\n<li>REPEATABLE-READ：可重复读，默认级别，保证多次读取同一个数据时，其值都和事务开始时候的内容是一致，禁止读取到别的事务未提交的数据（会造成幻读）。</li>\n<li>SERIALIZABLE：序列化，代价最高最可靠的隔离级别，该隔离级别能防止脏读、不可重复读、幻读。</li>\n</ul>\n<p>**脏读 ：**表示一个事务能够读取另一个事务中还未提交的数据。比如，某个事务尝试插入记录 A，此时该事务还未提交，然后另一个事</p>\n<p>务尝试读取到了记录 A。</p>\n<p>**不可重复读 ：**是指在一个事务内，多次读同一数据。</p>\n<p>**幻读 ：**指同一个事务内多次查询返回的结果集不一样。比如同一个事务 A 第一次查询时候有 n 条记录，但是第二次同等条件下查询却</p>\n<p>有 n+1 条记录，这就好像产生了幻觉。发生幻读的原因也是另外一个事务新增或者删除或者修改了第一个事务结果集里面的数据，同一</p>\n<p>个记录的数据内容被修改了，所有数据行的记录就变多或者变少了。</p>\n<h3 id=\"_174-说一下mysql常用的引擎\"> 174.说一下MySQL常用的引擎?</h3>\n<p>InnoDB 引擎：InnoDB 引擎提供了对数据库 ACID 事务的支持，并且还提供了行级锁和外键的约束，它的设计的目标就是处理大数据容量的数据库系统。MySQL 运行的时候，InnoDB 会在内存中建立缓冲池，用于缓冲数据和索引。但是该引擎是不支持全文搜索，同时启动也比较的慢，它是不<strong>会保存表的行数</strong>的，所以当进行 select count(*) from table 指令的时候，<strong>需要进行扫描全表</strong>。由于<strong>锁的粒度小，写操作是不会锁定全表的,所以在并发度较高的场景下使用会提升效率的。</strong></p>\n<p>MyIASM 引擎：MySQL 的默认引擎，但不提供事务的支持，也不支持行级锁和外键。因此当执行插入和更新语句时，即执行写操作的时候需要锁定这个表，所以会导致效率会降低。不过和 InnoDB 不同的是，MyIASM 引擎是<strong>保存了表的行数</strong>，于是当进行 select count(*) from table 语句时，可以直接的读取已经保存的值而<strong>不需要进行扫描全表</strong>。所以，如果<strong>表的读操作远远多于写操作时，并且不需要事务的支持的，可以将 MyIASM 作为数据库引擎的首选。</strong></p>\n<h3 id=\"_175-说一下mysql的行锁和表锁\"> 175.说一下MySQL的行锁和表锁?</h3>\n<p>MyISAM 只支持表锁，InnoDB 支持表锁和行锁，默认为行锁。</p>\n<ul>\n<li>表级锁：开销小，加锁快，不会出现死锁。锁粒度大，发生锁冲突的概率最高，并发量最低。</li>\n<li>行级锁：开销大，加锁慢，会出现死锁。锁粒度小，发生锁冲突的概率小，并发度最高。</li>\n</ul>\n<h3 id=\"_176-说一下乐观锁和悲观锁\"> 176.说一下乐观锁和悲观锁?</h3>\n<ul>\n<li>乐观锁：每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在提交更新的时候会判断一下在此期间别人有没有去更新这个数据。</li>\n<li>悲观锁：每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻止，直到这个锁被释放。</li>\n</ul>\n<p>数据库的乐观锁需要自己实现，在表里面添加一个 version 字段，每次修改成功值加 1，这样每次修改的时候先对比一下，自己拥有的</p>\n<p>version 和数据库现在的 version 是否一致，如果不一致就不修改，这样就实现了乐观锁。</p>\n<h3 id=\"_177-mysql问题排查都有哪些手段\"> 177.MySQL问题排查都有哪些手段?</h3>\n<ul>\n<li>使用 show processlist 命令查看当前所有连接信息。</li>\n<li>使用 explain 命令查询 SQL 语句执行计划。</li>\n<li>开启慢查询日志，查看慢查询的 SQL。</li>\n</ul>\n<h3 id=\"_178-如何做mysql的性能优化\"> 178.如何做MySQL的性能优化?</h3>\n<ul>\n<li>为搜索字段创建索引。</li>\n<li>避免使用 select *，列出需要查询的字段。</li>\n<li>垂直分割分表。</li>\n<li>选择正确的存储引擎。</li>\n</ul>\n",
      "date_modified": "2021-02-07T05:08:56.000Z",
      "authors": [
        {
          "name": "南辞"
        }
      ],
      "tags": []
    },
    {
      "title": "模块18—Redis",
      "url": "http://qiqi.dreamagain.top/interview/Java208/%E6%A8%A1%E5%9D%9718%E2%80%94Redis/",
      "id": "http://qiqi.dreamagain.top/interview/Java208/%E6%A8%A1%E5%9D%9718%E2%80%94Redis/",
      "content_html": "<h2 id=\"问题\"> 问题：</h2>\n<p>179.redis是什么?都有哪些使用场景?</p>\n<p>180.redis有哪些功能?</p>\n<p>181.redis和 memecache有什么区别?</p>\n<p>182.redis为什么是单线程的?</p>\n<p>183.什么是缓存穿透?怎么解决?</p>\n<p>184.redis支持的数据类型有哪些?</p>\n<p>185.redis支持的java客户端都有哪些?</p>\n<p>186.jedis和redisson有哪些区别?</p>\n<p>187.怎么保证缓存和数据库数据的一致性?</p>\n<p>188.redis持久化有几种方式?</p>\n<p>189.redis 怎么实现分布式锁?</p>\n<p>190.redis分布式锁有什么缺陷?</p>\n<p>191.redis如何做内存优化?</p>\n<p>192.redis淘汰策略有哪些?</p>\n<p>193.redis 常见的性能问题有哪些?该如何解决?</p>\n<h2 id=\"答案\"> 答案：</h2>\n<h3 id=\"_179-redis是什么-都有哪些使用场景\"> 179.redis是什么?都有哪些使用场景?</h3>\n<p>Redis是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。-----</p>\n<p>Redis 使用场景：</p>\n<ul>\n<li>数据高并发的读写</li>\n<li>海量数据的读写</li>\n<li>对扩展性要求高的数据</li>\n</ul>\n<h3 id=\"_180-redis有哪些功能\"> 180.redis有哪些功能?</h3>\n<ul>\n<li>数据缓存功能</li>\n<li>分布式锁的功能</li>\n<li>支持数据持久化</li>\n<li>支持事务</li>\n<li>支持消息队列</li>\n</ul>\n<h3 id=\"_181-redis和-memecache有什么区别\"> 181.redis和 memecache有什么区别?</h3>\n<ul>\n<li>memcached所有的值均是简单的字符串，redis作为其替代者，支持更为丰富的数据类型</li>\n<li>redis的速度比memcached快很多</li>\n<li>redis可以持久化其数据</li>\n</ul>\n<h3 id=\"_182-redis为什么是单线程的\"> 182.redis为什么是单线程的?</h3>\n<p>因为 cpu 不是 Redis 的瓶颈，Redis 的瓶颈最有可能是机器内存或者网络带宽。既然单线程容易实现，而且 cpu 又不会成为瓶颈，那就</p>\n<p>顺理成章地采用单线程的方案了。</p>\n<p>关于 Redis 的性能，官方网站也有，普通笔记本轻松处理每秒几十万的请求。</p>\n<p>而且单线程并不代表就慢 nginx 和 nodejs 也都是高性能单线程的代表。</p>\n<h3 id=\"_183-什么是缓存穿透-怎么解决\"> 183.什么是缓存穿透?怎么解决?</h3>\n<p>缓存穿透：指查询一个一定不存在的数据，由于缓存是不命中时需要从数据库查询，查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到数据库去查询，造成缓存穿透。</p>\n<p>解决方案：最简单粗暴的方法如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），我们就把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。</p>\n<h3 id=\"_184-redis支持的数据类型有哪些\"> 184.redis支持的数据类型有哪些?</h3>\n<p>string、list、hash、set、zset。</p>\n<h3 id=\"_185-redis支持的java客户端都有哪些\"> 185.redis支持的java客户端都有哪些?</h3>\n<p>Redisson、Jedis、lettuce等等，官方推荐使用Redisson。</p>\n<h3 id=\"_186-jedis和redisson有哪些区别\"> 186.jedis和redisson有哪些区别?</h3>\n<ul>\n<li>\n<p>Jedis是Redis的Java实现的客户端，其API提供了比较全面的Redis命令的支持。</p>\n</li>\n<li>\n<p>Redisson实现了分布式和可扩展的Java数据结构，和Jedis相比，功能较为简单，不支持字符串操作，不支持排序、事务、管道、分区等Redis特性。Redisson的宗旨是促进使用者对Redis的关注分离，从而让使用者能够将精力更集中地放在处理业务逻辑上。</p>\n</li>\n</ul>\n<h3 id=\"_187-怎么保证缓存和数据库数据的一致性\"> 187.怎么保证缓存和数据库数据的一致性?</h3>\n<ul>\n<li>合理设置缓存的过期时间。</li>\n<li>新增、更改、删除数据库操作时同步更新 Redis，可以使用事务机制来保证数据的一致性。</li>\n</ul>\n<h3 id=\"_188-redis持久化有几种方式\"> 188.redis持久化有几种方式?</h3>\n<p>Redis 的持久化有两种方式，或者说有两种策略：</p>\n<ul>\n<li>RDB（Redis Database）：指定的时间间隔能对你的数据进行快照存储。</li>\n<li>AOF（Append Only File）：每一个收到的写命令都通过write函数追加到文件中。</li>\n</ul>\n<h3 id=\"_189-redis-怎么实现分布式锁\"> 189.redis 怎么实现分布式锁?</h3>\n<ul>\n<li>\n<p>Redis 分布式锁其实就是在系统里面占一个“坑”，其他程序也要占“坑”的时候，</p>\n<p>占用成功了就可以继续执行，失败了就只能放弃或稍后重试。</p>\n</li>\n<li>\n<p>占坑一般使用 setnx(set if not exists)指令，只允许被一个程序占有，使用完调用 del 释放锁。</p>\n</li>\n</ul>\n<h3 id=\"_190-redis分布式锁有什么缺陷\"> 190.redis分布式锁有什么缺陷?</h3>\n<p>Redis 分布式锁不能解决超时的问题，分布式锁有一个超时时间，程序的执行如果超出了锁的超时时间就会出现问题。</p>\n<h3 id=\"_191-redis如何做内存优化\"> 191.redis如何做内存优化?</h3>\n<p>尽可能使用散列表（hashes），散列表（是说散列表里面存储的数少）使用的内存非常小，所以你应该尽可能的将你的数据模型抽象到一个散列表里面。</p>\n<p>比如你的web系统中有一个用户对象，不要为这个用户的名称，姓氏，邮箱，密码设置单独的key,而是应该把这个用户的所有信息存储到一张散列表里面。</p>\n<h3 id=\"_192-redis淘汰策略有哪些\"> 192.redis淘汰策略有哪些?</h3>\n<ul>\n<li>volatile-lru：从已设置过期时间的数据集（server. db[i]. expires）中挑选最近最少使用的数据淘汰。</li>\n<li>volatile-ttl：从已设置过期时间的数据集（server. db[i]. expires）中挑选将要过期的数据淘汰。</li>\n<li>volatile-random：从已设置过期时间的数据集（server. db[i]. expires）中任意选择数据淘汰。</li>\n<li>allkeys-lru：从数据集（server. db[i]. dict）中挑选最近最少使用的数据淘汰。</li>\n<li>allkeys-random：从数据集（server. db[i]. dict）中任意选择数据淘汰。</li>\n<li>no-enviction（驱逐）：禁止驱逐数据。</li>\n</ul>\n<h3 id=\"_193-redis-常见的性能问题有哪些-该如何解决\"> 193.redis 常见的性能问题有哪些?该如何解决?</h3>\n<ul>\n<li>主服务器写内存快照，会阻塞主线程的工作，当快照比较大时对性能影响是非常大的，会间断性暂停服务，所以主服务器最好不要写内存快照。</li>\n<li>Redis 主从复制的性能问题，为了主从复制的速度和连接的稳定性，主从库最好在同一个局域网内。</li>\n</ul>\n",
      "date_modified": "2021-02-07T05:08:56.000Z",
      "authors": [
        {
          "name": "南辞"
        }
      ],
      "tags": []
    },
    {
      "title": "模块19—JVM",
      "url": "http://qiqi.dreamagain.top/interview/Java208/%E6%A8%A1%E5%9D%9719%E2%80%94JVM/",
      "id": "http://qiqi.dreamagain.top/interview/Java208/%E6%A8%A1%E5%9D%9719%E2%80%94JVM/",
      "content_html": "<h2 id=\"问题\"> 问题：</h2>\n<p>194.说一下 jvm的主要组成部分?及其作用?</p>\n<p>195.说一下 jvm运行时数据区?</p>\n<p>196.说一下堆栈的区别?</p>\n<p>197.队列和栈是什么?有什么区别?</p>\n<p>198.什么是双亲委派模型?</p>\n<p>199.说一下类加载的执行过程?</p>\n<p>200.怎么判断对象是否可以被回收?</p>\n<p>201.java中都有哪些引用类型?</p>\n<p>202.说一下 jvm有哪些垃圾回收算法?</p>\n<p>203.说一下 jvm有哪些垃圾回收器?</p>\n<p>204.详细介绍一下 CMS垃圾回收器?</p>\n<p>205.新生代垃圾回收器和老生代垃圾回收器都有哪些?有什么区别?</p>\n<p>206.简述分代垃圾回收器是怎么工作的?</p>\n<p>207.说一下jvm调优的工具?</p>\n<p>208.常用的jvm调优的参数都有哪些?</p>\n<h2 id=\"答案\"> 答案：</h2>\n<h3 id=\"_194-说一下-jvm的主要组成部分-及其作用\"> 194.说一下 jvm的主要组成部分?及其作用?</h3>\n<ul>\n<li>类加载器（ClassLoader）</li>\n<li>运行时数据区（Runtime Data Area）</li>\n<li>执行引擎（Execution Engine）</li>\n<li>本地库接口（Native Interface）</li>\n</ul>\n<p>组件的作用： 首先通过类加载器（ClassLoader）会把 Java 代码转换成字节码，运行时数据区（Runtime Data Area）再把字节码加载</p>\n<p>到内存中，而字节码文件只是 JVM 的一套指令集规范，并不能直接交给底层操作系统去执行，因此需要特定的命令解析器执行引擎</p>\n<p>（Execution Engine），将字节码翻译成底层系统指令，再交由 CPU 去执行，而这个过程中需要调用其他语言的本地库接口（Native</p>\n<p>Interface）来实现整个程序的功能。</p>\n<h3 id=\"_195-说一下-jvm运行时数据区\"> 195.说一下 jvm运行时数据区?</h3>\n<ul>\n<li>程序计数器</li>\n<li>虚拟机栈</li>\n<li>本地方法栈</li>\n<li>堆</li>\n<li>方法区</li>\n</ul>\n<p>有的区域随着虚拟机进程的启动而存在，有的区域则依赖用户进程的启动和结束而创建和销毁。</p>\n<p><img src=\"./assets/java-12.png\" alt=\"\"></p>\n<h3 id=\"_196-说一下堆栈的区别\"> 196.说一下堆栈的区别?</h3>\n<ol>\n<li>\n<p>栈内存存储的是局部变量而堆内存存储的是实体；</p>\n</li>\n<li>\n<p>栈内存的更新速度要快于堆内存，因为局部变量的生命周期很短；</p>\n</li>\n<li>\n<p>栈内存存放的变量生命周期一旦结束就会被释放，而堆内存存放的实体会被垃圾回收机制不定时的回收。</p>\n</li>\n</ol>\n<h3 id=\"_197-队列和栈是什么-有什么区别\"> 197.队列和栈是什么?有什么区别?</h3>\n<ul>\n<li>队列和栈都是被用来预存储数据的。</li>\n<li>队列允许先进先出检索元素，但也有例外的情况，Deque 接口允许从两端检索元素。</li>\n<li>栈和队列很相似，但它运行对元素进行后进先出进行检索。</li>\n</ul>\n<h3 id=\"_198-什么是双亲委派模型\"> 198.什么是双亲委派模型?</h3>\n<p>在介绍双亲委派模型之前先说下类加载器。对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立在 JVM 中的唯一性，每</p>\n<p>一个类加载器，都有一个独立的类名称空间。类加载器就是根据指定全限定名称将 class 文件加载到 JVM 内存，然后再转化为 class 对</p>\n<p>象。</p>\n<p><strong>类加载器分类：</strong></p>\n<ul>\n<li>启动类加载器（Bootstrap ClassLoader），是虚拟机自身的一部分，用来加载Java_HOME/lib/目录中的，或者被 -Xbootclasspath 参数所指定的路径中并且被虚拟机识别的类库；</li>\n<li>扩展类加载器（Extension ClassLoader）：负责加载&lt;java_home style=&quot;box-sizing: border-box; -webkit-tap-highlight-color: transparent; text-size-adjust: none; -webkit-font-smoothing: antialiased; outline: 0px !important;&quot;&gt;\\lib\\ext目录或Java. ext. dirs系统变量指定的路径中的所有类库；&lt;/java_home&gt;</li>\n<li>应用程序类加载器（Application ClassLoader）。负责加载用户类路径（classpath）上的指定类库，我们可以直接使用这个类加载器。一般情况，如果我们没有自定义类加载器默认就是用这个加载器。</li>\n<li>其他类加载器：</li>\n</ul>\n<p>双亲委派模型：如果一个类加载器收到了类加载的请求，它首先不会自己去加载这个类，而是把这个请求委派给父类加载器去完成，每</p>\n<p>一层的类加载器都是如此，这样所有的加载请求都会被传送到顶层的启动类加载器中，只有当父加载无法完成加载请求（它的搜索范围</p>\n<p>中没找到所需的类）时，子加载器才会尝试去加载类。</p>\n<h3 id=\"_199-说一下类加载的执行过程\"> 199.说一下类加载的执行过程?</h3>\n<p>类加载分为以下 5 个步骤：</p>\n<ol>\n<li>加载：根据查找路径找到相应的 class 文件然后导入；</li>\n<li>检查：检查加载的 class 文件的正确性；</li>\n<li>准备：给类中的静态变量分配内存空间；</li>\n<li>解析：虚拟机将常量池中的符号引用替换成直接引用的过程。符号引用就理解为一个标示，而在直接引用直接指向内存中的地址；</li>\n<li>初始化：对静态变量和静态代码块执行初始化工作。</li>\n</ol>\n<h3 id=\"_200-怎么判断对象是否可以被回收\"> 200.怎么判断对象是否可以被回收?</h3>\n<p>一般有两种方法来判断：</p>\n<ul>\n<li>引用计数器：为每个对象创建一个引用计数，有对象引用时计数器 +1，引用被释放时计数 -1，当计数器为 0 时就可以被回收。它有一个缺点不能解决循环引用的问题；</li>\n<li>可达性分析：从 GC Roots 开始向下搜索，搜索所走过的路径称为引用链。当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是可以被回收的。</li>\n</ul>\n<h3 id=\"_201-java中都有哪些引用类型\"> 201.java中都有哪些引用类型?</h3>\n<ul>\n<li>强引用</li>\n<li>软引用</li>\n<li>弱引用</li>\n<li>虚引用（幽灵引用/幻影引用）</li>\n</ul>\n<h3 id=\"_202-说一下-jvm有哪些垃圾回收算法\"> 202.说一下 jvm有哪些垃圾回收算法?</h3>\n<ul>\n<li>标记-清除算法</li>\n<li>标记-整理算法</li>\n<li>复制算法</li>\n<li>分代算法</li>\n</ul>\n<h3 id=\"_203-说一下-jvm有哪些垃圾回收器\"> 203.说一下 jvm有哪些垃圾回收器?</h3>\n<ul>\n<li>Serial：最早的单线程串行垃圾回收器。</li>\n<li>Serial Old：Serial 垃圾回收器的老年版本，同样也是单线程的，可以作为 CMS 垃圾回收器的备选预案。</li>\n<li>ParNew：是 Serial 的多线程版本。</li>\n<li>Parallel 和 ParNew 收集器类似是多线程的，但 Parallel 是吞吐量优先的收集器，可以牺牲等待时间换取系统的吞吐量。</li>\n<li>Parallel Old 是 Parallel 老生代版本，Parallel 使用的是复制的内存回收算法，Parallel Old 使用的是标记-整理的内存回收算法。</li>\n<li>CMS：一种以获得最短停顿时间为目标的收集器，非常适用 B/S 系统。</li>\n<li>G1：一种兼顾吞吐量和停顿时间的 GC 实现，是 JDK 9 以后的默认 GC 选项。</li>\n</ul>\n<h3 id=\"_204-详细介绍一下-cms垃圾回收器\"> 204.详细介绍一下 CMS垃圾回收器?</h3>\n<p>CMS 是英文 Concurrent Mark-Sweep 的简称，是以牺牲吞吐量为代价来获得最短回收停顿时间的垃圾回收器。对于要求服务器响应速度的应用上，这种垃圾回收器非常适合。在启动 JVM 的参数加上“-XX:+UseConcMarkSweepGC”来指定使用 CMS 垃圾回收器。</p>\n<p>CMS 使用的是标记-清除的算法实现的，所以在 gc 的时候回产生大量的内存碎片，当剩余内存不能满足程序运行要求时，系统将会出现 Concurrent Mode Failure，临时 CMS 会采用 Serial Old 回收器进行垃圾清除，此时的性能将会被降低。</p>\n<h3 id=\"_205-新生代垃圾回收器和老生代垃圾回收器都有哪些-有什么区别\"> 205.新生代垃圾回收器和老生代垃圾回收器都有哪些?有什么区别?</h3>\n<ul>\n<li>新生代回收器：Serial、ParNew、Parallel Scavenge</li>\n<li>老年代回收器：Serial Old、Parallel Old、CMS</li>\n<li>整堆回收器：G1</li>\n</ul>\n<p>新生代垃圾回收器一般采用的是复制算法，复制算法的优点是效率高，缺点是内存利用率低；老年代回收器一般采用的是标记-整理的算法进行垃圾回收。</p>\n<h3 id=\"_206-简述分代垃圾回收器是怎么工作的\"> 206.简述分代垃圾回收器是怎么工作的?</h3>\n<p>分代回收器有两个分区：老生代和新生代，新生代默认的空间占比总空间的 1/3，老生代的默认占比是 2/3。</p>\n<p>新生代使用的是复制算法，新生代里有 3 个分区：Eden、To Survivor、From Survivor，它们的默认占比是 8:1:1，它的执行流程如下：</p>\n<ul>\n<li>把 Eden + From Survivor 存活的对象放入 To Survivor 区；</li>\n<li>清空 Eden 和 From Survivor 分区；</li>\n<li>From Survivor 和 To Survivor 分区交换，From Survivor 变 To Survivor，To Survivor 变 From Survivor。</li>\n</ul>\n<p>每次在 From Survivor 到 To Survivor 移动时都存活的对象，年龄就 +1，当年龄到达 15（默认配置是 15）时，升级为老生代。大对象也会直接进入老生代。</p>\n<p>老生代当空间占用到达某个值之后就会触发全局垃圾收回，一般使用标记整理的执行算法。以上这些循环往复就构成了整个分代垃圾回收的整体执行流程。</p>\n<h3 id=\"_207-说一下jvm调优的工具\"> 207.说一下jvm调优的工具?</h3>\n<p>JDK 自带了很多监控工具，都位于 JDK 的 bin 目录下，其中最常用的是 jconsole 和 jvisualvm 这两款视图监控工具。</p>\n<ul>\n<li>jconsole：用于对 JVM 中的内存、线程和类等进行监控；</li>\n<li>jvisualvm：JDK 自带的全能分析工具，可以分析：内存快照、线程快照、程序死锁、监控内存的变化、gc 变化等。</li>\n</ul>\n<h3 id=\"_208-常用的jvm调优的参数都有哪些\"> 208.常用的jvm调优的参数都有哪些?</h3>\n<ul>\n<li>-Xms2g：初始化推大小为 2g；</li>\n<li>-Xmx2g：堆最大内存为 2g；</li>\n<li>-XX:NewRatio=4：设置年轻的和老年代的内存比例为 1:4；</li>\n<li>-XX:SurvivorRatio=8：设置新生代 Eden 和 Survivor 比例为 8:2；</li>\n<li>–XX:+UseParNewGC：指定使用 ParNew + Serial Old 垃圾回收器组合；</li>\n<li>-XX:+UseParallelOldGC：指定使用 ParNew + ParNew Old 垃圾回收器组合；</li>\n<li>-XX:+UseConcMarkSweepGC：指定使用 CMS + Serial Old 垃圾回收器组合；</li>\n<li>-XX:+PrintGC：开启打印 gc 信息；</li>\n<li>-XX:+PrintGCDetails：打印 gc 详细信息。</li>\n</ul>\n",
      "date_modified": "2021-02-07T05:08:56.000Z",
      "authors": [
        {
          "name": "南辞"
        }
      ],
      "tags": []
    },
    {
      "title": "面试准备",
      "url": "http://qiqi.dreamagain.top/interview/",
      "id": "http://qiqi.dreamagain.top/interview/",
      "summary": "<blockquote>\n<p><img src=\"https://img.shields.io/badge/%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3-blue.svg\" alt=\"img\"></p>\n</blockquote>\n",
      "content_html": "<blockquote>\n<p><img src=\"https://img.shields.io/badge/%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3-blue.svg\" alt=\"img\"></p>\n</blockquote>\n\n<h2 id=\"网上面试题\"> 网上面试题</h2>\n<p><a href=\"./Java208/\">Java必备208道面试题</a></p>\n",
      "image": "https://img.shields.io/badge/面试相关-blue.svg",
      "date_modified": "2021-02-07T05:08:56.000Z",
      "authors": [
        {
          "name": "南辞"
        }
      ],
      "tags": [
        "面试"
      ]
    },
    {
      "title": "后端框架",
      "url": "http://qiqi.dreamagain.top/program/backend/framework/",
      "id": "http://qiqi.dreamagain.top/program/backend/framework/",
      "content_html": "<h2 id=\"一、spring家族\"> 一、Spring家族</h2>\n<h3 id=\"一-spring-framework\"> <a href=\"\">（一）Spring Framework</a></h3>\n<h3 id=\"二-spring-mvc\"> <a href=\"\">（二）Spring MVC</a></h3>\n<h3 id=\"三-spring-boot\"> <a href=\"\">（三）Spring Boot</a></h3>\n<h3 id=\"四-spring-security\"> <a href=\"\">（四）Spring Security</a></h3>\n<h3 id=\"五-spring-cloud\"> <a href=\"\">（五）Spring Cloud</a></h3>\n<h2 id=\"二、orm框架\"> 二、ORM框架</h2>\n<h3 id=\"一-mybatis\"> <a href=\"\">（一）MyBatis</a></h3>\n<h3 id=\"二-mybatis-plus\"> <a href=\"\">（二）MyBatis-Plus</a></h3>\n<h3 id=\"三-hibanate\"> <a href=\"\">（三）Hibanate</a></h3>\n",
      "date_modified": "2021-02-08T17:34:42.000Z",
      "authors": [
        {
          "name": "南辞"
        }
      ],
      "tags": [
        "框架"
      ]
    },
    {
      "title": "JavaSE-注解",
      "url": "http://qiqi.dreamagain.top/program/backend/java/annotation/",
      "id": "http://qiqi.dreamagain.top/program/backend/java/annotation/",
      "content_html": "<h2 id=\"为什么要引入注解\"> 为什么要引入注解？</h2>\n<p>使用注解之前(甚至在使用之后)，XML被广泛的应用于描述元数据，得到各大框架的青睐，它以松耦合的方式完成了框架中几乎所有的配置，但是随着项目越来越庞大，XML的内容也越来越复杂，一些应用开发人员和架构师发现维护成本变高。他们希望使用一些和代码紧耦合的东西，于是就有人提出来一种标记式高耦合的配置方式注解。方法上可以进行注解，类上也可以注解，字段属性上也可以注解，反正几乎需要配置的地方都可以进行注解。</p>\n<p>【注解】 VS 【XML】:</p>\n<ul>\n<li>注解可以提供更大的便捷性，易于维护修改，但耦合度高</li>\n<li>XML相对于注解则是相反的。追求低耦合就要抛弃高效率，追求效率必然会遇到耦合。</li>\n</ul>\n<div><p>如何选择</p>\n<p>假如你想为应用设置很多的常量或参数，这种情况下，【XML】是一个很好的选择，因为它不会同特定的代码耦合。</p>\n<p>如果你想把某个方法声明为服务，那么使用【注解】会更好一些，因为这种情况下需要注解和方法紧密耦合起来，开发人员也必须认识到这点。</p>\n<p>目前，许多框架将【XML】和【注解】两种方式结合使用，平衡两者之间的利弊。</p>\n</div>\n<h2 id=\"什么是注解\"> 什么是注解</h2>\n<p>注解也叫<strong>元数据</strong>，即一种描述数据的数据。例如我们常见的@Override和@Deprecated，注解是JDK1.5版本开始引入的一个特性，用于对代码进行说明，可以对包、类、接口、字段、方法参数、局部变量等进行注解</p>\n<p>Annotation接口中有下面这句话来描述注解：Annotation 是所有注解继承的公共接口</p>\n<div><pre><code><span>The</span> common <span>interface</span> extended by all annotation types<span>.</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>注解本质是一个继承了Annotation的特殊接口，其具体实现类是Java运行时生成的动态代理类。而我们通过反射获取注解时，返回的是Java运行时生成的动态代理对象$Proxy1。通过代理对象调用自定义注解（接口）的方法，会最终调用AnnotationInvocationHandler的invoke方法。该方法会从memberValues这个Map中索引出对应的值。而memberValues的来源是Java常量池。</p>\n<p><strong>一个注解准确意义上来说，只不过是一种特殊的注释而已，如果没有解析它的代码，它可能连注释都不如。</strong></p>\n<p>而解析一个类或者方法的注解往往有两种形式，一种是编译期直接的扫描，一种是运行期反射。反射的事情我们先不讨论，而编译器的扫描指的是编译器在对 Java 代码编译成字节码的过程中会检测到某个类或者方法被一些注解修饰，这时它就会对于这些注解进行某些处理。</p>\n<div><pre><code><span>@Override</span>\n<span>public</span> <span>String</span> <span>toString</span><span>(</span><span>)</span> <span>{</span>\n    <span>return</span> <span>\"Hello Annotation\"</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>上面的代码中重写了<code>toString()</code>方法并使用了<code>@Override</code>注解。但是，即使不使用<code>@Override</code>注解标记代码，程序也能够正常执行。那么，该注解表示什么？这么写有什么好处吗？事实上，<code>@Override</code>告诉编译器这个方法是一个重写方法(描述方法的元数据)，如果父类中不存在该方法，编译器便会报错，提示该方法没有重写父类中的方法。如果我不小心拼写错误，例如将<code>toString()</code>写成了<code>toStrring()</code>，而且我也没有使用<code>@Override</code>注解，那程序依然能编译运行。但运行结果会和我期望的大不相同。现在我们了解了什么是注解，并且使用注解有助于提高代码的可读性。</p>\n<h2 id=\"注解的用途\"> 注解的用途</h2>\n<ol>\n<li>生成文档，通过代码里标识的元数据生成javadoc文档。</li>\n<li>编译检查，通过代码里标识的元数据让编译器在编译期间进行检查验证。</li>\n<li>编译时动态处理，编译时通过代码里标识的元数据动态处理，例如动态生成代码。</li>\n<li>运行时动态处理，运行时通过代码里标识的元数据动态处理，例如使用反射注入实例</li>\n</ol>\n<h2 id=\"注解的分类\"> 注解的分类</h2>\n<p>Java 定义了一套注解，共有 7 个，3 个在 java.lang 中，剩下 4 个在 java.lang.annotation 中。</p>\n<p><strong>作用在代码的注解</strong> ( <mark>使用这些注解后编译器就会进行检查</mark> )</p>\n<ol>\n<li>\n<p>@Override ：检查该方法是否是重写方法。如果发现其父类，或者是引用的接口中并没有该方法时，会报编译错误。</p>\n</li>\n<li>\n<p>@Deprecated ：标记过时方法。如果使用该方法，会报编译警告。</p>\n</li>\n<li>\n<p>@SuppressWarnings ：指示编译器去忽略注解中声明的警告。</p>\n</li>\n</ol>\n<p><strong>元注解</strong>（ <mark>用于定义注解的注解</mark> ）</p>\n<ol>\n<li>@Retention ：标识这个注解怎么保存，是只在代码中，还是编入class文件中，或者是在运行时可以通过反射访问。</li>\n<li>@Documented ： 标记这些注解是否包含在用户文档中。</li>\n<li>@Target ：标记这个注解应该是哪种 Java 成员。</li>\n<li>@Inherited ： 标记这个注解是继承于哪个注解类(默认 注解并没有继承于任何子类)</li>\n</ol>\n<p><strong>Java7之后额外添加了 3 个注解</strong></p>\n<ul>\n<li>@SafeVarargs ： Java 7 开始支持，忽略任何使用参数为泛型变量的方法或构造函数调用产生的警告。</li>\n<li>@FunctionalInterface ： Java 8 开始支持，标识一个匿名函数或函数式接口。</li>\n<li>@Repeatable： Java 8 开始支持，标识某注解可以在同一个声明上使用多次，属于元注解。</li>\n</ul>\n<p><strong>自定义注解</strong></p>\n<p>​         可以根据自己的需求定义注解</p>\n<h2 id=\"元注解\"> 元注解</h2>\n<p>要想真正掌握怎么使用注解，还需要先学习一下元注解。元注解(meta annotation)是用于修饰注解的注解</p>\n<p>元注解有 @Retention、@Documented、@Target、@Inherited、@Repeatable 5 种。</p>\n<h3 id=\"target\"> @Target</h3>\n<p>Target 是目标的意思，使用<code>@Target</code>可以定义<code>Annotation</code>能够被应用于源码的哪些位置，可以这样理解，当一个注解被 @Target 注解时，这个注解就被限定了 <mark>运用场景</mark>。</p>\n<p>@Target 有下面的取值：</p>\n<ul>\n<li><code>ElementType.ANNOTATION_TYPE</code> 可以给一个注解进行注解</li>\n<li><code>ElementType.CONSTRUCTOR</code> 可以给构造方法进行注解</li>\n<li><code>ElementType.FIELD</code> 可以给属性进行注解</li>\n<li><code>ElementType.LOCAL_VARIABLE</code> 可以给局部变量进行注解</li>\n<li><code>ElementType.METHOD</code> 可以给方法进行注解</li>\n<li><code>ElementType.PACKAGE</code> 可以给一个包进行注解</li>\n<li><code>ElementType.PARAMETER</code> 可以给一个方法内的参数进行注解</li>\n<li><code>ElementType.TYPE</code> 可以给一个类型进行注解，比如类、接口、枚举</li>\n</ul>\n<p><code>@Target</code>注解参数可以是数组<code>{ ElementType.METHOD, ElementType.FIELD }</code>，如：</p>\n<div><pre><code><span>// Java语言使用`@interface`语法来定义注解（`Annotation`）</span>\n<span>// 参数表明此自定义注解可以用在方法或字段上</span>\n<span>@Target</span><span>(</span><span>{</span><span>ElementType</span><span>.</span>METHOD<span>,</span><span>ElementType</span><span>.</span>FIELD<span>}</span><span>)</span>\n<span>public</span> <span>@interface</span> <span>MyAnnotation</span> <span>{</span>\n    <span>.</span><span>.</span><span>.</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><hr>\n<h3 id=\"retention\"> @Retention</h3>\n<p>Retention 的英文意为保留期的意思。当 @Retention 应用到一个注解上的时候，它解释说明了这个注解的的 <mark>生命周期</mark>。</p>\n<p>它的取值如下：</p>\n<ul>\n<li><code>RetentionPolicy.SOURCE</code> 注解只在源码阶段保留，在编译器进行编译时它将被丢弃忽视。</li>\n<li><code>RetentionPolicy.CLASS</code>注解只被保留到编译进行,生成.class文件的时候，它并不会被加载到 JVM 中。如Java内置注解，@Override、@Deprecated、@SuppressWarnning等</li>\n<li><code>RetentionPolicy.RUNTIME</code> 注解可以保留到程序运行的时候，它会被加载进入到 JVM 中，所以在程序运行时可以获取到它们。如SpringMVC中的@Controller、@Autowired、@RequestMapping等。</li>\n</ul>\n<div><p>提示</p>\n<p>如果<code>@Retention</code>不存在，则该<code>Annotation</code>默认为<code>CLASS</code>。因为通常我们自定义的<code>Annotation</code>都是<code>RUNTIME</code>，所以，务必要加上<code>@Retention(RetentionPolicy.RUNTIME)</code>这个元注解</p>\n</div>\n<hr>\n<h3 id=\"repeatable\"> @Repeatable</h3>\n<p>Repeatable 自然是可重复的意思。@Repeatable 是 Java 1.8 才加进来的，所以算是一个新的特性。这个注解应用不是特别广泛。</p>\n<p>Repeatable使用场景：在需要对同一种注解多次使用时，往往需要借助@Repeatable。</p>\n<p>下面举例说明一下，在生活中一个人往往是具有多种身份，如果我把每种身份当成一种注解该如何使用</p>\n<p>先声明一个Persons类用来包含所有的身份</p>\n<div><pre><code><span>@Target</span><span>(</span><span>ElementType</span><span>.</span>TYPE<span>)</span> \n<span>@Retention</span><span>(</span><span>RetentionPolicy</span><span>.</span>RUNTIME<span>)</span>\n<span>public</span> <span>@interface</span> <span>Persons</span> <span>{</span>\n\t<span>Person</span><span>[</span><span>]</span> <span>value</span><span>(</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>这里@Target是声明Persons注解的作用范围，参数ElementType.Type代表可以给一个类进行注解</p>\n<p>@Retention是注解的有效时间，RetentionPolicy.RUNTIME是指程序运行的时候。</p>\n<p>Person注解</p>\n<div><pre><code><span>@Repeatable</span><span>(</span><span>Persons</span><span>.</span><span>class</span><span>)</span>\n<span>public</span> <span>@interface</span> <span>Person</span><span>{</span>\n\t<span>String</span> <span>role</span><span>(</span><span>)</span> <span>default</span> <span>\"\"</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>@Repeatable括号内的就相当于用来保存该注解内容的容器。</p>\n<p>声明一个Man类，给该类加上一些身份。</p>\n<div><pre><code><span>@Person</span><span>(</span>role<span>=</span><span>\"CEO\"</span><span>)</span>\n<span>@Person</span><span>(</span>role<span>=</span><span>\"husband\"</span><span>)</span>\n<span>@Person</span><span>(</span>role<span>=</span><span>\"father\"</span><span>)</span>\n<span>public</span>   <span>class</span> <span>Man</span> <span>{</span>\n\t<span>String</span> name<span>=</span><span>\"\"</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>在主方法中访问该注解。</p>\n<div><pre><code><span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n    <span>Annotation</span><span>[</span><span>]</span> annotations <span>=</span> <span>Man</span><span>.</span><span>class</span><span>.</span><span>getAnnotations</span><span>(</span><span>)</span><span>;</span>  \n    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>annotations<span>.</span>length<span>)</span><span>;</span>\n    <span>Persons</span> p<span>=</span><span>(</span><span>Persons</span><span>)</span> annotations<span>[</span><span>0</span><span>]</span><span>;</span>\n    <span>for</span><span>(</span><span>Person</span> t<span>:</span>p<span>.</span><span>value</span><span>(</span><span>)</span><span>)</span><span>{</span>\n    \t<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>t<span>.</span><span>role</span><span>(</span><span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>运行结果</p>\n<div><pre><code><span>1</span>\nCEO\nhusband\nfather\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id=\"inherited\"> @Inherited</h3>\n<p>使用<code>@Inherited</code>定义子类是否可继承父类定义的<code>Annotation</code>。<code>@Inherited</code>仅针对<code>@Target(ElementType.TYPE)</code>类型的<code>annotation</code>有效，并且仅针对<code>class</code>的继承，对<code>interface</code>的继承无效：</p>\n<div><pre><code><span>@Inherited</span>\n<span>@Target</span><span>(</span><span>ElementType</span><span>.</span>TYPE<span>)</span>\n<span>public</span> <span>@interface</span> <span>MyAnnotation</span> <span>{</span>\n    <span>int</span> <span>type</span><span>(</span><span>)</span> <span>default</span> <span>0</span><span>;</span>\n    <span>String</span> <span>level</span><span>(</span><span>)</span> <span>default</span> <span>\"info\"</span><span>;</span>\n    <span>String</span> <span>value</span><span>(</span><span>)</span> <span>default</span> <span>\"\"</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>在使用的时候，如果一个类用到了<code>@MyAnnotation</code>：</p>\n<div><pre><code><span>@MyAnnotation</span><span>(</span>type<span>=</span><span>1</span><span>)</span>\n<span>public</span> <span>class</span> <span>Person</span> <span>{</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>则它的子类默认也定义了该注解：</p>\n<div><pre><code><span>public</span> <span>class</span> <span>Student</span> <span>extends</span> <span>Person</span> <span>{</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><h3 id=\"documented\"> @Documented</h3>\n<p>顾名思义，这个元注解肯定是和文档有关。它的作用是能够将注解中的元素包含到 Javadoc 中去。</p>\n<p>如果使用@Documented标注了，在生成javadoc的时候就会把@Documented注解给显示出来。</p>\n<p>@Documented注解只是用来做标识，没什么实际作用，了解就好。</p>\n<p><img src=\"./assets/java-01.png\" alt=\"\"></p>\n<p><img src=\"./assets/java-02.png\" alt=\"\"></p>\n<h2 id=\"自定义注解\"> 自定义注解</h2>\n<h3 id=\"第一步-用-interface定义注解\"> 第一步，用<code>@interface</code>定义注解：</h3>\n<div><pre><code><span>public</span> <span>@interface</span> <span>MyAnnotation</span> <span>{</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><h3 id=\"第二步-添加参数、默认值\"> 第二步，添加参数、默认值：</h3>\n<div><pre><code><span>public</span> <span>@interface</span> <span>MyAnnotation</span> <span>{</span>\n    <span>int</span> <span>type</span><span>(</span><span>)</span> <span>default</span> <span>0</span><span>;</span>\n    <span>String</span> <span>level</span><span>(</span><span>)</span> <span>default</span> <span>\"info\"</span><span>;</span>\n    <span>String</span> <span>value</span><span>(</span><span>)</span> <span>default</span> <span>\"\"</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>注解的参数类似无参数方法，可以用<code>default</code>设定一个默认值（强烈推荐）。把最常用的参数定义为<code>value()</code>，推荐所有参数都尽量设置默认值。</p>\n<h3 id=\"第三步-用元注解配置注解\"> 第三步，用元注解配置注解：</h3>\n<div><pre><code><span>@Target</span><span>(</span><span>ElementType</span><span>.</span>TYPE<span>)</span>\n<span>@Retention</span><span>(</span><span>RetentionPolicy</span><span>.</span>RUNTIME<span>)</span>\n<span>public</span> <span>@interface</span> <span>MyAnnotation</span> <span>{</span>\n    <span>int</span> <span>type</span><span>(</span><span>)</span> <span>default</span> <span>0</span><span>;</span>\n    <span>String</span> <span>level</span><span>(</span><span>)</span> <span>default</span> <span>\"info\"</span><span>;</span>\n    <span>String</span> <span>value</span><span>(</span><span>)</span> <span>default</span> <span>\"\"</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>其中，必须设置<code>@Target</code>和<code>@Retention</code>，<code>@Retention</code>一般设置为<code>RUNTIME</code>，因为我们自定义的注解通常要求在运行期读取。一般情况下，不必写<code>@Inherited</code>和<code>@Repeatable</code>。</p>\n<div><p>小结</p>\n<ul>\n<li>Java使用<code>@interface</code>定义注解;</li>\n<li>可定义多个参数和默认值，核心参数使用<code>value</code>名称；</li>\n<li>必须设置<code>@Target</code>来指定<code>Annotation</code>可以应用的范围；</li>\n<li>应当设置<code>@Retention(RetentionPolicy.RUNTIME)</code>便于运行期读取该<code>Annotation</code>。</li>\n</ul>\n</div>\n<h2 id=\"注解的属性\"> 注解的属性</h2>\n<p>注解的属性也叫做成员变量。注解只有成员变量，没有方法。注解的成员变量在注解的定义中以“无形参的方法”形式来声明，其方法名定义了该成员变量的名字，其返回值定义了该成员变量的类型。</p>\n<div><pre><code><span>@Target</span><span>(</span><span>ElementType</span><span>.</span>TYPE<span>)</span>\n<span>@Retention</span><span>(</span><span>RetentionPolicy</span><span>.</span>RUNTIME<span>)</span>\n<span>public</span> <span>@interface</span> <span>TestAnnotation</span><span>{</span>\n    \n    <span>int</span> <span>id</span><span>(</span><span>)</span><span>;</span>\n    \n    <span>String</span> <span>msg</span><span>(</span><span>)</span><span>;</span>\n\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>上面代码定义了 @TestAnnotation 这个注解中拥有 id 和 msg 两个属性。在使用的时候，我们应该给它们进行赋值。</p>\n<p>赋值的方式是在注解的括号内以 value=&quot;&quot; 形式，多个属性之前用 ，隔开。</p>\n<div><pre><code><span>@TestAnnotation</span><span>(</span>id<span>=</span><span>3</span><span>,</span> msg<span>=</span><span>\"hello annotation\"</span><span>)</span>\n<span>public</span> <span>class</span> <span>Test</span> <span>{</span>\n\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h2 id=\"快捷方式\"> 快捷方式</h2>\n<p>所谓的快捷方式就是注解中定义了名为value的元素，并且在使用该注解时，如果该元素是唯一需要赋值的一个元素，那么此时无需使用key=value的语法，而只需在括号内给出value元素所需的值即可。这可以应用于任何合法类型的元素，记住，这限制了 <mark>元素名必须为value</mark>，<strong>推荐设置默认值</strong>，简单案例如下</p>\n<div><pre><code><span>@Target</span><span>(</span><span>ElementType</span><span>.</span>FIELD<span>)</span>\n<span>@Retention</span><span>(</span><span>RetentionPolicy</span><span>.</span>RUNTIME<span>)</span>\n<span>@interface</span> <span>IntegerVaule</span><span>{</span>\n   <span>int</span> <span>value</span><span>(</span><span>)</span> <span>default</span> <span>0</span><span>;</span>\n   <span>String</span> <span>name</span><span>(</span><span>)</span> <span>default</span> <span>\"\"</span><span>;</span>\n<span>}</span>\n\n<span>public</span> <span>class</span> <span>QuicklyWay</span> <span>{</span>\n   \n   <span>@IntegerVaule</span><span>(</span><span>20</span><span>)</span>\n   <span>public</span> <span>int</span> age<span>;</span>\n   \n   <span>@IntegerVaule</span><span>(</span>value <span>=</span> <span>10000</span><span>,</span> name <span>=</span> <span>\"MONEY\"</span><span>)</span>\n   <span>public</span> <span>int</span> money<span>;</span>\n \n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><h2 id=\"注解不支持继承\"> 注解不支持继承</h2>\n<p>注解是不支持继承的，因此不能使用关键字extends来继承某个@interface，但注解在编译后，编译器会自动继承java.lang.annotation.Annotation接口</p>\n<h2 id=\"处理注解\"> 处理注解</h2>\n<h3 id=\"定义了4个注解来演示注解的声明\"> 定义了4个注解来演示注解的声明</h3>\n<ol>\n<li>定义一个可以注解在Class，interface，enum上的注解</li>\n<li>定义一个可以注解在METHOD上的注解</li>\n<li>定义一个可以注解在FIELD上的注解</li>\n<li>定义一个可以注解在PARAMETER上的注解</li>\n</ol>\n<div><pre><code><span>@Target</span><span>(</span><span>ElementType</span><span>.</span>TYPE<span>)</span>\n<span>@Retention</span><span>(</span><span>RetentionPolicy</span><span>.</span>RUNTIME<span>)</span>\n<span>public</span> <span>@interface</span> <span>MyAnTargetType</span> <span>{</span>\n\n    <span>/**\n     * 定义注解的一个元素 并给定默认值\n     * @return\n     */</span>\n    <span>String</span> <span>value</span><span>(</span><span>)</span> <span>default</span> <span>\"定义在类、接口、枚举类上的注解元素value的默认值\"</span><span>;</span>\n\n<span>}</span>\n<span>@Target</span><span>(</span><span>{</span><span>ElementType</span><span>.</span>METHOD<span>}</span><span>)</span>\n<span>@Retention</span><span>(</span><span>RetentionPolicy</span><span>.</span>RUNTIME<span>)</span>\n<span>public</span> <span>@interface</span> <span>MyAnTargetMethod</span> <span>{</span>\n\n    <span>/**\n     * 定义注解的一个元素 并给定默认值\n     * @return\n     */</span>\n    <span>String</span> <span>value</span><span>(</span><span>)</span> <span>default</span> <span>\"定义在方法上的注解元素value的默认值\"</span><span>;</span>\n\n<span>}</span>\n<span>@Target</span><span>(</span><span>{</span><span>ElementType</span><span>.</span>FIELD<span>}</span><span>)</span>\n<span>@Retention</span><span>(</span><span>RetentionPolicy</span><span>.</span>RUNTIME<span>)</span>\n<span>public</span> <span>@interface</span> <span>MyAnTargetField</span> <span>{</span>\n\n    <span>/**\n     * 定义注解的一个元素 并给定默认值\n     * @return\n     */</span>\n    <span>String</span> <span>value</span><span>(</span><span>)</span> <span>default</span> <span>\"定义在字段上的注解元素value的默认值\"</span><span>;</span>\n\n<span>}</span>\n<span>@Target</span><span>(</span><span>{</span><span>ElementType</span><span>.</span>PARAMETER<span>}</span><span>)</span>\n<span>@Retention</span><span>(</span><span>RetentionPolicy</span><span>.</span>RUNTIME<span>)</span>\n<span>public</span> <span>@interface</span> <span>MyAnTargetParameter</span> <span>{</span>\n\n    <span>/**\n     * 定义注解的一个元素 并给定默认值\n     * @return\n     */</span>\n    <span>String</span> <span>value</span><span>(</span><span>)</span> <span>default</span> <span>\"定义在参数上的注解元素value的默认值\"</span><span>;</span>\n\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br></div></div><h3 id=\"编写一个测试处理类处理以上注解\"> 编写一个测试处理类处理以上注解</h3>\n<p>因为注解定义后也是一种<code>class</code>，所有的注解都继承自<code>java.lang.annotation.Annotation</code>，因此，读取注解，需要使用反射API。</p>\n<p><strong>Java提供的使用反射API读取<code>Annotation</code>的方法包括</strong>：</p>\n<p>（1）判断某个注解是否存在于<code>Class</code>、<code>Field</code>、<code>Method</code>或<code>Constructor</code>：</p>\n<ul>\n<li><code>Class.isAnnotationPresent(Class)</code></li>\n<li><code>Field.isAnnotationPresent(Class)</code></li>\n<li><code>Method.isAnnotationPresent(Class)</code></li>\n<li><code>Constructor.isAnnotationPresent(Class)</code></li>\n</ul>\n<p>（2）使用反射API读取Annotation：</p>\n<ul>\n<li><code>Class.getAnnotation(Class)</code></li>\n<li><code>Field.getAnnotation(Class)</code></li>\n<li><code>Method.getAnnotation(Class)</code></li>\n<li><code>Constructor.getAnnotation(Class)</code></li>\n</ul>\n<p><strong>使用反射API读取<code>Annotation</code>有两种方法</strong>：</p>\n<p>方法一：先判断<code>Annotation</code>是否存在，如果存在，就直接读取：</p>\n<div><pre><code><span>Class</span> test <span>=</span> <span>Test</span><span>.</span><span>class</span><span>;</span>\n<span>if</span> <span>(</span>cls<span>.</span><span>isAnnotationPresent</span><span>(</span><span>MyAnnotation</span><span>.</span><span>class</span><span>)</span><span>)</span> <span>{</span>\n    <span>MyAnnotation</span> <span>MyAnnotation</span> <span>=</span> test<span>.</span><span>getAnnotation</span><span>(</span><span>MyAnnotation</span><span>.</span><span>class</span><span>)</span><span>;</span>\n    <span>.</span><span>.</span><span>.</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>方法二：直接读取<code>Annotation</code>，如果<code>Annotation</code>不存在，将返回<code>null</code>：</p>\n<div><pre><code><span>Class</span> test <span>=</span> <span>Test</span><span>.</span><span>class</span><span>;</span>\n<span>MyAnnotation</span> <span>MyAnnotation</span> <span>=</span> test<span>.</span><span>getAnnotation</span><span>(</span><span>MyAnnotation</span><span>.</span><span>class</span><span>)</span><span>;</span>\n<span>if</span> <span>(</span><span>MyAnnotation</span> <span>!=</span> <span>null</span><span>)</span> <span>{</span>\n   <span>.</span><span>.</span><span>.</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>知道如何获取注解后可以接下来的测试了</p>\n<div><pre><code><span>package</span> <span>test</span><span>;</span>\n\n<span>import</span> <span>java<span>.</span>lang<span>.</span>annotation<span>.</span></span><span>Annotation</span><span>;</span>\n<span>import</span> <span>java<span>.</span>lang<span>.</span>reflect<span>.</span></span><span>Method</span><span>;</span>\n\n<span>@MyAnTargetType</span>\n<span>public</span> <span>class</span> <span>AnnotationTest</span> <span>{</span>\n\n    <span>@MyAnTargetField</span>\n    <span>private</span> <span>String</span> field <span>=</span> <span>\"我是字段\"</span><span>;</span>\n\n    <span>@MyAnTargetMethod</span><span>(</span><span>\"测试方法\"</span><span>)</span>\n    <span>public</span> <span>void</span> <span>test</span><span>(</span><span>@MyAnTargetParameter</span> <span>String</span> args<span>)</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"参数值 === \"</span> <span>+</span> args<span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n        <span>// 1、先获取Class实例</span>\n        <span>Class</span><span><span>&lt;</span><span>AnnotationTest</span><span>></span></span> testClass <span>=</span> <span>AnnotationTest</span><span>.</span><span>class</span><span>;</span>\n\n        <span>// 2、反射获取类上的注解MyAnTargetType</span>\n        <span>MyAnTargetType</span> t <span>=</span> testClass<span>.</span><span>getAnnotation</span><span>(</span><span>MyAnTargetType</span><span>.</span><span>class</span><span>)</span><span>;</span>\n        <span>if</span> <span>(</span>t <span>!=</span> <span>null</span><span>)</span><span>{</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"类上的注解值 === \"</span> <span>+</span> t<span>.</span><span>value</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>}</span>\n\n        <span>MyAnTargetMethod</span> tm <span>=</span> <span>null</span><span>;</span>\n        <span>try</span> <span>{</span>\n            <span>// 3、反射获取AnnotationTest类上的test方法</span>\n            <span>Method</span> method <span>=</span> testClass<span>.</span><span>getDeclaredMethod</span><span>(</span><span>\"test\"</span><span>,</span> <span>String</span><span>.</span><span>class</span><span>)</span><span>;</span>\n            <span>// 获取方法上的注解MyAnTargetMethod</span>\n            tm <span>=</span> method<span>.</span><span>getAnnotation</span><span>(</span><span>MyAnTargetMethod</span><span>.</span><span>class</span><span>)</span><span>;</span>\n            <span>if</span> <span>(</span>tm <span>!=</span> <span>null</span><span>)</span><span>{</span>\n                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"方法上的注解值 === \"</span> <span>+</span> tm<span>.</span><span>value</span><span>(</span><span>)</span><span>)</span><span>;</span>\n            <span>}</span>\n\n            <span>// 4、获取方法上的所有参数注解  循环所有注解找到MyAnTargetParameter注解</span>\n            <span>// 要读取方法参数的Annotation就比较麻烦一点，因为方法参数本身可以看成一个数组，</span>\n            <span>// 而每个参数又可以定义多个注解，所以，一次获取方法参数的所有注解就必须用一个二维数组来表示。</span>\n            <span>// 获取所有参数的Annotation:</span>\n            <span>Annotation</span><span>[</span><span>]</span><span>[</span><span>]</span> annotations <span>=</span> method<span>.</span><span>getParameterAnnotations</span><span>(</span><span>)</span><span>;</span>\n            <span>for</span> <span>(</span><span>Annotation</span><span>[</span><span>]</span> tt <span>:</span> annotations<span>)</span> <span>{</span>\n                <span>for</span> <span>(</span><span>Annotation</span> t1 <span>:</span> tt<span>)</span> <span>{</span>\n                    <span>if</span> <span>(</span>t1 <span>instanceof</span> <span>MyAnTargetParameter</span><span>)</span> <span>{</span>\n                        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"参数上的注解值 === \"</span> <span>+</span> <span>(</span><span>(</span><span>MyAnTargetParameter</span><span>)</span> t1<span>)</span><span>.</span><span>value</span><span>(</span><span>)</span><span>)</span><span>;</span>\n                    <span>}</span>\n                <span>}</span>\n            <span>}</span>\n            method<span>.</span><span>invoke</span><span>(</span><span>new</span> <span>AnnotationTest</span><span>(</span><span>)</span><span>,</span> <span>\"改变默认参数\"</span><span>)</span><span>;</span>\n            <span>// 获取AnnotationTest类上字段field的注解MyAnTargetField</span>\n            <span>MyAnTargetField</span> fieldAn <span>=</span> testClass<span>.</span><span>getDeclaredField</span><span>(</span><span>\"field\"</span><span>)</span><span>.</span><span>getAnnotation</span><span>(</span><span>MyAnTargetField</span><span>.</span><span>class</span><span>)</span><span>;</span>\n            <span>if</span> <span>(</span>fieldAn <span>!=</span> <span>null</span><span>)</span><span>{</span>\n                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"字段上的注解值 === \"</span> <span>+</span> fieldAn<span>.</span><span>value</span><span>(</span><span>)</span><span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span> <span>catch</span> <span>(</span><span>Exception</span> e<span>)</span> <span>{</span>\n            e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n\n<span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br></div></div><p>输出结果</p>\n<div><pre><code>类上的注解值 === 定义在类接口枚举类上的注解元素value的默认值\n方法上的注解值 === 测试方法\n参数上的注解值 === 定义在参数上的注解元素value的默认值\n参数值 === 改变默认参数\n字段上的注解值 === 定义在字段上的注解元素value的默认值\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h2 id=\"annotation-架构\"> Annotation 架构</h2>\n<p>如果一来就看Annotation 架构可能就很懵逼了，但是学习了上面的相关知识再来看就很清晰了</p>\n<h3 id=\"annotation-架构图\"> <mark>Annotation 架构图</mark>：</h3>\n<img src=\"./assets/java-03.png\" style=\"zoom:80%;\" />\n<p>从图看出：</p>\n<p>1、 <mark>所有注解本质上都继承自Annotation</mark></p>\n<p>2、1 个 Annotation 和 1 个 RetentionPolicy 关联</p>\n<ul>\n<li>RetentionPolicy 是 Enum 枚举类型，它用来指定 Annotation 的策略。通俗点说，就是不同 RetentionPolicy 类型的 Annotation 的作用域不同</li>\n<li>可以理解为：每1个Annotation对象，都会有唯一的RetentionPolicy属性</li>\n</ul>\n<p>3、 1 个 Annotation 和 1~n 个 ElementType 关联</p>\n<ul>\n<li>ElementType 是 Enum 枚举类型，它用来指定 Annotation 的类型</li>\n<li>可以理解为：对于每 1 个 Annotation 对象，可以有若干个 ElementType 属性。</li>\n</ul>\n<h3 id=\"annotation-组成部分\"> Annotation 组成部分</h3>\n<div><pre><code><span>//Annotation.java</span>\n\n<span>package</span> <span>java<span>.</span>lang<span>.</span>annotation</span><span>;</span>\n<span>public</span> <span>interface</span> <span>Annotation</span> <span>{</span>\n\n    <span>boolean</span> <span>equals</span><span>(</span><span>Object</span> obj<span>)</span><span>;</span>\n\n    <span>int</span> <span>hashCode</span><span>(</span><span>)</span><span>;</span>\n\n    <span>String</span> <span>toString</span><span>(</span><span>)</span><span>;</span>\n\n    <span>Class</span><span><span>&lt;</span><span>?</span> <span>extends</span> <span>Annotation</span><span>></span></span> <span>annotationType</span><span>(</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><div><pre><code><span>//ElementType.java</span>\n\n<span>package</span> <span>java<span>.</span>lang<span>.</span>annotation</span><span>;</span>\n<span>public</span> <span>enum</span> <span>ElementType</span> <span>{</span>\n   <span>/**标明该注解可以用于类、接口（包括注解类型）或enum声明*/</span>\n   TYPE<span>,</span>\n \n   <span>/** 标明该注解可以用于字段(域)声明，包括enum实例 */</span>\n   FIELD<span>,</span>\n \n   <span>/** 标明该注解可以用于方法声明 */</span>\n   METHOD<span>,</span>\n \n   <span>/** 标明该注解可以用于参数声明 */</span>\n   PARAMETER<span>,</span>\n \n   <span>/** 标明注解可以用于构造函数声明 */</span>\n   CONSTRUCTOR<span>,</span>\n \n   <span>/** 标明注解可以用于局部变量声明 */</span>\n   LOCAL_VARIABLE<span>,</span>\n \n   <span>/** 标明注解可以用于注解声明(应用于另一个注解上)*/</span>\n   ANNOTATION_TYPE<span>,</span>\n \n   <span>/** 标明注解可以用于包声明 */</span>\n   PACKAGE<span>,</span>\n \n   <span>/**\n    * 标明注解可以用于类型参数声明（1.8新加入）\n    * @since 1.8\n    */</span>\n   TYPE_PARAMETER<span>,</span>\n \n   <span>/**\n    * 类型使用声明（1.8新加入)\n    * @since 1.8\n    */</span>\n   TYPE_USE\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br></div></div><div><pre><code><span>//RetentionPolicy.java</span>\n\n<span>package</span> <span>java<span>.</span>lang<span>.</span>annotation</span><span>;</span>\n<span>public</span> <span>enum</span> <span>RetentionPolicy</span> <span>{</span>\n   <span>/** Annotation信息仅存在于编译器处理期间，编译器处理完之后就没有该Annotation信息了 */</span>\n    SOURCE<span>,</span>            \n\n    <span>/** 编译器将Annotation存储于类对应的.class文件中。默认行为 */</span>\n    CLASS<span>,</span>             \n\n    <span>/** 编译器将Annotation存储于class文件中，并且可由JVM读入 */</span>\n    RUNTIME           \n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><div><p>参考</p>\n<p><a href=\"https://www.liaoxuefeng.com/wiki/1252599548343744/1255945389098144\" target=\"_blank\" rel=\"noopener noreferrer\">廖雪峰 - 注解</a></p>\n<p><a href=\"https://www.runoob.com/w3cnote/java-annotation.html\" target=\"_blank\" rel=\"noopener noreferrer\">菜鸟教程 - 注解</a></p>\n</div>\n",
      "date_modified": "2021-02-08T17:34:42.000Z",
      "authors": [
        {
          "name": "南辞"
        }
      ],
      "tags": [
        "Java"
      ]
    },
    {
      "title": "JavaSE-集合",
      "url": "http://qiqi.dreamagain.top/program/backend/java/collection/",
      "id": "http://qiqi.dreamagain.top/program/backend/java/collection/",
      "summary": "<blockquote>\n<p><img src=\"https://img.shields.io/badge/collection-blue.svg\" alt=\"\"> <img src=\"https://img.shields.io/badge/List-blue.svg\" alt=\"\"> <img src=\"https://img.shields.io/badge/Set-blue.svg\" alt=\"\"> <img src=\"https://img.shields.io/badge/Map-blue.svg\" alt=\"\"></p>\n</blockquote>\n",
      "content_html": "<blockquote>\n<p><img src=\"https://img.shields.io/badge/collection-blue.svg\" alt=\"\"> <img src=\"https://img.shields.io/badge/List-blue.svg\" alt=\"\"> <img src=\"https://img.shields.io/badge/Set-blue.svg\" alt=\"\"> <img src=\"https://img.shields.io/badge/Map-blue.svg\" alt=\"\">\n</p>\n</blockquote>\n<h2 id=\"集合概要\"> 集合概要</h2>\n<p><img src=\"./assets/collection-01.png\" alt=\"\"></p>\n<p>Java的<code>java.util</code>包主要提供了以下三种类型的集合（也可以叫作容器，用来存储对象）</p>\n<ul>\n<li><code>List</code>：一种有序列表的集合</li>\n<li><code>Set</code>：一种保证没有重复元素的集合</li>\n<li><code>Map</code>：一种通过键值（key-value）查找的映射表集合</li>\n</ul>\n<p>Java集合的设计有几个特点：</p>\n<ol>\n<li>\n<p>一是实现了接口和实现类相分离，例如，有序表的接口是<code>List</code>，具体的实现类有<code>ArrayList</code>，<code>LinkedList</code>等，</p>\n</li>\n<li>\n<p>二是支持泛型，我们可以限制在一个集合中只能放入同一种数据类型的元素，如：</p>\n<div><pre><code><span>List</span><span><span>&lt;</span><span>String</span><span>></span></span> list <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span> <span>// 只能放入String类型</span>\n</code></pre>\n<div><span>1</span><br></div></div></li>\n<li>\n<p>三是Java访问集合总是通过统一的方式——迭代器（Iterator）来实现，它最明显的好处在于无需知道集合内部元素是按什么方式存储</p>\n</li>\n</ol>\n<div><p>提示</p>\n<p>由于Java的集合设计非常久远，中间经历过大规模改进，我们要注意到有一小部分集合类是遗留类，不应该继续使用：</p>\n<ul>\n<li><code>Hashtable</code>：一种线程安全的<code>Map</code>实现；</li>\n<li><code>Vector</code>：一种线程安全的<code>List</code>实现；</li>\n<li><code>Stack</code>：基于<code>Vector</code>实现的<code>LIFO</code>的栈。</li>\n</ul>\n<p>还有一小部分接口是遗留接口，也不应该继续使用：</p>\n<ul>\n<li><code>Enumeration&lt;E&gt;</code>：已被<code>Iterator&lt;E&gt;</code>取代。</li>\n</ul>\n</div>\n<h2 id=\"泛型\"> 泛型</h2>\n<p>泛型是JDK1.5以后增加的，它可以帮助我们建立类型安全的集合。在使用了泛型的集合中，遍历时不必进行强制类型转换。JDK提供了支持泛型的编译器，将运行时的类型检查提前到了编译时执行，提高了代码可读性和安全性。</p>\n<p>泛型的本质就是“数据类型的参数化”。 我们可以把“泛型”理解为数据类型的一个占位符(形式参数)，即告诉编译器，在调用泛型时必须传入实际类型。</p>\n<p>为了能够更好的学习集合，建议先学习<strong>泛型</strong>。</p>\n<ul>\n<li><a href=\"./generics.html\">Java泛型学习笔记</a></li>\n<li><a href=\"https://www.w3cschool.cn/java/java-generics.html\" target=\"_blank\" rel=\"noopener noreferrer\">w3cschool教程</a></li>\n</ul>\n<h2 id=\"collection接口\"> Collection接口</h2>\n<p>Collection 表示一组对象，它是集中、收集的意思。Collection接口是List、Set接口的父接口，也就是List、Set都包含Collection中的方法，可以在List、Set接口的实现类中进行测试。</p>\n<p><img src=\"./assets/image-20210208121434678.png\" alt=\"image-20210208121434678\"></p>\n<p>Collection的功能:</p>\n<p>1、添加功能</p>\n<p><code>boolean add (objcet obj)</code>:添加一个元素</p>\n<p><code>boolean addAll(Collection c)</code>:添加一个集合的元素</p>\n<p>2、删除功能:</p>\n<p><code>void clear ()</code>:清除所有的元素</p>\n<p><code>boolean remove (object)</code>:移除一个元素</p>\n<p><code>boolean removeAll(Collection c)</code>:移除本集合和集合c中都包含的元素</p>\n<p>3、判断功能:</p>\n<p><code>boolean contains (0bject o)</code>:判断集合是否包含该元素</p>\n<p><code>boolean containsAll(Collection c)</code>:判断集合中是否包含指定的集合元素，只有包含所有的元素,才叫包含</p>\n<p><code>boolean isEmpty()</code>:判断集合是否为空</p>\n<p>4、获取功能:</p>\n<p><code>Iterator&lt;E&gt;iterator()</code>:迭代器</p>\n<p><code>Object[] toArray()</code>:转化成Object数组</p>\n<p>5、长度功能:</p>\n<p><code>int size()</code>:元素的个数</p>\n<p>6、交集功能:</p>\n<p><code>boolean retainAll(Collection c)</code>:取本集合和集合c都包含的元素</p>\n<p>Collection 类图（工作中需要掌握一些常用的集合类就行了）</p>\n<p><img src=\"./assets/image-20210208122857060.png\" alt=\"image-20210208122857060\"></p>\n<h2 id=\"list接口及其实现类\"> List接口及其实现类</h2>\n<p>List是有序、可重复的容器。</p>\n<p><strong>有序</strong>：List中每个元素都有索引标记。可以根据元素的索引标记(在List中的位置)访问元素，从而精确控制这些元素。</p>\n<p><strong>可重复</strong>：List允许加入重复的元素。更确切地讲，List通常允许满足 e1.equals(e2) 的元素重复加入容器。</p>\n<p>除了Collection接口中的方法，List多了一些跟顺序(索引)有关的方法</p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>void add (int index, Object element)</td>\n<td>在指定位置插入元素，以前元素全部后移一位</td>\n</tr>\n<tr>\n<td>Object set (int index,Object element)</td>\n<td>修改指定位置的元素</td>\n</tr>\n<tr>\n<td>Object get (int index)</td>\n<td>返回指定位置的元素</td>\n</tr>\n<tr>\n<td>Object remove (int index)</td>\n<td>删除指定位置的元素，后面元素全部前移一位</td>\n</tr>\n<tr>\n<td>int indexOf (Object o)</td>\n<td>返回第一个匹配元素的索引，如果没有该元素，返回-1.</td>\n</tr>\n<tr>\n<td>int lastIndexOf (Object o)</td>\n<td>返回最后一个匹配元素的索引，如果没有该元素，返回-1</td>\n</tr>\n</tbody>\n</table>\n",
      "image": "https://img.shields.io/badge/collection-blue.svg",
      "date_modified": "2021-02-08T17:34:42.000Z",
      "authors": [
        {
          "name": "南辞"
        }
      ],
      "tags": [
        "Java"
      ]
    },
    {
      "title": "JavaSE-泛型",
      "url": "http://qiqi.dreamagain.top/program/backend/java/generics/",
      "id": "http://qiqi.dreamagain.top/program/backend/java/generics/",
      "content_html": "<h2 id=\"前言\"> 前言</h2>\n<p>Java 泛型（Generic）的引入加强了参数类型的安全性，减少了类型的转换，但有一点需要注意：Java 的泛型在编译器有效，在运行期被删除，也就是说所有泛型参数类型在编译后都会被清除掉，看下面一个列子，代码如下：</p>\n<div><pre><code><span>public</span> <span>class</span> <span>Foo</span> <span>{</span>\n    <span>public</span> <span>void</span> <span>listMethod</span><span>(</span><span>List</span><span><span>&lt;</span><span>String</span><span>></span></span> stringList<span>)</span><span>{</span>\n    <span>}</span>\n    <span>public</span> <span>void</span> <span>listMethod</span><span>(</span><span>List</span><span><span>&lt;</span><span>Integer</span><span>></span></span> intList<span>)</span> <span>{</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>代码很简单，看起来没什么问题，但是编译器却报出如下错误信息：</p>\n<div><pre><code><span>Method</span> <span>listMethod</span><span>(</span><span>List</span><span><span>&lt;</span><span>String</span><span>></span></span><span>)</span> has the same erasure <span>listMethod</span><span>(</span><span>List</span><span><span>&lt;</span><span>E</span><span>></span></span><span>)</span> as another method in type <span>Foo</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>此错误的意思是说<code>listMethod(List&lt;String&gt;)</code>方法在编译时擦除类型后的方法是<code>listMethod(List&lt;E&gt;)</code>，它与另外一个方法重复，也就是方法签名重复。反编译之后的方法代码如下：</p>\n<div><pre><code><span>public</span> <span>void</span> <span>listMethod</span><span>(</span><span>List</span> list<span>)</span><span>{</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>从上面代码可以看出 Java 编译后的字节码中已经没有泛型的任何信息，在编译后所有的泛型类型都会做相应的转化，转化如下：</p>\n<ul>\n<li><code>List&lt;String&gt;</code>、<code>List&lt;T&gt;</code>擦除后的类型为 List。</li>\n<li><code>List&lt;String&gt;</code>、<code>List&lt;T&gt;[]</code> 擦除后的类型为 List[]。</li>\n<li><code>List&lt;? extends E&gt;、List&lt;? super E&gt;</code> 擦除后的类型为 <code>List&lt;E&gt;</code>。</li>\n<li><code>List&lt;T extends Serialzable &amp; Cloneable&gt;</code> 擦除后类型为 <code>List&lt;Serializable&gt;</code>。</li>\n</ul>\n<p>Java 为什么这么处理呢？有以下两个原因：</p>\n<p>避免 JVM 的大换血（如果 JVM 将泛型类型延续到运行期，那么到运行期时 JVM 就需要进行大量的重构工作了），提高了运行期的效率。  版本兼容。 在编译期擦除可以更好地支持原生类型（Raw Type）。</p>\n<p>明白了 Java 泛型是类型擦除的，下面的问题就很好理解了：</p>\n<h2 id=\"泛型注意点\"> 泛型注意点</h2>\n<h3 id=\"泛型的-class-对象是相同的\"> 泛型的 class 对象是相同的</h3>\n<p>每个类都有一个 class 属性，泛型化不会改变 class 属性的返回值，例如：</p>\n<div><pre><code><span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n\t<span>List</span><span><span>&lt;</span><span>String</span><span>></span></span> ls <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>String</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n\t<span>List</span><span><span>&lt;</span><span>Integer</span><span>></span></span> li <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>Integer</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n\t<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>ls<span>.</span><span>getClass</span><span>(</span><span>)</span> <span>==</span> li<span>.</span><span>getClass</span><span>(</span><span>)</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>代码返回值为 true，原因很简单，<code>List&lt;String&gt;</code> 和<code>List&lt;Integer&gt;</code> 擦除后的类型都是 List。</p>\n<h3 id=\"泛型数组初始化时不能声明泛型类型\"> 泛型数组初始化时不能声明泛型类型</h3>\n<p>如下代码编译时通不过：</p>\n<div><pre><code><span>List</span><span><span>&lt;</span><span>String</span><span>></span></span><span>[</span><span>]</span> list <span>=</span> <span>new</span> <span>List</span><span><span>&lt;</span><span>String</span><span>></span></span><span>[</span><span>]</span><span>;</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>在这里可以声明一个带有泛型参数的数组，但是不能初始化该数组，因为执行了类型擦除操作后，<code>List&lt;Object&gt;[]</code>与 <code>List&lt;String&gt;[]</code>就是同一回事了，编译器拒绝如此声明。</p>\n<h3 id=\"instanceof-不允许存在泛型参数\"> instanceof 不允许存在泛型参数</h3>\n<p>以下代码不能通过编译，原因一样，泛型类型被擦除了。</p>\n<div><pre><code><span>List</span><span><span>&lt;</span><span>String</span><span>></span></span> list <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>String</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>list <span>instanceof</span> <span>List</span><span><span>&lt;</span><span>String</span><span>></span></span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>错误信息如下：<br>\n<code>Cannot perform instanceof check against parameterized type List&lt;String&gt;. Use the form List&lt;?&gt; instead since further generic type information will be erased at runtime</code></p>\n<h2 id=\"类型擦除\"> 类型擦除</h2>\n<p>正确理解泛型概念的首要前提是理解类型擦除（type erasure）。 Java中的泛型基本上都是在编译器这个层次来实现的。在生成的Java字节代码中是不包含泛型中的类型信息的。使用泛型的时候加上的类型参数，会被编译器在编译的时候去掉。这个过程就称为类型擦除。</p>\n<p>如在代码中定义的<code>List&lt;Object&gt;</code>和<code>List&lt;String&gt;</code>等类型，在编译之后都会变成List。JVM看到的只是List，而由泛型附加的类型信息对JVM来说是不可见的。Java编译器会在编译时尽可能的发现可能出错的地方，但是仍然无法避免在运行时刻出现类型转换异常的情况。类型擦除也是Java的泛型实现方式与<a href=\"http://www.cplusplus.com/doc/tutorial/templates/\" target=\"_blank\" rel=\"noopener noreferrer\">C++模板机制</a>实现方式之间的重要区别。</p>\n<p>很多泛型的奇怪特性都与这个类型擦除的存在有关，包括：</p>\n<ul>\n<li>泛型类并没有自己独有的Class类对象。比如并不存在<code>List&lt;String&gt;.class</code>或是<code>List&lt;Integer&gt;.class</code>，而只有<code>List.class</code>。</li>\n<li>静态变量是被泛型类的所有实例所共享的。对于声明为<code>MyClass&lt;T&gt;</code>的类，访问其中的静态变量的方法仍然是 <code>MyClass.myStaticVar</code>。不管是通过<code>new MyClass&lt;String&gt;</code>还是<code>new MyClass&lt;Integer&gt;</code>创建的对象，都是共享一个静态变量。</li>\n<li><mark>泛型的类型参数不能用在Java异常处理的catch语句中。因为异常处理是由JVM在运行时刻来进行的。由于类型信息被擦除，JVM是无法区分两个异常类型<code>MyException&lt;String&gt;</code>和<code>MyException&lt;Integer&gt;</code>的。对于JVM来说，它们都是 MyException类型的。也就无法执行与异常对应的catch语句。</mark></li>\n</ul>\n<p>类型擦除的基本过程也比较简单，首先是找到用来替换类型参数的具体类。这个具体类一般是Object。如果指定了类型参数的上界的话，则使用这个上界。把代码中的类型参数都替换成具体的类。同时去掉出现的类型声明，即去掉<code>&lt;&gt;</code>的内容。比如<code>T get()</code>方法声明就变成了<code>Object get()</code>；<code>List&lt;String&gt;</code>就变成了List。接下来就可能需要生成一些桥接方法<code>（bridge method）</code>。这是由于擦除了类型之后的类可能缺少某些必须的方法。比如考虑下面的代码：</p>\n<div><pre><code><span>class</span> <span>MyString</span> <span>implements</span> <span>Comparable</span><span><span>&lt;</span><span>String</span><span>></span></span> <span>{</span>\n    <span>public</span> <span>int</span> <span>compareTo</span><span>(</span><span>String</span> str<span>)</span> <span>{</span>        \n        <span>return</span> <span>0</span><span>;</span>    \n    <span>}</span>\n<span>}</span> \n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>当类型信息被擦除之后，上述类的声明变成了<code>class MyString implements Comparable</code>。但是这样的话，类MyString就会有编译错误，因为没有实现接口Comparable声明的<code>String compareTo(Object)</code>方法。这个时候就由编译器来动态生成这个方法。</p>\n<h3 id=\"实例分析\"> 实例分析</h3>\n<p>了解了类型擦除机制之后，就会明白编译器承担了全部的类型检查工作。编译器禁止某些泛型的使用方式，正是为了确保类型的安全性。以上面提到的<code>List&lt;Object&gt;</code>和<code>List&lt;String&gt;</code>为例来具体分析：</p>\n<div><pre><code><span>public</span> <span>void</span> <span>inspect</span><span>(</span><span>List</span><span><span>&lt;</span><span>Object</span><span>></span></span> list<span>)</span> <span>{</span>    \n    <span>for</span> <span>(</span><span>Object</span> obj <span>:</span> list<span>)</span> <span>{</span>        \n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>obj<span>)</span><span>;</span>    \n    <span>}</span>    \n    list<span>.</span><span>add</span><span>(</span><span>1</span><span>)</span><span>;</span> <span>//这个操作在当前方法的上下文是合法的。 </span>\n<span>}</span>\n<span>public</span> <span>void</span> <span>test</span><span>(</span><span>)</span> <span>{</span>    \n    <span>List</span><span><span>&lt;</span><span>String</span><span>></span></span> strs <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>String</span><span>></span></span><span>(</span><span>)</span><span>;</span>    \n    <span>inspect</span><span>(</span>strs<span>)</span><span>;</span> <span>//编译错误 </span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>这段代码中，inspect方法接受<code>List&lt;Object&gt;</code>作为参数，当在test方法中试图传入<code>List&lt;String&gt;</code>的时候，会出现编译错误。假设这样的做法是允许的，那么在inspect方法就可以通过list.add(1)来向集合中添加一个数字。这样在test方法看来，其声明为<code>List&lt;String&gt;</code>的集合中却被添加了一个Integer类型的对象。这显然是违反类型安全的原则的，在某个时候肯定会抛出<a href=\"http://download.oracle.com/javase/1.5.0/docs/api/java/lang/ClassCastException.html\" target=\"_blank\" rel=\"noopener noreferrer\">ClassCastException</a>。因此，编译器禁止这样的行为。编译器会尽可能的检查可能存在的类型安全问题。对于确定是违反相关原则的地方，会给出编译错误。当编译器无法判断类型的使用是否正确的时候，会给出警告信息。</p>\n<h3 id=\"通配符与上下界\"> 通配符与上下界</h3>\n<p>在使用泛型类的时候，既可以指定一个具体的类型，如：</p>\n<p><code>List&lt;String&gt;</code>就声明了具体的类型是String；也可以用通配符<code>?</code>来表示未知类型，如<code>List&lt;?&gt;</code>就声明了List中包含的元素类型是未知的。 通配符所代表的其实是一组类型，但具体的类型是未知的。<code>List&lt;?&gt;</code>所声明的就是所有类型都是可以的。但是<code>List&lt;?&gt;</code>并不等同于<code>List&lt;Object&gt;</code>。<code>List&lt;Object&gt;</code>实际上确定了List中包含的是Object及其子类，在使用的时候都可以通过Object来进行引用。而<code>List&lt;?&gt;</code>则其中所包含的元素类型是不确定。其中可能包含的是String，也可能是 Integer。如果它包含了String的话，往里面添加Integer类型的元素就是错误的。正因为类型未知，就不能通过<code>new ArrayList&lt;?&gt;()</code>的方法来创建一个新的ArrayList对象。因为编译器无法知道具体的类型是什么。但是对于<code>List&lt;?&gt;</code>中的元素确总是可以用Object来引用的，因为虽然类型未知，但肯定是Object及其子类。考虑下面的代码：</p>\n<div><pre><code><span>public</span> <span>void</span> <span>wildcard</span><span>(</span><span>List</span><span><span>&lt;</span><span>?</span><span>></span></span> list<span>)</span> <span>{</span>\n    list<span>.</span><span>add</span><span>(</span><span>1</span><span>)</span><span>;</span><span>//编译错误 </span>\n<span>}</span> \n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>如上所示，试图对一个带通配符的泛型类进行操作的时候，总是会出现编译错误。其原因在于通配符所表示的类型是未知的。</p>\n<p>因为对于<code>List&lt;?&gt;</code>中的元素只能用Object来引用，在有些情况下不是很方便。在这些情况下，<mark>可以使用上下界来限制未知类型的范围。</mark> 如<code>List&lt;? extends Number&gt;</code>说明List中可能包含的元素类型是Number及其子类。而<code>List&lt;? super Number&gt;</code>则说明List中包含的是Number及其父类。当引入了上界之后，在使用类型的时候就可以使用上界类中定义的方法。比如访问 <code>List&lt;? extends Number&gt;</code>的时候，就可以使用Number类的intValue等方法。</p>\n<h3 id=\"类型系统\"> 类型系统</h3>\n<p>在Java中，大家比较熟悉的是通过继承机制而产生的类型体系结构。比如String继承自Object。根据<a href=\"http://en.wikipedia.org/wiki/Liskov_substitution_principle\" target=\"_blank\" rel=\"noopener noreferrer\">Liskov替换原则</a>，子类是可以替换父类的。当需要Object类的引用的时候，如果传入一个String对象是没有任何问题的。但是反过来的话，即用父类的引用替换子类引用的时候，就需要进行强制类型转换。编译器并不能保证运行时刻这种转换一定是合法的。这种自动的子类替换父类的类型转换机制，对于数组也是适用的。 String[]可以替换Object[]。但是泛型的引入，对于这个类型系统产生了一定的影响。正如前面提到的<code>List&lt;String&gt;</code>是不能替换掉<code>List&lt;Object&gt;</code>的。</p>\n<p>引入泛型之后的类型系统增加了两个维度：一个是类型参数自身的继承体系结构，另外一个是泛型类或接口自身的继承体系结构。第一个指的是对于<code>List&lt;String&gt;</code>和<code>List&lt;Object&gt;</code>这样的情况，类型参数String是继承自Object的。而第二种指的是 List接口继承自Collection接口。对于这个类型系统，有如下的一些规则：</p>\n<ul>\n<li>相同类型参数的泛型类的关系取决于泛型类自身的继承体系结构。即<code>List&lt;String&gt;</code>是<code>Collection&lt;String&gt;</code> 的子类型，<code>List&lt;String&gt;</code>可以替换<code>Collection&lt;String&gt;</code>。这种情况也适用于带有上下界的类型声明。</li>\n<li>当泛型类的类型声明中使用了通配符的时候， 其子类型可以在两个维度上分别展开。如对<code>Collection&lt;? extends Number&gt;</code>来说，其子类型可以在Collection这个维度上展开，即<code>List&lt;? extends Number&gt;</code>和<code>Set&lt;? extends Number&gt;</code>等；也可以在Number这个层次上展开，即<code>Collection&lt;Double&gt;</code>和<code>Collection&lt;Integer&gt;</code>等。如此循环下去，<code>ArrayList&lt;Long&gt;</code>和<code>HashSet&lt;Double&gt;</code>等也都算是<code>Collection&lt;? extends Number&gt;</code>的子类型。</li>\n<li>如果泛型类中包含多个类型参数，则对于每个类型参数分别应用上面的规则。</li>\n</ul>\n<p>理解了上面的规则之后，就可以很容易的修正实例分析中给出的代码了。只需要把<code>List&lt;Object&gt;</code>改成<code>List&lt;?&gt;</code>即可。<code>List&lt;String&gt;</code>是<code>List&lt;?&gt;</code>的子类型，因此传递参数时不会发生错误。</p>\n<h3 id=\"泛型传递\"> 泛型传递</h3>\n<p>即泛型可以当作参数在不同的实例化的类中传递，理论上来说可以无限制层次的传递下去。最终会约束每一层的方法或者类型的泛型确定，在《<a href=\"http://www.raychase.net/2446\" target=\"_blank\" rel=\"noopener noreferrer\">泛型传递</a>》这篇文章中对具体的用法进行详尽的描述。</p>\n<h3 id=\"最佳实践\"> 最佳实践</h3>\n<p>在使用泛型的时候可以遵循一些基本的原则，从而避免一些常见的问题。</p>\n<ul>\n<li>在代码中避免泛型类和原始类型的混用。比如<code>List&lt;String&gt;</code>和List不应该共同使用。这样会产生一些编译器警告和潜在的运行时异常。当需要利用JDK 5之前开发的遗留代码，而不得不这么做时，也尽可能的隔离相关的代码。</li>\n<li>在使用带通配符的泛型类的时候，需要明确通配符所代表的一组类型的概念。由于具体的类型是未知的，很多操作是不允许的。</li>\n<li>泛型类最好不要同数组一块使用。你只能创建<code>new List&lt;?&gt;[10]</code>这样的数组，无法创建<code>new List&lt;String&gt;[10]</code>这样的。这限制了数组的使用能力，而且会带来很多费解的问题。因此，当需要类似数组的功能时候，使用集合类即可。</li>\n<li>不要忽视编译器给出的警告信息。</li>\n</ul>\n<h2 id=\"集合中使用泛型\"> 集合中使用泛型</h2>\n<p>集合相关类都定义了泛型，我们在开发和工作中，在使用集合类时都要使用泛型。这样，在集合的存储数据、读取数据时都避免了大量的类型判断，非常便捷。</p>\n<p>泛型类的在集合中的使用</p>\n<div><pre><code><span>public</span> <span>class</span> <span>Test</span> <span>{</span>\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n        <span>// 以下代码中List、Set、Map、Iterator都是与容器相关的接口;</span>\n        <span>List</span><span><span>&lt;</span><span>String</span><span>></span></span> list <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>String</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n        <span>Set</span><span><span>&lt;</span><span>Man</span><span>></span></span> mans <span>=</span> <span>new</span> <span>HashSet</span><span><span>&lt;</span><span>Man</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n        <span>Map</span><span><span>&lt;</span><span>Integer</span><span>,</span> <span>Man</span><span>></span></span> maps <span>=</span> <span>new</span> <span>HashMap</span><span><span>&lt;</span><span>Integer</span><span>,</span> <span>Man</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n        <span>Iterator</span><span><span>&lt;</span><span>Man</span><span>></span></span> iterator <span>=</span> mans<span>.</span><span>iterator</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>阅读源码，发现Collection、List、Set、Map、Iterator接口都定义了泛型</p>\n<div><pre><code><span>public</span> <span>interface</span> <span>Collection</span><span><span>&lt;</span><span>E</span><span>></span></span> <span>extends</span> <span>Iterable</span><span><span>&lt;</span><span>E</span><span>></span></span>\n<span>public</span> <span>interface</span> <span>List</span><span><span>&lt;</span><span>E</span><span>></span></span> <span>extends</span> <span>Collection</span><span><span>&lt;</span><span>E</span><span>></span></span> \n<span>public</span> <span>interface</span> <span>Set</span><span><span>&lt;</span><span>E</span><span>></span></span> <span>extends</span> <span>Collection</span><span><span>&lt;</span><span>E</span><span>></span></span> \n<span>public</span> <span>interface</span> <span>Map</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> \n<span>public</span> <span>interface</span> <span>Iterator</span><span><span>&lt;</span><span>E</span><span>></span></span>    \n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><div><p>注意</p>\n<p>因此，我们在使用这些接口及其实现类时，都要使用泛型。</p>\n</div>\n<h2 id=\"自定义泛型\"> 自定义泛型</h2>\n<p>泛型类与一般的Java类基本相同，只是在类和接口定义上多出来了用&lt;&gt;声明的类型参数。</p>\n<p>一个类可以有多个类型参数，我们可以在类的声明处增加泛型列表，如：&lt;T,E,V&gt;。此处，字符可以是任何标识符，一般采用这3个字母。 每个类型参数在声明的时候可以指定上界。所声明的类型参数在Java类中可以像一般的类型一样作为方法的参数和返回值，或是作为域和局部变量的类型。</p>\n<h3 id=\"泛型类的声明\"> 泛型类的声明</h3>\n<div><pre><code><span>class</span> <span>MyCollection</span><span><span>&lt;</span><span>E</span><span>></span></span> <span>{</span><span>// E:表示泛型;</span>\n    <span>Object</span><span>[</span><span>]</span> objs <span>=</span> <span>new</span> <span>Object</span><span>[</span><span>5</span><span>]</span><span>;</span>\n \n    <span>public</span> <span>E</span> <span>get</span><span>(</span><span>int</span> index<span>)</span> <span>{</span><span>// E:表示泛型;</span>\n        <span>return</span> <span>(</span><span>E</span><span>)</span> objs<span>[</span>index<span>]</span><span>;</span>\n    <span>}</span>\n    <span>public</span> <span>void</span> <span>set</span><span>(</span><span>E</span> e<span>,</span> <span>int</span> index<span>)</span> <span>{</span><span>// E:表示泛型;</span>\n        objs<span>[</span>index<span>]</span> <span>=</span> e<span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>泛型E像一个占位符一样表示“未知的某个数据类型”，我们在真正调用的时候传入这个“数据类型”</p>\n<p>但是由于类型擦除机制，<mark>类型参数并不能用来创建对象或是作为静态变量的类型</mark>。考虑下面的泛型类中的正确和错误的用法。</p>\n<div><pre><code><span>class</span> <span>ClassTest</span><span><span>&lt;</span><span>X</span> <span>extends</span> <span>Number</span><span>,</span> <span>Y</span><span>,</span> <span>Z</span><span>></span></span> <span>{</span>    \n    <span>private</span> <span>X</span> x<span>;</span>    \n    <span>private</span> <span>static</span> <span>Y</span> y<span>;</span> <span>//编译错误，不能用在静态变量中    </span>\n    <span>public</span> <span>X</span> <span>getFirst</span><span>(</span><span>)</span> <span>{</span>\n        <span>//正确用法        </span>\n        <span>return</span> x<span>;</span>    \n    <span>}</span>    \n    <span>public</span> <span>void</span> <span>wrong</span><span>(</span><span>)</span> <span>{</span>        \n        <span>Z</span> z <span>=</span> <span>new</span> <span>Z</span><span>(</span><span>)</span><span>;</span> <span>//编译错误，不能创建对象    </span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h3 id=\"泛型类的应用\"> 泛型类的应用</h3>\n<div><pre><code><span>public</span> <span>class</span> <span>TestGenerics</span> <span>{</span>\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n        <span>// 这里的”String”就是实际传入的数据类型；</span>\n        <span>MyCollection</span><span><span>&lt;</span><span>String</span><span>></span></span> mc <span>=</span> <span>new</span> <span>MyCollection</span><span><span>&lt;</span><span>String</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n        mc<span>.</span><span>set</span><span>(</span><span>\"aaa\"</span><span>,</span> <span>0</span><span>)</span><span>;</span>\n        mc<span>.</span><span>set</span><span>(</span><span>\"bbb\"</span><span>,</span> <span>1</span><span>)</span><span>;</span>\n        <span>String</span> str <span>=</span> mc<span>.</span><span>get</span><span>(</span><span>1</span><span>)</span><span>;</span> <span>//加了泛型，直接返回String类型，不用强制转换;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>str<span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div>",
      "date_modified": "2021-02-08T17:34:42.000Z",
      "authors": [
        {
          "name": "南辞"
        }
      ],
      "tags": [
        "Java"
      ]
    },
    {
      "title": "Java",
      "url": "http://qiqi.dreamagain.top/program/backend/java/",
      "id": "http://qiqi.dreamagain.top/program/backend/java/",
      "summary": "<blockquote>\n<p><img src=\"https://img.shields.io/badge/Java%E7%AE%80%E4%BB%8B-blue.svg\" alt=\"\"> <img src=\"https://img.shields.io/badge/%E5%AD%A6%E4%B9%A0%E6%95%99%E7%A8%8B-blue.svg\" alt=\"\"> <img src=\"https://img.shields.io/badge/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-blue.svg\" alt=\"\"></p>\n</blockquote>\n",
      "content_html": "<blockquote>\n<p><img src=\"https://img.shields.io/badge/Java%E7%AE%80%E4%BB%8B-blue.svg\" alt=\"\"> <img src=\"https://img.shields.io/badge/%E5%AD%A6%E4%B9%A0%E6%95%99%E7%A8%8B-blue.svg\" alt=\"\"> <img src=\"https://img.shields.io/badge/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-blue.svg\" alt=\"\">\n</p>\n</blockquote>\n<h2 id=\"java简介\"> Java简介</h2>\n<h3 id=\"java语言的诞生\"> Java语言的诞生</h3>\n<p>Java 是由 Sun Microsystems 公司于 1995 年 5 月推出的 Java 面向对象程序设计语言和 Java 平台的总称。由 James Gosling（Javaz之父）和同事们共同研发，并在 1995 年正式推出。</p>\n<p>后来 Sun 公司被 Oracle （甲骨文）公司收购，Java 也随之成为 Oracle 公司的产品。</p>\n<h3 id=\"java的三个体系\"> Java的三个体系</h3>\n<ul>\n<li>\n<p>JavaSE（J2SE）（Java2 Platform Standard Edition，java平台标准版）</p>\n</li>\n<li>\n<p>JavaEE(J2EE)(Java 2 Platform,Enterprise Edition，java平台企业版)</p>\n</li>\n<li>\n<p>JavaME(J2ME)(Java 2 Platform Micro Edition，java平台微型版)。</p>\n<img src=\"./assets/java-00.png\" style=\"zoom:120%;\" align=\"left\"/>\n</li>\n</ul>\n<p>2005 年 6 月，JavaOne 大会召开，SUN 公司公开 Java SE 6。此时，Java 的各种版本已经更名，以取消其中的数字 &quot;2&quot;：</p>\n<ul>\n<li>J2EE 更名为 Java EE</li>\n<li>J2SE 更名为Java SE，</li>\n<li>J2ME 更名为 Java ME。</li>\n</ul>\n<br/>\n<ol>\n<li>Java SE就是标准版，包含标准的JVM和标准库</li>\n<li>Java EE是企业版，它只是在Java SE的基础上加上了大量的API和库，以便方便开发Web应用、数据库、消息服务等，Java EE的应用使用的虚拟机和Java SE完全相同。</li>\n<li>Java ME就和Java SE不同，它是一个针对嵌入式设备的“瘦身版”，Java SE的标准库无法在Java ME上使用，Java ME的虚拟机也是“瘦身版”。业界以Android开发成为了移动平台的标准之一，Java ME的使用相当少，不建议学习</li>\n</ol>\n<div><p>学习指南</p>\n<ol>\n<li>首先要学习Java SE，掌握Java语言本身、Java核心开发技术以及Java标准库的使用；</li>\n<li>如果继续学习Java EE，那么Spring框架、数据库开发、分布式架构就是需要学习的；</li>\n<li>如果要学习大数据开发，那么Hadoop、Spark、Flink这些大数据平台就是需要学习的，他们都基于Java或Scala开发；</li>\n<li>如果想要学习移动开发，那么就深入Android平台，掌握Android App开发。</li>\n</ol>\n<p>Java SE是整个Java平台的核心，要成为真正的Java程序猿需要学习更多Java底层原理，精通Java SE</p>\n</div>\n",
      "image": "https://img.shields.io/badge/Java简介-blue.svg",
      "date_modified": "2021-02-08T17:34:42.000Z",
      "authors": [
        {
          "name": "南辞"
        }
      ],
      "tags": [
        "Java"
      ]
    },
    {
      "title": "Java基础",
      "url": "http://qiqi.dreamagain.top/program/backend/java/solution/Java%E5%9F%BA%E7%A1%80/",
      "id": "http://qiqi.dreamagain.top/program/backend/java/solution/Java%E5%9F%BA%E7%A1%80/",
      "content_html": "<h2 id=\"问题\"> 问题：</h2>\n<h3 id=\"一、java概述\"> 一、Java概述</h3>\n<p>1、何为编程</p>\n<p>2、什么是Java</p>\n<p>3、jdk1.5之后的三大版本</p>\n<p>4、JVM、JRE和JDK的关系</p>\n<p>5、什么是跨平台性？原理是什么</p>\n<p>6、Java语言有哪些特点？</p>\n<p>7、什么是字节码？采用字节码的最大好处是什么</p>\n<p>8、什么是Java程序的主类？应用程序和小程序的主类有何不同？</p>\n<p>9、Java应用程序与小程序之间有那些差别？</p>\n<p>10、Java和C++的区别</p>\n<p>11、Oracle JDK 和 OpenJDK 的对比</p>\n<h3 id=\"二、基础语法\"> 二、基础语法</h3>\n<h4 id=\"一-数据类型\"> （一）数据类型</h4>\n<p>1、Java有哪些数据类型</p>\n<p>2、switch 是否能作用在 byte 上，是否能作用在 long 上，是否能作用在 String 上</p>\n<p>3、用最有效率的方法计算 2 乘以 8</p>\n<p>4、Math.round(11.5) 等于多少？Math.round(-11.5)等于多少</p>\n<p>5、float f=3.4;是否正确</p>\n<p>6、short s1 = 1; s1 = s1 + 1;有错吗?short s1 = 1; s1 += 1;有错吗</p>\n<h4 id=\"二-编码\"> （二）编码</h4>\n<p>1、Java语言采用何种编码方案？有何特点？</p>\n<h4 id=\"三-注释\"> （三）注释</h4>\n<p>1、什么Java注释</p>\n<h4 id=\"四-访问修饰符\"> （四）访问修饰符</h4>\n<p>1、访问修饰符 public,private,protected,以及不写（默认）时的区别</p>\n<h4 id=\"五-运算符\"> （五）运算符</h4>\n<p>1、&amp;和&amp;&amp;的区别</p>\n<h4 id=\"六-关键字\"> （六）关键字</h4>\n<p>1、Java 有没有 goto</p>\n<p>2、final 有什么用？</p>\n<p>3、final finally finalize区别</p>\n<p>4、this关键字的用法</p>\n<p>5、super关键字的用法</p>\n<p>6、this与super的区别</p>\n<p>7、static存在的主要意义</p>\n<p>8、static的独特之处</p>\n<p>9、static应用场景</p>\n<p>10、static注意事项</p>\n<h4 id=\"七-流程控制\"> （七）流程控制</h4>\n<p>1、break ,continue ,return 的区别及作用</p>\n<p>2、在 Java 中，如何跳出当前的多重嵌套循环</p>\n<h3 id=\"三、面向对象\"> 三、面向对象</h3>\n<h4 id=\"一-面向对象概述\"> （一）面向对象概述</h4>\n<p>1、面向对象和面向过程的区别</p>\n<h4 id=\"二-面向对象三大特性\"> （二）面向对象三大特性</h4>\n<p>2、面向对象的特征有哪些方面</p>\n<p>3、什么是多态机制？Java语言是如何实现多态的？</p>\n<p>4、面向对象七大基本原则是什么？</p>\n<h4 id=\"三-类与接口\"> （三）类与接口</h4>\n<p>1、抽象类和接口的对比</p>\n<p>2、普通类和抽象类有哪些区别？</p>\n<p>3、抽象类能使用 final 修饰吗？</p>\n<p>4、创建一个对象用什么关键字？对象实例与对象引用有何不同？</p>\n<h4 id=\"四-变量与方法\"> （四）变量与方法</h4>\n<p>1、成员变量与局部变量的区别有哪些？</p>\n<p>2、在Java中定义一个不做事且没有参数的构造方法的作用</p>\n<p>3、在调用子类构造方法之前会先调用父类没有参数的构造方法，其目的是？</p>\n<p>4、一个类的构造方法的作用是什么？若一个类没有声明构造方法，该程序能正确执行吗？为什么？</p>\n<p>5、构造方法有哪些特点？</p>\n<p>6、静态变量和实例变量区别</p>\n<p>7、静态变量与普通变量区别</p>\n<p>8、静态方法和实例方法有何不同？</p>\n<p>9、在一个静态方法内调用一个非静态成员为什么是非法的？</p>\n<p>10、什么是方法的返回值？返回值的作用是什么？</p>\n<h4 id=\"五-内部类\"> （五）内部类</h4>\n<p>1、什么是内部类？</p>\n<p>2、内部类的分类有哪些？</p>\n<p>3、内部类的优点</p>\n<p>4、内部类有哪些应用场景</p>\n<p>5、局部内部类和匿名内部类访问局部变量的时候，为什么变量必须要加上final？</p>\n<p>6、内部类相关，看程序说出运行结果</p>\n<h4 id=\"六-重写与重载\"> （六）重写与重载</h4>\n<p>1、构造器（constructor）是否可被重写（override）</p>\n<p>2、重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？</p>\n<h4 id=\"七-对象相等判断\"> （七）对象相等判断</h4>\n<p>1、== 和 equals 的区别是什么</p>\n<p>2、hashCode与 equals 方法 (<mark>重要</mark>)</p>\n<p>4、对象的相等与指向他们的引用相等，两者有什么不同？</p>\n<h4 id=\"八-值传递\"> （八）值传递</h4>\n<p>1、当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递</p>\n<p>2、Java 中对象作为形参为什么还是值传递</p>\n<p>3、值传递和引用传递有什么区别</p>\n<h4 id=\"九-java包\"> （九）Java包</h4>\n<p>1、JDK 中常用的包有哪些</p>\n<p>2、import java和javax有什么区别</p>\n<h3 id=\"四、常用api\"> 四、常用API</h3>\n<h4 id=\"一-string相关\"> （一）String相关</h4>\n<p>1、字符型常量和字符串常量的区别</p>\n<p>2、什么是字符串常量池？</p>\n<p>3、String 是最基本的数据类型吗</p>\n<p>4、String有哪些特性</p>\n<p>5、String为什么是不可变的吗？</p>\n<p>6、String真的是不可变的吗？</p>\n<p>7、是否可以继承 String 类</p>\n<p>8、String str=&quot;i&quot;与 String str=new String(&quot;i&quot;)一样吗？</p>\n<p>9、String s = new String(&quot;xyz&quot;);创建了几个字符串对象</p>\n<p>10、如何将字符串反转？</p>\n<p>11、数组有没有 length()方法？String 有没有 length()方法</p>\n<p>12、String 类的常用方法都有那些？</p>\n<p>13、在使用 HashMap 的时候，用 String 做 key 有什么好处？</p>\n<p>14、String和StringBuffer、StringBuilder的区别是什么？String为什么是不可变的</p>\n<h4 id=\"二-date相关\"> （二）Date相关</h4>\n<h4 id=\"三-包装类相关\"> （三）包装类相关</h4>\n<p>1、自动装箱与拆箱</p>\n<p>2、int 和 Integer 有什么区别</p>\n<p>3、Integer a= 127 与 Integer b = 127相等吗</p>\n<h2 id=\"参考答案\"> 参考答案：</h2>\n<h3 id=\"一、java概述-2\"> 一、Java概述</h3>\n<blockquote>\n<p>1、何为编程</p>\n</blockquote>\n<p>编程就是让计算机为解决某个问题而使用某种程序设计语言编写程序代码，并最终得到结果的过程。为了使计算机能够理解人的意图，</p>\n<p>人类就必须要将需解决的问题的思路、方法、和手段通过计算机能够理解的形式告诉计算机，使得计算机能够根据人的指令一步一步去</p>\n<p>工作，完成某种特定的任务。这种人和计算机之间交流的过程就是编程。</p>\n<blockquote>\n<p>2、什么是Java</p>\n</blockquote>\n<p>Java是一门面向对象编程语言，不仅吸收了C++语言的各种优点，还摒弃了C++里难以理解的多继承、指针等概念，因此Java语言具有功</p>\n<p>能强大和简单易用两个特征。Java语言作为静态面向对象编程语言的代表，极好地实现了面向对象理论，允许程序员以优雅的思维方式</p>\n<p>进行复杂的编程 。</p>\n<blockquote>\n<p>3、jdk1.5之后的三大版本</p>\n</blockquote>\n<ol>\n<li><strong>Java SE</strong>（J2SE，Java 2 Platform Standard Edition，标准版）\nJava SE 以前称为 J2SE。它允许开发和部署在桌面、服务器、嵌入式环境和实时环境中使用的 Java 应用程序。Java SE 包含了支持 Java Web 服务开发的类，并为Java EE和Java ME提供基础。</li>\n<li><strong>Java EE</strong>（J2EE，Java 2 Platform Enterprise Edition，企业版）\nJava EE 以前称为 J2EE。企业版本帮助开发和部署可移植、健壮、可伸缩且安全的服务器端Java 应用程序。Java EE 是在 Java SE 的基础上构建的，它提供 Web 服务、组件模型、管理和通信 API，可以用来实现企业级的面向服务体系结构（service-oriented architecture，SOA）和 Web2.0应用程序。2018年2月，Eclipse 宣布正式将 JavaEE 更名为 JakartaEE</li>\n<li><strong>Java ME</strong>（J2ME，Java 2 Platform Micro Edition，微型版）\nJava ME 以前称为 J2ME。Java ME 为在移动设备和嵌入式设备（比如手机、PDA、电视机顶盒和打印机）上运行的应用程序提供一个健壮且灵活的环境。Java ME 包括灵活的用户界面、健壮的安全模型、许多内置的网络协议以及对可以动态下载的连网和离线应用程序的丰富支持。基于 Java ME 规范的应用程序只需编写一次，就可以用于许多设备，而且可以利用每个设备的本机功能。</li>\n</ol>\n<blockquote>\n<p>4、JVM、JRE和JDK的关系</p>\n</blockquote>\n<p><strong>JVM:</strong></p>\n<ul>\n<li>Java Virtual Machine是Java虚拟机，Java程序需要运行在虚拟机上</li>\n<li>不同的平台有自己的虚拟机，因此Java语言可以实现跨平台。</li>\n</ul>\n<p><strong>JRE:</strong></p>\n<ul>\n<li>Java Runtime Environment包括Java虚拟机和Java程序所需的核心类库等。</li>\n<li>核心类库主要是java.lang包：包含了运行Java程序必不可少的系统类，如基本数据类型、基本数学函数、字符串处理、线程、异常处理类等，系统缺省加载这个包</li>\n<li>如果想要运行一个开发好的Java程序，计算机中只需要安装JRE即可。</li>\n</ul>\n<p><strong>JDK：</strong></p>\n<ul>\n<li>Java Development Kit是提供给Java开发人员使用的</li>\n<li>JDK包含了Java的开发工具，也包括了JRE。所以安装了JDK，就无需再单独安装JRE了。</li>\n<li>JDK的开发工具：编译工具(javac.exe)，打包工具(jar.exe)等</li>\n</ul>\n<p>JVM&amp;JRE&amp;JDK关系图</p>\n<img src=\"./assets/01.jpg\" style=\"zoom:80%;\" />\n<blockquote>\n<p>5、什么是跨平台性？原理是什么</p>\n</blockquote>\n<p>所谓跨平台性，是指java语言编写的程序，一次编译后，可以在多个系统平台上运行。</p>\n<p>实现原理：Java程序是通过java虚拟机在系统平台上运行的，只要该系统可以安装相应的java虚拟机，该系统就可以运行java程序。</p>\n<blockquote>\n<p>6、Java语言有哪些特点</p>\n</blockquote>\n<p>简单易学（Java语言的语法与C语言和C++语言很接近）</p>\n<p>面向对象（封装，继承，多态）</p>\n<p>平台无关性（Java虚拟机实现平台无关性）</p>\n<p>支持网络编程并且很方便（Java语言诞生本身就是为简化网络编程设计的）</p>\n<p>支持多线程（多线程机制使应用程序在同一时间并行执行多项任）</p>\n<p>健壮性（Java语言的强类型机制、异常处理、垃圾的自动收集等）</p>\n<p>安全性</p>\n<blockquote>\n<p>7、什么是字节码？采用字节码的最大好处是什么</p>\n</blockquote>\n<p><strong>字节码</strong>：</p>\n<p>Java源代码经过虚拟机编译器编译后产生的文件（即扩展为 <mark>.class的文件</mark> ），它不面向任何特定的处理器，只面向虚拟机。</p>\n<p><strong>采用字节码的好处：</strong></p>\n<p>Java语言通过字节码的方式，在一定程度上 <mark>解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。</mark> 所以Java程序运行时比较高效，而且，由于字节码并不专对一种特定的机器，因此，Java程序无须重新编译便可在多种不同的计算机上运行。</p>\n<p>先看下java中的编译器和解释器：</p>\n<div><pre><code><span>Java</span>源代码<span>--</span><span>--</span><span>></span>编译器<span>--</span><span>--</span><span>></span>jvm可执行的<span>Java</span>字节码<span>(</span>即虚拟指令<span>)</span><span>--</span><span>--</span><span>></span>jvm<span>--</span><span>--</span><span>></span>jvm中解释器<span>--</span><span>--</span><span>-></span>机器可执行的二进制机器码<span>--</span><span>--</span><span>></span>程序运行。\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><ol>\n<li>\n<p>Java中引入了虚拟机的概念，即在机器和编译程序之间加入了一层抽象的虚拟机器。</p>\n</li>\n<li>\n<p>这台虚拟的机器在任何平台上都提供给编译程序一个共同的接口。</p>\n</li>\n<li>\n<p>编译程序只需要面向虚拟机，生成虚拟机能够理解的代码，然后由解释器来将虚拟机代码转换为特定系统的机器码执行。</p>\n</li>\n<li>\n<p>在Java中，这种供虚拟机理解的代码叫做字节码（即扩展为.class的文件），它不面向任何特定的处理器，只面向虚拟机。</p>\n</li>\n<li>\n<p>每一种平台的解释器是不同的，但是实现的虚拟机是相同的。</p>\n</li>\n<li>\n<p>Java源程序经过编译器编译后变成字节码，字节码由虚拟机解释执行，虚拟机将每一条要执行的字节码送给解释器，解释器将其翻译成特定机器上的机器码，然后在特定的机器上运行，这就是上面提到的<strong>Java的特点的编译与解释并存</strong>的解释。</p>\n</li>\n</ol>\n<blockquote>\n<p>8、什么是Java程序的主类？应用程序和小程序的主类有何不同？</p>\n</blockquote>\n<ol>\n<li>\n<p>一个程序中可以有多个类，但只能有一个类是主类。</p>\n</li>\n<li>\n<p>在Java应用程序中，这个主类是指包含main()方法的类。</p>\n</li>\n<li>\n<p>而在Java小程序中，这个主类是一个继承自系统类JApplet或Applet的子类。</p>\n</li>\n<li>\n<p>应用程序的主类不一定要求是public类，但小程序的主类要求必须是public类。主类是Java程序执行的入口点。</p>\n</li>\n</ol>\n<blockquote>\n<p>9、Java应用程序与小程序之间有那些差别？</p>\n</blockquote>\n<ol>\n<li>\n<p>简单说应用程序是从主线程启动(也就是main()方法)。</p>\n</li>\n<li>\n<p>applet小程序没有main方法，主要是嵌在浏览器页面上运行(调用init()线程或者run()来启动)，嵌入浏览器这点跟flash的小游戏类似</p>\n</li>\n</ol>\n<blockquote>\n<p>10、Java和C++的区别</p>\n</blockquote>\n<ul>\n<li>都是面向对象的语言，都支持封装、继承和多态</li>\n<li>Java不提供指针来直接访问内存，程序内存更加安全</li>\n<li>Java的类是单继承的，C++支持多重继承；虽然Java的类不可以多继承，但是接口可以多继承。</li>\n<li>Java有自动内存管理机制，不需要程序员手动释放无用内存</li>\n</ul>\n<blockquote>\n<p>11、Oracle JDK 和 OpenJDK 的对比</p>\n</blockquote>\n<ol>\n<li>\n<p>Oracle JDK版本将每三年发布一次，而OpenJDK版本每三个月发布一次；</p>\n</li>\n<li>\n<p>OpenJDK 是一个参考模型并且是完全开源的，而Oracle JDK是OpenJDK的一个实现，并不是完全开源的；</p>\n</li>\n<li>\n<p>Oracle JDK 比 OpenJDK 更稳定。OpenJDK和Oracle JDK的代码几乎相同，但Oracle JDK有更多的类和一些错误修复。因此，如果您想开发企业/商业软件，我建议您选择Oracle JDK，因为它经过了彻底的测试和稳定。某些情况下，有些人提到在使用OpenJDK 可能会遇到了许多应用程序崩溃的问题，但是，只需切换到Oracle JDK就可以解决问题；</p>\n</li>\n<li>\n<p>在响应性和JVM性能方面，Oracle JDK与OpenJDK相比提供了更好的性能；</p>\n</li>\n<li>\n<p>Oracle JDK不会为即将发布的版本提供长期支持，用户每次都必须通过更新到最新版本获得支持来获取最新版本；</p>\n</li>\n<li>\n<p>Oracle JDK根据<strong>二进制代码许可协议</strong>获得许可，而OpenJDK根据<strong>GPL v2许可</strong>获得许可。</p>\n</li>\n</ol>\n<h3 id=\"二、基础语法-2\"> 二、基础语法</h3>\n<h4 id=\"一-数据类型-2\"> （一）数据类型</h4>\n<p>定义：Java语言是强类型语言，对于每一种数据都定义了明确的具体的数据类型，在内存中分配了不同大小的内存空间。</p>\n<p><strong>分类：</strong></p>\n<p><strong>（1）基本数据类型：</strong></p>\n<ol>\n<li>数值型\n<ul>\n<li>整数类型(byte,short,int,long)</li>\n<li>浮点类型(float,double)</li>\n</ul>\n</li>\n<li>字符型(char)</li>\n<li>布尔型(boolean)</li>\n</ol>\n<p><strong>（2）引用数据类型：</strong></p>\n<ol>\n<li>类(class)</li>\n<li>接口(interface)</li>\n<li>数组([])</li>\n</ol>\n<blockquote>\n<p>1、Java有哪些数据类型</p>\n</blockquote>\n<p><img src=\"./assets/02.jpg\" alt=\"\"></p>\n<blockquote>\n<p>2、switch 是否能作用在 byte 上，是否能作用在 long 上，是否能作用在 String 上</p>\n</blockquote>\n<ol>\n<li>在 Java 5 以前，switch(expr)中，expr 只能是 byte、short、char、int。</li>\n<li>从 Java5 开始，Java 中引入了枚举类型，expr 也可以是 enum 类型，</li>\n<li>从 Java 7 开始，expr 还可以是字符串（String），但是长整型（long）在目前所有的版本中都是不可以的。</li>\n<li></li>\n</ol>\n<blockquote>\n<p>3、用最有效率的方法计算 2 乘以 8</p>\n</blockquote>\n<p><code>2 &lt;&lt; 3</code>（左移 3 位相当于乘以 2 的 3 次方，右移 3 位相当于除以 2 的 3 次方）。</p>\n<blockquote>\n<p>4、Math.round(11.5) 等于多少？Math.round(-11.5)等于多少</p>\n</blockquote>\n<p>Math.round(11.5)的返回值是 12，Math.round(-11.5)的返回值是-11。</p>\n<p>四舍五入的原理是在参数上加 0.5 然后进行下取整。</p>\n<blockquote>\n<p>5、float f=3.4;是否正确</p>\n</blockquote>\n<p>不正确。</p>\n<p>3.4 是双精度数，将双精度型（double）赋值给浮点型（float）属于下转型（down-casting，也称为窄化）会造成精度损失。</p>\n<p>因此需要强制类型转换float f =(float)3.4; 或者写成 float f =3.4F;。</p>\n<blockquote>\n<p>6、short s1 = 1; s1 = s1 + 1;有错吗?short s1 = 1; s1 += 1;有错吗</p>\n</blockquote>\n<p>对于 short s1 = 1; s1 = s1 + 1;由于 1 是 int 类型，因此 s1+1 运算结果也是 int型，需要强制转换类型才能赋值给 short 型。</p>\n<p>而 short s1 = 1; s1 += 1;可以正确编译，因为 s1+= 1;相当于 s1 = (short(s1 + 1);其中有隐含的强制类型转换。</p>\n<h4 id=\"二-编码-2\"> （二）编码</h4>\n<blockquote>\n<p>1、Java语言采用何种编码方案？有何特点？</p>\n</blockquote>\n<p>Java语言采用Unicode编码标准</p>\n<p>Unicode（标准码），它为每个字符制订了一个唯一的数值，因此在任何的语言，平台，程序都可以放心的使用。</p>\n<h4 id=\"三-注释-2\"> （三）注释</h4>\n<blockquote>\n<p>1、什么Java注释</p>\n</blockquote>\n<p>定义：用于解释说明程序的文字</p>\n<p>Java的三种注释：</p>\n<ul>\n<li>单行注释: // 注释文字</li>\n<li>多行注释: /* 注释文字 */</li>\n<li>文档注释：/** 注释文字 */</li>\n</ul>\n<p><strong>作用</strong>：在程序中，尤其是复杂的程序中，适当地加入注释可以 <mark>增加程序的可读性，有利于程序的修改、调试和交流</mark></p>\n<p>注释的内容在程序编译的时候会被忽视，不会产生目标代码，注释的部分不会对程序的执行结果产生任何影响。</p>\n<p><strong>注意事项</strong>：多行和文档注释都不能嵌套使用。</p>\n<h4 id=\"四-访问修饰符-2\"> （四）访问修饰符</h4>\n<blockquote>\n<p>1、访问修饰符 public,private,protected,以及不写（默认）时的区别</p>\n</blockquote>\n<p><strong>定义</strong>：Java中，可以使用访问修饰符来保护对类、变量、方法和构造方法的访问。</p>\n<p>​\t\t\t Java 支持 4 种不同的访问权限，为实现封装性提供了条件。</p>\n<p><strong>分类：</strong></p>\n<p>private : 在同一类内可见。使用对象：变量、方法。 注意：不能修饰类（外部类）</p>\n<p>default (即缺省，什么也不写，不使用任何关键字）: 在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法。</p>\n<p>protected : 对同一包内的类和所有子类可见。使用对象：变量、方法。 注意：不能修饰类（外部类）。</p>\n<p>public : 对所有类可见。使用对象：类、接口、变量、方法</p>\n<p>访问修饰符图\n<img src=\"./assets/03.jpg\" alt=\"\"></p>\n<h4 id=\"五-运算符-2\"> （五）运算符</h4>\n<blockquote>\n<p>1、&amp;和&amp;&amp;的区别</p>\n</blockquote>\n<p>&amp;运算符有两种用法：(1)按位与；(2)逻辑与。</p>\n<ul>\n<li>&amp;&amp;是短路与</li>\n<li>&amp;是逻辑与</li>\n</ul>\n<p><strong>相同点</strong>：二者都要求运算符左右两端的布尔值都是true 整个表达式的值才是 true</p>\n<p><strong>不同的</strong>：&amp;&amp;之所以称为短路运算，是因为如果&amp;&amp;左边的表达式的值是 false，右边的表达式会被直接短路掉，不会进行运算。</p>\n<p>注意：逻辑或运算符（|）和短路或运算符（||）的差别也是如此。</p>\n<h4 id=\"六-关键字-2\"> （六）关键字</h4>\n<blockquote>\n<p>1、Java 有没有 goto</p>\n</blockquote>\n<p>goto 是 Java 中的保留字，在目前版本的 Java 中没有使用。</p>\n<blockquote>\n<p>2、final 有什么用？</p>\n</blockquote>\n<p>用于修饰类、属性和方法；</p>\n<ul>\n<li>被final修饰的类不可以被继承,如String类</li>\n<li>被final修饰的方法不可以被重写</li>\n<li>被final修饰的变量不可以被改变，被final修饰不可变的是变量的引用，而不是引用指向的内容，引用指向的内容是可以改变的</li>\n</ul>\n<blockquote>\n<p>3、final finally finalize区别</p>\n</blockquote>\n<ul>\n<li>\n<p>final可以修饰类、变量、方法，修饰类表示该类不能被继承、修饰方法表示该方法不能被重写、修饰变量表\n示该变量是一个常量不能被重新赋值。</p>\n</li>\n<li>\n<p>finally一般作用在try-catch代码块中，在处理异常的时候，通常我们将一定要执行的代码方法finally代码块\n中，表示不管是否出现异常，该代码块都会执行，一般用来存放一些关闭资源的代码。</p>\n</li>\n<li>\n<p>finalize是一个方法，属于Object类的一个方法，而Object类是所有类的父类，该方法一般由垃圾回收器来调\n用，当我们调用System.gc() 方法的时候,只是提醒垃圾回收器作一次垃圾回收的操作，由垃圾回收器调用finalize()，</p>\n<p>回收垃圾，一个对象是否可回收的最后判断。</p>\n</li>\n</ul>\n<blockquote>\n<p>4、this关键字的用法</p>\n</blockquote>\n<p>this是自身的一个对象，代表对象本身，可以理解为：指向对象本身的一个指针。</p>\n<p>this的用法在java中大体可以分为3种：</p>\n<ul>\n<li>\n<p>普通的直接引用，this相当于是指向当前对象本身。</p>\n</li>\n<li>\n<p>形参与成员名字重名，用this来区分：</p>\n</li>\n<li>\n<p>引用本类的构造函数</p>\n</li>\n</ul>\n<div><pre><code><span>public</span> <span>Person</span><span>(</span><span>String</span> name<span>,</span> <span>int</span> age<span>)</span> <span>{</span>\n    <span>this</span><span>.</span>name <span>=</span> name<span>;</span>\n    <span>this</span><span>.</span>age <span>=</span> age<span>;</span>\n<span>}</span>\n\n<span>class</span> <span>Person</span><span>{</span>\n    <span>private</span> <span>String</span> name<span>;</span>\n    <span>private</span> <span>int</span> age<span>;</span>\n    \n    <span>public</span> <span>Person</span><span>(</span><span>)</span> <span>{</span>\n    <span>}</span>\n \n    <span>public</span> <span>Person</span><span>(</span><span>String</span> name<span>)</span> <span>{</span>\n        <span>this</span><span>.</span>name <span>=</span> name<span>;</span>\n    <span>}</span>\n    <span>public</span> <span>Person</span><span>(</span><span>String</span> name<span>,</span> <span>int</span> age<span>)</span> <span>{</span>\n        <span>this</span><span>(</span>name<span>)</span><span>;</span>\n        <span>this</span><span>.</span>age <span>=</span> age<span>;</span>\n    <span>}</span>\n<span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><blockquote>\n<p>5、super关键字的用法</p>\n</blockquote>\n<p>super可以理解为是指向自己超（父）类对象的一个指针，而这个超类指的是离自己最近的一个父类。</p>\n<p>super也有三种用法：</p>\n<ol>\n<li>\n<p>普通的调用</p>\n<p>与this类似，super相当于是指向当前对象的父类的引用，这样就可以用<code>super.xxx</code>来引用父类的成员。</p>\n<p>（注意：super不是一个对象的引用，这里 <mark>只是说作用类似，不能将它赋值给另一个变量</mark> ，它只是指示编译器去调用父类方法的一个特殊关键词，这是super与this的区别所在）</p>\n</li>\n<li>\n<p>子类中的成员变量或方法与父类中的成员变量或方法同名时，用super进行区分</p>\n</li>\n<li>\n<p>引用父类构造函数</p>\n<ul>\n<li>\n<p>super（参数）：调用父类中的某一个构造函数（应该为构造函数中的第一条语句）。</p>\n</li>\n<li>\n<p>this（参数）：调用本类中另一种形式的构造函数（应该为构造函数中的第一条语句）。</p>\n<p><mark>因此在同意构造函数中不能同时有super和this关键字</mark></p>\n</li>\n</ul>\n</li>\n</ol>\n<div><pre><code><span>class</span> <span>Person</span><span>{</span>\n    <span>protected</span> <span>String</span> name<span>;</span>\n \n    <span>public</span> <span>Person</span><span>(</span><span>String</span> name<span>)</span> <span>{</span>\n        <span>this</span><span>.</span>name <span>=</span> name<span>;</span>\n    <span>}</span>\n \n<span>}</span>\n \n<span>class</span> <span>Student</span> <span>extends</span> <span>Person</span><span>{</span>\n    <span>private</span> <span>String</span> name<span>;</span>\n \n    <span>public</span> <span>Student</span><span>(</span><span>String</span> name<span>,</span> <span>String</span> name1<span>)</span> <span>{</span>\n        <span>super</span><span>(</span>name<span>)</span><span>;</span>\n        <span>this</span><span>.</span>name <span>=</span> name1<span>;</span>\n    <span>}</span>\n \n    <span>public</span> <span>void</span> <span>getInfo</span><span>(</span><span>)</span><span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>this</span><span>.</span>name<span>)</span><span>;</span>      <span>//Child</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>super</span><span>.</span>name<span>)</span><span>;</span>     <span>//Father</span>\n    <span>}</span>\n \n<span>}</span>\n\n<span>public</span> <span>class</span> <span>Test</span> <span>{</span>\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n       <span>Student</span> s1 <span>=</span> <span>new</span> <span>Student</span><span>(</span><span>\"Father\"</span><span>,</span><span>\"Child\"</span><span>)</span><span>;</span>\n       s1<span>.</span><span>getInfo</span><span>(</span><span>)</span><span>;</span>\n \n    <span>}</span>\n<span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br></div></div><blockquote>\n<p>6、this与super的区别</p>\n</blockquote>\n<ul>\n<li>\n<p>super:　它引用当前对象的直接父类中的成员（用来 <mark>访问直接父类中被隐藏的父类中成员数据或函数</mark> ），基类与派生类中有相同成员定义时如：super.变量名 super.成员函数据名（实参）</p>\n</li>\n<li>\n<p>this：它代表当前对象名（在程序中易产生二义性之处，应使用this来指明当前对象；如果函数的形参与类中的成员数据同名，这时需用this来指明成员变量名）</p>\n</li>\n<li>\n<p>super()和this()类似,区别是，super()在子类中调用父类的构造方法，this()在本类内调用本类的其它构造方法。</p>\n</li>\n<li>\n<p><strong>super()和this()均需放在构造方法内第一行。</strong></p>\n</li>\n<li>\n<p>尽管可以用this调用一个构造器，但却不能调用两个。</p>\n</li>\n<li>\n<p><mark>this和super不能同时出现在一个构造函数里面</mark> ，因为this必然会调用其它的构造函数，其它的构造函数必然也会有super语句的存在，所以在同一个构造函数里面有相同的语句，就失去了语句的意义，编译器也不会通过。</p>\n</li>\n<li>\n<p>this()和super()都指的是对象，所以，<mark>均不可以在static环境中使用</mark>。包括：static变量,static方法，static语句块。</p>\n</li>\n<li>\n<p>从本质上讲，<mark>this是一个指向本对象的指针</mark>, 然而 <mark>super是一个Java关键字</mark>。</p>\n</li>\n</ul>\n<blockquote>\n<p>7、static存在的主要意义</p>\n</blockquote>\n<ul>\n<li>\n<p>static的主要意义是在于<strong>创建独立于具体对象的域变量或者方法</strong>。以致于即使没有创建对象，也能使用属性和调用方法！</p>\n</li>\n<li>\n<p>static关键字还有一个比较关键的作用就是 用来形成<strong>静态代码块以优化程序性能</strong>。static块可以置于类中的任何地方，类中可以有多个static块。在类初次被加载的时候，会按照static块的顺序来执行每个static块，并且只会执行一次。</p>\n</li>\n<li>\n<p>为什么说static块可以用来优化程序性能，是因为它的特性:<strong>只会在类加载的时候执行一次</strong>。因此，很多时候会将一些只需要进行一次的初始化操作都放在static代码块中进行。</p>\n</li>\n</ul>\n<blockquote>\n<p>8、static的独特之处</p>\n</blockquote>\n<p>1、被static修饰的变量或者方法是独立于该类的任何对象，也就是说，这些变量和方法不属于任何一个实例对象，而是<strong>被类的实例对</strong></p>\n<p><strong>象所共享。</strong></p>\n<p>怎么理解 “被类的实例对象所共享” 这句话呢？就是说，一个类的静态成员，它是属于大伙的【大伙指的是这个类的多个对象实例，我们</p>\n<p>都知道一个类可以创建多个实例！】，所有的类对象共享的，不像成员变量是自个的【自个指的是这个类的单个实例对象】</p>\n<p>2、在该类被第一次加载的时候，就会去加载被static修饰的部分，而且<strong>只在类第一次使用时加载并进行初始化</strong>，注意这是第</p>\n<p>一次用就要初始化，后面根据需要是可以再次赋值的。</p>\n<p>3、static变量值在<strong>类加载的时候分配空间</strong>，以后创建类对象的时候不会重新分配。赋值的话，是<strong>可以任意赋值</strong>的！</p>\n<p>4、<strong>被static修饰的变量或者方法是优先于对象存在</strong>的，也就是说当一个类加载完毕之后，即便没有创建对象，也可以去访问。</p>\n<blockquote>\n<p>9、static应用场景</p>\n</blockquote>\n<p>因为static是被类的实例对象所共享，因此如果某个成员变量是被所有对象所共享的，那么这个成员变量就应该定义为静态变量。</p>\n<p>因此比较常见的static应用场景有：</p>\n<ol>\n<li>修饰成员变量</li>\n<li>修饰成员方法</li>\n<li>静态代码块</li>\n<li>修饰类【只能修饰内部类也就是静态内部类】</li>\n<li>静态导包</li>\n</ol>\n<blockquote>\n<p>10、static注意事项</p>\n</blockquote>\n<p>1、静态只能访问静态。</p>\n<p>2、非静态既可以访问非静态的，也可以访问静态的。</p>\n<h4 id=\"七-流程控制-2\"> （七）流程控制</h4>\n<blockquote>\n<p>1、break ,continue ,return 的区别及作用</p>\n</blockquote>\n<p>break 跳出总上一层循环，不再执行循环(结束当前的循环体)</p>\n<p>continue 跳出本次循环，继续执行下次循环(结束正在执行的循环 进入下一个循环条件)</p>\n<p>return 程序返回，不再执行下面的代码(结束当前的方法 直接返回)</p>\n<blockquote>\n<p>2、在 Java 中，如何跳出当前的多重嵌套循环</p>\n</blockquote>\n<p>在Java中，要想跳出多重循环，可以在外面的循环语句前定义一个标签，然后在里层循环体的代码中使用带有标号的break 语句，即可跳出外层循环。例如：</p>\n<div><pre><code><span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n    ok<span>:</span>\n    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>10</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>\n        <span>for</span> <span>(</span><span>int</span> j <span>=</span> <span>0</span><span>;</span> j <span>&lt;</span> <span>10</span><span>;</span> j<span>++</span><span>)</span> <span>{</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"i=\"</span> <span>+</span> i <span>+</span> <span>\",j=\"</span> <span>+</span> j<span>)</span><span>;</span>\n            <span>if</span> <span>(</span>j <span>==</span> <span>5</span><span>)</span> <span>{</span>\n                <span>break</span> ok<span>;</span>\n            <span>}</span>\n\n        <span>}</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h3 id=\"三、面向对象-2\"> 三、面向对象</h3>\n<h4 id=\"一-面向对象概述-2\"> （一）面向对象概述</h4>\n<blockquote>\n<p>1、面向对象和面向过程的区别</p>\n</blockquote>\n<p><strong>(1)面向过程：</strong></p>\n<p>​\t\t优点：性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源;比如单片机、嵌入式开发、Linux/Unix等一般采用面向过程开发，性能是最重要的因素。</p>\n<p>​\t\t缺点：没有面向对象易维护、易复用、易扩展</p>\n<p><strong>(2)面向对象：</strong></p>\n<p>​\t\t优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统更加灵活、更加易于维护</p>\n<p>​\t\t缺点：性能比面向过程低</p>\n<p>面向过程是具体化的，流程化的，解决一个问题，你需要一步一步的分析，一步一步的实现。</p>\n<p>面向对象是模型化的，你只需抽象出一个类，这是一个封闭的盒子，在这里你拥有数据也拥有解决问题的方法。需要什么功能直接使用就可以了，不必去一步一步的实现，至于这个功能是如何实现的，管我们什么事？我们会用就可以了。</p>\n<p>面向对象的<strong>底层其实还是面向过程</strong>，把面向过程抽象成类，然后封装，方便我们使用的就是面向对象了。</p>\n<h4 id=\"二-面向对象三大特性-2\"> （二）面向对象三大特性</h4>\n<blockquote>\n<p>1、面向对象的特征有哪些方面</p>\n</blockquote>\n<p><strong>抽象：</strong></p>\n<p>​\t\t抽象是将一类对象的共同特征总结出来构造类的过程，包括数据抽象和行为抽象两方面。抽象只关注对象有哪些属性和行为，并不关注这些行为的细节是什么。</p>\n<p><strong>封装:</strong></p>\n<p>​\t\t封装把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法，如果属性不想被外界访问，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。</p>\n<p><strong>继承:</strong></p>\n<p>​\t\t继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承我们能够非常方便地复用以前的代码。</p>\n<p>关于继承记住如下 3 点：</p>\n<ul>\n<li>\n<p>子类拥有父类非 private 的属性和方法。</p>\n</li>\n<li>\n<p>子类可以拥有自己属性和方法，即子类可以对父类进行扩展。</p>\n</li>\n<li>\n<p>子类可以用自己的方式实现父类的方法。</p>\n</li>\n</ul>\n<p><strong>多态:</strong></p>\n<p>​\t\t所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编译时并不确定，而是在程序运行期间才确定，即一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。</p>\n<p>在Java中有两种形式可以实现多态：<strong>继承</strong>（多个子类对同一方法的重写）和 <strong>接口</strong>（实现接口并覆盖接口中同一方法）。</p>\n<p>其中Java 面向对象编程三大特性：<mark>封装 、继承、 多态</mark></p>\n<p><strong>封装</strong>：隐藏对象的属性和实现细节，仅对外提供公共访问方式，将变化隔离，便于使用，提高复用性和安全性。</p>\n<p><strong>继承</strong>：继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但\t\t\t\t\t不能选择性地继承父类。通过使用继承可以提高代码复用性。继承是多态的前提。</p>\n<p><strong>多态性</strong>：父类或接口定义的引用变量可以指向子类或具体实现类的实例对象。提高了程序的拓展性。在Java中有两种形式可以实现多\t\t\t\t\t\t态：继承（多个子类对同一方法的重写）和接口（实现接口并覆盖接口中同一方法）。</p>\n<p><mark>方法重载</mark>(overload)实现的是编译时的多态性（也称为前绑定/<strong>静态绑定</strong>），而 <mark>方法重写</mark> 实现的是运行时的多态性（也\t\t称为后绑定/<strong>动态绑定</strong>）。</p>\n<p>一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。运行时的多态是面向对象最精髓的东西。</p>\n<p>要实现<strong>多态的条件</strong>：</p>\n<ul>\n<li>方法重写（子类继承父类并重写父类中已有的或抽象的方法）；</li>\n<li>对象造型（用父类型引用子类型对象，这样同样的引用调用同样的方法就会根据子类对象的不同而表现出不同的行为）。</li>\n</ul>\n<blockquote>\n<p>2、什么是多态机制？Java语言是如何实现多态的？</p>\n</blockquote>\n<p>所谓多态就是指:程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编译时并不确定，而是在程序运行期间才确定，即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。因为在程序运行时才确定具体的类，这样，不用修改源程序代码，就可以让引用变量绑定到各种不同的类实现上，从而导致该引用调用的具体方法随之改变，即不修改程序代码就可以改变程序运行时所绑定的具体代码，让程序可以选择多个运行状态，这就是多态性。</p>\n<p>多态分为<strong>编译时多态</strong>和<strong>运行时多态</strong>。</p>\n<ul>\n<li>\n<p>其中编译时多态是静态的，主要是指方法的重载，它是根据参数列表的不同来区分不同的函数，通过编译之后会变成两个不同的函数，在运行时谈不上多态。</p>\n</li>\n<li>\n<p>而运行时多态是动态的，它是通过动态绑定来实现的，也就是我们所说的多态性。</p>\n</li>\n</ul>\n<p><strong>多态的实现</strong></p>\n<p>Java实现多态有三个必要条件：<mark>继承、重写、向上转型。</mark></p>\n<p>继承：在多态中必须存在有继承关系的子类和父类。</p>\n<p>重写：子类对父类中某些方法进行重新定义，在调用这些方法时就会调用子类的方法。</p>\n<p>向上转型：在多态中需要 <mark>将子类的对象赋给父类引用</mark>，只有这样该引用才能够具备技能调用父类的方法和子类的方法。</p>\n<p>只有满足了上述三个条件，我们才能够在同一个继承结构中使用统一的逻辑实现代码处理不同的对象，从而达到执行不同的行为。</p>\n<p>对于Java而言，它多态的实现机制遵循一个【<strong>原则</strong>】：<mark>当超类对象引用子类对象时，被引用对象的类型决定了调用谁的成员方法，但是这个被调用的方法必须是在超类中定义过的，也就是说被子类覆盖的方法。</mark></p>\n<blockquote>\n<p>3、面向对象七大基本原则是什么（可选）</p>\n</blockquote>\n<ol>\n<li>\n<p><strong>单一职责原则</strong>SRP(Single Responsibility Principle)\n类的功能要单一，不能包罗万象，跟杂货铺似的。</p>\n</li>\n<li>\n<p><strong>开放封闭原则</strong>OCP(Open－Close Principle)\n一个模块对于拓展是开放的，对于修改是封闭的，想要增加功能热烈欢迎，想要修改，哼，一万个不乐意。</p>\n</li>\n<li>\n<p><strong>里式替换原则</strong>LSP(the Liskov Substitution Principle LSP)\n子类可以替换父类，出现在父类能够出现的任何地方。比如你能代表你爸去你姥姥家干活。</p>\n</li>\n<li>\n<p><strong>依赖倒置原则</strong>DIP(the Dependency Inversion Principle DIP)\n高层次的模块不应该依赖于低层次的模块，他们都应该依赖于抽象。<mark>抽象不应该依赖于具体实现，具体实现应该依赖于抽象</mark>。就是你出国要说你是中国人，而不能说你是哪个村子的。比如说中国人是抽象的，下面有具体的xx省，xx市，xx县。你要依赖的抽象是中国人，而不是你是xx村的。</p>\n</li>\n<li>\n<p><strong>接口分离原则</strong>ISP(the Interface Segregation Principle ISP)\n设计时采用多个与特定客户类有关的接口比采用一个通用的接口要好。就比如一个手机拥有打电话，看视频，玩游戏等功能，把这几个功能拆分成不同的接口，比在一个接口里要好的多。</p>\n</li>\n<li>\n<p><strong>迪米特法则</strong></p>\n<p>只与你的朋友交谈，不与“陌生人”说话，（降低耦合度）</p>\n</li>\n<li>\n<p><strong>合成复用原则</strong></p>\n<p>尽量使用组合和聚合的关系来实现，然后才考虑使用继承，使用继承时要考虑里氏替换</p>\n</li>\n</ol>\n<h4 id=\"三-类与接口-2\"> （三）类与接口</h4>\n<blockquote>\n<p>1、抽象类和接口的对比</p>\n</blockquote>\n<p>抽象类是用来捕捉子类的通用特性的。接口是抽象方法的集合。</p>\n<p>从设计层面来说，<mark>抽象类是对类的抽象</mark>，是一种模板设计，<mark>接口是行为的抽象</mark>，是一种行为的规范。</p>\n<p><strong>相同点</strong></p>\n<ul>\n<li>接口和抽象类都不能实例化</li>\n<li>都位于继承的顶端，用于被其他实现或继承</li>\n<li>都包含抽象方法，其子类都必须覆写这些抽象方法</li>\n</ul>\n<p><strong>不同点</strong></p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>抽象类</th>\n<th>接口</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>声明</td>\n<td>抽象类使用abstract关键字声明</td>\n<td>接口使用interface关键字声明</td>\n</tr>\n<tr>\n<td>实现</td>\n<td>子类使用<strong>extends</strong>关键字来继承抽象类。如果子类不是抽象类的话，它需要提供抽象类中所有声明的方法的实现</td>\n<td>子类使用implements关键字来实现接口。它需要提供接口中所有声明的方法的实现</td>\n</tr>\n<tr>\n<td>构造器</td>\n<td>抽象类可以有构造器</td>\n<td>接口没有构造器</td>\n</tr>\n<tr>\n<td>访问修饰符</td>\n<td>抽象类中的方法可以是任意访问修饰符</td>\n<td>接口方法默认修饰符是public。并且不允许定义为 private 或者 protected</td>\n</tr>\n<tr>\n<td>多继承</td>\n<td>一个类最多只能继承一个抽象类</td>\n<td>一个类可以实现多个接口</td>\n</tr>\n<tr>\n<td>字段声明</td>\n<td>抽象类的字段声明可以是任意的</td>\n<td>接口的字段默认都是 static 和 final 的</td>\n</tr>\n</tbody>\n</table>\n<p><strong>备注</strong>：Java8中的接口引入默认方法和静态方法，以此来减少抽象类和接口之间的差异。</p>\n<p>现在，我们可以为接口提供默认实现的方法了，并且不用强制子类来实现它。</p>\n<p>接口和抽象类各有优缺点，在接口和抽象类的选择上，必须遵守这样一个原则：</p>\n<p><mark>行为模型应该总是通过接口而不是抽象类定义，所以通常是优先选用接口，尽量少用抽象类。</mark></p>\n<p>选择抽象类的时候通常是如下情况：需要定义子类的行为，又要为子类提供通用的功能。</p>\n<blockquote>\n<p>2、普通类和抽象类有哪些区别？</p>\n</blockquote>\n<ul>\n<li>普通类不能包含抽象方法，抽象类可以包含抽象方法。</li>\n<li>抽象类不能直接实例化，普通类可以直接实例化。</li>\n</ul>\n<blockquote>\n<p>3、抽象类能使用 final 修饰吗？</p>\n</blockquote>\n<p>不能</p>\n<p>定义抽象类就是让其他类继承的，如果定义为 final 该类就不能被继承，这样彼此就会产生矛盾，所以 final 不能修饰抽象类</p>\n<blockquote>\n<p>4、创建一个对象用什么关键字？对象实例与对象引用有何不同？</p>\n</blockquote>\n<p>new关键字</p>\n<ol>\n<li>new创建对象实例（<mark>对象</mark> 实例在 <mark>堆内存</mark> 中）</li>\n<li>对象引用指向对象实例（对象 <mark>引用</mark> 存放在 <mark>栈内存</mark> 中）。</li>\n<li>一个对象引用可以指向0个或1个对象（一根绳子可以不系气球，也可以系一个气球）</li>\n<li>一个对象可以有n个引用指向它（可以用n条绳子系住一个气球）</li>\n</ol>\n<h4 id=\"四-变量与方法-2\"> （四）变量与方法</h4>\n<blockquote>\n<p>1、成员变量与局部变量的区别有哪些</p>\n</blockquote>\n<p>变量：在程序执行的过程中，在某个范围内其值可以发生改变的量。从本质上讲，变量其实是内存中的一小块区域</p>\n<p>成员变量：方法外部，类内部定义的变量</p>\n<p>局部变量：类的方法中的变量。</p>\n<p><strong>成员变量和局部变量的区别</strong></p>\n<ul>\n<li>\n<p><strong>作用域</strong></p>\n<p>成员变量：针对整个类有效。\n局部变量：只在某个范围内有效。(一般指的就是方法,语句体内)</p>\n</li>\n<li>\n<p><strong>存储位置</strong></p>\n<p>成员变量：随着对象的创建而存在，随着对象的消失而消失，存储在 <mark>堆内存</mark> 中。\n局部变量：在方法被调用，或者语句被执行的时候存在，存储在 <mark>栈内存</mark> 中。当方法调用完，或者语句结束后，就自动释放。</p>\n</li>\n<li>\n<p><strong>生命周期</strong></p>\n<p>成员变量：随着对象的创建而存在，随着对象的消失而消失\n局部变量：当方法调用完，或者语句结束后，就自动释放。</p>\n</li>\n<li>\n<p><strong>初始值</strong></p>\n<p>成员变量：有默认初始值。</p>\n<p>局部变量：没有默认初始值，使用前必须赋值。</p>\n</li>\n<li>\n<p><strong>使用原则</strong></p>\n<p>在使用变量时需要遵循的原则为：就近原则\n首先在局部范围找，有就使用；接着在成员位置找。</p>\n</li>\n</ul>\n<blockquote>\n<p>2、在Java中定义一个不做事且没有参数的构造方法的作用</p>\n</blockquote>\n<ul>\n<li>Java程序在执行子类的构造方法之前，如果没有用super()来调用父类特定的构造方法，则会调用父类中“没有参数的构造方法”。</li>\n<li>因此，如果父类中只定义了有参数的构造方法，而在子类的构造方法中又没有用super()来调用父类中特定的构造方法，则编译时将发生错误，因为Java程序在父类中找不到没有参数的构造方法可供执行。解决办法是在父类里加上一个不做事且没有参数的构造方法。</li>\n</ul>\n<blockquote>\n<p>3、在调用子类构造方法之前会先调用父类没有参数的构造方法，其目的是？</p>\n</blockquote>\n<p>帮助子类做初始化工作。</p>\n<blockquote>\n<p>4、一个类的构造方法的作用是什么？若一个类没有声明构造方法，该程序能正确执行吗？为什么？</p>\n</blockquote>\n<ul>\n<li>主要作用是完成对类对象的初始化工作。</li>\n<li>可以执行。因为一个类即使没有声明构造方法也会有默认的不带参数的构造方法。</li>\n</ul>\n<blockquote>\n<p>5、构造方法有哪些特点？</p>\n</blockquote>\n<ol>\n<li>\n<p>名字与类名相同；</p>\n</li>\n<li>\n<p>没有返回值，但不能用void声明构造函数；</p>\n</li>\n<li>\n<p>生成类的对象时自动执行，无需调用。</p>\n</li>\n</ol>\n<blockquote>\n<p>6、静态变量和实例变量区别</p>\n</blockquote>\n<ul>\n<li>\n<p>静态变量：</p>\n<p>1、静态变量由于不属于任何实例对象，属于类的，所以在内存中只会有一份</p>\n<p>2、在类的加载过程中，JVM只为静态变量分配一次内存空间。</p>\n</li>\n<li>\n<p>实例变量：</p>\n<p>每次创建对象，都会为每个对象分配成员变量内存空间，实例变量是属于实例对象的，</p>\n<p>在内存中，创建几次对象，就有几份成员变量。</p>\n</li>\n</ul>\n<blockquote>\n<p>7、静态变量与普通变量区别</p>\n</blockquote>\n<p>static变量也称作静态变量</p>\n<p>静态变量和非静态变量的<strong>区别</strong>是：</p>\n<ol>\n<li>静态变量被所有的对象所共享，在内存中只有一个副本，它当且仅当在类初次加载时会被初始化。</li>\n<li>而非静态变量是对象所拥有的，在创建对象的时候被初始化，存在多个副本，各个对象拥有的副本互不影响。</li>\n<li>还有一点就是<strong>static成员变量的初始化顺序按照定义的顺序进行初始化</strong></li>\n</ol>\n<blockquote>\n<p>8、静态方法和实例方法有何不同？</p>\n</blockquote>\n<p>静态方法和实例方法的区别主要体现在两个方面：</p>\n<ul>\n<li>\n<p>在外部调用静态方法时，可以使用&quot;类名.方法名&quot;的方式，也可以使用&quot;对象名.方法名&quot;的方式。而实例方法只有后面这种方式。也就是说，调用静态方法可以无需创建对象。</p>\n</li>\n<li>\n<p>静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），而不允许访问实例成员变量和实例方法；实例方法则无此限制</p>\n</li>\n</ul>\n<blockquote>\n<p>9、在一个静态方法内调用一个非静态成员为什么是非法的？</p>\n</blockquote>\n<p>由于静态方法可以不通过对象进行调用，因此在静态方法里，不能调用其他非静态变量，也不可以访问非静态变量成员。</p>\n<blockquote>\n<p>10、什么是方法的返回值？返回值的作用是什么？</p>\n</blockquote>\n<ul>\n<li>方法的返回值是指我们获取到的某个方法体中的代码执行后产生的结果！（前提是该方法可能产生结果）。</li>\n<li>返回值的作用：接收出结果，使得它可以用于其他的操作！</li>\n</ul>\n<h4 id=\"五-内部类-2\"> （五）内部类</h4>\n<blockquote>\n<p>1、什么是内部类？</p>\n</blockquote>\n<ul>\n<li>在Java中，可以将一个类的定义放在另外一个类的定义内部，这就是<strong>内部类</strong>。</li>\n<li>内部类本身就是类的一个属性，与其他属性定义方式一致。</li>\n</ul>\n<blockquote>\n<p>2、内部类的分类有哪些</p>\n</blockquote>\n<p>内部类可以分为四种：<strong>成员内部类、局部内部类、匿名内部类和静态内部类</strong>。</p>\n<p><strong>（1）静态内部类</strong></p>\n<p>定义在类内部的静态类，就是静态内部类。</p>\n<div><pre><code><span>public</span> <span>class</span> <span>Outer</span> <span>{</span>\n\n    <span>private</span> <span>static</span> <span>int</span> radius <span>=</span> <span>1</span><span>;</span>\n\n    <span>static</span> <span>class</span> <span>StaticInner</span> <span>{</span>\n        <span>public</span> <span>void</span> <span>visit</span><span>(</span><span>)</span> <span>{</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"visit outer static  variable:\"</span> <span>+</span> radius<span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n<span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>静态内部类可以访问外部类所有的静态变量，而不可访问外部类的非静态变量；</p>\n<p>静态内部类的创建方式，<code>new 外部类.静态内部类()</code>，如下：</p>\n<div><pre><code><span>Outer<span>.</span>StaticInner</span> inner <span>=</span> <span>new</span> <span>Outer<span>.</span>StaticInner</span><span>(</span><span>)</span><span>;</span>\ninner<span>.</span><span>visit</span><span>(</span><span>)</span><span>;</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><strong>（2）成员内部类</strong></p>\n<p>定义在类内部，成员位置上的非静态类，就是成员内部类</p>\n<div><pre><code><span>public</span> <span>class</span> <span>Outer</span> <span>{</span>\n\n    <span>private</span> <span>static</span>  <span>int</span> radius <span>=</span> <span>1</span><span>;</span>\n    <span>private</span> <span>int</span> count <span>=</span><span>2</span><span>;</span>\n    \n     <span>class</span> <span>Inner</span> <span>{</span>\n        <span>public</span> <span>void</span> <span>visit</span><span>(</span><span>)</span> <span>{</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"visit outer static  variable:\"</span> <span>+</span> radius<span>)</span><span>;</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"visit outer   variable:\"</span> <span>+</span> count<span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n<span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>成员内部类可以访问外部类所有的变量和方法，包括静态和非静态，私有和公有。成员内部类依赖于外部类的实例，</p>\n<p>它的创建方式<code>外部类实例.new 内部类()</code>，如下：</p>\n<div><pre><code><span>Outer</span> outer <span>=</span> <span>new</span> <span>Outer</span><span>(</span><span>)</span><span>;</span>\n<span>Outer<span>.</span>Inner</span> inner <span>=</span> outer<span>.</span><span>new</span> <span>Inner</span><span>(</span><span>)</span><span>;</span>\ninner<span>.</span><span>visit</span><span>(</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><strong>（3）局部内部类</strong></p>\n<p>定义在方法中的内部类，就是局部内部类。</p>\n<div><pre><code><span>public</span> <span>class</span> <span>Outer</span> <span>{</span>\n\n    <span>private</span>  <span>int</span> out_a <span>=</span> <span>1</span><span>;</span>\n    <span>private</span> <span>static</span> <span>int</span> <span>STATIC_b</span> <span>=</span> <span>2</span><span>;</span>\n\n    <span>public</span> <span>void</span> <span>testFunctionClass</span><span>(</span><span>)</span><span>{</span>\n        <span>int</span> inner_c <span>=</span><span>3</span><span>;</span>\n        <span>class</span> <span>Inner</span> <span>{</span>\n            <span>private</span> <span>void</span> <span>fun</span><span>(</span><span>)</span><span>{</span>\n                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>out_a<span>)</span><span>;</span>\n                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>STATIC_b</span><span>)</span><span>;</span>\n                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>inner_c<span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span>\n        <span>Inner</span>  inner <span>=</span> <span>new</span> <span>Inner</span><span>(</span><span>)</span><span>;</span>\n        inner<span>.</span><span>fun</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n    <span>public</span> <span>static</span> <span>void</span> <span>testStaticFunctionClass</span><span>(</span><span>)</span><span>{</span>\n        <span>int</span> d <span>=</span><span>3</span><span>;</span>\n        <span>class</span> <span>Inner</span> <span>{</span>\n            <span>private</span> <span>void</span> <span>fun</span><span>(</span><span>)</span><span>{</span>\n                <span>// System.out.println(out_a); 编译错误，定义在静态方法中的局部类不可以访问外部类的实例变量</span>\n                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>STATIC_b</span><span>)</span><span>;</span>\n                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>d<span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span>\n        <span>Inner</span>  inner <span>=</span> <span>new</span> <span>Inner</span><span>(</span><span>)</span><span>;</span>\n        inner<span>.</span><span>fun</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br></div></div><p>定义在实例方法中的局部类可以访问外部类的所有变量和方法，定义在静态方法中的局部类只能访问外部类的静态变量和方法。</p>\n<p>局部内部类的创建方式，在对应方法内，<code>new 内部类()</code>，如下：</p>\n<div><pre><code> <span>public</span> <span>static</span> <span>void</span> <span>testStaticFunctionClass</span><span>(</span><span>)</span><span>{</span>\n    <span>class</span> <span>Inner</span> <span>{</span>\n    <span>}</span>\n    <span>Inner</span>  inner <span>=</span> <span>new</span> <span>Inner</span><span>(</span><span>)</span><span>;</span>\n <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p><strong>（4）匿名内部类</strong></p>\n<p>匿名内部类就是没有名字的内部类，日常开发中使用的比较多。</p>\n<div><pre><code><span>public</span> <span>class</span> <span>Outer</span> <span>{</span>\n\n    <span>private</span> <span>void</span> <span>test</span><span>(</span><span>final</span> <span>int</span> i<span>)</span> <span>{</span>\n        <span>new</span> <span>Service</span><span>(</span><span>)</span> <span>{</span>\n            <span>public</span> <span>void</span> <span>method</span><span>(</span><span>)</span> <span>{</span>\n                <span>for</span> <span>(</span><span>int</span> j <span>=</span> <span>0</span><span>;</span> j <span>&lt;</span> i<span>;</span> j<span>++</span><span>)</span> <span>{</span>\n                    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"匿名内部类\"</span> <span>)</span><span>;</span>\n                <span>}</span>\n            <span>}</span>\n        <span>}</span><span>.</span><span>method</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n <span>}</span>\n <span>//匿名内部类必须继承或实现一个已有的接口 </span>\n <span>interface</span> <span>Service</span><span>{</span>\n    <span>void</span> <span>method</span><span>(</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>除了没有名字，匿名内部类还有以下特点：</p>\n<ul>\n<li><mark>匿名内部类必须继承一个抽象类或者实现一个接口。</mark></li>\n<li>匿名内部类不能定义任何静态成员和静态方法。</li>\n<li>当所在的方法的形参需要被匿名内部类使用时，必须声明为 final。</li>\n<li>匿名内部类不能是抽象的，它必须要实现继承的类或者实现的接口的所有抽象方法。</li>\n</ul>\n<p>匿名内部类创建方式：</p>\n<div><pre><code><span>new</span> 类<span>/</span>接口<span>{</span> \n  <span>//匿名内部类实现部分</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><blockquote>\n<p>3、内部类的优点</p>\n</blockquote>\n<p>我们为什么要使用内部类呢？因为它有以下优点：</p>\n<ul>\n<li>一个内部类对象可以访问创建它的外部类对象的内容，包括私有数据！</li>\n<li>内部类不为同一包的其他类所见，具有很好的封装性；</li>\n<li>内部类有效实现了“多重继承”，优化 java 单继承的缺陷。</li>\n<li>匿名内部类可以很方便的定义回调。</li>\n</ul>\n<blockquote>\n<p>4、内部类有哪些应用场景</p>\n</blockquote>\n<ol>\n<li>一些多算法场合</li>\n<li>解决一些非面向对象的语句块。</li>\n<li>适当使用内部类，使得代码更加灵活和富有扩展性。</li>\n<li>当某个类除了它的外部类，不再被其他的类使用时。</li>\n</ol>\n<blockquote>\n<p>5、局部内部类和匿名内部类访问 <mark>局部变量</mark> 的时候，为什么变量必须 <mark>要加上final</mark> ？</p>\n</blockquote>\n<p>先看这段代码：</p>\n<div><pre><code><span>public</span> <span>class</span> <span>Outer</span> <span>{</span>\n\n    <span>void</span> <span>outMethod</span><span>(</span><span>)</span><span>{</span>\n        <span>final</span> <span>int</span> a <span>=</span><span>10</span><span>;</span>\n        <span>class</span> <span>Inner</span> <span>{</span>\n            <span>void</span> <span>innerMethod</span><span>(</span><span>)</span><span>{</span>\n                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>a<span>)</span><span>;</span>\n            <span>}</span>\n\n        <span>}</span>\n    <span>}</span>\n<span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>以上例子，为什么要加final呢？是因为生命周期不一致， 局部变量直接存储在栈中，当方法执行结束后，非final的局部变量就被销毁。</p>\n<p>而局部内部类对局部变量的引用依然存在，如果局部内部类要调用局部变量时，就会出错。加了final，可以确保局部内部类使用的变量</p>\n<p>与外层的局部变量区分开，解决了这个问题。</p>\n<blockquote>\n<p>6、内部类相关，看程序说出运行结果</p>\n</blockquote>\n<div><pre><code><span>public</span> <span>class</span> <span>Outer</span> <span>{</span>\n    <span>private</span> <span>int</span> age <span>=</span> <span>12</span><span>;</span>\n\n    <span>class</span> <span>Inner</span> <span>{</span>\n        <span>private</span> <span>int</span> age <span>=</span> <span>13</span><span>;</span>\n        <span>public</span> <span>void</span> <span>print</span><span>(</span><span>)</span> <span>{</span>\n            <span>int</span> age <span>=</span> <span>14</span><span>;</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"局部变量：\"</span> <span>+</span> age<span>)</span><span>;</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"内部类变量：\"</span> <span>+</span> <span>this</span><span>.</span>age<span>)</span><span>;</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"外部类变量：\"</span> <span>+</span> <span>Outer</span><span>.</span><span>this</span><span>.</span>age<span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n        <span>Outer<span>.</span>Inner</span> in <span>=</span> <span>new</span> <span>Outer</span><span>(</span><span>)</span><span>.</span><span>new</span> <span>Inner</span><span>(</span><span>)</span><span>;</span>\n        in<span>.</span><span>print</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n\n<span>}</span>\n运行结果\n局部变量：<span>14</span>\n内部类变量：<span>13</span>\n外部类变量：<span>12</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><h4 id=\"六-重写与重载-2\"> （六）重写与重载</h4>\n<blockquote>\n<p>1、构造器（constructor）是否可被重写（override）</p>\n</blockquote>\n<p>构造器不能被继承，因此不能被重写，但可以被重载。</p>\n<blockquote>\n<p>2、重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？</p>\n</blockquote>\n<p><mark>方法的重载和重写都是实现多态的方式</mark>，区别在于前者实现的是 <mark>编译时的多态性</mark> ，而后者实现的是 <mark>运行时的多态性</mark>。</p>\n<ul>\n<li>\n<p><strong>重载：</strong></p>\n<p>1、发生在同一个类中，方法名相同参数列表不同（参数类型不同、个数不同、顺序不同），</p>\n<p>2、与方法返回值和访问修饰符无关，即重载的方法不能根据返回类型进行区分</p>\n</li>\n<li>\n<p><strong>重写：</strong></p>\n<p>1、发生在父子类中，方法名、参数列表必须相同，</p>\n<p>2、返回值小于等于父类，抛出的异常小于等于父类，</p>\n<p>3、访问修饰符大于等于父类（里氏替换原则）</p>\n<p>4、如果父类方法访问修饰符为private则子类中就不是重写。</p>\n</li>\n</ul>\n<h4 id=\"七-对象相等判断-2\"> （七）对象相等判断</h4>\n<blockquote>\n<p>1、== 和 equals 的区别是什么</p>\n</blockquote>\n<p><mark>==和equals都是值比较</mark></p>\n<p><strong>（1）==</strong></p>\n<ul>\n<li>\n<p>基本数据类型 == 比较的是值</p>\n</li>\n<li>\n<p>引用数据类型 == 比较的是内存地址值</p>\n</li>\n</ul>\n<p><strong>（2）equals() :</strong></p>\n<p>​\t对象之间进行比较的方法</p>\n<ul>\n<li>\n<p>equals内部先进行的还是==，判断是否是同一个对象</p>\n</li>\n<li>\n<p>接着才会是对象内容的比较（重写过equals方法）</p>\n</li>\n</ul>\n<p><strong>equals() 一般有两种使用情况：</strong></p>\n<ul>\n<li>\n<p>情况1：类没有覆盖 equals() 方法。则通过 equals() 比较该类的两个对象时，等价于通过“==”比较这两个对象。</p>\n</li>\n<li>\n<p>情况2：类覆盖了 equals() 方法。一般，我们都覆盖 equals() 方法来两个对象的内容相等；若它们的内容相等，则返回 true (即认   为这两个对象相等)。</p>\n</li>\n</ul>\n<div><pre><code><span>public</span> <span>class</span> test1 <span>{</span>\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n        <span>String</span> a <span>=</span> <span>new</span> <span>String</span><span>(</span><span>\"ab\"</span><span>)</span><span>;</span> <span>// a 为一个引用</span>\n        <span>String</span> b <span>=</span> <span>new</span> <span>String</span><span>(</span><span>\"ab\"</span><span>)</span><span>;</span> <span>// b为另一个引用,对象的内容一样</span>\n        <span>String</span> aa <span>=</span> <span>\"ab\"</span><span>;</span> <span>// 放在常量池中</span>\n        <span>String</span> bb <span>=</span> <span>\"ab\"</span><span>;</span> <span>// 从常量池中查找</span>\n        <span>if</span> <span>(</span>aa <span>==</span> bb<span>)</span> <span>// true</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"aa==bb\"</span><span>)</span><span>;</span>\n        <span>if</span> <span>(</span>a <span>==</span> b<span>)</span> <span>// false，非同一对象</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"a==b\"</span><span>)</span><span>;</span>\n        <span>if</span> <span>(</span>a<span>.</span><span>equals</span><span>(</span>b<span>)</span><span>)</span> <span>// true</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"aEQb\"</span><span>)</span><span>;</span>\n        <span>if</span> <span>(</span><span>42</span> <span>==</span> <span>42.0</span><span>)</span> <span>{</span> <span>// true</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"true\"</span><span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p>说明：</p>\n<ul>\n<li>String中的equals方法是被重写过的，因为object的equals方法是比较的对象的内存地址，而String的equals方法比较的是对象的内容。</li>\n<li>当创建String类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个String对象。</li>\n</ul>\n<blockquote>\n<p>2、hashCode 与 equals 方法 ( <mark>重要</mark> )</p>\n</blockquote>\n<p><strong>HashSet如何检查重复？</strong></p>\n<p>两个对象的 hashCode() 相同，则 equals() 也一定为 true，对吗？</p>\n<p>hashCode和equals方法的关系</p>\n<p>面试官可能会问你：“你重写过 hashcode 和 equals 么，为什么重写equals时必须重写hashCode方法？”</p>\n<p><strong>（1）hashCode()介绍</strong></p>\n<p>hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个int整数。这个哈希码的作用是确定该对象在哈希表中的索引位</p>\n<p>置。hashCode() 定义在JDK的Object.java中，这就意味着Java中的任何类都包含有hashCode()函数。散列表存储的是键值对(key-</p>\n<p>value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）</p>\n<p><strong>（2）为什么要有 hashCode</strong></p>\n<p>我们以“HashSet 如何检查重复”为例子来说明为什么要有 hashCode：</p>\n<p>当你把对象加入 HashSet 时，HashSet 会先计算对象的 hashcode 值来判断对象加入的位置，同时也会与其他已经加入的对象的</p>\n<p>hashcode 值作比较，如果没有相符的hashcode，HashSet会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时</p>\n<p>会调用 equals()方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让加入操作成功。如果不同的话，就</p>\n<p>会重新散列到其他位置。（摘自我的Java启蒙书《Head first java》第二版）。这样我们就 <mark>大大减少了 equals 的次数</mark> ，相应就大大提高</p>\n<p>了执行速度。</p>\n<p><strong>（3）hashCode()与equals()的相关规定</strong></p>\n<ul>\n<li>\n<p>如果两个对象相等，则hashcode一定也是相同的</p>\n</li>\n<li>\n<p>两个对象相等，对两个对象分别调用equals方法都返回true</p>\n</li>\n<li>\n<p>两个对象有相同的hashcode值，它们也不一定是相等的</p>\n</li>\n<li>\n<p>hashCode() 的默认行为是对堆上的对象产生独特值。如果没有重写 hashCode()，</p>\n<p>则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）</p>\n</li>\n<li>\n<p><mark>因此，equals 方法被覆盖过，则 hashCode 方法也必须被覆盖</mark></p>\n</li>\n</ul>\n<blockquote>\n<p>3、对象的相等与指向他们的引用相等，两者有什么不同？</p>\n</blockquote>\n<p>对象的相等比的是内存中存放的内容是否相等，而引用相等 比较的是他们指向的内存地址是否相等。</p>\n<h4 id=\"八-值传递-2\"> （八）值传递</h4>\n<blockquote>\n<p>1、当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递</p>\n</blockquote>\n<p>是值传递。</p>\n<ul>\n<li>\n<p>Java 语言的方法调用只支持参数的值传递。</p>\n</li>\n<li>\n<p>当一个对象实例作为一个参数被传递到方法中时，<mark>参数的值就是对该对象的引用</mark> 。</p>\n</li>\n<li>\n<p>对象的属性可以在被调用过程中被改变，但对对象引用的改变是不会影响到调用者的</p>\n</li>\n</ul>\n<blockquote>\n<p>2、 Java 中对象作为形参为什么还是值传递</p>\n</blockquote>\n<p>首先回顾一下在程序设计语言中有关将参数传递给方法（或函数）的一些专业术语。</p>\n<ul>\n<li>按值调用(call by value)表示方法接收的是调用者提供的值，</li>\n<li>而按引用调用（call by reference)表示方法接收的是调用者提供的变量地址。</li>\n<li><mark>一个方法可以修改传递引用所对应的变量值，而不能修改传递值所对应的变量值</mark> 。 它用来描述各种程序设计语言（不只是Java)中方法参数传递方式。</li>\n<li>Java程序设计语言总是采用按值调用。也就是说，<mark>方法得到的是所有参数值的一个拷贝</mark> ，也就是说，方法不能修改传递给它的任何参数变量的内容。</li>\n</ul>\n<p>下面通过 3 个例子来说明</p>\n<p>example1：</p>\n<div><pre><code><span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n    <span>int</span> num1 <span>=</span> <span>10</span><span>;</span>\n    <span>int</span> num2 <span>=</span> <span>20</span><span>;</span>\n\n    <span>swap</span><span>(</span>num1<span>,</span> num2<span>)</span><span>;</span>\n\n    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"num1 = \"</span> <span>+</span> num1<span>)</span><span>;</span>\n    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"num2 = \"</span> <span>+</span> num2<span>)</span><span>;</span>\n<span>}</span>\n\n<span>public</span> <span>static</span> <span>void</span> <span>swap</span><span>(</span><span>int</span> a<span>,</span> <span>int</span> b<span>)</span> <span>{</span>\n    <span>int</span> temp <span>=</span> a<span>;</span>\n    a <span>=</span> b<span>;</span>\n    b <span>=</span> temp<span>;</span>\n\n    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"a = \"</span> <span>+</span> a<span>)</span><span>;</span>\n    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"b = \"</span> <span>+</span> b<span>)</span><span>;</span>\n<span>}</span>\na <span>=</span> <span>20</span>\nb <span>=</span> <span>10</span>\nnum1 <span>=</span> <span>10</span>\nnum2 <span>=</span> <span>20</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><p><img src=\"./assets/04.jpg\" alt=\"\"></p>\n<p>在swap方法中，a、b的值进行交换，并不会影响到 num1、num2。因为，a、b中的值，只是从 num1、num2 的复制过来的。也就是说，a、b相当于num1、num2 的副本，副本的内容无论怎么修改，都不会影响到原件本身。</p>\n<p>通过上面例子，我们已经知道了一个方法不能修改一个基本数据类型的参数，而 <mark>对象引用作为参数就不一样</mark></p>\n<p>example2 ：</p>\n<div><pre><code>    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n        <span>int</span><span>[</span><span>]</span> arr <span>=</span> <span>{</span> <span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>4</span><span>,</span> <span>5</span> <span>}</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>arr<span>[</span><span>0</span><span>]</span><span>)</span><span>;</span>\n        <span>change</span><span>(</span>arr<span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>arr<span>[</span><span>0</span><span>]</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>static</span> <span>void</span> <span>change</span><span>(</span><span>int</span><span>[</span><span>]</span> array<span>)</span> <span>{</span>\n        <span>// 将数组的第一个元素变为0</span>\n        array<span>[</span><span>0</span><span>]</span> <span>=</span> <span>0</span><span>;</span>\n    <span>}</span>\n结果：\n    <span>0</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p><img src=\"./assets/05.jpg\" alt=\"\"></p>\n<ul>\n<li>\n<p>array 被初始化 arr 的拷贝也就是一个对象的引用，也就是说 array 和 arr 指向的时同一个数组对象。 因此，外部对引用对象的改变会反映到所对应的对象上。</p>\n</li>\n<li>\n<p>通过 example2 我们已经看到，实现一个改变对象参数状态的方法并不是一件难事。理由很简单，方法得到的是 <mark>对象引用的拷贝</mark>，对象引用及其他的拷贝同时引用同一个对象。</p>\n</li>\n<li>\n<p>很多程序设计语言（特别是，C++和Pascal)提供了两种参数传递的方式：值调用和引用调用。有些程序员 <mark>认为Java程序设计语言对对象采用的是引用调用，实际上，这种理解是不对的</mark>。由于这种误解具有一定的普遍性，所以下面给出一个反例来详细地阐述一下这个问题。</p>\n</li>\n</ul>\n<p>example3:</p>\n<div><pre><code><span>public</span> <span>class</span> <span>Test</span> <span>{</span>\n\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n        <span>// TODO Auto-generated method stub</span>\n        <span>Student</span> s1 <span>=</span> <span>new</span> <span>Student</span><span>(</span><span>\"小张\"</span><span>)</span><span>;</span>\n        <span>Student</span> s2 <span>=</span> <span>new</span> <span>Student</span><span>(</span><span>\"小李\"</span><span>)</span><span>;</span>\n        <span>//s1,s2都是对象的引用，有自己的地址，它们各自存储这相应对象的地址</span>\n        <span>Test</span><span>.</span><span>swap</span><span>(</span>s1<span>,</span> s2<span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"s1:\"</span> <span>+</span> s1<span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"s2:\"</span> <span>+</span> s2<span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>static</span> <span>void</span> <span>swap</span><span>(</span><span>Student</span> x<span>,</span> <span>Student</span> y<span>)</span> <span>{</span>\n        <span>Student</span> temp <span>=</span> x<span>;</span>\n        x <span>=</span> y<span>;</span>\n        y <span>=</span> temp<span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"x:\"</span> <span>+</span> x<span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"y:\"</span> <span>+</span> y<span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n结果：\n    x<span>:</span>小李\n\ty<span>:</span>小张\n\ts1<span>:</span>小张\n\ts2<span>:</span>小李\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><p>交换前：</p>\n<p><img src=\"./assets/06.jpg\" alt=\"\"></p>\n<p>交换后：</p>\n<p><img src=\"./assets/07.jpg\" alt=\"\"></p>\n<p>通过上面两张图可以很清晰的看出： 方法并没有改变存储在变量 s1 和 s2 中的对象引用。swap方法的参数x和y被初始化为两个对象引用的拷贝，这个方法交换的是这两个拷贝</p>\n<p><strong>总结</strong></p>\n<ol>\n<li>\n<p>Java程序设计语言对对象采用的不是引用调用，实际上，对象引用是按值传递的，只不过这个值是对应的内存地址，与基本数据类型稍微不同而已</p>\n</li>\n<li>\n<p>或者只需要记住传参都是进行拷贝，  <mark>对象引用的拷贝与引用传递不一样</mark></p>\n</li>\n<li>\n<p>一个引用有自己的地址，它还存储着所引用对象的地址。</p>\n</li>\n<li>\n<p><strong>对象引用的拷贝</strong>就是是 <mark>传递引用里存储的内存地址</mark> ，而<strong>引用传递</strong>是 <mark>传递引用自己本身的地址</mark>。</p>\n<div><pre><code> <span>Student</span> s1 <span>=</span> <span>new</span> <span>Student</span><span>(</span><span>\"小张\"</span><span>)</span><span>;</span>\n<span>//假设s1地址为123,所指向的对象的地址为456</span>\n<span>//Java的值传递:将地址456拷贝给形参</span>\n<span>//引用传递:将地址123拷贝给形参</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div></li>\n</ol>\n<p><strong>总结一下Java中方法参数的使用情况：</strong></p>\n<ul>\n<li>一个方法不能修改一个基本数据类型的参数（即数值型或布尔型》</li>\n<li>一个方法可以改变一个对象参数的状态。</li>\n<li><mark>一个方法不能让对象参数引用一个新的对象。</mark></li>\n</ul>\n<blockquote>\n<p>3、值传递和引用传递有什么区别</p>\n</blockquote>\n<p><strong>值传递</strong> ：指的是在方法调用时，传递的参数是按值的拷贝传递，传递的是值的拷贝，也就是说传递后就互不相关了。</p>\n<p><strong>引用传递</strong>：指的是在方法调用时，传递的参数是按引用进行传递，<mark>传递的是引用的地址</mark>，也就是变量所对应的内存空间的地址。传递\t\t\t\t\t\t\t 的是值的引用，也就是说传递前和传递后都指向同一个引用（也就是同一个内存空间）。</p>\n<h4 id=\"九-java包-2\"> （九）Java包</h4>\n<blockquote>\n<p>1、JDK 中常用的包有哪些</p>\n</blockquote>\n<p>java.lang：这个是系统的基础类，不用显示导入</p>\n<p>java.io：这里面是所有输入输出有关的类，比如文件操作等；</p>\n<p>java.nio：为了完善 io 包中的功能，提高 io 包中性能而写的一个新包；</p>\n<p>java.net：这里面是与网络有关的类；</p>\n<p>java.util：这个是系统辅助类，特别是集合类；</p>\n<p>java.sql：这个是数据库操作的类。</p>\n<blockquote>\n<p>2、import java和javax有什么区别</p>\n</blockquote>\n<p>刚开始的时候 JavaAPI 所必需的包是 java 开头的包，javax 当时只是作为扩展 API 包来使用。后来考虑到将扩展从 javax 包移动到 java</p>\n<p>包太麻烦了，最终会破坏一堆现有的代码，最终决定将 javax 包作为标准API的一部分。</p>\n<p>所以，实际上java和javax没有区别。这都是一个名字。</p>\n<h3 id=\"四、常用api-2\"> 四、常用API</h3>\n<h4 id=\"一-string相关-2\"> （一）String相关</h4>\n<blockquote>\n<p>1、字符型常量和字符串常量的区别</p>\n</blockquote>\n<ul>\n<li>形式上: 字符常量是单引号引起的一个字符 字符串常量是双引号引起的若干个字符</li>\n<li>含义上: 字符常量相当于一个整形值(ASCII值),可以参加表达式运算 ,字符串常量代表一个地址值(该字符串在内存中存放位置)</li>\n<li>占内存大小: 字符常量只占一个字节 字符串常量占若干个字节(至少一个字符结束标志)</li>\n</ul>\n<blockquote>\n<p>2、什么是字符串常量池？</p>\n</blockquote>\n<ul>\n<li>字符串常量池位于<strong>堆内存</strong>中，专门用来存储字符串常量，可以提高内存的使用率，避免开辟多块空间存储相同的字符串</li>\n<li>在创建字符串时 JVM 会首先检查字符串常量池，如果该字符串已经存在池中，则返回它的引用，如果不存在，则实例化一个字符串放到池中，并返回其引用。</li>\n</ul>\n<blockquote>\n<p>3、String 是最基本的数据类型吗</p>\n</blockquote>\n<p>不是。</p>\n<ul>\n<li>\n<p>Java 中的基本数据类型只有 8 个 ：byte、short、int、long、float、double、char、boolean；</p>\n</li>\n<li>\n<p>除了基本类型（primitive type），剩下的都是引用类型（referencetype），Java 5 以后引入的枚举类型也算是一种比较特殊的引用类型。</p>\n</li>\n<li>\n<p>这是很基础的东西，但是很多初学者却容易忽视，Java 的 8 种基本数据类型中不包括 String，基本数据类型中用来描述文本数据的是 char，但是它只能表示单个字符，比如 ‘a’,‘好’ 之类的，如果要描述一段文本，就需要用多个 char 类型的变量，也就是一个 char 类型数组，比如“你好” 就是长度为2的数组 char[] chars = {‘你’,‘好’};</p>\n</li>\n<li>\n<p>但是使用数组过于麻烦，所以就有了 String，String 底层就是一个 char 类型的数组，只是使用的时候开发者不需要直接操作底层数组，用更加简便的方式即可完成对字符串的使用。</p>\n</li>\n</ul>\n<blockquote>\n<p>4、String有哪些特性</p>\n</blockquote>\n<ul>\n<li>\n<p>不变性：String 是只读字符串，是一个典型的 immutable 对象，对它进行任何操作，其实都是创建一个新的对象，再把引用指向该对象。不变模式的主要作用在于当一个对象需要被多线程共享并频繁访问时，可以保证数据的一致性。</p>\n</li>\n<li>\n<p>常量池优化：String 对象创建之后，会在字符串常量池中进行缓存，如果下次创建同样的对象时，会直接返回缓存的引用。</p>\n</li>\n<li>\n<p>final：使用 final 来定义 String 类，表示 String 类不能被继承，提高了系统的安全性。</p>\n</li>\n</ul>\n<blockquote>\n<p>5、String为什么是不可变的吗？</p>\n</blockquote>\n<p>简单来说就是String类利用了final修饰的char类型数组存储字符，源码如下图所以：</p>\n<div><pre><code><span>/** The value is used for character storage. */</span>\n<span>private</span> <span>final</span> <span>char</span> value<span>[</span><span>]</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><blockquote>\n<p>6、String真的是不可变的吗？</p>\n</blockquote>\n<p>我觉得如果别人问这个问题的话，回答不可变就可以了。 下面只是给大家看两个有代表性的例子：</p>\n<p><strong>1) String不可变但不代表引用(句柄)不可以变</strong></p>\n<div><pre><code><span>String</span> str <span>=</span> <span>\"Hello\"</span><span>;</span>\nstr <span>=</span> str <span>+</span> <span>\" World\"</span><span>;</span>\n<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"str=\"</span> <span>+</span> str<span>)</span><span>;</span>\n结果：\n    str<span>=</span><span>Hello</span> <span>World</span>\n实际上，原来<span>String</span>的内容是不变的，只是str由原来指向<span>\"Hello\"</span>的内存地址转为指向<span>\"Hello World\"</span>的内存地址而已，也就是说多开辟了一块内存区域给<span>\"Hello World\"</span>字符串。\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p><strong>2) 通过反射是可以修改所谓的“不可变”对象</strong></p>\n<div><pre><code><span>// 创建字符串\"Hello World\"， 并赋给引用s</span>\n<span>String</span> s <span>=</span> <span>\"Hello World\"</span><span>;</span>\n\n<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"s = \"</span> <span>+</span> s<span>)</span><span>;</span> <span>// Hello World</span>\n\n<span>// 获取String类中的value字段</span>\n<span>Field</span> valueFieldOfString <span>=</span> <span>String</span><span>.</span><span>class</span><span>.</span><span>getDeclaredField</span><span>(</span><span>\"value\"</span><span>)</span><span>;</span>\n\n<span>// 改变value属性的访问权限</span>\nvalueFieldOfString<span>.</span><span>setAccessible</span><span>(</span><span>true</span><span>)</span><span>;</span>\n\n<span>// 获取s对象上的value属性的值</span>\n<span>char</span><span>[</span><span>]</span> value <span>=</span> <span>(</span><span>char</span><span>[</span><span>]</span><span>)</span> valueFieldOfString<span>.</span><span>get</span><span>(</span>s<span>)</span><span>;</span>\n\n<span>// 改变value所引用的数组中的第5个字符</span>\nvalue<span>[</span><span>5</span><span>]</span> <span>=</span> <span>'_'</span><span>;</span>\n\n<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"s = \"</span> <span>+</span> s<span>)</span><span>;</span> <span>// Hello_World</span>\n结果：\n    s <span>=</span> <span>Hello</span> <span>World</span>\n\ts <span>=</span> <span>Hello_World</span>\n用反射可以访问私有成员， 然后反射出<span>String</span>对象中的value属性， 进而改变通过获得的value引用改变数组的结构。但是一般我们不会这么做，这里只是简单提一下有这个东西。\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><blockquote>\n<p>7、是否可以继承 String 类</p>\n</blockquote>\n<p>String 类是 final 类，不可以被继承。</p>\n<blockquote>\n<p>8、String str=&quot;i&quot;与 String str=new String(&quot;i&quot;)一样吗？</p>\n</blockquote>\n<p>不一样，因为内存的分配方式不一样。</p>\n<ul>\n<li>String str=&quot;i&quot;的方式，java 虚拟机会将其分配到常量池中</li>\n<li>而 String str=new String(“i”) 则会被分到堆内存中。</li>\n</ul>\n<blockquote>\n<p>9、String s = new String(&quot;xyz&quot;);创建了几个字符串对象</p>\n</blockquote>\n<p>两个对象，一个是静态区的&quot;xyz&quot;，一个是用new创建在堆上的对象。（前提是之前字符串常量池中没有&quot;xyz&quot;）</p>\n<div><pre><code><span>String</span> str1 <span>=</span> <span>\"hello\"</span><span>;</span> <span>//str1指向静态区</span>\n<span>String</span> str2 <span>=</span> <span>new</span> <span>String</span><span>(</span><span>\"hello\"</span><span>)</span><span>;</span>  <span>//str2指向堆上的对象</span>\n<span>String</span> str3 <span>=</span> <span>\"hello\"</span><span>;</span>\n<span>String</span> str4 <span>=</span> <span>new</span> <span>String</span><span>(</span><span>\"hello\"</span><span>)</span><span>;</span>\n<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>str1<span>.</span><span>equals</span><span>(</span>str2<span>)</span><span>)</span><span>;</span> <span>//true</span>\n<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>str2<span>.</span><span>equals</span><span>(</span>str4<span>)</span><span>)</span><span>;</span> <span>//true</span>\n<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>str1 <span>==</span> str3<span>)</span><span>;</span> <span>//true</span>\n<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>str1 <span>==</span> str2<span>)</span><span>;</span> <span>//false</span>\n<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>str2 <span>==</span> str4<span>)</span><span>;</span> <span>//false</span>\n<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>str2 <span>==</span> <span>\"hello\"</span><span>)</span><span>;</span> <span>//false</span>\nstr2 <span>=</span> str1<span>;</span>\n<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>str2 <span>==</span> <span>\"hello\"</span><span>)</span><span>;</span> <span>//true</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><blockquote>\n<p>10、如何将字符串反转？</p>\n</blockquote>\n<p>使用 StringBuilder 或者 stringBuffer 的 reverse() 方法</p>\n<div><pre><code><span>// StringBuffer reverse</span>\n<span>StringBuffer</span> stringBuffer <span>=</span> <span>new</span> <span>StringBuffer</span><span>(</span><span>)</span><span>;</span>\nstringBuffer<span>.</span> <span>append</span><span>(</span><span>\"abcdefg\"</span><span>)</span><span>;</span>\n<span>System</span><span>.</span> out<span>.</span> <span>println</span><span>(</span>stringBuffer<span>.</span> <span>reverse</span><span>(</span><span>)</span><span>)</span><span>;</span> <span>// gfedcba</span>\n<span>// StringBuilder reverse</span>\n<span>StringBuilder</span> stringBuilder <span>=</span> <span>new</span> <span>StringBuilder</span><span>(</span><span>)</span><span>;</span>\nstringBuilder<span>.</span> <span>append</span><span>(</span><span>\"abcdefg\"</span><span>)</span><span>;</span>\n<span>System</span><span>.</span> out<span>.</span> <span>println</span><span>(</span>stringBuilder<span>.</span> <span>reverse</span><span>(</span><span>)</span><span>)</span><span>;</span> <span>// gfedcba</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><blockquote>\n<p>11、数组有没有 length()方法？String 有没有 length()方法</p>\n</blockquote>\n<ul>\n<li>数组没有 length()方法 ，有 length 的属性。</li>\n<li>String 有 length()方法。</li>\n<li>JavaScript中，获得字符串的长度是通过 length 属性得到的，这一点容易和 Java 混淆。</li>\n</ul>\n<blockquote>\n<p>12、String 类的常用方法都有那些？</p>\n</blockquote>\n<ul>\n<li>\n<p>indexOf()：返回指定字符的索引。</p>\n</li>\n<li>\n<p>charAt()：返回指定索引处的字符。</p>\n</li>\n<li>\n<p>replace()：字符串替换。</p>\n</li>\n<li>\n<p>trim()：去除字符串两端空白。</p>\n</li>\n<li>\n<p>split()：分割字符串，返回一个分割后的字符串数组。</p>\n</li>\n<li>\n<p>getBytes()：返回字符串的 byte 类型数组。</p>\n</li>\n<li>\n<p>length()：返回字符串长度。</p>\n</li>\n<li>\n<p>toLowerCase()：将字符串转成小写字母。</p>\n</li>\n<li>\n<p>toUpperCase()：将字符串转成大写字符。</p>\n</li>\n<li>\n<p>substring()：截取字符串。</p>\n</li>\n<li>\n<p>equals()：字符串比较。</p>\n</li>\n</ul>\n<blockquote>\n<p>13、在使用 HashMap 的时候，用 String 做 key 有什么好处？</p>\n</blockquote>\n<p>HashMap 内部实现是通过 key 的 hashcode 来确定 value 的存储位置，因为字符串是不可变的，所以当创建字符串时，它的</p>\n<p>hashcode 被缓存下来，不需要再次计算，所以相比于其他对象更快。</p>\n<blockquote>\n<p>14、String和StringBuffer、StringBuilder的区别是什么？String为什么是不可变的</p>\n</blockquote>\n<p><strong>可变性</strong></p>\n<p>String类中使用字符数组保存字符串，private　final　char　value[]，所以string对象是不可变的。StringBuilder与StringBuffer都继承自AbstractStringBuilder类，在AbstractStringBuilder中也是使用字符数组保存字符串，char[] value，这两种对象都是可变的。</p>\n<p><strong>线程安全性</strong></p>\n<p>String中的对象是不可变的，也就可以理解为常量，线程安全。AbstractStringBuilder是StringBuilder与StringBuffer的公共父类，定义了一些字符串的基本操作，如expandCapacity、append、insert、indexOf等公共方法。StringBuffer对方法加了<strong>同步锁</strong>或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder并没有对方法进行加同步锁，所以是非线程安全的。</p>\n<p><strong>性能</strong></p>\n<p>每次对String 类型进行改变的时候，都会生成一个新的String对象，然后将指针指向新的String 对象。StringBuffer每次都会对StringBuffer对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用StirngBuilder 相比使用StringBuffer 仅能获得10%~15% 左右的性能提升，但却要冒多线程不安全的风险。</p>\n<p><strong>对于三者使用的总结</strong></p>\n<p>如果要操作少量的数据用   String</p>\n<p>单线程操作字符串缓冲区 下操作大量数据  StringBuilder</p>\n<p>多线程操作字符串缓冲区 下操作大量数据  StringBuffer</p>\n<h4 id=\"二-date相关-2\"> （二）Date相关</h4>\n<h4 id=\"三-包装类相关-2\"> （三）包装类相关</h4>\n<blockquote>\n<p>1、自动装箱与拆箱</p>\n</blockquote>\n<p><strong>装箱</strong>：将基本类型用它们对应的引用类型包装起来；</p>\n<p><strong>拆箱</strong>：将包装类型转换为基本数据类型；</p>\n<blockquote>\n<p>2、int 和 Integer 有什么区别</p>\n</blockquote>\n<ul>\n<li>Java 是一个近乎纯洁的面向对象编程语言，但是为了编程的方便还是引入了基本数据类型，</li>\n<li><mark>为了能够将这些基本数据类型当成对象操作</mark>，Java 为每一个基本数据类型都引入了对应的包装类型（wrapper class），</li>\n<li>从 Java 5 开始引入了自动装箱/拆箱机制，使得二者可以相互转换。</li>\n</ul>\n<p>Java 为每个原始类型提供了<strong>包装类型</strong>：</p>\n<ul>\n<li>\n<p>原始类型: boolean，char，byte，short，int，long，float，double</p>\n</li>\n<li>\n<p>包装类型：Boolean，Character，Byte，Short，Integer，Long，Float，Double</p>\n</li>\n</ul>\n<blockquote>\n<p>3、Integer a= 127 与 Integer b = 127相等吗</p>\n</blockquote>\n<p>相等。</p>\n<ul>\n<li>对于对象引用类型：== 比较的是对象的内存地址。</li>\n<li>对于基本数据类型：==比较的是值。</li>\n</ul>\n<p>如果整型字面量的值在-128到127之间，那么自动装箱时不会new新的Integer对象，而是直接引用 <mark>常量池</mark> 中的Integer对象，</p>\n<p>超过范围 a==b的结果是false</p>\n<div><pre><code><span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n    <span>Integer</span> a <span>=</span> <span>new</span> <span>Integer</span><span>(</span><span>3</span><span>)</span><span>;</span>\n    <span>Integer</span> b <span>=</span> <span>3</span><span>;</span>  <span>// 将3自动装箱成Integer类型</span>\n    <span>int</span> c <span>=</span> <span>3</span><span>;</span>\n    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>a <span>==</span> b<span>)</span><span>;</span> <span>// false 两个引用没有引用同一对象</span>\n    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>a <span>==</span> c<span>)</span><span>;</span> <span>// true a自动拆箱成int类型再和c比较</span>\n    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>b <span>==</span> c<span>)</span><span>;</span> <span>// true</span>\n\n    <span>Integer</span> a1 <span>=</span> <span>128</span><span>;</span>\n    <span>Integer</span> b1 <span>=</span> <span>128</span><span>;</span>\n    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>a1 <span>==</span> b1<span>)</span><span>;</span> <span>// false</span>\n\n    <span>Integer</span> a2 <span>=</span> <span>127</span><span>;</span>\n    <span>Integer</span> b2 <span>=</span> <span>127</span><span>;</span>\n    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>a2 <span>==</span> b2<span>)</span><span>;</span> <span>// true</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><h3 id=\"五、常用工具类库\"> 五、常用工具类库</h3>\n<h3 id=\"六、单元测试\"> 六、单元测试</h3>\n<h3 id=\"七、日志\"> 七、日志</h3>\n",
      "date_modified": "2021-02-08T17:34:42.000Z",
      "authors": [
        {
          "name": "南辞"
        }
      ],
      "tags": []
    },
    {
      "title": "Java进阶",
      "url": "http://qiqi.dreamagain.top/program/backend/java/solution/Java%E8%BF%9B%E9%98%B6/",
      "id": "http://qiqi.dreamagain.top/program/backend/java/solution/Java%E8%BF%9B%E9%98%B6/",
      "content_html": "<h2 id=\"问题\"> 问题：</h2>\n<h3 id=\"一、集合-容器\"> 一、集合/容器</h3>\n<h4 id=\"一-概述\"> （一）概述</h4>\n<ol>\n<li>\n<p>什么是集合</p>\n</li>\n<li>\n<p>集合的特点</p>\n</li>\n<li>\n<p>集合和数组的区别</p>\n</li>\n<li>\n<p>使用集合框架的好处</p>\n</li>\n<li>\n<p>常用的集合类有哪些？</p>\n</li>\n<li>\n<p>List，Set，Map三者的区别？List、Set、Map 是否继承自 Collection 接口？List、Map、Set 三个接口存取元素时，各有什么特点？</p>\n</li>\n<li>\n<p>哪些集合类是线程安全的？</p>\n</li>\n<li>\n<p>Java集合的快速失败机制 “fail-fast”？</p>\n</li>\n<li>\n<p>怎么确保一个集合不能被修改？</p>\n</li>\n</ol>\n<h4 id=\"二-collection接口\"> （二）Collection接口</h4>\n<h5 id=\"_1-list接口\"> （1）List接口</h5>\n<ol>\n<li>迭代器 Iterator 是什么？</li>\n<li>Iterator 怎么使用？有什么特点？</li>\n<li>如何边遍历边移除 Collection 中的元素？</li>\n<li>Iterator 和 ListIterator 有什么区别？</li>\n<li>遍历一个 List 有哪些不同的方式？每种方法的实现原理是什么？Java 中 List 遍历的最佳实践是什么？</li>\n<li>说一下 ArrayList 的优缺点</li>\n<li>如何实现数组和 List 之间的转换？</li>\n<li>ArrayList 和 LinkedList 的区别是什么？</li>\n<li>ArrayList 和 Vector 的区别是什么？</li>\n<li>插入数据时，ArrayList、LinkedList、Vector谁速度较快？阐述 ArrayList、Vector、LinkedList 的存储性能和特性？</li>\n<li>多线程场景下如何使用 ArrayList？</li>\n<li>为什么 ArrayList 的 elementData 加上 transient 修饰？</li>\n<li>List 和 Set 的区别</li>\n</ol>\n<h5 id=\"_2-set接口\"> （2）Set接口</h5>\n<ol>\n<li>说一下 HashSet 的实现原理？</li>\n<li>HashSet如何检查重复？HashSet是如何保证数据不可重复的？</li>\n<li>HashSet与HashMap的区别</li>\n</ol>\n<h5 id=\"_3-queue接口\"> （3）Queue接口</h5>\n<ol>\n<li>BlockingQueue是什么？</li>\n<li>在 Queue 中 poll()和 remove()有什么区别？</li>\n</ol>\n<h4 id=\"三-map接口\"> （三）Map接口</h4>\n<ol>\n<li>说一下 HashMap 的实现原理？</li>\n<li>HashMap在JDK1.7和JDK1.8中有哪些不同？HashMap的底层实现</li>\n<li>HashMap的put方法的具体流程？</li>\n<li>HashMap的扩容操作是怎么实现的？</li>\n<li>HashMap是怎么解决哈希冲突的？</li>\n<li>能否使用任何类作为 Map 的 key？</li>\n<li>为什么HashMap中String、Integer这样的包装类适合作为K？</li>\n<li>如果使用Object作为HashMap的Key，应该怎么办呢？</li>\n<li>HashMap为什么不直接使用hashCode()处理后的哈希值直接作为table的下标？</li>\n<li>HashMap 的长度为什么是2的幂次方</li>\n<li>HashMap 与 HashTable 有什么区别？</li>\n<li>如何决定使用 HashMap 还是 TreeMap？</li>\n<li>HashMap 和 ConcurrentHashMap 的区别</li>\n<li>ConcurrentHashMap 和 Hashtable 的区别？</li>\n</ol>\n<h4 id=\"四-辅助工具类\"> （四）辅助工具类</h4>\n<ol>\n<li>Array 和 ArrayList 有何区别？</li>\n<li>如何实现 Array 和 List 之间的转换？</li>\n<li>comparable 和 comparator的区别？</li>\n<li>Collection 和 Collections 有什么区别？</li>\n<li>TreeMap 和 TreeSet 在排序时如何比较元素？Collections 工具类中的 sort()方法如何比较元素？</li>\n</ol>\n<h3 id=\"二、泛型\"> 二、泛型</h3>\n<h3 id=\"三、异常\"> 三、异常</h3>\n<ol>\n<li>Error 和 Exception 区别是什么？</li>\n<li>运行时异常和一般异常(受检异常)区别是什么？</li>\n<li>JVM 是如何处理异常的？</li>\n<li>throw 和 throws 的区别是什么？</li>\n<li>final、finally、finalize 有什么区别？</li>\n<li>NoClassDefFoundError 和 ClassNotFoundException 区别？</li>\n<li>try-catch-finally 中哪个部分可以省略？</li>\n<li>try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？</li>\n<li>类 ExampleA 继承 Exception，类 ExampleB 继承ExampleA。</li>\n<li>常见的 RuntimeException 有哪些？</li>\n<li>Java常见异常有哪些？</li>\n</ol>\n<h3 id=\"四、io流\"> 四、IO流</h3>\n<ol>\n<li>Java 中 IO 流分为几种?</li>\n<li>BIO,NIO,AIO 有什么区别?</li>\n<li>Files的常用方法都有哪些？</li>\n</ol>\n<h3 id=\"五、注解\"> 五、注解</h3>\n<ol>\n<li>谈谈你对Java中注解的理解</li>\n<li>Java中的元注解有哪些？</li>\n</ol>\n<h3 id=\"六、反射\"> 六、反射</h3>\n<ol>\n<li>什么是反射机制？</li>\n<li>反射机制优缺点</li>\n<li>反射机制的应用场景有哪些？</li>\n<li>Java获取反射的三种方法</li>\n</ol>\n<h3 id=\"七、网络\"> 七、网络</h3>\n<ol>\n<li>\n<p>为什么TCP连接的时候是3次？2次不可以吗？</p>\n</li>\n<li>\n<p>为什么TCP连接的时候是3次，关闭的时候却是4次？</p>\n</li>\n<li>\n<p>为什么客户端发出第四次挥手的确认报文后要等2MSL的时间才能释放TCP连接？</p>\n</li>\n<li>\n<p>如果已经建立了连接，但是客户端突然出现故障了怎么办？</p>\n</li>\n<li>\n<p>什么是HTTP，HTTP 与 HTTPS 的区别</p>\n</li>\n<li>\n<p>常用HTTP状态码</p>\n</li>\n<li>\n<p>GET和POST区别</p>\n</li>\n<li>\n<p>什么是对称加密与非对称加密</p>\n</li>\n<li>\n<p>什么是HTTP2</p>\n</li>\n<li>\n<p>Session、Cookie和Token的主要区别</p>\n</li>\n<li>\n<p>Servlet是线程安全的吗</p>\n</li>\n<li>\n<p>Servlet接口中有哪些方法及Servlet生命周期探秘</p>\n</li>\n<li>\n<p>如果客户端禁止 cookie 能实现 session 还能用吗？</p>\n</li>\n</ol>\n<h3 id=\"八、并发\"> 八、并发</h3>\n<h4 id=\"一-基础知识\"> （一）基础知识</h4>\n<h5 id=\"_1-并发编程的优缺点\"> （1）并发编程的优缺点</h5>\n<ol>\n<li>为什么要使用并发编程（并发编程的优点）</li>\n<li>并发编程有什么缺点</li>\n<li>并发编程三要素是什么？在 Java 程序中怎么保证多线程的运行安全？</li>\n<li>并行和并发有什么区别？</li>\n<li>什么是多线程，多线程的优劣？</li>\n</ol>\n<h5 id=\"_2-线程和进程区别\"> （2）线程和进程区别</h5>\n<ol>\n<li>什么是线程和进程?</li>\n<li>进程与线程的区别</li>\n<li>什么是上下文切换?</li>\n<li>守护线程和用户线程有什么区别呢？</li>\n<li>如何在 Windows 和 Linux 上查找哪个线程cpu利用率最高？</li>\n<li>什么是线程死锁</li>\n<li>形成死锁的四个必要条件是什么</li>\n<li>如何避免线程死锁</li>\n</ol>\n<h5 id=\"_3-创建线程的四种方式\"> （3）创建线程的四种方式</h5>\n<ul>\n<li>创建线程有哪几种方式？</li>\n<li>说一下 runnable 和 callable 有什么区别？</li>\n<li>线程的 run()和 start()有什么区别？</li>\n<li>为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？</li>\n<li>什么是 Callable 和 Future?</li>\n<li>什么是 FutureTask？</li>\n</ul>\n<h5 id=\"_4-线程的状态和基本操作\"> （4）线程的状态和基本操作</h5>\n<ol>\n<li>说说线程的生命周期及五种基本状态？</li>\n<li>Java 中用到的线程调度算法是什么？</li>\n<li>线程的调度策略？</li>\n<li>什么是线程调度器(Thread Scheduler)和时间分片(Time Slicing )？</li>\n<li>请说出与线程同步以及线程调度相关的方法。</li>\n<li>sleep() 和 wait() 有什么区别？</li>\n<li>你是如何调用 wait() 方法的？使用 if 块还是循环？为什么？</li>\n<li>为什么线程通信的方法 wait(), notify()和 notifyAll()被定义在 Object 类里？</li>\n<li>为什么 wait(), notify()和 notifyAll()必须在同步方法或者同步块中被调用？</li>\n<li>Thread 类中的 yield 方法有什么作用？</li>\n<li>为什么 Thread 类的 sleep()和 yield ()方法是静态的？</li>\n<li>线程的 sleep()方法和 yield()方法有什么区别？</li>\n<li>如何停止一个正在运行的线程？</li>\n<li>Java 中 interrupted 和 isInterrupted 方法的区别？</li>\n<li>什么是阻塞式方法？</li>\n<li>Java 中你怎样唤醒一个阻塞的线程？</li>\n<li>notify() 和 notifyAll() 有什么区别？</li>\n<li>如何在两个线程间共享数据？</li>\n<li>Java 如何实现多线程之间的通讯和协作？</li>\n<li>同步方法和同步块，哪个是更好的选择？</li>\n<li>什么是线程同步和线程互斥，有哪几种实现方式？</li>\n<li>在监视器(Monitor)内部，是如何做线程同步的？程序应该做哪种级别的同步？</li>\n<li>如果你提交任务时，线程池队列已满，这时会发生什么</li>\n<li>什么叫线程安全？servlet 是线程安全吗?</li>\n<li>在 Java 程序中怎么保证多线程的运行安全？</li>\n<li>你对线程优先级的理解是什么？</li>\n<li>线程类的构造方法、静态块是被哪个线程调用的</li>\n<li>Java 中怎么获取一份线程 dump 文件？你如何在 Java 中获取线程堆栈？</li>\n<li>一个线程运行时发生异常会怎样？</li>\n<li>Java 线程数过多会造成什么异常？</li>\n</ol>\n<h4 id=\"二-并发理论\"> （二）并发理论</h4>\n<h5 id=\"_1-java内存模型\"> （1）Java内存模型</h5>\n<ol>\n<li>Java中垃圾回收有什么目的？什么时候进行垃圾回收？</li>\n<li>如果对象的引用被置为null，垃圾收集器是否会立即释放对象占用的内存？</li>\n<li>finalize()方法什么时候被调用？析构函数(finalization)的目的是什么？</li>\n</ol>\n<h5 id=\"_2-重排序与数据依赖性\"> （2）重排序与数据依赖性</h5>\n<ol>\n<li>为什么代码会重排序？</li>\n</ol>\n<h5 id=\"_3-as-if-serial规则和happens-before规则的区别\"> （3）as-if-serial规则和happens-before规则的区别</h5>\n<h4 id=\"三-并发关键字\"> （三）并发关键字</h4>\n<h5 id=\"_1-synchronized\"> （1）synchronized</h5>\n<ol>\n<li>synchronized 的作用？</li>\n<li>说说自己是怎么使用 synchronized 关键字，在项目中用到了吗</li>\n<li>说一下 synchronized 底层实现原理？</li>\n<li>什么是自旋</li>\n<li>多线程中 synchronized 锁升级的原理是什么？</li>\n<li>线程 B 怎么知道线程 A 修改了变量</li>\n<li>当一个线程进入一个对象的 synchronized 方法 A 之后，其它线程是否可进入此对象的 synchronized 方法 B？</li>\n<li>synchronized、volatile、CAS 比较</li>\n<li>synchronized 和 Lock 有什么区别？</li>\n<li>synchronized 和 ReentrantLock 区别是什么？</li>\n</ol>\n<h5 id=\"_2-volatile\"> （2）volatile</h5>\n<ol>\n<li>volatile 关键字的作用</li>\n<li>Java 中能创建 volatile 数组吗？</li>\n<li>volatile 变量和 atomic 变量有什么不同？</li>\n<li>volatile 能使得一个非原子操作变成原子操作吗？</li>\n<li>volatile 修饰符的有过什么实践？</li>\n<li>synchronized 和 volatile 的区别是什么？</li>\n</ol>\n<h5 id=\"_3-final\"> （3）final</h5>\n<ol>\n<li>什么是不可变对象，它对写并发应用有什么帮助？</li>\n</ol>\n<h4 id=\"四-lock体系\"> （四）Lock体系</h4>\n<h5 id=\"_1-lock简介与初识aqs\"> （1）Lock简介与初识AQS</h5>\n<ol>\n<li>Java Concurrency API 中的 Lock 接口(Lock interface)是什么？对比同步它有什么优势？</li>\n<li>乐观锁和悲观锁的理解及如何实现，有哪些实现方式？</li>\n<li>什么是 CAS</li>\n<li>CAS 的会产生什么问题？</li>\n<li>什么是死锁？</li>\n<li>产生死锁的条件是什么？怎么防止死锁？</li>\n<li>死锁与活锁的区别，死锁与饥饿的区别？</li>\n<li>多线程锁的升级原理是什么？</li>\n</ol>\n<h5 id=\"_2-aqs-abstractqueuedsynchronizer-详解与源码分析\"> （2）AQS(AbstractQueuedSynchronizer)详解与源码分析</h5>\n<ol>\n<li>AQS 介绍</li>\n<li>AQS 原理分析</li>\n</ol>\n<h5 id=\"_3-reentrantlock-重入锁-实现原理与公平锁非公平锁区别\"> （3）ReentrantLock(重入锁)实现原理与公平锁非公平锁区别</h5>\n<ol>\n<li>什么是可重入锁（ReentrantLock）？</li>\n</ol>\n<h5 id=\"_4-读写锁reentrantreadwritelock源码分析\"> （4）读写锁ReentrantReadWriteLock源码分析</h5>\n<ol>\n<li>ReadWriteLock 是什么</li>\n</ol>\n<h5 id=\"_5-condition源码分析与等待通知机制\"> （5）Condition源码分析与等待通知机制</h5>\n<h5 id=\"_6-locksupport详解\"> （6）LockSupport详解</h5>\n<h4 id=\"五-并发容器\"> （五）并发容器</h4>\n<h5 id=\"_1-并发容器之concurrenthashmap详解-jdk1-8版本-与源码分析\"> （1）并发容器之ConcurrentHashMap详解(JDK1.8版本)与源码分析</h5>\n<ol>\n<li>什么是ConcurrentHashMap？</li>\n<li>Java 中 ConcurrentHashMap 的并发度是什么？</li>\n<li>什么是并发容器的实现？</li>\n<li>Java 中的同步集合与并发集合有什么区别？</li>\n<li>SynchronizedMap 和 ConcurrentHashMap 有什么区别？</li>\n</ol>\n<h5 id=\"_2-并发容器之copyonwritearraylist详解\"> （2）并发容器之CopyOnWriteArrayList详解</h5>\n<ol>\n<li>CopyOnWriteArrayList 是什么，可以用于什么应用场景？有哪些优缺点？</li>\n</ol>\n<h5 id=\"_3-并发容器之threadlocal详解\"> （3）并发容器之ThreadLocal详解</h5>\n<ol>\n<li>ThreadLocal 是什么？有哪些使用场景？</li>\n<li>什么是线程局部变量？</li>\n</ol>\n<h5 id=\"_4-threadlocal内存泄漏分析与解决方案\"> （4）ThreadLocal内存泄漏分析与解决方案</h5>\n<ol>\n<li>ThreadLocal造成内存泄漏的原因？</li>\n<li>ThreadLocal内存泄漏解决方案？</li>\n</ol>\n<h5 id=\"_5-并发容器之blockingqueue详解\"> （5）并发容器之BlockingQueue详解</h5>\n<ol>\n<li>什么是阻塞队列？阻塞队列的实现原理是什么？如何使用阻塞队列来实现生产者-消费者模型？</li>\n</ol>\n<h5 id=\"_6-并发容器之concurrentlinkedqueue详解与源码分析\"> （6）并发容器之ConcurrentLinkedQueue详解与源码分析</h5>\n<h5 id=\"_7-并发容器之arrayblockingqueue与linkedblockingqueue详解\"> （7）并发容器之ArrayBlockingQueue与LinkedBlockingQueue详解</h5>\n<h4 id=\"六-线程池\"> （六）线程池</h4>\n<h5 id=\"_1-executors类创建四种常见线程池\"> （1）Executors类创建四种常见线程池</h5>\n<ol>\n<li>什么是线程池？有哪几种创建方式？</li>\n<li>线程池有什么优点？</li>\n<li>线程池都有哪些状态？</li>\n<li>什么是 Executor 框架？为什么使用 Executor 框架？</li>\n<li>在 Java 中 Executor 和 Executors 的区别？</li>\n<li>线程池中 submit() 和 execute() 方法有什么区别？</li>\n<li>什么是线程组，为什么在 Java 中不推荐使用？</li>\n</ol>\n<h5 id=\"_2-线程池之threadpoolexecutor详解\"> （2）线程池之ThreadPoolExecutor详解</h5>\n<ol>\n<li>Executors和ThreaPoolExecutor创建线程池的区别</li>\n<li>你知道怎么创建线程池吗？</li>\n<li>ThreadPoolExecutor构造函数重要参数分析</li>\n<li>ThreadPoolExecutor饱和策略</li>\n<li>一个简单的线程池Demo:<code>Runnable</code>+<code>ThreadPoolExecutor</code></li>\n</ol>\n<h5 id=\"_3-线程池之scheduledthreadpoolexecutor详解\"> （3）线程池之ScheduledThreadPoolExecutor详解</h5>\n<h5 id=\"_4-futuretask详解\"> （4）FutureTask详解</h5>\n<h4 id=\"七-原子操作类\"> （七）原子操作类</h4>\n<ol>\n<li>什么是原子操作？在 Java Concurrency API 中有哪些原子类(atomic classes)？</li>\n<li>说一下 atomic 的原理？</li>\n</ol>\n<h4 id=\"八-并发工具\"> （八）并发工具</h4>\n<h5 id=\"_1-countdownlatch与cyclicbarrier\"> （1）CountDownLatch与CyclicBarrier</h5>\n<ol>\n<li>在 Java 中 CycliBarriar 和 CountdownLatch 有什么区别？</li>\n</ol>\n<h5 id=\"_2-semaphore与exchanger\"> （2）Semaphore与Exchanger</h5>\n<ol>\n<li>Semaphore 有什么作用</li>\n<li>什么是线程间交换数据的工具Exchanger</li>\n<li>常用的并发工具类有哪些？</li>\n</ol>\n<h3 id=\"九、jvm\"> 九、JVM</h3>\n<p>（一）JVM 的主要组成部分及其作用</p>\n<h2 id=\"参考答案\"> 参考答案：</h2>\n<h3 id=\"一、集合-容器-2\"> 一、集合/容器</h3>\n<h4 id=\"一-概述-2\"> （一）概述</h4>\n<blockquote>\n<p>1、什么是集合</p>\n</blockquote>\n<p>集合框架：<strong>用于存储数据的容器</strong>。集合框架是为表示和操作集合而规定的一种统一的标准的体系结构。</p>\n<p>任何集合框架都包含三大块内容：对外的接口、接口的实现和对集合运算的算法。</p>\n<ul>\n<li><strong>接口</strong>：表示集合的抽象数据类型。接口允许我们操作集合时不必关注具体实现，从而达到“多态”。在面向对象编程语言中，接口通常用来形成规范。</li>\n<li><strong>实现</strong>：集合接口的具体实现，是重用性很高的数据结构。</li>\n<li><strong>算法</strong>：在一个实现了某个集合框架中的接口的对象身上完成某种有用的计算的方法，例如查找、排序等。这些算法通常是多态的，因为相同的方法可以在同一个接口被多个类实现时有不同的表现。事实上，算法是可复用的函数。\n它减少了程序设计的辛劳。</li>\n</ul>\n<p><strong>设计集合的目的</strong>：</p>\n<ol>\n<li>集合框架通过提供有用的数据结构和算法使你能集中注意力于你的程序的重要部分上，而不是为了让程序能正常运转而将注意力于低层设计上。</li>\n<li>通过这些在无关API之间的简易的互用性，使你免除了为改编对象或转换代码以便联合这些API而去写大量的代码。 它提高了程序速度和质量。</li>\n</ol>\n<blockquote>\n<p>2、集合的特点</p>\n</blockquote>\n<p>集合的特点主要有如下两点：</p>\n<ul>\n<li>\n<p>对象封装数据，对象多了也需要存储。集合用于存储对象。</p>\n</li>\n<li>\n<p>对象的个数确定可以使用数组，对象的个数不确定的可以用集合。因为集合是可变长度的。</p>\n</li>\n</ul>\n<blockquote>\n<p>3、集合和数组的区别</p>\n</blockquote>\n<ul>\n<li>\n<p>数组是固定长度的；集合可变长度的。</p>\n</li>\n<li>\n<p>数组可以存储基本数据类型，也可以存储引用数据类型；集合只能存储引用数据类型。</p>\n</li>\n<li>\n<p>数组存储的元素必须是同一个数据类型；集合存储的对象可以是不同数据类型。</p>\n</li>\n</ul>\n<p><strong>数据结构</strong>：就是容器中存储数据的方式。</p>\n<p>对于集合容器，有很多种。因为每一个容器的自身特点不同，其实原理在于每个容器的内部数据结构不同。</p>\n<p>集合容器在不断向上抽取过程中，出现了集合体系。在使用一个体系的<strong>原则</strong>： <mark>参阅顶层内容。建立底层对象。</mark></p>\n<blockquote>\n<p>4、使用集合框架的好处</p>\n</blockquote>\n<ul>\n<li>容量自增长；</li>\n<li>提供了高性能的数据结构和算法，使编码更轻松，提高了程序速度和质量；</li>\n<li>允许不同 API 之间的互操作，API之间可以来回传递集合；</li>\n<li>可以方便地扩展或改写集合，提高代码复用性和可操作性。</li>\n<li>通过使用JDK自带的集合类，可以降低代码维护和学习新API成本。</li>\n</ul>\n<blockquote>\n<p>5、常用的集合类有哪些？</p>\n</blockquote>\n<p><strong>Map接口和Collection接口是所有集合框架的父接口</strong></p>\n<p><strong>Collection接口</strong>的子接口包括：<strong>Set</strong>接口和List接口</p>\n<ul>\n<li>\n<p>Set接口的实现类主要有：</p>\n<p>1、HashSet</p>\n<p>2、TreeSet</p>\n<p>3、LinkedHashSet等</p>\n</li>\n<li>\n<p>List接口的实现类主要有：</p>\n<p>1、ArrayList</p>\n<p>2、LinkedList</p>\n<p>3、Stack</p>\n<p>4、Vector等</p>\n</li>\n</ul>\n<p><strong>Map接口</strong>的实现类主要有：</p>\n<ol>\n<li>HashMap</li>\n<li>TreeMap</li>\n<li>Hashtable</li>\n<li>ConcurrentHashMap</li>\n<li>Properties</li>\n</ol>\n<p><img src=\"./assets/08.jpg\" alt=\"\"></p>\n<blockquote>\n<p>6、List，Set，Map三者的区别？List、Set、Map 是否继承自 Collection 接口？List、Map、Set 三个接口存取元素时，各有什么特点？</p>\n</blockquote>\n<p>Java 容器分为 Collection 和 Map 两大类，Collection集合的子接口有Set、List、Queue三种子接口。</p>\n<p>我们比较常用的是Set、List。Map接口不是collection的子接口。</p>\n<p><strong>Collection集合</strong>主要有List和Set两大接口</p>\n<ul>\n<li>List：一个有序（元素存入集合的顺序和取出的顺序一致）容器，元素可以重复，可以插入多个null元素，元素都有索引。常用的实现类有 ArrayList、LinkedList 和 Vector。</li>\n<li>Set：一个无序（存入和取出顺序有可能不一致）容器，不可以存储重复元素，只允许存入一个null元素，必须保证元素唯一性。Set 接口常用实现类是 HashSet、LinkedHashSet 以及 TreeSet。</li>\n</ul>\n<p><strong>Map集合</strong></p>\n<ul>\n<li>\n<p>Map没有继承于Collection接口，从Map集合中检索元素时，只要给出键对象，就会返回对应的值对象。</p>\n</li>\n<li>\n<p>Map是一个键值对集合，存储键、值和之间的映射。 Key无序，唯一；value 不要求有序，允许重复。</p>\n</li>\n<li>\n<p>Map 的常用实现类：HashMap、TreeMap、HashTable、LinkedHashMap、ConcurrentHashMap</p>\n</li>\n</ul>\n<blockquote>\n<p>7、集合框架底层数据结构</p>\n</blockquote>\n<p><strong>List接口</strong>：</p>\n<ul>\n<li>Arraylist： Object数组</li>\n<li>Vector： Object数组</li>\n<li>LinkedList： 双向循环链表</li>\n</ul>\n<p><strong>Set接口</strong>：</p>\n<ul>\n<li>HashSet（无序，唯一）：基于 HashMap 实现的，底层采用 HashMap 来保存元素</li>\n<li>LinkedHashSet： LinkedHashSet 继承与 HashSet，并且其内部是通过 LinkedHashMap 来实现的。有点类似于我们之前说的LinkedHashMap 其内部是基于 HashMap 实现一样，不过还是有一点点区别的。</li>\n<li>TreeSet（有序，唯一）： 红黑树(自平衡的排序二叉树。)</li>\n</ul>\n<p><strong>Map接口</strong>：</p>\n<ul>\n<li>\n<p>HashMap： JDK1.8之前HashMap由<strong>数组+链表</strong>组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）.JDK1.8以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间</p>\n</li>\n<li>\n<p>LinkedHashMap：LinkedHashMap 继承自 HashMap，所以它的底层仍然是基于<strong>拉链式散列结构</strong>即由数组和链表或红黑树组成。另外，LinkedHashMap 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。</p>\n</li>\n<li>\n<p>HashTable： HashTable除了实现同步外跟HashMap没什么区别，在实际应用中很少用到</p>\n</li>\n<li>\n<p>TreeMap： 红黑树（自平衡的排序二叉树）</p>\n</li>\n</ul>\n<blockquote>\n<p>8、Java集合的快速失败机制 “fail-fast”？</p>\n</blockquote>\n<p>是java集合的一种<strong>错误检测机制</strong>，当多个线程对集合进行结构上的改变的操作时，有可能会产生 fail-fast 机制。</p>\n<ul>\n<li>例如：假设存在两个线程（线程1、线程2），线程1通过Iterator在遍历集合A中的元素，在某个时候线程2修改了集合A的结构（是结构上面的修改，而不是简单的修改集合元素的内容），那么这个时候程序就会抛出 ConcurrentModificationException 异常，从而产生fail-fast机制。</li>\n<li>原因：迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个 <strong>modCount</strong> 变量。集合在被遍历期间如果内容发生变化，就会改变modCount的值。每当迭代器使用hashNext()/next()遍历下一个元素之前，都会检测modCount变量是否为expectedmodCount值，是的话就返回遍历；否则抛出异常，终止遍历。</li>\n</ul>\n<p><strong>解决办法</strong>：</p>\n<ol>\n<li>在遍历过程中，所有涉及到改变modCount值得地方全部加上synchronized。</li>\n<li>使用CopyOnWriteArrayList来替换ArrayList</li>\n</ol>\n<blockquote>\n<p>9、怎么确保一个集合不能被修改？</p>\n</blockquote>\n<p>可以使用 Collections. unmodifiableCollection(Collection c) 方法来创建一个只读集合，这样改变集合的任何操作都会抛出 Java. lang. UnsupportedOperationException 异常。</p>\n<p>示例代码如下：</p>\n<div><pre><code><span>List</span><span><span>&lt;</span><span>String</span><span>></span></span> list <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>\nlist<span>.</span> <span>add</span><span>(</span><span>\"x\"</span><span>)</span><span>;</span>\n<span>Collection</span><span><span>&lt;</span><span>String</span><span>></span></span> clist <span>=</span> <span>Collections</span><span>.</span> <span>unmodifiableCollection</span><span>(</span>list<span>)</span><span>;</span>\nclist<span>.</span> <span>add</span><span>(</span><span>\"y\"</span><span>)</span><span>;</span> <span>// 运行时此行报错</span>\n<span>System</span><span>.</span> out<span>.</span> <span>println</span><span>(</span>list<span>.</span> <span>size</span><span>(</span><span>)</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h4 id=\"二-collection接口-2\"> （二）Collection接口</h4>\n<h5 id=\"_1-list接口-2\"> （1）List接口</h5>\n<blockquote>\n<p>1、迭代器 Iterator 是什么？</p>\n</blockquote>\n<ul>\n<li>Iterator 接口提供遍历任何 Collection 接口的方法。</li>\n<li>我们可以从一个 Collection 中使用迭代器方法来获取迭代器实例。</li>\n<li>迭代器取代了 Java 集合框架中的 Enumeration，迭代器允许调用者在迭代过程中移除元素。</li>\n</ul>\n<blockquote>\n<p>2、Iterator 怎么使用？有什么特点？</p>\n</blockquote>\n<p>Iterator 使用代码如下：</p>\n<div><pre><code><span>List</span><span><span>&lt;</span><span>String</span><span>></span></span> list <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n<span>Iterator</span><span><span>&lt;</span><span>String</span><span>></span></span> it <span>=</span> list<span>.</span> <span>iterator</span><span>(</span><span>)</span><span>;</span>\n<span>while</span><span>(</span>it<span>.</span> <span>hasNext</span><span>(</span><span>)</span><span>)</span><span>{</span>\n  <span>String</span> obj <span>=</span> it<span>.</span> <span>next</span><span>(</span><span>)</span><span>;</span>\n  <span>System</span><span>.</span> out<span>.</span> <span>println</span><span>(</span>obj<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>Iterator 的特点是只能单向遍历，但是更加安全，因为它可以确保，在当前遍历的集合元素被更改的时候，就会抛出</p>\n<p>ConcurrentModificationException 异常。</p>\n<blockquote>\n<p>3、如何边遍历边移除 Collection 中的元素？</p>\n</blockquote>\n<p>边遍历边修改 Collection 的唯一正确方式是使用 Iterator.remove() 方法，如下：</p>\n<div><pre><code><span>Iterator</span><span><span>&lt;</span><span>Integer</span><span>></span></span> it <span>=</span> list<span>.</span><span>iterator</span><span>(</span><span>)</span><span>;</span>\n<span>while</span><span>(</span>it<span>.</span><span>hasNext</span><span>(</span><span>)</span><span>)</span><span>{</span>\n   <span>*</span><span>// do something*</span>\n   it<span>.</span><span>remove</span><span>(</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>一种最常见的<strong>错误</strong>代码如下：</p>\n<div><pre><code><span>for</span><span>(</span><span>Integer</span> i <span>:</span> list<span>)</span><span>{</span>\n   list<span>.</span><span>remove</span><span>(</span>i<span>)</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>运行以上错误代码会报 <strong>ConcurrentModificationException 异常</strong>。</p>\n<p>这是因为当使用 foreach(for(Integer i : list)) 语句时，会自动生成一个iterator 来遍历该 list，但同时该 list 正在被 Iterator.remove() 修</p>\n<p>改。Java 一般不允许一个线程在遍历 Collection 时另一个线程修改它。</p>\n<blockquote>\n<p>4、Iterator 和 ListIterator 有什么区别？</p>\n</blockquote>\n<ul>\n<li>Iterator 可以遍历 Set 和 List 集合，而 ListIterator 只能遍历 List。</li>\n<li>Iterator 只能单向遍历，而 ListIterator 可以双向遍历（向前/后遍历）。</li>\n<li>ListIterator 实现 Iterator 接口，然后添加了一些额外的功能，比如添加一个元素、替换一个元素、获取前面或后面元素的索引位置。</li>\n</ul>\n<blockquote>\n<p>5、遍历一个 List 有哪些不同的方式？每种方法的实现原理是什么？Java 中 List 遍历的最佳实践是什么？</p>\n</blockquote>\n<p>遍历方式有以下几种：</p>\n<ol>\n<li>for 循环遍历，基于计数器。在集合外部维护一个计数器，然后依次读取每一个位置的元素，当读取到最后一个元素后停止。</li>\n<li>迭代器遍历，Iterator。Iterator 是面向对象的一个设计模式，目的是屏蔽不同数据集合的特点，统一遍历集合的接口。Java 在 Collections 中支持了 Iterator 模式。</li>\n<li>foreach 循环遍历。foreach 内部也是采用了 Iterator 的方式实现，使用时不需要显式声明 Iterator 或计数器。优点是代码简洁，不易出错；缺点是只能做简单的遍历，不能在遍历过程中操作数据集合，例如删除、替换。</li>\n</ol>\n<p>最佳实践：Java Collections 框架中提供了一个 RandomAccess 接口，用来标记 List 实现是否支持 Random Access。</p>\n<ul>\n<li>如果一个数据集合实现了该接口，就意味着它支持 Random Access，按位置读取元素的平均时间复杂度为 O(1)，如ArrayList。</li>\n<li>如果没有实现该接口，表示不支持 Random Access，如LinkedList。</li>\n</ul>\n<p>推荐的做法就是，支持 Random Access 的列表可用 for 循环遍历，否则建议用 Iterator 或 foreach 遍历。</p>\n<blockquote>\n<p>6、说一下 ArrayList 的优缺点</p>\n</blockquote>\n<p>ArrayList的优点如下：</p>\n<ul>\n<li>ArrayList 底层以数组实现，是一种随机访问模式。ArrayList 实现了 RandomAccess 接口，因此查找的时候非常快。</li>\n<li>ArrayList 在顺序添加一个元素的时候非常方便。</li>\n</ul>\n<p>ArrayList 的缺点如下：</p>\n<ul>\n<li>删除元素的时候，需要做一次元素复制操作。如果要复制的元素很多，那么就会比较耗费性能。</li>\n<li>插入元素的时候，也需要做一次元素复制操作，缺点同上。</li>\n</ul>\n<p>ArrayList 比较适合顺序添加、随机访问的场景。</p>\n<blockquote>\n<p>7、如何实现数组和 List 之间的转换？</p>\n</blockquote>\n<ul>\n<li>数组转 List：使用 Arrays. asList(array) 进行转换。</li>\n<li>List 转数组：使用 List 自带的 toArray() 方法。</li>\n</ul>\n<p>代码示例：</p>\n<div><pre><code><span>// list to array</span>\n<span>List</span><span><span>&lt;</span><span>String</span><span>></span></span> list <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>String</span><span>></span></span><span>(</span><span>)</span><span>;</span>\nlist<span>.</span><span>add</span><span>(</span><span>\"123\"</span><span>)</span><span>;</span>\nlist<span>.</span><span>add</span><span>(</span><span>\"456\"</span><span>)</span><span>;</span>\nlist<span>.</span><span>toArray</span><span>(</span><span>)</span><span>;</span>\n\n<span>// array to list</span>\n<span>String</span><span>[</span><span>]</span> array <span>=</span> <span>new</span> <span>String</span><span>[</span><span>]</span><span>{</span><span>\"123\"</span><span>,</span><span>\"456\"</span><span>}</span><span>;</span>\n<span>Arrays</span><span>.</span><span>asList</span><span>(</span>array<span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><blockquote>\n<p>8、ArrayList 和 LinkedList 的区别是什么？</p>\n</blockquote>\n<ul>\n<li>数据结构实现：ArrayList 是动态数组的数据结构实现，而 LinkedList 是双向链表的数据结构实现。</li>\n<li>随机访问效率：ArrayList 比 LinkedList 在随机访问的时候效率要高，因为 LinkedList 是线性的数据存储方式，所以需要移动指针从前往后依次查找。</li>\n<li>增加和删除效率：在非首尾的增加和删除操作，LinkedList 要比 ArrayList 效率要高，因为 ArrayList 增删操作要影响数组内的其他数据的下标。</li>\n<li>内存空间占用：LinkedList 比 ArrayList 更占内存，因为 LinkedList 的节点除了存储数据，还存储了两个引用，一个指向前一个元素，一个指向后一个元素。</li>\n<li>线程安全：ArrayList 和 LinkedList 都是不同步的，也就是不保证线程安全；</li>\n</ul>\n<p>综合来说，在需要频繁读取集合中的元素时，更推荐使用 ArrayList，而在插入和删除操作较多时，更推荐使用 LinkedList。</p>\n<p>补充：数据结构基础之双向链表</p>\n<p>双向链表也叫双链表，是链表的一种，它的每个数据结点中都有两个指针，分别指向直接后继和直接前驱。所以，从双向链表中的任意一个结点开始，都可以很方便地访问它的前驱结点和后继结点。</p>\n<blockquote>\n<p>9、ArrayList 和 Vector 的区别是什么？</p>\n</blockquote>\n<p>这两个类都实现了 List 接口（List 接口继承了 Collection 接口），他们都是有序集合</p>\n<ul>\n<li>线程安全：Vector 使用了 Synchronized 来实现线程同步，是线程安全的，而 ArrayList 是非线程安全的。</li>\n<li>性能：ArrayList 在性能方面要优于 Vector。</li>\n<li>扩容：ArrayList 和 Vector 都会根据实际的需要动态的调整容量，只不过在 Vector 扩容每次会增加 1 倍，而 ArrayList 只会增加 50%。</li>\n</ul>\n<p>Vector类的所有方法都是同步的。可以由两个线程安全地访问一个Vector对象、但是一个线程访问Vector的话代码要在同步操作上耗费大量的时间。</p>\n<p>Arraylist不是同步的，所以在不需要保证线程安全时时建议使用Arraylist。</p>\n<blockquote>\n<p>10、插入数据时，ArrayList、LinkedList、Vector谁速度较快？阐述 ArrayList、Vector、LinkedList 的存储性能和特性？</p>\n</blockquote>\n<ul>\n<li>ArrayList、Vector 底层的实现都是使用数组方式存储数据。数组元素数大于实际存储的数据以便增加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入数据慢。</li>\n<li>Vector 中的方法由于加了 synchronized 修饰，因此 <strong>Vector</strong> <strong>是线程安全容器，但性能上较ArrayList差</strong>。</li>\n<li>LinkedList 使用双向链表实现存储，按序号索引数据需要进行前向或后向遍历，但插入数据时只需要记录当前项的前后项即可，所以 <strong>LinkedList</strong> <strong>插入速度较快</strong>。</li>\n</ul>\n<blockquote>\n<p>11、多线程场景下如何使用 ArrayList？</p>\n</blockquote>\n<p>ArrayList 不是线程安全的，如果遇到多线程场景，可以通过 Collections 的 synchronizedList 方法将其转换成线程安全的容器后再使</p>\n<p>用。例如像下面这样：</p>\n<div><pre><code><span>List</span><span><span>&lt;</span><span>String</span><span>></span></span> synchronizedList <span>=</span> <span>Collections</span><span>.</span><span>synchronizedList</span><span>(</span>list<span>)</span><span>;</span>\nsynchronizedList<span>.</span><span>add</span><span>(</span><span>\"aaa\"</span><span>)</span><span>;</span>\nsynchronizedList<span>.</span><span>add</span><span>(</span><span>\"bbb\"</span><span>)</span><span>;</span>\n\n<span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> synchronizedList<span>.</span><span>size</span><span>(</span><span>)</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>\n    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>synchronizedList<span>.</span><span>get</span><span>(</span>i<span>)</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><blockquote>\n<p>12、为什么 ArrayList 的 elementData 加上 transient 修饰？</p>\n</blockquote>\n<p>ArrayList 中的数组定义如下：</p>\n<div><pre><code><span>private</span> <span>transient</span> <span>Object</span><span>[</span><span>]</span> elementData<span>;</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>再看一下 ArrayList 的定义：</p>\n<div><pre><code><span>public</span> <span>class</span> <span>ArrayList</span><span><span>&lt;</span><span>E</span><span>></span></span> <span>extends</span> <span>AbstractList</span><span><span>&lt;</span><span>E</span><span>></span></span>\n     <span>implements</span> <span>List</span><span><span>&lt;</span><span>E</span><span>></span></span><span>,</span> <span>RandomAccess</span><span>,</span> <span>Cloneable</span><span>,</span> <span><span>java<span>.</span>io<span>.</span></span>Serializable</span>\n    \n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>可以看到 ArrayList 实现了 Serializable 接口，这意味着 ArrayList 支持序列化。transient 的作用是说不希望 elementData 数组被序列化，重写了 writeObject 实现：</p>\n<div><pre><code><span>private</span> <span>void</span> <span>writeObject</span><span>(</span><span><span>java<span>.</span>io<span>.</span></span>ObjectOutputStream</span> s<span>)</span> <span>throws</span> <span><span>java<span>.</span>io<span>.</span></span>IOException</span><span>{</span>\n    <span>*</span><span>// Write out element count, and any hidden stuff*</span>\n        <span>int</span> expectedModCount <span>=</span> modCount<span>;</span>\n    s<span>.</span><span>defaultWriteObject</span><span>(</span><span>)</span><span>;</span>\n    <span>*</span><span>// Write out array length*</span>\n        s<span>.</span><span>writeInt</span><span>(</span>elementData<span>.</span>length<span>)</span><span>;</span>\n    <span>*</span><span>// Write out all elements in the proper order.*</span>\n        <span>for</span> <span>(</span><span>int</span> i<span>=</span><span>0</span><span>;</span> i<span>&lt;</span>size<span>;</span> i<span>++</span><span>)</span>\n            s<span>.</span><span>writeObject</span><span>(</span>elementData<span>[</span>i<span>]</span><span>)</span><span>;</span>\n    <span>if</span> <span>(</span>modCount <span>!=</span> expectedModCount<span>)</span> <span>{</span>\n        <span>throw</span> <span>new</span> <span>ConcurrentModificationException</span><span>(</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>每次序列化时，先调用 defaultWriteObject() 方法序列化 ArrayList 中的非 transient 元素，然后遍历 elementData，只序列化已存入的元素，这样既加快了序列化的速度，又减小了序列化之后的文件大小。</p>\n<blockquote>\n<p>13、List 和 Set 的区别</p>\n</blockquote>\n<ul>\n<li>List , Set 都是继承自Collection 接口</li>\n<li>List 特点：一个有序（元素存入集合的顺序和取出的顺序一致）容器，元素可以重复，可以插入多个null元素，元素都有索引。常用的实现类有 ArrayList、LinkedList 和 Vector。</li>\n<li>Set 特点：一个无序（存入和取出顺序有可能不一致）容器，不可以存储重复元素，只允许存入一个null元素，必须保证元素唯一性。Set 接口常用实现类是 HashSet、LinkedHashSet 以及 TreeSet。</li>\n<li>另外 List 支持for循环，也就是通过下标来遍历，也可以用迭代器，但是set只能用迭代，因为他无序，无法用下标来取得想要的值。</li>\n<li>Set：检索元素效率低下，删除和插入效率高，插入和删除不会引起元素位置改变。List：和数组类似，List可以动态增长，查找元素效率高，插入删除元素效率低，因为会引起其他元素位置改变</li>\n</ul>\n<h5 id=\"_2-set接口-2\"> （2）Set接口</h5>\n<blockquote>\n<p>1、说一下 HashSet 的实现原理？</p>\n</blockquote>\n<p>HashSet 是基于 HashMap 实现的，HashSet的值存放于HashMap的key上，HashMap的value统一为PRESENT，因此 HashSet 的实</p>\n<p>现比较简单，相关 HashSet 的操作，基本上都是直接调用底层 HashMap 的相关方法来完成，HashSet 不允许重复的值。</p>\n<blockquote>\n<p>2、HashSet如何检查重复？HashSet是如何保证数据不可重复的？</p>\n</blockquote>\n<ul>\n<li>向HashSet 中add ()元素时，判断元素是否存在的依据，不仅要比较hash值，同时还要结合equles 方法比较。HashSet 中的add ()方法会使用HashMap 的put()方法。</li>\n<li>HashMap 的 key 是唯一的，由源码可以看出 HashSet 添加进去的值就是作为HashMap 的key，并且在HashMap中如果K/V相同时，会用新的V覆盖掉旧的V，然后返回旧的V。所以不会重复（ HashMap 比较key是否相等是先比较hashcode 再比较equals ）。</li>\n</ul>\n<p>以下是HashSet 部分源码：</p>\n<div><pre><code><span>private</span> <span>static</span> <span>final</span> <span>Object</span> PRESENT <span>=</span> <span>new</span> <span>Object</span><span>(</span><span>)</span><span>;</span>\n<span>private</span> <span>transient</span> <span>HashMap</span><span><span>&lt;</span><span>E</span><span>,</span><span>Object</span><span>></span></span> map<span>;</span>\n\n<span>public</span> <span>HashSet</span><span>(</span><span>)</span> <span>{</span>\n    map <span>=</span> <span>new</span> <span>HashMap</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n<span>}</span>\n\n<span>public</span> <span>boolean</span> <span>add</span><span>(</span><span>E</span> e<span>)</span> <span>{</span>\n    <span>// 调用HashMap的put方法,PRESENT是一个至始至终都相同的虚值</span>\n\t<span>return</span> map<span>.</span><span>put</span><span>(</span>e<span>,</span> PRESENT<span>)</span><span>==</span><span>null</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p><strong>hashCode（）与equals（）的相关规定</strong>：</p>\n<ol>\n<li>如果两个对象相等，则hashcode一定也是相同的</li>\n<li>两个对象相等,对两个equals方法返回true</li>\n<li>两个对象有相同的hashcode值，它们也不一定是相等的</li>\n<li>综上，equals方法被覆盖过，则hashCode方法也必须被覆盖</li>\n<li>hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写hashCode()，则该class的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）。</li>\n</ol>\n<p><strong>==与equals的区别</strong></p>\n<ol>\n<li>==是判断两个变量或实例是不是指向同一个内存空间 equals是判断两个变量或实例所指向的内存空间的值是不是相同</li>\n<li>==是指对内存地址进行比较 equals()是对字符串的内容进行比较</li>\n<li>==指引用是否相同 equals()指的是值是否相同</li>\n</ol>\n<blockquote>\n<p>3、HashSet与HashMap的区别</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>HashMap</th>\n<th>HashSet</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>实现了Map接口</td>\n<td>实现Set接口</td>\n</tr>\n<tr>\n<td>存储键值对</td>\n<td>仅存储对象</td>\n</tr>\n<tr>\n<td>调用put（）向map中添加元素</td>\n<td>调用add（）方法向Set中添加元素</td>\n</tr>\n<tr>\n<td>HashMap使用键（Key）计算Hashcode</td>\n<td>HashSet使用成员对象来计算hashcode值，对于两个对象来说hashcode可能相同，所以equals()方法用来判断对象的相等性，如果两个对象不同的话，那么返回false</td>\n</tr>\n<tr>\n<td>HashMap相对于HashSet较快，因为它是使用唯一的键获取对象</td>\n<td>HashSet较HashMap来说比较慢</td>\n</tr>\n</tbody>\n</table>\n<h5 id=\"_3-queue\"> （3）Queue</h5>\n<blockquote>\n<p>1、BlockingQueue是什么？</p>\n</blockquote>\n<p>Java.util.concurrent.BlockingQueue是一个队列，在进行检索或移除一个元素的时候，它会等待队列变为非空；当在添加一个元素时，它会等待队列中的可用空间。</p>\n<p>BlockingQueue接口是Java集合框架的一部分，主要用于<strong>实现生产者-消费者模式</strong>。我们不需要担心等待生产者有可用的空间，或消费者有可用的对象，因为它都在BlockingQueue的实现类中被处理了。Java提供了几种BlockingQueue的实现，比如ArrayBlockingQueue、LinkedBlockingQueue、PriorityBlockingQueue,、SynchronousQueue等。</p>\n<blockquote>\n<p>2、在 Queue 中 poll()和 remove()有什么区别？</p>\n</blockquote>\n<ul>\n<li>相同点：都是返回第一个元素，并在队列中删除返回的对象。</li>\n<li>不同点：如果没有元素 poll()会返回 null，而 remove()会直接抛出 NoSuchElementException 异常。</li>\n</ul>\n<p>代码示例：</p>\n<div><pre><code><span>Queue</span><span><span>&lt;</span><span>String</span><span>></span></span> queue <span>=</span> <span>new</span> <span>LinkedList</span><span><span>&lt;</span><span>String</span><span>></span></span><span>(</span><span>)</span><span>;</span>\nqueue<span>.</span> <span>offer</span><span>(</span><span>\"string\"</span><span>)</span><span>;</span> <span>// add</span>\n<span>System</span><span>.</span> out<span>.</span> <span>println</span><span>(</span>queue<span>.</span> <span>poll</span><span>(</span><span>)</span><span>)</span><span>;</span>\n<span>System</span><span>.</span> out<span>.</span> <span>println</span><span>(</span>queue<span>.</span> <span>remove</span><span>(</span><span>)</span><span>)</span><span>;</span>\n<span>System</span><span>.</span> out<span>.</span> <span>println</span><span>(</span>queue<span>.</span> <span>size</span><span>(</span><span>)</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h4 id=\"三-map接口-2\"> （三）Map接口</h4>\n<blockquote>\n<p>1、说一下 HashMap 的实现原理？</p>\n</blockquote>\n<p>HashMap概述： HashMap是基于哈希表的Map接口的非同步实现。此实现提供所有可选的映射操作，并允许使用null值和null键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。</p>\n<p>HashMap的数据结构： 在Java编程语言中，最基本的结构就是两种，一个是数组，另外一个是模拟指针（引用），所有的数据结构都可以用这两个基本结构来构造的，HashMap也不例外。HashMap实际上是一个“链表散列”的数据结构，即数组和链表的结合体。</p>\n<p>HashMap 基于 Hash 算法实现的</p>\n<ol>\n<li>\n<p>当我们往HashMap中put元素时，利用key的hashCode重新hash，计算出当前对象的元素在数组中的下标</p>\n</li>\n<li>\n<p>存储时，如果出现hash值相同的key，此时有两种情况。</p>\n<p>(1)如果key相同，则覆盖原始值；</p>\n<p>(2)如果key不同（出现冲突），则将当前的key-value放入链表中</p>\n</li>\n<li>\n<p>获取时，直接找到hash值对应的下标，在进一步判断key是否相同，从而找到对应值。</p>\n</li>\n<li>\n<p>理解了以上过程就不难明白HashMap是如何解决hash冲突的问题，核心就是使用了数组的存储方式，然后将冲突的key的对象放入链表中，一旦发现冲突就在链表中做进一步的对比。</p>\n</li>\n</ol>\n<p>需要注意<strong>Jdk 1.8中对HashMap的实现做了优化</strong>： <mark>当链表中的节点数据超过八个之后，该链表会转为红黑树来提高查询效率，从原来的O(n)到O(logn)</mark></p>\n<blockquote>\n<p>2、HashMap在JDK1.7和JDK1.8中有哪些不同？HashMap的底层实现</p>\n</blockquote>\n<p>在Java中，保存数据有两种比较简单的数据结构：数组和链表。数组的特点是：寻址容易，插入和删除困难；链表的特点是：寻址困难，但插入和删除容易；所以我们将数组和链表结合在一起，发挥两者各自的优势，使用一种叫做<strong>拉链法</strong>的方式可以解决哈希冲突。</p>\n<p><strong>（1）JDK1.8之前</strong></p>\n<p>JDK1.8之前采用的是拉链法。<strong>拉链法</strong>：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。</p>\n<p><img src=\"./assets/09.png\" alt=\"jdk1.7中HashMap数据结构\"></p>\n<p><strong>（2）JDK1.8之后</strong></p>\n<p>相比于之前的版本，jdk1.8在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。</p>\n<p><img src=\"./assets/10.png\" alt=\"jdk1.8中HashMap数据结构\"></p>\n<p><strong>（3）JDK1.7 VS JDK1.8</strong></p>\n<p>JDK1.8主要解决或优化了一下问题：</p>\n<ol>\n<li>resize 扩容优化</li>\n<li>引入了红黑树，目的是避免单条链表过长而影响查询效率，<a href=\"\">红黑树算法</a></li>\n<li>解决了多线程死循环问题，但仍是非线程安全的，多线程时可能会造成数据丢失问题。</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>不同</th>\n<th>JDK 1.7</th>\n<th>JDK 1.8</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>存储结构</td>\n<td>数组 + 链表</td>\n<td>数组 + 链表 + 红黑树</td>\n</tr>\n<tr>\n<td>初始化方式</td>\n<td>单独函数：<code>inflateTable()</code></td>\n<td>直接集成到了扩容函数<code>resize()</code>中</td>\n</tr>\n<tr>\n<td>hash值计算方式</td>\n<td>扰动处理 = 9次扰动 = 4次位运算 + 5次异或运算</td>\n<td>扰动处理 = 2次扰动 = 1次位运算 + 1次异或运算</td>\n</tr>\n<tr>\n<td>存放数据的规则</td>\n<td>无冲突时，存放数组；冲突时，存放链表</td>\n<td>无冲突时，存放数组；冲突 &amp; 链表长度 &lt; 8：存放单链表；冲突 &amp; 链表长度 &gt; 8：树化并存放红黑树</td>\n</tr>\n<tr>\n<td>插入数据方式</td>\n<td>头插法（先讲原位置的数据移到后1位，再插入数据到该位置）</td>\n<td>尾插法（直接插入到链表尾部/红黑树）</td>\n</tr>\n<tr>\n<td>扩容后存储位置的计算方式</td>\n<td>全部按照原来方法进行计算（即hashCode -&gt;&gt; 扰动函数 -&gt;&gt; (h&amp;length-1)）</td>\n<td>按照扩容后的规律计算（即扩容后的位置=原位置 or 原位置 + 旧容量）</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>3、HashMap的put方法的具体流程？</p>\n</blockquote>\n<p>当我们put的时候，首先计算 <code>key</code>的<code>hash</code>值，这里调用了 <code>hash</code>方法，<code>hash</code>方法实际是让<code>key.hashCode()</code>与<code>key.hashCode()&gt;&gt;&gt;16</code>进行异或操作，高16bit补0，一个数和0异或不变，所以 hash 函数大概的作用就是：<strong>高16bit不变，低16bit和高16bit做了一个异或，目的是减少碰撞</strong>。按照函数注释，因为bucket数组大小是2的幂，计算下标<code>index = (table.length - 1) &amp; hash</code>，如果不做 hash 处理，相当于散列生效的只有几个低 bit 位，为了减少散列的碰撞，设计者综合考虑了速度、作用、质量之后，使用高16bit和低16bit异或来简单处理减少碰撞，而且JDK8中用了复杂度 O（logn）的树结构来提升碰撞下的性能。</p>\n<p>putVal方法执行流程图</p>\n<p><img src=\"./assets/11.png\" alt=\"putVal方法执行流程图\"></p>\n<div><pre><code><span>public</span> <span>V</span> <span>put</span><span>(</span><span>K</span> key<span>,</span> <span>V</span> value<span>)</span> <span>{</span>\n    <span>return</span> <span>putVal</span><span>(</span><span>hash</span><span>(</span>key<span>)</span><span>,</span> key<span>,</span> value<span>,</span> <span>false</span><span>,</span> <span>true</span><span>)</span><span>;</span>\n<span>}</span>\n\n<span>static</span> <span>final</span> <span>int</span> <span>hash</span><span>(</span><span>Object</span> key<span>)</span> <span>{</span>\n    <span>int</span> h<span>;</span>\n    <span>return</span> <span>(</span>key <span>==</span> <span>null</span><span>)</span> <span>?</span> <span>0</span> <span>:</span> <span>(</span>h <span>=</span> key<span>.</span><span>hashCode</span><span>(</span><span>)</span><span>)</span> <span>^</span> <span>(</span>h <span>>>></span> <span>16</span><span>)</span><span>;</span>\n<span>}</span>\n\n<span>//实现Map.put和相关方法</span>\n<span>final</span> <span>V</span> <span>putVal</span><span>(</span><span>int</span> hash<span>,</span> <span>K</span> key<span>,</span> <span>V</span> value<span>,</span> <span>boolean</span> onlyIfAbsent<span>,</span>\n                   <span>boolean</span> evict<span>)</span> <span>{</span>\n    <span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span><span>[</span><span>]</span> tab<span>;</span> <span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> p<span>;</span> <span>int</span> n<span>,</span> i<span>;</span>\n    <span>// 步骤①：tab为空则创建 </span>\n    <span>// table未初始化或者长度为0，进行扩容</span>\n    <span>if</span> <span>(</span><span>(</span>tab <span>=</span> table<span>)</span> <span>==</span> <span>null</span> <span>||</span> <span>(</span>n <span>=</span> tab<span>.</span>length<span>)</span> <span>==</span> <span>0</span><span>)</span>\n        n <span>=</span> <span>(</span>tab <span>=</span> <span>resize</span><span>(</span><span>)</span><span>)</span><span>.</span>length<span>;</span>\n    <span>// 步骤②：计算index，并对null做处理  </span>\n    <span>// (n - 1) &amp; hash 确定元素存放在哪个桶中(相当于取余)，桶为空，新生成结点放入桶中(此时，这个结点是放在数组中)</span>\n    <span>if</span> <span>(</span><span>(</span>p <span>=</span> tab<span>[</span>i <span>=</span> <span>(</span>n <span>-</span> <span>1</span><span>)</span> <span>&amp;</span> hash<span>]</span><span>)</span> <span>==</span> <span>null</span><span>)</span>\n        tab<span>[</span>i<span>]</span> <span>=</span> <span>newNode</span><span>(</span>hash<span>,</span> key<span>,</span> value<span>,</span> <span>null</span><span>)</span><span>;</span>\n    <span>// 桶中已经存在元素</span>\n    <span>else</span> <span>{</span>\n        <span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> e<span>;</span> <span>K</span> k<span>;</span>\n        <span>// 步骤③：节点key存在，直接覆盖value </span>\n        <span>// 比较桶中第一个元素(数组中的结点)的hash值相等，key相等</span>\n        <span>if</span> <span>(</span>p<span>.</span>hash <span>==</span> hash <span>&amp;&amp;</span>\n            <span>(</span><span>(</span>k <span>=</span> p<span>.</span>key<span>)</span> <span>==</span> key <span>||</span> <span>(</span>key <span>!=</span> <span>null</span> <span>&amp;&amp;</span> key<span>.</span><span>equals</span><span>(</span>k<span>)</span><span>)</span><span>)</span><span>)</span>\n                <span>// 将第一个元素赋值给e，用e来记录</span>\n                e <span>=</span> p<span>;</span>\n        <span>// 步骤④：判断该链为红黑树 </span>\n        <span>// hash值不相等，即key不相等；为红黑树结点</span>\n        <span>// 如果当前元素类型为TreeNode，表示为红黑树，putTreeVal返回待存放的node, e可能为null</span>\n        <span>else</span> <span>if</span> <span>(</span>p <span>instanceof</span> <span>TreeNode</span><span>)</span>\n            <span>// 放入树中</span>\n            e <span>=</span> <span>(</span><span>(</span><span>TreeNode</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span><span>)</span>p<span>)</span><span>.</span><span>putTreeVal</span><span>(</span><span>this</span><span>,</span> tab<span>,</span> hash<span>,</span> key<span>,</span> value<span>)</span><span>;</span>\n        <span>// 步骤⑤：该链为链表 </span>\n        <span>// 为链表结点</span>\n        <span>else</span> <span>{</span>\n            <span>// 在链表最末插入结点</span>\n            <span>for</span> <span>(</span><span>int</span> binCount <span>=</span> <span>0</span><span>;</span> <span>;</span> <span>++</span>binCount<span>)</span> <span>{</span>\n                <span>// 到达链表的尾部</span>\n                \n                <span>//判断该链表尾部指针是不是空的</span>\n                <span>if</span> <span>(</span><span>(</span>e <span>=</span> p<span>.</span>next<span>)</span> <span>==</span> <span>null</span><span>)</span> <span>{</span>\n                    <span>// 在尾部插入新结点</span>\n                    p<span>.</span>next <span>=</span> <span>newNode</span><span>(</span>hash<span>,</span> key<span>,</span> value<span>,</span> <span>null</span><span>)</span><span>;</span>\n                    <span>//判断链表的长度是否达到转化红黑树的临界值，临界值为8</span>\n                    <span>if</span> <span>(</span>binCount <span>>=</span> TREEIFY_THRESHOLD <span>-</span> <span>1</span><span>)</span> <span>// -1 for 1st</span>\n                        <span>//链表结构转树形结构</span>\n                        <span>treeifyBin</span><span>(</span>tab<span>,</span> hash<span>)</span><span>;</span>\n                    <span>// 跳出循环</span>\n                    <span>break</span><span>;</span>\n                <span>}</span>\n                <span>// 判断链表中结点的key值与插入的元素的key值是否相等</span>\n                <span>if</span> <span>(</span>e<span>.</span>hash <span>==</span> hash <span>&amp;&amp;</span>\n                    <span>(</span><span>(</span>k <span>=</span> e<span>.</span>key<span>)</span> <span>==</span> key <span>||</span> <span>(</span>key <span>!=</span> <span>null</span> <span>&amp;&amp;</span> key<span>.</span><span>equals</span><span>(</span>k<span>)</span><span>)</span><span>)</span><span>)</span>\n                    <span>// 相等，跳出循环</span>\n                    <span>break</span><span>;</span>\n                <span>// 用于遍历桶中的链表，与前面的e = p.next组合，可以遍历链表</span>\n                p <span>=</span> e<span>;</span>\n            <span>}</span>\n        <span>}</span>\n        <span>//判断当前的key已经存在的情况下，再来一个相同的hash值、key值时，返回新来的value这个值</span>\n        <span>if</span> <span>(</span>e <span>!=</span> <span>null</span><span>)</span> <span>{</span> \n            <span>// 记录e的value</span>\n            <span>V</span> oldValue <span>=</span> e<span>.</span>value<span>;</span>\n            <span>// onlyIfAbsent为false或者旧值为null</span>\n            <span>if</span> <span>(</span><span>!</span>onlyIfAbsent <span>||</span> oldValue <span>==</span> <span>null</span><span>)</span>\n                <span>//用新值替换旧值</span>\n                e<span>.</span>value <span>=</span> value<span>;</span>\n            <span>// 访问后回调</span>\n            <span>afterNodeAccess</span><span>(</span>e<span>)</span><span>;</span>\n            <span>// 返回旧值</span>\n            <span>return</span> oldValue<span>;</span>\n        <span>}</span>\n    <span>}</span>\n    <span>// 结构性修改</span>\n    <span>++</span>modCount<span>;</span>\n    <span>// 步骤⑥：超过最大容量就扩容 </span>\n    <span>// 实际大小大于阈值则扩容</span>\n    <span>if</span> <span>(</span><span>++</span>size <span>></span> threshold<span>)</span>\n        <span>resize</span><span>(</span><span>)</span><span>;</span>\n    <span>// 插入后回调</span>\n    <span>afterNodeInsertion</span><span>(</span>evict<span>)</span><span>;</span>\n    <span>return</span> <span>null</span><span>;</span>\n<span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br></div></div><p>①.判断键值对数组table[i]是否为空或为null，否则执行resize()进行扩容；</p>\n<p>②.根据键值key计算hash值得到插入的数组索引i，如果table[i]==null，直接新建节点添加，转向⑥，如果table[i]不为空，转向③；</p>\n<p>③.判断table[i]的首个元素是否和key一样，如果相同直接覆盖value，否则转向④，这里的相同指的是hashCode以及equals；</p>\n<p>④.判断table[i] 是否为treeNode，即table[i] 是否是红黑树，如果是红黑树，则直接在树中插入键值对，否则转向⑤；</p>\n<p>⑤.遍历table[i]，判断链表长度是否大于8，大于8的话把链表转换为红黑树，在红黑树中执行插入操作，否则进行链表的插入操作；遍历过程中若发现key已经存在直接覆盖value即可；</p>\n<p>⑥.插入成功后，判断实际存在的键值对数量size是否超多了最大容量threshold，如果超过，进行扩容。</p>\n<blockquote>\n<p>4、HashMap的扩容操作是怎么实现的？</p>\n</blockquote>\n<p>①.在jdk1.8中，resize()方法是在hashmap中的键值对大于阀值时或者初始化时，就调用resize()方法进行扩容；</p>\n<p>②.每次扩展的时候，都是扩展2倍；</p>\n<p>③.扩展后Node对象的位置要么在原位置，要么移动到原偏移量两倍的位置。</p>\n<p>在putVal()中，我们看到在这个函数里面使用到了2次resize()方法，resize()方法表示的在进行第一次<strong>初始化时</strong>会对其进行扩容，或者当该<strong>数组的实际大小大于其临界值值(第一次为12),</strong></p>\n<p>这个时候在扩容的同时也会伴随的桶上面的元素进行重新分发，这也是JDK1.8版本的一个优化的地方，</p>\n<ul>\n<li>在1.7中，扩容之后需要重新去计算其Hash值，根据Hash值对其进行分发</li>\n<li>但在1.8版本中，则是根据在同一个桶的位置中进行判断(e.hash &amp; oldCap)是否为0，重新进行hash分配后，该元素的位置要么停留在原始位置，要么移动到原始位置+增加的数组大小这个位置上</li>\n</ul>\n<div><pre><code><span>final</span> <span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span><span>[</span><span>]</span> <span>resize</span><span>(</span><span>)</span> <span>{</span>\n    <span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span><span>[</span><span>]</span> oldTab <span>=</span> table<span>;</span><span>//oldTab指向hash桶数组</span>\n    <span>int</span> oldCap <span>=</span> <span>(</span>oldTab <span>==</span> <span>null</span><span>)</span> <span>?</span> <span>0</span> <span>:</span> oldTab<span>.</span>length<span>;</span>\n    <span>int</span> oldThr <span>=</span> threshold<span>;</span>\n    <span>int</span> newCap<span>,</span> newThr <span>=</span> <span>0</span><span>;</span>\n    <span>if</span> <span>(</span>oldCap <span>></span> <span>0</span><span>)</span> <span>{</span><span>//如果oldCap不为空的话，就是hash桶数组不为空</span>\n        <span>if</span> <span>(</span>oldCap <span>>=</span> MAXIMUM_CAPACITY<span>)</span> <span>{</span><span>//如果大于最大容量了，就赋值为整数最大的阀值</span>\n            threshold <span>=</span> <span>Integer</span><span>.</span>MAX_VALUE<span>;</span>\n            <span>return</span> oldTab<span>;</span><span>//返回</span>\n        <span>}</span><span>//如果当前hash桶数组的长度在扩容后仍然小于最大容量 并且oldCap大于默认值16</span>\n        <span>else</span> <span>if</span> <span>(</span><span>(</span>newCap <span>=</span> oldCap <span>&lt;&lt;</span> <span>1</span><span>)</span> <span><span>&lt;</span> MAXIMUM_CAPACITY <span>&amp;</span><span>&amp;</span>\n                 oldCap <span>></span></span><span>=</span> DEFAULT_INITIAL_CAPACITY<span>)</span>\n            newThr <span>=</span> oldThr <span>&lt;&lt;</span> <span>1</span><span>;</span> <span>// double threshold 双倍扩容阀值threshold</span>\n    <span>}</span>\n    <span>// 旧的容量为0，但threshold大于零，代表有参构造有cap传入，threshold已经被初始化成最小2的n次幂</span>\n    <span>// 直接将该值赋给新的容量</span>\n    <span>else</span> <span>if</span> <span>(</span>oldThr <span>></span> <span>0</span><span>)</span> <span>// initial capacity was placed in threshold</span>\n        newCap <span>=</span> oldThr<span>;</span>\n    <span>// 无参构造创建的map，给出默认容量和threshold 16, 16*0.75</span>\n    <span>else</span> <span>{</span>               <span>// zero initial threshold signifies using defaults</span>\n        newCap <span>=</span> DEFAULT_INITIAL_CAPACITY<span>;</span>\n        newThr <span>=</span> <span>(</span><span>int</span><span>)</span><span>(</span>DEFAULT_LOAD_FACTOR <span>*</span> DEFAULT_INITIAL_CAPACITY<span>)</span><span>;</span>\n    <span>}</span>\n    <span>// 新的threshold = 新的cap * 0.75</span>\n    <span>if</span> <span>(</span>newThr <span>==</span> <span>0</span><span>)</span> <span>{</span>\n        <span>float</span> ft <span>=</span> <span>(</span><span>float</span><span>)</span>newCap <span>*</span> loadFactor<span>;</span>\n        newThr <span>=</span> <span>(</span>newCap <span>&lt;</span> MAXIMUM_CAPACITY <span>&amp;&amp;</span> ft <span>&lt;</span> <span>(</span><span>float</span><span>)</span>MAXIMUM_CAPACITY <span>?</span>\n                  <span>(</span><span>int</span><span>)</span>ft <span>:</span> <span>Integer</span><span>.</span>MAX_VALUE<span>)</span><span>;</span>\n    <span>}</span>\n    threshold <span>=</span> newThr<span>;</span>\n    <span>// 计算出新的数组长度后赋给当前成员变量table</span>\n    <span>@SuppressWarnings</span><span>(</span><span>{</span><span>\"rawtypes\"</span><span>,</span><span>\"unchecked\"</span><span>}</span><span>)</span>\n        <span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span><span>[</span><span>]</span> newTab <span>=</span> <span>(</span><span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span><span>[</span><span>]</span><span>)</span><span>new</span> <span>Node</span><span>[</span>newCap<span>]</span><span>;</span><span>//新建hash桶数组</span>\n    table <span>=</span> newTab<span>;</span><span>//将新数组的值复制给旧的hash桶数组</span>\n    <span>// 如果原先的数组没有初始化，那么resize的初始化工作到此结束，否则进入扩容元素重排逻辑，使其均匀的分散</span>\n    <span>if</span> <span>(</span>oldTab <span>!=</span> <span>null</span><span>)</span> <span>{</span>\n        <span>// 遍历新数组的所有桶下标</span>\n        <span>for</span> <span>(</span><span>int</span> j <span>=</span> <span>0</span><span>;</span> j <span>&lt;</span> oldCap<span>;</span> <span>++</span>j<span>)</span> <span>{</span>\n            <span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> e<span>;</span>\n            <span>if</span> <span>(</span><span>(</span>e <span>=</span> oldTab<span>[</span>j<span>]</span><span>)</span> <span>!=</span> <span>null</span><span>)</span> <span>{</span>\n                <span>// 旧数组的桶下标赋给临时变量e，并且解除旧数组中的引用，否则就数组无法被GC回收</span>\n                oldTab<span>[</span>j<span>]</span> <span>=</span> <span>null</span><span>;</span>\n                <span>// 如果e.next==null，代表桶中就一个元素，不存在链表或者红黑树</span>\n                <span>if</span> <span>(</span>e<span>.</span>next <span>==</span> <span>null</span><span>)</span>\n                    <span>// 用同样的hash映射算法把该元素加入新的数组</span>\n                    newTab<span>[</span>e<span>.</span>hash <span>&amp;</span> <span>(</span>newCap <span>-</span> <span>1</span><span>)</span><span>]</span> <span>=</span> e<span>;</span>\n                <span>// 如果e是TreeNode并且e.next!=null，那么处理树中元素的重排</span>\n                <span>else</span> <span>if</span> <span>(</span>e <span>instanceof</span> <span>TreeNode</span><span>)</span>\n                    <span>(</span><span>(</span><span>TreeNode</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span><span>)</span>e<span>)</span><span>.</span><span>split</span><span>(</span><span>this</span><span>,</span> newTab<span>,</span> j<span>,</span> oldCap<span>)</span><span>;</span>\n                <span>// e是链表的头并且e.next!=null，那么处理链表中元素重排</span>\n                <span>else</span> <span>{</span> <span>// preserve order</span>\n                    <span>// loHead,loTail 代表扩容后不用变换下标，见注1</span>\n                    <span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> loHead <span>=</span> <span>null</span><span>,</span> loTail <span>=</span> <span>null</span><span>;</span>\n                    <span>// hiHead,hiTail 代表扩容后变换下标，见注1</span>\n                    <span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> hiHead <span>=</span> <span>null</span><span>,</span> hiTail <span>=</span> <span>null</span><span>;</span>\n                    <span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> next<span>;</span>\n                    <span>// 遍历链表</span>\n                    <span>do</span> <span>{</span>             \n                        next <span>=</span> e<span>.</span>next<span>;</span>\n                        <span>if</span> <span>(</span><span>(</span>e<span>.</span>hash <span>&amp;</span> oldCap<span>)</span> <span>==</span> <span>0</span><span>)</span> <span>{</span>\n                            <span>if</span> <span>(</span>loTail <span>==</span> <span>null</span><span>)</span>\n                                <span>// 初始化head指向链表当前元素e，e不一定是链表的第一个元素，初始化后loHead</span>\n                                <span>// 代表下标保持不变的链表的头元素</span>\n                                loHead <span>=</span> e<span>;</span>\n                            <span>else</span>                                \n                                <span>// loTail.next指向当前e</span>\n                                loTail<span>.</span>next <span>=</span> e<span>;</span>\n                            <span>// loTail指向当前的元素e</span>\n                            <span>// 初始化后，loTail和loHead指向相同的内存，所以当loTail.next指向下一个元素时，</span>\n                            <span>// 底层数组中的元素的next引用也相应发生变化，造成lowHead.next.next.....</span>\n                            <span>// 跟随loTail同步，使得lowHead可以链接到所有属于该链表的元素。</span>\n                            loTail <span>=</span> e<span>;</span>                           \n                        <span>}</span>\n                        <span>else</span> <span>{</span>\n                            <span>if</span> <span>(</span>hiTail <span>==</span> <span>null</span><span>)</span>\n                                <span>// 初始化head指向链表当前元素e, 初始化后hiHead代表下标更改的链表头元素</span>\n                                hiHead <span>=</span> e<span>;</span>\n                            <span>else</span>\n                                hiTail<span>.</span>next <span>=</span> e<span>;</span>\n                            hiTail <span>=</span> e<span>;</span>\n                        <span>}</span>\n                    <span>}</span> <span>while</span> <span>(</span><span>(</span>e <span>=</span> next<span>)</span> <span>!=</span> <span>null</span><span>)</span><span>;</span>\n                    <span>// 遍历结束, 将tail指向null，并把链表头放入新数组的相应下标，形成新的映射。</span>\n                    <span>if</span> <span>(</span>loTail <span>!=</span> <span>null</span><span>)</span> <span>{</span>\n                        loTail<span>.</span>next <span>=</span> <span>null</span><span>;</span>\n                        newTab<span>[</span>j<span>]</span> <span>=</span> loHead<span>;</span>\n                    <span>}</span>\n                    <span>if</span> <span>(</span>hiTail <span>!=</span> <span>null</span><span>)</span> <span>{</span>\n                        hiTail<span>.</span>next <span>=</span> <span>null</span><span>;</span>\n                        newTab<span>[</span>j <span>+</span> oldCap<span>]</span> <span>=</span> hiHead<span>;</span>\n                    <span>}</span>\n                <span>}</span>\n            <span>}</span>\n        <span>}</span>\n    <span>}</span>\n    <span>return</span> newTab<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br><span>96</span><br><span>97</span><br></div></div><blockquote>\n<p>5、HashMap是怎么解决哈希冲突的？</p>\n</blockquote>\n<p>在解决这个问题之前，我们首先需要知道<strong>什么是哈希冲突</strong>，而在了解哈希冲突之前我们还要知道<strong>什么是哈希</strong>才行；</p>\n<p><strong>（1）什么是哈希？</strong></p>\n<p>Hash，一般翻译为“散列”，也有直接音译为“哈希”的，这就是把任意长度的输入通过散列算法，变换成固定长度的输出，该输出就是散列值（哈希值）；这种转换是一种压缩映射，也就是，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，所以不可能从散列值来唯一的确定输入值。<strong>简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数</strong>。</p>\n<p>所有散列函数都有如下一个基本特性：<strong>一定不同根据同一散列函数计算出的散列值如果不同，那么输入值肯定也不同；输入值不同，根据同一散列函数计算出的散列值可能相同</strong>。</p>\n<p><strong>（2）什么是哈希冲突？</strong></p>\n<p>当两个不同的输入值，根据同一散列函数计算出相同的散列值的现象，我们就把它叫做碰撞（哈希碰撞）。</p>\n<p><strong>（3）HashMap的数据结构</strong></p>\n<p>HashMap使用一种叫做<strong>链地址法</strong>的方式可以解决哈希冲突：</p>\n<p><img src=\"./assets/12.png\" alt=\"image-20210115113459601\"></p>\n<p>这样我们就可以将拥有相同哈希值的对象组织成一个链表放在hash值所对应的bucket下， <strong>但相比于hashCode返回的int类型，我们HashMap初始的容量大小<code>DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4</code>（即2的四次方16）要远小于int类型的范围，所以我们如果只是单纯的用hashCode取余来获取对应的bucket这将会大大增加哈希碰撞的概率，并且最坏情况下还会将HashMap变成一个单链表，所以我们还需要对hashCode作一定的优化</strong></p>\n<p><strong>（4）hash()函数</strong></p>\n<p>上面提到的问题，主要是因为如果使用hashCode取余，那么相当于<strong>参与运算的只有hashCode的低位</strong>，高位是没有起到任何作用的，所以我们的思路就是让hashCode取值出的高位也参与运算，进一步降低hash碰撞的概率，使得数据分布更平均，我们把这样的操作称为<strong>扰动</strong>，在<strong>JDK 1.8</strong>中的hash()函数如下：</p>\n<div><pre><code><span>static</span> <span>final</span> <span>int</span> <span>hash</span><span>(</span><span>Object</span> key<span>)</span> <span>{</span>\n    <span>int</span> h<span>;</span>\n    <span>return</span> <span>(</span>key <span>==</span> <span>null</span><span>)</span> <span>?</span> <span>0</span> <span>:</span> <span>(</span>h <span>=</span> key<span>.</span><span>hashCode</span><span>(</span><span>)</span><span>)</span> <span>^</span> <span>(</span>h <span>>>></span> <span>16</span><span>)</span><span>;</span><span>// 与自己右移16位进行异或运算（高低位异或）</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>这比在<strong>JDK 1.7</strong>中，更为简洁，<strong>相比在1.7中的4次位运算，5次异或运算（9次扰动），在1.8中，只进行了1次位运算和1次异或运算（2次扰动）</strong>；</p>\n<p><strong>（5）JDK1.8新增红黑树</strong></p>\n<p><img src=\"./assets/13.png\" alt=\"img\"></p>\n<p>通过上面的<strong>链地址法（使用散列表）<strong>和</strong>扰动函数</strong>我们成功让我们的数据分布更平均，哈希碰撞减少，但是当我们的HashMap中存在大量数据时，加入我们某个bucket下对应的链表有n个元素，那么遍历时间复杂度就为O(n)，为了针对这个问题，JDK1.8在HashMap中新增了红黑树的数据结构，进一步使得遍历复杂度降低至O(logn)；</p>\n<p><strong>（4）总结</strong></p>\n<p>简单总结一下HashMap是使用了哪些方法来有效解决哈希冲突的：</p>\n<ol>\n<li>\n<p>使用链地址法（使用散列表）来链接拥有相同hash值的数据；</p>\n</li>\n<li>\n<p>使用2次扰动函数（hash函数）来降低哈希冲突的概率，使得数据分布更平均；</p>\n</li>\n<li>\n<p>引入红黑树进一步降低遍历的时间复杂度，使得遍历更快；</p>\n</li>\n</ol>\n<blockquote>\n<p>6、能否使用任何类作为Map的 key？</p>\n</blockquote>\n<p><strong>可以，</strong> 然而在使用之前，需要考虑以下几点：</p>\n<ul>\n<li>如果类重写了 equals() 方法，也应该重写 hashCode() 方法。</li>\n<li>类的所有实例需要遵循与 equals() 和 hashCode() 相关的规则。</li>\n<li>如果一个类没有使用 equals()，不应该在 hashCode() 中使用它。</li>\n<li>用户自定义 Key 类最佳实践是使之为不可变的，这样 hashCode() 值可以被缓存起来，拥有更好的性能。不可变的类也可以确保 hashCode() 和 equals() 在未来不会改变，这样就会解决与可变相关的问题了。</li>\n</ul>\n<blockquote>\n<p>7、为什么HashMap中String、Integer这样的包装类适合作为K？</p>\n</blockquote>\n<p>String、Integer等包装类的特性能够保证Hash值的不可更改性和计算准确性，能够有效的减少Hash碰撞的几率</p>\n<ol>\n<li>都是final类型，即不可变性，保证key的不可更改性，不会存在获取hash值不同的情况</li>\n<li>内部已重写了<code>equals()</code>、<code>hashCode()</code>等方法，遵守了HashMap内部的规范，不容易出现Hash值计算错误的情况；</li>\n</ol>\n<blockquote>\n<p>8、如果使用Object作为HashMap的Key，应该怎么办呢？</p>\n</blockquote>\n<p>重写hashCode()和equals()方法</p>\n<ol>\n<li><strong>重写hashCode()是因为需要计算存储数据的存储位置</strong>，需要注意不要试图从散列码计算中排除掉一个对象的关键部分来提高性能，这样虽然能更快但可能会导致更多的Hash碰撞；</li>\n<li><strong>重写equals()方法</strong>，需要遵守自反性、对称性、传递性、一致性以及对于任何非null的引用值x，x.equals(null)必须返回false的这几个特性，<strong>目的是为了保证key在哈希表中的唯一性</strong>；</li>\n</ol>\n<blockquote>\n<p>9、HashMap为什么不直接使用hashCode()处理后的哈希值直接作为table的下标？</p>\n</blockquote>\n<ul>\n<li>hashCode()方法返回的是int整数类型，其范围为-(2 ^ 31)~(2 ^ 31 - 1)，约有40亿个映射空间，</li>\n<li>而HashMap的容量范围是在16（初始化默认值）~2 ^ 30，</li>\n<li>HashMap通常情况下是取不到最大值的，并且设备上也难以提供这么多的存储空间，</li>\n<li>通过hashCode()计算出的哈希值可能不在数组大小范围内，进而无法匹配存储位置，因此不能直接作为下标</li>\n</ul>\n<blockquote>\n<p>10、HashMap 的长度为什么是2的幂次方</p>\n</blockquote>\n<p>为了能让 HashMap 存取高效，尽量较少碰撞，也就是要尽量把数据分配均匀，</p>\n<p>每个链表/红黑树长度大致相同。这个实现就是把数据存到哪个链表/红黑树中的算法。</p>\n<p><strong>这个算法应该如何设计呢？</strong></p>\n<p>我们首先可能会想到采用%取余的操作来实现。但是，重点来了：“取余(%)操作中如果除数是2的幂次则等价于与其除数减一的与(&amp;)操</p>\n<p>作（也就是说 hash%length==hash&amp;(length-1)的前提是 length 是2的 n 次方；）。” 并且 采用二进制位操作 &amp;，相对于%能够提高运</p>\n<p>算效率，这就解释了 HashMap 的长度为什么是2的幂次方。</p>\n<p><strong>那为什么是两次扰动呢？</strong></p>\n<p>这样就是加大哈希值低位的随机性，使得分布更均匀，从而提高对应数组存储下标位置的随机性&amp;均匀性，最终减少Hash冲突，</p>\n<p>两次就够了，已经达到了高位低位同时参与运算的目的；</p>\n<blockquote>\n<p>11、HashMap 与 HashTable 有什么区别？</p>\n</blockquote>\n<ol>\n<li><strong>线程安全</strong>： HashMap 是非线程安全的，HashTable 是线程安全的；HashTable 内部的方法基本都经过 <code>synchronized</code> 修饰。HashTable已经不推荐使用（如果你要保证线程安全的话就使用 <code>ConcurrentHashMap</code>！）；</li>\n<li><strong>效率</strong>： 因为线程安全的问题，HashMap 要比 HashTable 效率高一点。另外，HashTable 基本被淘汰，不要在代码中使用它；</li>\n<li><strong>对Null key 和Null value的支持</strong>： HashMap 中，null 可以作为键，这样的键只有一个，可以有一个或多个键所对应的值为 null。但是在 HashTable 中 put 进的键值只要有一个 null，直接抛NullPointerException。</li>\n<li><strong>初始容量大小和每次扩充容量大小的不同</strong>  ： ①创建时如果不指定容量初始值，Hashtable 默认的初始大小为11，之后每次扩充，容量变为原来的2n+1。HashMap 默认的初始化大小为16。之后每次扩充，容量变为原来的2倍。②创建时如果给定了容量初始值，那么 Hashtable 会直接使用你给定的大小，而 HashMap 会将其扩充为2的幂次方大小。也就是说 HashMap 总是使用2的幂作为哈希表的大小，后面会介绍到为什么是2的幂次方。</li>\n<li><strong>底层数据结构</strong>： JDK1.8 以后的 HashMap 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。Hashtable 没有这样的机制。</li>\n<li>推荐使用：在 Hashtable 的类注释可以看到，Hashtable 是保留类不建议使用，推荐在单线程环境下使用 HashMap 替代，如果需要多线程使用则用 ConcurrentHashMap 替代。</li>\n</ol>\n<blockquote>\n<p>12、如何决定使用 HashMap 还是 TreeMap？</p>\n</blockquote>\n<ul>\n<li>对于在Map中插入、删除和定位元素这类操作，HashMap是最好的选择。</li>\n<li>然而，假如你需要对一个有序的key集合进行遍历，TreeMap是更好的选择。</li>\n<li>基于你的collection的大小，也许向HashMap中添加元素会更快，将map换为TreeMap进行有序key的遍历。</li>\n</ul>\n<blockquote>\n<p>13、HashMap 和 ConcurrentHashMap 的区别</p>\n</blockquote>\n<ul>\n<li>\n<p>ConcurrentHashMap对整个桶数组进行了分割分段(Segment)，然后在每一个分段上都用lock锁进行保护，</p>\n<p>相对于HashTable的synchronized锁的粒度更精细了一些，并发性能更好，</p>\n<p>而HashMap没有锁机制，不是线程安全的。（JDK1.8之后ConcurrentHashMap启用了一种全新的方式实现,利用<strong>CAS算法</strong>。）</p>\n</li>\n<li>\n<p>HashMap的键值对允许有null，但是ConCurrentHashMap都不允许。</p>\n</li>\n</ul>\n<blockquote>\n<p>14、 ConcurrentHashMap 和 Hashtable 的区别？</p>\n</blockquote>\n<p>ConcurrentHashMap 结合了 HashMap 和 HashTable 二者的优势。HashMap 没有考虑同步，HashTable 考虑了同步的问题。但是</p>\n<p>HashTable 在每次同步执行时都要锁住整个结构。 ConcurrentHashMap 锁的方式是稍微细粒度的。</p>\n<p>ConcurrentHashMap 和 Hashtable 的区别主要体现在实现线程安全的方式上不同。</p>\n<ul>\n<li>\n<p><strong>底层数据结构</strong>： JDK1.7的 ConcurrentHashMap 底层采用 <strong>分段的数组+链表</strong> 实现，JDK1.8 采用的数据结构跟HashMap1.8的结构一样，数组+链表/红黑二叉树。Hashtable 和 JDK1.8 之前的 HashMap 的底层数据结构类似都是采用 <strong>数组+链表</strong> 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的；</p>\n</li>\n<li>\n<p><strong>实现线程安全的方式（重要）</strong>：</p>\n<p>① <strong>在JDK1.7的时候，ConcurrentHashMap（分段锁）</strong> 对整个桶数组进行了分割分段(Segment)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。（默认分配16个Segment，比Hashtable效率提高16倍。） <strong>到了 JDK1.8 的时候已经摒弃了Segment的概念，而是直接用 Node 数组+链表+红黑树的数据结构来实现，并发控制使用 synchronized 和 CAS 来操作。（JDK1.6以后 对 synchronized锁做了很多优化）</strong> 整个看起来就像是优化过且线程安全的 HashMap，虽然在JDK1.8中还能看到 Segment 的数据结构，但是已经简化了属性，只是为了兼容旧版本；</p>\n<p>② <strong>Hashtable(同一把锁)</strong> :使用 synchronized 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。</p>\n</li>\n</ul>\n<p><strong>两者的对比图</strong>：</p>\n<p>HashTable:</p>\n<p><img src=\"./assets/14.png\" alt=\"img\"></p>\n<p>JDK1.7的ConcurrentHashMap：</p>\n<p><img src=\"./assets/15.png\" alt=\"img\"></p>\n<p>JDK1.8的ConcurrentHashMap（TreeBin: 红黑二叉树节点 Node: 链表节点）：</p>\n<p><img src=\"./assets/16.png\" alt=\"img\"></p>\n<blockquote>\n<p>15、ConcurrentHashMap 底层具体实现知道吗？实现原理是什么？</p>\n</blockquote>\n<p><strong>JDK1.7</strong></p>\n<p>首先将数据分为一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问。</p>\n<p>在JDK1.7中，ConcurrentHashMap采用Segment + HashEntry的方式进行实现，结构如下：</p>\n<ul>\n<li>一个 ConcurrentHashMap 里包含一个 Segment 数组。Segment 的结构和HashMap类似，是一种数组和链表结构，</li>\n<li>一个 Segment 包含一个 HashEntry 数组，每个 HashEntry 是一个链表结构的元素，每个 Segment 守护着一个HashEntry数组里的元素，</li>\n<li>当对 HashEntry 数组的数据进行修改时，必须首先获得对应的 Segment的锁。</li>\n</ul>\n<p><img src=\"./assets/17.png\" alt=\"img\"></p>\n<ol>\n<li>该类包含两个<strong>静态内部类</strong> HashEntry 和 Segment ；前者用来封装映射表的键值对，后者用来充当锁的角色；</li>\n<li>Segment 是一种<strong>可重入的锁</strong> ReentrantLock，每个 Segment 守护一个HashEntry 数组里的元素，当对 HashEntry 数组的数据进行修改时，必须首先获得对应的 Segment 锁。</li>\n</ol>\n<p><strong>JDK1.8</strong></p>\n<p>在<strong>JDK1.8中，放弃了Segment臃肿的设计，取而代之的是采用Node + CAS + Synchronized来保证并发安全进行实现</strong>，synchronized只锁定当前链表或红黑二叉树的首节点，这样只要hash不冲突，就不会产生并发，效率又提升N倍。</p>\n<p>结构如下：</p>\n<p><img src=\"./assets/18.png\" alt=\"img\"></p>\n<p><strong>附加源码，有需要的可以看看</strong></p>\n<p>插入元素过程（建议去看看源码）：</p>\n<p>如果相应位置的Node还没有初始化，则调用CAS插入相应的数据；</p>\n<div><pre><code><span>else</span> <span>if</span> <span>(</span><span>(</span>f <span>=</span> <span>tabAt</span><span>(</span>tab<span>,</span> i <span>=</span> <span>(</span>n <span>-</span> <span>1</span><span>)</span> <span>&amp;</span> hash<span>)</span><span>)</span> <span>==</span> <span>null</span><span>)</span> <span>{</span>\n    <span>if</span> <span>(</span><span>casTabAt</span><span>(</span>tab<span>,</span> i<span>,</span> <span>null</span><span>,</span> <span>new</span> <span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span><span>(</span>hash<span>,</span> key<span>,</span> value<span>,</span> <span>null</span><span>)</span><span>)</span><span>)</span>\n        <span>break</span><span>;</span>                   <span>// no lock when adding to empty bin</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>如果相应位置的Node不为空，且当前该节点不处于移动状态，则对该节点加synchronized锁，如果该节点的hash不小于0，则遍历链表更新节点或插入新节点；</p>\n<div><pre><code><span>if</span> <span>(</span>fh <span>>=</span> <span>0</span><span>)</span> <span>{</span>\n    binCount <span>=</span> <span>1</span><span>;</span>\n    <span>for</span> <span>(</span><span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> e <span>=</span> f<span>;</span><span>;</span> <span>++</span>binCount<span>)</span> <span>{</span>\n        <span>K</span> ek<span>;</span>\n        <span>if</span> <span>(</span>e<span>.</span>hash <span>==</span> hash <span>&amp;&amp;</span>\n            <span>(</span><span>(</span>ek <span>=</span> e<span>.</span>key<span>)</span> <span>==</span> key <span>||</span>\n             <span>(</span>ek <span>!=</span> <span>null</span> <span>&amp;&amp;</span> key<span>.</span><span>equals</span><span>(</span>ek<span>)</span><span>)</span><span>)</span><span>)</span> <span>{</span>\n            oldVal <span>=</span> e<span>.</span>val<span>;</span>\n            <span>if</span> <span>(</span><span>!</span>onlyIfAbsent<span>)</span>\n                e<span>.</span>val <span>=</span> value<span>;</span>\n            <span>break</span><span>;</span>\n        <span>}</span>\n        <span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> pred <span>=</span> e<span>;</span>\n        <span>if</span> <span>(</span><span>(</span>e <span>=</span> e<span>.</span>next<span>)</span> <span>==</span> <span>null</span><span>)</span> <span>{</span>\n            pred<span>.</span>next <span>=</span> <span>new</span> <span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span><span>(</span>hash<span>,</span> key<span>,</span> value<span>,</span> <span>null</span><span>)</span><span>;</span>\n            <span>break</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><ol>\n<li>如果该节点是TreeBin类型的节点，说明是红黑树结构，则通过putTreeVal方法往红黑树中插入节点；如果binCount不为0，说明put操作对数据产生了影响，如果当前链表的个数达到8个，则通过treeifyBin方法转化为红黑树，如果oldVal不为空，说明是一次更新操作，没有对元素个数产生影响，则直接返回旧值；</li>\n<li>如果插入的是一个新节点，则执行addCount()方法尝试更新元素个数baseCount；</li>\n</ol>\n<h4 id=\"四-辅助工具类-2\"> （四）辅助工具类</h4>\n<blockquote>\n<p>1、Array 和 ArrayList 有何区别？</p>\n</blockquote>\n<ul>\n<li>Array 可以存储基本数据类型和对象，ArrayList 只能存储对象。</li>\n<li>Array 是指定固定大小的，而 ArrayList 大小是自动扩展的。</li>\n<li>Array 内置方法没有 ArrayList 多，比如 addAll、removeAll、iteration 等方法只有 ArrayList 有。</li>\n</ul>\n<p>对于基本类型数据，集合使用自动装箱来减少编码工作量。但是，当处理固定大小的基本数据类型的时候，这种方式相对比较慢。</p>\n<blockquote>\n<p>2、如何实现 Array 和 List 之间的转换？</p>\n</blockquote>\n<ul>\n<li>Array 转 List： Arrays. asList(array) ；</li>\n<li>List 转 Array：List 的 toArray() 方法。</li>\n</ul>\n<blockquote>\n<p>3、comparable 和 comparator的区别？</p>\n</blockquote>\n<ul>\n<li>comparable接口实际上是出自java.lang包，它有一个 compareTo(Object obj)方法用来排序</li>\n<li>comparator接口实际上是出自 java.util 包，它有一个compare(Object obj1, Object obj2)方法用来排序</li>\n</ul>\n<ol>\n<li>\n<p>一般我们需要对一个集合使用自定义排序时，我们就要重写compareTo方法或compare方法，</p>\n</li>\n<li>\n<p>当我们需要对某一个集合实现两种排序方式，</p>\n<p>比如一个song对象中的歌名和歌手名分别采用一种排序方法的话，我们可以</p>\n<p>①重写compareTo方法和使用自制的Comparator方法</p>\n<p>②以两个Comparator来实现歌名排序和歌星名排序</p>\n<p>第二种代表我们只能使用两个参数版的Collections.sort().</p>\n</li>\n</ol>\n<blockquote>\n<p>4、Collection 和 Collections 有什么区别？</p>\n</blockquote>\n<ul>\n<li>java.util.Collection 是一个集合接口（集合类的一个顶级接口）。它提供了对集合对象进行基本操作的通用接口方法。Collection接口在Java 类库中有很多具体的实现。Collection接口的意义是为各种具体的集合提供了最大化的统一操作方式，其直接继承接口有List与Set。</li>\n<li>Collections则是集合类的一个工具类/帮助类，其中提供了一系列静态方法，用于对集合中元素进行排序、搜索以及线程安全等各种操作。</li>\n</ul>\n<blockquote>\n<p>5、TreeMap 和 TreeSet 在排序时如何比较元素？Collections 工具类中的 sort()方法如何比较元素？</p>\n</blockquote>\n<ol>\n<li>TreeSet 要求存放的<strong>对象</strong>所属的类必须实现 <strong>Comparable 接口</strong>，该接口提供了比较元素的 compareTo()方法，当插入元素时会回调该方法比较元素的大小。</li>\n<li>TreeMap 要求存放的键值对映射的<strong>键</strong>必须实现 <strong>Comparable 接口</strong>从而根据键对元素进行排序。</li>\n</ol>\n<p>Collections 工具类的 sort 方法有两种重载的形式，</p>\n<ul>\n<li>第一种：要求传入的待排序容器中存放的<strong>对象</strong>比较实现 <strong>Comparable 接口</strong>以实现元素的比较；</li>\n<li>第二种：不强制性的要求容器中的元素必须可比较，但是要求传入第二个参数，<strong>参数是Comparator 接口的子类型</strong>（需要重写 compare 方法实现元素的比较），相当于一个临时定义的排序规则，其实就是通过 <mark>接口注入</mark> 比较元素大小的算法，也是对 <mark>回调模式</mark> 的应用（Java 中对函数式编程的支持）。</li>\n</ul>\n<h3 id=\"二、泛型-2\"> 二、泛型</h3>\n<h3 id=\"三、异常-2\"> 三、异常</h3>\n<blockquote>\n<p>1、Error 和 Exception 区别是什么？</p>\n</blockquote>\n<ol>\n<li>Error 类型的错误通常为虚拟机相关错误，如系统崩溃，内存不足，堆栈溢出等，编译器不会对这类错误进行检测，JAVA 应用程序也不应对这类错误进行捕获，一旦这类错误发生，通常应用程序会被终止，仅靠应用程序本身无法恢复；</li>\n<li>Exception 类的错误是可以在应用程序中进行捕获并处理的，通常遇到这种错误，应对其进行处理，使应用程序可以继续正常运行。</li>\n</ol>\n<blockquote>\n<p>2、运行时异常和一般异常(受检异常)区别是什么？</p>\n</blockquote>\n<p>运行时异常包括 RuntimeException 类及其子类，表示 JVM 在运行期间可能出现的异常。 Java 编译器不会检查运行时异常。</p>\n<p>受检异常是Exception 中除 RuntimeException 及其子类之外的异常。 Java 编译器会检查受检异常。</p>\n<p><strong>RuntimeException异常和受检异常之间的区别</strong>：</p>\n<ul>\n<li>是否强制要求调用者必须处理此异常，如果强制要求调用者必须进行处理，那么就使用受检异常，</li>\n<li>否则就选择非受检异常(RuntimeException)。一般来讲，如果没有特殊的要求，我们建议使用RuntimeException异常。</li>\n</ul>\n<blockquote>\n<p>3、JVM 是如何处理异常的？</p>\n</blockquote>\n<ol>\n<li>在一个方法中如果发生异常，这个方法会创建一个异常对象，并转交给 JVM，该异常对象包含异常名称，异常描述以及异常发生时应用程序的状态。创建异常对象并转交给 JVM 的过程称为<strong>抛出异常</strong>。可能有一系列的方法调用，最终才进入抛出异常的方法，这一系列方法调用的有序列表叫做调用栈。</li>\n<li>JVM 会顺着调用栈去查找看是否有可以处理异常的代码，如果有，则调用异常处理代码。当 JVM 发现可以处理异常的代码时，会把发生的异常传递给它。如果 JVM 没有找到可以处理该异常的代码块，JVM 就会将该异常转交给默认的异常处理器（默认处理器为 JVM 的一部分），默认异常处理器打印出异常信息并终止应用程序。</li>\n</ol>\n<blockquote>\n<p>4、throw 和 throws 的区别是什么？</p>\n</blockquote>\n<p>Java 中的异常处理除了包括捕获异常和处理异常之外，还包括声明异常和拋出异常，可以通过 throws 关键字在方法上声明该方法要拋</p>\n<p>出的异常，或者在方法内部通过 throw 拋出异常对象。</p>\n<p><strong>throws 关键字和 throw 关键字在使用上的几点区别如下</strong>：</p>\n<ul>\n<li>throw 关键字用在方法内部，只能用于抛出一种异常，用来抛出方法或代码块中的异常，受查异常和非受查异常都可以被抛出。</li>\n<li>throws 关键字用在方法声明上，可以抛出多个异常，用来标识该方法可能抛出的异常列表。一个方法用 throws 标识了可能抛出的异常列表，调用该方法的方法中必须包含可处理异常的代码，否则也要在方法签名中用 throws 关键字声明相应的异常。</li>\n</ul>\n<blockquote>\n<p>5、final、finally、finalize 有什么区别？</p>\n</blockquote>\n<ul>\n<li>final可以修饰类、变量、方法，修饰类表示该类不能被继承、修饰方法表示该方法不能被重写、修饰变量表示该变量是一个常量不能被重新赋值。</li>\n<li>finally一般作用在try-catch代码块中，在处理异常的时候，通常我们将一定要执行的代码方法finally代码块中，表示不管是否出现异常，该代码块都会执行，一般用来存放一些关闭资源的代码。</li>\n<li>finalize是一个方法，属于Object类的一个方法，而Object类是所有类的父类，Java 中允许使用 finalize()方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。</li>\n</ul>\n<blockquote>\n<p>6、NoClassDefFoundError 和 ClassNotFoundException 区别？</p>\n</blockquote>\n<ul>\n<li>\n<p>NoClassDefFoundError 是一个 Error 类型的异常，是由 JVM 引起的，不应该尝试捕获这个异常。</p>\n<p>1、引起该异常的原因是 JVM 或 ClassLoader 尝试加载某类时在内存中找不到该类的定义，</p>\n<p>2、该动作发生在运行期间，即编译时该类存在，但是在运行时却找不到了，可能是编译后被删除了等原因导致；</p>\n</li>\n<li>\n<p>ClassNotFoundException 是一个受查异常，需要显式地使用 try-catch 对其进行捕获和处理，或在方法签名中用 throws 关键字进行声明。</p>\n<p>1、当使用 Class.forName, ClassLoader.loadClass 或 ClassLoader.findSystemClass 动态加载类到内存的时候，通过传入的类路径参数没有找到该类，就会抛出该异常；</p>\n<p>2、另一种抛出该异常的可能原因是某个类已经由一个类加载器加载至内存中，另一个加载器又尝试去加载它。</p>\n</li>\n</ul>\n<blockquote>\n<p>7、try-catch-finally 中哪个部分可以省略？</p>\n</blockquote>\n<p>catch 可以省略</p>\n<p><strong>原因</strong></p>\n<ol>\n<li>更为严格的说法其实是：try只适合处理运行时异常，try+catch适合处理运行时异常+普通异常。也就是说，如果你只用try去处理普通异常却不加以catch处理，编译是通不过的，因为编译器硬性规定，普通异常如果选择捕获，则必须用catch显示声明以便进一步处理。而运行时异常在编译时没有如此规定，所以catch可以省略，你加上catch编译器也觉得无可厚非。</li>\n<li>理论上，编译器看任何代码都不顺眼，都觉得可能有潜在的问题，所以你即使对所有代码加上try，代码在运行期时也只不过是在正常运行的基础上加一层皮。但是你一旦对一段代码加上try，就等于显示地承诺编译器，对这段代码可能抛出的异常进行捕获而非向上抛出处理。如果是普通异常，编译器要求必须用catch捕获以便进一步处理；如果运行时异常，捕获然后丢弃并且+finally扫尾处理，或者加上catch捕获以便进一步处理。</li>\n<li>至于加上finally，则是在不管有没捕获异常，都要进行的“扫尾”处理。</li>\n</ol>\n<blockquote>\n<p>8、try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？</p>\n</blockquote>\n<p>答：会执行，在 return 前执行。</p>\n<p><strong>注意</strong>：在 finally 中改变返回值的做法是不好的，因为如果存在 finally 代码块，<strong>try中的 return 语句不会立马返回调用者</strong>，而是</p>\n<p>记录下返回值待 finally 代码块执行完毕之后再向调用者返回其值，然后如果在 finally 中修改了返回值，就会返回修改后的值。显然，</p>\n<p>在 finally 中返回或者修改返回值会对程序造成很大的困扰，C#中直接用编译错误的方式来阻止程序员干这种龌龊的事情，Java 中也可</p>\n<p>以通过提升编译器的语法检查级别来产生警告或错误。</p>\n<p><strong>代码示例1：</strong></p>\n<div><pre><code><span>public</span> <span>static</span> <span>int</span> <span>getInt</span><span>(</span><span>)</span> <span>{</span>\n    <span>int</span> a <span>=</span> <span>10</span><span>;</span>\n    <span>try</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>a <span>/</span> <span>0</span><span>)</span><span>;</span>\n        a <span>=</span> <span>20</span><span>;</span>\n    <span>}</span> <span>catch</span> <span>(</span><span>ArithmeticException</span> e<span>)</span> <span>{</span>\n        a <span>=</span> <span>30</span><span>;</span>\n        <span>return</span> a<span>;</span>\n        <span>/*\n         * return a 在程序执行到这一步的时候，这里不是return a 而是 return 30；这个返回路径就形成了\n         * 但是呢，它发现后面还有finally，所以继续执行finally的内容，a=40\n         * 再次回到以前的路径,继续走return 30，形成返回路径之后，这里的a就不是a变量了，而是常量30\n         */</span>\n    <span>}</span> <span>finally</span> <span>{</span>\n        a <span>=</span> <span>40</span><span>;</span>\n    <span>}</span>\n\t<span>return</span> a<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><p>执行结果：30</p>\n<p><strong>代码示例2：</strong></p>\n<div><pre><code><span>public</span> <span>static</span> <span>int</span> <span>getInt</span><span>(</span><span>)</span> <span>{</span>\n    <span>int</span> a <span>=</span> <span>10</span><span>;</span>\n    <span>try</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>a <span>/</span> <span>0</span><span>)</span><span>;</span>\n        a <span>=</span> <span>20</span><span>;</span>\n    <span>}</span> <span>catch</span> <span>(</span><span>ArithmeticException</span> e<span>)</span> <span>{</span>\n        a <span>=</span> <span>30</span><span>;</span>\n        <span>return</span> a<span>;</span>\n    <span>}</span> <span>finally</span> <span>{</span>\n        a <span>=</span> <span>40</span><span>;</span>\n        <span>//如果这样，就又重新形成了一条返回路径，由于只能通过1个return返回，所以这里直接返回40</span>\n        <span>return</span> a<span>;</span> \n    <span>}</span>\n\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>执行结果：40</p>\n<blockquote>\n<p>9、类 ExampleA 继承 Exception，类 ExampleB 继承ExampleA。</p>\n</blockquote>\n<p>有如下代码片断：</p>\n<div><pre><code><span>try</span> <span>{</span>\n\t<span>throw</span> <span>new</span> <span>ExampleB</span><span>(</span><span>\"b\"</span><span>)</span>\n<span>}</span> <span>catch</span>（<span>ExampleA</span> e）<span>{</span>\n\t<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"ExampleA\"</span><span>)</span><span>;</span>\n<span>}</span> <span>catch</span>（<span>Exception</span> e）<span>{</span>\n\t<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"Exception\"</span><span>)</span><span>;</span>\n<span>}</span>\n<span>1234567</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>请问执行此段代码的输出是什么？</p>\n<p><strong>答</strong>：</p>\n<p>输出：ExampleA。（根据里<strong>氏代换原则</strong>[能使用父类型的地方一定能使用子类型]，抓取 ExampleA 类型异常的 catch 块能够抓住 try 块中抛出的 ExampleB 类型的异常）</p>\n<p>面试题 - 说出下面代码的运行结果。（此题的出处是《Java 编程思想》一书）</p>\n<div><pre><code><span>class</span> <span>Annoyance</span> <span>extends</span> <span>Exception</span> <span>{</span>\n<span>}</span>\n<span>class</span> <span>Sneeze</span> <span>extends</span> <span>Annoyance</span> <span>{</span>\n<span>}</span>\n<span>class</span> <span>Human</span> <span>{</span>\n\t<span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span>\n\t<span>throws</span> <span>Exception</span> <span>{</span>\n\t\t<span>try</span> <span>{</span>\n\t\t\t<span>try</span> <span>{</span>\n\t\t\t\t<span>throw</span> <span>new</span> <span>Sneeze</span><span>(</span><span>)</span><span>;</span>\n\t\t\t<span>}</span> <span>catch</span> <span>(</span> <span>Annoyance</span> a <span>)</span> <span>{</span>\n\t\t\t\t<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"Caught Annoyance\"</span><span>)</span><span>;</span>\n\t\t\t\t<span>throw</span> a<span>;</span>\n\t\t\t<span>}</span>\n\t\t<span>}</span> <span>catch</span> <span>(</span> <span>Sneeze</span> s <span>)</span> <span>{</span>\n\t\t\t<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"Caught Sneeze\"</span><span>)</span><span>;</span>\n\t\t\t<span>return</span> <span>;</span>\n\t\t<span>}</span> <span>finally</span> <span>{</span>\n\t\t\t<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"Hello World!\"</span><span>)</span><span>;</span>\n\t\t<span>}</span>\n\t<span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><p>结果</p>\n<div><pre><code><span>Caught</span> <span>Annoyance</span>\n<span>Caught</span> <span>Sneeze</span>\n<span>Hello</span> <span>World</span><span>!</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><blockquote>\n<p>10、常见的 RuntimeException 有哪些？</p>\n</blockquote>\n<ul>\n<li>ClassCastException(类转换异常)</li>\n<li>IndexOutOfBoundsException(数组越界)</li>\n<li>NullPointerException(空指针)</li>\n<li>ArrayStoreException(数据存储异常，操作数组时类型不一致)</li>\n<li>还有IO操作的BufferOverflowException异常</li>\n</ul>\n<blockquote>\n<p>11、Java常见异常有哪些？</p>\n</blockquote>\n<ul>\n<li>java.lang.<strong>IllegalAccessError</strong>：违法访问错误。当一个应用试图访问、修改某个类的域（Field）或者调用其方法，但是又违反域或方法的可见性声明，则抛出该异常。</li>\n<li>java.lang.<strong>InstantiationError</strong>：实例化错误。当一个应用试图通过Java的new操作符构造一个抽象类或者接口时抛出该异常.</li>\n<li>java.lang.<strong>OutOfMemoryError</strong>：内存不足错误。当可用内存不足以让Java虚拟机分配给一个对象时抛出该错误。</li>\n<li>java.lang.<strong>StackOverflowError</strong>：堆栈溢出错误。当一个应用递归调用的层次太深而导致堆栈溢出或者陷入死循环时抛出该错误。</li>\n<li>java.lang.<strong>ClassCastException</strong>：类造型异常。假设有类A和B（A不是B的父类或子类），O是A的实例，那么当强制将O构造为类B的实例时抛出该异常。该异常经常被称为强制类型转换异常。</li>\n<li>java.lang.<strong>ClassNotFoundException</strong>：找不到类异常。当应用试图根据字符串形式的类名构造类，而在遍历CLASSPAH之后找不到对应名称的class文件时，抛出该异常。</li>\n<li>java.lang.<strong>ArithmeticException</strong>：算术条件异常。譬如：整数除零等。</li>\n<li>java.lang.<strong>ArrayIndexOutOfBoundsExceptio</strong>n：数组索引越界异常。当对数组的索引值为负数或大于等于数组大小时抛出。</li>\n<li>java.lang.<strong>IndexOutOfBoundsException</strong>：索引越界异常。当访问某个序列的索引值小于0或大于等于序列大小时，抛出该异常。</li>\n<li>java.lang.<strong>InstantiationException</strong>：实例化异常。当试图通过newInstance()方法创建某个类的实例，而该类是一个抽象类或接口时，抛出该异常。</li>\n<li>java.lang.<strong>NoSuchFieldException</strong>：属性不存在异常。当访问某个类的不存在的属性时抛出该异常。</li>\n<li>java.lang.<strong>NoSuchMethodException</strong>：方法不存在异常。当访问某个类的不存在的方法时抛出该异常。</li>\n<li>java.lang.<strong>NullPointerException</strong>：空指针异常。当应用试图在要求使用对象的地方使用了null时，抛出该异常。譬如：调用null对象的实例方法、访问null对象的属性、计算null对象的长度、使用throw语句抛出null等等。</li>\n<li>java.lang.<strong>NumberFormatException</strong>：数字格式异常。当试图将一个String转换为指定的数字类型，而该字符串确不满足数字类型要求的格式时，抛出该异常。</li>\n<li>java.lang.<strong>StringIndexOutOfBoundsException</strong>：字符串索引越界异常。当使用索引值访问某个字符串中的字符，而该索引值小于0或大于等于序列大小时，抛出该异常。</li>\n</ul>\n<h3 id=\"四、io流-2\"> 四、IO流</h3>\n<blockquote>\n<p>1、Java 中 IO 流分为几种?</p>\n</blockquote>\n<ul>\n<li>\n<p>按照流的流向分，可以分为输入流和输出流；</p>\n</li>\n<li>\n<p>按照操作单元划分，可以划分为字节流和字符流；</p>\n</li>\n<li>\n<p>按照流的角色划分为节点流和处理流。\nJava IO流共涉及40多个类，这些类看上去很杂乱，但实际上很有规则，而且彼此之间存在非常紧密的联系， Java IO流的40多个类都是从如下4个抽象类基类中派生出来的。</p>\n</li>\n<li>\n<p>InputStream/Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。</p>\n</li>\n<li>\n<p>OutputStream/Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流。</p>\n</li>\n</ul>\n<p>按操作方式分类结构图：\n<img src=\"./assets/19.jpg\" alt=\"\"></p>\n<p>按操作对象分类结构图：</p>\n<p>​\t<img src=\"./assets/20.jpg\" alt=\"\"></p>\n<blockquote>\n<p>2、BIO,NIO,AIO 有什么区别?</p>\n</blockquote>\n<p><strong>简答</strong></p>\n<ul>\n<li>\n<p>BIO：Blocking IO 同步<strong>阻塞式 IO</strong>，就是我们平常使用的<strong>传统 IO</strong>，它的特点是模式简单使用方便，<strong>并发处理能力低</strong>。</p>\n</li>\n<li>\n<p>NIO：New IO 同步<strong>非阻塞 IO</strong>，是传统 IO 的升级，客户端和服务器端通过 Channel（通道）通讯，实现了<strong>多路复用</strong>。</p>\n</li>\n<li>\n<p>AIO：Asynchronous IO 是 NIO 的升级，也叫 NIO2，实现了<strong>异步非堵塞 IO</strong> ，异步 IO 的操作基于<strong>事件和回调机制</strong>。</p>\n</li>\n</ul>\n<p><strong>使用场景：</strong></p>\n<ul>\n<li>对于低负载、低并发的应用程序，可以使用同步阻塞I/O来提升开发速率和更好的维护性；</li>\n<li>对于高负载、高并发的（网络）应用，应使用 NIO 的非阻塞模式来开发</li>\n</ul>\n<p><strong>详细回答</strong></p>\n<ul>\n<li>BIO (Blocking I/O): 同步阻塞I/O模式，数据的读取写入必须阻塞在一个线程内等待其完成。在活动连接数不是特别高（小于单机1000）的情况下，这种模型是比较不错的，可以让每一个连接专注于自己的 I/O 并且编程模型简单，也不用过多考虑系统的过载、限流等问题。线程池本身就是一个天然的漏斗，可以缓冲一些系统处理不了的连接或请求。但是，当面对十万甚至百万级连接的时候，传统的 BIO 模型是无能为力的。因此，我们需要一种更高效的 I/O 处理模型来应对更高的并发量。</li>\n<li>NIO (New I/O): NIO是一种同步非阻塞的I/O模型，在<strong>Java 1.4</strong> 中引入了NIO框架，对应 java.nio 包，提供了 <strong>Channel , Selector，Buffer</strong>等抽象。NIO中的N可以理解为Non-blocking，不单纯是New。它支持面向缓冲的，基于通道的I/O操作方法。 NIO提供了与传统BIO模型中的 Socket 和 ServerSocket 相对应的 SocketChannel 和 ServerSocketChannel 两种不同的套接字通道实现,两种通道都支持阻塞和非阻塞两种模式。阻塞模式使用就像传统中的支持一样，比较简单，但是性能和可靠性都不好；非阻塞模式正好与之相反。</li>\n<li>AIO (Asynchronous I/O): AIO 也就是 NIO 2。在 <strong>Java 7</strong> 中引入了 NIO 的改进版 NIO 2,它是异步非阻塞的IO模型。异步 IO 是<strong>基于事件和回调机制</strong>实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。AIO 是异步IO的缩写，虽然 NIO 在网络操作中，提供了非阻塞的方法，但是 NIO 的 IO 行为还是同步的。对于 NIO 来说，我们的业务线程是在 IO 操作准备好时，得到通知，接着就由这个线程自行进行 IO 操作，IO操作本身是同步的。查阅网上相关资料，我发现就目前来说 AIO 的应用还不是很广泛，Netty 之前也尝试使用过 AIO，不过又放弃了。</li>\n</ul>\n<blockquote>\n<p>3、Files的常用方法都有哪些？</p>\n</blockquote>\n<p>Files. exists()：检测文件路径是否存在。</p>\n<p>Files. createFile()：创建文件。</p>\n<p>Files. createDirectory()：创建文件夹。</p>\n<p>Files. delete()：删除一个文件或目录。</p>\n<p>Files. copy()：复制文件。</p>\n<p>Files. move()：移动文件。</p>\n<p>Files. size()：查看文件个数。</p>\n<p>Files. read()：读取文件。</p>\n<p>Files. write()：写入文件。</p>\n<h3 id=\"五、注解-2\"> 五、注解</h3>\n<h3 id=\"六、反射-2\"> 六、反射</h3>\n<blockquote>\n<p>1、什么是反射机制？</p>\n</blockquote>\n<p>JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种<strong>动态获取的信息以及动态调用对象的方法的功能</strong>称为java语言的反射机制。</p>\n<p>静态编译和动态编译</p>\n<p><strong>静态编译</strong>：在编译时确定类型，绑定对象</p>\n<p><strong>动态编译</strong>：运行时确定类型，绑定对象</p>\n<blockquote>\n<p>2、反射机制优缺点</p>\n</blockquote>\n<p>优点： 运行期类型的判断，动态加载类，提高代码灵活度。</p>\n<p>缺点： 性能瓶颈：反射相当于一系列解释操作，通知 JVM 要做的事情，性能比直接的java代码要慢很多。</p>\n<blockquote>\n<p>3、反射机制的应用场景有哪些？</p>\n</blockquote>\n<p><strong>反射是框架设计的灵魂。</strong></p>\n<p>在我们平时的项目开发过程中，基本上很少会直接使用到反射机制，但这不能说明反射机制没有用，实际上有很多设计、开发都与反射机制有关，例如：</p>\n<ul>\n<li>模块化的开发，通过反射去调用对应的字节码；</li>\n<li>动态代理设计模式也采用了反射机制，</li>\n<li>还有我们日常使用的 Spring／Hibernate 等框架也大量使用到了反射机制。</li>\n</ul>\n<p><strong>举例：</strong></p>\n<p>1、我们在使用JDBC连接数据库时使用Class.forName()通过反射加载数据库的驱动程序；</p>\n<p>2、Spring框架也用到很多反射机制，最经典的就是xml的配置模式。</p>\n<p>Spring 通过 XML 配置模式装载 Bean 的过程：</p>\n<ul>\n<li>1）将程序内所有 XML 或 Properties 配置文件加载入内存中;</li>\n<li>2）Java类里面解析xml或properties里面的内容，得到对应实体类的字节码字符串以及相关的属性信息;</li>\n<li>3）使用反射机制，根据这个字符串获得某个类的Class实例;</li>\n<li>4）动态配置实例的属性</li>\n</ul>\n<blockquote>\n<p>4、Java获取反射的三种方法</p>\n</blockquote>\n<p>1.通过new对象实现反射机制</p>\n<p>2.通过路径实现反射机制</p>\n<p>3.通过类名实现反射机制</p>\n<div><pre><code><span>public</span> <span>class</span> <span>Student</span> <span>{</span>\n    <span>private</span> <span>int</span> id<span>;</span>\n    <span>String</span> name<span>;</span>\n    <span>protected</span> <span>boolean</span> sex<span>;</span>\n    <span>public</span> <span>float</span> score<span>;</span>\n<span>}</span>\n\n<span>public</span> <span>class</span> <span>Get</span> <span>{</span>\n    <span>//获取反射机制三种方式</span>\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>throws</span> <span>ClassNotFoundException</span> <span>{</span>\n        <span>//方式一(通过建立对象)</span>\n        <span>Student</span> stu <span>=</span> <span>new</span> <span>Student</span><span>(</span><span>)</span><span>;</span>\n        <span>Class</span> classobj1 <span>=</span> stu<span>.</span><span>getClass</span><span>(</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>classobj1<span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>//方式二（通过所在路径-相对路径）</span>\n        <span>Class</span> classobj2 <span>=</span> <span>Class</span><span>.</span><span>forName</span><span>(</span><span>\"fanshe.Student\"</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>classobj2<span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>//方式三（通过类名）</span>\n        <span>Class</span> classobj3 <span>=</span> <span>Student</span><span>.</span><span>class</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>classobj3<span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><h3 id=\"七、网络-2\"> 七、网络</h3>\n<blockquote>\n<p>1、为什么TCP连接的时候是3次？2次不可以吗？</p>\n</blockquote>\n<ol>\n<li>因为需要考虑连接时丢包的问题，如果只握手2次，第二次握手时如果服务端发给客户端的确认报文段丢失，此时服务端已经准备好了收发数(可以理解服务端已经连接成功)据，而客户端一直没收到服务端的确认报文，所以客户端就不知道服务端是否已经准备好了(可以理解为客户端未连接成功)，这种情况下客户端不会给服务端发数据，也会忽略服务端发过来的数据。</li>\n<li>如果是三次握手，即便发生丢包也不会有问题，比如如果第三次握手客户端发的确认ack报文丢失，服务端在一段时间内没有收到确认ACK报文的话就会重新进行第二次握手，也就是服务端会重发SYN报文段，客户端收到重发的报文段后会再次给服务端发送确认ACK报文。</li>\n</ol>\n<p>客户端：兄弟，在吗？</p>\n<p>服务端：在的，老铁</p>\n<p>客户端：回个消息磨磨唧唧，都等你半天了</p>\n<p><img src=\"./assets/21.png\" alt=\"\"></p>\n<ul>\n<li><strong>第一次握手</strong>：客户端要向服务端发起连接请求，首先客户端随机生成一个起始序列号ISN(比如是100)，那客户端向服务端发送的报文段包含SYN标志位(也就是SYN=1)，序列号seq=100。</li>\n<li><strong>第二次握手</strong>：服务端收到客户端发过来的报文后，发现SYN=1，知道这是一个连接请求，于是将客户端的起始序列号100存起来，并且随机生成一个服务端的起始序列号(比如是300)。然后给客户端回复一段报文，回复报文包含SYN和ACK标志(也就是SYN=1,ACK=1)、序列号seq=300、确认号ack=101(客户端发过来的序列号+1)。</li>\n<li><strong>第三次握手</strong>：客户端收到服务端的回复后发现ACK=1并且ack=101,于是知道服务端已经收到了序列号为100的那段报文；同时发现SYN=1，知道了服务端同意了这次连接，于是就将服务端的序列号300给存下来。然后客户端再回复一段报文给服务端，报文包含ACK标志位(ACK=1)、ack=301(服务端序列号+1)、seq=101(第一次握手时发送报文是占据一个序列号的，所以这次seq就从101开始，需要注意的是不携带数据的ACK报文是不占据序列号的，所以后面第一次正式发送数据时seq还是101)。当服务端收到报文后发现ACK=1并且ack=301，就知道客户端收到序列号为300的报文了，就这样客户端和服务端通过TCP建立了连接。</li>\n</ul>\n<blockquote>\n<p>2、为什么TCP连接的时候是3次，关闭的时候却是4次？</p>\n</blockquote>\n<p>因为只有在客户端和服务端都没有数据要发送的时候才能断开TCP。而客户端发出FIN报文时只能保证客户端没有数据发了，服务端还有没有数据发客户端是不知道的。而服务端收到客户端的FIN报文后只能先回复客户端一个确认报文来告诉客户端我服务端已经收到你的FIN报文了，但我服务端还有一些数据没发完，等这些数据发完了服务端才能给客户端发FIN报文(所以不能一次性将确认报文和FIN报文发给客户端，就是这里多出来了一次)。</p>\n<p>客户端：我要准备溜了</p>\n<p>服务端：收到，老铁。不过等一下，我还有点东西要发你</p>\n<p>服务端：也不是啥重要的，算了，不发了，滚你</p>\n<p>客户端：****</p>\n<p>服务端断开连接....</p>\n<p>2MSL后</p>\n<p>客户端断开连接......</p>\n<p><img src=\"./assets/22.png\" alt=\"\"></p>\n<p>比如客户端初始化的序列号ISA=100，服务端初始化的序列号ISA=300。TCP连接成功后客户端总共发送了1000个字节的数据，服务端在客户端发FIN报文前总共回复了2000个字节的数据。</p>\n<ul>\n<li>\n<p><strong>第一次挥手</strong>：当客户端的数据都传输完成后，客户端向服务端发出连接释放报文(当然数据没发完时也可以发送连接释放报文并停止发送数据)，释放连接报文包含FIN标志位(FIN=1)、序列号seq=1101(100+1+1000，其中的1是建立连接时占的一个序列号)。需要注意的是客户端发出FIN报文段后只是不能发数据了，但是还可以正常收数据；另外FIN报文段即使不携带数据也要占据一个序列号。</p>\n</li>\n<li>\n<p><strong>第二次挥手</strong>：服务端收到客户端发的FIN报文后给客户端回复确认报文，确认报文包含ACK标志位(ACK=1)、确认号ack=1102(客户端FIN报文序列号1101+1)、序列号seq=2300(300+2000)。此时服务端处于关闭等待状态，而不是立马给客户端发FIN报文，这个状态还要持续一段时间，因为服务端可能还有数据没发完。</p>\n</li>\n<li>\n<p><strong>第三次挥手</strong>：服务端将最后数据(比如50个字节)发送完毕后就向客户端发出连接释放报文，报文包含FIN和ACK标志位(FIN=1,ACK=1)、确认号和第二次挥手一样ack=1102、序列号seq=2350(2300+50)。</p>\n</li>\n<li>\n<p><strong>第四次挥手</strong>：客户端收到服务端发的FIN报文后，向服务端发出确认报文，确认报文包含ACK标志位(ACK=1)、确认号ack=2351、序列号seq=1102。注意客户端发出确认报文后不是立马释放TCP连接，而是要经过2MSL(最长报文段寿命的2倍时长)后才释放TCP连接。而服务端一旦收到客户端发出的确认报文就会立马释放TCP连接，所以服务端结束TCP连接的时间要比客户端早一些。</p>\n</li>\n</ul>\n<blockquote>\n<p>3、为什么客户端发出第四次挥手的确认报文后要等2MSL的时间才能释放TCP连接？</p>\n</blockquote>\n<p>这里同样是要考虑丢包的问题，如果第四次挥手的报文丢失，服务端就收到确认ACK报文，这样服务端就会就会重发第三次挥手的报文。这样以来，客户端从发出第四次挥手的报文到再次收到第三次挥手的报文经历的最长时间就是2MSL，所以需要等这么长时间来确认服务端确实已经收到了。</p>\n<blockquote>\n<p>4、如果已经建立了连接，但是客户端突然出现故障了怎么办？</p>\n</blockquote>\n<p>TCP设有一个<strong>保活计时器</strong>，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为<strong>2小时</strong>，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后<strong>每隔75秒</strong>钟发送一次。若一连发送<strong>10个探测报文</strong>仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。</p>\n<blockquote>\n<p>5、什么是HTTP，HTTP 与 HTTPS 的区别</p>\n</blockquote>\n<p>HTTP 是一个在计算机世界里专门在两点之间传输文字、图片、音频、视频等<strong>超文本数据的约定和规范</strong></p>\n<table>\n<thead>\n<tr>\n<th>区别</th>\n<th>HTTP</th>\n<th>HTTPS</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>协议</td>\n<td>运行在 TCP 之上，明文传输，<strong>客户端与服务器端都无法验证对方的身份</strong></td>\n<td>身披 SSL( Secure Socket Layer )外壳的 HTTP，运行于 SSL 上，SSL 运行于 TCP 之上， <strong>是添加了加密和认证机制的 HTTP</strong>。</td>\n</tr>\n<tr>\n<td>端口</td>\n<td>80</td>\n<td>443</td>\n</tr>\n<tr>\n<td>资源消耗</td>\n<td>较少</td>\n<td>由于加解密处理，会消耗更多的 CPU 和内存资源</td>\n</tr>\n<tr>\n<td>开销</td>\n<td>无需证书</td>\n<td>需要证书，而证书一般需要向认证机构购买</td>\n</tr>\n<tr>\n<td>加密机制</td>\n<td>无</td>\n<td>共享密钥加密和公开密钥加密并用的混合加密机制</td>\n</tr>\n<tr>\n<td>安全性</td>\n<td>弱</td>\n<td>由于加密机制，安全性强</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>6、常用HTTP状态码</p>\n</blockquote>\n<p>HTTP状态码表示客户端HTTP请求的返回结果、标识服务器处理是否正常、表明请求出现的错误等。</p>\n<p><strong>状态码的类别：</strong></p>\n<table>\n<thead>\n<tr>\n<th>类别</th>\n<th>原因短语</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1XX</td>\n<td>Informational（信息性状态码） 接受的请求正在处理</td>\n</tr>\n<tr>\n<td>2XX</td>\n<td>Success（成功状态码） 请求正常处理完毕</td>\n</tr>\n<tr>\n<td>3XX</td>\n<td>Redirection（重定向状态码） 需要进行附加操作以完成请求</td>\n</tr>\n<tr>\n<td>4XX</td>\n<td>Client Error（客户端错误状态码） 服务器无法处理请求</td>\n</tr>\n<tr>\n<td>5XX</td>\n<td>Server Error（服务器错误状态码） 服务器处理请求出错</td>\n</tr>\n</tbody>\n</table>\n<p><strong>常用HTTP状态码：</strong></p>\n<table>\n<thead>\n<tr>\n<th>2XX</th>\n<th>成功（这系列表明请求被正常处理了）</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>200</td>\n<td>OK，表示从客户端发来的请求在服务器端被正确处理</td>\n</tr>\n<tr>\n<td>204</td>\n<td>No content，表示请求成功，但响应报文不含实体的主体部分</td>\n</tr>\n<tr>\n<td>206</td>\n<td>Partial Content，进行范围请求成功</td>\n</tr>\n</tbody>\n</table>\n<table>\n<thead>\n<tr>\n<th>3XX</th>\n<th>重定向（表明浏览器要执行特殊处理）</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>301</td>\n<td>moved permanently，永久性重定向，表示资源已被分配了新的 URL</td>\n</tr>\n<tr>\n<td>302</td>\n<td>found，临时性重定向，表示资源临时被分配了新的 URL</td>\n</tr>\n<tr>\n<td>303</td>\n<td>see other，表示资源存在着另一个 URL，应使用 GET 方法获取资源（对于301/302/303响应，几乎所有浏览器都会删除报文主体并自动用GET重新请求）</td>\n</tr>\n<tr>\n<td>304</td>\n<td>not modified，表示服务器允许访问资源，但请求未满足条件的情况（与重定向无关）</td>\n</tr>\n<tr>\n<td>307</td>\n<td>temporary redirect，临时重定向，和302含义类似，但是期望客户端保持请求方法不变向新的地址发出请求</td>\n</tr>\n</tbody>\n</table>\n<table>\n<thead>\n<tr>\n<th>4XX</th>\n<th>客户端错误</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>400</td>\n<td>bad request，请求报文存在语法错误</td>\n</tr>\n<tr>\n<td>401</td>\n<td>unauthorized，表示发送的请求需要有通过 HTTP 认证的认证信息</td>\n</tr>\n<tr>\n<td>403</td>\n<td>forbidden，表示对请求资源的访问被服务器拒绝，可在实体主体部分返回原因描述</td>\n</tr>\n<tr>\n<td>404</td>\n<td>not found，表示在服务器上没有找到请求的资源</td>\n</tr>\n</tbody>\n</table>\n<table>\n<thead>\n<tr>\n<th>5XX</th>\n<th>服务器错误</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>500</td>\n<td>internal sever error，表示服务器端在执行请求时发生了错误</td>\n</tr>\n<tr>\n<td>501</td>\n<td>Not Implemented，表示服务器不支持当前请求所需要的某个功能</td>\n</tr>\n<tr>\n<td>503</td>\n<td>service unavailable，表明服务器暂时处于超负载或正在停机维护，无法处理请求</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>7、GET和POST区别</p>\n</blockquote>\n<p>1、说到GET和POST，就不得不提HTTP协议，因为浏览器和服务器的交互是通过HTTP协议执行的，而GET和POST也是HTTP协议中的\t\t\t  两种方法。</p>\n<p>2、HTTP全称为Hyper Text Transfer Protocol，中文翻译为超文本传输协议，目的是保证浏览器与服务器之间的通信。HTTP的工作方\t\t\t 式是客户端与服务器之间的请求-应答协议。</p>\n<p>3、HTTP协议中定义了浏览器和服务器进行交互的不同方法，基本方法有4种，分别是GET，POST，PUT，DELETE。这四种方法可以理         \t          解为，对服务器资源的查，改，增，删。</p>\n<ul>\n<li>GET：从服务器上获取数据，也就是所谓的查，仅仅是获取服务器资源，不进行修改。</li>\n<li>POST：向服务器提交数据，这就涉及到了数据的更新，也就是更改服务器的数据。</li>\n<li>PUT：英文含义是放置，也就是向服务器新添加数据，就是所谓的增。</li>\n<li>DELETE：从字面意思也能看出，这种方式就是删除服务器数据的过程。</li>\n</ul>\n<p><strong>GET和POST区别</strong></p>\n<ol>\n<li>\n<p><strong>Get是不安全的</strong>，因为在传输过程，数据被放在请求的URL中；Post的所有操作对用户来说都是不可见的。 但是这种做法也不时绝对的，大部分人的做法也是按照上面的说法来的，但是也可以在get请求加上 request body，给 post请求带上 URL 参数。</p>\n</li>\n<li>\n<p>Get请求提交的url中的数据<strong>最多只能是2048字节</strong>，这个限制是<strong>浏览器或者服务器给添加的</strong>，http协议并没有对url长度进行限制，目的是为了保证服务器和浏览器能够正常运行，防止有人恶意发送请求。POST请求则没有大小限制。</p>\n</li>\n<li>\n<p>Get限制Form表单的数据集的值必须为ASCII字符；而POST支持整个ISO10646字符集。</p>\n</li>\n<li>\n<p>Get执行效率却比POST方法好。Get是Form提交的默认方法。</p>\n</li>\n<li>\n<p>GET产生一个TCP数据包；POST产生两个TCP数据包。</p>\n<p>对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；</p>\n<p>而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。</p>\n</li>\n</ol>\n<blockquote>\n<p>8、什么是对称加密与非对称加密</p>\n</blockquote>\n<ul>\n<li>对称密钥加密是指加密和解密使用同一个密钥的方式，<strong>这种方式存在的最大问题就是密钥发送问题，即如何安全地将密钥发给对方；</strong></li>\n<li>而非对称加密是指使用一对非对称密钥，即公钥和私钥，公钥可以随意发布，但私钥只有自己知道。发送密文的一方使用对方的公钥进行加密处理，对方接收到加密信息后，使用自己的私钥进行解密。</li>\n<li>由于非对称加密的方式不需要发送用来解密的私钥，所以可以保证安全性；但是和对称加密比起来，非常的慢</li>\n</ul>\n<blockquote>\n<p>9、什么是HTTP2</p>\n</blockquote>\n<ul>\n<li>HTTP2 可以提高了网页的性能。</li>\n<li>在 HTTP1 中浏览器限制了同一个域名下的请求数量（Chrome 下一般是六个），当在请求很多资源的时候，由于队头阻塞，此时当浏览器达到最大请求数量，剩余的资源只能等待当前的六个请求完成后才能发起请求。</li>\n<li>HTTP2 中引入了<strong>多路复用</strong>的技术，这个技术可以只通过一个 TCP 连接就可以传输所有的请求数据。多路复用可以<strong>绕过浏览器限制同一个域名下的请求数量的问题</strong>，进而提高了网页的性能。</li>\n</ul>\n<blockquote>\n<p>10、Session、Cookie和Token的主要区别</p>\n</blockquote>\n<p>HTTP协议本身是 <mark>无状态</mark> 的。什么是无状态呢，<mark>即服务器无法判断用户身份。</mark></p>\n<p><strong>（1）什么是cookie</strong></p>\n<ul>\n<li>cookie是<strong>由Web服务器保存在用户浏览器上的小文件（key-value格式）</strong>，包含用户相关的信息。</li>\n<li>客户端向服务器发起请求，如果服务器需要记录该用户状态，就使用response向客户端浏览器颁发一个Cookie。</li>\n<li>客户端浏览器会把Cookie保存起来。当浏览器再请求该网站时，浏览器把请求的网址连同该Cookie一同提交给服务器。服务器检查该Cookie，以此来辨认用户身份。</li>\n</ul>\n<p><strong>（2）什么是session</strong></p>\n<ul>\n<li>session是<strong>依赖Cookie实现</strong>的。session是服务器端对象</li>\n<li>session 是浏览器和服务器会话过程中，服务器分配的一块储存空间。服务器默认浏览器在cookie中设置 sessionid，浏览器在向服务器请求过程中传输 cookie 包含 sessionid ，服务器根据 sessionid 获取出会话中存储的信息，然后确定会话的身份信息。</li>\n</ul>\n<p><strong>（3）cookie与session区别</strong></p>\n<ul>\n<li>存储位置与安全性：cookie数据存放在客户端上，安全性较差，session数据放在服务器上，安全性相对更高；</li>\n<li>存储空间：单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie，session无此限制</li>\n<li>占用服务器资源：session一定时间内保存在服务器上，当访问增多，占用服务器性能，考虑到服务器性能方面，应当使用cookie。</li>\n</ul>\n<p><strong>（4）什么是Token</strong></p>\n<ul>\n<li>Token的引入：Token是在客户端频繁向服务端请求数据，服务端频繁的去数据库查询用户名和密码并进行对比，判断用户名和密码正确与否，并作出相应提示，在这样的背景下，Token便应运而生。</li>\n<li>Token的定义：<strong>Token是服务端生成的一串字符串</strong>，以作客户端进行请求的一个<strong>令牌</strong>，当第一次登录后，服务器生成一个Token便将此Token返回给客户端，以后客户端只需带上这个Token前来请求数据即可，无需再次带上用户名和密码。</li>\n<li>使用Token的目的：Token的目的是<strong>为了减轻服务器的压力，减少频繁的查询数据库，使服务器更加健壮。</strong></li>\n<li>Token 是在服务端产生的。如果前端使用用户名/密码向服务端请求认证，服务端认证成功，那么在服务端会返回 Token 给前端。前端可以在每次请求的时候带上 Token 证明自己的合法地位</li>\n</ul>\n<p><strong>（5）session与token区别</strong></p>\n<ul>\n<li>session机制存在服务器压力增大，CSRF跨站伪造请求攻击，扩展性不强等问题；</li>\n<li>session存储在服务器端，token存储在客户端</li>\n<li>token提供<strong>认证和授权</strong>功能，作为身份认证，<strong>token安全性比session好</strong>；</li>\n<li>session这种会话存储方式方式只适用于客户端代码和服务端代码运行在同一台服务器上，token适用于项目级的前后端分离（前后端代码运行在不同的服务器下）</li>\n</ul>\n<blockquote>\n<p>11、Servlet是线程安全的吗</p>\n</blockquote>\n<p><strong>Servlet不是线程安全的，多线程并发的读写会导致数据不同步的问题。</strong></p>\n<ul>\n<li>\n<p>解决的办法是尽量不要定义name属性，而是要把name变量分别定义在doGet()和doPost()方法内。</p>\n<p>虽然使用synchronized(name){}语句块可以解决问题，但是会造成线程的等待，不是很科学的办法。</p>\n</li>\n<li>\n<p>注意：</p>\n<p>1、多线程的并发的读写Servlet类属性会导致数据不同步。</p>\n<p>2、但是如果只是并发地读取属性而不写入，则不存在数据不同步的问题。因此Servlet里的只读属性最好定义为final类型的。</p>\n</li>\n</ul>\n<blockquote>\n<p>12、Servlet接口中有哪些方法及Servlet生命周期探秘</p>\n</blockquote>\n<p>在Java Web程序中，<strong>Servlet</strong>主要负责接收用户请求<strong>HttpServletRequest</strong>，在doGet()、doPost()中做相应的处理，并将回应HttpServletResponse反馈给用户。Servlet可以设置初始化参数，供Servlet内部使用。</p>\n<p>Servlet接口定义了5个方法，其中<strong>前三个方法与Servlet生命周期相关</strong>：</p>\n<ul>\n<li>\n<p>void <strong>init</strong>(ServletConfig config) throws ServletException</p>\n</li>\n<li>\n<p>void <strong>service</strong>(ServletRequest req, ServletResponse resp) throws ServletException, java.io.IOException</p>\n</li>\n<li>\n<p>void <strong>destory</strong>()</p>\n</li>\n<li>\n<p>java.lang.String <strong>getServletInfo()</strong></p>\n</li>\n<li>\n<p>ServletConfig <strong>getServletConfig()</strong></p>\n</li>\n</ul>\n<p><strong>生命周期：</strong></p>\n<ul>\n<li>\n<p><strong>Web容器加载Servlet并将其实例化后，Servlet生命周期开始</strong>，容器运行其<strong>init()方法</strong>进行Servlet的初始化；</p>\n</li>\n<li>\n<p>请求到达时调用Servlet的<strong>service()方法</strong>，service()方法会根据需要调用与请求对应的<strong>doGet或doPost</strong>等方法；</p>\n</li>\n<li>\n<p>当服务器关闭或项目被卸载时服务器会将Servlet实例销毁，此时会调用Servlet的<strong>destroy()方法</strong>。</p>\n</li>\n<li>\n<p><strong>init方法和destory方法只会执行一次，service方法客户端每次请求Servlet都会执行</strong>。Servlet中有时会用到一些需要初始化与销毁的资源，因此可以把初始化资源的代码放入init方法中，销毁资源的代码放入destroy方法中，这样就不需要每次处理客户端的请求都要初始化与销毁资源。</p>\n</li>\n</ul>\n<blockquote>\n<p>13、如果客户端禁止 cookie 能实现 session 还能用吗？</p>\n</blockquote>\n<p><strong>不能。</strong></p>\n<ul>\n<li>Cookie 与 Session，一般认为是两个独立的东西，Session采用的是在服务器端保持状态的方案，而Cookie采用的是在客户端保持状态的方案。</li>\n<li>但为什么禁用Cookie就不能得到Session呢？因为Session是用Session ID来确定当前对话所对应的服务器Session，而Session ID是通过Cookie来传递的，禁用Cookie相当于失去了Session ID，也就得不到Session了。</li>\n</ul>\n<p>假定用户关闭Cookie的情况下使用Session，其实现途径有以下几种：</p>\n<ol>\n<li>手动通过URL传值、隐藏表单传递Session ID。</li>\n<li>用文件、数据库等形式保存Session ID，在跨页过程中手动调用。</li>\n</ol>\n<h3 id=\"八、并发-2\"> 八、并发</h3>\n<h3 id=\"九、jvm-2\"> 九、JVM</h3>\n<h6 id=\"\"> </h6>\n",
      "date_modified": "2021-02-08T17:34:42.000Z",
      "authors": [
        {
          "name": "南辞"
        }
      ],
      "tags": []
    },
    {
      "title": "编程语言",
      "url": "http://qiqi.dreamagain.top/program/backend/language/",
      "id": "http://qiqi.dreamagain.top/program/backend/language/",
      "content_html": "<h2 id=\"一、如何快速入门\"> 一、如何快速入门</h2>\n<p>一门编程语言的入门学习最好参考网上优质网站教程、视频教程和参考书籍，尤其对于有编程基础的人而言，通过网站教程和参考书是最快的入门方式，虽然没有视频教程来得直观，但是学完后印象会比较深刻。</p>\n<div><p>提示</p>\n<p>学习一门语言的基本顺序是:</p>\n<ul>\n<li>了解数据结构</li>\n<li>了解变量声明与赋值</li>\n<li>了解判断和循环体结构</li>\n<li>了解函数声明</li>\n<li>了解输入输出</li>\n</ul>\n</div>\n<h2 id=\"二、java\"> 二、<a href=\"./java/\">Java</a></h2>\n<h3 id=\"一-学习教程\"> （一）学习教程</h3>\n<h4 id=\"网站\"> 网站：</h4>\n<ul>\n<li><a href=\"https://www.liaoxuefeng.com/wiki/1252599548343744\" target=\"_blank\" rel=\"noopener noreferrer\">廖雪峰 - Java教程</a> <i>Not supported content</i><i>Not supported content</i></li>\n<li><a href=\"https://www.runoob.com/java/java-tutorial.html\" target=\"_blank\" rel=\"noopener noreferrer\">菜鸟教程</a> <i>Not supported content</i></li>\n<li><a href=\"https://www.w3cschool.cn/java/\" target=\"_blank\" rel=\"noopener noreferrer\">w3cschool</a> <i>Not supported content</i> <i>Not supported content</i> <i>Not supported content</i></li>\n<li><a href=\"https://www.sxt.cn/Java_jQuery_in_action/History_Direction.html\" target=\"_blank\" rel=\"noopener noreferrer\">速学堂 Java教程</a><i>Not supported content</i> <i>Not supported content</i></li>\n</ul>\n<h4 id=\"视频\"> 视频</h4>\n<ul>\n<li><a href=\"https://www.bilibili.com/video/BV1Kb411W75N\" target=\"_blank\" rel=\"noopener noreferrer\">宋红康老师 - Java零基础教程</a></li>\n<li><a href=\"https://www.bilibili.com/video/BV137411V7Y1?from=search&amp;seid=12229606472951180090\" target=\"_blank\" rel=\"noopener noreferrer\">尚学堂 - Java教程</a></li>\n<li><a href=\"https://www.bilibili.com/video/BV187411B7iv?from=search&amp;seid=6206316045477009865\" target=\"_blank\" rel=\"noopener noreferrer\">圣思园张龙 - 深入理解JVM虚拟机</a></li>\n</ul>\n<h3 id=\"二-学习笔记\"> （二）学习笔记</h3>\n<p>Java基础重点掌握面向对象、泛型、集合、IO流、反射、异常处理、多线程</p>\n<ul>\n<li><a href=\"./java/generics.html\">JavaSE 泛型</a></li>\n<li><a href=\"./java/collection.html\">JavaSE 集合</a></li>\n<li><a href=\"./java/annotation.html\">JavaSE 注解</a></li>\n</ul>\n<h3 id=\"三-基础知识-面试\"> （三）基础知识/面试</h3>\n<p>因为我们平时都是基于框架编程，有的基础知识时间长后很容易忘记。 虽然网上分享的面试题总结都是为了营销，但用来查缺补漏也不失为一种不错的方式。整理自互联网，仅供参考</p>\n<ul>\n<li><a href=\"./java/solution/Java基础.html\">Java基础</a></li>\n<li><a href=\"./java/solution/Java进阶.html\">Java进阶</a></li>\n</ul>\n<h2 id=\"三、python\"> 三、Python</h2>\n",
      "date_modified": "2021-02-08T17:34:42.000Z",
      "authors": [
        {
          "name": "南辞"
        }
      ],
      "tags": [
        "编程语言"
      ]
    },
    {
      "title": "后端指南",
      "url": "http://qiqi.dreamagain.top/program/backend/",
      "id": "http://qiqi.dreamagain.top/program/backend/",
      "summary": "<blockquote>\n<p><img src=\"https://img.shields.io/badge/%E5%90%8E%E7%AB%AF-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80-success.svg\" alt=\"img\">   <img src=\"https://img.shields.io/badge/%E5%90%8E%E7%AB%AF-%E6%A1%86%E6%9E%B6-success.svg\" alt=\"img\"></p>\n</blockquote>\n",
      "content_html": "<blockquote>\n<p><img src=\"https://img.shields.io/badge/%E5%90%8E%E7%AB%AF-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80-success.svg\" alt=\"img\">   <img src=\"https://img.shields.io/badge/%E5%90%8E%E7%AB%AF-%E6%A1%86%E6%9E%B6-success.svg\" alt=\"img\"></p>\n</blockquote>\n\n<h2 id=\"编程语言\"> 编程语言</h2>\n<ul>\n<li><a href=\"./java/\">Java</a></li>\n</ul>\n<h2 id=\"后端框架\"> 后端框架</h2>\n<ul>\n<li><a href=\"./backframe/spring.html\">Spring framework</a></li>\n</ul>\n",
      "image": "https://img.shields.io/badge/后端-编程语言-success.svg",
      "date_modified": "2021-02-08T17:34:42.000Z",
      "authors": [
        {
          "name": "南辞"
        }
      ],
      "tags": []
    },
    {
      "title": "Spring Security整合",
      "url": "http://qiqi.dreamagain.top/program/frontend/backframe/Spring%20Security/example/",
      "id": "http://qiqi.dreamagain.top/program/frontend/backframe/Spring%20Security/example/",
      "content_html": "<h1 id=\"spring-security\"> Spring Security</h1>\n<h1 id=\"spring-security整合\"> Spring Security整合</h1>\n<h2 id=\"一、创建spring-security模块\"> 一、创建spring_security模块</h2>\n<p><img src=\"Spring%20Security%E6%95%B4%E5%90%88.assets/423034c7-c21a-4555-8380-393ac7ebca4d.png\" alt=\"img\"></p>\n<h2 id=\"二、在spring-security中引入相关依赖\"> 二、在spring_security中引入相关依赖</h2>\n<div><pre><code><span><span><span>&lt;</span>dependencies</span><span>></span></span>\n    <span><span><span>&lt;</span>dependency</span><span>></span></span>\n        <span><span><span>&lt;</span>groupId</span><span>></span></span>com.atguigu<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n        <span><span><span>&lt;</span>artifactId</span><span>></span></span>common_utils<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n        <span><span><span>&lt;</span>version</span><span>></span></span>0.0.1-SNAPSHOT<span><span><span>&lt;/</span>version</span><span>></span></span>\n    <span><span><span>&lt;/</span>dependency</span><span>></span></span>\n    \n    <span>&lt;!-- Spring Security依赖 --></span>\n    <span><span><span>&lt;</span>dependency</span><span>></span></span>\n        <span><span><span>&lt;</span>groupId</span><span>></span></span>org.springframework.boot<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n        <span><span><span>&lt;</span>artifactId</span><span>></span></span>spring-boot-starter-security<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n    <span><span><span>&lt;/</span>dependency</span><span>></span></span>\n    <span><span><span>&lt;</span>dependency</span><span>></span></span>\n        <span><span><span>&lt;</span>groupId</span><span>></span></span>io.jsonwebtoken<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n        <span><span><span>&lt;</span>artifactId</span><span>></span></span>jjwt<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n    <span><span><span>&lt;/</span>dependency</span><span>></span></span>\n<span><span><span>&lt;/</span>dependencies</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><h2 id=\"三、在service-acl引入spring-security依赖\"> 三、在service_acl引入spring_security依赖</h2>\n<div><pre><code><span><span><span>&lt;</span>dependency</span><span>></span></span>\n    <span><span><span>&lt;</span>groupId</span><span>></span></span>com.nanci<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n    <span><span><span>&lt;</span>artifactId</span><span>></span></span>spring_security<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n    <span><span><span>&lt;</span>version</span><span>></span></span>0.0.1-SNAPSHOT<span><span><span>&lt;/</span>version</span><span>></span></span>\n<span><span><span>&lt;/</span>dependency</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p><strong>1、代码结构说明：</strong></p>\n<p>**<img src=\"Spring%20Security%E6%95%B4%E5%90%88.assets/6aafe337-8a5d-440c-b93d-ff60d4f9cef6.png\" alt=\"img\">\n**</p>\n<p><strong>2、创建spring security核心配置类</strong></p>\n<p><em><strong>*<img src=\"Spring%20Security%E6%95%B4%E5%90%88.assets/553c05a4-ff6d-456c-a5f6-ee9db5e6954a.png\" alt=\"img\">*</strong></em></p>\n<p>Spring Security的核心配置就是继承WebSecurityConfigurerAdapter并注解@EnableWebSecurity的配置。</p>\n<p>这个配置指明了用户名密码的处理方式、请求路径的开合、登录登出控制等和安全相关的配置</p>\n<div><pre><code><span>import</span> <span>com<span>.</span>atguigu<span>.</span>serurity<span>.</span>filter<span>.</span></span><span>TokenAuthenticationFilter</span><span>;</span>\n<span>import</span> <span>com<span>.</span>atguigu<span>.</span>serurity<span>.</span>filter<span>.</span></span><span>TokenLoginFilter</span><span>;</span>\n<span>import</span> <span>com<span>.</span>atguigu<span>.</span>serurity<span>.</span>security<span>.</span></span><span>DefaultPasswordEncoder</span><span>;</span>\n<span>import</span> <span>com<span>.</span>atguigu<span>.</span>serurity<span>.</span>security<span>.</span></span><span>TokenLogoutHandler</span><span>;</span>\n<span>import</span> <span>com<span>.</span>atguigu<span>.</span>serurity<span>.</span>security<span>.</span></span><span>TokenManager</span><span>;</span>\n<span>import</span> <span>com<span>.</span>atguigu<span>.</span>serurity<span>.</span>security<span>.</span></span><span>UnauthorizedEntryPoint</span><span>;</span>\n<span>import</span> <span>org<span>.</span>springframework<span>.</span>beans<span>.</span>factory<span>.</span>annotation<span>.</span></span><span>Autowired</span><span>;</span>\n<span>import</span> <span>org<span>.</span>springframework<span>.</span>context<span>.</span>annotation<span>.</span></span><span>Configuration</span><span>;</span>\n<span>import</span> <span>org<span>.</span>springframework<span>.</span>data<span>.</span>redis<span>.</span>core<span>.</span></span><span>RedisTemplate</span><span>;</span>\n<span>import</span> <span>org<span>.</span>springframework<span>.</span>security<span>.</span>config<span>.</span>annotation<span>.</span>authentication<span>.</span>builders<span>.</span></span><span>AuthenticationManagerBuilder</span><span>;</span>\n<span>import</span> <span>org<span>.</span>springframework<span>.</span>security<span>.</span>config<span>.</span>annotation<span>.</span>method<span>.</span>configuration<span>.</span></span><span>EnableGlobalMethodSecurity</span><span>;</span>\n<span>import</span> <span>org<span>.</span>springframework<span>.</span>security<span>.</span>config<span>.</span>annotation<span>.</span>web<span>.</span>builders<span>.</span></span><span>HttpSecurity</span><span>;</span>\n<span>import</span> <span>org<span>.</span>springframework<span>.</span>security<span>.</span>config<span>.</span>annotation<span>.</span>web<span>.</span>builders<span>.</span></span><span>WebSecurity</span><span>;</span>\n<span>import</span> <span>org<span>.</span>springframework<span>.</span>security<span>.</span>config<span>.</span>annotation<span>.</span>web<span>.</span>configuration<span>.</span></span><span>EnableWebSecurity</span><span>;</span>\n<span>import</span> <span>org<span>.</span>springframework<span>.</span>security<span>.</span>config<span>.</span>annotation<span>.</span>web<span>.</span>configuration<span>.</span></span><span>WebSecurityConfigurerAdapter</span><span>;</span>\n<span>import</span> <span>org<span>.</span>springframework<span>.</span>security<span>.</span>core<span>.</span>userdetails<span>.</span></span><span>UserDetailsService</span><span>;</span>\n<span>/**\n * &lt;p>\n * Security配置类\n * &lt;/p>\n */</span>\n<span>@Configuration</span>\n<span>@EnableWebSecurity</span>\n<span>@EnableGlobalMethodSecurity</span><span>(</span>prePostEnabled <span>=</span> <span>true</span><span>)</span>\n<span>public</span> <span>class</span> <span>TokenWebSecurityConfig</span> <span>extends</span> <span>WebSecurityConfigurerAdapter</span> <span>{</span>\n    <span>private</span> <span>UserDetailsService</span> userDetailsService<span>;</span>\n    <span>private</span> <span>TokenManager</span> tokenManager<span>;</span>\n    <span>private</span> <span>DefaultPasswordEncoder</span> defaultPasswordEncoder<span>;</span>\n    <span>private</span> <span>RedisTemplate</span> redisTemplate<span>;</span>\n    <span>@Autowired</span>\n    <span>public</span> <span>TokenWebSecurityConfig</span><span>(</span><span>UserDetailsService</span> userDetailsService<span>,</span> <span>DefaultPasswordEncoder</span> defaultPasswordEncoder<span>,</span>\n                                  <span>TokenManager</span> tokenManager<span>,</span> <span>RedisTemplate</span> redisTemplate<span>)</span> <span>{</span>\n        <span>this</span><span>.</span>userDetailsService <span>=</span> userDetailsService<span>;</span>\n        <span>this</span><span>.</span>defaultPasswordEncoder <span>=</span> defaultPasswordEncoder<span>;</span>\n        <span>this</span><span>.</span>tokenManager <span>=</span> tokenManager<span>;</span>\n        <span>this</span><span>.</span>redisTemplate <span>=</span> redisTemplate<span>;</span>\n    <span>}</span>\n    <span>/**\n     * 配置设置\n     * @param http\n     * @throws Exception\n     */</span>\n    <span>@Override</span>\n    <span>protected</span> <span>void</span> <span>configure</span><span>(</span><span>HttpSecurity</span> http<span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n        http<span>.</span><span>exceptionHandling</span><span>(</span><span>)</span>\n                <span>.</span><span>authenticationEntryPoint</span><span>(</span><span>new</span> <span>UnauthorizedEntryPoint</span><span>(</span><span>)</span><span>)</span>\n                <span>.</span><span>and</span><span>(</span><span>)</span><span>.</span><span>csrf</span><span>(</span><span>)</span><span>.</span><span>disable</span><span>(</span><span>)</span>\n                <span>.</span><span>authorizeRequests</span><span>(</span><span>)</span>\n                <span>.</span><span>anyRequest</span><span>(</span><span>)</span><span>.</span><span>authenticated</span><span>(</span><span>)</span>\n                <span>.</span><span>and</span><span>(</span><span>)</span><span>.</span><span>logout</span><span>(</span><span>)</span><span>.</span><span>logoutUrl</span><span>(</span><span>\"/admin/acl/index/logout\"</span><span>)</span>\n                <span>.</span><span>addLogoutHandler</span><span>(</span><span>new</span> <span>TokenLogoutHandler</span><span>(</span>tokenManager<span>,</span>redisTemplate<span>)</span><span>)</span><span>.</span><span>and</span><span>(</span><span>)</span>\n                <span>.</span><span>addFilter</span><span>(</span><span>new</span> <span>TokenLoginFilter</span><span>(</span><span>authenticationManager</span><span>(</span><span>)</span><span>,</span> tokenManager<span>,</span> redisTemplate<span>)</span><span>)</span>\n                <span>.</span><span>addFilter</span><span>(</span><span>new</span> <span>TokenAuthenticationFilter</span><span>(</span><span>authenticationManager</span><span>(</span><span>)</span><span>,</span> tokenManager<span>,</span> redisTemplate<span>)</span><span>)</span><span>.</span><span>httpBasic</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n    <span>/**\n     * 密码处理\n     * @param auth\n     * @throws Exception\n     */</span>\n    <span>@Override</span>\n    <span>public</span> <span>void</span> <span>configure</span><span>(</span><span>AuthenticationManagerBuilder</span> auth<span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n        auth<span>.</span><span>userDetailsService</span><span>(</span>userDetailsService<span>)</span><span>.</span><span>passwordEncoder</span><span>(</span>defaultPasswordEncoder<span>)</span><span>;</span>\n    <span>}</span>\n    <span>/**\n     * 配置哪些请求不拦截\n     * @param web\n     * @throws Exception\n     */</span>\n    <span>@Override</span>\n    <span>public</span> <span>void</span> <span>configure</span><span>(</span><span>WebSecurity</span> web<span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n        web<span>.</span><span>ignoring</span><span>(</span><span>)</span><span>.</span><span>antMatchers</span><span>(</span><span>\"/api/**\"</span><span>,</span>\n                <span>\"/swagger-resources/**\"</span><span>,</span> <span>\"/webjars/**\"</span><span>,</span> <span>\"/v2/**\"</span><span>,</span> <span>\"/swagger-ui.html/**\"</span>\n               <span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br></div></div><p><strong>5、创建认证授权相关的工具类</strong></p>\n<p><img src=\"Spring%20Security%E6%95%B4%E5%90%88.assets/75ccbeef-10c1-45fd-8f68-b598019832b1.png\" alt=\"img\"></p>\n<div><pre><code>（1）DefaultPasswordEncoder：密码处理的方法\n</code></pre>\n<div><span>1</span><br></div></div><div><pre><code>package com.atguigu.serurity.security;\nimport com.atguigu.commonutils.utils.MD5;\nimport org.springframework.security.crypto.password.PasswordEncoder;\nimport org.springframework.stereotype.Component;\n/**\n * &lt;p&gt;\n * 密码的处理方法类型\n * &lt;/p&gt;\n */\n@Component\npublic class DefaultPasswordEncoder implements PasswordEncoder {\n    public DefaultPasswordEncoder() {\n        this(-1);\n    }\n    /**\n     * @param strength\n     *            the log rounds to use, between 4 and 31\n     */\n    public DefaultPasswordEncoder(int strength) {\n    }\n    public String encode(CharSequence rawPassword) {\n        return MD5.encrypt(rawPassword.toString());\n    }\n    public boolean matches(CharSequence rawPassword, String encodedPassword) {\n        return encodedPassword.equals(MD5.encrypt(rawPassword.toString()));\n    }\n}\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div><p><em><em><em>*</em>*（2）********<code>TokenManager：token操作的工具类</code>******</em>*</em>*</p>\n<div><pre><code>import io.jsonwebtoken.CompressionCodecs;\nimport io.jsonwebtoken.Jwts;\nimport io.jsonwebtoken.SignatureAlgorithm;\nimport org.springframework.stereotype.Component;\nimport java.util.Date;\n/**\n * &lt;p&gt;\n * token管理\n * &lt;/p&gt;\n */\n@Component\npublic class TokenManager {\n    private long tokenExpiration = 24*60*60*1000;\n    private String tokenSignKey = &quot;123456&quot;;\n    public String createToken(String username) {\n        String token = Jwts.builder().setSubject(username)\n                .setExpiration(new Date(System.currentTimeMillis() + tokenExpiration))\n                .signWith(SignatureAlgorithm.HS512, tokenSignKey).compressWith(CompressionCodecs.GZIP).compact();\n        return token;\n    }\n    public String getUserFromToken(String token) {\n        String user = Jwts.parser().setSigningKey(tokenSignKey).parseClaimsJws(token).getBody().getSubject();\n        return user;\n    }\n    public void removeToken(String token) {\n        //jwttoken无需删除，客户端扔掉即可。\n    }\n}\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br></div></div><p><em><em><em>*</em>*（3）**********<code>TokenLogoutHandler：退出实现</code>**********\n**</em>*</em>*</p>\n<div><pre><code>import com.atguigu.commonutils.R;\nimport com.atguigu.commonutils.utils.ResponseUtil;\nimport org.springframework.data.redis.core.RedisTemplate;\nimport org.springframework.security.core.Authentication;\nimport org.springframework.security.web.authentication.logout.LogoutHandler;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n/**\n * &lt;p&gt;\n * 登出业务逻辑类\n * &lt;/p&gt;\n */\npublic class TokenLogoutHandler implements LogoutHandler {\n    private TokenManager tokenManager;\n    private RedisTemplate redisTemplate;\n    public TokenLogoutHandler(TokenManager tokenManager, RedisTemplate redisTemplate) {\n        this.tokenManager = tokenManager;\n        this.redisTemplate = redisTemplate;\n    }\n    @Override\n    public void logout(HttpServletRequest request, HttpServletResponse response, Authentication authentication) {\n        String token = request.getHeader(&quot;token&quot;);\n        if (token != null) {\n            tokenManager.removeToken(token);\n            //清空当前用户缓存中的权限数据\n            String userName = tokenManager.getUserFromToken(token);\n            redisTemplate.delete(userName);\n        }\n        ResponseUtil.out(response, R.ok());\n    }\n}\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br></div></div><p><em><strong>*（4）********<code>UnauthorizedEntryPoint：未授权统一处理</code>*********</strong></em></p>\n<div><pre><code>import com.atguigu.commonutils.R;\nimport com.atguigu.commonutils.utils.ResponseUtil;\nimport org.springframework.security.core.AuthenticationException;\nimport org.springframework.security.web.AuthenticationEntryPoint;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\n/**\n * &lt;p&gt;\n * 未授权的统一处理方式\n * &lt;/p&gt;\n */\npublic class UnauthorizedEntryPoint implements AuthenticationEntryPoint {\n    @Override\n    public void commence(HttpServletRequest request, HttpServletResponse response,\n                         AuthenticationException authException) throws IOException, ServletException {\n        ResponseUtil.out(response, R.error());\n    }\n}\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><p><strong><em>*</em>*********6、创建认证授权实体类**********\n****<img src=\"Spring%20Security%E6%95%B4%E5%90%88.assets/76236594-2238-4d28-a15e-7cf743bb53e2.png\" alt=\"img\">（1）SecutityUser*****</strong>*</p>\n<div><pre><code>import lombok.Data;\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.security.core.GrantedAuthority;\nimport org.springframework.security.core.authority.SimpleGrantedAuthority;\nimport org.springframework.security.core.userdetails.UserDetails;\nimport org.springframework.util.StringUtils;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.List;\n/**\n * &lt;p&gt;\n * 安全认证用户详情信息\n * &lt;/p&gt;\n */\n@Data\n@Slf4j\npublic class SecurityUser implements UserDetails {\n    //当前登录用户\n    private transient User currentUserInfo;\n    //当前权限\n    private List&lt;String&gt; permissionValueList;\n    public SecurityUser() {\n    }\n    public SecurityUser(User user) {\n        if (user != null) {\n            this.currentUserInfo = user;\n        }\n    }\n    @Override\n    public Collection&lt;? extends GrantedAuthority&gt; getAuthorities() {\n        Collection&lt;GrantedAuthority&gt; authorities = new ArrayList&lt;&gt;();\n        for(String permissionValue : permissionValueList) {\n            if(StringUtils.isEmpty(permissionValue)) continue;\n            SimpleGrantedAuthority authority = new SimpleGrantedAuthority(permissionValue);\n            authorities.add(authority);\n        }\n        return authorities;\n    }\n    @Override\n    public String getPassword() {\n        return currentUserInfo.getPassword();\n    }\n    @Override\n    public String getUsername() {\n        return currentUserInfo.getUsername();\n    }\n    @Override\n    public boolean isAccountNonExpired() {\n        return true;\n    }\n    @Override\n    public boolean isAccountNonLocked() {\n        return true;\n    }\n    @Override\n    public boolean isCredentialsNonExpired() {\n        return true;\n    }\n    @Override\n    public boolean isEnabled() {\n        return true;\n    }\n}\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br></div></div><p><em><em><em>*</em>*****（2）User******</em>*</em>*</p>\n<div><pre><code>import io.swagger.annotations.ApiModel;\nimport io.swagger.annotations.ApiModelProperty;\nimport lombok.Data;\nimport java.io.Serializable;\n/**\n * &lt;p&gt;\n * 用户实体类\n * &lt;/p&gt;\n */\n@Data\n@ApiModel(description = &quot;用户实体类&quot;)\npublic class User implements Serializable {\n    private static final long serialVersionUID = 1L;\n    @ApiModelProperty(value = &quot;微信openid&quot;)\n    private String username;\n    @ApiModelProperty(value = &quot;密码&quot;)\n    private String password;\n    @ApiModelProperty(value = &quot;昵称&quot;)\n    private String nickName;\n    @ApiModelProperty(value = &quot;用户头像&quot;)\n    private String salt;\n    @ApiModelProperty(value = &quot;用户签名&quot;)\n    private String token;\n}\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><p><strong><em>*</em>*******************7、创建认证和授权的filter**********\n**********<img src=\"Spring%20Security%E6%95%B4%E5%90%88.assets/bee4d171-befe-4b08-a792-5f1d50a8642b.png\" alt=\"img\">\n****（1）TokenLoginFilter：认证的filter*****</strong>*</p>\n<div><pre><code>import com.atguigu.commonutils.R;\nimport com.atguigu.commonutils.utils.ResponseUtil;\nimport com.atguigu.serurity.entity.SecurityUser;\nimport com.atguigu.serurity.entity.User;\nimport com.atguigu.serurity.security.TokenManager;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport org.springframework.data.redis.core.RedisTemplate;\nimport org.springframework.security.authentication.AuthenticationManager;\nimport org.springframework.security.authentication.UsernamePasswordAuthenticationToken;\nimport org.springframework.security.core.Authentication;\nimport org.springframework.security.core.AuthenticationException;\nimport org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;\nimport org.springframework.security.web.util.matcher.AntPathRequestMatcher;\nimport javax.servlet.FilterChain;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.util.ArrayList;\n/**\n * &lt;p&gt;\n * 登录过滤器，继承UsernamePasswordAuthenticationFilter，对用户名密码进行登录校验\n * &lt;/p&gt;\n */\npublic class TokenLoginFilter extends UsernamePasswordAuthenticationFilter {\n    private AuthenticationManager authenticationManager;\n    private TokenManager tokenManager;\n    private RedisTemplate redisTemplate;\n    public TokenLoginFilter(AuthenticationManager authenticationManager, TokenManager tokenManager, RedisTemplate redisTemplate) {\n        this.authenticationManager = authenticationManager;\n        this.tokenManager = tokenManager;\n        this.redisTemplate = redisTemplate;\n        this.setPostOnly(false);\n        this.setRequiresAuthenticationRequestMatcher(new AntPathRequestMatcher(&quot;/admin/acl/login&quot;,&quot;POST&quot;));\n    }\n    @Override\n    public Authentication attemptAuthentication(HttpServletRequest req, HttpServletResponse res)\n            throws AuthenticationException {\n        try {\n            User user = new ObjectMapper().readValue(req.getInputStream(), User.class);\n            return authenticationManager.authenticate(new UsernamePasswordAuthenticationToken(user.getUsername(), user.getPassword(), new ArrayList&lt;&gt;()));\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n    /**\n     * 登录成功\n     * @param req\n     * @param res\n     * @param chain\n     * @param auth\n     * @throws IOException\n     * @throws ServletException\n     */\n    @Override\n    protected void successfulAuthentication(HttpServletRequest req, HttpServletResponse res, FilterChain chain,\n                                            Authentication auth) throws IOException, ServletException {\n        SecurityUser user = (SecurityUser) auth.getPrincipal();\n        String token = tokenManager.createToken(user.getCurrentUserInfo().getUsername());\n        redisTemplate.opsForValue().set(user.getCurrentUserInfo().getUsername(), user.getPermissionValueList());\n        ResponseUtil.out(res, R.ok().data(&quot;token&quot;, token));\n    }\n    /**\n     * 登录失败\n     * @param request\n     * @param response\n     * @param e\n     * @throws IOException\n     * @throws ServletException\n     */\n    @Override\n    protected void unsuccessfulAuthentication(HttpServletRequest request, HttpServletResponse response,\n                                              AuthenticationException e) throws IOException, ServletException {\n        ResponseUtil.out(response, R.error());\n    }\n}\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br></div></div><p><strong><em>*</em>*******************************<code>（2）TokenAuthenticationFilter：</code>*********************************</strong>*</p>\n<div><pre><code>授权filter\n</code></pre>\n<div><span>1</span><br></div></div><div><pre><code>package com.atguigu.serurity.filter;\nimport com.atguigu.commonutils.R;\nimport com.atguigu.commonutils.utils.ResponseUtil;\nimport com.atguigu.serurity.security.TokenManager;\nimport org.springframework.data.redis.core.RedisTemplate;\nimport org.springframework.security.authentication.AuthenticationManager;\nimport org.springframework.security.authentication.UsernamePasswordAuthenticationToken;\nimport org.springframework.security.core.GrantedAuthority;\nimport org.springframework.security.core.authority.SimpleGrantedAuthority;\nimport org.springframework.security.core.context.SecurityContextHolder;\nimport org.springframework.security.web.authentication.www.BasicAuthenticationFilter;\nimport org.springframework.util.StringUtils;\nimport javax.servlet.FilterChain;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.List;\n/**\n * &lt;p&gt;\n * 访问过滤器\n * &lt;/p&gt;\n */\npublic class TokenAuthenticationFilter extends BasicAuthenticationFilter {\n    private TokenManager tokenManager;\n    private RedisTemplate redisTemplate;\n    public TokenAuthenticationFilter(AuthenticationManager authManager, TokenManager tokenManager,RedisTemplate redisTemplate) {\n        super(authManager);\n        this.tokenManager = tokenManager;\n        this.redisTemplate = redisTemplate;\n    }\n    @Override\n    protected void doFilterInternal(HttpServletRequest req, HttpServletResponse res, FilterChain chain)\n            throws IOException, ServletException {\n        logger.info(&quot;=================&quot;+req.getRequestURI());\n        if(req.getRequestURI().indexOf(&quot;admin&quot;) == -1) {\n            chain.doFilter(req, res);\n            return;\n        }\n        UsernamePasswordAuthenticationToken authentication = null;\n        try {\n            authentication = getAuthentication(req);\n        } catch (Exception e) {\n            ResponseUtil.out(res, R.error());\n        }\n        if (authentication != null) {\n            SecurityContextHolder.getContext().setAuthentication(authentication);\n        } else {\n            ResponseUtil.out(res, R.error());\n        }\n        chain.doFilter(req, res);\n    }\n    private UsernamePasswordAuthenticationToken getAuthentication(HttpServletRequest request) {\n        // token置于header里\n        String token = request.getHeader(&quot;token&quot;);\n        if (token != null &amp;&amp; !&quot;&quot;.equals(token.trim())) {\n            String userName = tokenManager.getUserFromToken(token);\n            List&lt;String&gt; permissionValueList = (List&lt;String&gt;) redisTemplate.opsForValue().get(userName);\n            Collection&lt;GrantedAuthority&gt; authorities = new ArrayList&lt;&gt;();\n            for(String permissionValue : permissionValueList) {\n                if(StringUtils.isEmpty(permissionValue)) continue;\n                SimpleGrantedAuthority authority = new SimpleGrantedAuthority(permissionValue);\n                authorities.add(authority);\n            }\n            if (!StringUtils.isEmpty(userName)) {\n                return new UsernamePasswordAuthenticationToken(userName, token, authorities);\n            }\n            return null;\n        }\n        return null;\n    }\n}\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br></div></div>",
      "date_published": "2021-01-13T00:00:00.000Z",
      "date_modified": "2021-02-08T17:34:42.000Z",
      "authors": [
        {
          "name": "南辞"
        }
      ],
      "tags": [
        "后端框架"
      ]
    },
    {
      "title": "Spring Security介绍",
      "url": "http://qiqi.dreamagain.top/program/frontend/backframe/Spring%20Security/intro/",
      "id": "http://qiqi.dreamagain.top/program/frontend/backframe/Spring%20Security/intro/",
      "content_html": "<h1 id=\"spring-security\"> Spring Security</h1>\n<h2 id=\"一、框架介绍\"> 一、框架介绍</h2>\n<p>Spring 是一个非常流行和成功的 Java 应用开发框架。Spring Security 基于 Spring 框架，提供了一套 Web 应用安全性的完整解决方案。一般来说，Web 应用的安全性包括**用户认证（Authentication）和用户授权（Authorization）**两个部分。</p>\n<p>（1）用户认证指的是：验证某个用户是否为系统中的合法主体，也就是说用户能否访问该系统。用户认证一般要求用户提供用户名和密码。系统通过校验用户名和密码来完成认证过程。</p>\n<p>（2）用户授权指的是验证某个用户是否有权限执行某个操作。在一个系统中，不同用户所具有的权限是不同的。比如对一个文件来说，有的用户只能进行读取，而有的用户可以进行修改。一般来说，系统会为不同的用户分配不同的角色，而每个角色则对应一系列的权限。</p>\n<p><strong>Spring Security其实就是用filter，对多请求的路径进行过滤。</strong></p>\n<p>（1）如果是基于Session，那么Spring Security会对cookie里的sessionid进行解析，找到服务器存储的sesion信息，然后判断当前用户是否符合请求的要求。</p>\n<p>（2）如果是token，则是解析出token，然后将当前请求加入到Spring Security管理的权限信息中去</p>\n<h2 id=\"二、认证与授权实现思路\"> 二、认证与授权实现思路</h2>\n<p>如果系统的模块众多，每个模块都需要进行授权与认证，可以选择基于token的形式进行授权与认证，用户根据用户名密码认证成功，然后获取当前用户角色的一系列权限值，并以用户名为key，权限列表为value的形式存入redis缓存中，根据用户名相关信息生成token返回，浏览器将token记录到cookie中，每次调用api接口都默认将token携带到header请求头中，Spring Security解析header头获取token信息，解析token获取当前用户名，根据用户名就可以从redis中获取权限列表，这样Spring Security就能够判断当前请求是否有权限访问。</p>\n<p>流程图：</p>\n<p><img src=\"intro.assets/image-20210202105449950.png\" alt=\"image-20210202105449950\"></p>\n<p>代码执行过程：</p>\n<p><img src=\"intro.assets/image-20210202105704682.png\" alt=\"image-20210202105704682\"></p>\n",
      "date_published": "2021-01-13T00:00:00.000Z",
      "date_modified": "2021-02-08T17:34:42.000Z",
      "authors": [
        {
          "name": "南辞"
        }
      ],
      "tags": [
        "后端框架"
      ]
    },
    {
      "title": "ORM相关框架",
      "url": "http://qiqi.dreamagain.top/program/frontend/backframe/orm/",
      "id": "http://qiqi.dreamagain.top/program/frontend/backframe/orm/",
      "content_html": "",
      "date_modified": "2021-02-08T17:34:42.000Z",
      "authors": [
        {
          "name": "南辞"
        }
      ],
      "tags": []
    },
    {
      "title": "后端框架",
      "url": "http://qiqi.dreamagain.top/program/frontend/backframe/",
      "id": "http://qiqi.dreamagain.top/program/frontend/backframe/",
      "summary": "<blockquote>\n<p><img src=\"https://img.shields.io/badge/%E6%A1%86%E6%9E%B6-Spring-blue.svg\" alt=\"img\">  <img src=\"https://img.shields.io/badge/%E6%A1%86%E6%9E%B6-SpringMVC-blue.svg\" alt=\"img\">  <img src=\"https://img.shields.io/badge/%E6%A1%86%E6%9E%B6-SpringBoot-blue.svg\" alt=\"img\">  <img src=\"https://img.shields.io/badge/%E6%A1%86%E6%9E%B6-SpringCloud-blue.svg\" alt=\"img\"> <img src=\"https://img.shields.io/badge/%E6%A1%86%E6%9E%B6-SpringSecurity-blue.svg\" alt=\"img\"></p>\n<p><img src=\"https://img.shields.io/badge/%E6%A1%86%E6%9E%B6-MyBatis-blue.svg\" alt=\"img\">  <img src=\"https://img.shields.io/badge/%E6%A1%86%E6%9E%B6-MyBatis--Plus-blue.svg\" alt=\"img\"></p>\n</blockquote>\n",
      "content_html": "<blockquote>\n<p><img src=\"https://img.shields.io/badge/%E6%A1%86%E6%9E%B6-Spring-blue.svg\" alt=\"img\">  <img src=\"https://img.shields.io/badge/%E6%A1%86%E6%9E%B6-SpringMVC-blue.svg\" alt=\"img\">  <img src=\"https://img.shields.io/badge/%E6%A1%86%E6%9E%B6-SpringBoot-blue.svg\" alt=\"img\">  <img src=\"https://img.shields.io/badge/%E6%A1%86%E6%9E%B6-SpringCloud-blue.svg\" alt=\"img\"> <img src=\"https://img.shields.io/badge/%E6%A1%86%E6%9E%B6-SpringSecurity-blue.svg\" alt=\"img\"></p>\n<p><img src=\"https://img.shields.io/badge/%E6%A1%86%E6%9E%B6-MyBatis-blue.svg\" alt=\"img\">  <img src=\"https://img.shields.io/badge/%E6%A1%86%E6%9E%B6-MyBatis--Plus-blue.svg\" alt=\"img\"></p>\n</blockquote>\n\n",
      "image": "https://img.shields.io/badge/框架-Spring-blue.svg",
      "date_published": "2019-09-10T00:00:00.000Z",
      "date_modified": "2021-02-08T17:34:42.000Z",
      "authors": [
        {
          "name": "南辞"
        }
      ],
      "tags": [
        "后端框架"
      ]
    },
    {
      "title": "Spring家族框架体系",
      "url": "http://qiqi.dreamagain.top/program/frontend/backframe/spring/",
      "id": "http://qiqi.dreamagain.top/program/frontend/backframe/spring/",
      "content_html": "",
      "date_modified": "2021-02-08T17:34:42.000Z",
      "authors": [
        {
          "name": "南辞"
        }
      ],
      "tags": []
    },
    {
      "title": "JavaScript",
      "url": "http://qiqi.dreamagain.top/program/frontend/js/",
      "id": "http://qiqi.dreamagain.top/program/frontend/js/",
      "content_html": "<h2 id=\"初学者教程\"> 初学者教程</h2>\n<ul>\n<li><a href=\"./../language/js/guide/\">快速上手</a></li>\n</ul>\n<h3 id=\"javascript-手册\"> JavaScript 手册</h3>\n<ul>\n<li><a href=\"./../language/js/\">JavaScript 学习教程</a></li>\n</ul>\n<h3 id=\"在线教程\"> 在线教程</h3>\n<ul>\n<li>\n<p><a href=\"http://www.w3school.com.cn/js/index.asp\" target=\"_blank\" rel=\"noopener noreferrer\">W3School 教程</a></p>\n</li>\n<li>\n<p><a href=\"https://www.runoob.com/js/js-tutorial.html\" target=\"_blank\" rel=\"noopener noreferrer\">菜鸟教程</a></p>\n</li>\n<li>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript\" target=\"_blank\" rel=\"noopener noreferrer\">MDN 教程</a></p>\n</li>\n</ul>\n<h3 id=\"es6\"> ES6</h3>\n<p>ES6 是 JavaScript 的 2015 标注，现已基本被广泛使用和支持；</p>\n<ul>\n<li><a href=\"./../language/js/es6/\">ES6 教程</a></li>\n</ul>\n<div><p>提示</p>\n<p>此教程由阮一峰老师书写(<strong>真·大佬</strong>)，建议深刻理解 JavaScript 原理(大概一年左右)之后再看。</p>\n</div>\n<blockquote>\n<p>开始下一章学习前，您需要跳转到 <a href=\"./../language/js/guide/\">JS 快速入门章节</a> 了解 JavaScript，或 <a href=\"./../language/js/\">深入学习 JavaScript</a> 后，方能进入 jQuery 学习。</p>\n</blockquote>\n",
      "date_published": "2019-09-01T00:00:00.000Z",
      "date_modified": "2021-02-08T17:34:42.000Z",
      "authors": [
        {
          "name": "南辞"
        }
      ],
      "tags": [
        "JavaScript"
      ]
    },
    {
      "title": "前端指南",
      "url": "http://qiqi.dreamagain.top/program/frontend/",
      "id": "http://qiqi.dreamagain.top/program/frontend/",
      "summary": "<blockquote>\n<p><img src=\"https://img.shields.io/badge/%E5%89%8D%E7%AB%AF-HTML-blue.svg\" alt=\"img\"> <img src=\"https://img.shields.io/badge/%E5%89%8D%E7%AB%AF-CSSL-blue.svg\" alt=\"img\"> <img src=\"https://img.shields.io/badge/%E5%89%8D%E7%AB%AF-JavaScript-blue.svg\" alt=\"img\"> <img src=\"https://img.shields.io/badge/%E5%89%8D%E7%AB%AF-jQuery-blue.svg\" alt=\"img\">  <img src=\"https://img.shields.io/badge/%E6%A1%86%E6%9E%B6-Vue-blue.svg\" alt=\"img\"> <img src=\"https://img.shields.io/badge/%E6%A1%86%E6%9E%B6-React-blue.svg\" alt=\"img\"> <img src=\"https://img.shields.io/badge/%E6%A1%86%E6%9E%B6-Angular-blue.svg\" alt=\"img\"></p>\n</blockquote>\n",
      "content_html": "<blockquote>\n<p><img src=\"https://img.shields.io/badge/%E5%89%8D%E7%AB%AF-HTML-blue.svg\" alt=\"img\"> <img src=\"https://img.shields.io/badge/%E5%89%8D%E7%AB%AF-CSSL-blue.svg\" alt=\"img\"> <img src=\"https://img.shields.io/badge/%E5%89%8D%E7%AB%AF-JavaScript-blue.svg\" alt=\"img\"> <img src=\"https://img.shields.io/badge/%E5%89%8D%E7%AB%AF-jQuery-blue.svg\" alt=\"img\">  <img src=\"https://img.shields.io/badge/%E6%A1%86%E6%9E%B6-Vue-blue.svg\" alt=\"img\"> <img src=\"https://img.shields.io/badge/%E6%A1%86%E6%9E%B6-React-blue.svg\" alt=\"img\"> <img src=\"https://img.shields.io/badge/%E6%A1%86%E6%9E%B6-Angular-blue.svg\" alt=\"img\"></p>\n</blockquote>\n\n<p>编写前端网页需要掌握三件套: <strong>HTML</strong>、<strong>CSS</strong> 和 <strong>JavaScript</strong>。</p>\n<ol>\n<li>HTML 定义了网页的内容</li>\n<li>CSS 描述了网页的样式</li>\n<li>JavaScript 编写网页的行为</li>\n</ol>\n<div><p>提示</p>\n<p>一个大型的网站，很少是直接使用原生代码写的。</p>\n<p>最新的网站大多数都是用三大框架(、、)搭建，并引入 npm 上的 UI 库编写而成。</p>\n<p>稍微老的网站会使用其他框架作为辅助，比如、等。</p>\n</div>\n<div><p>网页标准指定</p>\n<p>互联网网页标准由 W3C 组织制定，它的全称是万维网联盟组织。</p>\n</div>\n<h2 id=\"html\"> HTML</h2>\n<p>HTML 指的是超文本标记语言 (Hyper Text Markup Language)，描述了网页的骨架(具体结构)。</p>\n<ul>\n<li><a href=\"./html/\">HTML 教程</a></li>\n</ul>\n<h2 id=\"css\"> CSS</h2>\n<p>CSS 指层叠样式表 (Cascading Style Sheets)，声明了网页的样式(具体布局)。</p>\n<ul>\n<li><a href=\"./css/\">CSS 教程</a></li>\n</ul>\n<h2 id=\"emmet\"> Emmet</h2>\n<p>Emmet 是一种快速输入 HTML 和 CSS 的语法。</p>\n<ul>\n<li><a href=\"./emmet/\">Emmet 用法介绍</a></li>\n</ul>\n<h2 id=\"javascript\"> JavaScript</h2>\n<p>JavaScript 是一种编程语言，声明了网页的交互逻辑。</p>\n<p>JavaScript 是一种轻量级的编程语言，为可插入 HTML 页面的编程代码。所有现代的 HTML 页面都使用 JavaScript。</p>\n<ul>\n<li><a href=\"./js.html\">JS 教程</a></li>\n</ul>\n<h3 id=\"typescript\"> TypeScript</h3>\n<p>TypeScript 是 JavaScript 的一个超集，使得 JS 变成了一种强定义语言。TypeScript 由于其诸多优良特性，目前在前端的份额越来越大。</p>\n<ul>\n<li><a href=\"./../language/typescript/\">TypeScript 教程</a></li>\n</ul>\n<h2 id=\"node-js\"> Node.js</h2>\n<p>在深入了解并进行前端开发后，就避不开 Node。</p>\n<p>Node.js 是一款全球使用广泛的框架，可以用在前端与后端上，拥有大量的模块。Node.js 主要以其丰富并及其容易导入的 Node.js package，以及其方便管理 npm (Node.js Package Manager)闻名。</p>\n<ul>\n<li><a href=\"./src/program/language/node.js/\">Node.js 教程</a></li>\n</ul>\n<h2 id=\"历史前端框架\"> 历史前端框架</h2>\n<h3 id=\"jquery\"> jQuery</h3>\n<p>jQuery 是一个 JavaScript 库，极大地简化了 JavaScript 编程，很容易学习。</p>\n<p>jQuery 的优势在于它能够在互联网发展早期兼容各式各样的浏览器，并轻松的选定与操作 DOM。</p>\n<p>由于 NVVM 的兴起，目前 jQuery 已逐步被前端三大框架所取代。</p>\n<ul>\n<li>\n<p><a href=\"./jQuery/\">jQuery 教程</a></p>\n</li>\n<li>\n<p><a href=\"http://www.w3school.com.cn/jquery/index.asp\" target=\"_blank\" rel=\"noopener noreferrer\">W3School</a></p>\n</li>\n<li>\n<p><a href=\"https://www.runoob.com/jquery/jquery-tutorial.html\" target=\"_blank\" rel=\"noopener noreferrer\">菜鸟教程</a></p>\n</li>\n</ul>\n<h3 id=\"bootstrap4\"> Bootstrap4</h3>\n<p>Bootstrap 是全球最受欢迎的前端组件库，用于开发响应式布局、移动设备优先的 WEB 项目。</p>\n<p>Bootstrap 是一套用于 HTML、CSS 和 JS 开发的开源工具集。利用提供的 Sass 变量和大量 mixin、响应式栅格系统、可扩展的预制组件、基于 jQuery 的强大的插件系统，能够快速为您的想法开发出原型或者构建整个 app 。</p>\n<ul>\n<li>\n<p><a href=\"https://getbootstrap.com/docs/4.1/getting-started/introduction/\" target=\"_blank\" rel=\"noopener noreferrer\">bootstrap 官方文档</a></p>\n</li>\n<li>\n<p><a href=\"https://v4.bootcss.com/docs/4.0/getting-started/introduction/\" target=\"_blank\" rel=\"noopener noreferrer\">bootstrap 4.0 中文文档</a></p>\n</li>\n</ul>\n<h2 id=\"现代前端框架\"> 现代前端框架</h2>\n<h3 id=\"vue\"> Vue</h3>\n<p>Vue 是一套轻量化的前端渐进式框架框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。</p>\n<p>Vue 与 React、Angular 一起合称前端三大框架。</p>\n<ul>\n<li>\n<p><a href=\"./../vue/\">Vue 学习教程</a></p>\n</li>\n<li>\n<p><a href=\"https://cn.vuejs.org/v2/guide/\" target=\"_blank\" rel=\"noopener noreferrer\">Vue 官方文档</a></p>\n</li>\n</ul>\n<h3 id=\"react\"> React</h3>\n<ul>\n<li><a href=\"./src/program/webframe/react/\">React 教程</a></li>\n</ul>\n<h3 id=\"angular\"> Angular</h3>\n<ul>\n<li><a href=\"./../angular/\">Angular 教程</a></li>\n</ul>\n<h2 id=\"其他文档\"> 其他文档</h2>\n<ul>\n<li><a href=\"./https.html\">HTTPS 介绍</a></li>\n</ul>\n",
      "image": "https://img.shields.io/badge/前端-HTML-blue.svg",
      "date_published": "2019-09-01T00:00:00.000Z",
      "date_modified": "2021-02-08T17:34:42.000Z",
      "authors": [
        {
          "name": "南辞"
        }
      ],
      "tags": [
        "前端"
      ]
    },
    {
      "title": "编程开发",
      "url": "http://qiqi.dreamagain.top/program/",
      "id": "http://qiqi.dreamagain.top/program/",
      "summary": "<blockquote>\n<p><img src=\"https://img.shields.io/badge/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-blue.svg\" alt=\"\"> <img src=\"https://img.shields.io/badge/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80-blue.svg\" alt=\"\"> <img src=\"https://img.shields.io/badge/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91-blue.svg\" alt=\"\">  <img src=\"https://img.shields.io/badge/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91-blue.svg\" alt=\"\"> <img src=\"https://img.shields.io/badge/%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%91-blue.svg\" alt=\"\"> <img src=\"https://img.shields.io/badge/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91-blue.svg\" alt=\"\"> <img src=\"https://img.shields.io/badge/%E5%AD%A6%E4%B9%A0%E7%BD%91%E7%AB%99-blue.svg\" alt=\"\"></p>\n</blockquote>\n",
      "content_html": "<blockquote>\n<p><img src=\"https://img.shields.io/badge/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-blue.svg\" alt=\"\"> <img src=\"https://img.shields.io/badge/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80-blue.svg\" alt=\"\"> <img src=\"https://img.shields.io/badge/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91-blue.svg\" alt=\"\">  <img src=\"https://img.shields.io/badge/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91-blue.svg\" alt=\"\"> <img src=\"https://img.shields.io/badge/%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%91-blue.svg\" alt=\"\"> <img src=\"https://img.shields.io/badge/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91-blue.svg\" alt=\"\"> <img src=\"https://img.shields.io/badge/%E5%AD%A6%E4%B9%A0%E7%BD%91%E7%AB%99-blue.svg\" alt=\"\"></p>\n</blockquote>\n \n<h2 id=\"目录\"> 目录</h2>\n<ul>\n<li>\n<p><a href=\"./backend/\">后端开发</a></p>\n</li>\n<li>\n<p><a href=\"./frontend/\">前端开发</a></p>\n</li>\n</ul>\n<h2 id=\"编程学习网站\"> 编程学习网站</h2>\n<h3 id=\"优质网站\"> 优质网站</h3>\n<ul>\n<li>\n<p><a href=\"https://wangdoc.com/\" target=\"_blank\" rel=\"noopener noreferrer\">网道</a></p>\n</li>\n<li>\n<p><a href=\"https://www.liaoxuefeng.com/\" target=\"_blank\" rel=\"noopener noreferrer\">廖雪峰的网站</a></p>\n</li>\n<li>\n<p><a href=\"https://developer.mozilla.org/zh-CN/\" target=\"_blank\" rel=\"noopener noreferrer\">MDN</a></p>\n<div><p>相关信息</p>\n<p>MDN 的中文文档翻译很差，大多都是机翻，十分建议直接阅读英文文档。</p>\n</div>\n</li>\n</ul>\n<h3 id=\"杂牌网站\"> 杂牌网站</h3>\n<ul>\n<li>\n<p><a href=\"https://www.runoob.com/\" target=\"_blank\" rel=\"noopener noreferrer\">菜鸟教程</a> <i>Not supported content</i></p>\n</li>\n<li>\n<p><a href=\"https://www.w3cschool.cn\" target=\"_blank\" rel=\"noopener noreferrer\">w3cschool</a> <i>Not supported content</i> <i>Not supported content</i> <i>Not supported content</i></p>\n</li>\n<li>\n<p><a href=\"http://www.w3school.com.cn/\" target=\"_blank\" rel=\"noopener noreferrer\">w3school</a> <i>Not supported content</i></p>\n</li>\n</ul>\n",
      "image": "https://img.shields.io/badge/计算机基础-blue.svg",
      "date_modified": "2021-02-08T17:34:42.000Z",
      "authors": [
        {
          "name": "南辞"
        }
      ],
      "tags": [
        "编程开发"
      ]
    },
    {
      "title": "七七部落 | 主页",
      "url": "http://qiqi.dreamagain.top/",
      "id": "http://qiqi.dreamagain.top/",
      "content_html": "",
      "date_modified": "2021-02-07T07:26:30.000Z",
      "authors": [
        {
          "name": "南辞"
        }
      ],
      "tags": []
    }
  ]
}