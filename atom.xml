<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="zh-CN">
  <id>http://qiqi.dreamagain.top/</id>
  <title>七七部落</title>
  <subtitle>Actions speak louder than words.</subtitle>
  <author>
    <name>南辞</name>
  </author>
  <updated>2021-04-11T06:16:42.300Z</updated>
  <generator>@mr-hope/vuepress-plugin-feed</generator>
  <link rel="self" href="http://qiqi.dreamagain.top/atom.xml"/>
  <link rel="alternate" href="http://qiqi.dreamagain.top/"/>
  <rights>&lt;a href='https://github.com/small-universe/qiqi-tribe/blob/main/LICENSE' target='_blank'&gt;License MIT&lt;/a&gt; | Copyright © 2021 Mr·Yang『nanci』</rights>
  <category term="目录"/>
  <category term="电子书"/>
  <category term="使用指南"/>
  <category term="面试"/>
  <category term="后端框架"/>
  <category term="框架"/>
  <category term="Java"/>
  <category term="编程语言"/>
  <category term="JavaScript"/>
  <category term="前端"/>
  <category term="编程开发"/>
  <category term="数据库"/>
  <category term="软件使用"/>
  <category term="在线工具"/>
  <contributor>
    <name>南辞</name>
  </contributor>
  <contributor>
    <name>𝓜𝓻. 𝓗𝓸𝓹𝓮</name>
  </contributor>
  <entry>
    <title type="html">关于我</title>
    <id>http://qiqi.dreamagain.top/about/intro/</id>
    <link href="http://qiqi.dreamagain.top/about/intro/"/>
    <updated>2021-02-16T17:39:43.000Z</updated>
    <content type="html"><![CDATA[<h2 id="自我介绍"> 自我介绍</h2>
<ul>
<li>笔名: 南辞</li>
<li>性别: 男</li>
<li>年龄: 22</li>
<li>爱好: 编程</li>
</ul>
<h2 id="联系方式"> 联系方式</h2>
<p>qq：1715261428</p>
<p>邮箱：18846770224@163.com</p>
<p>希望能在圈子里认识更多朋友。欢迎大家留言交流。</p>
<h2 id="友情链接"> 友情链接</h2>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <contributor>
      <name>南辞</name>
    </contributor>
    <published>2021-02-16T17:39:43.000Z</published>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">关于本站</title>
    <id>http://qiqi.dreamagain.top/about/site/</id>
    <link href="http://qiqi.dreamagain.top/about/site/"/>
    <updated>2021-02-16T17:39:43.000Z</updated>
    <content type="html"><![CDATA[<h2 id="网站介绍"> 网站介绍</h2>
<p>网站使用 <a href="https://v1.vuepress.vuejs.org/zh/guide/" target="_blank" rel="noopener noreferrer">VuePress</a> 建站工具构建，主题使用 <a href="https://github.com/Mister-Hope/vuepress-theme-hope/" target="_blank" rel="noopener noreferrer">vuepress-theme-hope</a></p>
<h2 id="仓库链接"> 仓库链接</h2>
<ul>
<li><a href="https://github.com/small-universe/QiQi-Blog" target="_blank" rel="noopener noreferrer"><strong>QiQi-Blog</strong></a></li>
</ul>
<h2 id="免责声明"> 免责声明</h2>
<ul>
<li>本站内容均用于个人学习，有转载或参考的博客文章都已在每篇博客中声明，若有侵权请联系删除！</li>
</ul>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <contributor>
      <name>南辞</name>
    </contributor>
    <published>2021-02-16T17:39:43.000Z</published>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">Home</title>
    <id>http://qiqi.dreamagain.top/blog/</id>
    <link href="http://qiqi.dreamagain.top/blog/"/>
    <updated>2021-02-18T01:11:00.000Z</updated>
    <author>
      <name>南辞</name>
    </author>
    <contributor>
      <name>南辞</name>
    </contributor>
    <published>2021-02-16T17:39:43.000Z</published>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">目录导航</title>
    <id>http://qiqi.dreamagain.top/content/</id>
    <link href="http://qiqi.dreamagain.top/content/"/>
    <updated>2021-02-18T01:11:00.000Z</updated>
    <summary type="html"><![CDATA[<blockquote>
<p><img src="https://img.shields.io/badge/%E4%B8%83%E4%B8%83%E5%8D%9A%E5%AE%A2-%E7%9B%AE%E5%BD%95%E5%AF%BC%E8%88%AA-blue.svg" alt="img"></p>
</blockquote>
]]></summary>
    <content type="html"><![CDATA[<blockquote>
<p><img src="https://img.shields.io/badge/%E4%B8%83%E4%B8%83%E5%8D%9A%E5%AE%A2-%E7%9B%AE%E5%BD%95%E5%AF%BC%E8%88%AA-blue.svg" alt="img"></p>
</blockquote>

<h2 id="项目结构"> 项目结构</h2>
<div><pre><code>.
├──.github
|   └── workflows
|       └── deploy-github.yml(github action 用于持续部署)
|
├── src
│   ├── .vuepress 
│   │   ├── config 
|   |   |   ├── sideBar (侧边栏)
|   |   |   |   ├── backend
|   |   |   |   ├── frontend
|   |   |   |   ├── interview
|   |   |   |   ├── software
|   |   |   |   └── index.js
|   |   |   |
|   |   |   ├── navBar.js (导航栏)
|   |   |   └── private.js (私人设置，可在.gitignore中设置不加入版本管理)
│   │   |
│   │   ├── public (引用图片资源目录约定使用&quot;/&quot;为public目录)
|   |   |   └── assets
|   |   |       ├── icon
|   |   |       └── img
|   |   |
│   │   ├── styles (自定义主题的一些样式)
│   │   │   ├── base.styl
│   │   │   ├── index.styl
│   │   │   └── palette.styl
|   |   |
│   │   └── config.js (项目的配置)
│   │ 
│   ├── about
|   |   ├── intro.md
|   |   └── site.md
|   |  
│   ├── guide
|   |   ├── markdown.md
│   │   └── template.md
|   |
│   ├── interview
|   |   ├── Java208
│   │   └── readme.md
|   |
│   ├── program
|   |   ├── backend
│   │   └── readme.md
|   |
│   ├── blog.md (博客首页)
│   ├── content.md (目录导航)
│   └── readme.md (部落主页)
|   
├── .gitignore
├── deploy.sh (手动部署脚本)
├── package.json
└── package-lock.json
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br></div></div><h2 id="快速导航"> 快速导航</h2>
<p>侧边栏显示即为一级目录，点击查看相关内容</p>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <category term="目录"/>
    <contributor>
      <name>南辞</name>
    </contributor>
    <published>2021-02-16T17:39:43.000Z</published>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">阅览室</title>
    <id>http://qiqi.dreamagain.top/ebook/</id>
    <link href="http://qiqi.dreamagain.top/ebook/"/>
    <updated>2021-04-10T04:40:33.000Z</updated>
    <author>
      <name>南辞</name>
    </author>
    <category term="电子书"/>
    <contributor>
      <name>南辞</name>
    </contributor>
    <published>2021-04-10T04:40:33.000Z</published>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">element-ui插件使用文档</title>
    <id>http://qiqi.dreamagain.top/guide/element-ui-plugin/</id>
    <link href="http://qiqi.dreamagain.top/guide/element-ui-plugin/"/>
    <updated>2021-02-18T01:11:00.000Z</updated>
    <summary type="html"><![CDATA[<p><a href="https://www.npmjs.com/package/vuepress-plugin-element-ui" target="_blank" rel="noopener noreferrer"><img src="https://img.shields.io/npm/v/vuepress-plugin-element-ui.svg" alt="Version"></a> <a href="https://www.npmjs.com/package/vuepress-plugin-element-ui" target="_blank" rel="noopener noreferrer"><img src="https://img.shields.io/npm/l/vuepress-plugin-element-ui.svg" alt="License"></a> <img src="https://img.shields.io/badge/thanks-element-brightgreen.svg" alt="img"></p>
<p>Vuepress plugin - extend <a href="https://github.com/ElemeFE/element" target="_blank" rel="noopener noreferrer">Element UI</a> base on markdown-it-container</p>
]]></summary>
    <content type="html"><![CDATA[<p><a href="https://www.npmjs.com/package/vuepress-plugin-element-ui" target="_blank" rel="noopener noreferrer"><img src="https://img.shields.io/npm/v/vuepress-plugin-element-ui.svg" alt="Version"></a> <a href="https://www.npmjs.com/package/vuepress-plugin-element-ui" target="_blank" rel="noopener noreferrer"><img src="https://img.shields.io/npm/l/vuepress-plugin-element-ui.svg" alt="License"></a> <img src="https://img.shields.io/badge/thanks-element-brightgreen.svg" alt="img"></p>
<p>Vuepress plugin - extend <a href="https://github.com/ElemeFE/element" target="_blank" rel="noopener noreferrer">Element UI</a> base on markdown-it-container</p>

<h2 id="一、安装"> 一、安装</h2>
<blockquote>
<p>This plugin requires VuePress &gt;= 1.0.0, for now you can try it via yarn add vuepress@next -D</p>
</blockquote>
<div><pre><code><span>yarn</span> <span>add</span> vuepress-plugin-element-ui -D
// .vuepress/config.js
module.exports <span>=</span> <span>{</span>
  plugins: <span>[</span>
    <span>'element-ui'</span>
  <span>]</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h2 id="二、预览"> 二、预览</h2>
<h3 id="_1、el-tabs"> 1、el-tabs</h3>
<div><pre><code>:::: el-tabs
::: el-tab-pane label=markdown
<span>*</span> vue
  <span>*</span> vue-cli
  <span>*</span> nuxt
  <span>*</span> vuepress
<span>*</span> react
  <span>*</span> create-react-app
  <span>*</span> nest
:::
::: el-tab-pane label=javascript
<span><span>```</span><span> javascript</span>
<span><span>&lt;</span>span <span>class</span><span>=</span><span>"token punctuation"</span><span>></span><span>(</span><span>&lt;</span><span>/</span>span<span>></span><span>&lt;</span>span <span>class</span><span>=</span><span>"token punctuation"</span><span>></span><span>)</span><span>&lt;</span><span>/</span>span<span>></span> <span>&lt;</span>span <span>class</span><span>=</span><span>"token operator"</span><span>>=</span><span>></span><span>&lt;</span><span>/</span>span<span>></span> <span>&lt;</span>span <span>class</span><span>=</span><span>"token punctuation"</span><span>></span><span>{</span><span>&lt;</span><span>/</span>span<span>></span>
  console<span>&lt;</span>span <span>class</span><span>=</span><span>"token punctuation"</span><span>></span><span>.</span><span>&lt;</span><span>/</span>span<span>></span><span>&lt;</span>span <span>class</span><span>=</span><span>"token function"</span><span>></span>log<span>&lt;</span><span>/</span>span<span>></span><span>&lt;</span>span <span>class</span><span>=</span><span>"token punctuation"</span><span>></span><span>(</span><span>&lt;</span><span>/</span>span<span>></span><span>&lt;</span>span <span>class</span><span>=</span><span>"token string"</span><span>></span><span>'Javascript code example'</span><span>&lt;</span><span>/</span>span<span>></span><span>&lt;</span>span <span>class</span><span>=</span><span>"token punctuation"</span><span>></span><span>)</span><span>&lt;</span><span>/</span>span<span>></span>
<span>&lt;</span>span <span>class</span><span>=</span><span>"token punctuation"</span><span>></span><span>}</span><span>&lt;</span><span>/</span>span<span>></span></span>
<span>```</span></span>
:::
::::
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><el-tabs >
<el-tab-pane label=markdown>
<ul>
<li>vue
<ul>
<li>vue-cli</li>
<li>nuxt</li>
<li>vuepress</li>
</ul>
</li>
<li>react
<ul>
<li>create-react-app</li>
<li>nest</li>
</ul>
</li>
</ul>
</el-tab-pane>
<el-tab-pane label=javascript>
<div><pre><code><span>(</span><span>)</span> <span>=></span> <span>{</span>
  console<span>.</span><span>log</span><span>(</span><span>'Javascript code example'</span><span>)</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><div><p>注意</p>
<p>这里左右两侧图标有轻微遮挡，影响美观，应该需要在源码中调整z-index 属性。但不影响使用，这里暂且不对源码动刀了</p>
</div>
</el-tab-pane>
</el-tabs>
<h3 id="_2、el-collapses"> 2、el-collapses</h3>
<div><pre><code>:::: el-collapse
::: el-collapse-item title="一致性 Consistency"
与现实生活一致：与现实生活的流程、逻辑保持一致，遵循用户习惯的语言和概念；
在界面中一致：所有的元素和结构需保持一致，比如：设计样式、图标和文本、元素的位置等。
:::
::: el-collapse-item title="反馈 Feedback"
控制反馈：通过界面样式和交互动效让用户可以清晰的感知自己的操作；
页面反馈：操作后，通过页面元素的变化清晰地展现当前状态。
:::
::: el-collapse-item title="效率 Efficiency"
简化流程：设计简洁直观的操作流程；
清晰明确：语言表达清晰且表意明确，让用户快速理解进而作出决策；
帮助用户识别：界面简单直白，让用户快速识别而非回忆，减少用户记忆负担。
:::
::: el-collapse-item title="可控 Controllability"
用户决策：根据场景可给予用户操作建议或安全提示，但不能代替用户进行决策；
结果可控：用户可以自由的进行操作，包括撤销、回退和终止当前操作等。
:::
::::
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><el-collapse >
<el-collapse-item title="一致性 Consistency">
<p>与现实生活一致：与现实生活的流程、逻辑保持一致，遵循用户习惯的语言和概念；</p>
<p>在界面中一致：所有的元素和结构需保持一致，比如：设计样式、图标和文本、元素的位置等。</p>
</el-collapse-item>
<el-collapse-item title="反馈 Feedback">
<p>控制反馈：通过界面样式和交互动效让用户可以清晰的感知自己的操作；</p>
<p>页面反馈：操作后，通过页面元素的变化清晰地展现当前状态。</p>
</el-collapse-item>
<el-collapse-item title="效率 Efficiency">
<p>简化流程：设计简洁直观的操作流程；</p>
<p>清晰明确：语言表达清晰且表意明确，让用户快速理解进而作出决策；</p>
<p>帮助用户识别：界面简单直白，让用户快速识别而非回忆，减少用户记忆负担。</p>
</el-collapse-item>
<el-collapse-item title="可控 Controllability">
<p>用户决策：根据场景可给予用户操作建议或安全提示，但不能代替用户进行决策；</p>
<p>结果可控：用户可以自由的进行操作，包括撤销、回退和终止当前操作等。</p>
</el-collapse-item>
</el-collapse>
<h3 id="_3、el-steps"> 3、el-steps</h3>
<div><pre><code>:::: el-steps
::: el-step title=&quot;步骤 11&quot; icon=&quot;el-icon-edit&quot;
:::
::: el-step title=&quot;步骤 2&quot; icon=&quot;el-icon-upload&quot;
:::
::: el-step title=&quot;步骤 3&quot; icon=&quot;el-icon-picture&quot;
:::
::::
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><el-steps style="height: 300px;" active="2">
<el-step title="步骤 1" icon="el-icon-edit" description="这是一段很长很长很长的描述性文字">
</el-step>
<el-step title="步骤 2" icon="el-icon-upload">
<p>第二步：XXX</p>
</el-step>
<el-step title="步骤 3" icon="el-icon-picture">
<p>第三步：XXX</p>
</el-step>
</el-steps>
<h3 id="_4、all-componenets"> 4、All Componenets</h3>
<p>you can use all of element-ui components in below:</p>
<div><pre><code>  &#39;el-collapse-transition&#39;, &#39;el-pagination&#39;,      &#39;el-dialog&#39;,
  &#39;el-autocomplete&#39;,        &#39;el-dropdown&#39;,        &#39;el-dropdown-menu&#39;,
  &#39;el-dropdown-item&#39;,       &#39;el-menu&#39;,            &#39;el-submenu&#39;,
  &#39;el-menu-item&#39;,           &#39;el-menu-item-group&#39;, &#39;el-input&#39;,
  &#39;el-input-number&#39;,        &#39;el-radio&#39;,           &#39;el-radio-group&#39;,
  &#39;el-radio-button&#39;,        &#39;el-checkbox&#39;,        &#39;el-checkbox-button&#39;,
  &#39;el-checkbox-group&#39;,      &#39;el-switch&#39;,          &#39;el-select&#39;,
  &#39;el-option&#39;,              &#39;el-option-group&#39;,    &#39;el-button&#39;,
  &#39;el-button-group&#39;,        &#39;el-table&#39;,           &#39;el-table-column&#39;,
  &#39;el-date-picker&#39;,         &#39;el-time-select&#39;,     &#39;el-time-picker&#39;,
  &#39;el-popover&#39;,             &#39;el-tooltip&#39;,         &#39;el-breadcrumb&#39;,
  &#39;el-breadcrumb-item&#39;,     &#39;el-form&#39;,            &#39;el-form-item&#39;,
  &#39;el-tabs&#39;,                &#39;el-tab-pane&#39;,        &#39;el-tag&#39;,
  &#39;el-tree&#39;,                &#39;el-alert&#39;,           &#39;el-slider&#39;,
  &#39;el-icon&#39;,                &#39;el-row&#39;,             &#39;el-col&#39;,
  &#39;el-upload&#39;,              &#39;el-progress&#39;,        &#39;el-spinner&#39;,
  &#39;el-badge&#39;,               &#39;el-card&#39;,            &#39;el-rate&#39;,
  &#39;el-steps&#39;,               &#39;el-step&#39;,            &#39;el-carousel&#39;,
  &#39;el-scrollbar&#39;,           &#39;el-carousel-item&#39;,   &#39;el-collapse&#39;,
  &#39;el-collapse-item&#39;,       &#39;el-cascader&#39;,        &#39;el-color-picker&#39;,
  &#39;el-transfer&#39;,            &#39;el-container&#39;,       &#39;el-header&#39;,
  &#39;el-aside&#39;,               &#39;el-main&#39;,            &#39;el-footer&#39;,
  &#39;el-timeline&#39;,            &#39;el-timeline-item&#39;,   &#39;el-link&#39;,
  &#39;el-divider&#39;,             &#39;el-image&#39;,           &#39;el-calendar&#39;,
  &#39;el-backtop&#39;,             &#39;el-page-header&#39;,     &#39;el-cascader-panel&#39;,
  &#39;el-avatar&#39;,              &#39;el-drawer&#39;,          &#39;el-popconfirm&#39;
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><p>当然，你可以直接在Markdown中使用element标签，因为 vuepress是使用vue-loader来编译markdown的</p>
<div><pre><code>&lt;el-tag&gt;标签一&lt;/el-tag&gt;
&lt;el-tag type=&quot;success&quot;&gt;标签二&lt;/el-tag&gt;
&lt;el-tag type=&quot;info&quot;&gt;标签三&lt;/el-tag&gt;
&lt;el-tag type=&quot;warning&quot;&gt;标签四&lt;/el-tag&gt;
&lt;el-tag type=&quot;danger&quot;&gt;标签五&lt;/el-tag&gt;
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><el-tag>标签一</el-tag>
<el-tag type="success">标签二</el-tag>
<el-tag type="info">标签三</el-tag>
<el-tag type="warning">标签四</el-tag>
<el-tag type="danger">标签五</el-tag>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <category term="使用指南"/>
    <contributor>
      <name>南辞</name>
    </contributor>
    <published>2021-02-16T17:39:43.000Z</published>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">Markdown指南</title>
    <id>http://qiqi.dreamagain.top/guide/markdown/</id>
    <link href="http://qiqi.dreamagain.top/guide/markdown/"/>
    <updated>2021-02-18T01:11:00.000Z</updated>
    <summary type="html"><![CDATA[<blockquote>
<p><code>vuepress-theme-hope</code> 通过内置 <a href="https://vuepress-md-enhance.mrhope.site" target="_blank" rel="noopener noreferrer">md-enhance</a>，在 Markdown 中启用了更多的语法与新功能。</p>
</blockquote>
]]></summary>
    <content type="html"><![CDATA[<blockquote>
<p><code>vuepress-theme-hope</code> 通过内置 <a href="https://vuepress-md-enhance.mrhope.site" target="_blank" rel="noopener noreferrer">md-enhance</a>，在 Markdown 中启用了更多的语法与新功能。</p>
</blockquote>

<h2 id="一键启用"> 一键启用</h2>
<p>你可以设置 <code>themeconfig.mdEnhance.enableAll</code> 启用 <a href="https://vuepress-md-enhance.mrhope.site" target="_blank" rel="noopener noreferrer">md-enhance</a> 插件的所有功能。</p>
<div><div><br><br><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><br><br><br></div><pre><code>module<span>.</span>exports <span>=</span> <span>{</span>
    themeConfig<span>:</span> <span>{</span>
        mdEnhance<span>:</span> <span>{</span>
            enableAll<span>:</span> <span>true</span><span>,</span>
        <span>}</span><span>,</span>
    <span>}</span><span>,</span>
<span>}</span><span>;</span>
</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h2 id="新增的更多语法"> 新增的更多语法</h2>
<h3 id="上下角标"> 上下角标</h3>
<p>19<sup>th</sup> H<sub>2</sub>O</p>
<details><summary>代码</summary>
<div><pre><code>19^th^ H<span><span>~</span><span>2</span><span>~</span></span>O
</code></pre>
<div><span>1</span><br></div></div></details>
<ul>
<li><a href="https://vuepress-theme.mrhope.site/zh/guide/feature/markdown/sup-sub/" target="_blank" rel="noopener noreferrer">点击查看</a></li>
</ul>
<h3 id="自定义对齐"> 自定义对齐</h3>
<div>
<p>我是居中的</p>
</div>
<div>
<p>我在右对齐</p>
</div>
<details><summary>代码</summary>
<div><pre><code>::: center
我是居中的
:::

::: right
我在右对齐
:::
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div></details>
<ul>
<li><a href="https://vuepress-theme.mrhope.site/zh/guide/feature/markdown/align/" target="_blank" rel="noopener noreferrer">点击查看</a></li>
</ul>
<h3 id="脚注"> 脚注</h3>
<p>此文字有脚注<sup></sup>.</p>
<details><summary>代码</summary>
<div><pre><code>此文字有脚注[^first].

<span><span>[</span><span>^first</span><span>]</span><span>:</span> 这是脚注内容</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div></details>
<ul>
<li><a href="https://vuepress-theme.mrhope.site/zh/guide/feature/markdown/footnote/" target="_blank" rel="noopener noreferrer">点击查看</a></li>
</ul>
<h3 id="标记"> 标记</h3>
<p>你可以标记 <mark>重要的内容</mark> 。</p>
<details><summary>代码</summary>
<div><pre><code>你可以标记 ==重要的内容== 。
</code></pre>
<div><span>1</span><br></div></div></details>
<ul>
<li><a href="https://vuepress-theme.mrhope.site/zh/guide/feature/markdown/mark/" target="_blank" rel="noopener noreferrer">点击查看</a></li>
</ul>
<h3 id="流程图"> 流程图</h3>
<i>Not supported content</i><details><summary>代码</summary>
<div><pre><code>@flowstart
cond=>condition: Process?
process=>operation: Process
e=>end: End

cond(yes)->process->e
cond(no)->e
@flowend
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div></details>
<ul>
<li><a href="https://vuepress-theme.mrhope.site/zh/guide/feature/markdown/flowchart/" target="_blank" rel="noopener noreferrer">点击查看</a></li>
</ul>
<h3 id="tex-语法"> Tex 语法</h3>
<p class='katex-block'><span><span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:2.40003em;vertical-align:-0.95003em;"></span><span><span></span><span><span><span><span style="height:1.37144em;"><span style="top:-2.314em;"><span style="height:3em;"></span><span><span style="margin-right:0.05556em;">∂</span><span><span style="margin-right:0.03588em;">ω</span><span><span><span><span style="height:0.590392em;"><span style="top:-2.9890000000000003em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span style="margin-right:0.02778em;">r</span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span style="height:3em;"></span><span style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span style="height:3em;"></span><span><span><span style="margin-right:0.05556em;">∂</span><span><span><span><span style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span style="margin-right:0.02778em;">r</span></span></span></span></span></span></span></span></span></span></span><span>​</span></span><span><span style="height:0.686em;"><span></span></span></span></span></span><span></span></span><span style="margin-right:0.16666666666666666em;"></span><span><span style="top:0em;"><span>(</span></span><span><span></span><span><span><span><span style="height:1.341392em;"><span style="top:-2.314em;"><span style="height:3em;"></span><span><span style="margin-right:0.03588em;">ω</span></span></span><span style="top:-3.23em;"><span style="height:3em;"></span><span style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span style="height:3em;"></span><span><span><span style="margin-right:0.03588em;">y</span><span><span><span><span style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span><span style="margin-right:0.03588em;">ω</span></span></span></span></span></span></span></span></span></span></span></span><span>​</span></span><span><span style="height:0.686em;"><span></span></span></span></span></span><span></span></span><span style="top:0em;"><span>)</span></span></span><span style="margin-right:0.2777777777777778em;"></span><span>=</span><span style="margin-right:0.2777777777777778em;"></span></span><span><span style="height:3.027669em;vertical-align:-1.277669em;"></span><span><span style="top:0em;"><span>(</span></span><span><span></span><span><span><span><span style="height:1.341392em;"><span style="top:-2.314em;"><span style="height:3em;"></span><span><span style="margin-right:0.03588em;">ω</span></span></span><span style="top:-3.23em;"><span style="height:3em;"></span><span style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span style="height:3em;"></span><span><span><span style="margin-right:0.03588em;">y</span><span><span><span><span style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span><span style="margin-right:0.03588em;">ω</span></span></span></span></span></span></span></span></span></span></span></span><span>​</span></span><span><span style="height:0.686em;"><span></span></span></span></span></span><span></span></span><span style="top:0em;"><span>)</span></span></span><span style="margin-right:0.16666666666666666em;"></span><span><span style="top:0em;"><span>{</span></span><span>(</span><span>lo<span style="margin-right:0.01389em;">g</span></span><span style="margin-right:0.16666666666666666em;"></span><span style="margin-right:0.03588em;">y</span><span><span>)</span><span><span><span><span style="height:0.7143919999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span style="margin-right:0.02778em;">r</span></span></span></span></span></span></span></span><span style="margin-right:0.2222222222222222em;"></span><span>+</span><span style="margin-right:0.2222222222222222em;"></span><span><span><span><span style="height:1.6513970000000002em;"><span style="top:-1.872331em;margin-left:0em;"><span style="height:3.05em;"></span><span><span><span>i</span><span>=</span><span>1</span></span></span></span><span style="top:-3.050005em;"><span style="height:3.05em;"></span><span><span>∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span style="height:3.05em;"></span><span><span style="margin-right:0.02778em;">r</span></span></span></span><span>​</span></span><span><span style="height:1.277669em;"><span></span></span></span></span></span><span style="margin-right:0.16666666666666666em;"></span><span><span></span><span><span><span><span style="height:1.5016639999999999em;"><span style="top:-2.314em;"><span style="height:3em;"></span><span><span><span style="margin-right:0.03588em;">ω</span><span><span><span><span style="height:0.750664em;"><span style="top:-2.9890000000000003em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>i</span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span style="height:3em;"></span><span style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span style="height:3em;"></span><span><span>(</span><span>−</span><span>1</span><span><span>)</span><span><span><span><span style="height:0.824664em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>i</span></span></span></span></span></span></span></span><span style="margin-right:0.02778em;">r</span><span style="margin-right:0.16666666666666666em;"></span><span>⋯</span><span style="margin-right:0.16666666666666666em;"></span><span>(</span><span style="margin-right:0.02778em;">r</span><span style="margin-right:0.2222222222222222em;"></span><span>−</span><span style="margin-right:0.2222222222222222em;"></span><span>i</span><span style="margin-right:0.2222222222222222em;"></span><span>+</span><span style="margin-right:0.2222222222222222em;"></span><span>1</span><span>)</span><span>(</span><span>lo<span style="margin-right:0.01389em;">g</span></span><span style="margin-right:0.16666666666666666em;"></span><span style="margin-right:0.03588em;">y</span><span><span>)</span><span><span><span><span style="height:0.824664em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span><span style="margin-right:0.02778em;">r</span><span>−</span><span>i</span></span></span></span></span></span></span></span></span></span></span></span><span>​</span></span><span><span style="height:0.686em;"><span></span></span></span></span></span><span></span></span><span style="top:0em;"><span>}</span></span></span></span></span></span></span></p>
<details><summary>代码</summary>
<div><pre><code>$$
\frac {\partial^r} {\partial \omega^r} \left(\frac {y^{\omega}} {\omega}\right)
= \left(\frac {y^{\omega}} {\omega}\right) \left\{(\log y)^r + \sum_{i=1}^r \frac {(-1)^i r \cdots (r-i+1) (\log y)^{r-i}} {\omega^i} \right\}
$$
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div></details>
<ul>
<li><a href="https://vuepress-theme.mrhope.site/zh/guide/feature/markdown/tex/" target="_blank" rel="noopener noreferrer">点击查看</a></li>
</ul>
<h3 id="代码案例"> 代码案例</h3>

          <div
            id="code-demo-40b08364"
           
  
 data-title="%E4%B8%80%E4%B8%AA%E6%99%AE%E9%80%9A%20Demo"

            data-code="%7B%22html%22%3A%22%3Ch1%3EMr.Hope%3C%2Fh1%3E%5Cn%3Cp%3E%3Cspan%20id%3D%5C%22very%5C%22%3E%E5%8D%81%E5%88%86%3C%2Fspan%3E%20%E5%B8%85%3C%2Fp%3E%5Cn%22%2C%22js%22%3A%22document.querySelector(%5C%22%23very%5C%22).addEventListener(%5C%22click%5C%22%2C%20()%20%3D%3E%20%7B%5Cn%20%20%20%20alert(%5C%22%E5%8D%81%E5%88%86%E5%B8%85%5C%22)%3B%5Cn%7D)%3B%5Cn%22%2C%22css%22%3A%22span%20%7B%5Cn%20%20%20%20color%3A%20red%3B%5Cn%7D%5Cn%22%7D"
          >
              <div>
                
              </div>
              <div>
                <div>
<div><pre><code><span><span><span>&lt;</span>h1</span><span>></span></span>Mr.Hope<span><span><span>&lt;/</span>h1</span><span>></span></span>
<span><span><span>&lt;</span>p</span><span>></span></span><span><span><span>&lt;</span>span</span> <span>id</span><span><span>=</span><span>"</span>very<span>"</span></span><span>></span></span>十分<span><span><span>&lt;/</span>span</span><span>></span></span> 帅<span><span><span>&lt;/</span>p</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><div><pre><code>document<span>.</span><span>querySelector</span><span>(</span><span>"#very"</span><span>)</span><span>.</span><span>addEventListener</span><span>(</span><span>"click"</span><span>,</span> <span>(</span><span>)</span> <span>=></span> <span>{</span>
    <span>alert</span><span>(</span><span>"十分帅"</span><span>)</span><span>;</span>
<span>}</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><div><pre><code><span>span</span> <span>{</span>
    <span>color</span><span>:</span> red<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div>
            </div>
          </div>
          
        </div>
<details><summary>代码</summary>
<div><pre><code>::: demo 一个普通 Demo

​```html
<span><span><span>&lt;</span>h1</span><span>></span></span>Mr.Hope<span><span><span>&lt;/</span>h1</span><span>></span></span>
<span><span><span>&lt;</span>p</span><span>></span></span><span><span><span>&lt;</span>span</span> <span>id</span><span><span>=</span><span>"</span>very<span>"</span></span><span>></span></span>十分<span><span><span>&lt;/</span>span</span><span>></span></span> 帅<span><span><span>&lt;/</span>p</span><span>></span></span>
<span><span>```</span>
<span>
```js
document.querySelector("#very").addEventListener("click", () => {
  alert("十分帅");
});</span>
<span>```</span></span>

<span><span>```</span><span>css</span>
<span><span>&lt;span>span&lt;/span> &lt;span></span><span>{</span>&lt;/span>
  &lt;span class=<span>"token property"</span>>color&lt;/span>&lt;span class=<span>"token punctuation"</span>><span>:</span>&lt;/span> red&lt;span class=<span>"token punctuation"</span>><span>;</span>&lt;/span>
&lt;span class=<span>"token punctuation"</span>><span>}</span>&lt;/span></span>
<span>```</span></span>

:::



:::: details 代码

<span><span>```</span><span>`md</span>
<span>::: demo [react] 一个 React Demo

​```js
export default class App extends React.Component {
  constructor(props) {
    super(props);
    this.state = { message: "十分帅" };
  }
  render() {
    return (
      <span><span><span>&lt;</span>span</span> <span>class</span><span><span>=</span><span>"</span>token tag<span>"</span></span><span>></span></span><span><span><span>&lt;</span>span</span> <span>class</span><span><span>=</span><span>"</span>token tag<span>"</span></span><span>></span></span><span><span><span>&lt;</span>span</span> <span>class</span><span><span>=</span><span>"</span>token punctuation<span>"</span></span><span>></span></span>&lt;<span><span><span>&lt;/</span>span</span><span>></span></span>div<span><span><span>&lt;/</span>span</span><span>></span></span> <span><span><span>&lt;</span>span</span> <span>class</span><span><span>=</span><span>"</span>token attr-name<span>"</span></span><span>></span></span>className<span><span><span>&lt;/</span>span</span><span>></span></span><span><span><span>&lt;</span>span</span> <span>class</span><span><span>=</span><span>"</span>token attr-value<span>"</span></span><span>></span></span><span><span><span>&lt;</span>span</span> <span>class</span><span><span>=</span><span>"</span>token punctuation attr-equals<span>"</span></span><span>></span></span>=<span><span><span>&lt;/</span>span</span><span>></span></span><span><span><span>&lt;</span>span</span> <span>class</span><span><span>=</span><span>"</span>token punctuation<span>"</span></span><span>></span></span>"<span><span><span>&lt;/</span>span</span><span>></span></span>box-react<span><span><span>&lt;</span>span</span> <span>class</span><span><span>=</span><span>"</span>token punctuation<span>"</span></span><span>></span></span>"<span><span><span>&lt;/</span>span</span><span>></span></span><span><span><span>&lt;/</span>span</span><span>></span></span><span><span><span>&lt;</span>span</span> <span>class</span><span><span>=</span><span>"</span>token punctuation<span>"</span></span><span>></span></span>><span><span><span>&lt;/</span>span</span><span>></span></span><span><span><span>&lt;/</span>span</span><span>></span></span>
        Mr.Hope <span><span><span>&lt;</span>span</span> <span>class</span><span><span>=</span><span>"</span>token tag<span>"</span></span><span>></span></span><span><span><span>&lt;</span>span</span> <span>class</span><span><span>=</span><span>"</span>token tag<span>"</span></span><span>></span></span><span><span><span>&lt;</span>span</span> <span>class</span><span><span>=</span><span>"</span>token punctuation<span>"</span></span><span>></span></span>&lt;<span><span><span>&lt;/</span>span</span><span>></span></span>span<span><span><span>&lt;/</span>span</span><span>></span></span><span><span><span>&lt;</span>span</span> <span>class</span><span><span>=</span><span>"</span>token punctuation<span>"</span></span><span>></span></span>><span><span><span>&lt;/</span>span</span><span>></span></span><span><span><span>&lt;/</span>span</span><span>></span></span>{this.state.message}<span><span><span>&lt;</span>span</span> <span>class</span><span><span>=</span><span>"</span>token tag<span>"</span></span><span>></span></span><span><span><span>&lt;</span>span</span> <span>class</span><span><span>=</span><span>"</span>token tag<span>"</span></span><span>></span></span><span><span><span>&lt;</span>span</span> <span>class</span><span><span>=</span><span>"</span>token punctuation<span>"</span></span><span>></span></span>&lt;/<span><span><span>&lt;/</span>span</span><span>></span></span>span<span><span><span>&lt;/</span>span</span><span>></span></span><span><span><span>&lt;</span>span</span> <span>class</span><span><span>=</span><span>"</span>token punctuation<span>"</span></span><span>></span></span>><span><span><span>&lt;/</span>span</span><span>></span></span><span><span><span>&lt;/</span>span</span><span>></span></span>
      <span><span><span>&lt;</span>span</span> <span>class</span><span><span>=</span><span>"</span>token tag<span>"</span></span><span>></span></span><span><span><span>&lt;</span>span</span> <span>class</span><span><span>=</span><span>"</span>token tag<span>"</span></span><span>></span></span><span><span><span>&lt;</span>span</span> <span>class</span><span><span>=</span><span>"</span>token punctuation<span>"</span></span><span>></span></span>&lt;/<span><span><span>&lt;/</span>span</span><span>></span></span>div<span><span><span>&lt;/</span>span</span><span>></span></span><span><span><span>&lt;</span>span</span> <span>class</span><span><span>=</span><span>"</span>token punctuation<span>"</span></span><span>></span></span>><span><span><span>&lt;/</span>span</span><span>></span></span><span><span><span>&lt;/</span>span</span><span>></span></span>
    );
  }
}</span>
<span>```</span></span>

<span><span>```</span><span>css</span>
<span><span>&lt;span>.box-react span&lt;/span> &lt;span></span><span>{</span>&lt;/span>
  &lt;span class=<span>"token property"</span>>color&lt;/span>&lt;span class=<span>"token punctuation"</span>><span>:</span>&lt;/span> red&lt;span class=<span>"token punctuation"</span>><span>;</span>&lt;/span>
&lt;span class=<span>"token punctuation"</span>><span>}</span>&lt;/span></span>
<span>```</span></span>

:::



</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br></div></div></details>

          <div
            id="code-demo-a8b6364c"
           
  data-type="vue"
 data-title="%E4%B8%80%E4%B8%AA%20Vue%20Demo"

            data-code="%7B%22%22%3A%22%5Cn%22%7D"
          >
              <div>
                
              </div>
              <div>
                <div>
<p>​```vue
<template>
<div>
Mr.Hope <span>{{ message }}</span>
</div>
</template>
<script>
export default {
data: () =&gt; ({ message: &quot;十分帅&quot; }),
};
</script>
<style>
.box-vue span {
color: red;
}
</style></p>
<div><pre><code>
</code></pre>
<div><span>1</span><br></div></div>
            </div>
          </div>
          
        </div>
<details><summary>代码</summary>
<div><pre><code>::: demo [vue] 一个 Vue Demo

​```vue
<span><span><span>&lt;</span>template</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>box-vue<span>"</span></span><span>></span></span>
    Mr.Hope <span><span><span>&lt;</span>span</span><span>></span></span>{{ message }}<span><span><span>&lt;/</span>span</span><span>></span></span>
  <span><span><span>&lt;/</span>div</span><span>></span></span>
<span><span><span>&lt;/</span>template</span><span>></span></span>
<span><span><span>&lt;</span>script</span><span>></span></span><span><span>
<span>export</span> <span>default</span> <span>{</span>
  <span>data</span><span>:</span> <span>(</span><span>)</span> <span>=></span> <span>(</span><span>{</span> message<span>:</span> <span>"十分帅"</span> <span>}</span><span>)</span><span>,</span>
<span>}</span><span>;</span>
</span></span><span><span><span>&lt;/</span>script</span><span>></span></span>
<span><span><span>&lt;</span>style</span><span>></span></span><span><span>
<span>.box-vue span</span> <span>{</span>
  <span>color</span><span>:</span> red<span>;</span>
<span>}</span>
</span></span><span><span><span>&lt;/</span>style</span><span>></span></span>
```

:::

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div></details>

          <div
            id="code-demo-4ad68778"
           
  
 data-title="%E4%B8%80%E4%B8%AA%E6%99%AE%E9%80%9A%20Demo"

            data-code="%7B%22%22%3A%22%5Cn%60%60%60ts%5Cnconst%20message%3A%20string%20%3D%20%5C%22Mr.Hope%5C%22%3B%5Cn%5Cndocument.querySelector(%5C%22h1%5C%22).innerHTML%20%3D%20message%3B%5Cn%22%2C%22scss%22%3A%22h1%20%7B%5Cn%20%20font-style%3A%20italic%3B%5Cn%5Cn%20%20%2B%20p%20%7B%5Cn%20%20%20%20color%3A%20red%3B%5Cn%20%20%7D%5Cn%7D%5Cn%22%7D"
          >
              <div>
                
              </div>
              <div>
                <div>
<p>​```md</p>
<h1 id="标题"> 标题</h1>
<p>十分帅</p>
<div><pre><code>
```ts
const message: string = &quot;Mr.Hope&quot;;

document.querySelector(&quot;h1&quot;).innerHTML = message;
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><div><pre><code><span>h1 </span><span>{</span>
  <span>font-style</span><span>:</span> italic<span>;</span>

  <span>+ p </span><span>{</span>
    <span>color</span><span>:</span> red<span>;</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div>
            </div>
          </div>
          
        </div>
<details><summary>代码</summary>
<div><pre><code>::: demo 一个普通 Demo

​```md
<span><span>#</span> 标题</span>

十分帅
<span><span>```</span>
<span>
```ts
const message: string = "Mr.Hope";

document.querySelector("h1").innerHTML = message;</span>
<span>```</span></span>

<span><span>```</span><span>scss</span>
<span><span>&lt;span>h1 &lt;/span>&lt;span></span><span>{</span>&lt;/span>
  &lt;span class=<span>"token property"</span>>font-style&lt;/span>&lt;span class=<span>"token punctuation"</span>><span>:</span>&lt;/span> italic&lt;span class=<span>"token punctuation"</span>><span>;</span><span>&lt;/span>

  &lt;span>+ p &lt;/span>&lt;span></span><span>{</span>&lt;/span>
    &lt;span class=<span>"token property"</span>>color&lt;/span>&lt;span class=<span>"token punctuation"</span>><span>:</span>&lt;/span> red&lt;span class=<span>"token punctuation"</span>><span>;</span>&lt;/span>
  &lt;span class=<span>"token punctuation"</span>><span>}</span>&lt;/span>
&lt;span class=<span>"token punctuation"</span>><span>}</span>&lt;/span></span>
<span>```</span></span>

:::

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div></details>
<ul>
<li><a href="https://vuepress-theme.mrhope.site/zh/guide/feature/markdown/demo/" target="_blank" rel="noopener noreferrer">点击查看</a></li>
</ul>
<h3 id="幻灯片"> 幻灯片</h3>
<i>Not supported content</i><details><summary>代码</summary>
<div><pre><code>@slidestart

<span><span>##</span> 幻灯片 1</span>

一个有文字和 <span>[<span>链接</span>](<span>https://mrhope.site</span>)</span> 的段落

<span>---</span>

<span><span>##</span> 幻灯片 2</span>

<span>-</span> 列表 1
<span>-</span> 列表 2

<span>---</span>

<span><span>##</span> 幻灯片 3.1</span>

​```js
const a = 1;
```

--

<span><span>##</span> 幻灯片 3.2</span>

$$
J(\theta_0,\theta_1) = \sum_{i=0}
$$

@slideend

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br></div></div></details>
<ul>
<li><a href="https://vuepress-theme.mrhope.site/zh/guide/feature/markdown/presentation/" target="_blank" rel="noopener noreferrer">点击查看</a></li>
</ul>
<h2 id="其他语法"> 其他语法</h2>
<div><p>自定义标题</p>
<p>信息容器</p>
</div>
<div><p>自定义标题</p>
<p>提示容器</p>
</div>
<div><p>自定义标题</p>
<p>警告容器</p>
</div>
<div><p>自定义标题</p>
<p>危险容器</p>
</div>
<details><summary>自定义标题</summary>
<p>详情容器</p>
</details>
<details><summary>代码</summary>
<p>​```md</p>
<div><p>自定义标题</p>
<p>信息容器</p>
</div>
<div><p>自定义标题</p>
<p>提示容器</p>
</div>
<div><p>自定义标题</p>
<p>警告容器</p>
</div>
<div><p>自定义标题</p>
<p>危险容器</p>
</div>
<details><summary>自定义标题</summary>
<p>详情容器</p>
</details>
<div><pre><code>
</code></pre>
<div><span>1</span><br></div></div></details>
<hr>
<section>
<ol>
<li id="fn1"><p>这是脚注内容 </p>
</li>
</ol>
</section>
]]></content>
    <author>
      <name>𝓜𝓻. 𝓗𝓸𝓹𝓮</name>
    </author>
    <category term="使用指南"/>
    <contributor>
      <name>𝓜𝓻. 𝓗𝓸𝓹𝓮</name>
    </contributor>
    <published>2021-02-16T17:39:43.000Z</published>
    <rights>Copyright by 𝓜𝓻. 𝓗𝓸𝓹𝓮</rights>
  </entry>
  <entry>
    <title type="html">指南</title>
    <id>http://qiqi.dreamagain.top/guide/</id>
    <link href="http://qiqi.dreamagain.top/guide/"/>
    <updated>2021-02-16T17:39:43.000Z</updated>
    <content type="html"><![CDATA[<h2 id="目录"> 目录</h2>
<ul>
<li><a href="./markdown.html">Markdown指南</a></li>
<li><a href="./template.html">页面模板</a></li>
</ul>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <category term="使用指南"/>
    <contributor>
      <name>南辞</name>
    </contributor>
    <published>2021-02-16T17:39:43.000Z</published>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">页面配置模板</title>
    <id>http://qiqi.dreamagain.top/guide/template/</id>
    <link href="http://qiqi.dreamagain.top/guide/template/"/>
    <updated>2021-02-16T17:39:43.000Z</updated>
    <summary type="html"><![CDATA[模板]]></summary>
    <content type="html"><![CDATA[<blockquote>
<div><pre><code><span><span>---</span>
<span><span>########## 页面信息配置 ############</span>
<span># 这是页面的图标</span>
<span>icon</span><span>:</span> page
<span># 这是文章的标题</span>
<span>title</span><span>:</span> 博文参考模板
<span># 设置当前页面内容描述</span>
<span>description</span><span>:</span> 模板
<span># 设置作者</span>
<span>author</span><span>:</span> 南辞
<span># 是否原创</span>
<span>original</span><span>:</span> <span>true</span>
<span># 设置写作时间</span>
<span>time</span><span>:</span> <span>2021-01-01</span>
<span># 一个页面只能有一个分类</span>
<span>category</span><span>:</span> 使用指南
<span># 一个页面可以有多个标签</span>
<span>tag</span><span>:</span>
    <span>-</span> 页面配置
<span># 设置当前文章是否在列表中置顶。当填入数字时，数字越大，排名越靠前</span>
<span>sticky</span><span>:</span> <span>1</span>
<span># 是否将该文章添加至文章列表中</span>
<span>article</span><span>:</span> <span>true</span>
<span># 是否将该文章添加至文章列表中</span>
<span>timeline</span><span>:</span> <span>false</span>
<span># 设置当前文章的密码</span>
<span>password</span><span>:</span> <span>123</span>
<span># 设置当前页面的预览图(分享图)</span>
<span>images</span><span>:</span> <span>"/images/1.jpg"</span>


<span>########## 页面显示配置 ###########</span>
<span># 默认显示信息</span>
pageInfo<span>:</span><span>[</span><span>'author'</span><span>,</span> <span>'visitor'</span><span>,</span> <span>'time'</span><span>,</span> <span>'category'</span><span>,</span> <span>'tag'</span><span>,</span> <span>'readtime'</span><span>]</span>
<span># 当前页面是否显示浏览量</span>
<span>visitor</span><span>:</span> <span>true</span>
<span># 当前页面是否开启路径导航</span>
<span>breadcrumb</span><span>:</span> <span>true</span>
<span># 当前页面是否开启路径导航图标</span>
<span>breadcrumbIcon</span><span>:</span> <span>true</span>
<span># 是否禁用导航栏,false会禁用</span>
<span>navbar</span><span>:</span> <span>true</span>
<span># 页面的侧边栏配置选项，支持 false 或 auto</span>
<span>sidebar</span><span>:</span> <span>'auto'</span>
<span># 该页面的侧边栏渲染深度</span>
<span>sidebarDepth</span><span>:</span> <span>4</span>
<span># 当前页面是否开启评论功能</span>
<span>comment</span><span>:</span> <span>true</span>
<span># 页脚,想要移除默认的页脚内容，设置为 '';如果你想使用默认页脚，设置为 true</span>
<span>footer</span><span>:</span> <span>true</span>
<span># 页面的自定义布局名称</span>
<span>layout</span><span>:</span> <span>""</span></span>
<span>---</span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br></div></div></blockquote>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <category term="使用指南"/>
    <contributor>
      <name>南辞</name>
    </contributor>
    <published>2020-12-27T00:00:00.000Z</published>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">VuePresss入坑指南</title>
    <id>http://qiqi.dreamagain.top/guide/vuepress/</id>
    <link href="http://qiqi.dreamagain.top/guide/vuepress/"/>
    <updated>2021-02-19T09:11:17.000Z</updated>
    <summary type="html"><![CDATA[<blockquote>
<p><img src="https://img.shields.io/badge/vuepress-blue.svg" alt=""> <img src="https://img.shields.io/badge/vuepress--theme--reco-blue.svg" alt=""></p>
<p>没有问题演示的教程都不是好教程</p>
</blockquote>
]]></summary>
    <content type="html"><![CDATA[<blockquote>
<p><img src="https://img.shields.io/badge/vuepress-blue.svg" alt=""> <img src="https://img.shields.io/badge/vuepress--theme--reco-blue.svg" alt=""></p>
<p>没有问题演示的教程都不是好教程</p>
</blockquote>

<p>在利用vuepress搭建个人博客的过程中参考过很多教程，最权威的教程是<a href="https://v1.vuepress.vuejs.org/zh/" target="_blank" rel="noopener noreferrer">vuepress官网</a>，其他不懂的细节再通过百度基本能解决，不过不得不说如果要自定义主题、编写自己的组件或者开发一下插件的时候，这方面的教程很少，即使是仅有的教程也没有达到我所期望的质效果。</p>
<h2 id="一、vuepresss简介"> 一、VuePresss简介</h2>
<p>通过<a href="https://v1.vuepress.vuejs.org/zh/guide/" target="_blank" rel="noopener noreferrer">官方介绍</a>提取如下几点关键信息</p>
<h3 id="_1、什么是vuepresss"> 1、什么是VuePresss</h3>
<p>Vue全家桶成员之一，尤雨溪大神于2018年4月12日推出</p>
<ul>
<li><strong>VuePresss = <a href="https://github.com/vuejs/vuepress/tree/master/packages/%40vuepress/core" target="_blank" rel="noopener noreferrer">极简静态网站生成器</a> + <a href="https://v1.vuepress.vuejs.org/zh/theme/default-theme-config.html" target="_blank" rel="noopener noreferrer">默认主题</a></strong></li>
</ul>
<h3 id="_2、vuepresss是干什么的"> 2、VuePresss是干什么的</h3>
<ul>
<li>
<p>它的诞生初衷是为了支持 Vue 及其子项目的文档需求</p>
</li>
<li>
<p>现在，你可以通过添加<strong>博客主题</strong>来搭建属于自己的静态博客</p>
<p>软硬件要求：</p>
<ul>
<li>
<p>vuepress</p>
</li>
<li>
<p>vuepress主题模板</p>
</li>
<li>
<p><s>vuepress插件</s> （可选）</p>
</li>
<li>
<p><s>第三方组件库，如Element-UI，View UI</s> （可选）</p>
</li>
<li>
<p><s>自己的服务器</s> （可选）</p>
</li>
<li>
<p><s>自己的备案域名</s>（可选）</p>
</li>
</ul>
</li>
</ul>
<h3 id="_3、vuepresss工作原理"> 3、VuePresss工作原理</h3>
<ul>
<li>一个 VuePresss网站是一个由 <a href="http://vuejs.org/" target="_blank" rel="noopener noreferrer">Vue </a>、<a href="https://github.com/vuejs/vue-router" target="_blank" rel="noopener noreferrer">Vue Router</a>和 <a href="http://webpack.js.org/" target="_blank" rel="noopener noreferrer">webpack </a>驱动的单页应用</li>
<li>所以，VuePresss是借鉴了Nuxt框架，采用服务端渲染。<strong>一个VuePresss网站=应用</strong>。</li>
</ul>
<h3 id="_4、使用体验"> 4、使用体验</h3>
<ul>
<li>推荐使用VuePresss的社区主题，样式比较好看</li>
<li>使用主题也并非开箱即用，还是需要不少的配置</li>
<li>文章写在md文件中，有时需要插入网页标签，会带来一定的不便</li>
<li>使用Markdown请使用比较友好的编辑器，推荐<code>Typora</code></li>
</ul>
<p>接下来就看看如何一步步搭建、扩展以及使用。</p>
<h2 id="二、开始搭建"> 二、开始搭建</h2>
<h3 id="一-创建项目目录"> （一）创建项目目录</h3>
<p>在任意位置新建一个目录<code>qiqi-algorithm</code></p>
<h3 id="二-初始化"> （二）初始化</h3>
<p>进入qiqi-blog目录中，执行下面的命令</p>
<div><pre><code><span>yarn</span> init 
或
<span>npm</span> init
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>可以一直回车，不用填任何信息</p>
<p><img src="./assets/vuepress01.png" alt=""></p>
<p>执行结束后项目下会生成<code>package.json</code>文件</p>
<div><pre><code><span>{</span>
  <span>"name"</span><span>:</span> <span>"`qiqi-algorithm`"</span><span>,</span>
  <span>"version"</span><span>:</span> <span>"1.0.0"</span><span>,</span>
  <span>"main"</span><span>:</span> <span>"index.js"</span><span>,</span>
  <span>"license"</span><span>:</span> <span>"MIT"</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><div><p>提示</p>
<p>npm 和 yarn都是包管理工具，在使用之前需要安装node.js</p>
<p>如果你还没有安装过node.js、npm、yarn这些基础环境可以参考<a href="/software/nvm/">windows下安装多版本Node.js</a></p>
</div>
<h3 id="三-安装-vuepress"> （三）安装 vuepress</h3>
<p><mark>官方推荐局部安装</mark>，听官方的准没错，省去一些可能不必要的麻烦</p>
<div><pre><code><span>yarn</span> <span>add</span> -D vuepress 
或
<span>npm</span> <span>install</span> -D vuepress
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><div><p>官方提示</p>
<p>注意</p>
<p>如果你的现有项目依赖了 webpack 3.x，我们推荐使用 <a href="https://classic.yarnpkg.com/zh-Hans/" target="_blank" rel="noopener noreferrer">Yarn (opens new window)</a>而不是 npm 来安装 vuepress。因为在这种情形下，npm 会生成错误的依赖树。</p>
<p>yarn能够解决npm存在的一些问题，所以推荐还是使用yarn</p>
</div>
<h3 id="四-创建目录src"> （四）创建目录src</h3>
<p>在<code>qiqi-algorithm</code>下创建目录<code>src</code>，这个目录可以任意命名，只是后面要提交的脚本要相应改一下就行。官方是<code>docs</code></p>
<h3 id="五-package-json"> （五）<code>package.json</code></h3>
<p>在 <code>package.json</code> 中添加以下内容</p>
<div><pre><code><span>{</span>
  <span>"scripts"</span><span>:</span> <span>{</span>
    <span>"dev"</span><span>:</span> <span>"vuepress dev src"</span><span>,</span>
    <span>"build"</span><span>:</span> <span>"vuepress build src"</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>添加该内容后将把 <code>src</code>目录作为 <code>targetDir</code></p>
<p>如果按照官方创建的是docs目录，添加的内容是：</p>
<div><pre><code><span>{</span>
  <span>"scripts"</span><span>:</span> <span>{</span>
    <span>"docs:dev"</span><span>:</span> <span>"vuepress dev docs"</span><span>,</span>
    <span>"docs:build"</span><span>:</span> <span>"vuepress build docs"</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>dev、build是vuepress中的相关命令，更多命令参考：<a href="https://www.vuepress.cn/api/cli.html" target="_blank" rel="noopener noreferrer">命令行接口</a>，还可以使用 <a href="https://www.vuepress.cn/plugin/option-api.html#extendcli" target="_blank" rel="noopener noreferrer">extendCli</a> 来创建自定义命令。</p>
<p>所以可以据个人需要设置一下在此处添加更多命令</p>
<p>这里我改一下script内容为：</p>
<div><pre><code><span>{</span>
<span>"scripts"</span><span>:</span> <span>{</span>
    <span>"dev"</span><span>:</span> <span>"vuepress dev src --open --host localhost"</span><span>,</span>
    <span>"build"</span><span>:</span> <span>"vuepress build src --dest dist"</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h3 id="六-编写首页"> （六）编写首页</h3>
<p>在src目录下创建readme.md文件并在开头插入<a href="https://vuepress.vuejs.org/zh/guide/frontmatter.html" target="_blank" rel="noopener noreferrer">Front Matter</a>内容</p>
<div><pre><code><span><span>---</span>
<span><span>home</span><span>:</span> <span>true</span>
<span>heroImage</span><span>:</span> /logo.png
<span>heroText</span><span>:</span> 七七算法
<span>tagline</span><span>:</span> welcome
<span>actionText</span><span>:</span> 了解更多 →
<span>actionLink</span><span>:</span> /
<span>features</span><span>:</span>
<span>-</span> <span>title</span><span>:</span> 简洁至上
  <span>details</span><span>:</span> 以 Markdown 为中心的项目结构，以最少的配置帮助你专注于写作。
<span>-</span> <span>title</span><span>:</span> Vue驱动
  <span>details</span><span>:</span> 享受 Vue + webpack 的开发体验，在 Markdown 中使用 Vue 组件，同时可以使用 Vue 来开发自定义主题。
<span>-</span> <span>title</span><span>:</span> 高性能
  <span>details</span><span>:</span> vuepress 为每个页面预渲染生成静态的 HTML，同时在页面被加载的时候，将作为 SPA 运行。
<span>footer</span><span>:</span> Copyright © 2021 Mr·Yang</span>
<span>---</span></span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><h3 id="七-在本地启动服务器"> （七）在本地启动服务器</h3>
<p>根据第五步执行相关命令</p>
<p>按照官网来启动命令是：</p>
<div><pre><code><span>yarn</span> docs:dev 
或
<span>npm</span> run docs:dev
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>按照我自己配置的就应该是：</p>
<div><pre><code><span>yarn</span> dev 
或
<span>npm</span> run dev
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>此时<code>package.json</code>完整内容应该是这样</p>
<div><pre><code><span>{</span>
  <span>"name"</span><span>:</span> <span>"qiqi-algorithm"</span><span>,</span>
  <span>"version"</span><span>:</span> <span>"1.0.0"</span><span>,</span>
  <span>"main"</span><span>:</span> <span>"index.js"</span><span>,</span>
  <span>"scripts"</span><span>:</span> <span>{</span>
    <span>"dev"</span><span>:</span> <span>"vuepress dev src --open --host localhost"</span><span>,</span>
    <span>"build"</span><span>:</span> <span>"vuepress build src --dest dist"</span>
  <span>}</span><span>,</span>
  <span>"license"</span><span>:</span> <span>"MIT"</span><span>,</span>
  <span>"devDependencies"</span><span>:</span> <span>{</span>
    <span>"vuepress"</span><span>:</span> <span>"^1.8.1"</span>
  <span>}</span>
<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><div><p>提示</p>
<p>不按照官网主要是为了更直观看到那些地方可以自定义</p>
</div>
<p>运行结果：</p>
<p><img src="./assets/vuepress02.png" alt=""></p>
<p>能运行出来说明配置没有出错，仔细看还有圈出来的基础地方没有显示，说明我们还要接着做一些配置</p>
<p>官网里也详细指出我们接下来的工作了：</p>
<img src="./assets/vuepress03.png"/>
<h3 id="八-创建基本项目结构"> （八）创建基本项目结构</h3>
<p>官方只有<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.vuepress.cn%2Fguide%2Fdirectory-structure.html" target="_blank" rel="noopener noreferrer">推荐目录结构</a>，并没有现成的cli，所以需要通过命令行或手动创建如下结构：</p>
<div><pre><code>qiqi<span>-</span>algorithm
├─package<span>.</span>json
├─docs
<span>|</span>  ├─readme<span>.</span>md
<span>|</span>  ├─<span>.</span>vuepress
<span>|</span>  <span>|</span>     ├─config<span>.</span>js
<span>|</span>  <span>|</span>     ├─<span>public</span>
<span>|</span>  <span>|</span>     <span>|</span>   └logo<span>.</span>png
<span>|</span>  <span>|</span>     <span>|</span>   └favicon<span>.</span>ico
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>其中有后缀的是文件，没后缀的是文件夹</p>
<h3 id="九-配置config-js"> （九）配置config.js</h3>
<p>该文件为项目最重要的配置文件，几乎所有配置项都是在此进行。</p>
<p>我们先来一个最简单的配置看看效果：</p>
<div><pre><code>module<span>.</span>exports <span>=</span> <span>{</span>
    title<span>:</span> <span>'七七算法'</span><span>,</span>
    head<span>:</span> <span>[</span> <span>// 注入到当前页面的 HTML &lt;head> 中的标签</span>
      <span>[</span><span>'link'</span><span>,</span> <span>{</span> rel<span>:</span> <span>'icon'</span><span>,</span> href<span>:</span> <span>'/favicon.ico'</span> <span>}</span><span>]</span><span>,</span> <span>// 增加一个自定义的 favicon(网页标签的图标)</span>
    <span>]</span><span>,</span>
    themeConfig<span>:</span> <span>{</span>
      logo<span>:</span> <span>'/logo.png'</span><span>,</span>  <span>// 左上角logo</span>
      nav<span>:</span><span>[</span> <span>// 导航栏配置</span>
        <span>{</span>text<span>:</span> <span>'首页'</span><span>,</span> link<span>:</span> <span>'/'</span> <span>}</span><span>,</span>
        <span>{</span>text<span>:</span> <span>'侧边栏测试'</span><span>,</span> link<span>:</span> <span>'/sidebar'</span> <span>}</span><span>,</span>
        <span>{</span>text<span>:</span> <span>'七七部落'</span><span>,</span> link<span>:</span> <span>'http://qiqi.dreamagain.top'</span> <span>}</span><span>,</span> 
      <span>]</span><span>,</span>
      sidebar<span>:</span> <span>'auto'</span><span>,</span> <span>// 配置为自动生成侧边栏</span>
    <span>}</span>
  <span>}</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>详细配置可直接查询<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.vuepress.cn%2Fconfig%2F%23%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE" target="_blank" rel="noopener noreferrer">官网-config配置</a></p>
<div><p>注意</p>
<ol>
<li>此时路由根路径为src文件夹（我们在package.json中通过build、dev命令后的参数指定的）</li>
<li>静态资源（图片）根路径为public文件夹（这是VuePress约定的）</li>
</ol>
</div>
<p>在src下新建：sidebar.md</p>
<div><pre><code><span><span>---</span>
<span><span>title</span><span>:</span> 侧边栏测试</span>
<span>---</span></span>
<span><span>##</span> 二级标题01</span>

<span><span>###</span> 三级标题01-1</span>

<span><span>##</span> 二级标题02</span>

<span><span>###</span> 三级标题02-1 </span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h3 id="十-再次启动项目"> （十）再次启动项目</h3>
<p><code>yarn run dev</code></p>
<p>效果如下：</p>
<img src="./assets/vuepress04.png" style="zoom: 80%;" />
<img src="./assets/vuepress05.png" style="zoom: 80%;" />
<p>我们配置的title、nav、sidebar、logo全都生效了！</p>
<p>到这里一个极简的框架已经搭建起来了</p>
<p>这里默认使用的是<strong>官方默认主题</strong>：</p>
<ul>
<li>左上角的logo与title</li>
<li>右上角的全局搜索框与nav导航栏</li>
<li>左侧的sidebar导航栏（自动将md一级标题设置为导航文案）</li>
<li>右侧的markdown内容</li>
</ul>
<p><strong>注意：项目自带热更新; 但config.js有时可能会热更新失败，需要重启项目</strong></p>
<h2 id="三、详细配置"> 三、详细配置</h2>
<p>接下来参照官网<a href="https://www.vuepress.cn/guide/basic-config.html" target="_blank" rel="noopener noreferrer">基本配置</a>进行一些更细节的配置</p>
<h3 id="一-更换主题"> （一）更换主题</h3>
<div><p>主题分类</p>
<ul>
<li>默认主题</li>
<li>自定义主题</li>
</ul>
<p>默认主题样式比较简洁，如果要使用丰富样式的主题就使用官方或社区提供的一些自定义主题，如果实力允许你也可以开发一个自定义主题。不想那么麻烦，但默认主题又不满足需求？那就在默认主题基础上做一些修改，以满足需求。</p>
</div>
<p>可以在<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.npmjs.com%2F" target="_blank" rel="noopener noreferrer">npm官网</a>中输入<code>vuepress-theme</code>寻找相关的vuepress主题，其中以 @vuepress/theme- 开头的主题是官方维护的主</p>
<p>这里使用  <a href="https://github.com/vuepress-reco/vuepress-theme-reco" target="_blank" rel="noopener noreferrer">vuepress-theme-reco</a>，<a href="https://vuepress-reco-doc.now.sh/views/1.x/" target="_blank" rel="noopener noreferrer">官方文档</a></p>
<p>该主题提供了快速构建的脚手架，这里选择yarn安装</p>
<p><strong>1、使用脚手架安装</strong></p>
<div><pre><code>// 安装脚手架
<span>yarn</span> <span>add</span> global @vuepress-reco/theme-cli

// 初始化
theme-cli init reco-demo

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>执行<code>theme-cli init reco-demo</code>命令后根据提示填写相关信息</p>
<div><pre><code>PS F:<span>\</span>program<span>\</span>我的博客<span>\</span>qiqi-algorithm<span>></span> theme-cli init reco-demo
? What<span>'s the name of new directory? reco-demo
? What'</span>s the title of your project? reco-demo
? What<span>'s the description of your project? Create a blog template with vuepress-theme-reco.
? What'</span>s the author<span>'s name? nanci
? What style do you want your home page to be?(Select afternoon-grocery, if you want to download reco_luan'</span>s <span>'午后南杂'</span><span>)</span>? What style <span>do</span> you want your home page to be?<span>(</span>Select afternoon-grocery, <span>if</span> you want to download reco_luan<span>'s '</span>午后南杂<span>')? What style do you want your home page to be?(Select afternoon-grocery, if you want to download reco_luan'</span>s <span>'午后南杂'</span><span>)</span>? What style <span>do</span> you want your home page to be?<span>(</span>Select afternoon-grocery, <span>if</span> you want to download reco_luan<span>'s '</span>午后南杂'<span>)</span> 
<span>></span> blog
  doc
  afternoon-grocery

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><blockquote>
<p>&gt;blog</p>
<p>doc</p>
<p>afternoon-grocery</p>
</blockquote>
<p>通过上下键来选择，这里选择blog，回车</p>
<p>继续执行以下命令</p>
<div><pre><code><span>yarn</span> <span>install</span>

<span># run</span>
<span>yarn</span> dev

<span># build</span>
<span>yarn</span> build
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>运行效果：</p>
<p><img src="./assets/vuepress06.png" alt=""></p>
<p>查看项目的目录结构和package.json文件</p>
<p><img src="./assets/vuepress28.png" alt=""></p>
<p>说明是把项目根目录作为 <code>targetDir</code>，如果要按照官方推荐的目录就手动改一下，不过改不改这都无伤大雅。</p>
<div><p>官方说明</p>
<p>vuepress官网也提供了 <a href="https://www.vuepress.cn/theme/using-a-theme.html" target="_blank" rel="noopener noreferrer">使用主题</a> 的方法</p>
<p><strong>使用社区主题</strong></p>
<div><pre><code><span>// .vuepress/config.js</span>
module<span>.</span>exports <span>=</span> <span>{</span>
  theme<span>:</span> <span>'vuepress-theme-xx'</span>
<span>}</span>

<span>// 主题名以 vuepress-theme- 开头，可以使用缩写来省略这个前缀：</span>
module<span>.</span>exports <span>=</span> <span>{</span>
  theme<span>:</span> <span>'xxx'</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p><strong>使用官方主题</strong></p>
<div><pre><code><span>// .vuepress/config.js</span>
module<span>.</span>exports <span>=</span> <span>{</span>
  theme<span>:</span> <span>'@org/vuepress-theme-xxx'</span><span>,</span> <span>//一个官方主题: '@vuepress/theme-xxx'</span>
<span>}</span>
<span>// 缩写</span>
module<span>.</span>exports <span>=</span> <span>{</span>
  theme<span>:</span> <span>'@org/xxx'</span><span>,</span> <span>// 或者一个官方主题: '@vuepress/xxx'</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>所以如果你不想使用开始搭建，而是在旧项目中使用，可以像官方介绍的这样来安装</p>
<p>1、安装</p>
<div><pre><code><span>yarn</span> <span>add</span> vuepress-theme-reco
</code></pre>
<div><span>1</span><br></div></div><p>2、引用</p>
<div><pre><code>// .vuepress/config.js

module.exports <span>=</span> <span>{</span>
  theme: <span>'reco'</span>
<span>}</span>  
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div></div>
<p><strong>2、查看<code>package.json</code></strong></p>
<div><pre><code><span>{</span>
  <span>"name"</span><span>:</span> <span>"reco-demo"</span><span>,</span>
  <span>"version"</span><span>:</span> <span>"1.0.0"</span><span>,</span>
  <span>"author"</span><span>:</span> <span>"nanci"</span><span>,</span>
  <span>"scripts"</span><span>:</span> <span>{</span>
    <span>"dev"</span><span>:</span> <span>"vuepress dev . --open --host \"localhost\""</span><span>,</span>
    <span>"build"</span><span>:</span> <span>"vuepress build ."</span>
  <span>}</span><span>,</span>
  <span>"devDependencies"</span><span>:</span> <span>{</span>
    <span>"vuepress"</span><span>:</span> <span>"1.7.1"</span><span>,</span>
    <span>"vuepress-theme-reco"</span><span>:</span> <span>"1.6.1"</span>
  <span>}</span><span>,</span>
  <span>"description"</span><span>:</span> <span>"Create a blog template with vuepress-theme-reco."</span>
<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p><strong>3、更新依赖</strong>（3种方式）</p>
<ol>
<li>下载npm-check-updates</li>
<li>yarn upgrade-interactive --latest</li>
<li>yarn upgrade package@version</li>
</ol>
<p><strong>第一种</strong></p>
<div><pre><code>// 先下载
<span>yarn</span> global <span>add</span> npm-check-updates

// 更新包（yarn.lock和package.json同步更新）
ncu --upgrade --upgradeAll <span>&amp;&amp;</span> <span>yarn</span> upgrade
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p><strong>第二种</strong></p>
<div><pre><code><span>yarn</span> upgrade-interactive --latest
// 需要手动选择升级的依赖包，按空格键选择，a 键切换所有，i 键反选选择
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><strong>第三种</strong></p>
<div><pre><code><span>yarn</span> upgrade package@version
// yarn.lock和package.json都会更新，但是会进行版本锁定 <span>"echarts"</span><span>:</span> <span>"4.2.0-rc.2"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><div><p>参考</p>
<p><a href="https://blog.csdn.net/qq_37939251/article/details/107832805" target="_blank" rel="noopener noreferrer">多纤果冻</a></p>
</div>
<div><p>提示</p>
<ul>
<li>yarn upgrade  依赖包小版本升级</li>
<li>yarn upgrade-interactive --latest  大版本升级。忽略package.json指定的版本范围，并使用latest注册表中标记的版本。
大版本升级会让你手动选择要升级的工具包，尽量选择范围调整到最小，以防止项目出现问题</li>
<li>小版本升级一般不会影响现在的工具使用，大版本升级要慎用，由于最新的ES语法babel不能识别，特地将babel进行了大版本升级。</li>
</ul>
<p><mark>推荐使用第二种<code>yarn upgrade-interactive --latest</code>不需要安装过多的依赖就可以达到目的</mark></p>
</div>
<p>大胆尝试更新，运行报错无法解决我们再退回到以前版本即可。</p>
<p>执行命令后依赖版本如下:</p>
<div><pre><code><span>{</span>
  <span>"name"</span><span>:</span> <span>"reco-demo"</span><span>,</span>
  <span>"version"</span><span>:</span> <span>"1.0.0"</span><span>,</span>
  <span>"author"</span><span>:</span> <span>"nanci"</span><span>,</span>
  <span>"scripts"</span><span>:</span> <span>{</span>
    <span>"dev"</span><span>:</span> <span>"vuepress dev . --open --host \"localhost\""</span><span>,</span>
    <span>"build"</span><span>:</span> <span>"vuepress build ."</span>
  <span>}</span><span>,</span>
  <span>"devDependencies"</span><span>:</span> <span>{</span>
    <span>"vuepress"</span><span>:</span> <span>"1.8.1"</span><span>,</span>
    <span>"vuepress-theme-reco"</span><span>:</span> <span>"1.6.4"</span>
  <span>}</span><span>,</span>
  <span>"description"</span><span>:</span> <span>"Create a blog template with vuepress-theme-reco."</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p><strong>4、测试运行</strong></p>
<p>发现页面空白，后台也没有任何报错信息</p>
<p>去到github官网查看<a href="https://github.com/vuepress-reco/vuepress-theme-reco/releases" target="_blank" rel="noopener noreferrer"><code>vuepress-theme-reco</code>的发布版本</a>，当前已发布版本如下：</p>
<p><img src="./assets/vuepress07.png" alt=""></p>
<p>发现1.6.2、1.6.3、1.6.4 才是最近发布的，可能存在不少bug，查看<code>issue</code>，找到这样的信息</p>
<p><img src="./assets/vuepress52.png" alt=""></p>
<p>明确是版本的问题，我们还是还是切换回之前的1.6.1版本。</p>
<p>测试发现，只要改用<code>&quot;vuepress-theme-reco&quot;: &quot;1.6.1&quot;</code>就能正常显示，所以在更新依赖的时候不更新<code>vuepress-theme-reco</code>就可以了</p>
<p><strong>5、修改配置文件config.js</strong></p>
<p>修改的同时我们也可以安装一些实用的插件</p>
<div><pre><code>// 阅读进度条
<span>yarn</span> <span>add</span> vuepress-plugin-reading-progress 
// 代码一键复制
<span>yarn</span> <span>add</span> @mr-hope/vuepress-plugin-copy-code 
或
<span>yarn</span> <span>add</span> @xiaopanda/vuepress-plugin-code-copy
// RSS
<span>yarn</span> <span>add</span> @vuepress-reco/vuepress-plugin-rss 
// 加载进度条
<span>yarn</span> <span>add</span> @vuepress/plugin-nprogress 
// 音乐
<span>yarn</span> <span>add</span> vuepress-plugin-meting 
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p><strong>config.js</strong>完整内容如下：</p>
<div><pre><code>module<span>.</span>exports <span>=</span> <span>{</span>
  host<span>:</span> <span>"127.0.0.1"</span><span>,</span> <span>// 生成网页地址（本地调试使用）</span>
  port<span>:</span> <span>"65535"</span><span>,</span> <span>// 生成网页端口（本地调试使用）</span>
  title<span>:</span> <span>"reco-demo"</span><span>,</span> <span>// 显示在左上角的网页名称以及首页在浏览器标签显示的title名称</span>
  description<span>:</span> <span>"A blog template with vuepress-theme-reco."</span><span>,</span> <span>// meta 中的描述文字，用于SEO</span>
  head<span>:</span> <span>[</span>
    <span>[</span><span>"link"</span><span>,</span> <span>{</span> rel<span>:</span> <span>"icon"</span><span>,</span> href<span>:</span> <span>"/favicon.svg"</span> <span>}</span><span>]</span><span>,</span> <span>//浏览器的标签栏的网页图标,基地址/.vuepress/public</span>
    <span>[</span>
      <span>"meta"</span><span>,</span>
      <span>{</span>
        name<span>:</span> <span>"viewport"</span><span>,</span>
        content<span>:</span> <span>"width=device-width,initial-scale=1,user-scalable=no"</span><span>,</span>
      <span>}</span><span>,</span>
    <span>]</span><span>,</span> <span>//在移动端，搜索框在获得焦点时会放大</span>
  <span>]</span><span>,</span>
  theme<span>:</span> <span>"reco"</span><span>,</span> <span>//选择主题‘reco’</span>
  themeConfig<span>:</span> <span>{</span>
    type<span>:</span> <span>"blog"</span><span>,</span> <span>//选择类型博客</span>
    fullscreen<span>:</span> <span>true</span><span>,</span>
    blogConfig<span>:</span> <span>{</span>
      category<span>:</span> <span>{</span>
        location<span>:</span> <span>2</span><span>,</span> <span>// 在导航栏菜单中所占的位置，默认2</span>
        text<span>:</span> <span>"分类"</span><span>,</span> <span>// 默认 “分类”</span>
      <span>}</span><span>,</span>
      tag<span>:</span> <span>{</span>
        location<span>:</span> <span>3</span><span>,</span> <span>// 在导航栏菜单中所占的位置，默认3</span>
        text<span>:</span> <span>"标签"</span><span>,</span> <span>// 默认 “标签”</span>
      <span>}</span><span>,</span>
      socialLinks<span>:</span> <span>[</span>
        <span>{</span> icon<span>:</span> <span>"reco-github"</span><span>,</span> link<span>:</span> <span>"https://github.com/small-universe"</span> <span>}</span><span>,</span>
        <span>{</span> icon<span>:</span> <span>"reco-qq"</span><span>,</span> link<span>:</span> <span>"tencent://AddContact/?fromId=50&amp;fromSubId=1&amp;subcmd=all&amp;uin=1715261428"</span> <span>}</span><span>,</span>
        <span>{</span> icon<span>:</span> <span>"reco-mail"</span><span>,</span> link<span>:</span> <span>"mailto:18846770224@163.com"</span> <span>}</span><span>,</span>
        <span>{</span> icon<span>:</span> <span>"reco-gitee"</span><span>,</span> link<span>:</span> <span>"https://gitee.com/small-universe"</span> <span>}</span><span>,</span>
        <span>{</span> icon<span>:</span> <span>"reco-csdn"</span><span>,</span> link<span>:</span> <span>"https://blog.csdn.net/qq_39839033/"</span>  <span>}</span><span>,</span>
      <span>]</span><span>,</span>
    <span>}</span><span>,</span>
    nav<span>:</span> <span>[</span>
      <span>//导航栏设置</span>
      <span>{</span>text<span>:</span> <span>'首页'</span><span>,</span> link<span>:</span> <span>'/'</span><span>,</span> icon<span>:</span> <span>'reco-home'</span><span>}</span><span>,</span>
    <span>{</span> text<span>:</span> <span>"时间线"</span><span>,</span> link<span>:</span> <span>"/timeline/"</span><span>,</span> icon<span>:</span> <span>"reco-date"</span> <span>}</span><span>,</span>
    <span>{</span>
        text<span>:</span> <span>"联系"</span><span>,</span>
        icon<span>:</span> <span>"reco-message"</span><span>,</span>
        items<span>:</span> <span>[</span>
            <span>{</span>text<span>:</span> <span>'七七部落'</span><span>,</span> link<span>:</span> <span>'http://qiqi.dreamagain.top/'</span><span>,</span> icon<span>:</span> <span>'reco-logo'</span><span>}</span><span>,</span>
            <span>{</span>text<span>:</span> <span>'GitHub'</span><span>,</span> link<span>:</span> <span>'https://github.com/small-universe/qiqi-algorithm'</span><span>,</span> icon<span>:</span> <span>'reco-github'</span><span>}</span><span>,</span>
            <span>{</span>text<span>:</span> <span>"CSDN"</span><span>,</span> link<span>:</span> <span>"https://blog.csdn.net/qq_27961843/"</span><span>,</span> icon<span>:</span> <span>"reco-csdn"</span><span>}</span><span>,</span>
            <span>{</span>text<span>:</span> <span>"QQ"</span><span>,</span> link<span>:</span> <span>"tencent://message/?uin=1715261428"</span><span>,</span> icon<span>:</span> <span>"reco-qq"</span><span>}</span><span>,</span>
            <span>{</span>text<span>:</span> <span>"Gmail"</span><span>,</span> link<span>:</span> <span>"mailto:18846770224@163.com"</span><span>,</span> icon<span>:</span> <span>"reco-mail"</span><span>}</span><span>,</span>
        <span>]</span><span>,</span>
    <span>}</span><span>,</span>
    <span>]</span><span>,</span>

    <span>// displayAllHeaders: true, // 默认值：false</span>
    subSidebar<span>:</span> <span>"auto"</span><span>,</span>

    record<span>:</span> <span>"滇ICP备20004889号-1"</span><span>,</span>
    recordLink<span>:</span> <span>"https://icp.chinaz.com/home/info?host=dreamagain.top"</span><span>,</span>
    <span>// cyberSecurityRecord: "全国互联网安全管理服务平台",</span>
    <span>// cyberSecurityLink:</span>
    <span>//   "http://www.beian.gov.cn/portal/registerSystemInfo",</span>
    startYear<span>:</span> <span>"2021"</span><span>,</span> <span>// 项目开始时间，只填写年份</span>
    lastUpdated<span>:</span> <span>"最后更新时间"</span><span>,</span> <span>// string | boolean</span>
    author<span>:</span> <span>"nanci"</span><span>,</span>
    authorAvatar<span>:</span> <span>"/avatar.jpg"</span><span>,</span> <span>//作者头像</span>
    mode<span>:</span> <span>"light"</span><span>,</span> <span>//默认显示白天模式</span>
    codeTheme<span>:</span> <span>"okaidia"</span><span>,</span> <span>// default 'tomorrow'</span>
    smooth<span>:</span> <span>"true"</span><span>,</span> <span>//平滑滚动</span>
    <span>// 评论设置,结合github actions使用，避免暴露个人重要信息</span>
    valineConfig<span>:</span> <span>{</span>
      appId<span>:</span> process<span>.</span>env<span>.</span><span>LEANCLOUD_APP_ID</span><span>,</span>
      appKey<span>:</span> process<span>.</span>env<span>.</span><span>LEANCLOUD_APP_KEY</span><span>,</span>
    <span>}</span><span>,</span>
  <span>}</span><span>,</span>
  markdown<span>:</span> <span>{</span>
    lineNumbers<span>:</span> <span>true</span><span>,</span> <span>//代码显示行号</span>
  <span>}</span><span>,</span> <span>// 搜索设置</span>
  search<span>:</span> <span>true</span><span>,</span>
  searchMaxSuggestions<span>:</span> <span>10</span><span>,</span> <span>// 插件</span>
  plugins<span>:</span> <span>[</span>
    <span>// 音乐</span>
    <span>[</span>
      <span>"meting"</span><span>,</span>
      <span>{</span>
        <span>// metingApi: "https://meting.sigure.xyz/api/music",</span>
        meting<span>:</span> <span>{</span>
          server<span>:</span> <span>"netease"</span><span>,</span>
          type<span>:</span> <span>"playlist"</span><span>,</span>
          <span>// 歌单id</span>
          mid<span>:</span> <span>"3047591896"</span><span>,</span>
        <span>}</span><span>,</span>
        aplayer<span>:</span> <span>{</span>
          lrcType<span>:</span> <span>3</span><span>,</span>
          theme<span>:</span> <span>"#3489fd"</span><span>,</span>
        <span>}</span><span>,</span>
      <span>}</span><span>,</span>
    <span>]</span><span>,</span>
    <span>// ],</span>
    <span>[</span>
      <span>"@vuepress-reco/vuepress-plugin-rss"</span><span>,</span> <span>//RSS插件</span>
      <span>{</span>
        site_url<span>:</span> <span>"http://algorithm.dreamagain.top"</span><span>,</span> <span>//网站地址</span>
        copyright<span>:</span> <span>"nanci"</span><span>,</span> <span>//版权署名</span>
      <span>}</span><span>,</span>
    <span>]</span><span>,</span>
    <span>[</span><span>"@vuepress/nprogress"</span><span>]</span><span>,</span> <span>// 加载进度条</span>
    <span>[</span><span>"reading-progress"</span><span>]</span><span>,</span> <span>// 阅读进度条</span>
    <span>[</span><span>"vuepress-plugin-code-copy"</span><span>]</span><span>,</span> <span>//一键复制代码插件</span>
  <span>]</span><span>,</span>
<span>}</span><span>;</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br><span>96</span><br><span>97</span><br><span>98</span><br><span>99</span><br><span>100</span><br><span>101</span><br><span>102</span><br><span>103</span><br><span>104</span><br><span>105</span><br><span>106</span><br><span>107</span><br><span>108</span><br><span>109</span><br><span>110</span><br><span>111</span><br></div></div><h3 id="二-修改主题"> （二）修改主题</h3>
<p><strong>1、添加图标</strong></p>
<p>主题有默认图标，如果还不满足需求，怎么办？引入阿里妈妈提供的矢量图标库</p>
<p><strong>第一步：</strong></p>
<p>首先你需要登录并创建自己的一下项目，如下示例：</p>
<img src="./assets/vuepress08.png" style="zoom: 80%;" />
<p>为了统一图标前缀，新建一个项目<code>reco-demo</code>并添加一个gitee的图标，如下图所示：</p>
<p><mark>新建项目reco-demo</mark> :</p>
<img src="./assets/vuepress09.png" style="zoom:80%;" />
<p><mark>添加图标gitee</mark> ：</p>
<img src="./assets/vuepress10.png" style="zoom: 50%;" />
<p><strong>第二步：</strong></p>
<p>在.vuepress/styles/下创建一个index.styl文件，将上图所示的代码添加进去</p>
<div><pre><code>//.vuepress/styles/index.styl

@import <span>'//at.alicdn.com/t/font_2372941_unkgma3bras.css'</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>这也是上面配置<code>config.js</code>留下的一个小坑，个人信息栏没有显示<strong>gitee</strong>，也就是默认图标库中没有<code>reco-gitee</code>这个图标</p>
<p><img src="./assets/vuepress11.png" alt=""></p>
<p><strong>第三步：</strong></p>
<p>运行测试，图标可以正常显示。在其他地方扩展图标也是按照这样的步骤来就可以</p>
<p><img src="./assets/vuepress12.png" alt=""></p>
<h3 id="三-修改默认主题"> （三）修改默认主题</h3>
<div><p>提示</p>
<ul>
<li>学习的话可以花些时间捣鼓捣鼓</li>
<li>使用的话可以直接跳过此节</li>
</ul>
</div>
<p>在使用默认主题的情况下可将默认主题的各功能组件释放出来，只需执行命令：</p>
<div><pre><code> vuepress <span>eject</span> docs
</code></pre>
<div><span>1</span><br></div></div><p>你会发现，在根目录下，多了一个theme文件夹，如下：</p>
<p><img src="./assets/vuepress13.png" alt=""></p>
<p>上图列出了主要的布局组件，只需在其中做适量修改以满足业务需求即可。</p>
<p>不过我们用的<code>vuepress-theme-reco</code>主题已经很强大了，没有必要花费太多精力在搭建博客上面，而是花更多的时间在内容创作上。</p>
<h3 id="四-客户端增强"> （四）客户端增强</h3>
<p>如果你想对自己的应用做一些优化，比如使用router做登录拦截、给Vue实例挂载全局变量或注册其他组件等，可以在.vuepress下新建文件<code>enhanceApp.js</code>：</p>
<div><pre><code><span>export</span> <span>default</span> <span>(</span><span>{</span>
  Vue<span>,</span> <span>// vuepress 正在使用的 Vue 构造函数</span>
  options<span>,</span> <span>// 附加到根实例的一些选项</span>
  router<span>,</span> <span>// 当前应用的路由实例</span>
  siteData <span>// 站点元数据</span>
<span>}</span><span>)</span> <span>=</span><span>></span> <span>{</span>
  <span>// ...做一些其他的应用级别的优化</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>这个文件类似于<code>vue-cli</code>脚手架中的main.js文件</p>
<p>这个功能还是比较实用的，可以引入你想要的vue组件库并在md文件中使用。或者利用组件库来封装一个自定义组件。</p>
<p><strong>1、尝试集成Element-UI组件</strong></p>
<p>参照<a href="https://element.eleme.cn/#/zh-CN/component/installation" target="_blank" rel="noopener noreferrer">Element-UI官方文档</a></p>
<p>（1）安装组件</p>
<div><pre><code><span>yarn</span> <span>add</span> element-ui
</code></pre>
<div><span>1</span><br></div></div><p>（2）引入组件</p>
<div><pre><code><span>//.vuepress/enhanceApp.js</span>

<span>/**
 * 扩展 vuepress 应用
 */</span>
<span>import</span> Element <span>from</span> <span>'element-ui'</span>
<span>import</span> <span>'element-ui/lib/theme-chalk/index.css'</span>

<span>export</span> <span>default</span> <span>(</span><span><span>{</span>
  Vue<span>,</span> 
<span>}</span></span><span>)</span> <span>=></span> <span>{</span>
  <span>// ...做一些其他的应用级别的优化</span>
  Vue<span>.</span><span>use</span><span>(</span>Element<span>)</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>在扩展之后，就可以在自定义的组件或者md文件中使用element的组件了。</p>
<p>（3）测试在md中使用</p>
<p>创建<code>blogs/components/element-ui.md</code>，内容如下</p>
<details><summary>element-ui.md</summary>
<div><pre><code><span><span>---</span>
<span><span>title</span><span>:</span> Element<span>-</span>UI Test
<span>date</span><span>:</span> 2021<span>-</span>1<span>-</span><span>15</span>
<span>tags</span><span>:</span>
  <span>-</span> element<span>-</span>ui
<span>categories</span><span>:</span>
  <span>-</span> Vue Components</span>
<span>---</span></span>
<span><span><span>&lt;</span>template</span><span>></span></span>
<span><span><span>&lt;</span>el-row</span><span>></span></span>
  <span><span><span>&lt;</span>el-button</span><span>></span></span>默认按钮<span><span><span>&lt;/</span>el-button</span><span>></span></span>
  <span><span><span>&lt;</span>el-button</span> <span>type</span><span><span>=</span><span>"</span>primary<span>"</span></span><span>></span></span>主要按钮<span><span><span>&lt;/</span>el-button</span><span>></span></span>
  <span><span><span>&lt;</span>el-button</span> <span>type</span><span><span>=</span><span>"</span>success<span>"</span></span><span>></span></span>成功按钮<span><span><span>&lt;/</span>el-button</span><span>></span></span>
  <span><span><span>&lt;</span>el-button</span> <span>type</span><span><span>=</span><span>"</span>info<span>"</span></span><span>></span></span>信息按钮<span><span><span>&lt;/</span>el-button</span><span>></span></span>
  <span><span><span>&lt;</span>el-button</span> <span>type</span><span><span>=</span><span>"</span>warning<span>"</span></span><span>></span></span>警告按钮<span><span><span>&lt;/</span>el-button</span><span>></span></span>
  <span><span><span>&lt;</span>el-button</span> <span>type</span><span><span>=</span><span>"</span>danger<span>"</span></span><span>></span></span>危险按钮<span><span><span>&lt;/</span>el-button</span><span>></span></span>
<span><span><span>&lt;/</span>el-row</span><span>></span></span>

<span><span><span>&lt;</span>el-row</span><span>></span></span>
  <span><span><span>&lt;</span>el-button</span> <span>plain</span><span>></span></span>朴素按钮<span><span><span>&lt;/</span>el-button</span><span>></span></span>
  <span><span><span>&lt;</span>el-button</span> <span>type</span><span><span>=</span><span>"</span>primary<span>"</span></span> <span>plain</span><span>></span></span>主要按钮<span><span><span>&lt;/</span>el-button</span><span>></span></span>
  <span><span><span>&lt;</span>el-button</span> <span>type</span><span><span>=</span><span>"</span>success<span>"</span></span> <span>plain</span><span>></span></span>成功按钮<span><span><span>&lt;/</span>el-button</span><span>></span></span>
  <span><span><span>&lt;</span>el-button</span> <span>type</span><span><span>=</span><span>"</span>info<span>"</span></span> <span>plain</span><span>></span></span>信息按钮<span><span><span>&lt;/</span>el-button</span><span>></span></span>
  <span><span><span>&lt;</span>el-button</span> <span>type</span><span><span>=</span><span>"</span>warning<span>"</span></span> <span>plain</span><span>></span></span>警告按钮<span><span><span>&lt;/</span>el-button</span><span>></span></span>
  <span><span><span>&lt;</span>el-button</span> <span>type</span><span><span>=</span><span>"</span>danger<span>"</span></span> <span>plain</span><span>></span></span>危险按钮<span><span><span>&lt;/</span>el-button</span><span>></span></span>
<span><span><span>&lt;/</span>el-row</span><span>></span></span>

<span><span><span>&lt;</span>el-row</span><span>></span></span>
  <span><span><span>&lt;</span>el-button</span> <span>round</span><span>></span></span>圆角按钮<span><span><span>&lt;/</span>el-button</span><span>></span></span>
  <span><span><span>&lt;</span>el-button</span> <span>type</span><span><span>=</span><span>"</span>primary<span>"</span></span> <span>round</span><span>></span></span>主要按钮<span><span><span>&lt;/</span>el-button</span><span>></span></span>
  <span><span><span>&lt;</span>el-button</span> <span>type</span><span><span>=</span><span>"</span>success<span>"</span></span> <span>round</span><span>></span></span>成功按钮<span><span><span>&lt;/</span>el-button</span><span>></span></span>
  <span><span><span>&lt;</span>el-button</span> <span>type</span><span><span>=</span><span>"</span>info<span>"</span></span> <span>round</span><span>></span></span>信息按钮<span><span><span>&lt;/</span>el-button</span><span>></span></span>
  <span><span><span>&lt;</span>el-button</span> <span>type</span><span><span>=</span><span>"</span>warning<span>"</span></span> <span>round</span><span>></span></span>警告按钮<span><span><span>&lt;/</span>el-button</span><span>></span></span>
  <span><span><span>&lt;</span>el-button</span> <span>type</span><span><span>=</span><span>"</span>danger<span>"</span></span> <span>round</span><span>></span></span>危险按钮<span><span><span>&lt;/</span>el-button</span><span>></span></span>
<span><span><span>&lt;/</span>el-row</span><span>></span></span>

<span><span><span>&lt;</span>el-row</span><span>></span></span>
  <span><span><span>&lt;</span>el-button</span> <span>icon</span><span><span>=</span><span>"</span>el-icon-search<span>"</span></span> <span>circle</span><span>></span></span><span><span><span>&lt;/</span>el-button</span><span>></span></span>
  <span><span><span>&lt;</span>el-button</span> <span>type</span><span><span>=</span><span>"</span>primary<span>"</span></span> <span>icon</span><span><span>=</span><span>"</span>el-icon-edit<span>"</span></span> <span>circle</span><span>></span></span><span><span><span>&lt;/</span>el-button</span><span>></span></span>
  <span><span><span>&lt;</span>el-button</span> <span>type</span><span><span>=</span><span>"</span>success<span>"</span></span> <span>icon</span><span><span>=</span><span>"</span>el-icon-check<span>"</span></span> <span>circle</span><span>></span></span><span><span><span>&lt;/</span>el-button</span><span>></span></span>
  <span><span><span>&lt;</span>el-button</span> <span>type</span><span><span>=</span><span>"</span>info<span>"</span></span> <span>icon</span><span><span>=</span><span>"</span>el-icon-message<span>"</span></span> <span>circle</span><span>></span></span><span><span><span>&lt;/</span>el-button</span><span>></span></span>
  <span><span><span>&lt;</span>el-button</span> <span>type</span><span><span>=</span><span>"</span>warning<span>"</span></span> <span>icon</span><span><span>=</span><span>"</span>el-icon-star-off<span>"</span></span> <span>circle</span><span>></span></span><span><span><span>&lt;/</span>el-button</span><span>></span></span>
  <span><span><span>&lt;</span>el-button</span> <span>type</span><span><span>=</span><span>"</span>danger<span>"</span></span> <span>icon</span><span><span>=</span><span>"</span>el-icon-delete<span>"</span></span> <span>circle</span><span>></span></span><span><span><span>&lt;/</span>el-button</span><span>></span></span>
<span><span><span>&lt;/</span>el-row</span><span>></span></span>
<span><span><span>&lt;/</span>template</span><span>></span></span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br></div></div></details>
<p>（4）运行测试</p>
<p>页面空白，打开控制台查看报错信息</p>
<p><img src="./assets/vuepress14.png" alt=""></p>
<div><p>问题解决</p>
<p>使用命令安装依赖</p>
<div><pre><code><span>yarn</span> <span>add</span> async-validator@1.11.5 
或
<span>npm</span> <span>install</span> async-validator@1.11.5
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>另外，使用命令：</p>
<div><pre><code>npx vuepress info
</code></pre>
<div><span>1</span><br></div></div><p>查看vue包的版本，有助于查看版本是否对应</p>
<div><p>感谢</p>
<p><a href="https://blog.csdn.net/qq_32855007/article/details/108726430" target="_blank" rel="noopener noreferrer">无休止的bug</a></p>
</div>
</div>
<p>再次运行，页面可以正常显示</p>
<p>点击文章Element-UI Test，显示的效果如下</p>
<p><img src="./assets/vuepress15.png" alt=""></p>
<p>在npm官网中也可以找到相关的插件，我们可以免去自己集成的麻烦。经测试，插件<a href="https://superbiger.github.io/vuepress-plugin-tabs/" target="_blank" rel="noopener noreferrer">vuepress-plugin-element-ui</a>可以正常使用。使用yarn安装网站能正常使用，但如果使用npm安装就不行，页面显示是空白的，好在对应github仓库的issue中已经给出解决方法，就是版本对应的问题。</p>
<p>不过如果你要用这个插件就使用yarn来安装，减少不必要的麻烦。</p>
<p><img src="./assets/vuepress51.png" alt=""></p>
<p><strong>2、尝试集成View UI组件</strong></p>
<div><p>提示</p>
<p>View UI原来叫做iview，<a href="">官方文档</a></p>
</div>
<p>（1）安装iview</p>
<div><pre><code><span>yarn</span> <span>add</span> view-design
</code></pre>
<div><span>1</span><br></div></div><p>（2）引入组件</p>
<div><pre><code><span>/**
 * 扩展 vuepress 应用
 */</span>
<span>// import Element from 'element-ui'</span>
<span>// import 'element-ui/lib/theme-chalk/index.css'</span>

<span>import</span> ViewUI <span>from</span> <span>'view-design'</span><span>;</span>
<span>import</span> <span>'view-design/dist/styles/iview.css'</span><span>;</span>


<span>export</span> <span>default</span> <span>(</span><span><span>{</span>
                    Vue<span>,</span>
                <span>}</span></span><span>)</span> <span>=></span> <span>{</span>
    <span>// ...做一些其他的应用级别的优化</span>
    <span>// Vue.use(Element);</span>
    Vue<span>.</span><span>use</span><span>(</span>ViewUI<span>)</span><span>;</span>

<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><p>（3）在md中测试</p>
<p>创建<code>blogs/components/view-ui.md</code>，内容如下</p>
<details><summary>view-ui.md</summary>
<div><pre><code><span><span>---</span>
<span><span>title</span><span>:</span> View UI Test
<span>date</span><span>:</span> <span>2021-01-15</span>
<span>tags</span><span>:</span>
  <span>-</span> iview
  <span>-</span> view ui
<span>categories</span><span>:</span>
  <span>-</span> Vue Components</span>
<span>---</span></span>
<span><span><span>&lt;</span>template</span><span>></span></span>
    <span><span><span>&lt;</span>Row</span><span>></span></span>
        <span><span><span>&lt;</span>Col</span> <span>span</span><span><span>=</span><span>"</span>8<span>"</span></span><span>></span></span>
            <span><span><span>&lt;</span>Menu</span> <span>:theme</span><span><span>=</span><span>"</span>theme2<span>"</span></span><span>></span></span>
                <span><span><span>&lt;</span>Submenu</span> <span>name</span><span><span>=</span><span>"</span>1<span>"</span></span><span>></span></span>
                    <span><span><span>&lt;</span>template</span> <span>slot</span><span><span>=</span><span>"</span>title<span>"</span></span><span>></span></span>
                        <span><span><span>&lt;</span>Icon</span> <span>type</span><span><span>=</span><span>"</span>ios-paper<span>"</span></span> <span>/></span></span>
                        内容管理
                    <span><span><span>&lt;/</span>template</span><span>></span></span>
                    <span><span><span>&lt;</span>MenuItem</span> <span>name</span><span><span>=</span><span>"</span>1-1<span>"</span></span><span>></span></span>文章管理<span><span><span>&lt;/</span>MenuItem</span><span>></span></span>
                    <span><span><span>&lt;</span>MenuItem</span> <span>name</span><span><span>=</span><span>"</span>1-2<span>"</span></span><span>></span></span>评论管理<span><span><span>&lt;/</span>MenuItem</span><span>></span></span>
                    <span><span><span>&lt;</span>MenuItem</span> <span>name</span><span><span>=</span><span>"</span>1-3<span>"</span></span><span>></span></span>举报管理<span><span><span>&lt;/</span>MenuItem</span><span>></span></span>
                <span><span><span>&lt;/</span>Submenu</span><span>></span></span>
                <span><span><span>&lt;</span>Submenu</span> <span>name</span><span><span>=</span><span>"</span>2<span>"</span></span><span>></span></span>
                    <span><span><span>&lt;</span>template</span> <span>slot</span><span><span>=</span><span>"</span>title<span>"</span></span><span>></span></span>
                        <span><span><span>&lt;</span>Icon</span> <span>type</span><span><span>=</span><span>"</span>ios-people<span>"</span></span> <span>/></span></span>
                        用户管理
                    <span><span><span>&lt;/</span>template</span><span>></span></span>
                    <span><span><span>&lt;</span>MenuItem</span> <span>name</span><span><span>=</span><span>"</span>2-1<span>"</span></span><span>></span></span>新增用户<span><span><span>&lt;/</span>MenuItem</span><span>></span></span>
                    <span><span><span>&lt;</span>MenuItem</span> <span>name</span><span><span>=</span><span>"</span>2-2<span>"</span></span><span>></span></span>活跃用户<span><span><span>&lt;/</span>MenuItem</span><span>></span></span>
                <span><span><span>&lt;/</span>Submenu</span><span>></span></span>
                <span><span><span>&lt;</span>Submenu</span> <span>name</span><span><span>=</span><span>"</span>3<span>"</span></span><span>></span></span>
                    <span><span><span>&lt;</span>template</span> <span>slot</span><span><span>=</span><span>"</span>title<span>"</span></span><span>></span></span>
                        <span><span><span>&lt;</span>Icon</span> <span>type</span><span><span>=</span><span>"</span>ios-stats<span>"</span></span> <span>/></span></span>
                        统计分析
                    <span><span><span>&lt;/</span>template</span><span>></span></span>
                    <span><span><span>&lt;</span>MenuGroup</span> <span>title</span><span><span>=</span><span>"</span>使用<span>"</span></span><span>></span></span>
                        <span><span><span>&lt;</span>MenuItem</span> <span>name</span><span><span>=</span><span>"</span>3-1<span>"</span></span><span>></span></span>新增和启动<span><span><span>&lt;/</span>MenuItem</span><span>></span></span>
                        <span><span><span>&lt;</span>MenuItem</span> <span>name</span><span><span>=</span><span>"</span>3-2<span>"</span></span><span>></span></span>活跃分析<span><span><span>&lt;/</span>MenuItem</span><span>></span></span>
                        <span><span><span>&lt;</span>MenuItem</span> <span>name</span><span><span>=</span><span>"</span>3-3<span>"</span></span><span>></span></span>时段分析<span><span><span>&lt;/</span>MenuItem</span><span>></span></span>
                    <span><span><span>&lt;/</span>MenuGroup</span><span>></span></span>
                    <span><span><span>&lt;</span>MenuGroup</span> <span>title</span><span><span>=</span><span>"</span>留存<span>"</span></span><span>></span></span>
                        <span><span><span>&lt;</span>MenuItem</span> <span>name</span><span><span>=</span><span>"</span>3-4<span>"</span></span><span>></span></span>用户留存<span><span><span>&lt;/</span>MenuItem</span><span>></span></span>
                        <span><span><span>&lt;</span>MenuItem</span> <span>name</span><span><span>=</span><span>"</span>3-5<span>"</span></span><span>></span></span>流失用户<span><span><span>&lt;/</span>MenuItem</span><span>></span></span>
                    <span><span><span>&lt;/</span>MenuGroup</span><span>></span></span>
                <span><span><span>&lt;/</span>Submenu</span><span>></span></span>
            <span><span><span>&lt;/</span>Menu</span><span>></span></span>
        <span><span><span>&lt;/</span>Col</span><span>></span></span>
        <span><span><span>&lt;</span>Col</span> <span>span</span><span><span>=</span><span>"</span>8<span>"</span></span><span>></span></span>
            <span><span><span>&lt;</span>Menu</span> <span>:theme</span><span><span>=</span><span>"</span>theme2<span>"</span></span> <span>active-name</span><span><span>=</span><span>"</span>1-2<span>"</span></span> <span>:open-names</span><span><span>=</span><span>"</span>[<span>'</span>1<span>'</span>]<span>"</span></span><span>></span></span>
                <span><span><span>&lt;</span>Submenu</span> <span>name</span><span><span>=</span><span>"</span>1<span>"</span></span><span>></span></span>
                    <span><span><span>&lt;</span>template</span> <span>slot</span><span><span>=</span><span>"</span>title<span>"</span></span><span>></span></span>
                        <span><span><span>&lt;</span>Icon</span> <span>type</span><span><span>=</span><span>"</span>ios-paper<span>"</span></span> <span>/></span></span>
                        内容管理
                    <span><span><span>&lt;/</span>template</span><span>></span></span>
                    <span><span><span>&lt;</span>MenuItem</span> <span>name</span><span><span>=</span><span>"</span>1-1<span>"</span></span><span>></span></span>文章管理<span><span><span>&lt;/</span>MenuItem</span><span>></span></span>
                    <span><span><span>&lt;</span>MenuItem</span> <span>name</span><span><span>=</span><span>"</span>1-2<span>"</span></span><span>></span></span>评论管理<span><span><span>&lt;/</span>MenuItem</span><span>></span></span>
                    <span><span><span>&lt;</span>MenuItem</span> <span>name</span><span><span>=</span><span>"</span>1-3<span>"</span></span><span>></span></span>举报管理<span><span><span>&lt;/</span>MenuItem</span><span>></span></span>
                <span><span><span>&lt;/</span>Submenu</span><span>></span></span>
                <span><span><span>&lt;</span>Submenu</span> <span>name</span><span><span>=</span><span>"</span>2<span>"</span></span><span>></span></span>
                    <span><span><span>&lt;</span>template</span> <span>slot</span><span><span>=</span><span>"</span>title<span>"</span></span><span>></span></span>
                        <span><span><span>&lt;</span>Icon</span> <span>type</span><span><span>=</span><span>"</span>ios-people<span>"</span></span> <span>/></span></span>
                        用户管理
                    <span><span><span>&lt;/</span>template</span><span>></span></span>
                    <span><span><span>&lt;</span>MenuItem</span> <span>name</span><span><span>=</span><span>"</span>2-1<span>"</span></span><span>></span></span>新增用户<span><span><span>&lt;/</span>MenuItem</span><span>></span></span>
                    <span><span><span>&lt;</span>MenuItem</span> <span>name</span><span><span>=</span><span>"</span>2-2<span>"</span></span><span>></span></span>活跃用户<span><span><span>&lt;/</span>MenuItem</span><span>></span></span>
                <span><span><span>&lt;/</span>Submenu</span><span>></span></span>
                <span><span><span>&lt;</span>Submenu</span> <span>name</span><span><span>=</span><span>"</span>3<span>"</span></span><span>></span></span>
                    <span><span><span>&lt;</span>template</span> <span>slot</span><span><span>=</span><span>"</span>title<span>"</span></span><span>></span></span>
                        <span><span><span>&lt;</span>Icon</span> <span>type</span><span><span>=</span><span>"</span>ios-stats<span>"</span></span> <span>/></span></span>
                        统计分析
                    <span><span><span>&lt;/</span>template</span><span>></span></span>
                    <span><span><span>&lt;</span>MenuGroup</span> <span>title</span><span><span>=</span><span>"</span>使用<span>"</span></span><span>></span></span>
                        <span><span><span>&lt;</span>MenuItem</span> <span>name</span><span><span>=</span><span>"</span>3-1<span>"</span></span><span>></span></span>新增和启动<span><span><span>&lt;/</span>MenuItem</span><span>></span></span>
                        <span><span><span>&lt;</span>MenuItem</span> <span>name</span><span><span>=</span><span>"</span>3-2<span>"</span></span><span>></span></span>活跃分析<span><span><span>&lt;/</span>MenuItem</span><span>></span></span>
                        <span><span><span>&lt;</span>MenuItem</span> <span>name</span><span><span>=</span><span>"</span>3-3<span>"</span></span><span>></span></span>时段分析<span><span><span>&lt;/</span>MenuItem</span><span>></span></span>
                    <span><span><span>&lt;/</span>MenuGroup</span><span>></span></span>
                    <span><span><span>&lt;</span>MenuGroup</span> <span>title</span><span><span>=</span><span>"</span>留存<span>"</span></span><span>></span></span>
                        <span><span><span>&lt;</span>MenuItem</span> <span>name</span><span><span>=</span><span>"</span>3-4<span>"</span></span><span>></span></span>用户留存<span><span><span>&lt;/</span>MenuItem</span><span>></span></span>
                        <span><span><span>&lt;</span>MenuItem</span> <span>name</span><span><span>=</span><span>"</span>3-5<span>"</span></span><span>></span></span>流失用户<span><span><span>&lt;/</span>MenuItem</span><span>></span></span>
                    <span><span><span>&lt;/</span>MenuGroup</span><span>></span></span>
                <span><span><span>&lt;/</span>Submenu</span><span>></span></span>
            <span><span><span>&lt;/</span>Menu</span><span>></span></span>
        <span><span><span>&lt;/</span>Col</span><span>></span></span>
        <span><span><span>&lt;</span>Col</span> <span>span</span><span><span>=</span><span>"</span>8<span>"</span></span><span>></span></span>
            <span><span><span>&lt;</span>Menu</span> <span>:theme</span><span><span>=</span><span>"</span>theme2<span>"</span></span> <span>:open-names</span><span><span>=</span><span>"</span>[<span>'</span>1<span>'</span>]<span>"</span></span> <span>accordion</span><span>></span></span>
                <span><span><span>&lt;</span>Submenu</span> <span>name</span><span><span>=</span><span>"</span>1<span>"</span></span><span>></span></span>
                    <span><span><span>&lt;</span>template</span> <span>slot</span><span><span>=</span><span>"</span>title<span>"</span></span><span>></span></span>
                        <span><span><span>&lt;</span>Icon</span> <span>type</span><span><span>=</span><span>"</span>ios-paper<span>"</span></span> <span>/></span></span>
                        内容管理
                    <span><span><span>&lt;/</span>template</span><span>></span></span>
                    <span><span><span>&lt;</span>MenuItem</span> <span>name</span><span><span>=</span><span>"</span>1-1<span>"</span></span><span>></span></span>文章管理<span><span><span>&lt;/</span>MenuItem</span><span>></span></span>
                    <span><span><span>&lt;</span>MenuItem</span> <span>name</span><span><span>=</span><span>"</span>1-2<span>"</span></span><span>></span></span>评论管理<span><span><span>&lt;/</span>MenuItem</span><span>></span></span>
                    <span><span><span>&lt;</span>MenuItem</span> <span>name</span><span><span>=</span><span>"</span>1-3<span>"</span></span><span>></span></span>举报管理<span><span><span>&lt;/</span>MenuItem</span><span>></span></span>
                <span><span><span>&lt;/</span>Submenu</span><span>></span></span>
                <span><span><span>&lt;</span>Submenu</span> <span>name</span><span><span>=</span><span>"</span>2<span>"</span></span><span>></span></span>
                    <span><span><span>&lt;</span>template</span> <span>slot</span><span><span>=</span><span>"</span>title<span>"</span></span><span>></span></span>
                        <span><span><span>&lt;</span>Icon</span> <span>type</span><span><span>=</span><span>"</span>ios-people<span>"</span></span> <span>/></span></span>
                        用户管理
                    <span><span><span>&lt;/</span>template</span><span>></span></span>
                    <span><span><span>&lt;</span>MenuItem</span> <span>name</span><span><span>=</span><span>"</span>2-1<span>"</span></span><span>></span></span>新增用户<span><span><span>&lt;/</span>MenuItem</span><span>></span></span>
                    <span><span><span>&lt;</span>MenuItem</span> <span>name</span><span><span>=</span><span>"</span>2-2<span>"</span></span><span>></span></span>活跃用户<span><span><span>&lt;/</span>MenuItem</span><span>></span></span>
                <span><span><span>&lt;/</span>Submenu</span><span>></span></span>
                <span><span><span>&lt;</span>Submenu</span> <span>name</span><span><span>=</span><span>"</span>3<span>"</span></span><span>></span></span>
                    <span><span><span>&lt;</span>template</span> <span>slot</span><span><span>=</span><span>"</span>title<span>"</span></span><span>></span></span>
                        <span><span><span>&lt;</span>Icon</span> <span>type</span><span><span>=</span><span>"</span>ios-stats<span>"</span></span> <span>/></span></span>
                        统计分析
                    <span><span><span>&lt;/</span>template</span><span>></span></span>
                    <span><span><span>&lt;</span>MenuGroup</span> <span>title</span><span><span>=</span><span>"</span>使用<span>"</span></span><span>></span></span>
                        <span><span><span>&lt;</span>MenuItem</span> <span>name</span><span><span>=</span><span>"</span>3-1<span>"</span></span><span>></span></span>新增和启动<span><span><span>&lt;/</span>MenuItem</span><span>></span></span>
                        <span><span><span>&lt;</span>MenuItem</span> <span>name</span><span><span>=</span><span>"</span>3-2<span>"</span></span><span>></span></span>活跃分析<span><span><span>&lt;/</span>MenuItem</span><span>></span></span>
                        <span><span><span>&lt;</span>MenuItem</span> <span>name</span><span><span>=</span><span>"</span>3-3<span>"</span></span><span>></span></span>时段分析<span><span><span>&lt;/</span>MenuItem</span><span>></span></span>
                    <span><span><span>&lt;/</span>MenuGroup</span><span>></span></span>
                    <span><span><span>&lt;</span>MenuGroup</span> <span>title</span><span><span>=</span><span>"</span>留存<span>"</span></span><span>></span></span>
                        <span><span><span>&lt;</span>MenuItem</span> <span>name</span><span><span>=</span><span>"</span>3-4<span>"</span></span><span>></span></span>用户留存<span><span><span>&lt;/</span>MenuItem</span><span>></span></span>
                        <span><span><span>&lt;</span>MenuItem</span> <span>name</span><span><span>=</span><span>"</span>3-5<span>"</span></span><span>></span></span>流失用户<span><span><span>&lt;/</span>MenuItem</span><span>></span></span>
                    <span><span><span>&lt;/</span>MenuGroup</span><span>></span></span>
                <span><span><span>&lt;/</span>Submenu</span><span>></span></span>
            <span><span><span>&lt;/</span>Menu</span><span>></span></span>
        <span><span><span>&lt;/</span>Col</span><span>></span></span>
    <span><span><span>&lt;/</span>Row</span><span>></span></span>
    <span><span><span>&lt;</span>br</span><span>></span></span>
    <span><span><span>&lt;</span>p</span><span>></span></span>Change theme<span><span><span>&lt;/</span>p</span><span>></span></span>
    <span><span><span>&lt;</span>RadioGroup</span> <span>v-model</span><span><span>=</span><span>"</span>theme2<span>"</span></span><span>></span></span>
        <span><span><span>&lt;</span>Radio</span> <span>label</span><span><span>=</span><span>"</span>light<span>"</span></span><span>></span></span><span><span><span>&lt;/</span>Radio</span><span>></span></span>
        <span><span><span>&lt;</span>Radio</span> <span>label</span><span><span>=</span><span>"</span>dark<span>"</span></span><span>></span></span><span><span><span>&lt;/</span>Radio</span><span>></span></span>
    <span><span><span>&lt;/</span>RadioGroup</span><span>></span></span>
<span><span><span>&lt;/</span>template</span><span>></span></span>
<span><span><span>&lt;</span>script</span><span>></span></span><span><span>
    <span>export</span> <span>default</span> <span>{</span>
        <span>data</span> <span>(</span><span>)</span> <span>{</span>
            <span>return</span> <span>{</span>
                theme2<span>:</span> <span>'light'</span>
            <span>}</span>
        <span>}</span>
    <span>}</span>
</span></span><span><span><span>&lt;/</span>script</span><span>></span></span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br><span>96</span><br><span>97</span><br><span>98</span><br><span>99</span><br><span>100</span><br><span>101</span><br><span>102</span><br><span>103</span><br><span>104</span><br><span>105</span><br><span>106</span><br><span>107</span><br><span>108</span><br><span>109</span><br><span>110</span><br><span>111</span><br><span>112</span><br><span>113</span><br><span>114</span><br><span>115</span><br><span>116</span><br><span>117</span><br><span>118</span><br><span>119</span><br><span>120</span><br><span>121</span><br><span>122</span><br><span>123</span><br><span>124</span><br><span>125</span><br><span>126</span><br><span>127</span><br><span>128</span><br><span>129</span><br><span>130</span><br><span>131</span><br><span>132</span><br><span>133</span><br><span>134</span><br><span>135</span><br><span>136</span><br><span>137</span><br></div></div></details>
<p>（4）运行测试</p>
<p>发现页面空白，控制台信息如下，所以不知道是哪里有问题</p>
<p><img src="./assets/vuepress16.png" alt=""></p>
<p>索性把enhanceApp.js内容全部注释，页面恢复正常。为什么会这样，原因未知，有待继续深入学习。</p>
<p>参照view ui文档中的main.js</p>
<p><img src="./assets/vuepress17.png" alt=""></p>
<p>修改enhanceApp.js的内容如下：</p>
<div><pre><code><span>// import Element from 'element-ui'</span>
<span>// import 'element-ui/lib/theme-chalk/index.css'</span>
<span>import</span> Vue <span>from</span> <span>'vue'</span><span>;</span>
<span>import</span> ViewUI <span>from</span> <span>'view-design'</span><span>;</span>
<span>import</span> <span>'view-design/dist/styles/iview.css'</span><span>;</span>
Vue<span>.</span><span>use</span><span>(</span>ViewUI<span>)</span><span>;</span>

<span>export</span> <span>default</span> <span>(</span><span><span>{</span>
                    Vue<span>,</span>
                <span>}</span></span><span>)</span> <span>=></span> <span>{</span>
    <span>// ...做一些其他的应用级别的优化</span>
    <span>// Vue.use(Element);</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>查看首页面已经能够正常显示，点开View UI Test文章查看，效果也正常显示</p>
<p><img src="./assets/vuepress18.png" alt=""></p>
<p>以上测试了两个前端常用的组件库Element-UI和View UI，其他的组件库的使用也是类似，如果出现页面空白而后台没有报错的情况，先查看浏览器控制台报错信息，问题不明显可百度查找解决方法。</p>
<div><p>提示</p>
<p><strong>修改enhanceApp.js内容后项目不用重启，直接看浏览器中是否正常显示</strong>。</p>
</div>
<h3 id="五-个性化组件开发"> （五）个性化组件开发</h3>
<p>上一小节演示的是直接在md文件中使用vue，实际写博客时这样操作就失去了写博客的初衷了，所以我们一般都是利用第三方的组件库来便携编写一个我们自己的组件，方便我们在md文件中使用</p>
<p>如果我们需要开发自己的组件，那么在<code>.vuepress</code>下新建<code>components</code>文件夹，可以在里面编写vue文件，与vue-cli开发无异，而且，组件是全局注册的，组件之间互相调用，不用手动引入，<strong>在md文件中，在theme中都可以使用</strong>。</p>
<p>下图是对应的官方说明</p>
<img src="./assets/vuepress19.png" style="zoom:80%;" />
<h3 id="六-博客的自动路由"> （六）博客的自动路由</h3>
<p>vuepress是一个单页面应用，所谓路由，是VueRouter模拟出来的假象，通过官方对<a href="https://vuepress.vuejs.org/zh/theme/writing-a-theme.html#%E7%BD%91%E7%AB%99%E5%92%8C%E9%A1%B5%E9%9D%A2%E7%9A%84%E5%85%83%E6%95%B0%E6%8D%AE" target="_blank" rel="noopener noreferrer">元数据</a> 的描述，我们可以了解到<code>vuepress</code>能够提供博客中的分类、标签、时间线等功能支持主要就是使用元数据 <strong>$page</strong> 来实现，看一下官方文档中比较关键的说明：</p>
<div><p>元数据</p>
<p><code>pages</code> 是一个包含了每个页面元数据对象的数据，包括它的路径、页面标题（明确地通过 <a href="https://vuepress.vuejs.org/zh/guide/markdown.html#front-matter" target="_blank" rel="noopener noreferrer">YAML front matter</a> 指定，或者通过该页面的第一个标题取到），以及所有源文件中的 <code>YAML front matter</code> 的数据。</p>
<p>如果用户在 <code>.vuepress/config.js</code> 配置了 <code>themeConfig</code>，你将可以通过 <code>$site.themeConfig</code> 访问到它。如此一来，你可以通过它来对用户开放一些自定义主题的配置 —— 比如指定目录或者页面的顺序，你也可以结合 <code>$site.pages</code> 来动态地构建导航链接。</p>
<p>最后，别忘了，作为 Vue Router API 的一部分，<code>this.$route</code> 和 <code>this.$router</code> 同样可以使用。</p>
</div>
<p>没错，<strong>$pages</strong>它记录了所有md文件的元数据，我可以通过在元数据中添加分类、标签，以及时间来实现路由。</p>
<p>每一次新写的文章，无需在config.js中设置路由，只需要在md中按照元数据的格式，设置好type(分类),tags(标签)。</p>
<p>最后编译，push到github，就可以在相应的菜单中看到它。</p>
<p><mark>如果你有兴趣去做一些相关开发，元数据是你得好好深入学习一下</mark></p>
<h3 id="七-导航栏与侧边栏"> （七）导航栏与侧边栏</h3>
<p>我们不必把导航栏和侧边栏的配置都放到config.js中，我们可以单独配置然后在config.js中引用</p>
<p><strong>1、.vuepress下创建以下的文件结构</strong></p>
<div><pre><code><span>.</span>vuepress
├─ config
	├─ navbar
    <span>|</span>  └── index<span>.</span>js
	└─ sidebar
       └── index<span>.</span>js

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>navbar/index.js内容</p>
<div><pre><code>module<span>.</span>exports<span>=</span><span>[</span>

    <span>{</span>text<span>:</span> <span>'首页'</span><span>,</span> link<span>:</span> <span>'/'</span><span>,</span> icon<span>:</span> <span>'reco-home'</span><span>}</span><span>,</span>
    <span>{</span> text<span>:</span> <span>"时间线"</span><span>,</span> link<span>:</span> <span>"/timeline/"</span><span>,</span> icon<span>:</span> <span>"reco-date"</span> <span>}</span><span>,</span>
    <span>{</span>
        text<span>:</span> <span>"联系"</span><span>,</span>
        icon<span>:</span> <span>"reco-message"</span><span>,</span>
        items<span>:</span> <span>[</span>
            <span>{</span>text<span>:</span> <span>'七七部落'</span><span>,</span> link<span>:</span> <span>'http://qiqi.dreamagain.top/'</span><span>,</span> icon<span>:</span> <span>'reco-logo'</span><span>}</span><span>,</span>
            <span>{</span>text<span>:</span> <span>'GitHub'</span><span>,</span> link<span>:</span> <span>'https://github.com/small-universe/qiqi-algorithm'</span><span>,</span> icon<span>:</span> <span>'reco-github'</span><span>}</span><span>,</span>
            <span>{</span>text<span>:</span> <span>"CSDN"</span><span>,</span> link<span>:</span> <span>"https://blog.csdn.net/qq_27961843/"</span><span>,</span> icon<span>:</span> <span>"reco-csdn"</span><span>}</span><span>,</span>
            <span>{</span>text<span>:</span> <span>"QQ"</span><span>,</span> link<span>:</span> <span>"tencent://message/?uin=1715261428"</span><span>,</span> icon<span>:</span> <span>"reco-qq"</span><span>}</span><span>,</span>
            <span>{</span>text<span>:</span> <span>"Gmail"</span><span>,</span> link<span>:</span> <span>"mailto:18846770224@163.com"</span><span>,</span> icon<span>:</span> <span>"reco-mail"</span><span>}</span><span>,</span>
        <span>]</span><span>,</span>
    <span>}</span><span>,</span>
<span>]</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p>sidebar/index.js内容</p>
<div><pre><code>//侧边栏
module.exports = {
    &#39;/blogs/&#39;: [
        {
            title: &#39;分类一&#39;,
            collapsable: false,
            children: [
                &#39;./category1/2018/121501&#39;,
                &#39;./category1/2019/092101&#39;,
            ]
        },
        {
            title: &#39;分类二&#39;,
            collapsable: false,
            children: [
                &#39;./category2/2016/121501&#39;,
                &#39;./category2/2017/092101&#39;,
            ]
        },
        {
            title: &#39;组件&#39;,
            // collapsable: false,
            children: [
                &#39;./components/element-ui&#39;,
                &#39;./components/view-ui&#39;,
            ]
        },
    ],

}


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br></div></div><p><strong>2、config.js中导入</strong></p>
<div><div><div>&nbsp;</div><div>&nbsp;</div><br><br><br><br><div>&nbsp;</div><div>&nbsp;</div><br><br><br><br></div><pre><code><span>const</span> sidebar <span>=</span> <span>require</span><span>(</span><span>'./config/sidebar'</span><span>)</span>
<span>const</span> nav <span>=</span> <span>require</span><span>(</span><span>'./config/navbar'</span><span>)</span>
<span>...</span><span>...</span>
  themeConfig<span>:</span> <span>{</span>
    type<span>:</span> <span>"blog"</span><span>,</span> <span>//选择类型博客</span>
    fullscreen<span>:</span> <span>true</span><span>,</span>
    nav<span>,</span> <span>//导航栏设置</span>
    sidebar<span>,</span> <span>//侧边栏</span>
    subSidebar<span>:</span> <span>'auto'</span><span>,</span><span>//在所有页面中启用自动生成子侧边栏，原 sidebar 仍然兼容</span>
  <span>}</span>
<span>...</span><span>...</span>
</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p><strong>3、测试</strong></p>
<p><img src="./assets/vuepress20.png" alt=""></p>
<div><p>问题小结</p>
<ol>
<li>
<p><s>切换主题颜色的按钮样式改变，如下图所示</s> ：<mark>引入第三方组件库导致</mark></p>
</li>
<li>
<p><s>点击标签，页面跳转后显示空白</s>：<mark>引入第三方组件库导致</mark></p>
<p><img src="./assets/vuepress50.png" alt=""></p>
</li>
<li>
<p><s>去除组件库后，按钮样式正常，标签和分类功能出现返回时页面404</s>： <mark>标签和分类不能是中文，不能有空格</mark></p>
</li>
</ol>
<p>当前版本还是存在一些不足之处，坐等主题稳定新版本。</p>
</div>
<h2 id="四、部署"> 四、部署</h2>
<h3 id="一-通过deploy-sh脚本部署"> （一）通过deploy.sh脚本部署</h3>
<p>在项目的根路径下创建脚本deploy.sh，内容如下：</p>
<div><pre><code># 确保脚本抛出遇到的错误
set -e

# 生成静态文件
npm run build

# 进入生成的文件夹
cd .vuepress/dist

# 如果是发布到自定义域名
#　echo &#39;reco-demo.dreamagain.top&#39; &gt; CNAME

git init
git add -A
git commit -m &#39;deploy&#39;

# 如果发布到 https://&lt;USERNAME&gt;.github.io
# git push -f git@github.com:&lt;USERNAME&gt;/&lt;USERNAME&gt;.github.io.git master

# 如果发布到 https://&lt;USERNAME&gt;.github.io/&lt;REPO&gt;
# git push -f git@github.com:&lt;USERNAME&gt;/&lt;REPO&gt;.git master:gh-pages

git push -f git@github.com:small-universe/reco-demo.git master:gh-pages

cd -

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><p>在package.json的script中添加如下内容</p>
<div><div><br><div>&nbsp;</div><br><br></div><pre><code><span>"scripts"</span><span>:</span> <span>{</span>
    <span>"deploy"</span><span>:</span> <span>"deploy.sh"</span>
  <span>}</span><span>,</span>
</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>执行命令</p>
<div><pre><code><span>yarn</span> run deploy
</code></pre>
<div><span>1</span><br></div></div><p>项目构建的静态文件已经被发布到对应的github仓库的gh-pages分支</p>
<p><img src="./assets/vuepress21.png" alt=""></p>
<p>点开仓库的设置往下找到GitHub Pages</p>
<p><img src="./assets/vuepress22.png" alt=""></p>
<p><img src="./assets/vuepress23.png" alt=""></p>
<p>访问https://small-universe.github.io/reco-demo/，结果surprise，我们的页面样式丢失了。</p>
<p><img src="./assets/vuepress24.png" alt=""></p>
<p><mark>更多的报错信息说是无法加载静态资源：</mark></p>
<img src="./assets/vuepress25.png" style="zoom:80%;" />
<p>​		仔细查看访问静态资源使用的都是'/'开头，说明默认是从根路径开始查找，但是实际上我们应该使用相对路径，接下来怎么办？</p>
<p>​        回头再仔细看看官方文档有没有什么被我们忽略的说明。</p>
<p>果然在<a href="https://vuepress.vuejs.org/zh/config/#base" target="_blank" rel="noopener noreferrer">基本配置</a>里有这样的说明：</p>
<p><img src="./assets/vuepress26.png" alt=""></p>
<p>那就在config.js中配置一下<code>base: &quot;/reco-demo/&quot;,</code></p>
<div><pre><code>module<span>.</span>exports <span>=</span> <span>{</span>
  host<span>:</span> <span>"127.0.0.1"</span><span>,</span> <span>// 生成网页地址（本地调试使用）</span>
  port<span>:</span> <span>"65535"</span><span>,</span> <span>// 生成网页端口（本地调试使用）</span>
  title<span>:</span> <span>"reco-demo"</span><span>,</span> <span>// 显示在左上角的网页名称以及首页在浏览器标签显示的title名称</span>
  description<span>:</span> <span>"A blog template with vuepress-theme-reco."</span><span>,</span> <span>// meta 中的描述文字，用于SEO</span>
  base<span>:</span> <span>"/reco-demo/"</span><span>,</span>
  <span>...</span><span>...</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>再执行一下命令<code>yarn run deploy</code>，这次正常显示了</p>
<p><img src="./assets/vuepress27.png" alt=""></p>
<div><p>提示</p>
<p>配置到此，基本的使用是没有问题了，可以开开心心写博客了。</p>
<p>但还有下面几个步骤，推荐配置一下Github Actions自动部署，这样使用起来会更舒心一些，每次只需要push文件到远程仓库即可，使用deploy.sh部署的这种方式就可以不用了。</p>
</div>
<h3 id="二-github-actions自动部署-推荐"> （二）Github Actions自动部署（推荐）</h3>
<p>在 Github 网页上添加 Github Actions 配置文件，参考<a href="https://docs.github.com/cn/actions/quickstart" target="_blank" rel="noopener noreferrer">官方的文档</a>，可自行取舍相应内容，其中需要保密的部分需要添加 Github Secrets 环境变量【仓库的 Settings --&gt; Secrets --&gt; Add a new secret】</p>
<p>在看官方文档之前建议看一下简单的入门教程，推荐<a href="http://www.ruanyifeng.com/blog/2019/09/getting-started-with-github-actions.html" target="_blank" rel="noopener noreferrer">阮一峰 GitHub Actions 入门教程</a>，对<code>Guthub Actions</code>有基本了解后就可以参照官方文档进行详细的配置</p>
<p><strong>1、配置步骤：</strong></p>
<p>第一步: 创建<code>.github/workflows</code>目录并在该目录下创建<code>deploy.yml</code>文件，内容如下：</p>
<div><pre><code><span>name</span><span>:</span> Deploy

<span>on</span><span>:</span>
  <span>push</span><span>:</span>
    <span>branches</span><span>:</span>
      <span>-</span> master

<span>jobs</span><span>:</span>
  <span>deploy-gh-pages</span><span>:</span>
    <span>runs-on</span><span>:</span> ubuntu<span>-</span>latest
    <span>steps</span><span>:</span>
      <span># 获取源码</span>
      <span>-</span> <span>name</span><span>:</span> Checkout
        <span>uses</span><span>:</span> actions/checkout@v2
        <span>with</span><span>:</span>
          <span>persist-credentials</span><span>:</span> <span>false</span>
          <span>ssh-key</span><span>:</span> $<span>{</span><span>{</span> secrets.SSH_PRIVATE_KEY <span>}</span><span>}</span>
          <span>submodules</span><span>:</span> <span>true</span>
          <span>fetch-depth</span><span>:</span> <span>0</span>
	  <span># 缓存依赖项配置</span>
      <span>-</span> <span>uses</span><span>:</span> actions/cache@v2
        <span>id</span><span>:</span> node<span>-</span>modules
        <span>with</span><span>:</span>
          <span>path</span><span>:</span> node_modules/
          <span>key</span><span>:</span> $<span>{</span><span>{</span> runner.os <span>}</span><span>}</span><span>-</span>node<span>-</span>modules<span>-</span>$<span>{</span><span>{</span> hashFiles('yarn.lock') <span>}</span><span>}</span>
          <span>restore-keys</span><span>:</span> <span>|</span><span>
            ${{ runner.os }}-node-modules-</span>
	  <span># 安装依赖</span>
      <span>-</span> <span>name</span><span>:</span> Install Deps
        <span>if</span><span>:</span> steps.node<span>-</span>modules.outputs.cache<span>-</span>hit <span>!=</span> 'true'
        <span>run</span><span>:</span> yarn install <span>-</span><span>-</span>frozen<span>-</span>lockfile

	  <span># 构建</span>
      <span>-</span> <span>name</span><span>:</span> Build reco<span>-</span>demo
        <span>run</span><span>:</span> yarn run build

	  <span># 部署</span>
      <span>-</span> <span>name</span><span>:</span> Deploy To gh<span>-</span>pages
        <span>uses</span><span>:</span> JamesIves/github<span>-</span>pages<span>-</span>deploy<span>-</span>action@releases/v3
        <span>with</span><span>:</span>
          <span>ACCESS_TOKEN</span><span>:</span> $<span>{</span><span>{</span> secrets.ACCESS_TOKEN <span>}</span><span>}</span>
          <span>BRANCH</span><span>:</span> gh<span>-</span>pages
          <span>FOLDER</span><span>:</span> .vuepress/dist
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br></div></div><p>第二步：配置<code>ACCESS_TOKEN</code></p>
<p>1、生成Personal access tokens（ <mark>仅第一次显示</mark> ）</p>
<p><img src="./assets/vuepress29.png" alt=""></p>
<p>2、复制 <code>ACCESS_TOKEN</code>内容到仓库的Settings --&gt; Secrets--&gt;<code>ACCESS_TOKEN</code></p>
<p><img src="./assets/vuepress32.png" alt=""></p>
<p>第三步：配置<code>SSH_PRIVATE_KEY</code></p>
<p>1、生成sshkey: 输入命令ssh-keygen -t rsa -C &quot;邮箱地址&quot; 【邮箱地址：注册github时填写的邮箱地址】</p>
<div><pre><code>ssh-keygen -t rsa -C <span>"1715261428@qq.com"</span>
</code></pre>
<div><span>1</span><br></div></div><p>2、进入.ssh目录</p>
<p><img src="./assets/vuepress30.png" alt=""></p>
<p>3、复制 id_rsa内容到仓库的 Settings --&gt; Secrets--&gt;SSH_PRIVATE_KEY</p>
<p><img src="./assets/vuepress31.png" alt=""></p>
<p>第四步：测试</p>
<p>报错如下</p>
<p><img src="./assets/vuepress33.png" alt=""></p>
<p>我们config.js的配置这样：</p>
<div><pre><code><span>const</span> sidebar <span>=</span> <span>require</span><span>(</span><span>'./config/sidebar'</span><span>)</span>
<span>const</span> nav <span>=</span> <span>require</span><span>(</span><span>'./config/navbar'</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>本地测试正常，线上就出问题，那我们就配置完整路径</p>
<div><pre><code><span>const</span> sidebar <span>=</span> <span>require</span><span>(</span><span>'./config/sidebar/index.js'</span><span>)</span>
</code></pre>
<div><span>1</span><br></div></div><p>再次提交，测试，部署成功。</p>
<p><img src="./assets/vuepress34.png" alt=""></p>
<p>第五步：配置域名</p>
<div><p>设置域名dns指向（ 补充）</p>
<p>方法有<strong>3种</strong>：</p>
<ul>
<li><strong>第一种：</strong>
A记录：域名直接映射IP，但是这个IP换成了192.30.252.153或192.30.252.154。</li>
<li><strong>第二种：</strong>
如果域名提供商支持ALIAS或ANAME，将域名指向username.github.io，这样可以在域名解析的时候得到一个动态的IP，这个IP是一台离你最近的镜像主机。</li>
<li><strong>第三种：</strong>
CNMAE：如果你希望使用二级域名访问，将一个二级域名配置成CNAME，指向username.github.io，这样可以在域名解析的时候得到一个动态的IP，这个IP是一台离你最近的镜像主机</li>
</ul>
<p>这里使用的是第三种方法CNAME。</p>
</div>
<p>在域名供应商处新增一个CNAME类型的域名域名解析,记录类型固定的是 ：<strong>CNAME</strong>，记录值就是你的<strong>GitHub</strong>地址</p>
<p>这里还白嫖了百度云CDN加速</p>
<p><img src="./assets/vuepress35.png" alt=""></p>
<p>Github Pages添加自定义域名，点击<code>save</code>等它解析一会</p>
<p><img src="./assets/vuepress36.png" alt=""></p>
<p>如下图所示，你可以通过域名http://reco-demo.dreamagain.top访问了</p>
<p><img src="./assets/vuepress37.png" alt=""></p>
<p>访问测试，又是一个surprise！！！,就是惊喜加意外。</p>
<p><img src="./assets/vuepress38.png" alt=""></p>
<p>如上图中资源的访问路径应该是没有问题，那我们通过deploy.sh直接设置自定义域名试一下</p>
<div><pre><code><span># 如果是发布到自定义域名</span>
<span>echo</span> <span>'reco-demo.dreamagain.top'</span> <span>></span> CNAME
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>执行命令<code>yarn run deploy</code>，运行结束后再次访问<code>reco-demo.dreamagain.top</code>，样式依旧还是没有出来</p>
<p>两种方式下自定义域名都出现样式丢失，想到之前样式丢失的时候我们加了<code>base:&quot;/reco-demo/&quot;</code>，我们注释掉base配置尝试一下。</p>
<p>结果发现注释之后能通过自定义域名正常访问了。</p>
<p><img src="./assets/vuepress39.png" alt=""></p>
<p>对比一下没有配置自定义域名的情况下如何访问到静态资源的</p>
<p><img src="./assets/vuepress40.png" alt=""></p>
<p>这就是说明了自定义域名<code>http://reco-demo.dreamagain.top/</code>--&gt;<code>https://small-universe.github.io/reco-demo/</code></p>
<p>在vuepress中没有看到这样的说明，那我们就去github中看看自定义域名的相关文档，</p>
<p><img src="./assets/vuepress41.png" alt=""></p>
<p>与测试时得出的结论有点出入，但大体是一个意思。仓库下配置类自定义域名<code>reco-demo.dreamagain.top</code>虽然只是替换的<code>&lt;user&gt;.github.io</code>，但此时Gihub Pages服务已经默认通过域名直接访问仓库中资源，所以这时候不用在config.js中添加<code>base:&quot;/reco-demo/&quot;</code>了</p>
<div><p>小结</p>
<p>仓库名为<code>&lt;username&gt;.github.io</code>或者是使用自定义域名，不用在config.js中配置base字段</p>
<p>不使用自定义域名且仓库名不是<code>&lt;username&gt;.github.io</code>,那么<code>base</code> 应该被设置成 <code>&quot;/&lt;仓库名&gt;/&quot;</code></p>
</div>
<p><strong>2、完善评论功能</strong></p>
<p>第一步：<a href="https://console.leancloud.cn/login" target="_blank" rel="noopener noreferrer">LeanCloud</a>注册并登录</p>
<p><img src="./assets/vuepress42.png" alt=""></p>
<p>第二步：创建应用</p>
<p><img src="./assets/vuepress43.png" alt=""></p>
<p>第三步：获取AppKey和AppID</p>
<p><img src="./assets/vuepress44.png" alt=""></p>
<p><img src="./assets/vuepress45.png" alt=""></p>
<p>第四步：在仓库中添加刚刚获得的Key和ID</p>
<p><img src="./assets/vuepress46.png" alt=""></p>
<p>第五步：在deploy.yml中添加如下内容</p>
<div><div><br><br><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><br><br></div><pre><code><span>-</span> <span>name</span><span>:</span> Build reco<span>-</span>demo
  <span>run</span><span>:</span> yarn run build
  <span>env</span><span>:</span>
     <span>LEANCLOUD_APP_ID</span><span>:</span> $<span>{</span><span>{</span> secrets.LEANCLOUD_APP_ID <span>}</span><span>}</span> <span># 评论系统的ID</span>
     <span>LEANCLOUD_APP_KEY</span><span>:</span> $<span>{</span><span>{</span> secrets.LEANCLOUD_APP_KEY <span>}</span><span>}</span> <span># 评论系统的KEY</span>

</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>第六步：测试</p>
<p><img src="./assets/vuepress47.png" alt=""></p>
<h3 id="三-部署到阿里云服务器-可选"> （三）部署到阿里云服务器（可选）</h3>
<p>实现步骤：</p>
<ol>
<li><code>zip -r dist.zip .vuepress/dist</code> 将构建的静态文件压缩</li>
<li><code>appleboy/scp-action@master</code> 拷贝文件到服务器</li>
<li><code>appleboy/ssh-action@master</code> SSH远程登录服务器将原文件备份并解压<code>dist.zip</code></li>
<li>安装配置nginx、测试访问</li>
</ol>
<p><strong>1、配置Secrets和yml文件</strong></p>
<p>需要在Secrets中添加：</p>
<ul>
<li>ALIYUN_SERVER_IP ：服务器的IP地址</li>
<li>ALIYUN_SERVER_USERNAME：服务器用户名</li>
<li>ALIYUN_SERVER_PASSWORD：服务器登录密码</li>
<li>ALIYUN_SERVER_PORT：SSH端口</li>
</ul>
<p>在deploy.yml中添加以下 <mark>高亮部分</mark> 的代码内容</p>
<div><div><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><br><br><br><br><br><br><br><br><br><br><br><br><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><br><br><br></div><pre><code><span>name</span><span>:</span> Deploy

<span>on</span><span>:</span>
  <span>push</span><span>:</span>
    <span>branches</span><span>:</span>
      <span>-</span> master

<span>jobs</span><span>:</span>
  <span>deploy-gh-pages</span><span>:</span>
    <span>runs-on</span><span>:</span> ubuntu<span>-</span>latest
    <span>steps</span><span>:</span>
      <span># 获取源码</span>
      <span>-</span> <span>name</span><span>:</span> Checkout
        <span>uses</span><span>:</span> actions/checkout@v2
        <span>with</span><span>:</span>
          <span>persist-credentials</span><span>:</span> <span>false</span>
          <span>ssh-key</span><span>:</span> $<span>{</span><span>{</span> secrets.SSH_PRIVATE_KEY <span>}</span><span>}</span>
          <span>submodules</span><span>:</span> <span>true</span>
          <span>fetch-depth</span><span>:</span> <span>0</span>
      <span># 缓存依赖项配置</span>
      <span>-</span> <span>uses</span><span>:</span> actions/cache@v2
        <span>id</span><span>:</span> node<span>-</span>modules
        <span>with</span><span>:</span>
          <span>path</span><span>:</span> node_modules/
          <span>key</span><span>:</span> $<span>{</span><span>{</span> runner.os <span>}</span><span>}</span><span>-</span>node<span>-</span>modules<span>-</span>$<span>{</span><span>{</span> hashFiles('yarn.lock') <span>}</span><span>}</span>
          <span>restore-keys</span><span>:</span> <span>|</span><span>
            ${{ runner.os }}-node-modules-</span>
      <span># 安装依赖</span>
      <span>-</span> <span>name</span><span>:</span> Install Deps
        <span>if</span><span>:</span> steps.node<span>-</span>modules.outputs.cache<span>-</span>hit <span>!=</span> 'true'
        <span>run</span><span>:</span> yarn install <span>-</span><span>-</span>frozen<span>-</span>lockfile

      <span># 构建项目并压缩为dist.zip</span>
      <span>-</span> <span>name</span><span>:</span> Build and zip
        <span>run</span><span>:</span> <span>|</span><span>
          yarn run build
          cd .vuepress
          zip -r dist.zip ./dist</span>
        <span>env</span><span>:</span>
          <span>LEANCLOUD_APP_ID</span><span>:</span> $<span>{</span><span>{</span> secrets.LEANCLOUD_APP_ID <span>}</span><span>}</span> <span># 评论系统的ID</span>
          <span>LEANCLOUD_APP_KEY</span><span>:</span> $<span>{</span><span>{</span> secrets.LEANCLOUD_APP_KEY <span>}</span><span>}</span> <span># 评论系统的KEY</span>

      <span># 部署到gh-pages分支</span>
      <span>-</span> <span>name</span><span>:</span> Deploy To gh<span>-</span>pages
        <span>uses</span><span>:</span> JamesIves/github<span>-</span>pages<span>-</span>deploy<span>-</span>action@releases/v3
        <span>with</span><span>:</span>
          <span>ACCESS_TOKEN</span><span>:</span> $<span>{</span><span>{</span> secrets.ACCESS_TOKEN <span>}</span><span>}</span>
          <span>BRANCH</span><span>:</span> gh<span>-</span>pages
          <span>FOLDER</span><span>:</span> .vuepress/dist

      <span># Scp脚本拷贝dist.zip到服务器</span>
      <span>-</span> <span>name</span><span>:</span> Scp file to aliyun
        <span>uses</span><span>:</span> appleboy/scp<span>-</span>action@master
        <span>with</span><span>:</span>
          <span># IP地址</span>
          <span>host</span><span>:</span> $<span>{</span><span>{</span> secrets.ALIYUN_SERVER_IP <span>}</span><span>}</span>
          <span># 用户，如：root等</span>
          <span>username</span><span>:</span> $<span>{</span><span>{</span> secrets.ALIYUN_SERVER_USERNAME <span>}</span><span>}</span>
          <span># 密码</span>
          <span>password</span><span>:</span> $<span>{</span><span>{</span> secrets.ALIYUN_SERVER_PASSWORD <span>}</span><span>}</span>
          <span># ssh端口，如：22</span>
          <span>port</span><span>:</span> $<span>{</span><span>{</span> secrets.ALIYUN_SERVER_PORT <span>}</span><span>}</span>
          <span>source</span><span>:</span> <span>".vuepress/dist.zip"</span>
          <span># 将文件拷贝到服务器</span>
          <span>target</span><span>:</span> <span>"/home/tmp"</span>

      <span># 备份、解压、删除</span>
      <span>-</span> <span>name</span><span>:</span> Backup and unzip
        <span>uses</span><span>:</span> appleboy/ssh<span>-</span>action@master
        <span>with</span><span>:</span>
          <span># IP地址</span>
          <span>host</span><span>:</span> $<span>{</span><span>{</span> secrets.ALIYUN_SERVER_IP <span>}</span><span>}</span>
          <span># 用户，如:root等</span>
          <span>username</span><span>:</span> $<span>{</span><span>{</span> secrets.ALIYUN_SERVER_USERNAME <span>}</span><span>}</span>
          <span># 密码</span>
          <span>password</span><span>:</span> $<span>{</span><span>{</span> secrets.ALIYUN_SERVER_PASSWORD <span>}</span><span>}</span>
          <span># ssh端口，如：22</span>
          <span>port</span><span>:</span> $<span>{</span><span>{</span> secrets.ALIYUN_SERVER_PORT <span>}</span><span>}</span>
          <span># 先备份再解压</span>
          <span>script</span><span>:</span> <span>|</span><span>
            echo "################# files remove #################"
            if [ -f "/home/web/reco-demo-bak" ];then
              rm -rf /home/web/reco-demo-bak
              echo "reco-demo-bak exists and is deleted"
            fi
            echo "################# files backup #################"
            if [ -f "/home/web/reco-demo" ];then
              mv /home/web/reco-demo /home/web/reco-demo-bak
              echo "reco-demo exists and is backuped"
            else
              mkdir /home/web/reco-demo
            fi
            echo "################# unzip dist.zip #################"
            unzip -od  /home/web/reco-demo /home/tmp/dist.zip</span>


</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br><span>96</span><br></div></div><p><strong>2、配置nginx</strong></p>
<div><p>提示</p>
<p><a href="">Linux安装Nginx</a></p>
<p>默认的<code>nginx.conf</code>文件会帮你将<code>.*\.(js|css)?$</code></p>
<p>文件和 <code>.*\.(gif|jpg|jpeg|png|bmp|swf|ico)$</code>这些文件进行缓存</p>
</div>
<p>修改<code>nginx.conf</code>内容如下：</p>
<div><div><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><br><br><br><br><br><br><br><br><br><br></div><pre><code>
#user  nobody;
worker_processes  <span>1</span>;

#error_log  logs/error.log;
#error_log  logs/error.log  notice;
#error_log  logs/error.log  info;

#pid        logs/nginx.pid;


events <span>{</span>
    worker_connections  <span>1024</span>;
<span>}</span>


http <span>{</span>
    include       mime.types;
    default_type  application/octet-stream;

    sendfile        on;
    keepalive_timeout  <span>65</span>;

    server <span>{</span>
    	#监听的是<span>80</span>端口，不建议换成其他端口，因为换成其他端口后，你访问时，域名也得加上加上端口，
        #比如端口号改成<span>8080</span>，访问时则是： reco-demo.dreamagain.top<span>:</span><span>8080</span>
        listen       <span>80</span>;
        server_name  demo.dreamagain.top;

        #如果访问的是ip，则直接返回<span>404</span>，此处只允许通过域名访问
		if ($host ~ <span>"\d+\.\d+\.\d+\.\d"</span>) <span>{</span>
    			return <span>404</span>;
		<span>}</span>

        location / <span>{</span>
            root   /home/web/reco-demo/dist;
            index  index.html index.htm;
        <span>}</span>
        error_page   <span>500</span> <span>502</span> <span>503</span> <span>504</span>  /50x.html;
        location = /50x.html <span>{</span>
            root   html;
        <span>}</span>

    <span>}</span>

<span>}</span>

</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br></div></div><div><p>nginx常用命令</p>
<p>./nginx   启动nginx</p>
<p>./nginx -s stop 关闭nginx</p>
<p>./nginx -s quit  退出nginx</p>
<p>./nginx -s reload 重启nginx（重启用户基本感觉不到）</p>
</div>
<p>访问<code>demo.dreamagain.top</code>，页面正常显示，测试成功</p>
<p><img src="./assets/vuepress49.png" alt=""></p>
<h2 id="五、写在最后的话"> 五、写在最后的话</h2>
<p>如此折腾，做一个属于自己的博客，其实也不会有几个人能看到，毕竟沧海一粟，如此平凡。</p>
<p>这篇博客正好是自己第一次入坑vuepress的心路历程，特此复现记录在此，限于主要从事Java开发，前端学习的不是很深入，很多问题也是点到即止，有什么建议可以评论区留言，这篇博客内容将会不断的更新完善，努力做到简洁、通俗易懂。</p>
<p>如果你有幸看到此篇博客，并且内容正好能解决你当前遇到的问题，欢迎留言支持 (/≧▽≦/) 。</p>
<div><p>感谢</p>
<ol>
<li>
<p><a href="https://vuepress.vuejs.org/zh/" target="_blank" rel="noopener noreferrer">VuePress</a></p>
</li>
<li>
<p><a href="https://vuepress-reco-doc.now.sh/" target="_blank" rel="noopener noreferrer">vuepress-theme-reco</a></p>
</li>
<li>
<p><a href="https://www.jianshu.com/p/37509da5a020" target="_blank" rel="noopener noreferrer">南宫__</a></p>
</li>
<li>
<p><a href="https://www.jianshu.com/p/2220dbacfde1" target="_blank" rel="noopener noreferrer">kobuta</a></p>
</li>
<li>
<p><a href="https://tsanfer.xyz/" target="_blank" rel="noopener noreferrer">Tsanfer's Blog</a></p>
</li>
</ol>
</div>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <category term="使用指南"/>
    <contributor>
      <name>南辞</name>
    </contributor>
    <published>2021-02-16T17:39:43.000Z</published>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">Java必备208道面试题</title>
    <id>http://qiqi.dreamagain.top/interview/Java208/</id>
    <link href="http://qiqi.dreamagain.top/interview/Java208/"/>
    <updated>2021-02-18T01:11:00.000Z</updated>
    <summary type="html"><![CDATA[<div><p>声明</p>
<p>此份面试题来自知乎<a href="https://www.zhihu.com/question/27858692/answer/787505434" target="_blank" rel="noopener noreferrer">java经验总结</a> ，原文参考答案比较浅显且部分有误，目前已对部分参考答案进行订正、补充。</p>
<p>提示：此份面试题在学完相关基础后食用效果最佳，可以快速查缺补漏，加深对知识的理解。切忌死记硬背，编程重在理解思想和代码编写</p>
</div>
]]></summary>
    <content type="html"><![CDATA[<div><p>声明</p>
<p>此份面试题来自知乎<a href="https://www.zhihu.com/question/27858692/answer/787505434" target="_blank" rel="noopener noreferrer">java经验总结</a> ，原文参考答案比较浅显且部分有误，目前已对部分参考答案进行订正、补充。</p>
<p>提示：此份面试题在学完相关基础后食用效果最佳，可以快速查缺补漏，加深对知识的理解。切忌死记硬背，编程重在理解思想和代码编写</p>
</div>

<h2 id="一-面试题模块介绍"> 一. 面试题模块介绍</h2>
<p>这份面试题，包含的内容了十九了模块：Java 基础、容器、多线程、反射、对象拷贝、Java Web 模块、异常、网络、设计模式、Spring/Spring MVC、Spring Boot/Spring Cloud、Hibernate、Mybatis、RabbitMQ、Kafka、Zookeeper、MySql、Redis、JVM 。如下图所示：</p>
<img src="./assets/java-00.png"  />
<p>可能对于初学者不需要看后面的框架和 JVM 模块的知识，读者朋友们可根据自己的情况，选择对应的模块进行阅读。</p>
<h2 id="二-适宜阅读人群"> 二. 适宜阅读人群</h2>
<ul>
<li>需要面试的初/中/高级 java 程序员</li>
<li>想要查漏补缺的人</li>
<li>想要不断完善和扩充自己 java 技术栈的人</li>
<li>java 面试官</li>
</ul>
<h2 id="三-具体面试题"> 三. 具体面试题</h2>
<div><p>(一)、Java基础</p>
<br/>
</div>
<p>1.JDK和JRE有什么区别?</p>
<p>2.==和equals的区别是什么?</p>
<p>3.两个对象的 hashCode()相同，则equals()也一定为true，对吗?</p>
<p>4.final在java中有什么作用?</p>
<p>5.java中的 Math.round(-1.5)等于多少?</p>
<p>6.String 属于基础的数据类型吗?</p>
<p>7.java 中操作字符串都有哪些类?它们之间有什么区别?</p>
<p>8.String str=&quot;i&quot;与String str=new String(&quot;i&quot;)一样吗?</p>
<p>9.如何将字符串反转?</p>
<p>10.String类的常用方法都有那些?</p>
<p>11.抽象类必须要有抽象方法吗?</p>
<p>12.普通类和抽象类有哪些区别?</p>
<p>13.抽象类能使用final 修饰吗?</p>
<p>14.接口和抽象类有什么区别?</p>
<p>15.java中IO流分为几种?</p>
<p>16.BIO、NIO、AIO有什么区别</p>
<p>17.Files的常用方法有哪些？</p>
<div>
<p><a href="./模块01—Java基础.html">参考答案</a></p>
</div>
<hr>
<div><p>（二）、容器</p>
<br/>
</div>
<p>18.java容器都有哪些?</p>
<p>19.Collection和Collections有什么区别?</p>
<p>20.List、Set、Map 之间的区别是什么?</p>
<p>21.HashMap和Hashtable有什么区别?</p>
<p>22.如何决定使用HashMap还是TreeMap?</p>
<p>23.说一下HashMap 的实现原理?</p>
<p>24.说一下 HashSet 的实现原理?</p>
<p>25.ArrayList和LinkedList的区别是什么?</p>
<p>26.如何实现数组和List 之间的转换?</p>
<p>27.ArrayList和Vector 的区别是什么?</p>
<p>28.Array和ArrayList有何区别?</p>
<p>29.在 Queue 中 poll()和remove()有什么区别?</p>
<p>30.哪些集合类是线程安全的?</p>
<p>31.迭代器lterator 是什么?</p>
<p>32.lterator怎么使用?有什么特点?</p>
<p>33.lterator和Listlterator有什么区别?</p>
<p>34.怎么确保一个集合不能被修改？</p>
<div>
<p><a href="./模块02—Java集合.html">参考答案</a></p>
</div>
<hr>
<div><p>（三）、多线程</p>
<br/>
</div>
<p>35.并行和并发有什么区别?</p>
<p>36.线程和进程的区别?</p>
<p>37.守护线程是什么?</p>
<p>38.创建线程有哪几种方式?</p>
<p>39.说一下runnable和callable有什么区别?</p>
<p>40.线程有哪些状态?</p>
<p>41.sleep()和wait()有什么区别?</p>
<p>42.notify()和 notifyAll)有什么区别?</p>
<p>43.线程的run()和start()有什么区别?</p>
<p>44.创建线程池有哪几种方式?</p>
<p>45.线程池都有哪些状态?</p>
<p>46.线程池中 submit()和execute()方法有什么区别?</p>
<p>47.在java程序中怎么保证多线程的运行安全?</p>
<p>48.多线程锁的升级原理是什么?</p>
<p>49.什么是死锁?</p>
<p>50.怎么防止死锁?</p>
<p>51.ThreadLocal是什么?有哪些使用场景?</p>
<p>52.说一下synchronized底层实现原理?</p>
<p>53.synchronized和volatile 的区别是什么?</p>
<p>54.synchronized和Lock有什么区别?</p>
<p>55.synchronized和ReentrantLock区别是什么?</p>
<p>56.说一下atomic 的原理?</p>
<hr>
<div><p>（四）、反射</p>
<br/>
</div>
<p>57.什么是反射?</p>
<p>58.什么是java序列化?什么情况下需要序列化?</p>
<p>59.动态代理是什么?有哪些应用?</p>
<p>60.怎么实现动态代理?</p>
<hr>
<div><p>（五）、对象拷贝</p>
<br/>
</div>
<p>61.为什么要使用克隆?</p>
<p>62.如何实现对象克隆?</p>
<p>63.深拷贝和浅拷贝区别是什么?</p>
<hr>
<div><p>（六）、Java Web</p>
<br/>
</div>
<p>64.jsp和servlet有什么区别?</p>
<p>65.jsp有哪些内置对象?作用分别是什么?</p>
<p>66.说一下jsp的4种作用域?</p>
<p>67.session和cookie有什么区别?</p>
<p>68.说一下 session的工作原理?</p>
<p>69.如果客户端禁止 cookie 能实现session 还能用吗?</p>
<p>70.spring mvc和struts 的区别是什么?</p>
<p>71.如何避免 sql注入?</p>
<p>72.什么是XSS攻击,如何避免?</p>
<p>73.什么是CSRF攻击，如何避免?</p>
<hr>
<div><p>（七）、异常</p>
<br/>
</div>
<p>74.throw和throws 的区别?</p>
<p>75.final、finally、finalize有什么区别?</p>
<p>76.try-catch-finally 中哪个部分可以省略?</p>
<p>77.try-catch-finally中，如果catch 中 return 了, finally还会执行吗?78.常见的异常类有哪些?</p>
<hr>
<div><p>（八）、网络</p>
<br/>
</div>
<p>79.http响应码301和302代表的是什么?有什么区别?</p>
<p>80.forward和redirect的区别?</p>
<p>81.简述tcp和udp的区别?</p>
<p>82.tcp为什么要三次握手，两次不行吗?为什么?</p>
<p>83.说一下 tcp粘包是怎么产生的?</p>
<p>84.OSl的七层模型都有哪些?</p>
<p>85.get和post请求有哪些区别?</p>
<p>86.如何实现跨域?</p>
<p>87.说一下JSONP 实现原理?</p>
<hr>
<div><p>（九）、设计模式</p>
<br/>
</div>
<p>88.说一下你熟悉的设计模式?</p>
<p>89.简单工厂和抽象工厂有什么区别?</p>
<hr>
<div><p>（十）.Spring/Spring MVC</p>
<br/>
</div>
<p>90.为什么要使用spring?</p>
<p>91.解释一下什么是aop?</p>
<p>9⒉.解释一下什么是ioc?</p>
<p>93.spring有哪些主要模块?</p>
<p>94.spring 常用的注入方式有哪些?</p>
<p>95.spring 中的 bean是线程安全的吗?</p>
<p>96.spring支持几种bean的作用域?</p>
<p>97.spring自动装配bean有哪些方式?</p>
<p>98.spring事务实现方式有哪些?</p>
<p>99.说一下spring 的事务隔离?</p>
<p>100.说一下spring mvc运行流程?</p>
<p>101.spring mvc有哪些组件?</p>
<p>102.@RequestMapping 的作用是什么?</p>
<p>103.@Autowired的作用是什么?</p>
<hr>
<div><p>（十一）、Spring Boot/Spring Cloud</p>
<br/>
</div>
<p>104.什么是spring boot?</p>
<p>105.为什么要用spring boot?</p>
<p>106.spring boot核心配置文件是什么?</p>
<p>107.spring boot配置文件有哪几种类型?它们有什么区别?</p>
<p>108.spring boot有哪些方式可以实现热部署?</p>
<p>109.jpa和hibernate有什么区别?</p>
<p>110.什么是 spring cloud?</p>
<p>111.spring cloud 断路器的作用是什么?</p>
<p>112.spring cloud的核心组件有哪些?</p>
<hr>
<div><p>（十二）、Hibernate</p>
<br/>
</div>
<p>113.为什么要使用hibernate?</p>
<p>114.什么是 ORM框架?</p>
<p>115.hibernate 中如何在控制台查看打印的sql语句?</p>
<p>116.hibernate有几种查询方式?</p>
<p>117.hibernate 实体类可以被定义为final 吗?</p>
<p>118.在hibernate中使用Integer和int做映射有什么区别?</p>
<p>119.hibernate是如何工作的?</p>
<p>120.get()和load()的区别?</p>
<p>121.说一下 hibernate 的缓存机制?</p>
<p>122.hibernate对象有哪些状态?</p>
<p>123.在 hibernate 中 getCurrentSession和openSession的区别是什么?</p>
<p>124.hibernate 实体类必须要有无参构造函数吗?为什么?</p>
<hr>
<div><p>（十三）、Mybatis</p>
<br/>
</div>
<p>125.mybatis 中#{和$0的区别是什么?</p>
<p>126.mybatis有几种分页方式?</p>
<p>127.RowBounds是一次性查询全部结果吗?为什么?</p>
<p>128.mybatis逻辑分页和物理分页的区别是什么?</p>
<p>129.mybatis 是否支持延迟加载?延迟加载的原理是什么?</p>
<p>130.说一下mybatis的一级缓存和二级缓存?</p>
<p>131.mybatis 和 hibernate的区别有哪些?</p>
<p>132.mybatis有哪些执行器(Executor) ?</p>
<p>133.mybatis分页插件的实现原理是什么?</p>
<p>134.mybatis 如何编写一个自定义插件?</p>
<hr>
<div><p>（十四）、RabbitMQ</p>
<br/>
</div>
<p>135.rabbitmq的使用场景有哪些?</p>
<p>136.rabbitmq有哪些重要的角色?</p>
<p>137.rabbitmq有哪些重要的组件?</p>
<p>138.rabbitmq中 vhost的作用是什么?</p>
<p>139.rabbitmq的消息是怎么发送的?</p>
<p>140.rabbitmq怎么保证消息的稳定性?</p>
<p>141.rabbitmq怎么避免消息丢失?</p>
<p>142.要保证消息持久化成功的条件有哪些?</p>
<p>143.rabbitmq持久化有什么缺点?</p>
<p>144.rabbitmq有几种广播类型?</p>
<p>145.rabbitmq怎么实现延迟消息队列?</p>
<p>146.rabbitmq集群有什么用?</p>
<p>147.rabbitmq节点的类型有哪些?</p>
<p>148.rabbitmq集群搭建需要注意哪些问题?</p>
<p>149.rabbitmq每个节点是其他节点的完整拷贝吗?为什么?</p>
<p>150.rabbitmq集群中唯—一个磁盘节点崩溃了会发生什么情况?</p>
<hr>
<div><p>（十五）、Kafka</p>
<br/>
</div>
<p>152.kafka可以脱离zookeeper单独使用吗?为什么?</p>
<p>153.kafka有几种数据保留的策略?</p>
<p>154.kafka同时设置了7天和10G清除数据，到第五天的时候消息达到了10G，这个时候 kafka将如何处理?</p>
<p>155.什么情况会导致kafka运行变慢?</p>
<p>156.使用kafka集群需要注意什么?</p>
<hr>
<div><p>（十六）、Zookeeper</p>
<br/>
</div>
<p>157.zookeeper是什么?</p>
<p>158.zookeeper都有哪些功能?</p>
<p>159.zookeeper有几种部署模式?</p>
<p>160.zookeeper怎么保证主从节点的状态同步?</p>
<p>161.集群中为什么要有主节点?</p>
<p>162.集群中有3台服务器，其中一个节点宕机，这个时候zookeeper还可以使用吗?</p>
<p>163.说一下zookeeper的通知机制?</p>
<hr>
<div><p>（十七）.MySQL</p>
<br/>
</div>
<p>164.数据库的三范式是什么?</p>
<p>165.一张自增表里面总共有7条数据，删除了最后⒉条数据，重启 mysql数据库，又插入了一条数据，此时id是几?</p>
<p>166.如何获取当前数据库版本?</p>
<p>167.说一下ACID是什么?</p>
<p>168.char和varchar 的区别是什么?</p>
<p>169.float和double的区别是什么?</p>
<p>170.mysql 的内连接、左连接、右连接有什么区别?</p>
<p>171.mysql索引是怎么实现的?</p>
<p>172.怎么验证 mysql的索引是否满足需求?</p>
<p>173.说一下数据库的事务隔离?</p>
<p>174.说一下mysql常用的引擎?</p>
<p>175.说一下mysql的行锁和表锁?</p>
<p>176.说一下乐观锁和悲观锁?</p>
<p>177.mysql问题排查都有哪些手段?</p>
<p>178.如何做mysql的性能优化?</p>
<hr>
<div><p>（十八）、Redis</p>
<br/>
</div>
<p>179.redis是什么?都有哪些使用场景?</p>
<p>180.redis有哪些功能?</p>
<p>181.redis和 memecache有什么区别?</p>
<p>182.redis为什么是单线程的?</p>
<p>183.什么是缓存穿透?怎么解决?</p>
<p>184.redis支持的数据类型有哪些?</p>
<p>185.redis支持的java客户端都有哪些?</p>
<p>186.jedis和redisson有哪些区别?</p>
<p>187.怎么保证缓存和数据库数据的一致性?</p>
<p>188.redis持久化有几种方式?</p>
<p>189.redis 怎么实现分布式锁?</p>
<p>190.redis分布式锁有什么缺陷?</p>
<p>191.redis如何做内存优化?</p>
<p>192.redis淘汰策略有哪些?</p>
<p>193.redis 常见的性能问题有哪些?该如何解决?</p>
<hr>
<div><p>（十九）、JVM</p>
<br/>
</div>
<p>194.说一下 jvm的主要组成部分?及其作用?</p>
<p>195.说一下 jvm运行时数据区?</p>
<p>196.说一下堆栈的区别?</p>
<p>197.队列和栈是什么?有什么区别?</p>
<p>198.什么是双亲委派模型?</p>
<p>199.说一下类加载的执行过程?</p>
<p>200.怎么判断对象是否可以被回收?</p>
<p>201.java中都有哪些引用类型?</p>
<p>202.说一下 jvm有哪些垃圾回收算法?</p>
<p>203.说一下 jvm有哪些垃圾回收器?</p>
<p>204.详细介绍一下 CMS垃圾回收器?</p>
<p>205.新生代垃圾回收器和老生代垃圾回收器都有哪些?有什么区别?</p>
<p>206.简述分代垃圾回收器是怎么工作的?</p>
<p>207.说一下jvm调优的工具?</p>
<p>208.常用的jvm调优的参数都有哪些?</p>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <contributor>
      <name>南辞</name>
    </contributor>
    <published>2021-02-18T01:11:00.000Z</published>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">模块01-Java基础</title>
    <id>http://qiqi.dreamagain.top/interview/Java208/%E6%A8%A1%E5%9D%9701%E2%80%94Java%E5%9F%BA%E7%A1%80/</id>
    <link href="http://qiqi.dreamagain.top/interview/Java208/%E6%A8%A1%E5%9D%9701%E2%80%94Java%E5%9F%BA%E7%A1%80/"/>
    <updated>2021-02-18T01:11:00.000Z</updated>
    <content type="html"><![CDATA[<h2 id="问题"> 问题：</h2>
<p>1.JDK和JRE有什么区别?</p>
<p>2.==和equals的区别是什么?</p>
<p>3.两个对象的 hashCode()相同，则equals()也一定为true，对吗?</p>
<p>4.final在java中有什么作用?</p>
<p>5.java中的 Math.round(-1.5)等于多少?</p>
<p>6.String 属于基础的数据类型吗?</p>
<p>7.java 中操作字符串都有哪些类?它们之间有什么区别?</p>
<p>8.String str=&quot;i&quot;与String str=new String(&quot;i&quot;)一样吗?</p>
<p>9.如何将字符串反转?</p>
<p>10.String类的常用方法都有那些?</p>
<p>11.抽象类必须要有抽象方法吗?</p>
<p>12.普通类和抽象类有哪些区别?</p>
<p>13.抽象类能使用final 修饰吗?</p>
<p>14.接口和抽象类有什么区别?</p>
<ol start="15">
<li>java中IO流分为几种?</li>
</ol>
<p>16.BIO、NIO、AIO有什么区别</p>
<p>17.Files的常用方法有哪些？</p>
<h2 id="答案"> 答案：</h2>
<blockquote>
<h3 id="_1-jdk和jre有什么区别"> 1.JDK和JRE有什么区别?</h3>
</blockquote>
<ul>
<li>JDK：Java Development Kit 的简称，java 开发工具包，提供了 java 的开发环境和运行环境。</li>
<li>JRE：Java Runtime Environment 的简称，java 运行环境，为 java 的运行提供了所需环境。</li>
</ul>
<p>具体来说 JDK 其实包含了 JRE，同时还包含了编译 java 源码的编译器 javac，还包含了很多 java 程序调试和分析的工具。</p>
<p>简单来说：如果你需要运行 java 程序，只需安装 JRE 就可以了，如果你需要编写 java 程序，需要安装 JDK。</p>
<blockquote>
<h3 id="_2-和equals的区别是什么"> 2.==和equals的区别是什么?</h3>
</blockquote>
<p><strong>① == 解读</strong></p>
<p>对于基本类型和引用类型 == 的作用效果是不同的，如下所示：</p>
<ul>
<li>基本类型：比较的是值是否相同；</li>
<li>引用类型：比较的是引用是否相同；</li>
</ul>
<p>代码示例：</p>
<div><pre><code><span>String</span> x <span>=</span> <span>"string"</span><span>;</span>
<span>String</span> y <span>=</span> <span>"string"</span><span>;</span>
<span>String</span> z <span>=</span> <span>new</span> <span>String</span><span>(</span><span>"string"</span><span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>x<span>==</span>y<span>)</span><span>;</span> <span>// true</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>x<span>==</span>z<span>)</span><span>;</span> <span>// false</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>x<span>.</span><span>equals</span><span>(</span>y<span>)</span><span>)</span><span>;</span> <span>// true</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>x<span>.</span><span>equals</span><span>(</span>z<span>)</span><span>)</span><span>;</span> <span>// true</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>代码解读：因为 x 和 y 指向的是同一个引用，所以 == 也是 true，而 new String()方法则重新<strong>在堆区</strong>中开辟了内存空间，所以 == 结果为 false，而 equals 比较的一直是值，所以结果都为 true。</p>
<p><strong>② equals 解读</strong></p>
<p>equals 本质上就是 ==，只不过 String 和 Integer 等重写了 equals 方法，把它变成了值比较。看下面的代码就明白了。</p>
<p>首先来看默认情况下 equals 比较一个有相同值的对象，代码如下：</p>
<div><pre><code><span>class</span> <span>Cat</span> <span>{</span>
    <span>public</span> <span>Cat</span><span>(</span><span>String</span> name<span>)</span> <span>{</span>
        <span>this</span><span>.</span>name <span>=</span> name<span>;</span>
    <span>}</span>

    <span>private</span> <span>String</span> name<span>;</span>

    <span>public</span> <span>String</span> <span>getName</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> name<span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>setName</span><span>(</span><span>String</span> name<span>)</span> <span>{</span>
        <span>this</span><span>.</span>name <span>=</span> name<span>;</span>
    <span>}</span>
<span>}</span>

<span>Cat</span> c1 <span>=</span> <span>new</span> <span>Cat</span><span>(</span><span>"王磊"</span><span>)</span><span>;</span>
<span>Cat</span> c2 <span>=</span> <span>new</span> <span>Cat</span><span>(</span><span>"王磊"</span><span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>c1<span>.</span><span>equals</span><span>(</span>c2<span>)</span><span>)</span><span>;</span> <span>// false</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><p>输出结果出乎我们的意料，竟然是 false？这是怎么回事，看了 equals 源码就知道了，源码如下：</p>
<div><pre><code><span>public</span> <span>boolean</span> <span>equals</span><span>(</span><span>Object</span> obj<span>)</span> <span>{</span>
    <span>return</span> <span>(</span><span>this</span> <span>==</span> obj<span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>原来 equals 本质上就是 ==。</p>
<p>那问题来了，<strong>两个相同值的 String 对象，为什么返回的是 true</strong>？代码如下：</p>
<div><pre><code><span>String</span> s1 <span>=</span> <span>new</span> <span>String</span><span>(</span><span>"老王"</span><span>)</span><span>;</span>
<span>String</span> s2 <span>=</span> <span>new</span> <span>String</span><span>(</span><span>"老王"</span><span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>s1<span>.</span><span>equals</span><span>(</span>s2<span>)</span><span>)</span><span>;</span> <span>// true</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>同样的，当我们进入 String 的 equals 方法，找到了答案，代码如下：</p>
<div><pre><code><span>public</span> <span>boolean</span> <span>equals</span><span>(</span><span>Object</span> anObject<span>)</span> <span>{</span>
    <span>//判断是否是同一个对象</span>
    <span>if</span> <span>(</span><span>this</span> <span>==</span> anObject<span>)</span> <span>{</span>
        <span>return</span> <span>true</span><span>;</span>
    <span>}</span>
    <span>//不是同一个对象才进行值比较</span>
    <span>//判断是不是String类型</span>
    <span>if</span> <span>(</span>anObject <span>instanceof</span> <span>String</span><span>)</span> <span>{</span>
        <span>String</span> anotherString <span>=</span> <span>(</span><span>String</span><span>)</span>anObject<span>;</span>
        <span>int</span> n <span>=</span> value<span>.</span>length<span>;</span>
        <span>//字符串长度比较</span>
        <span>if</span> <span>(</span>n <span>==</span> anotherString<span>.</span>value<span>.</span>length<span>)</span> <span>{</span>
            <span>char</span> v1<span>[</span><span>]</span> <span>=</span> value<span>;</span>
            <span>char</span> v2<span>[</span><span>]</span> <span>=</span> anotherString<span>.</span>value<span>;</span>
            <span>int</span> i <span>=</span> <span>0</span><span>;</span>
            <span>//两个字符数组一一进行字符比较</span>
            <span>while</span> <span>(</span>n<span>--</span> <span>!=</span> <span>0</span><span>)</span> <span>{</span>
                <span>if</span> <span>(</span>v1<span>[</span>i<span>]</span> <span>!=</span> v2<span>[</span>i<span>]</span><span>)</span>
                    <span>return</span> <span>false</span><span>;</span>
                i<span>++</span><span>;</span>
            <span>}</span>
            <span>return</span> <span>true</span><span>;</span>
        <span>}</span>
    <span>}</span>
    <span>//不是String类型的比较直接返回false</span>
    <span>return</span> <span>false</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div><p>原来是 <strong>String 重写了 Object 的 equals 方法</strong>，把<strong>引用比较改成了值比较</strong>。</p>
<p><strong>总结</strong> ：</p>
<ul>
<li>
<p>== 对于基本类型来说是值比较，对于引用类型来说是比较的是引用；</p>
</li>
<li>
<p>而 equals 默认情况下是引用比较，只是很多类重新了 equals 方法，比如 String、Integer 等把它变成了值比较，所以一般情况下 equals 比较的是值是否相等。</p>
</li>
</ul>
<blockquote>
<h3 id="_3-两个对象的-hashcode-相同-则equals-也一定为true-对吗"> 3.两个对象的 hashCode()相同，则equals()也一定为true，对吗?</h3>
</blockquote>
<p>不对，两个对象的 hashCode()相同，equals()不一定 true。</p>
<p>代码示例：</p>
<div><pre><code>String str1 = &quot;通话&quot;;
String str2 = &quot;重地&quot;;
System.out.println(String.format(&quot;str1：%d | str2：%d&quot;, str1.hashCode(),str2.hashCode()));
System.out.println(str1.equals(str2));
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>执行的结果：</p>
<p>str1：1179395 | str2：1179395</p>
<p>false</p>
<p>代码解读：很显然“通话”和“重地”的 hashCode() 相同，然而 equals() 则为 false，因为在散列表中，hashCode()相等即两个键值对的哈</p>
<p>希值相等，然而哈希值相等，并不一定能得出键值对相等。</p>
<blockquote>
<h3 id="_4-final在java中有什么作用"> 4.final在java中有什么作用?</h3>
</blockquote>
<ul>
<li>
<p>final 修饰的类叫最终类，该类不能被继承。</p>
</li>
<li>
<p>final 修饰的方法不能被重写。</p>
</li>
<li>
<p>final 修饰的变量叫常量，常量必须初始化，初始化之后值就不能被修改。</p>
</li>
</ul>
<blockquote>
<h3 id="_5-java中的-math-round-1-5-等于多少"> 5.java中的 Math.round(-1.5)等于多少?</h3>
</blockquote>
<p>等于 -1，因为在数轴上取值时，中间值（0.5）向右取整，所以正 0.5 是往上取整，负 0.5 是直接舍弃。</p>
<blockquote>
<h3 id="_6-string-属于基础的数据类型吗"> 6.String 属于基础的数据类型吗?</h3>
</blockquote>
<p>String 不属于基础类型，基础类型有 8 种：byte、short、int、long、float、double、boolean、char，而 String 属于对象。</p>
<p>这8种基本数据类型对应的存储字节数：1  2  4  8  4  8  1  2</p>
<blockquote>
<h3 id="_7-java-中操作字符串都有哪些类-它们之间有什么区别"> 7.java 中操作字符串都有哪些类?它们之间有什么区别?</h3>
</blockquote>
<p>操作字符串的类有：String、StringBuffer、StringBuilder。</p>
<p><strong>String 和 StringBuffer、StringBuilder 的区别:</strong></p>
<ul>
<li>
<p>String 声明的是不可变的对象，每次操作都会生成新的 String 对象，然后将指针指向新的 String 对象，</p>
</li>
<li>
<p>而 StringBuffer、StringBuilder 可以在原有对象的基础上进行操作，所以在经常改变字符串内容的情况下最好不要使用 String。</p>
</li>
</ul>
<p><strong>StringBuffer 和 StringBuilder 最大的区别：</strong></p>
<ul>
<li>
<p>StringBuffer 是线程安全的，而 StringBuilder 是非线程安全的，</p>
</li>
<li>
<p>但 StringBuilder 的性能却高于 StringBuffer，所以在单线程环境下推荐使用 StringBuilder，多线程环境下推荐使用 StringBuffer。</p>
</li>
</ul>
<blockquote>
<h3 id="_8-string-str-i-与string-str-new-string-i-一样吗"> 8.String str=&quot;i&quot;与String str=new String(&quot;i&quot;)一样吗?</h3>
</blockquote>
<p>不一样，因为内存的分配方式不一样。</p>
<ul>
<li>
<p>String str=&quot;i&quot;的方式，java 虚拟机会将其分配到常量池中；</p>
</li>
<li>
<p>而 String str=new String(&quot;i&quot;) 则会被分到堆内存中。</p>
</li>
</ul>
<blockquote>
<h3 id="_9-如何将字符串反转"> 9.如何将字符串反转?</h3>
</blockquote>
<p>使用 StringBuilder 或者 stringBuffer 的 reverse() 方法。当然也可以使用字符数组进行逆置</p>
<p>示例代码：</p>
<div><pre><code><span>// StringBuffer reverse</span>
<span>StringBuffer</span> stringBuffer <span>=</span> <span>new</span> <span>StringBuffer</span><span>(</span><span>)</span><span>;</span>
stringBuffer<span>.</span><span>append</span><span>(</span><span>"abcdefg"</span><span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>stringBuffer<span>.</span><span>reverse</span><span>(</span><span>)</span><span>)</span><span>;</span> <span>// gfedcba</span>
<span>// StringBuilder reverse</span>
<span>StringBuilder</span> stringBuilder <span>=</span> <span>new</span> <span>StringBuilder</span><span>(</span><span>)</span><span>;</span>
stringBuilder<span>.</span><span>append</span><span>(</span><span>"abcdefg"</span><span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>stringBuilder<span>.</span><span>reverse</span><span>(</span><span>)</span><span>)</span><span>;</span> <span>// gfedcba</span>
<span>// 字符数组</span>
<span>public</span> <span>static</span> <span>String</span> <span>reverse</span><span>(</span><span>String</span> str<span>)</span><span>{</span>
        <span>if</span> <span>(</span>str<span>==</span><span>null</span><span>||</span>str<span>.</span><span>length</span><span>(</span><span>)</span><span>==</span><span>0</span><span>||</span>str<span>.</span><span>length</span><span>(</span><span>)</span><span>==</span><span>1</span><span>)</span><span>{</span>
            <span>return</span> str<span>;</span>
        <span>}</span>
        <span>char</span><span>[</span><span>]</span> chars <span>=</span> str<span>.</span><span>toCharArray</span><span>(</span><span>)</span><span>;</span>
        <span>int</span> i <span>=</span> str<span>.</span><span>length</span><span>(</span><span>)</span><span>;</span>
        <span>int</span> j <span>=</span> <span>0</span><span>;</span>
        <span>while</span> <span>(</span>j<span>&lt;</span>i<span>)</span><span>{</span>
            <span>char</span> tmp <span>=</span> chars<span>[</span>i<span>-</span><span>1</span><span>]</span><span>;</span>
            chars<span>[</span>i<span>-</span><span>1</span><span>]</span> <span>=</span> chars<span>[</span>j<span>]</span><span>;</span>
            chars<span>[</span>j<span>]</span> <span>=</span> tmp<span>;</span>

            j<span>++</span><span>;</span>
            i<span>--</span><span>;</span>
        <span>}</span>
        str <span>=</span> <span>new</span> <span>String</span><span>(</span>chars<span>)</span><span>;</span>
         <span>return</span> str<span>;</span>
    <span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div><blockquote>
<h3 id="_10-string类的常用方法都有那些"> 10.String类的常用方法都有那些?</h3>
</blockquote>
<ul>
<li>
<p>indexOf()：返回指定字符的索引。</p>
</li>
<li>
<p>charAt()：返回指定索引处的字符。</p>
</li>
<li>
<p>replace()：字符串替换。</p>
</li>
<li>
<p>trim()：去除字符串两端空白。</p>
</li>
<li>
<p>split()：分割字符串，返回一个分割后的字符串数组。</p>
</li>
<li>
<p>getBytes()：返回字符串的 byte 类型数组。</p>
</li>
<li>
<p>length()：返回字符串长度。</p>
</li>
<li>
<p>toLowerCase()：将字符串转成小写字母。</p>
</li>
<li>
<p>toUpperCase()：将字符串转成大写字符。</p>
</li>
<li>
<p>toCharArray()：转为字符数组</p>
</li>
<li>
<p>substring()：截取字符串。</p>
</li>
<li>
<p>equals()：字符串比较。</p>
</li>
</ul>
<blockquote>
<h3 id="_11-抽象类必须要有抽象方法吗"> 11.抽象类必须要有抽象方法吗?</h3>
</blockquote>
<p>不需要，抽象类不一定非要有抽象方法。</p>
<p>示例代码：</p>
<div><pre><code><span>abstract</span> <span>class</span> <span>Cat</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>sayHi</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"hi~"</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>上面代码，抽象类并没有抽象方法但完全可以正常运行。</p>
<blockquote>
<h3 id="_12-普通类和抽象类有哪些区别"> 12.普通类和抽象类有哪些区别?</h3>
</blockquote>
<ul>
<li>普通类不能包含抽象方法，抽象类可以包含抽象方法。</li>
<li>抽象类不能直接实例化，普通类可以直接实例化。</li>
</ul>
<blockquote>
<h3 id="_13-抽象类能使用final-修饰吗"> 13.抽象类能使用final 修饰吗?</h3>
</blockquote>
<p>不能，定义抽象类就是让其他类继承的，如果定义为 final 该类就不能被继承，这样彼此就会产生矛盾，所以 final 不能修饰抽象类，</p>
<p>如果在抽象类上加final关键字，编辑器也会提示错误信息：</p>
<blockquote>
<h3 id="_14-接口和抽象类有什么区别"> 14.接口和抽象类有什么区别?</h3>
</blockquote>
<ul>
<li>实现：抽象类的子类使用 extends 来继承；接口必须使用 implements 来实现接口。</li>
<li>构造函数：抽象类可以有构造函数；接口不能有。</li>
<li>main 方法：抽象类可以有 main 方法，并且我们能运行它；接口不能有 main 方法。</li>
<li>实现数量：类可以实现很多个接口；但是只能继承一个抽象类。</li>
<li>访问修饰符：接口中的方法默认使用 public 修饰；抽象类中的方法可以是任意访问修饰符。</li>
</ul>
<blockquote>
<h3 id="_15-java中io流分为几种"> 15.java中IO流分为几种?</h3>
</blockquote>
<p>按功能来分：输入流（input）、输出流（output）。</p>
<p>按类型来分：字节流和字符流。</p>
<p>字节流和字符流的区别是：字节流按 8 位传输以字节为单位输入输出数据，字符流按 16 位传输以字符为单位输入输出数据。</p>
<blockquote>
<h3 id="_16-bio、nio、aio有什么区别"> 16.BIO、NIO、AIO有什么区别</h3>
</blockquote>
<ul>
<li>BIO：Block IO 同步阻塞式 IO，就是我们平常使用的传统 IO，它的特点是模式简单使用方便，并发处理能力低。</li>
<li>NIO：New IO 同步非阻塞 IO，是传统 IO 的升级，客户端和服务器端通过 Channel（通道）通讯，实现了多路复用。</li>
<li>AIO：Asynchronous IO 是 NIO 的升级，也叫 NIO2，实现了异步非堵塞 IO ，异步 IO 的操作基于<strong>事件和回调机制</strong>。</li>
</ul>
<blockquote>
<h3 id="_17-files的常用方法有哪些"> 17.Files的常用方法有哪些？</h3>
</blockquote>
<ul>
<li>Files.exists()：检测文件路径是否存在。</li>
<li>Files.createFile()：创建文件。</li>
<li>Files.createDirectory()：创建文件夹。</li>
<li>Files.delete()：删除一个文件或目录。</li>
<li>Files.copy()：复制文件。</li>
<li>Files.move()：移动文件。</li>
<li>Files.size()：查看文件个数。</li>
<li>Files.read()：读取文件。</li>
<li>Files.write()：写入文件。</li>
</ul>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <contributor>
      <name>南辞</name>
    </contributor>
    <published>2021-02-18T01:11:00.000Z</published>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">模块02-Java集合（容器）</title>
    <id>http://qiqi.dreamagain.top/interview/Java208/%E6%A8%A1%E5%9D%9702%E2%80%94Java%E9%9B%86%E5%90%88/</id>
    <link href="http://qiqi.dreamagain.top/interview/Java208/%E6%A8%A1%E5%9D%9702%E2%80%94Java%E9%9B%86%E5%90%88/"/>
    <updated>2021-02-18T01:11:00.000Z</updated>
    <content type="html"><![CDATA[<h2 id="问题"> 问题：</h2>
<p>18.java容器都有哪些?</p>
<p>19.Collection和Collections有什么区别?</p>
<p>20.List、Set、Map 之间的区别是什么?</p>
<p>21.HashMap和Hashtable有什么区别?</p>
<p>22.如何决定使用HashMap还是TreeMap?</p>
<p>23.说一下HashMap 的实现原理?</p>
<p>24.说一下 HashSet 的实现原理?</p>
<p>25.ArrayList和LinkedList的区别是什么?</p>
<p>26.如何实现数组和List 之间的转换?</p>
<p>27.ArrayList和Vector 的区别是什么?</p>
<p>28.Array和ArrayList有何区别?</p>
<p>29.在 Queue 中 poll()和remove()有什么区别?</p>
<p>30.哪些集合类是线程安全的?</p>
<p>31.迭代器lterator 是什么?</p>
<p>32.lterator怎么使用?有什么特点?</p>
<p>33.lterator和Listlterator有什么区别?</p>
<p>34.怎么确保一个集合不能被修改？</p>
<h2 id="答案"> 答案：</h2>
<h3 id="_18-java容器都有哪些"> 18.java容器都有哪些?</h3>
<p><img src="./assets/java-03.png" alt=""></p>
<h3 id="_19-collection和collections有什么区别"> 19.Collection和Collections有什么区别?</h3>
<ul>
<li>java.util.Collection 是一个集合接口（集合类的一个顶级接口）。它提供了对集合对象进行基本操作的通用接口方法。Collection接口在Java 类库中有很多具体的实现。Collection接口的意义是为各种具体的集合提供了最大化的统一操作方式，其直接继承接口有List与Set。</li>
<li>Collections则是集合类的一个工具类/帮助类，其中提供了一系列静态方法，用于对集合中元素进行排序、搜索以及线程安全等各种操作。</li>
</ul>
<h3 id="_20-list、set、map-之间的区别是什么"> 20.List、Set、Map 之间的区别是什么?</h3>
<img src="./assets/java-04.png" style="zoom:80%;" />
<h3 id="_21-hashmap和hashtable有什么区别"> 21.HashMap和Hashtable有什么区别?</h3>
<ul>
<li>hashMap去掉了Hashtable 的contains方法，但是加上了containsValue（）和containsKey（）方法。</li>
<li>Hashtable同步的，而HashMap是非同步的，效率上比Hashtable要高。</li>
<li>hashMap允许空键值，而Hashtable不允许。</li>
</ul>
<h3 id="_22-如何决定使用hashmap还是treemap"> 22.如何决定使用HashMap还是TreeMap?</h3>
<p>对于在Map中插入、删除和定位元素这类操作，HashMap是最好的选择。</p>
<p>然而，假如你需要对一个有序的key集合进行遍历，TreeMap是更好的选择。基于你的collection的大小，也许向HashMap中添加元素</p>
<p>会更快，将map换为TreeMap进行有序key的遍历。</p>
<h3 id="_23-说一下hashmap-的实现原理"> 23.说一下HashMap 的实现原理?</h3>
<p><strong>HashMap概述：</strong> HashMap是基于哈希表的Map接口的非同步实现。此实现提供所有可选的映射操作，并允许使用null值和null键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。</p>
<p><strong>HashMap的数据结构：</strong> 在java编程语言中，最基本的结构就是两种，一个是数组，另外一个是模拟指针（引用），所有的数据结构都可以用这两个基本结构来构造的，HashMap也不例外。HashMap实际上是一个“链表散列”的数据结构，即数组和链表的结合体。</p>
<p>当我们往HashMap中put元素时,首先根据key的hashcode重新计算hash值,根据hash值得到这个元素在数组中的位置(下标),如果该数组在该位置上已经存放了其他元素,那么在这个位置上的元素将以链表的形式存放,新加入的放在链头,最先加入的放入链尾.如果数组中该位置没有元素,就直接将该元素放到数组的该位置上。</p>
<p>需要注意Jdk 1.8中对HashMap的实现做了优化,当链表中的节点数据超过<strong>八个</strong>之后,该链表会转为<strong>红黑树</strong>来提高查询效率,从原来的O(n)到O(logn)</p>
<h3 id="_24-说一下-hashset-的实现原理"> 24.说一下 HashSet 的实现原理?</h3>
<ul>
<li>
<p>HashSet底层由HashMap实现</p>
</li>
<li>
<p>HashSet的值存放于HashMap的key上</p>
</li>
<li>
<p>HashMap的value统一为PRESENT</p>
</li>
</ul>
<h3 id="_25-arraylist和linkedlist的区别是什么"> 25.ArrayList和LinkedList的区别是什么?</h3>
<p>最明显的区别是 ArrrayList底层的数据结构是数组，支持随机访问，而 LinkedList 的底层数据结构是双向循环链表，不支持随机访问。</p>
<p>使用下标访问一个元素，ArrayList 的时间复杂度是 O(1)，而 LinkedList 是 O(n)。</p>
<h3 id="_26-如何实现数组和list-之间的转换"> 26.如何实现数组和List 之间的转换?</h3>
<ul>
<li>
<p>List转换成为数组：调用ArrayList的toArray方法。</p>
</li>
<li>
<p>数组转换成为List：调用Arrays的asList方法。</p>
</li>
</ul>
<h3 id="_27-arraylist和vector-的区别是什么"> 27.ArrayList和Vector 的区别是什么?</h3>
<ul>
<li>
<p>Vector是同步的，而ArrayList不是。然而，如果你寻求在迭代的时候对列表进行改变，你应该使用CopyOnWriteArrayList。</p>
</li>
<li>
<p>ArrayList比Vector快，Vecto它因为有同步，不会过载。 ArrayList在多线程情况下可能会出现ConcurrentModificationException。</p>
</li>
<li>
<p>ArrayList更加通用，因为我们可以使用Collections工具类轻易地获取同步列表和只读列表。</p>
</li>
</ul>
<h3 id="_28-array和arraylist有何区别"> 28.Array和ArrayList有何区别?</h3>
<ul>
<li>
<p>Array可以容纳基本类型和对象，而ArrayList只能容纳对象。</p>
</li>
<li>
<p>Array是指定大小的，而ArrayList大小是固定的。</p>
</li>
<li>
<p>Array没有提供ArrayList那么多功能，比如addAll、removeAll和iterator等。</p>
</li>
</ul>
<h3 id="_29-在-queue-中-poll-和remove-有什么区别"> 29.在 Queue 中 poll()和remove()有什么区别?</h3>
<p>poll() 和 remove() 都是从队列中取出一个元素，但是 poll() 在获取元素失败的时候会返回空，但是 remove() 失败的时候会抛出异常。</p>
<h3 id="_30-哪些集合类是线程安全的"> 30.哪些集合类是线程安全的?</h3>
<ul>
<li>
<p>Vector：就比ArrayList多了个同步化机制（线程安全），因为效率较低，现在已经不太建议使用。在web应用中，特别是前台页面，往往效率（页面响应速度）是优先考虑的。</p>
</li>
<li>
<p>statck：堆栈类，先进后出。</p>
</li>
<li>
<p>Hashtable：就比HashMap多了个线程安全。</p>
</li>
<li>
<p>Enumeration：枚举，相当于迭代器。</p>
</li>
</ul>
<h3 id="_31-迭代器lterator-是什么"> 31.迭代器lterator 是什么?</h3>
<p>迭代器是一种设计模式，它是一个对象，它可以遍历并选择序列中的对象，而开发人员不需要了解该序列的底层结构。迭代器通常被称</p>
<p>为“轻量级”对象，因为创建它的代价小。</p>
<h3 id="_32-lterator怎么使用-有什么特点"> 32.lterator怎么使用?有什么特点?</h3>
<p>Java中的Iterator功能比较简单，并且只能单向移动：</p>
<p>(1) 使用方法iterator()要求容器返回一个Iterator。第一次调用Iterator的next()方法时，它返回序列的第一个元素。注意：iterator()方法是java.lang.Iterable接口,被Collection继承。</p>
<p>(2) 使用next()获得序列中的下一个元素。</p>
<p>(3) 使用hasNext()检查序列中是否还有元素。</p>
<p>(4) 使用remove()将迭代器新返回的元素删除。</p>
<p>Iterator是Java迭代器最简单的实现，为List设计的ListIterator具有更多的功能，它可以从两个方向遍历List，也可以从List中插入和删除元素。</p>
<h3 id="_33-lterator和listlterator有什么区别"> 33.lterator和Listlterator有什么区别?</h3>
<ul>
<li>Iterator可用来遍历Set和List集合，但是ListIterator只能用来遍历List。</li>
<li>Iterator对集合只能是前向遍历，ListIterator既可以前向也可以后向。</li>
<li>ListIterator实现了Iterator接口，并包含其他的功能，比如：增加元素，替换元素，获取前一个和后一个元素的索引，等等。</li>
</ul>
<h3 id="_34-怎么确保一个集合不能被修改"> 34.怎么确保一个集合不能被修改？</h3>
<p>可以使用 Collections. unmodifiableCollection(Collection c) 方法来创建一个只读集合，这样改变集合的任何操作都会抛出 Java. lang.</p>
<p>UnsupportedOperationException 异常。</p>
<p>示例代码如下：</p>
<div><pre><code><span>List</span><span><span>&lt;</span><span>String</span><span>></span></span> list <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
list<span>.</span> <span>add</span><span>(</span><span>"A"</span><span>)</span><span>;</span>
<span>Collection</span><span><span>&lt;</span><span>String</span><span>></span></span> unmlist <span>=</span> <span>Collections</span><span>.</span> <span>unmodifiableCollection</span><span>(</span>list<span>)</span><span>;</span>
unmlist<span>.</span> <span>add</span><span>(</span><span>"B"</span><span>)</span><span>;</span> <span>// 运行时此行报错</span>
<span>System</span><span>.</span> out<span>.</span> <span>println</span><span>(</span>list<span>.</span><span>size</span><span>(</span><span>)</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div>]]></content>
    <author>
      <name>南辞</name>
    </author>
    <contributor>
      <name>南辞</name>
    </contributor>
    <published>2021-02-18T01:11:00.000Z</published>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">模块03-Java多线程</title>
    <id>http://qiqi.dreamagain.top/interview/Java208/%E6%A8%A1%E5%9D%9703%E2%80%94%E5%A4%9A%E7%BA%BF%E7%A8%8B/</id>
    <link href="http://qiqi.dreamagain.top/interview/Java208/%E6%A8%A1%E5%9D%9703%E2%80%94%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <updated>2021-02-18T01:11:00.000Z</updated>
    <content type="html"><![CDATA[<h2 id="问题"> 问题：</h2>
<p>35.并行和并发有什么区别?</p>
<p>36.线程和进程的区别?</p>
<p>37.守护线程是什么?</p>
<p>38.创建线程有哪几种方式?</p>
<p>39.说一下runnable和callable有什么区别?</p>
<p>40.线程有哪些状态?</p>
<p>41.sleep()和wait()有什么区别?</p>
<p>42.notify()和 notifyAll)有什么区别?</p>
<p>43.线程的run()和start()有什么区别?</p>
<p>44.创建线程池有哪几种方式?</p>
<p>45.线程池都有哪些状态?</p>
<p>46.线程池中 submit()和execute()方法有什么区别?</p>
<p>47.在java程序中怎么保证多线程的运行安全?</p>
<p>48.多线程锁的升级原理是什么?</p>
<p>49.什么是死锁?</p>
<p>50.怎么防止死锁?</p>
<p>51.ThreadLocal是什么?有哪些使用场景?</p>
<p>52.说一下synchronized底层实现原理?</p>
<p>53.synchronized和volatile 的区别是什么?</p>
<p>54.synchronized和Lock有什么区别?</p>
<p>55.synchronized和ReentrantLock区别是什么?</p>
<p>56.说一下atomic 的原理?</p>
<h3 id="答案"> 答案：</h3>
<h3 id="_35-并行和并发有什么区别"> 35.并行和并发有什么区别?</h3>
<ul>
<li>并行是指两个或者多个事件在同一时刻发生；而并发是指两个或多个事件在同一时间间隔发生。</li>
<li>并行是在不同实体上的多个事件，并发是在同一实体上的多个事件。</li>
<li>在一台处理器上“同时”处理多个任务；在多台处理器上同时处理多个任务。如hadoop分布式集群。</li>
</ul>
<p>所以并发编程的目标是充分的利用处理器的每一个核，以达到最高的处理性能。</p>
<h3 id="_36-线程和进程的区别"> 36.线程和进程的区别?</h3>
<p>简而言之，进程是程序运行和资源分配的基本单位，一个程序至少有一个进程，一个进程至少有一个线程。</p>
<p>进程在执行过程中拥有独立的内存单元，而多个线程共享内存资源，减少切换次数，从而效率更高。</p>
<p>线程是进程的一个实体，是cpu调度和分派的基本单位，是比程序更小的能独立运行的基本单位。</p>
<p>同一进程中的多个线程之间可以并发执行。</p>
<h3 id="_37-守护线程是什么"> 37.守护线程是什么?</h3>
<p>守护线程（即daemon thread），是个服务线程，准确地来说就是服务其他的线程。</p>
<h3 id="_38-创建线程有哪几种方式"> 38.创建线程有哪几种方式?</h3>
<p>①. 继承Thread类创建线程类</p>
<ul>
<li>定义Thread类的子类，并重写该类的run方法，该run方法的方法体就代表了线程要完成的任务。因此把run()方法称为执行体。</li>
<li>创建Thread子类的实例，即创建了线程对象。</li>
<li>调用线程对象的start()方法来启动该线程。</li>
</ul>
<p>②. 通过Runnable接口创建线程类</p>
<ul>
<li>定义runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体同样是该线程的线程执行体。</li>
<li>创建 Runnable实现类的实例，并依此实例作为Thread的target来创建Thread对象，该Thread对象才是真正的线程对象。</li>
<li>调用线程对象的start()方法来启动该线程。</li>
</ul>
<p>③. 通过Callable和Future创建线程</p>
<ul>
<li>创建Callable接口的实现类，并实现call()方法，该call()方法将作为线程执行体，并且有返回值。</li>
<li>创建Callable实现类的实例，使用FutureTask类来包装Callable对象，该FutureTask对象封装了该Callable对象的call()方法的返回值。</li>
<li>使用FutureTask对象作为Thread对象的target创建并启动新线程。</li>
<li>调用FutureTask对象的get()方法来获得子线程执行结束后的返回值。</li>
</ul>
<h3 id="_39-说一下runnable和callable有什么区别"> 39.说一下runnable和callable有什么区别?</h3>
<p>有点深的问题了，也看出一个Java程序员学习知识的广度。</p>
<ul>
<li>Runnable接口中的run()方法的返回值是void，它做的事情只是纯粹地去执行run()方法中的代码而已；</li>
<li>Callable接口中的call()方法是有返回值的，是一个泛型，和Future、FutureTask配合可以用来<strong>获取异步执行的结果</strong>。</li>
</ul>
<h3 id="_40-线程有哪些状态"> 40.线程有哪些状态?</h3>
<p>线程通常都有五种状态，创建、就绪、运行、阻塞和死亡。</p>
<ul>
<li>创建状态。在生成线程对象，并没有调用该对象的start方法，这是线程处于创建状态。</li>
<li>就绪状态。当调用了线程对象的start方法之后，该线程就进入了就绪状态，但是此时线程调度程序还没有把该线程设置为当前线程，此时处于就绪状态。在线程运行之后，从等待或者睡眠中回来之后，也会处于就绪状态。</li>
<li>运行状态。线程调度程序将处于就绪状态的线程设置为当前线程，此时线程就进入了运行状态，开始运行run函数当中的代码。</li>
<li>阻塞状态。线程正在运行的时候，被暂停，通常是为了等待某个时间的发生(比如说某项资源就绪)之后再继续运行。sleep,suspend，wait等方法都可以导致线程阻塞。</li>
<li>死亡状态。如果一个线程的run方法执行结束或者调用stop方法后，该线程就会死亡。对于已经死亡的线程，无法再使用start方法令其进入就绪</li>
</ul>
<h3 id="_41-sleep-和wait-有什么区别"> 41.sleep()和wait()有什么区别?</h3>
<ul>
<li>
<p>sleep()：方法是线程类（Thread）的静态方法，让调用线程进入睡眠状态，让出执行机会给其他线程，等到休眠时间结束后，线程进入就绪状态和其他线程一起竞争cpu的执行时间。</p>
</li>
<li>
<p>因为sleep() 是static静态的方法，他不能改变对象的机锁，当一个synchronized块中调用了sleep() 方法，线程虽然进入休眠，但是对象的机锁没有被释放，其他线程依然无法访问这个对象。</p>
</li>
<li>
<p>wait()：wait()是Object类的方法，当一个线程执行到wait方法时，它就进入到一个和该对象相关的等待池，同时释放对象的机锁，使得其他线程能够访问，可以通过notify，notifyAll方法来唤醒等待的线程</p>
</li>
</ul>
<h3 id="_42-notify-和-notifyall-有什么区别"> 42.notify()和 notifyAll)有什么区别?</h3>
<ul>
<li>如果线程调用了对象的 wait()方法，那么线程便会处于该对象的等待池中，等待池中的线程不会去竞争该对象的锁。</li>
<li>当有线程调用了对象的 notifyAll()方法（唤醒所有 wait 线程）或 notify()方法（只随机唤醒一个 wait 线程），被唤醒的的线程便会进入该对象的锁池中，锁池中的线程会去竞争该对象锁。也就是说，调用了notify后只要一个线程会由等待池进入锁池，而notifyAll会将该对象等待池内的所有线程移动到锁池中，等待锁竞争。</li>
<li>优先级高的线程竞争到对象锁的概率大，假若某线程没有竞争到该对象锁，它还会留在锁池中，唯有线程再次调用 wait()方法，它才会重新回到等待池中。而竞争到对象锁的线程则继续往下执行，直到执行完了 synchronized 代码块，它会释放掉该对象锁，这时锁池中的线程会继续竞争该对象锁。</li>
</ul>
<h3 id="_43-线程的run-和start-有什么区别"> 43.线程的run()和start()有什么区别?</h3>
<ul>
<li>
<p>每个线程都是通过某个特定Thread对象所对应的方法run()来完成其操作的，方法run()称为线程体。通过调用Thread类的start()方法来启动一个线程。</p>
</li>
<li>
<p>start()方法来启动一个线程，真正实现了多线程运行。这时无需等待run方法体代码执行完毕，可以直接继续执行下面的代码； 这时此线程是处于就绪状态， 并没有运行。 然后通过此Thread类调用方法run()来完成其运行状态， 这里方法run()称为线程体，它包含了要执行的这个线程的内容， run方法运行结束， 此线程终止。然后CPU再调度其它线程。</p>
</li>
<li>
<p>run()方法是在本线程里的，只是线程里的一个函数,而不是多线程的。 如果直接调用run(),其实就相当于是调用了一个普通函数而已，直接待用run()方法必须等待run()方法执行完毕才能执行下面的代码，所以执行路径还是只有一条，根本就没有线程的特征，所以在多线程执行时要使用start()方法而不是run()方法。</p>
</li>
</ul>
<h3 id="_44-创建线程池有哪几种方式"> 44.创建线程池有哪几种方式?</h3>
<p><strong>①. newFixedThreadPool(int nThreads)</strong></p>
<p>创建一个固定长度的线程池，每当提交一个任务就创建一个线程，直到达到线程池的最大数量，这时线程规模将不再变化，当线程发生未预期的错误而结束时，线程池会补充一个新的线程。</p>
<p><strong>②. newCachedThreadPool()</strong></p>
<p>创建一个可缓存的线程池，如果线程池的规模超过了处理需求，将自动回收空闲线程，而当需求增加时，则可以自动添加新线程，线程池的规模不存在任何限制。</p>
<p><strong>③. newSingleThreadExecutor()</strong></p>
<p>这是一个单线程的Executor，它创建单个工作线程来执行任务，如果这个线程异常结束，会创建一个新的来替代它；它的特点是能确保依照任务在队列中的顺序来串行执行。</p>
<p><strong>④. newScheduledThreadPool(int corePoolSize)</strong></p>
<p>创建了一个固定长度的线程池，而且以延迟或定时的方式来执行任务，类似于Timer。</p>
<h3 id="_45-线程池都有哪些状态"> 45.线程池都有哪些状态?</h3>
<p>线程池有5种状态：Running、ShutDown、Stop、Tidying、Terminated。</p>
<p>线程池各个状态切换框架图：</p>
<p><img src="./assets/java-01.png" alt=""></p>
<h3 id="_46-线程池中-submit-和execute-方法有什么区别"> 46.线程池中 submit()和execute()方法有什么区别?</h3>
<ul>
<li>接收的参数不一样</li>
<li>submit有返回值，而execute没有</li>
<li>submit方便Exception处理</li>
</ul>
<h3 id="_47-在java程序中怎么保证多线程的运行安全"> 47.在java程序中怎么保证多线程的运行安全?</h3>
<p>线程安全在三个方面体现：</p>
<ul>
<li>原子性：提供互斥访问，同一时刻只能有一个线程对数据进行操作，（atomic,synchronized）；</li>
<li>可见性：一个线程对主内存的修改可以及时地被其他线程看到，（synchronized,volatile）；</li>
<li>有序性：一个线程观察其他线程中的指令执行顺序，由于指令重排序，该观察结果一般杂乱无序，（happens-before原则）。</li>
</ul>
<h3 id="_48-多线程锁的升级原理是什么"> 48.多线程锁的升级原理是什么?</h3>
<p>在Java中，锁共有4种状态，级别从低到高依次为：无状态锁，偏向锁，轻量级锁和重量级锁状态，这几个状态会随着竞争情况逐渐升</p>
<p>级。锁可以升级但不能降级。</p>
<p>锁升级的图示过程：</p>
<p><img src="./assets/java-02.png" alt=""></p>
<h3 id="_49-什么是死锁"> 49.什么是死锁?</h3>
<p>死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无</p>
<p>法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。是操作系统层面的一个错误，是</p>
<p>进程死锁的简称，最早在 1965 年由 Dijkstra 在研究银行家算法时提出的，它是计算机操作系统乃至整个并发程序设计领域最难处理的</p>
<p>问题之一。</p>
<h3 id="_50-怎么防止死锁"> 50.怎么防止死锁?</h3>
<p>死锁的四个必要条件：</p>
<ul>
<li>**互斥条件：**进程对所分配到的资源不允许其他进程进行访问，若其他进程访问该资源，只能等待，直至占有该资源的进程使用完成后释放该资源</li>
<li>**请求和保持条件：**进程获得一定的资源之后，又对其他资源发出请求，但是该资源可能被其他进程占有，此事请求阻塞，但又对自己获得的资源保持不放</li>
<li>**不可剥夺条件：**是指进程已获得的资源，在未完成使用之前，不可被剥夺，只能在使用完后自己释放</li>
<li>**环路等待条件：**是指进程发生死锁后，若干进程之间形成一种头尾相接的循环等待资源关系</li>
</ul>
<p>这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之 一不满足，就不会发生死锁。</p>
<p>理解了死锁的原因，尤其是产生死锁的四个必要条件，就可以最大可能地避免、预防和 解除死锁。</p>
<p>所以，在系统设计、进程调度等方面注意如何不让这四个必要条件成立，如何确 定资源的合理分配算法，避免进程永久占据系统资源。</p>
<p>此外，也要防止进程在处于等待状态的情况下占用资源。因此，对资源的分配要给予合理的规划。</p>
<h3 id="_51-threadlocal是什么-有哪些使用场景"> 51.ThreadLocal是什么?有哪些使用场景?</h3>
<p>线程局部变量是局限于线程内部的变量，属于线程自身所有，不在多个线程间共享。Java提供ThreadLocal类来支持线程局部变量，是</p>
<p>一种实现线程安全的方式。但是在管理环境下（如 web 服务器）使用线程局部变量的时候要特别小心，在这种情况下，工作线程的生</p>
<p>命周期比任何应用变量的生命周期都要长。任何线程局部变量一旦在工作完成后没有释放，Java 应用就存在内存泄露的风险。</p>
<h3 id="_52-说一下synchronized底层实现原理"> 52.说一下synchronized底层实现原理?</h3>
<p>synchronized可以保证方法或者代码块在运行时，同一时刻只有一个方法可以进入到临界区，同时它还可以保证共享变量的内存可见性。</p>
<p>Java中每一个对象都可以作为锁，这是synchronized实现同步的基础：</p>
<ul>
<li>普通同步方法，锁是当前实例对象</li>
<li>静态同步方法，锁是当前类的class对象</li>
<li>同步方法块，锁是括号里面的对象</li>
</ul>
<h3 id="_53-synchronized和volatile-的区别是什么"> 53.synchronized和volatile 的区别是什么?</h3>
<ul>
<li>volatile本质是在告诉jvm当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取； synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。</li>
<li>volatile仅能使用在变量级别；synchronized则可以使用在变量、方法、和类级别的。</li>
<li>volatile仅能实现变量的修改可见性，不能保证原子性；而synchronized则可以保证变量的修改可见性和原子性。</li>
<li>volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞。</li>
<li>volatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化。</li>
</ul>
<h3 id="_54-synchronized和lock有什么区别"> 54.synchronized和Lock有什么区别?</h3>
<ul>
<li>首先synchronized是java内置关键字，在jvm层面，Lock是个java类；</li>
<li>synchronized无法判断是否获取锁的状态，Lock可以判断是否获取到锁；</li>
<li>synchronized会自动释放锁(a 线程执行完同步代码会释放锁 ；b 线程执行过程中发生异常会释放锁)，Lock需在finally中手工释放锁（unlock()方法释放锁），否则容易造成线程死锁；</li>
<li>用synchronized关键字的两个线程1和线程2，如果当前线程1获得锁，线程2线程等待。如果线程1阻塞，线程2则会一直等待下去，而Lock锁就不一定会等待下去，如果尝试获取不到锁，线程可以不用一直等待就结束了；</li>
<li>synchronized的锁可重入、不可中断、非公平，而Lock锁可重入、可判断、可公平（两者皆可）；</li>
<li>Lock锁适合大量同步的代码的同步问题，synchronized锁适合代码少量的同步问题。</li>
</ul>
<h3 id="_55-synchronized和reentrantlock区别是什么"> 55.synchronized和ReentrantLock区别是什么?</h3>
<p>synchronized是和if、else、for、while一样的关键字，ReentrantLock是类，这是二者的本质区别。既然ReentrantLock是类，那么它</p>
<p>就提供了比synchronized更多更灵活的特性，可以被继承、可以有方法、可以有各种各样的类变量，ReentrantLock比synchronized的</p>
<p>扩展性体现在几点上：</p>
<ul>
<li>ReentrantLock可以对获取锁的等待时间进行设置，这样就避免了死锁</li>
<li>ReentrantLock可以获取各种锁的信息</li>
<li>ReentrantLock可以灵活地实现多路通知</li>
</ul>
<p>另外，二者的锁机制其实也是不一样的:ReentrantLock底层调用的是Unsafe的park方法加锁，synchronized操作的应该是对象头中mark word。</p>
<h3 id="_56-说一下atomic-的原理"> 56.说一下atomic 的原理?</h3>
<p>Atomic包中的类基本的特性就是在多线程环境下，当有多个线程同时对单个（包括基本类型及引用类型）变量进行操作时，具有排他</p>
<p>性，即当多个线程同时对该变量的值进行更新时，仅有一个线程能成功，而未成功的线程可以像自旋锁一样，继续尝试，一直等到执行</p>
<p>成功。</p>
<p>Atomic系列的类中的核心方法都会调用unsafe类中的几个本地方法。我们需要先知道一个东西就是Unsafe类，全名为：</p>
<p>sun.misc.Unsafe，这个类包含了大量的对C代码的操作，包括很多直接内存分配以及原子操作的调用，而它之所以标记为非安全的，是</p>
<p>告诉你这个里面大量的方法调用都会存在安全隐患，需要小心使用，否则会导致严重的后果，例如在通过unsafe分配内存的时候，如果</p>
<p>自己指定某些区域可能会导致一些类似C++一样的指针越界到其他进程的问题。</p>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <contributor>
      <name>南辞</name>
    </contributor>
    <published>2021-02-18T01:11:00.000Z</published>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">模块04-Java反射</title>
    <id>http://qiqi.dreamagain.top/interview/Java208/%E6%A8%A1%E5%9D%9704%E2%80%94%E5%8F%8D%E5%B0%84/</id>
    <link href="http://qiqi.dreamagain.top/interview/Java208/%E6%A8%A1%E5%9D%9704%E2%80%94%E5%8F%8D%E5%B0%84/"/>
    <updated>2021-02-18T01:11:00.000Z</updated>
    <content type="html"><![CDATA[<h2 id="问题"> 问题：</h2>
<p>57.什么是反射?</p>
<p>58.什么是java序列化?什么情况下需要序列化?</p>
<p>59.动态代理是什么?有哪些应用?</p>
<p>60.怎么实现动态代理?</p>
<h2 id="答案"> 答案：</h2>
<h3 id="_57-什么是反射"> 57.什么是反射?</h3>
<p>反射主要是指程序可以访问、检测和修改它本身状态或行为的一种能力</p>
<p><strong>Java反射：</strong></p>
<p>在Java运行时环境中，对于任意一个类，能否知道这个类有哪些属性和方法？对于任意一个对象，能否调用它的任意一个方法</p>
<p>Java反射机制主要提供了以下功能：</p>
<ul>
<li>在运行时判断任意一个对象所属的类。</li>
<li>在运行时构造任意一个类的对象。</li>
<li>在运行时判断任意一个类所具有的成员变量和方法。</li>
<li>在运行时调用任意一个对象的方法。</li>
</ul>
<h3 id="_58-什么是java序列化-什么情况下需要序列化"> 58.什么是java序列化?什么情况下需要序列化?</h3>
<p>简单说就是为了保存在内存中的各种对象的状态（也就是实例变量，不是方法），并且可以把保存的对象状态再读出来。虽然你可以用</p>
<p>你自己的各种各样的方法来保存object states，但是Java给你提供一种应该比你自己好的保存对象状态的机制，那就是序列化。</p>
<p><strong>什么情况下需要序列化：</strong></p>
<ol>
<li>当你想把的内存中的对象状态保存到一个文件中或者数据库中时候；</li>
<li>当你想用<strong>套接字</strong>在网络上传送对象的时候；</li>
<li>当你想通过<strong>RMI</strong>传输对象的时候；</li>
</ol>
<h3 id="_59-动态代理是什么-有哪些应用"> 59.动态代理是什么?有哪些应用?</h3>
<p>动态代理：</p>
<p>当想要给实现了某个接口的类中的方法，加一些额外的处理。比如说加日志，加事务等。可以给这个类创建一个代理，故名思议就是创建一个新的类，这个类不仅包含原来类方法的功能，而且还在原来的基础上添加了额外处理的新类。这个代理类并不是定义好的，是动态生成的。具有解耦意义，灵活，扩展性强。</p>
<p>动态代理的应用：</p>
<ul>
<li>Spring的AOP</li>
<li>加事务</li>
<li>加权限</li>
<li>加日志</li>
</ul>
<h3 id="_60-怎么实现动态代理"> 60.怎么实现动态代理?</h3>
<ul>
<li>
<p>首先必须定义一个接口，还要有一个InvocationHandler(将实现接口的类的对象传递给它)处理类。</p>
</li>
<li>
<p>再有一个工具类Proxy(习惯性将其称为代理类，因为调用他的newInstance()可以产生代理对象,其实他只是一个产生代理对象的工具类）。</p>
</li>
<li>
<p>利用到InvocationHandler，拼接代理类源码，将其编译生成代理类的二进制码，利用加载器加载，并将其实例化产生代理对象，最后返回。</p>
</li>
</ul>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <contributor>
      <name>南辞</name>
    </contributor>
    <published>2021-02-18T01:11:00.000Z</published>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">模块05-Java对象拷贝</title>
    <id>http://qiqi.dreamagain.top/interview/Java208/%E6%A8%A1%E5%9D%9705%E2%80%94%E5%AF%B9%E8%B1%A1%E6%8B%B7%E8%B4%9D/</id>
    <link href="http://qiqi.dreamagain.top/interview/Java208/%E6%A8%A1%E5%9D%9705%E2%80%94%E5%AF%B9%E8%B1%A1%E6%8B%B7%E8%B4%9D/"/>
    <updated>2021-02-18T01:11:00.000Z</updated>
    <content type="html"><![CDATA[<h2 id="问题"> 问题：</h2>
<p>61.为什么要使用克隆?</p>
<p>62.如何实现对象克隆?</p>
<p>63.深拷贝和浅拷贝区别是什么?</p>
<h2 id="答案"> 答案：</h2>
<h3 id="_61-为什么要使用克隆"> 61.为什么要使用克隆?</h3>
<p>想对一个对象进行处理，又想保留原有的数据进行接下来的操作，就需要克隆了，Java语言中克隆针对的是类的实例。</p>
<h3 id="_62-如何实现对象克隆"> 62.如何实现对象克隆?</h3>
<p>有两种方式：</p>
<p>1). 实现Cloneable接口并重写Object类中的clone()方法；</p>
<p>2). 实现Serializable接口，通过对象的序列化和反序列化实现克隆，可以实现真正的深度克隆，代码如下：</p>
<div><pre><code>
<span>import</span> <span>java<span>.</span>io<span>.</span></span><span>ByteArrayInputStream</span><span>;</span>
<span>import</span> <span>java<span>.</span>io<span>.</span></span><span>ByteArrayOutputStream</span><span>;</span>
<span>import</span> <span>java<span>.</span>io<span>.</span></span><span>ObjectInputStream</span><span>;</span>
<span>import</span> <span>java<span>.</span>io<span>.</span></span><span>ObjectOutputStream</span><span>;</span>
<span>import</span> <span>java<span>.</span>io<span>.</span></span><span>Serializable</span><span>;</span>

<span>public</span> <span>class</span> <span>MyUtil</span> <span>{</span>

    <span>private</span> <span>MyUtil</span><span>(</span><span>)</span> <span>{</span>
        <span>throw</span> <span>new</span> <span>AssertionError</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>

    <span>@SuppressWarnings</span><span>(</span><span>"unchecked"</span><span>)</span>
    <span>public</span> <span>static</span> <span><span>&lt;</span><span>T</span> <span>extends</span> <span>Serializable</span><span>></span></span> <span>T</span> <span>clone</span><span>(</span><span>T</span> obj<span>)</span> 
                                  <span>throws</span> <span>Exception</span> <span>{</span>
        <span>ByteArrayOutputStream</span> bout <span>=</span> <span>new</span> <span>ByteArrayOutputStream</span><span>(</span><span>)</span><span>;</span>
        <span>ObjectOutputStream</span> oos <span>=</span> <span>new</span> <span>ObjectOutputStream</span><span>(</span>bout<span>)</span><span>;</span>
        oos<span>.</span><span>writeObject</span><span>(</span>obj<span>)</span><span>;</span>

        <span>ByteArrayInputStream</span> bin <span>=</span> 
                    <span>new</span> <span>ByteArrayInputStream</span><span>(</span>bout<span>.</span><span>toByteArray</span><span>(</span><span>)</span><span>)</span><span>;</span>
        <span>ObjectInputStream</span> ois <span>=</span> <span>new</span> <span>ObjectInputStream</span><span>(</span>bin<span>)</span><span>;</span>
        <span>return</span> <span>(</span><span>T</span><span>)</span> ois<span>.</span><span>readObject</span><span>(</span><span>)</span><span>;</span>

        <span>// 说明：调用ByteArrayInputStream</span>
        <span>//或ByteArrayOutputStream对象的close方法没有任何意义</span>
        <span>// 这两个基于内存的流只要垃圾回收器清理对象就能够释放资源，</span>
        <span>//这一点不同于对外部资源（如文件流）的释放</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br></div></div><p>下面是测试代码：</p>
<div><pre><code>
<span>import</span> <span>java<span>.</span>io<span>.</span></span><span>Serializable</span><span>;</span>

<span>/**
 * 人类
 * @author nnngu
 *
 */</span>
<span>class</span> <span>Person</span> <span>implements</span> <span>Serializable</span> <span>{</span>
    <span>private</span> <span>static</span> <span>final</span> <span>long</span> serialVersionUID 
                              <span>=</span> <span>-</span><span>9102017020286042305L</span><span>;</span>

    <span>private</span> <span>String</span> name<span>;</span>    <span>// 姓名</span>
    <span>private</span> <span>int</span> age<span>;</span>        <span>// 年龄</span>
    <span>private</span> <span>Car</span> car<span>;</span>        <span>// 座驾</span>

    <span>public</span> <span>Person</span><span>(</span><span>String</span> name<span>,</span> <span>int</span> age<span>,</span> <span>Car</span> car<span>)</span> <span>{</span>
        <span>this</span><span>.</span>name <span>=</span> name<span>;</span>
        <span>this</span><span>.</span>age <span>=</span> age<span>;</span>
        <span>this</span><span>.</span>car <span>=</span> car<span>;</span>
    <span>}</span>

    <span>public</span> <span>String</span> <span>getName</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> name<span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>setName</span><span>(</span><span>String</span> name<span>)</span> <span>{</span>
        <span>this</span><span>.</span>name <span>=</span> name<span>;</span>
    <span>}</span>

    <span>public</span> <span>int</span> <span>getAge</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> age<span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>setAge</span><span>(</span><span>int</span> age<span>)</span> <span>{</span>
        <span>this</span><span>.</span>age <span>=</span> age<span>;</span>
    <span>}</span>

    <span>public</span> <span>Car</span> <span>getCar</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> car<span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>setCar</span><span>(</span><span>Car</span> car<span>)</span> <span>{</span>
        <span>this</span><span>.</span>car <span>=</span> car<span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>String</span> <span>toString</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> <span>"Person [name="</span> <span>+</span> name <span>+</span> "<span>,</span>
                       age<span>=</span><span>" + age + "</span><span>,</span> car<span>=</span><span>" + car + "</span><span>]</span>"<span>;</span>
    <span>}</span>

<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br></div></div><div><pre><code>
<span>/**
 * 小汽车类
 * @author nnngu
 *
 */</span>
<span>class</span> <span>Car</span> <span>implements</span> <span>Serializable</span> <span>{</span>
    <span>private</span> <span>static</span> <span>final</span> <span>long</span> serialVersionUID 
                                <span>=</span> <span>-</span><span>5713945027627603702L</span><span>;</span>

    <span>private</span> <span>String</span> brand<span>;</span>       <span>// 品牌</span>
    <span>private</span> <span>int</span> maxSpeed<span>;</span>       <span>// 最高时速</span>

    <span>public</span> <span>Car</span><span>(</span><span>String</span> brand<span>,</span> <span>int</span> maxSpeed<span>)</span> <span>{</span>
        <span>this</span><span>.</span>brand <span>=</span> brand<span>;</span>
        <span>this</span><span>.</span>maxSpeed <span>=</span> maxSpeed<span>;</span>
    <span>}</span>

    <span>public</span> <span>String</span> <span>getBrand</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> brand<span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>setBrand</span><span>(</span><span>String</span> brand<span>)</span> <span>{</span>
        <span>this</span><span>.</span>brand <span>=</span> brand<span>;</span>
    <span>}</span>

    <span>public</span> <span>int</span> <span>getMaxSpeed</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> maxSpeed<span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>setMaxSpeed</span><span>(</span><span>int</span> maxSpeed<span>)</span> <span>{</span>
        <span>this</span><span>.</span>maxSpeed <span>=</span> maxSpeed<span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>String</span> <span>toString</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> <span>"Car [brand="</span> <span>+</span> brand <span>+</span> "<span>,</span> 
                      maxSpeed<span>=</span><span>" + maxSpeed + "</span><span>]</span>"<span>;</span>
    <span>}</span>

<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br></div></div><div><pre><code>
<span>class</span> <span>CloneTest</span> <span>{</span>

    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>try</span> <span>{</span>
            <span>Person</span> p1 <span>=</span> <span>new</span> <span>Person</span><span>(</span><span>"郭靖"</span><span>,</span> <span>33</span><span>,</span> 
                              <span>new</span> <span>Car</span><span>(</span><span>"Benz"</span><span>,</span> <span>300</span><span>)</span><span>)</span><span>;</span>
            <span>Person</span> p2 <span>=</span> <span>MyUtil</span><span>.</span><span>clone</span><span>(</span>p1<span>)</span><span>;</span>   <span>// 深度克隆</span>
            p2<span>.</span><span>getCar</span><span>(</span><span>)</span><span>.</span><span>setBrand</span><span>(</span><span>"BYD"</span><span>)</span><span>;</span>
            <span>// 修改克隆的Person对象p2关联的汽车对象的品牌属性</span>
            <span>// 原来的Person对象p1关联的汽车不会受到任何影响</span>
            <span>// 因为在克隆Person对象时其关联的汽车对象也被克隆了</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>p1<span>)</span><span>;</span>
        <span>}</span> <span>catch</span> <span>(</span><span>Exception</span> e<span>)</span> <span>{</span>
            e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><p>注意：基于序列化和反序列化实现的克隆不仅仅是深度克隆，更重要的是通过泛型限定，可以检查出要克隆的对象是否支持序列化，这</p>
<p>项检查是编译器完成的，不是在运行时抛出异常，这种是方案明显优于使用Object类的clone方法克隆对象。让问题在编译的时候暴露</p>
<p>出来总是好过把问题留到运行时。</p>
<h3 id="_63-深拷贝和浅拷贝区别是什么"> 63.深拷贝和浅拷贝区别是什么?</h3>
<ul>
<li>浅拷贝只是复制了对象的引用地址，两个对象指向同一个内存地址，所以修改其中任意的值，另一个值都会随之变化，这就是浅拷贝（例：assign()）</li>
<li>深拷贝是将对象及值复制过来，两个对象修改其中任意的值另一个值不会改变，这就是深拷贝（例：JSON.parse()和JSON.stringify()，但是此方法无法复制函数类型）</li>
</ul>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <contributor>
      <name>南辞</name>
    </contributor>
    <published>2021-02-18T01:11:00.000Z</published>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">模块06—Java Web</title>
    <id>http://qiqi.dreamagain.top/interview/Java208/%E6%A8%A1%E5%9D%9706%E2%80%94Java%20Web/</id>
    <link href="http://qiqi.dreamagain.top/interview/Java208/%E6%A8%A1%E5%9D%9706%E2%80%94Java%20Web/"/>
    <updated>2021-02-18T01:11:00.000Z</updated>
    <content type="html"><![CDATA[<h2 id="问题"> 问题：</h2>
<p>64.jsp和servlet有什么区别?</p>
<p>65.jsp有哪些内置对象?作用分别是什么?</p>
<p>66.说一下jsp的4种作用域?</p>
<p>67.session和cookie有什么区别?</p>
<p>68.说一下 session的工作原理?</p>
<p>69.如果客户端禁止 cookie 能实现session 还能用吗?</p>
<p>70.spring mvc和struts 的区别是什么?</p>
<p>71.如何避免 sql注入?</p>
<p>72.什么是XSS攻击,如何避免?</p>
<p>73.什么是CSRF攻击，如何避免?</p>
<h2 id="答案"> 答案：</h2>
<h3 id="_64-jsp和servlet有什么区别"> 64.jsp和servlet有什么区别?</h3>
<ol>
<li>jsp经编译后就变成了Servlet.（JSP的本质就是Servlet，JVM只能识别java的类，不能识别JSP的代码，Web容器将JSP的代码编译成JVM能够识别的java类）</li>
<li>jsp更擅长表现于页面显示，servlet更擅长于逻辑控制。</li>
<li>Servlet中没有内置对象，Jsp中的内置对象都是必须通过HttpServletRequest对象，HttpServletResponse对象以及HttpServlet对象得到。</li>
<li>Jsp是Servlet的一种简化，使用Jsp只需要完成程序员需要输出到客户端的内容，Jsp中的Java脚本如何镶嵌到一个类中，由Jsp容器完成。而Servlet则是个完整的Java类，这个类的Service方法用于生成对客户端的响应。</li>
</ol>
<h3 id="_65-jsp有哪些内置对象-作用分别是什么"> 65.jsp有哪些内置对象?作用分别是什么?</h3>
<p>JSP有9个内置对象：</p>
<ul>
<li>request：封装客户端的请求，其中包含来自GET或POST请求的参数；</li>
<li>response：封装服务器对客户端的响应；</li>
<li>pageContext：通过该对象可以获取其他对象；</li>
<li>session：封装用户会话的对象；</li>
<li>application：封装服务器运行环境的对象；</li>
<li>out：输出服务器响应的输出流对象；</li>
<li>config：Web应用的配置对象；</li>
<li>page：JSP页面本身（相当于Java程序中的this）；</li>
<li>exception：封装页面抛出异常的对象。</li>
</ul>
<h3 id="_66-说一下jsp的4种作用域"> 66.说一下jsp的4种作用域?</h3>
<p>JSP中的四种作用域包括page、request、session和application，具体来说：</p>
<ul>
<li><strong>page</strong>代表与一个页面相关的对象和属性。</li>
<li><strong>request</strong>代表与Web客户机发出的一个请求相关的对象和属性。一个请求可能跨越多个页面，涉及多个Web组件；需要在页面显示的临时数据可以置于此作用域。</li>
<li><strong>session</strong>代表与某个用户与服务器建立的一次会话相关的对象和属性。跟某个用户相关的数据应该放在用户自己的session中。</li>
<li><strong>application</strong>代表与整个Web应用程序相关的对象和属性，它实质上是跨越整个Web应用程序，包括多个页面、请求和会话的一个全局作用域。</li>
</ul>
<h3 id="_67-session和cookie有什么区别"> 67.session和cookie有什么区别?</h3>
<ul>
<li>
<p>由于HTTP协议是无状态的协议，所以服务端需要记录用户的状态时，就需要用某种机制来识具体的用户，这个机制就是Session.典型的场景比如购物车，当你点击下单按钮时，由于HTTP协议无状态，所以并不知道是哪个用户操作的，所以服务端要为特定的用户创建了特定的Session，用于标识这个用户，并且跟踪用户，这样才知道购物车里面有几本书。这个Session是保存在服务端的，有一个唯一标识。在服务端保存Session的方法很多，内存、数据库、文件都有。集群的时候也要考虑Session的转移，在大型的网站，一般会有专门的Session服务器集群，用来保存用户会话，这个时候 Session 信息都是放在内存的，使用一些缓存服务比如Memcached之类的来放 Session。</p>
</li>
<li>
<p>思考一下服务端如何识别特定的客户？这个时候Cookie就登场了。每次HTTP请求的时候，客户端都会发送相应的Cookie信息到服务端。实际上大多数的应用都是用 Cookie 来实现Session跟踪的，第一次创建Session的时候，服务端会在HTTP协议中告诉客户端，需要在 Cookie 里面记录一个Session ID，以后每次请求把这个会话ID发送到服务器，我就知道你是谁了。有人问，如果客户端的浏览器禁用了 Cookie 怎么办？一般这种情况下，会使用一种叫做<strong>URL重写</strong>的技术来进行会话跟踪，即每次HTTP交互，URL后面都会被附加上一个诸如 <strong>sid=xxxxx 这样的参数</strong>，服务端据此来识别用户。</p>
</li>
<li>
<p>Cookie其实还可以用在一些方便用户的场景下，设想你某次登陆过一个网站，下次登录的时候不想再次输入账号了，怎么办？这个信息可以写到Cookie里面，访问网站的时候，网站页面的脚本可以读取这个信息，就自动帮你把用户名给填了，能够方便一下用户。这也是Cookie名称的由来，给用户的一点甜头。所以，总结一下：Session是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中；Cookie是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现Session的一种方式。</p>
</li>
</ul>
<h3 id="_68-说一下-session的工作原理"> 68.说一下 session的工作原理?</h3>
<p>其实session是一个存在服务器上的类似于一个散列表格的文件。里面存有我们需要的信息，在我们需要用的时候可以从里面取出来。</p>
<p>类似于一个大号的map吧，里面的键存储的是用户的sessionid，用户向服务器发送请求的时候会带上这个sessionid。这时就可以从中</p>
<p>取出对应的值了。</p>
<h3 id="_69-如果客户端禁止-cookie-能实现session-还能用吗"> 69.如果客户端禁止 cookie 能实现session 还能用吗?</h3>
<p>Cookie与 Session，一般认为是两个独立的东西，Session采用的是在服务器端保持状态的方案，而Cookie采用的是在客户端保持状态</p>
<p>的方案。但为什么禁用Cookie就不能得到Session呢？因为Session是用Session ID来确定当前对话所对应的服务器Session，而Session</p>
<p>ID是通过Cookie来传递的，禁用Cookie相当于失去了Session ID，也就得不到Session了。</p>
<p>假定用户关闭Cookie的情况下使用Session，其实现途径有以下几种：</p>
<ol>
<li>设置php.ini配置文件中的“session.use_trans_sid = 1”，或者编译时打开“--enable-trans-sid”选项，让PHP自动跨页传递Session ID。</li>
<li>手动通过URL传值、隐藏表单传递Session ID。</li>
<li>用文件、数据库等形式保存Session ID，在跨页过程中手动调用。</li>
</ol>
<h3 id="_70-springmvc和struts-的区别是什么"> 70.SpringMVC和struts 的区别是什么?</h3>
<ul>
<li><strong>拦截机制的不同</strong></li>
</ul>
<p>Struts2是类级别的拦截，每次请求就会创建一个Action，和Spring整合时Struts2的ActionBean注入作用域是原型模式prototype，然后通过setter，getter把request数据注入到属性。Struts2中，一个Action对应一个request，response上下文，在接收参数时，可以通过属性接收，这说明属性参数是让多个方法共享的。Struts2中Action的一个方法可以对应一个url，而其类属性却被所有方法共享，这也就无法用注解或其他方式标识其所属方法了，只能设计为多例。</p>
<p>SpringMVC是方法级别的拦截，一个方法对应一个Request上下文，所以方法直接基本上是独立的，独享request，response数据。而每个方法同时又和一个url对应，参数的传递是直接注入到方法中的，是方法所独有的。处理结果通过ModeMap返回给框架。在Spring整合时，SpringMVC的Controller Bean默认单例模式Singleton，所以默认对所有的请求，只会创建一个Controller，又因为没有共享的属性，所以是线程安全的，如果要改变默认的作用域，需要添加@Scope注解修改。</p>
<p>Struts2有自己的拦截Interceptor机制，SpringMVC这是用的是独立的AOP方式，这样导致Struts2的配置文件量还是比SpringMVC大。</p>
<ul>
<li><strong>底层框架的不同</strong></li>
</ul>
<p>Struts2采用Filter（StrutsPrepareAndExecuteFilter）实现，SpringMVC（DispatcherServlet）则采用Servlet实现。Filter在容器启动之后即初始化；服务停止以后销毁，晚于Servlet。Servlet在是在调用时初始化，先于Filter调用，服务停止后销毁。</p>
<ul>
<li>
<h3 id="性能方面"> <strong>性能方面</strong></h3>
</li>
</ul>
<p>Struts2是类级别的拦截，每次请求对应实例一个新的Action，需要加载所有的属性值注入，SpringMVC实现了零配置，由于SpringMVC基于方法的拦截，有加载一次单例模式bean注入。所以，SpringMVC开发效率和性能高于Struts2。</p>
<ul>
<li>
<h3 id="配置方面"> <strong>配置方面</strong></h3>
</li>
</ul>
<p>Spring MVC和Spring是无缝的。从这个项目的管理和安全上也比Struts2高。</p>
<h3 id="_71-如何避免-sql注入"> 71.如何避免 sql注入?</h3>
<ol>
<li>PreparedStatement（简单又有效的方法）</li>
<li>使用正则表达式过滤传入的参数</li>
<li>字符串过滤</li>
<li>JSP中调用该函数检查是否包函非法字符</li>
<li>JSP页面判断代码</li>
</ol>
<h3 id="_72-什么是xss攻击-如何避免"> 72.什么是XSS攻击,如何避免?</h3>
<p>XSS攻击又称CSS,全称Cross Site Script （跨站脚本攻击），其原理是攻击者向有XSS漏洞的网站中输入恶意的 HTML 代码，当用户浏览</p>
<p>该网站时，这段 HTML 代码会自动执行，从而达到攻击的目的。XSS 攻击类似于 SQL 注入攻击，SQL注入攻击中以SQL语句作为用户输</p>
<p>入，从而达到查询/修改/删除数据的目的，而在xss攻击中，通过插入恶意脚本，实现对用户游览器的控制，获取用户的一些信息。 XSS</p>
<p>是 Web 程序中常见的漏洞，XSS 属于被动式且用于客户端的攻击方式。</p>
<p>XSS防范的总体思路是：<strong>对输入(和URL参数)进行过滤，对输出进行编码</strong>。</p>
<h3 id="_73-什么是csrf攻击-如何避免"> 73.什么是CSRF攻击，如何避免?</h3>
<p>CSRF（Cross-site request forgery）也被称为 one-click attack或者 session riding，中文全称是叫<strong>跨站请求伪造</strong>。一般来说，攻击者通过伪造用户的浏览器的请求，向访问一个用户自己曾经认证访问过的网站发送出去，使目标网站接收并误以为是用户的真实操作而去执行命令。常用于盗取账号、转账、发送虚假消息等。攻击者利用网站对请求的验证漏洞而实现这样的攻击行为，网站能够确认请求来源于用户的浏览器，却不能验证请求是否源于用户的真实意愿下的操作行为。</p>
<p><strong>如何避免：</strong></p>
<ol>
<li>
<p>验证 HTTP Referer 字段</p>
<p>HTTP头中的Referer字段记录了该 HTTP 请求的来源地址。在通常情况下，访问一个安全受限页面的请求来自于同一个网站，而如果黑客要对其实施 CSRF攻击，他一般只能在他自己的网站构造请求。因此，可以通过验证Referer值来防御CSRF 攻击。</p>
</li>
<li>
<p>使用验证码</p>
<p>关键操作页面加上验证码，后台收到请求后通过判断验证码可以防御CSRF。但这种方法对用户不太友好。</p>
</li>
<li>
<p>在请求地址中添加token并验证</p>
<p>CSRF 攻击之所以能够成功，是因为黑客可以完全<strong>伪造用户的请求</strong>，该请求中所有的用户验证信息都是存在于cookie中，因此黑客可以在不知道这些验证信息的情况下直接利用用户自己的cookie 来通过安全验证。要抵御 CSRF，关键在于在请求中放入黑客所不能伪造的信息，并且该信息不存在于 cookie 之中。</p>
<p>可以在 HTTP 请求<strong>中以参数的形式加入一个随机产生的 token</strong>，并在服务器端建立一个拦截器来验证这个 token，如果请求中没有token或者 token 内容不正确，则认为可能是 CSRF 攻击而拒绝该请求。这种方法要比检查 Referer 要安全一些，token 可以在用户登陆后产生并放于session之中，然后在每次请求时把token 从 session 中拿出，与请求中的 token 进行比对，但这种方法的难点在于如何把 token 以参数的形式加入请求。
对于 GET 请求，token 将附在请求地址之后，这样 URL 就变成 http://url?csrftoken=tokenvalue。
而对于 POST 请求来说，要在 form 的最后加上 <input type="hidden" name="csrftoken" value="tokenvalue"/>，这样就把token以参数的形式加入请求了。</p>
</li>
<li>
<p>在HTTP 头中自定义属性并验证</p>
<p>这种方法也是使用 token 并进行验证，和上一种方法不同的是，这里并不是把 token 以参数的形式置于 HTTP 请求之中，而是把它放到 HTTP 头中自定义的属性里。</p>
<p>通过 XMLHttpRequest 这个类，可以一次性给所有该类请求加上 csrftoken 这个 HTTP 头属性，并把 token 值放入其中。这样解决了上种方法在请求中加入 token 的不便，同时，通过 XMLHttpRequest 请求的地址不会被记录到浏览器的地址栏，也不用担心 token 会透过 Referer 泄露到其他网站中去。</p>
</li>
</ol>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <contributor>
      <name>南辞</name>
    </contributor>
    <published>2021-02-18T01:11:00.000Z</published>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">模块07—Java异常</title>
    <id>http://qiqi.dreamagain.top/interview/Java208/%E6%A8%A1%E5%9D%9707%E2%80%94%E5%BC%82%E5%B8%B8/</id>
    <link href="http://qiqi.dreamagain.top/interview/Java208/%E6%A8%A1%E5%9D%9707%E2%80%94%E5%BC%82%E5%B8%B8/"/>
    <updated>2021-02-18T01:11:00.000Z</updated>
    <content type="html"><![CDATA[<h2 id="问题"> 问题：</h2>
<p>74.throw和throws 的区别?</p>
<p>75.final、finally、finalize有什么区别?</p>
<p>76.try-catch-finally 中哪个部分可以省略?</p>
<p>77.try-catch-finally中，如果catch 中 return 了, finally还会执行吗?</p>
<p>78.常见的异常类有哪些?</p>
<h2 id="答案"> 答案:</h2>
<h3 id="_74-throw和throws-的区别"> 74.throw和throws 的区别?</h3>
<p>throws是用来声明一个方法可能抛出的所有异常信息，throws是将异常声明但是不处理，而是将异常往上传，谁调用我就交给谁处</p>
<p>理。而throw则是指抛出的一个具体的异常类型。</p>
<h3 id="_75-final、finally、finalize有什么区别"> 75.final、finally、finalize有什么区别?</h3>
<ul>
<li>final可以修饰类、变量、方法，修饰类表示该类不能被继承、修饰方法表示该方法不能被重写、修饰变量表示该变量是一个常量不能被重新赋值。</li>
<li>finally一般作用在try-catch代码块中，在处理异常的时候，通常我们将一定要执行的代码方法finally代码块中，表示不管是否出现异常，该代码块都会执行，一般用来存放一些关闭资源的代码。</li>
<li>finalize是一个方法，属于Object类的一个方法，而Object类是所有类的父类，该方法一般由垃圾回收器来调用，当我们调用System的gc()方法的时候，由垃圾回收器调用finalize(),回收垃圾。</li>
</ul>
<h3 id="_76-try-catch-finally-中哪个部分可以省略"> 76.try-catch-finally 中哪个部分可以省略?</h3>
<p>catch 可以省略</p>
<p><strong>原因：</strong></p>
<p>更为严格的说法其实是：try只适合处理运行时异常，try+catch适合处理运行时异常+普通异常。也就是说，如果你只用try去处理普通异常却不加以catch处理，编译是通不过的，因为编译器硬性规定，普通异常如果选择捕获，则必须用catch显示声明以便进一步处理。而运行时异常在编译时没有如此规定，所以catch可以省略，你加上catch编译器也觉得无可厚非。</p>
<p>理论上，编译器看任何代码都不顺眼，都觉得可能有潜在的问题，所以你即使对所有代码加上try，代码在运行期时也只不过是在正常运行的基础上加一层皮。但是你一旦对一段代码加上try，就等于显示地承诺编译器，对这段代码可能抛出的异常进行捕获而非向上抛出处理。如果是普通异常，编译器要求必须用catch捕获以便进一步处理；如果运行时异常，捕获然后丢弃并且+finally扫尾处理，或者加上catch捕获以便进一步处理。</p>
<p>至于加上finally，则是在不管有没捕获异常，都要进行的“扫尾”处理。</p>
<h3 id="_77-try-catch-finally中-如果catch-中-return-了-finally还会执行吗"> 77.try-catch-finally中，如果catch 中 return 了, finally还会执行吗?</h3>
<p>会执行，在 return 前执行。</p>
<div><pre><code><span>/*
 * java面试题--如果catch里面有return语句，finally里面的代码还会执行吗？
 */</span>
<span>public</span> <span>class</span> <span>FinallyDemo2</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>getInt</span><span>(</span><span>)</span><span>)</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>static</span> <span>int</span> <span>getInt</span><span>(</span><span>)</span> <span>{</span>
        <span>int</span> a <span>=</span> <span>10</span><span>;</span>
        <span>try</span> <span>{</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>a <span>/</span> <span>0</span><span>)</span><span>;</span>
            a <span>=</span> <span>20</span><span>;</span>
        <span>}</span> <span>catch</span> <span>(</span><span>ArithmeticException</span> e<span>)</span> <span>{</span>
            a <span>=</span> <span>30</span><span>;</span>
            <span>return</span> a<span>;</span>
            <span>/*
             * return a 在程序执行到这一步的时候，这里不是return a 而是 return 30；这个返回路径就形成了
             * 但是呢，它发现后面还有finally，所以继续执行finally的内容，a=40
             * 再次回到以前的路径,继续走return 30，形成返回路径之后，这里的a就不是a变量了，而是常量30
             */</span>
        <span>}</span> <span>finally</span> <span>{</span>
            a <span>=</span> <span>40</span><span>;</span>
        <span>}</span>

<span>//      return a;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br></div></div><p>执行结果：30</p>
<p><strong>代码示例2：</strong></p>
<div><pre><code>
<span>package</span> <span>com<span>.</span>java_02</span><span>;</span>

<span>/*
 * java面试题--如果catch里面有return语句，finally里面的代码还会执行吗？
 */</span>
<span>public</span> <span>class</span> <span>FinallyDemo2</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>getInt</span><span>(</span><span>)</span><span>)</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>static</span> <span>int</span> <span>getInt</span><span>(</span><span>)</span> <span>{</span>
        <span>int</span> a <span>=</span> <span>10</span><span>;</span>
        <span>try</span> <span>{</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>a <span>/</span> <span>0</span><span>)</span><span>;</span>
            a <span>=</span> <span>20</span><span>;</span>
        <span>}</span> <span>catch</span> <span>(</span><span>ArithmeticException</span> e<span>)</span> <span>{</span>
            a <span>=</span> <span>30</span><span>;</span>
            <span>return</span> a<span>;</span>
            <span>/*
             * return a 在程序执行到这一步的时候，这里不是return a 而是 return 30；这个返回路径就形成了
             * 但是呢，它发现后面还有finally，所以继续执行finally的内容，a=40
             * 再次回到以前的路径,继续走return 30，形成返回路径之后，这里的a就不是a变量了，而是常量30
             */</span>
        <span>}</span> <span>finally</span> <span>{</span>
            a <span>=</span> <span>40</span><span>;</span>
            <span>return</span> a<span>;</span> <span>//如果这样，就又重新形成了一条返回路径，由于只能通过1个return返回，所以这里直接返回40</span>
        <span>}</span>

<span>//      return a;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br></div></div><p>执行结果：40</p>
<h3 id="_78-常见的异常类有哪些"> 78.常见的异常类有哪些?</h3>
<ul>
<li>NullPointerException：当应用程序试图访问空对象时，则抛出该异常。</li>
<li>SQLException：提供关于数据库访问错误或其他错误信息的异常。</li>
<li>IndexOutOfBoundsException：指示某排序索引（例如对数组、字符串或向量的排序）超出范围时抛出。</li>
<li>NumberFormatException：当应用程序试图将字符串转换成一种数值类型，但该字符串不能转换为适当格式时，抛出该异常。</li>
<li>FileNotFoundException：当试图打开指定路径名表示的文件失败时，抛出此异常。</li>
<li>IOException：当发生某种I/O异常时，抛出此异常。此类是失败或中断的I/O操作生成的异常的通用类。</li>
<li>ClassCastException：当试图将对象强制转换为不是实例的子类时，抛出该异常。</li>
<li>ArrayStoreException：试图将错误类型的对象存储到一个对象数组时抛出的异常。</li>
<li>IllegalArgumentException：抛出的异常表明向方法传递了一个不合法或不正确的参数。</li>
<li>ArithmeticException：当出现异常的运算条件时，抛出此异常。例如，一个整数“除以零”时，抛出此类的一个实例。</li>
<li>NegativeArraySizeException：如果应用程序试图创建大小为负的数组，则抛出该异常。</li>
<li>NoSuchMethodException：无法找到某一特定方法时，抛出该异常。</li>
<li>SecurityException：由安全管理器抛出的异常，指示存在安全侵犯。</li>
<li>UnsupportedOperationException：当不支持请求的操作时，抛出该异常。</li>
<li>RuntimeExceptionRuntimeException：是那些可能在Java虚拟机正常运行期间抛出的异常的超类。</li>
</ul>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <contributor>
      <name>南辞</name>
    </contributor>
    <published>2021-02-18T01:11:00.000Z</published>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">模块08—网络</title>
    <id>http://qiqi.dreamagain.top/interview/Java208/%E6%A8%A1%E5%9D%9708%E2%80%94%E7%BD%91%E7%BB%9C/</id>
    <link href="http://qiqi.dreamagain.top/interview/Java208/%E6%A8%A1%E5%9D%9708%E2%80%94%E7%BD%91%E7%BB%9C/"/>
    <updated>2021-02-18T01:11:00.000Z</updated>
    <content type="html"><![CDATA[<h2 id="问题"> 问题：</h2>
<p>79.http响应码301和302代表的是什么?有什么区别?</p>
<p>80.forward和redirect的区别?</p>
<p>81.简述tcp和udp的区别?</p>
<p>82.tcp为什么要三次握手，两次不行吗?为什么?</p>
<p>83.说一下 tcp粘包是怎么产生的?</p>
<p>84.OSl的七层模型都有哪些?</p>
<p>85.get和post请求有哪些区别?</p>
<p>86.如何实现跨域?</p>
<p>87.说一下JSONP 实现原理?</p>
<h2 id="答案"> 答案：</h2>
<h3 id="_79-http响应码301和302代表的是什么-有什么区别"> 79.http响应码301和302代表的是什么?有什么区别?</h3>
<p>301，302 都是HTTP状态的编码，都代表着某个URL发生了转移。</p>
<p><strong>区别：</strong></p>
<ul>
<li>
<p>301 redirect: 301 代表永久性转移(Permanently Moved)。</p>
</li>
<li>
<p>302 redirect: 302 代表暂时性转移(Temporarily Moved )。</p>
</li>
</ul>
<h3 id="_80-forward和redirect的区别"> 80.forward和redirect的区别?</h3>
<p>Forward和Redirect代表了两种请求转发方式：直接转发和间接转发。</p>
<p><strong>直接转发方式（Forward）</strong>，客户端和浏览器只发出一次请求，Servlet、HTML、JSP或其它信息资源，由第二个信息资源响应该请求，在请求对象request中，保存的对象对于每个信息资源是共享的。</p>
<p>**间接转发方式（Redirect）**实际是两次HTTP请求，服务器端在响应第一次请求的时候，让浏览器再向另外一个URL发出请求，从而达到转发的目的。</p>
<p><strong>举个通俗的例子：</strong></p>
<p>直接转发就相当于：“A找B借钱，B说没有，B去找C借，借到借不到都会把消息传递给A”；</p>
<p>间接转发就相当于：&quot;A找B借钱，B说没有，让A去找C借&quot;。</p>
<h3 id="_81-简述tcp和udp的区别"> 81.简述TCP和UDP的区别?</h3>
<ul>
<li>TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接。</li>
<li>TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付。</li>
<li>TCP通过校验和，重传控制，序号标识，滑动窗口、确认应答实现可靠传输。如丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。</li>
<li>UDP具有较好的实时性，工作效率比TCP高，适用于对高速传输和实时性有较高的通信或广播通信。</li>
<li>每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信。</li>
<li>TCP对系统资源要求较多，UDP对系统资源要求较少。</li>
</ul>
<h3 id="_82-tcp为什么要三次握手-两次不行吗-为什么"> 82.TCP为什么要三次握手，两次不行吗?为什么?</h3>
<p>为了实现可靠数据传输， TCP 协议的通信双方， 都必须维护一个序列号， 以标识发送出去的数据包中， 哪些是已经被对方收到的。</p>
<p>三次握手的过程即是通信双方相互告知序列号起始值， 并确认对方已经收到了序列号起始值的必经步骤。</p>
<p>如果只是两次握手， 至多只有连接发起方的起始序列号能被确认， 另一方选择的序列号则得不到确认。</p>
<h3 id="_83-说一下-tcp粘包是怎么产生的"> 83.说一下 TCP粘包是怎么产生的?</h3>
<p><strong>①. 发送方产生粘包</strong></p>
<p>采用TCP协议传输数据的客户端与服务器经常是保持一个长连接的状态（一次连接发一次数据不存在粘包），双方在连接不断开的情况下，可以一直传输数据；但当发送的数据包过于小的时候，那么TCP协议默认的会启用Nagle算法，将这些较小的数据包进行合并发送（缓冲区数据发送是一个堆压的过程）；这个合并过程就是在发送缓冲区中进行的，也就是说数据发送出来它已经是粘包的状态了。</p>
<blockquote>
<p><img src="./assets/image-20210110112812920.png" alt=""></p>
</blockquote>
<p><strong>②. 接收方产生粘包</strong></p>
<p>接收方采用TCP协议接收数据时的过程是这样的：数据到底接收方，从网络模型的下方传递至传输层，传输层的TCP协议处理是将其放置接收缓冲区，然后由应用层来主动获取（C语言用recv、read等函数）；这时会出现一个问题，就是我们在程序中调用的读取数据函数不能及时的把缓冲区中的数据拿出来，而下一个数据又到来并有一部分放入的缓冲区末尾，等我们读取数据时就是一个粘包。（放数据的速度 &gt; 应用层拿数据速度）</p>
<blockquote>
<p><img src="./assets/image-20210110113226253.png" alt=""></p>
</blockquote>
<h3 id="_84-osl的七层模型都有哪些"> 84.OSl的七层模型都有哪些?</h3>
<p><strong>物联网淑慧示用</strong></p>
<ol>
<li>应用层：网络服务与最终用户的一个接口。</li>
<li>表示层：数据的表示、安全、压缩。</li>
<li>会话层：建立、管理、终止会话。</li>
<li>传输层：定义传输数据的协议端口号，以及流控和差错校验。</li>
<li>网络层：进行逻辑地址寻址，实现不同网络之间的路径选择。</li>
<li>数据链路层：建立逻辑连接、进行硬件地址寻址、差错校验等功能。</li>
<li>物理层：建立、维护、断开物理连接。</li>
</ol>
<h3 id="_85-get和post请求有哪些区别"> 85.get和post请求有哪些区别?</h3>
<ul>
<li>GET在浏览器回退时是无害的，而POST会再次提交请求。</li>
<li>GET产生的URL地址可以被Bookmark，而POST不可以。</li>
<li>GET请求会被浏览器主动cache，而POST不会，除非手动设置。</li>
<li>GET请求只能进行url编码，而POST支持多种编码方式。</li>
<li>GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。</li>
<li>GET请求在URL中传送的参数是有长度限制的，而POST么有。</li>
<li>对参数的数据类型，GET只接受ASCII字符，而POST没有限制。</li>
<li>GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。</li>
<li>GET参数通过URL传递，POST放在Request body中。</li>
</ul>
<h3 id="_86-如何实现跨域"> 86.如何实现跨域?</h3>
<h4 id="方式一-图片ping或script标签跨域"> 方式一：图片ping或script标签跨域</h4>
<p><strong>图片ping</strong>常用于跟踪用户点击页面或动态广告曝光次数。 <strong>script标签</strong>可以得到从其他来源数据，这也是JSONP依赖的根据。</p>
<h4 id="方式二-jsonp跨域"> 方式二：JSONP跨域</h4>
<p>JSONP（JSON with Padding）是数据格式JSON的一种“使用模式”，可以让网页从别的网域要数据。根据 XmlHttpRequest 对象受到同源策略的影响，而利用 <code>&lt;script&gt;</code>元素的这个开放策略，网页可以得到从其他来源动态产生的JSON数据，而这种使用模式就是所谓的 JSONP。用JSONP抓到的数据并不是JSON，而是任意的JavaScript，用 JavaScript解释器运行而不是用JSON解析器解析。所有通过Chrome查看所有JSONP发送的Get请求都是js类型，而非XHR。</p>
<h4 id="方式三-cors"> 方式三：CORS</h4>
<p>Cross-Origin Resource Sharing（CORS）跨域资源共享是一份浏览器技术的规范，提供了 Web 服务从不同域传来沙盒脚本的方法，以避开浏览器的同源策略，确保安全的跨域数据传输。现代浏览器使用CORS在API容器如XMLHttpRequest来减少HTTP请求的风险来源。与 JSONP 不同，CORS 除了 GET 要求方法以外也支持其他的 HTTP 要求。服务器一般需要增加如下响应头的一种或几种：</p>
<div><pre><code>Access-Control-Allow-Origin: *
Access-Control-Allow-Methods: POST, GET, OPTIONS
Access-Control-Allow-Headers: X-PINGOTHER, Content-Type
Access-Control-Max-Age: 86400
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>跨域请求默认不会携带Cookie信息，如果需要携带，请配置下述参数：</p>
<div><pre><code>"Access-Control-Allow-Credentials": true
// Ajax设置
"withCredentials": true
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h4 id="方式四-window-name-iframe"> 方式四：window.name+iframe</h4>
<p><code>window.name</code>通过在iframe（一般动态创建）中加载跨域HTML文件来起作用。然后，HTML文件将传递给请求者的字符串内容赋值<code>window.name</code>。然后，请求者可以检索<code>window.name</code>值作为响应。</p>
<ul>
<li>iframe标签的跨域能力；</li>
<li><code>window.name</code>属性值在文档刷新后依旧存在的能力（且最大允许2M左右）。</li>
</ul>
<p>每个iframe都有包裹它的window，而这个window是top window的子窗口。contentWindow属性返回<code>&lt;iframe&gt;</code>元素的Window对象。你可以使用这个Window对象来访问iframe的文档及其内部DOM。</p>
<div><pre><code><span>&lt;!-- 
 下述用端口 
 10000表示：domainA
 10001表示：domainB
--></span>

<span>&lt;!-- localhost:10000 --></span>
<span><span><span>&lt;</span>script</span><span>></span></span><span><span>
  <span>var</span> iframe <span>=</span> document<span>.</span><span>createElement</span><span>(</span><span>'iframe'</span><span>)</span><span>;</span>
  iframe<span>.</span>style<span>.</span>display <span>=</span> <span>'none'</span><span>;</span> <span>// 隐藏</span>

  <span>var</span> state <span>=</span> <span>0</span><span>;</span> <span>// 防止页面无限刷新</span>
  iframe<span>.</span><span>onload</span> <span>=</span> <span>function</span><span>(</span><span>)</span> <span>{</span>
      <span>if</span><span>(</span>state <span>===</span> <span>1</span><span>)</span> <span>{</span>
          console<span>.</span><span>log</span><span>(</span><span>JSON</span><span>.</span><span>parse</span><span>(</span>iframe<span>.</span>contentWindow<span>.</span>name<span>)</span><span>)</span><span>;</span>
          <span>// 清除创建的iframe</span>
          iframe<span>.</span>contentWindow<span>.</span>document<span>.</span><span>write</span><span>(</span><span>''</span><span>)</span><span>;</span>
          iframe<span>.</span>contentWindow<span>.</span><span>close</span><span>(</span><span>)</span><span>;</span>
          document<span>.</span>body<span>.</span><span>removeChild</span><span>(</span>iframe<span>)</span><span>;</span>
      <span>}</span> <span>else</span> <span>if</span><span>(</span>state <span>===</span> <span>0</span><span>)</span> <span>{</span>
          state <span>=</span> <span>1</span><span>;</span>
          <span>// 加载完成，指向当前域，防止错误(proxy.html为空白页面)</span>
          <span>// Blocked a frame with origin "http://localhost:10000" from accessing a cross-origin frame.</span>
          iframe<span>.</span>contentWindow<span>.</span>location <span>=</span> <span>'http://localhost:10000/proxy.html'</span><span>;</span>
      <span>}</span>
  <span>}</span><span>;</span>

  iframe<span>.</span>src <span>=</span> <span>'http://localhost:10001'</span><span>;</span>
  document<span>.</span>body<span>.</span><span>appendChild</span><span>(</span>iframe<span>)</span><span>;</span>
</span></span><span><span><span>&lt;/</span>script</span><span>></span></span>

<span>&lt;!-- localhost:10001 --></span>
<span><span>&lt;!</span><span>DOCTYPE</span> <span>html</span><span>></span></span>
...
<span><span><span>&lt;</span>script</span><span>></span></span><span><span>
  window<span>.</span>name <span>=</span> <span>JSON</span><span>.</span><span>stringify</span><span>(</span><span>{</span>a<span>:</span> <span>1</span><span>,</span> b<span>:</span> <span>2</span><span>}</span><span>)</span><span>;</span>
</span></span><span><span><span>&lt;/</span>script</span><span>></span></span>
<span><span><span>&lt;/</span>html</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br></div></div><h4 id="方式五-window-postmessage"> 方式五：window.postMessage()</h4>
<p>HTML5新特性，可以用来向其他所有的 window 对象发送消息。需要注意的是我们必须要保证所有的脚本执行完才发送 MessageEvent，如果在函数执行的过程中调用了它，就会让后面的函数超时无法执行。</p>
<p>下述代码实现了跨域存储localStorage</p>
<div><pre><code><span>&lt;!-- 
 下述用端口 
 10000表示：domainA
 10001表示：domainB
--></span>

<span>&lt;!-- localhost:10000 --></span>
<span><span><span>&lt;</span>iframe</span> <span>src</span><span><span>=</span><span>"</span>http://localhost:10001/msg.html<span>"</span></span> <span>name</span><span><span>=</span><span>"</span>myPostMessage<span>"</span></span> <span><span>style</span><span><span>=</span><span>"</span><span><span>display</span><span>:</span>none<span>;</span></span><span>"</span></span></span><span>></span></span>
<span><span><span>&lt;/</span>iframe</span><span>></span></span>

<span><span><span>&lt;</span>script</span><span>></span></span><span><span>
  <span>function</span> <span>main</span><span>(</span><span>)</span> <span>{</span>
      <span>LSsetItem</span><span>(</span><span>'test'</span><span>,</span> <span>'Test: '</span> <span>+</span> <span>new</span> <span>Date</span><span>(</span><span>)</span><span>)</span><span>;</span>
      <span>LSgetItem</span><span>(</span><span>'test'</span><span>,</span> <span>function</span><span>(</span><span>value</span><span>)</span> <span>{</span>
          console<span>.</span><span>log</span><span>(</span><span>'value: '</span> <span>+</span> value<span>)</span><span>;</span>
      <span>}</span><span>)</span><span>;</span>
      <span>LSremoveItem</span><span>(</span><span>'test'</span><span>)</span><span>;</span>
  <span>}</span>

  <span>var</span> callbacks <span>=</span> <span>{</span><span>}</span><span>;</span>
  window<span>.</span><span>addEventListener</span><span>(</span><span>'message'</span><span>,</span> <span>function</span><span>(</span><span>event</span><span>)</span> <span>{</span>
      <span>if</span> <span>(</span>event<span>.</span>source <span>===</span> frames<span>[</span><span>'myPostMessage'</span><span>]</span><span>)</span> <span>{</span>
          console<span>.</span><span>log</span><span>(</span>event<span>)</span>
          <span>var</span> data <span>=</span> <span><span>/</span><span>^#localStorage#(\d+)(null)?#([\S\s]*)</span><span>/</span></span><span>.</span><span>exec</span><span>(</span>event<span>.</span>data<span>)</span><span>;</span>
          <span>if</span> <span>(</span>data<span>)</span> <span>{</span>
              <span>if</span> <span>(</span>callbacks<span>[</span>data<span>[</span><span>1</span><span>]</span><span>]</span><span>)</span> <span>{</span>
                  callbacks<span>[</span>data<span>[</span><span>1</span><span>]</span><span>]</span><span>(</span>data<span>[</span><span>2</span><span>]</span> <span>===</span> <span>'null'</span> <span>?</span> <span>null</span> <span>:</span> data<span>[</span><span>3</span><span>]</span><span>)</span><span>;</span>
              <span>}</span>
              <span>delete</span> callbacks<span>[</span>data<span>[</span><span>1</span><span>]</span><span>]</span><span>;</span>
          <span>}</span>
      <span>}</span>
  <span>}</span><span>,</span> <span>false</span><span>)</span><span>;</span>

  <span>var</span> domain <span>=</span> <span>'*'</span><span>;</span>
  <span>// 增加</span>
  <span>function</span> <span>LSsetItem</span><span>(</span><span>key<span>,</span> value</span><span>)</span> <span>{</span>
      <span>var</span> obj <span>=</span> <span>{</span>
          setItem<span>:</span> key<span>,</span>
          value<span>:</span> value
      <span>}</span><span>;</span>
      frames<span>[</span><span>'myPostMessage'</span><span>]</span><span>.</span><span>postMessage</span><span>(</span><span>JSON</span><span>.</span><span>stringify</span><span>(</span>obj<span>)</span><span>,</span> domain<span>)</span><span>;</span>
  <span>}</span>
  <span>// 获取</span>
  <span>function</span> <span>LSgetItem</span><span>(</span><span>key<span>,</span> callback</span><span>)</span> <span>{</span>
      <span>var</span> identifier <span>=</span> <span>new</span> <span>Date</span><span>(</span><span>)</span><span>.</span><span>getTime</span><span>(</span><span>)</span><span>;</span>
      <span>var</span> obj <span>=</span> <span>{</span>
          identifier<span>:</span> identifier<span>,</span>
          getItem<span>:</span> key
      <span>}</span><span>;</span>
      callbacks<span>[</span>identifier<span>]</span> <span>=</span> callback<span>;</span>
      frames<span>[</span><span>'myPostMessage'</span><span>]</span><span>.</span><span>postMessage</span><span>(</span><span>JSON</span><span>.</span><span>stringify</span><span>(</span>obj<span>)</span><span>,</span> domain<span>)</span><span>;</span>
  <span>}</span>
  <span>// 删除</span>
  <span>function</span> <span>LSremoveItem</span><span>(</span><span>key</span><span>)</span> <span>{</span>
      <span>var</span> obj <span>=</span> <span>{</span>
          removeItem<span>:</span> key
      <span>}</span><span>;</span>
      frames<span>[</span><span>'myPostMessage'</span><span>]</span><span>.</span><span>postMessage</span><span>(</span><span>JSON</span><span>.</span><span>stringify</span><span>(</span>obj<span>)</span><span>,</span> domain<span>)</span><span>;</span>
  <span>}</span>
</span></span><span><span><span>&lt;/</span>script</span><span>></span></span>

<span>&lt;!-- localhost:10001 --></span>
<span><span><span>&lt;</span>script</span><span>></span></span><span><span>
  window<span>.</span><span>addEventListener</span><span>(</span><span>'message'</span><span>,</span> <span>function</span><span>(</span><span>event</span><span>)</span> <span>{</span>
    console<span>.</span><span>log</span><span>(</span><span>'Receiver debugging'</span><span>,</span> event<span>)</span><span>;</span>
    <span>if</span> <span>(</span>event<span>.</span>origin <span>==</span> <span>'http://localhost:10000'</span><span>)</span> <span>{</span>
      <span>var</span> data <span>=</span> <span>JSON</span><span>.</span><span>parse</span><span>(</span>event<span>.</span>data<span>)</span><span>;</span>
      <span>if</span> <span>(</span><span>'setItem'</span> <span>in</span> data<span>)</span> <span>{</span>
        localStorage<span>.</span><span>setItem</span><span>(</span>data<span>.</span>setItem<span>,</span> data<span>.</span>value<span>)</span><span>;</span>
      <span>}</span> <span>else</span> <span>if</span> <span>(</span><span>'getItem'</span> <span>in</span> data<span>)</span> <span>{</span>
        <span>var</span> gotItem <span>=</span> localStorage<span>.</span><span>getItem</span><span>(</span>data<span>.</span>getItem<span>)</span><span>;</span>
        event<span>.</span>source<span>.</span><span>postMessage</span><span>(</span>
          <span>'#localStorage#'</span> <span>+</span> data<span>.</span>identifier <span>+</span>
          <span>(</span>gotItem <span>===</span> <span>null</span> <span>?</span> <span>'null#'</span> <span>:</span> <span>'#'</span> <span>+</span> gotItem<span>)</span><span>,</span>
          event<span>.</span>origin
        <span>)</span><span>;</span>
      <span>}</span> <span>else</span> <span>if</span> <span>(</span><span>'removeItem'</span> <span>in</span> data<span>)</span> <span>{</span>
        localStorage<span>.</span><span>removeItem</span><span>(</span>data<span>.</span>removeItem<span>)</span><span>;</span>
      <span>}</span>
    <span>}</span>
  <span>}</span><span>,</span> <span>false</span><span>)</span><span>;</span>
</span></span><span><span><span>&lt;/</span>script</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br></div></div><p>注意Safari一下，会报错：</p>
<p><strong>Blocked a frame with origin “http://localhost:10001” from accessing a frame with origin “http://localhost:10000“. Protocols, domains, and ports must match.</strong></p>
<p>避免该错误，可以在Safari浏览器中勾选开发菜单==&gt;停用跨域限制。或者只能使用服务器端转存的方式实现，因为Safari浏览器默认只支持CORS跨域请求。</p>
<h4 id="方式六-修改document-domain跨子域"> 方式六：修改document.domain跨子域</h4>
<p>前提条件：这两个域名必须属于同一个基础域名!而且所用的协议，端口都要一致，否则无法利用document.domain进行跨域，所以只能跨子域</p>
<p>在根域范围内，允许把domain属性的值设置为它的上一级域。例如，在”aaa.xxx.com”域内，可以把domain设置为 “xxx.com” 但不能设置为 “xxx.org” 或者”com”。</p>
<p>现在存在两个域名aaa.xxx.com和bbb.xxx.com。在aaa下嵌入bbb的页面，由于其document.name不一致，无法在aaa下操作bbb的js。可以在aaa和bbb下通过js将document.name = 'xxx.com';设置一致，来达到互相访问的作用。</p>
<h4 id="方式七-websocket"> 方式七：WebSocket</h4>
<p>WebSocket protocol 是HTML5一种新的协议。它实现了浏览器与服务器全双工通信，同时允许跨域通讯，是server push技术的一种很棒的实现。相关文章，请查看：WebSocket、WebSocket-SockJS</p>
<p>需要注意：WebSocket对象不支持DOM 2级事件侦听器，必须使用DOM 0级语法分别定义各个事件。</p>
<h4 id="方式八-代理"> 方式八：代理</h4>
<p>同源策略是针对浏览器端进行的限制，可以通过服务器端来解决该问题</p>
<p>DomainA客户端（浏览器） ==&gt; DomainA服务器 ==&gt; DomainB服务器 ==&gt; DomainA客户端（浏览器）</p>
<h3 id="_87-说一下jsonp-实现原理"> 87.说一下JSONP 实现原理?</h3>
<p>jsonp 即 json+padding，动态创建script标签，利用script标签的src属性可以获取任何域下的js脚本，通过这个特性(也可以说漏洞)，服务器端不在返回json格式，而是返回一段调用某个函数的js代码，在src中进行了调用，这样实现了跨域。</p>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <contributor>
      <name>南辞</name>
    </contributor>
    <published>2021-02-18T01:11:00.000Z</published>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">模块09—设计模式</title>
    <id>http://qiqi.dreamagain.top/interview/Java208/%E6%A8%A1%E5%9D%9709%E2%80%94%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <link href="http://qiqi.dreamagain.top/interview/Java208/%E6%A8%A1%E5%9D%9709%E2%80%94%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <updated>2021-02-18T01:11:00.000Z</updated>
    <content type="html"><![CDATA[<h2 id="问题"> 问题：</h2>
<p>88.说一下你熟悉的设计模式?</p>
<p>89.简单工厂和抽象工厂有什么区别?</p>
<h2 id="答案"> 答案：</h2>
<h3 id="_88-说一下你熟悉的设计模式"> 88.说一下你熟悉的设计模式?</h3>
<h4 id="_1、单例模式"> 1、单例模式</h4>
<p>简单点说，就是一个应用程序中，某个类的实例对象只有一个，你没有办法去new，因为构造器是被private修饰的，一般通过getInstance()的方法来获取它们的实例。</p>
<p>getInstance()的返回值是一个对象的引用，并不是一个新的实例，所以不要错误的理解成多个对象。单例模式实现起来也很容易，直接看demo吧</p>
<p><strong>① 懒汉式法（线程不安全）</strong></p>
<div><pre><code><span>public</span> <span>class</span> <span>Singleton</span> <span>{</span>

<span>private</span> <span>static</span> <span>Singleton</span> singleton<span>;</span>

<span>private</span> <span>Singleton</span><span>(</span><span>)</span> <span>{</span>
<span>}</span>

<span>public</span> <span>static</span> <span>Singleton</span> <span>getInstance</span><span>(</span><span>)</span> <span>{</span>
 <span>if</span> <span>(</span>singleton <span>==</span> <span>null</span><span>)</span> <span>{</span>
  singleton <span>=</span> <span>new</span> <span>Singleton</span><span>(</span><span>)</span><span>;</span>
 <span>}</span>
 <span>return</span> singleton<span>;</span>
<span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p><strong>② 懒汉式写法（线程安全）</strong></p>
<div><pre><code><span>public</span> <span>class</span> <span>Singleton</span> <span>{</span>  
   <span>private</span> <span>static</span> <span>Singleton</span> instance<span>;</span>  
   <span>private</span> <span>Singleton</span> <span>(</span><span>)</span><span>{</span><span>}</span>  
   <span>public</span> <span>static</span> <span>synchronized</span> <span>Singleton</span> <span>getInstance</span><span>(</span><span>)</span> <span>{</span>  
   <span>if</span> <span>(</span>instance <span>==</span> <span>null</span><span>)</span> <span>{</span>  
       instance <span>=</span> <span>new</span> <span>Singleton</span><span>(</span><span>)</span><span>;</span>  
   <span>}</span>  
   <span>return</span> instance<span>;</span>  
   <span>}</span>  
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p><strong>③ 饿汉式写法</strong></p>
<div><pre><code><span>public</span> <span>class</span> <span>Singleton</span> <span>{</span>  
 
    <span>private</span> <span>static</span> <span>Singleton</span> instance <span>=</span> <span>new</span> <span>Singleton</span><span>(</span><span>)</span><span>;</span>  
 
    <span>private</span> <span>Singleton</span> <span>(</span><span>)</span><span>{</span><span>}</span>  
  
    <span>public</span> <span>static</span> <span>Singleton</span> <span>getInstance</span><span>(</span><span>)</span> <span>{</span>  
  			<span>return</span> instance<span>;</span>  
   <span>}</span>  
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p><strong>④ 静态内部类</strong></p>
<div><pre><code><span>public</span> <span>class</span> <span>Singleton</span> <span>{</span>  
    <span>private</span> <span>Singleton</span> <span>(</span><span>)</span><span>{</span><span>}</span>  
  
    <span>private</span> <span>static</span> <span>class</span> <span>SingletonHolder</span> <span>{</span>  
   		<span>private</span> <span>static</span> <span>final</span> <span>Singleton</span> INSTANCE <span>=</span> <span>new</span> <span>Singleton</span><span>(</span><span>)</span><span>;</span>  
   <span>}</span>  
   
    <span>public</span> <span>static</span> <span>final</span> <span>Singleton</span> <span>getInstance</span><span>(</span><span>)</span> <span>{</span>  
        <span>return</span> <span>SingletonHolder</span><span>.</span>INSTANCE<span>;</span>  
   <span>}</span>  
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p><strong>⑤ 枚举</strong></p>
<div><pre><code><span>public</span> <span>enum</span> <span>Singleton</span> <span>{</span>  
   INSTANCE<span>;</span>  
   <span>public</span> <span>void</span> <span>whateverMethod</span><span>(</span><span>)</span> <span>{</span>  
   <span>}</span>  
<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>这种方式是Effective Java作者Josh Bloch 提倡的方式，它不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象，可谓是很坚强的壁垒啊，不过，个人认为由于1.5中才加入enum特性，用这种方式写不免让人感觉生疏。</p>
<p><strong>⑥ 双重校验锁</strong></p>
<div><pre><code><span>public</span> <span>class</span> <span>Singleton</span> <span>{</span>  
   <span>private</span> <span>volatile</span> <span>static</span> <span>Singleton</span> singleton<span>;</span>  
   <span>private</span> <span>Singleton</span> <span>(</span><span>)</span><span>{</span><span>}</span>  
   <span>public</span> <span>static</span> <span>Singleton</span> <span>getSingleton</span><span>(</span><span>)</span> <span>{</span>  
   <span>if</span> <span>(</span>singleton <span>==</span> <span>null</span><span>)</span> <span>{</span>  
       <span>synchronized</span> <span>(</span><span>Singleton</span><span>.</span><span>class</span><span>)</span> <span>{</span>  
       <span>if</span> <span>(</span>singleton <span>==</span> <span>null</span><span>)</span> <span>{</span>  
           singleton <span>=</span> <span>new</span> <span>Singleton</span><span>(</span><span>)</span><span>;</span>  
       <span>}</span>  
       <span>}</span>  
   <span>}</span>  
   <span>return</span> singleton<span>;</span>  
   <span>}</span>  
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p><strong>总结</strong>：我个人比较喜欢静态内部类写法和饿汉式写法，其实这两种写法能够应付绝大多数情况了。其他写法也可以选择，主要还是看业务需求吧。</p>
<h4 id="_2、观察者模式"> 2、观察者模式</h4>
<p>对象间一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。</p>
<p><img src="./assets/image-20210110121411458.png" alt="image-20210110121411458"></p>
<p>看不懂图的人端着小板凳到这里来，给你举个栗子：假设有三个人，小美（女，22），小王和小李。小美很漂亮，小王和小李是两个程</p>
<p>序猿，时刻关注着小美的一举一动。有一天，小美说了一句：“谁来陪我打游戏啊。”这句话被小王和小李听到了，结果乐坏了，蹭蹭</p>
<p>蹭，没一会儿，小王就冲到小美家门口了，在这里，小美是被观察者，小王和小李是观察者，被观察者发出一条信息，然后观察者们进</p>
<p>行相应的处理，看代码：</p>
<div><pre><code><span>public</span> <span>interface</span> <span>Person</span> <span>{</span>
   <span>//小王和小李通过这个接口可以接收到小美发过来的消息</span>
   <span>void</span> <span>getMessage</span><span>(</span><span>String</span> s<span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>这个接口相当于小王和小李的电话号码，小美发送通知的时候就会拨打getMessage这个电话，拨打电话就是调用接口，看不懂没关</p>
<p>系，先往下看</p>
<div><pre><code><span>public</span> <span>class</span> <span>LaoWang</span> <span>implements</span> <span>Person</span> <span>{</span>

   <span>private</span> <span>String</span> name <span>=</span> <span>"小王"</span><span>;</span>

   <span>public</span> <span>LaoWang</span><span>(</span><span>)</span> <span>{</span>
   <span>}</span>

   <span>@Override</span>
   <span>public</span> <span>void</span> <span>getMessage</span><span>(</span><span>String</span> s<span>)</span> <span>{</span>
       <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>name <span>+</span> <span>"接到了小美打过来的电话，电话内容是："</span> <span>+</span> s<span>)</span><span>;</span>
   <span>}</span>

<span>}</span>

<span>public</span> <span>class</span> <span>LaoLi</span> <span>implements</span> <span>Person</span> <span>{</span>

   <span>private</span> <span>String</span> name <span>=</span> <span>"小李"</span><span>;</span>

   <span>public</span> <span>LaoLi</span><span>(</span><span>)</span> <span>{</span>
   <span>}</span>

   <span>@Override</span>
   <span>public</span> <span>void</span> <span>getMessage</span><span>(</span><span>String</span> s<span>)</span> <span>{</span>
       <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>name <span>+</span> <span>"接到了小美打过来的电话，电话内容是：->"</span> <span>+</span> s<span>)</span><span>;</span>
   <span>}</span>

<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div><p>代码很简单，我们再看看小美的代码：</p>
<div><pre><code><span>public</span> <span>class</span> <span>XiaoMei</span> <span>{</span>
   <span>List</span><span><span>&lt;</span><span>Person</span><span>></span></span> list <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>Person</span><span>></span></span><span>(</span><span>)</span><span>;</span>
    <span>public</span> <span>XiaoMei</span><span>(</span><span>)</span><span>{</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>addPerson</span><span>(</span><span>Person</span> person<span>)</span><span>{</span>
        list<span>.</span><span>add</span><span>(</span>person<span>)</span><span>;</span>
    <span>}</span>

    <span>//遍历list，把自己的通知发送给所有暗恋自己的人</span>
    <span>public</span> <span>void</span> <span>notifyPerson</span><span>(</span><span>)</span> <span>{</span>
        <span>for</span><span>(</span><span>Person</span> person<span>:</span>list<span>)</span><span>{</span>
            person<span>.</span><span>getMessage</span><span>(</span><span>"你们过来吧，谁先过来谁就能陪我一起玩儿游戏!"</span><span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>我们写一个测试类来看一下结果对不对</p>
<div><pre><code><span>public</span> <span>class</span> <span>Test</span> <span>{</span>
   <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>

       <span>XiaoMei</span> xiao_mei <span>=</span> <span>new</span> <span>XiaoMei</span><span>(</span><span>)</span><span>;</span>
       <span>LaoWang</span> lao_wang <span>=</span> <span>new</span> <span>LaoWang</span><span>(</span><span>)</span><span>;</span>
       <span>LaoLi</span> lao_li <span>=</span> <span>new</span> <span>LaoLi</span><span>(</span><span>)</span><span>;</span>

       <span>//小王和小李在小美那里都注册了一下</span>
       xiao_mei<span>.</span><span>addPerson</span><span>(</span>lao_wang<span>)</span><span>;</span>
       xiao_mei<span>.</span><span>addPerson</span><span>(</span>lao_li<span>)</span><span>;</span>

       <span>//小美向小王和小李发送通知</span>
       xiao_mei<span>.</span><span>notifyPerson</span><span>(</span><span>)</span><span>;</span>
   <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><h4 id="_3、装饰者模式"> 3、装饰者模式</h4>
<p>对已有的业务逻辑进一步的封装，使其增加额外的功能，如Java中的IO流就使用了装饰者模式，用户在使用的时候，可以任意组装，达</p>
<p>到自己想要的效果。 举个栗子，我想吃三明治，首先我需要一根大大的香肠，我喜欢吃奶油，在香肠上面加一点奶油，再放一点蔬菜，</p>
<p>最后再用两片面包夹一下，很丰盛的一顿午饭，营养又健康。那我们应该怎么来写代码呢？ 首先，我们需要写一个Food类，让其他所</p>
<p>有食物都来继承这个类，看代码：</p>
<div><pre><code><span>public</span> <span>class</span> <span>Food</span> <span>{</span>

   <span>private</span> <span>String</span> food_name<span>;</span>

   <span>public</span> <span>Food</span><span>(</span><span>)</span> <span>{</span>
   <span>}</span>

   <span>public</span> <span>Food</span><span>(</span><span>String</span> food_name<span>)</span> <span>{</span>
       <span>this</span><span>.</span>food_name <span>=</span> food_name<span>;</span>
   <span>}</span>

   <span>public</span> <span>String</span> <span>make</span><span>(</span><span>)</span> <span>{</span>
       <span>return</span> food_name<span>;</span>
   <span>}</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>代码很简单，然后我们写几个子类继承它：</p>
<div><pre><code><span>//面包类</span>
<span>public</span> <span>class</span> <span>Bread</span> <span>extends</span> <span>Food</span> <span>{</span>

   <span>private</span> <span>Food</span> basic_food<span>;</span>

   <span>public</span> <span>Bread</span><span>(</span><span>Food</span> basic_food<span>)</span> <span>{</span>
       <span>this</span><span>.</span>basic_food <span>=</span> basic_food<span>;</span>
   <span>}</span>

   <span>public</span> <span>String</span> <span>make</span><span>(</span><span>)</span> <span>{</span>
       <span>return</span> basic_food<span>.</span><span>make</span><span>(</span><span>)</span><span>+</span><span>"+面包"</span><span>;</span>
   <span>}</span>
<span>}</span>

<span>//奶油类</span>
<span>public</span> <span>class</span> <span>Cream</span> <span>extends</span> <span>Food</span> <span>{</span>

   <span>private</span> <span>Food</span> basic_food<span>;</span>

   <span>public</span> <span>Cream</span><span>(</span><span>Food</span> basic_food<span>)</span> <span>{</span>
       <span>this</span><span>.</span>basic_food <span>=</span> basic_food<span>;</span>
   <span>}</span>

   <span>public</span> <span>String</span> <span>make</span><span>(</span><span>)</span> <span>{</span>
       <span>return</span> basic_food<span>.</span><span>make</span><span>(</span><span>)</span><span>+</span><span>"+奶油"</span><span>;</span>
   <span>}</span>
<span>}</span>

<span>//蔬菜类</span>
<span>public</span> <span>class</span> <span>Vegetable</span> <span>extends</span> <span>Food</span> <span>{</span>

   <span>private</span> <span>Food</span> basic_food<span>;</span>

   <span>public</span> <span>Vegetable</span><span>(</span><span>Food</span> basic_food<span>)</span> <span>{</span>
       <span>this</span><span>.</span>basic_food <span>=</span> basic_food<span>;</span>
   <span>}</span>

   <span>public</span> <span>String</span> <span>make</span><span>(</span><span>)</span> <span>{</span>
       <span>return</span> basic_food<span>.</span><span>make</span><span>(</span><span>)</span><span>+</span><span>"+蔬菜"</span><span>;</span>
   <span>}</span>

<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br></div></div><p>这几个类都是差不多的，构造方法传入一个Food类型的参数，然后在make方法中加入一些自己的逻辑，如果你还是看不懂为什么这么</p>
<p>写，不急，你看看我的Test类是怎么写的，一看你就明白了</p>
<div><pre><code><span>public</span> <span>class</span> <span>Test</span> <span>{</span>
   <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
       <span>Food</span> food <span>=</span> <span>new</span> <span>Bread</span><span>(</span><span>new</span> <span>Vegetable</span><span>(</span><span>new</span> <span>Cream</span><span>(</span><span>new</span> <span>Food</span><span>(</span><span>"香肠"</span><span>)</span><span>)</span><span>)</span><span>)</span><span>;</span>
       <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>food<span>.</span><span>make</span><span>(</span><span>)</span><span>)</span><span>;</span>
   <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>看到没有，一层一层封装，我们从里往外看：最里面我new了一个香肠，在香肠的外面我包裹了一层奶油，在奶油的外面我又加了一层</p>
<p>蔬菜，最外面我放的是面包，是不是很形象，哈哈~ 这个设计模式简直跟现实生活中一摸一样，看懂了吗？ 我们看看运行结果吧</p>
<p><img src="./assets/image-20210110122635076.png" alt="image-20210110122635076"></p>
<p>一个三明治就做好了～</p>
<h4 id="_4、适配器模式"> 4、适配器模式</h4>
<p>将两种完全不同的事物联系到一起，就像现实生活中的变压器。假设一个手机充电器需要的电压是20V，但是正常的电压是220V，这时</p>
<p>候就需要一个变压器，将220V的电压转换成20V的电压，这样，变压器就将20V的电压和手机联系起来了。</p>
<div><pre><code><span>public</span> <span>class</span> <span>Test</span> <span>{</span>
   <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
       <span>Phone</span> phone <span>=</span> <span>new</span> <span>Phone</span><span>(</span><span>)</span><span>;</span>
       <span>VoltageAdapter</span> adapter <span>=</span> <span>new</span> <span>VoltageAdapter</span><span>(</span><span>)</span><span>;</span>
       phone<span>.</span><span>setAdapter</span><span>(</span>adapter<span>)</span><span>;</span>
       phone<span>.</span><span>charge</span><span>(</span><span>)</span><span>;</span>
   <span>}</span>
<span>}</span>

<span>// 手机类</span>
<span>class</span> <span>Phone</span> <span>{</span>

   <span>public</span> <span>static</span> <span>final</span> <span>int</span> <span>V</span> <span>=</span> <span>220</span><span>;</span><span>// 正常电压220v，是一个常量</span>

   <span>private</span> <span>VoltageAdapter</span> adapter<span>;</span>

   <span>// 充电</span>
   <span>public</span> <span>void</span> <span>charge</span><span>(</span><span>)</span> <span>{</span>
       adapter<span>.</span><span>changeVoltage</span><span>(</span><span>)</span><span>;</span>
   <span>}</span>

   <span>public</span> <span>void</span> <span>setAdapter</span><span>(</span><span>VoltageAdapter</span> adapter<span>)</span> <span>{</span>
       <span>this</span><span>.</span>adapter <span>=</span> adapter<span>;</span>
   <span>}</span>
<span>}</span>

<span>// 变压器</span>
<span>class</span> <span>VoltageAdapter</span> <span>{</span>
   <span>// 改变电压的功能</span>
   <span>public</span> <span>void</span> <span>changeVoltage</span><span>(</span><span>)</span> <span>{</span>
       <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"正在充电..."</span><span>)</span><span>;</span>
       <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"原始电压："</span> <span>+</span> <span>Phone<span>.</span>V</span> <span>+</span> <span>"V"</span><span>)</span><span>;</span>
       <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"经过变压器转换之后的电压:"</span> <span>+</span> <span>(</span><span>Phone<span>.</span>V</span> <span>-</span> <span>200</span><span>)</span> <span>+</span> <span>"V"</span><span>)</span><span>;</span>
   <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br></div></div><p><img src="./assets/image-20210110123230431.png" alt="image-20210110123230431"></p>
<h4 id="_5、工厂模式"> 5、工厂模式</h4>
<p>**① 简单工厂模式：**一个抽象的接口，多个抽象接口的实现类，一个工厂类，用来实例化抽象的接口</p>
<div><pre><code><span>// 抽象产品类</span>
<span>abstract</span> <span>class</span> <span>Car</span> <span>{</span>
   <span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span><span>;</span>

   <span>public</span> <span>void</span> <span>stop</span><span>(</span><span>)</span><span>;</span>
<span>}</span>

<span>// 具体实现类</span>
<span>class</span> <span>Benz</span> <span>implements</span> <span>Car</span> <span>{</span>
   <span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span> <span>{</span>
       <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"Benz开始启动了。。。。。"</span><span>)</span><span>;</span>
   <span>}</span>

   <span>public</span> <span>void</span> <span>stop</span><span>(</span><span>)</span> <span>{</span>
       <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"Benz停车了。。。。。"</span><span>)</span><span>;</span>
   <span>}</span>
<span>}</span>

<span>class</span> <span>Ford</span> <span>implements</span> <span>Car</span> <span>{</span>
   <span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span> <span>{</span>
       <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"Ford开始启动了。。。"</span><span>)</span><span>;</span>
   <span>}</span>

   <span>public</span> <span>void</span> <span>stop</span><span>(</span><span>)</span> <span>{</span>
       <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"Ford停车了。。。。"</span><span>)</span><span>;</span>
   <span>}</span>
<span>}</span>

<span>// 工厂类</span>
<span>class</span> <span>Factory</span> <span>{</span>
   <span>public</span> <span>static</span> <span>Car</span> <span>getCarInstance</span><span>(</span><span>String</span> type<span>)</span> <span>{</span>
       <span>Car</span> c <span>=</span> <span>null</span><span>;</span>
       <span>if</span> <span>(</span><span>"Benz"</span><span>.</span><span>equals</span><span>(</span>type<span>)</span><span>)</span> <span>{</span>
           c <span>=</span> <span>new</span> <span>Benz</span><span>(</span><span>)</span><span>;</span>
       <span>}</span>
       <span>if</span> <span>(</span><span>"Ford"</span><span>.</span><span>equals</span><span>(</span>type<span>)</span><span>)</span> <span>{</span>
           c <span>=</span> <span>new</span> <span>Ford</span><span>(</span><span>)</span><span>;</span>
       <span>}</span>
       <span>return</span> c<span>;</span>
   <span>}</span>
<span>}</span>

<span>public</span> <span>class</span> <span>Test</span> <span>{</span>

   <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
       <span>Car</span> c <span>=</span> <span>Factory</span><span>.</span><span>getCarInstance</span><span>(</span><span>"Benz"</span><span>)</span><span>;</span>
       <span>if</span> <span>(</span>c <span>!=</span> <span>null</span><span>)</span> <span>{</span>
           c<span>.</span><span>run</span><span>(</span><span>)</span><span>;</span>
           c<span>.</span><span>stop</span><span>(</span><span>)</span><span>;</span>
       <span>}</span> <span>else</span> <span>{</span>
           <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"造不了这种汽车。。。"</span><span>)</span><span>;</span>
       <span>}</span>

   <span>}</span>

<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br></div></div><p>**② 工厂方法模式：**有四个角色，抽象工厂模式，具体工厂模式，抽象产品模式，具体产品模式。不再是由一个工厂类去实例化</p>
<p>具体的产品，而是由抽象工厂的子类去实例化产品</p>
<div><pre><code><span>// 抽象产品角色</span>
<span>public</span> <span>interface</span> <span>Moveable</span> <span>{</span>
   <span>void</span> <span>run</span><span>(</span><span>)</span><span>;</span>
<span>}</span>

<span>// 具体产品角色</span>
<span>public</span> <span>class</span> <span>Plane</span> <span>implements</span> <span>Moveable</span> <span>{</span>
   <span>@Override</span>
   <span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span> <span>{</span>
       <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"plane...."</span><span>)</span><span>;</span>
   <span>}</span>
<span>}</span>

<span>public</span> <span>class</span> <span>Broom</span> <span>implements</span> <span>Moveable</span> <span>{</span>
   <span>@Override</span>
   <span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span> <span>{</span>
       <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"broom....."</span><span>)</span><span>;</span>
   <span>}</span>
<span>}</span>

<span>// 抽象工厂</span>
<span>public</span> <span>abstract</span> <span>class</span> <span>VehicleFactory</span> <span>{</span>
   <span>abstract</span> <span>Moveable</span> <span>create</span><span>(</span><span>)</span><span>;</span>
<span>}</span>

<span>// 具体工厂</span>
<span>public</span> <span>class</span> <span>PlaneFactory</span> <span>extends</span> <span>VehicleFactory</span> <span>{</span>
   <span>public</span> <span>Moveable</span> <span>create</span><span>(</span><span>)</span> <span>{</span>
       <span>return</span> <span>new</span> <span>Plane</span><span>(</span><span>)</span><span>;</span>
   <span>}</span>
<span>}</span>

<span>public</span> <span>class</span> <span>BroomFactory</span> <span>extends</span> <span>VehicleFactory</span> <span>{</span>
   <span>public</span> <span>Moveable</span> <span>create</span><span>(</span><span>)</span> <span>{</span>
       <span>return</span> <span>new</span> <span>Broom</span><span>(</span><span>)</span><span>;</span>
   <span>}</span>
<span>}</span>

<span>// 测试类</span>
<span>public</span> <span>class</span> <span>Test</span> <span>{</span>
   <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
       <span>VehicleFactory</span> factory <span>=</span> <span>new</span> <span>BroomFactory</span><span>(</span><span>)</span><span>;</span>
       <span>Moveable</span> m <span>=</span> factory<span>.</span><span>create</span><span>(</span><span>)</span><span>;</span>
       m<span>.</span><span>run</span><span>(</span><span>)</span><span>;</span>
   <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br></div></div><p>**③ 抽象工厂模式：**与工厂方法模式不同的是，工厂方法模式中的工厂只生产单一的产品，而抽象工厂模式中的工厂生产多个产</p>
<p>品</p>
<div><pre><code><span>//抽象工厂类</span>
<span>public</span> <span>abstract</span> <span>class</span> <span>AbstractFactory</span> <span>{</span>
   <span>public</span> <span>abstract</span> <span>Vehicle</span> <span>createVehicle</span><span>(</span><span>)</span><span>;</span>
   <span>public</span> <span>abstract</span> <span>Weapon</span> <span>createWeapon</span><span>(</span><span>)</span><span>;</span>
   <span>public</span> <span>abstract</span> <span>Food</span> <span>createFood</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
<span>//具体工厂类，其中Food,Vehicle，Weapon是抽象类，</span>
<span>public</span> <span>class</span> <span>DefaultFactory</span> <span>extends</span> <span>AbstractFactory</span><span>{</span>
   <span>@Override</span>
   <span>public</span> <span>Food</span> <span>createFood</span><span>(</span><span>)</span> <span>{</span>
       <span>return</span> <span>new</span> <span>Apple</span><span>(</span><span>)</span><span>;</span>
   <span>}</span>
   <span>@Override</span>
   <span>public</span> <span>Vehicle</span> <span>createVehicle</span><span>(</span><span>)</span> <span>{</span>
       <span>return</span> <span>new</span> <span>Car</span><span>(</span><span>)</span><span>;</span>
   <span>}</span>
   <span>@Override</span>
   <span>public</span> <span>Weapon</span> <span>createWeapon</span><span>(</span><span>)</span> <span>{</span>
       <span>return</span> <span>new</span> <span>AK47</span><span>(</span><span>)</span><span>;</span>
   <span>}</span>
<span>}</span>
<span>//测试类</span>
<span>public</span> <span>class</span> <span>Test</span> <span>{</span>
   <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
       <span>AbstractFactory</span> f <span>=</span> <span>new</span> <span>DefaultFactory</span><span>(</span><span>)</span><span>;</span>
       <span>Vehicle</span> v <span>=</span> f<span>.</span><span>createVehicle</span><span>(</span><span>)</span><span>;</span>
       v<span>.</span><span>run</span><span>(</span><span>)</span><span>;</span>
       <span>Weapon</span> w <span>=</span> f<span>.</span><span>createWeapon</span><span>(</span><span>)</span><span>;</span>
       w<span>.</span><span>shoot</span><span>(</span><span>)</span><span>;</span>
       <span>Food</span> a <span>=</span> f<span>.</span><span>createFood</span><span>(</span><span>)</span><span>;</span>
       a<span>.</span><span>printName</span><span>(</span><span>)</span><span>;</span>
   <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br></div></div><h4 id="_6、代理模式-proxy"> 6、代理模式（proxy）</h4>
<p>代理模式有两种，静态代理和动态代理。</p>
<p><strong>静态代理：</strong></p>
<p>到了一定的年龄，我们就要结婚，结婚是一件很麻烦的事情，（包括那些被父母催婚的）。有钱的家庭可能会找司仪来主持婚礼，显得</p>
<p>热闹，洋气～好了，现在婚庆公司的生意来了，我们只需要给钱，婚庆公司就会帮我们安排一整套结婚的流程。整个流程大概是这样</p>
<p>的：家里人催婚-&gt;男女双方家庭商定结婚的黄道即日-&gt;找一家靠谱的婚庆公司-&gt;在约定的时间举行结婚仪式-&gt;结婚完毕</p>
<p>婚庆公司打算怎么安排婚礼的节目，在婚礼完毕以后婚庆公司会做什么，我们一概不知。。。别担心，不是黑中介，我们只要把钱给人</p>
<p>家，人家会把事情给我们做好。所以，这里的婚庆公司相当于代理角色，现在明白什么是代理角色了吧。</p>
<p>代理接口代码：</p>
<div><pre><code><span>//代理接口</span>
<span>public</span> <span>interface</span> <span>ProxyInterface</span> <span>{</span>
<span>//需要代理的是结婚这件事，如果还有其他事情需要代理，比如吃饭睡觉上厕所，也可以写</span>
<span>void</span> <span>marry</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>婚庆公司的代码:</p>
<div><pre><code><span>public</span> <span>class</span> <span>WeddingCompany</span> <span>implements</span> <span>ProxyInterface</span> <span>{</span>

<span>private</span> <span>ProxyInterface</span> proxyInterface<span>;</span>

<span>public</span> <span>WeddingCompany</span><span>(</span><span>ProxyInterface</span> proxyInterface<span>)</span> <span>{</span>
 <span>this</span><span>.</span>proxyInterface <span>=</span> proxyInterface<span>;</span>
<span>}</span>

<span>@Override</span>
<span>public</span> <span>void</span> <span>marry</span><span>(</span><span>)</span> <span>{</span>
 <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"我们是婚庆公司的"</span><span>)</span><span>;</span>
 <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"我们在做结婚前的准备工作"</span><span>)</span><span>;</span>
 <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"节目彩排..."</span><span>)</span><span>;</span>
 <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"礼物购买..."</span><span>)</span><span>;</span>
 <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"工作人员分工..."</span><span>)</span><span>;</span>
 <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"可以开始结婚了"</span><span>)</span><span>;</span>
 proxyInterface<span>.</span><span>marry</span><span>(</span><span>)</span><span>;</span>
 <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"结婚完毕，我们需要做后续处理，你们可以回家了，其余的事情我们公司来做"</span><span>)</span><span>;</span>
<span>}</span>

<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><p>看到没有，婚庆公司需要做的事情很多，我们再看看结婚家庭的代码:</p>
<div><pre><code><span>public</span> <span>class</span> <span>NormalHome</span> <span>implements</span> <span>ProxyInterface</span><span>{</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>marry</span><span>(</span><span>)</span> <span>{</span>
     	<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"我们结婚啦～"</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>这个已经很明显了，结婚家庭只需要结婚，而婚庆公司要包揽一切，前前后后的事情都是婚庆公司来做，听说现在婚庆公司很赚钱的，</p>
<p>这就是原因，干的活多，能不赚钱吗？</p>
<p>来看看测试类代码：</p>
<div><pre><code><span>public</span> <span>class</span> <span>Test</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
         <span>ProxyInterface</span> proxyInterface <span>=</span> <span>new</span> <span>WeddingCompany</span><span>(</span><span>new</span> <span>NormalHome</span><span>(</span><span>)</span><span>)</span><span>;</span>
         proxyInterface<span>.</span><span>marry</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p><img src="./assets/image-20210110124934337.png" alt="image-20210110124934337"></p>
<blockquote>
<h3 id="_89-简单工厂和抽象工厂有什么区别"> 89.简单工厂和抽象工厂有什么区别?</h3>
</blockquote>
<p><strong>简单工厂模式</strong>：</p>
<p>这个模式本身很简单而且使用在业务较简单的情况下。一般用于小项目或者具体产品很少扩展的情况（这样工厂类才不用经常更改）。</p>
<p>它由三种角色组成：</p>
<ul>
<li>工厂类角色：这是本模式的核心，含有一定的商业逻辑和判断逻辑，根据逻辑不同，产生具体的工厂产品。如例子中的Driver类。</li>
<li>抽象产品角色：它一般是具体产品继承的父类或者实现的接口。由接口或者抽象类来实现。如例中的Car接口。</li>
<li>具体产品角色：工厂类所创建的对象就是此角色的实例。在java中由一个具体类实现，如例子中的Benz、Bmw类。</li>
</ul>
<p>用类图来清晰的表示下的它们之间的关系：</p>
<p><img src="./assets/image-20210110125152216.png" alt="image-20210110125152216"></p>
<p><strong>抽象工厂模式：</strong></p>
<p>先来认识下什么是产品族： 位于不同产品等级结构中，功能相关联的产品组成的家族。</p>
<p><img src="./assets/image-20210110125238563.png" alt="image-20210110125238563"></p>
<p>图中的BmwCar和BenzCar就是两个产品树（产品层次结构）；而如图所示的BenzSportsCar和BmwSportsCar就是一个产品族。他们都可以放到跑车家族中，因此功能有所关联。同理BmwBussinessCar和BenzBusinessCar也是一个产品族。</p>
<p><strong>可以这么说，它和工厂方法模式的区别就在于需要创建对象的复杂程度上。而且抽象工厂模式是三个里面最为抽象、最具一般性的。抽象工厂模式的用意为：给客户端提供一个接口，可以创建多个产品族中的产品对象。</strong></p>
<p>而且使用抽象工厂模式还要满足一下条件：</p>
<ol>
<li>系统中有多个产品族，而系统一次只可能消费其中一族产品</li>
<li>同属于同一个产品族的产品以其使用。</li>
</ol>
<p>来看看抽象工厂模式的各个角色（和工厂方法的如出一辙）：</p>
<ul>
<li>抽象工厂角色： 这是工厂方法模式的核心，它与应用程序无关。是具体工厂角色必须实现的接口或者必须继承的父类。在java中它由抽象类或者接口来实现。</li>
<li>具体工厂角色：它含有和具体业务逻辑有关的代码。由应用程序调用以创建对应的具体产品的对象。在java中它由具体的类来实现。</li>
<li>抽象产品角色：它是具体产品继承的父类或者是实现的接口。在java中一般有抽象类或者接口来实现。</li>
<li>具体产品角色：具体工厂角色所创建的对象就是此角色的实例。在java中由具体的类来实现。</li>
</ul>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <contributor>
      <name>南辞</name>
    </contributor>
    <published>2021-02-18T01:11:00.000Z</published>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">模块10—Spring/Spring MVC</title>
    <id>http://qiqi.dreamagain.top/interview/Java208/%E6%A8%A1%E5%9D%9710%E2%80%94SpringSpring%20MVC/</id>
    <link href="http://qiqi.dreamagain.top/interview/Java208/%E6%A8%A1%E5%9D%9710%E2%80%94SpringSpring%20MVC/"/>
    <updated>2021-02-18T01:11:00.000Z</updated>
    <content type="html"><![CDATA[<h2 id="问题"> 问题：</h2>
<p>90.为什么要使用Spring?</p>
<p>91.解释一下什么是AOP?</p>
<p>92.解释一下什么是IoC?</p>
<p>93.Spring有哪些主要模块?</p>
<p>94.Spring 常用的注入方式有哪些?</p>
<p>95.Spring 中的 bean是线程安全的吗?</p>
<p>96.Spring支持几种bean的作用域?</p>
<p>97.Spring自动装配bean有哪些方式?</p>
<p>98.Spring事务实现方式有哪些?</p>
<p>99.说一下Spring 的事务隔离?</p>
<p>100.说一下Spring MVC运行流程?</p>
<p>101.Spring MVC有哪些组件?</p>
<p>102.@RequestMapping 的作用是什么?</p>
<p>103.@Autowired的作用是什么?</p>
<h2 id="答案"> 答案：</h2>
<h3 id="_90-为什么要使用spring"> 90.为什么要使用Spring?</h3>
<p><strong>1.简介</strong></p>
<ul>
<li>目的：解决企业应用开发的复杂性</li>
<li>功能：使用基本的JavaBean代替EJB，并提供了更多的企业应用功能</li>
<li>范围：任何Java应用</li>
</ul>
<p>简单来说，Spring是一个轻量级的控制反转(IoC)和面向切面(AOP)的容器框架。</p>
<p><strong>2.轻量</strong></p>
<p>从大小与开销两方面而言Spring都是轻量的。完整的Spring框架可以在一个大小只有1MB多的 jar文件里发布。并且Spring所需的处理</p>
<p>开销也是微不足道的。此外，Spring是非侵入式的：典型地，Spring应用中的对象不依赖于Spring的特定类。</p>
<p><strong>3.控制反转</strong></p>
<p>Spring通过一种称作控制反转（IoC）的技术促进了松耦合。当应用了IoC，一个对象依赖的其它对象会通过被动的方式传递进来，而不</p>
<p>是这个对象自己创建或者查找依赖对象。你可以认为IoC与JNDI相反——不是对象从容器中查找依赖，而是容器在对象初始化时不等对</p>
<p>象请求就主动将依赖传递给它。</p>
<p><strong>4.面向切面</strong></p>
<p>Spring提供了面向切面编程的丰富支持，允许通过分离应用的业务逻辑与系统级服务（例如审计（auditing）和事务（transaction）管</p>
<p>理）进行内聚性的开发。应用对象只实现它们应该做的——完成业务逻辑——仅此而已。它们并不负责（甚至是意识）其它的系统级关</p>
<p>注点，例如日志或事务支持。</p>
<p><strong>5.容器</strong></p>
<p>Spring包含并管理应用对象的配置和生命周期，在这个意义上它是一种容器，你可以配置你的每个bean如何被创建——基于一个可配置</p>
<p>原型（prototype），你的bean可以创建一个单独的实例或者每次需要时都生成一个新的实例——以及它们是如何相互关联的。然而，</p>
<p>Spring不应该被混同于传统的重量级的EJB容器，它们经常是庞大与笨重的，难以使用。</p>
<p><strong>6.框架</strong></p>
<p>Spring可以将简单的组件配置、组合成为复杂的应用。在Spring中，应用对象被声明式地组合，典型地是在一个XML文件里。Spring也</p>
<p>提供了很多基础功能（事务管理、持久化框架集成等等），将应用逻辑的开发留给了你。所有Spring的这些特征使你能够编写更干净、</p>
<p>更可管理、并且更易于测试的代码。它们也为Spring中的各种模块提供了基础支持。</p>
<h3 id="_91-解释一下什么是aop"> 91.解释一下什么是AOP?</h3>
<p>AOP（Aspect-Oriented Programming，面向方面编程），可以说是OOP（Object-Oriented Programing，面向对象编程）的补充和完善。OOP引入封装、继承和多态性等概念来建立一种对象层次结构，用以模拟公共行为的一个集合。当我们需要为分散的对象引入公共行为的时候，OOP则显得无能为力。也就是说，OOP允许你定义从上到下的关系，但并不适合定义从左到右的关系。例如日志功能。日志代码往往水平地散布在所有对象层次中，而与它所散布到的对象的核心功能毫无关系。对于其他类型的代码，如安全性、异常处理和透明的持续性也是如此。这种散布在各处的无关的代码被称为横切（cross-cutting）代码，在OOP设计中，它导致了大量代码的重复，而不利于各个模块的重用。</p>
<p>而AOP技术则恰恰相反，它利用一种称为“横切”的技术，剖解开封装的对象内部，并将那些影响了多个类的公共行为封装到一个可重用模块，并将其名为“Aspect”，即方面。所谓“方面”，简单地说，就是将那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可操作性和可维护性。AOP代表的是一个横向的关系，如果说“对象”是一个空心的圆柱体，其中封装的是对象的属性和行为；那么面向方面编程的方法，就仿佛一把利刃，将这些空心圆柱体剖开，以获得其内部的消息。而剖开的切面，也就是所谓的“方面”了。然后它又以巧夺天功的妙手将这些剖开的切面复原，不留痕迹。</p>
<p>使用“横切”技术，AOP把软件系统分为两个部分：核心关注点和横切关注点。业务处理的主要流程是核心关注点，与之关系不大的部分是横切关注点。横切关注点的一个特点是，他们经常发生在核心关注点的多处，而各处都基本相似。比如权限认证、日志、事务处理。Aop 的作用在于分离系统中的各种关注点，将核心关注点和横切关注点分离开来。正如Avanade公司的高级方案构架师Adam Magee所说，AOP的核心思想就是“将应用程序中的商业逻辑同对其提供支持的通用服务进行分离。”</p>
<h3 id="_92-解释一下什么是ioc"> 92.解释一下什么是IoC?</h3>
<p>IOC是Inversion of Control的缩写，多数书籍翻译成“控制反转”。</p>
<p>1996年，Michael Mattson在一篇有关探讨面向对象框架的文章中，首先提出了IOC 这个概念。对于面向对象设计及编程的基本思想，前面我们已经讲了很多了，不再赘述，简单来说就是把复杂系统分解成相互合作的对象，这些对象类通过封装以后，内部实现对外部是透明的，从而降低了解决问题的复杂度，而且可以灵活地被重用和扩展。</p>
<p>IOC理论提出的观点大体是这样的：借助于“第三方”实现具有依赖关系的对象之间的解耦。如下图：</p>
<p><img src="./assets/java-05.png" alt=""></p>
<p>大家看到了吧，由于引进了中间位置的“第三方”，也就是IOC容器，使得A、B、C、D这4个对象没有了耦合关系，齿轮之间的传动全部依靠“第三方”了，全部对象的控制权全部上缴给“第三方”IOC容器，所以，IOC容器成了整个系统的关键核心，它起到了一种类似“粘合剂”的作用，把系统中的所有对象粘合在一起发挥作用，如果没有这个“粘合剂”，对象与对象之间会彼此失去联系，这就是有人把IOC容器比喻成“粘合剂”的由来。</p>
<p>我们再来做个试验：把上图中间的IOC容器拿掉，然后再来看看这套系统：</p>
<p><img src="./assets/java-06.png" alt=""></p>
<p>我们现在看到的画面，就是我们要实现整个系统所需要完成的全部内容。这时候，A、B、C、D这4个对象之间已经没有了耦合关系，彼</p>
<p>此毫无联系，这样的话，当你在实现A的时候，根本无须再去考虑B、C和D了，对象之间的依赖关系已经降低到了最低程度。所以，如</p>
<p>果真能实现IOC容器，对于系统开发而言，这将是一件多么美好的事情，参与开发的每一成员只要实现自己的类就可以了，跟别人没有</p>
<p>任何关系！</p>
<p><strong>我们再来看看，控制反转(IOC)到底为什么要起这么个名字？我们来对比一下：</strong></p>
<p>软件系统在没有引入IOC容器之前，如图1所示，对象A依赖于对象B，那么对象A在初始化或者运行到某一点的时候，自己必须主动去创建对象B或者使用已经创建的对象B。无论是创建还是使用对象B，控制权都在自己手上。</p>
<p>软件系统在引入IOC容器之后，这种情形就完全改变了，如图3所示，由于IOC容器的加入，对象A与对象B之间失去了直接联系，所以，当对象A运行到需要对象B的时候，IOC容器会主动创建一个对象B注入到对象A需要的地方。</p>
<p>通过前后的对比，我们不难看出来：对象A获得依赖对象B的过程,由主动行为变为了被动行为，控制权颠倒过来了，这就是“控制反转”这个名称的由来。</p>
<h3 id="_93-spring有哪些主要模块"> 93.Spring有哪些主要模块?</h3>
<p>Spring框架至今已集成了20多个模块。这些模块主要被分如下图所示的核心容器、数据访问/集成,、Web、AOP（面向切面编程）、工</p>
<p>具、消息和测试模块。</p>
<p><img src="./assets/java-07.png" alt=""></p>
<h3 id="_94-spring-常用的注入方式有哪些"> 94.Spring 常用的注入方式有哪些?</h3>
<p>Spring通过DI（依赖注入）实现IOC（控制反转），常用的注入方式主要有三种：</p>
<ol>
<li>构造方法注入</li>
<li>setter注入</li>
<li>基于注解的注入</li>
</ol>
<h3 id="_95-spring-中的-bean是线程安全的吗"> 95.Spring 中的 bean是线程安全的吗?</h3>
<p>Spring容器中的Bean是否线程安全，容器本身并没有提供Bean的线程安全策略，因此可以说spring容器中的Bean本身不具备线程安全</p>
<p>的特性，但是具体还是要结合具体scope的Bean去研究。</p>
<h3 id="_96-spring支持几种bean的作用域"> 96.Spring支持几种bean的作用域?</h3>
<p>当通过spring容器创建一个Bean实例时，不仅可以完成Bean实例的实例化，还可以为Bean指定特定的作用域。Spring支持如下5种作用域：</p>
<ul>
<li>**singleton：**单例模式，在整个Spring IoC容器中，使用singleton定义的Bean将只有一个实例</li>
<li>**prototype：**原型模式，每次通过容器的getBean方法获取prototype定义的Bean时，都将产生一个新的Bean实例</li>
<li>**request：**对于每次HTTP请求，使用request定义的Bean都将产生一个新实例，即每次HTTP请求将会产生不同的Bean实例。只有在Web应用中使用Spring时，该作用域才有效</li>
<li>**session：**对于每次HTTP Session，使用session定义的Bean豆浆产生一个新实例。同样只有在Web应用中使用Spring时，该作用域才有效</li>
<li>**globalsession：**每个全局的HTTP Session，使用session定义的Bean都将产生一个新实例。典型情况下，仅在使用portlet context的时候有效。同样只有在Web应用中使用Spring时，该作用域才有效</li>
</ul>
<p>其中比较常用的是singleton和prototype两种作用域。对于singleton作用域的Bean，每次请求该Bean都将获得相同的实例。容器负责跟踪Bean实例的状态，负责维护Bean实例的生命周期行为；如果一个Bean被设置成prototype作用域，程序每次请求该id的Bean，Spring都会新建一个Bean实例，然后返回给程序。在这种情况下，Spring容器仅仅使用new 关键字创建Bean实例，一旦创建成功，容器不在跟踪实例，也不会维护Bean实例的状态。</p>
<p>如果不指定Bean的作用域，Spring默认使用singleton作用域。Java在创建Java实例时，需要进行内存申请；销毁实例时，需要完成垃圾回收，这些工作都会导致系统开销的增加。因此，prototype作用域Bean的创建、销毁代价比较大。而singleton作用域的Bean实例一旦创建成功，可以重复使用。因此，除非必要，否则尽量避免将Bean被设置成prototype作用域。</p>
<h3 id="_97-spring自动装配bean有哪些方式"> 97.Spring自动装配bean有哪些方式?</h3>
<p>Spring容器负责创建应用程序中的bean同时通过ID来协调这些对象之间的关系。作为开发人员，我们需要告诉Spring要创建哪些bean并且如何将其装配到一起。</p>
<p>spring中bean装配有两种方式：</p>
<ul>
<li>隐式的bean发现机制和自动装配</li>
<li>在java代码或者XML中进行显示配置</li>
</ul>
<p>当然这些方式也可以配合使用。</p>
<h3 id="_98-spring事务实现方式有哪些"> 98.Spring事务实现方式有哪些?</h3>
<ol>
<li>编程式事务管理对基于 POJO 的应用来说是唯一选择。我们需要在代码中调用beginTransaction()、commit()、rollback()等事务管理相关的方法，这就是编程式事务管理。</li>
<li>基于 TransactionProxyFactoryBean 的声明式事务管理</li>
<li>基于 @Transactional 的声明式事务管理</li>
<li>基于 Aspectj AOP 配置事务</li>
</ol>
<h3 id="_99-说一下spring-的事务隔离"> 99.说一下Spring 的事务隔离?</h3>
<p>事务隔离级别指的是一个事务对数据的修改与另一个并行的事务的隔离程度，当多个事务同时访问相同数据时，如果没有采取必要的隔离机制，就可能发生以下问题：</p>
<ul>
<li>脏读：一个事务读到另一个事务未提交的更新数据。</li>
<li>幻读：例如第一个事务对一个表中的数据进行了修改，比如这种修改涉及到表中的“全部数据行”。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入“一行新数据”。那么，以后就会发生操作第一个事务的用户发现表中还存在没有修改的数据行，就好象发生了幻觉一样。</li>
<li>不可重复读：比方说在同一个事务中先后执行两条一模一样的select语句，期间在此次事务中没有执行过任何DDL语句，但先后得到的结果不一致，这就是不可重复读。</li>
</ul>
<h3 id="_100-说一下spring-mvc运行流程"> 100.说一下Spring MVC运行流程?</h3>
<p><strong>Spring MVC运行流程图：</strong></p>
<p><img src="./assets/java-08.png" alt=""></p>
<p><strong>Spring运行流程描述：</strong></p>
<ol>
<li>
<p>用户向服务器发送请求，请求被Spring 前端控制Servelt DispatcherServlet捕获；</p>
</li>
<li>
<p>DispatcherServlet对请求URL进行解析，得到请求资源标识符（URI）。然后根据该URI，调用HandlerMapping获得该Handler配置的所有相关的对象（包括Handler对象以及Handler对象对应的拦截器），最后以HandlerExecutionChain对象的形式返回；</p>
</li>
<li>
<p>DispatcherServlet 根据获得的Handler，选择一个合适的HandlerAdapter；（附注：如果成功获得HandlerAdapter后，此时将开始执行拦截器的preHandler(...)方法）</p>
</li>
<li>
<p>提取Request中的模型数据，填充Handler入参，开始执行Handler（Controller)。 在填充Handler的入参过程中，根据你的配置，Spring将帮你做一些额外的工作：</p>
<ul>
<li>HttpMessageConveter： 将请求消息（如Json、xml等数据）转换成一个对象，将对象转换为指定的响应信息</li>
<li>数据转换：对请求消息进行数据转换。如String转换成Integer、Double等</li>
<li>数据根式化：对请求消息进行数据格式化。 如将字符串转换成格式化数字或格式化日期等</li>
<li>数据验证： 验证数据的有效性（长度、格式等），验证结果存储到BindingResult或Error中</li>
</ul>
</li>
<li>
<p>Handler执行完成后，向DispatcherServlet 返回一个ModelAndView对象；</p>
</li>
<li>
<p>根据返回的ModelAndView，选择一个适合的ViewResolver（必须是已经注册到Spring容器中的ViewResolver)返回给DispatcherServlet ；</p>
</li>
<li>
<p>ViewResolver 结合Model和View，来渲染视图；</p>
</li>
<li>
<p>将渲染结果返回给客户端。</p>
</li>
</ol>
<h3 id="_101-spring-mvc有哪些组件"> 101.Spring MVC有哪些组件?</h3>
<p>Spring MVC的核心组件：</p>
<ol>
<li>DispatcherServlet：中央控制器，把请求给转发到具体的控制类</li>
<li>Controller：具体处理请求的控制器</li>
<li>HandlerMapping：映射处理器，负责映射中央处理器转发给controller时的映射策略</li>
<li>ModelAndView：服务层返回的数据和视图层的封装类</li>
<li>ViewResolver：视图解析器，解析具体的视图</li>
<li>Interceptors ：拦截器，负责拦截我们定义的请求然后做处理工作</li>
</ol>
<h3 id="_102-requestmapping-的作用是什么"> 102.@RequestMapping 的作用是什么?</h3>
<p>RequestMapping是一个用来处理请求地址映射的注解，可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。</p>
<p>RequestMapping注解有六个属性，下面我们把它分成三类进行说明。</p>
<p><strong>value， method：</strong></p>
<ul>
<li>value：指定请求的实际地址，指定的地址可以是URI Template 模式（后面将会说明）；</li>
<li>method：指定请求的method类型， GET、POST、PUT、DELETE等；</li>
</ul>
<p><strong>consumes，produces</strong></p>
<ul>
<li>consumes：指定处理请求的提交内容类型（Content-Type），例如application/json, text/html；</li>
<li>produces：指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回；</li>
</ul>
<p><strong>params，headers</strong></p>
<ul>
<li>params： 指定request中必须包含某些参数值是，才让该方法处理。</li>
<li>headers：指定request中必须包含某些指定的header值，才能让该方法处理请求。</li>
</ul>
<h3 id="_103-autowired的作用是什么"> 103.@Autowired的作用是什么?</h3>
<p>@Autowired 是一个注解，它可以对类成员变量、方法及构造函数进行标注，让 spring 完成 bean 自动装配的工作。</p>
<p>@Autowired 默认是按照类去匹配，配合 @Qualifier 指定按照名称去装配 bean。</p>
<p>常见用法</p>
<div><pre><code><span>import</span> <span>org<span>.</span>springframework<span>.</span>beans<span>.</span>factory<span>.</span>annotation<span>.</span></span><span>Autowired</span><span>;</span>
<span>import</span> <span>org<span>.</span>springframework<span>.</span>stereotype<span>.</span></span><span>Controller</span><span>;</span>
 
<span>import</span> <span>blog<span>.</span>service<span>.</span></span><span>ArticleService</span><span>;</span>
<span>import</span> <span>blog<span>.</span>service<span>.</span></span><span>TagService</span><span>;</span>
<span>import</span> <span>blog<span>.</span>service<span>.</span></span><span>TypeService</span><span>;</span>
 
<span>@Controller</span>
<span>public</span> <span>class</span> <span>TestController</span> <span>{</span>
 
	<span>//成员属性字段使用 @Autowired，无需字段的 set 方法</span>
	<span>@Autowired</span>
	<span>private</span> <span>TypeService</span> typeService<span>;</span>
	
	
	<span>//set 方法使用 @Autowired</span>
	<span>private</span> <span>ArticleService</span> articleService<span>;</span>
	<span>@Autowired</span>
	<span>public</span> <span>void</span> <span>setArticleService</span><span>(</span><span>ArticleService</span> articleService<span>)</span> <span>{</span>
		<span>this</span><span>.</span>articleService <span>=</span> articleService<span>;</span>
	<span>}</span>
 
	<span>//构造方法使用 @Autowired</span>
	<span>private</span> <span>TagService</span> tagService<span>;</span>
	<span>@Autowired</span>
	<span>public</span> <span>TestController</span><span>(</span><span>TagService</span> tagService<span>)</span> <span>{</span>
		<span>this</span><span>.</span>tagService <span>=</span> tagService<span>;</span> 
	<span>}</span>
	
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br></div></div>]]></content>
    <author>
      <name>南辞</name>
    </author>
    <contributor>
      <name>南辞</name>
    </contributor>
    <published>2021-02-18T01:11:00.000Z</published>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">模块11—Spring Boot/Spring Cloud</title>
    <id>http://qiqi.dreamagain.top/interview/Java208/%E6%A8%A1%E5%9D%9711%E2%80%94Spring%20BootSpring%20Cloud/</id>
    <link href="http://qiqi.dreamagain.top/interview/Java208/%E6%A8%A1%E5%9D%9711%E2%80%94Spring%20BootSpring%20Cloud/"/>
    <updated>2021-02-18T01:11:00.000Z</updated>
    <content type="html"><![CDATA[<h2 id="问题"> 问题：</h2>
<p>104.什么是Spring Boot?</p>
<p>105.为什么要用Spring Boot?</p>
<p>106.Spring Boot核心配置文件是什么?</p>
<p>107.Spring Boot配置文件有哪几种类型?它们有什么区别?</p>
<p>108.Spring Boot有哪些方式可以实现热部署?</p>
<p>109.jpa和hibernate有什么区别?</p>
<p>110.什么是 Spring Cloud?</p>
<p>111.Spring Cloud 断路器的作用是什么?</p>
<p>112.Spring Cloud的核心组件有哪些?</p>
<h2 id="答案"> 答案：</h2>
<h3 id="_104-什么是spring-boot"> 104.什么是Spring Boot?</h3>
<p>在Spring框架这个大家族中，产生了很多衍生框架，比如 Spring、SpringMvc框架等，Spring的核心内容在于控制反转(IOC)和依赖注入(DI),所谓控制反转并非是一种技术，而是一种思想，在操作方面是指在spring配置文件中创建<bean>，依赖注入即为由spring容器为应用程序的某个对象提供资源，比如 引用对象、常量数据等。</p>
<p>Spring Boot是一个框架，一种全新的编程规范，他的产生简化了框架的使用，所谓简化是指简化了Spring众多框架中所需的大量且繁琐的配置文件，所以 Spring Boot是一个服务于框架的框架，服务范围是简化配置文件。</p>
<h3 id="_105-为什么要用spring-boot"> 105.为什么要用Spring Boot?</h3>
<ul>
<li>Spring Boot使编码变简单</li>
<li>Spring Boot使配置变简单</li>
<li>Spring Boot使部署变简单</li>
<li>Spring Boot使监控变简单</li>
<li>Spring的不足</li>
</ul>
<h3 id="_106-spring-boot核心配置文件是什么"> 106.Spring Boot核心配置文件是什么?</h3>
<p>Spring Boot提供了两种常用的配置文件：</p>
<ul>
<li>properties文件</li>
<li>yml文件</li>
</ul>
<h3 id="_107-spring-boot配置文件有哪几种类型-它们有什么区别"> 107.Spring Boot配置文件有哪几种类型?它们有什么区别?</h3>
<p>Spring Boot提供了两种常用的配置文件，分别是properties文件和yml文件。</p>
<p>相对于properties文件而言，yml文件更年轻，也有很多的坑。可谓成也萧何败萧何，</p>
<p>yml通过空格来确定层级关系，使配置文件结构跟清晰，但也会因为微不足道的空格而破坏了层级关系。</p>
<h3 id="_108-spring-boot有哪些方式可以实现热部署"> 108.Spring Boot有哪些方式可以实现热部署?</h3>
<p>SpringBoot热部署实现有两种方式：</p>
<p><strong>①. 使用spring loaded</strong></p>
<p>在项目的pom.xml中添加如下代码：</p>
<div><pre><code><span><span><span>&lt;</span>build</span><span>></span></span>
    <span><span><span>&lt;</span>plugins</span><span>></span></span>
        <span><span><span>&lt;</span>plugin</span><span>></span></span>
            <span>&lt;!-- Spring Boot编译插件--></span>
            <span><span><span>&lt;</span>groupId</span><span>></span></span>org.springframework.boot<span><span><span>&lt;/</span>groupId</span><span>></span></span>
            <span><span><span>&lt;</span>artifactId</span><span>></span></span>spring-boot-maven-plugin<span><span><span>&lt;/</span>artifactId</span><span>></span></span>
            <span><span><span>&lt;</span>dependencies</span><span>></span></span>
                <span>&lt;!-- Spring热部署 --></span>
                <span>&lt;!-- 该依赖在此处下载不下来，可以放置在build标签外部下载完成后再粘贴进plugin中 --></span>
                <span><span><span>&lt;</span>dependency</span><span>></span></span>
                    <span><span><span>&lt;</span>groupId</span><span>></span></span>org.springframework<span><span><span>&lt;/</span>groupId</span><span>></span></span>
                    <span><span><span>&lt;</span>artifactId</span><span>></span></span>springloaded<span><span><span>&lt;/</span>artifactId</span><span>></span></span>
                    <span><span><span>&lt;</span>version</span><span>></span></span>1.2.6.RELEASE<span><span><span>&lt;/</span>version</span><span>></span></span>
                <span><span><span>&lt;/</span>dependency</span><span>></span></span>
            <span><span><span>&lt;/</span>dependencies</span><span>></span></span>
        <span><span><span>&lt;/</span>plugin</span><span>></span></span>
    <span><span><span>&lt;/</span>plugins</span><span>></span></span>
<span><span><span>&lt;/</span>build</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><p>添加完毕后需要使用mvn指令运行：</p>
<p>首先找到IDEA中的Edit configurations ,然后进行如下操作：（点击左上角的&quot;+&quot;,然后选择maven将出现右侧面板，在红色划线部位输入</p>
<p>如图所示指令，你可以为该指令命名(此处命名为MvnSpringBootRun)）</p>
<img src="./assets/java-09.png" style="zoom:80%;" />
<p>点击保存将会在IDEA项目运行部位出现，点击绿色箭头运行即可</p>
<p><img src="./assets/java-10.png" alt=""></p>
<p><strong>②. 使用spring-boot-devtools</strong></p>
<p>在项目的pom文件中添加依赖：</p>
<div><pre><code><span>&lt;!--热部署jar--></span>
<span><span><span>&lt;</span>dependency</span><span>></span></span>
    <span><span><span>&lt;</span>groupId</span><span>></span></span>org.springframework.boot<span><span><span>&lt;/</span>groupId</span><span>></span></span>
    <span><span><span>&lt;</span>artifactId</span><span>></span></span>spring-boot-devtools<span><span><span>&lt;/</span>artifactId</span><span>></span></span>
<span><span><span>&lt;/</span>dependency</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>然后：使用 shift+ctrl+alt+&quot;/&quot; （IDEA中的快捷键） 选择&quot;Registry&quot; 然后勾选 compiler.automake.allow.when.app.running</p>
<h3 id="_109jpa和hibernate有什么区别"> 109JPA和Hibernate有什么区别?</h3>
<ul>
<li>JPA Java Persistence API，是Java EE 5的标准ORM接口，也是Ejb3规范的一部分。</li>
<li>Hibernate，当今很流行的ORM框架，是JPA的一个实现，但是其功能是JPA的超集。</li>
<li>JPA和Hibernate之间的关系，可以简单的理解为JPA是标准接口，Hibernate是实现。那么Hibernate是如何实现与JPA的这种关系的呢。Hibernate主要是通过三个组件来实现的，及hibernate-annotation、hibernate-entitymanager和hibernate-core。</li>
<li>hibernate-annotation是Hibernate支持annotation方式配置的基础，它包括了标准的JPA annotation以及Hibernate自身特殊功能的annotation。</li>
<li>hibernate-core是Hibernate的核心实现，提供了Hibernate所有的核心功能。</li>
<li>hibernate-entitymanager实现了标准的JPA，可以把它看成hibernate-core和JPA之间的适配器，它并不直接提供ORM的功能，而是对hibernate-core进行封装，使得Hibernate符合JPA的规范。</li>
</ul>
<h3 id="_110-什么是-spring-cloud"> 110.什么是 Spring Cloud?</h3>
<p>从字面理解，Spring Cloud 就是致力于分布式系统、云服务的框架。</p>
<p>Spring Cloud 是整个 Spring 家族中新的成员，是最近云服务火爆的必然产物。</p>
<p>Spring Cloud 为开发人员提供了快速构建分布式系统中一些常见模式的工具，例如：</p>
<ul>
<li>配置管理</li>
<li>服务注册与发现</li>
<li>断路器</li>
<li>智能路由</li>
<li>服务间调用</li>
<li>负载均衡</li>
<li>微代理</li>
<li>控制总线</li>
<li>一次性令牌</li>
<li>全局锁</li>
<li>领导选举</li>
<li>分布式会话</li>
<li>集群状态</li>
<li>分布式消息</li>
<li>……</li>
</ul>
<p>使用 Spring Cloud 开发人员可以开箱即用的实现这些模式的服务和应用程序。这些服务可以任何环境下运行，包括分布式环境，也包括开发人员自己的笔记本电脑以及各种托管平台。</p>
<h3 id="_111-spring-cloud-断路器的作用是什么"> 111.Spring Cloud 断路器的作用是什么?</h3>
<p>在Spring Cloud中使用了Hystrix 来实现断路器的功能，断路器可以防止一个应用程序多次试图执行一个操作，即很可能失败，允许它继续而不等待故障恢复或者浪费 CPU 周期，而它确定该故障是持久的。断路器模式也使应用程序能够检测故障是否已经解决，如果问题似乎已经得到纠正，应用程序可以尝试调用操作。</p>
<p>断路器增加了稳定性和灵活性，以一个系统，提供稳定性，而系统从故障中恢复，并尽量减少此故障的对性能的影响。它可以帮助快速地拒绝对一个操作，即很可能失败，而不是等待操作超时（或者不返回）的请求，以保持系统的响应时间。如果断路器提高每次改变状态的时间的事件，该信息可以被用来监测由断路器保护系统的部件的健康状况，或以提醒管理员当断路器跳闸，以在打开状态。</p>
<h3 id="_112-spring-cloud的核心组件有哪些"> 112.Spring Cloud的核心组件有哪些?</h3>
<p><strong>①. 服务发现——Netflix Eureka</strong></p>
<p>一个RESTful服务，用来定位运行在AWS地区（Region）中的中间层服务。由两个组件组成：Eureka服务器和Eureka客户端。Eureka服务器用作服务注册服务器。Eureka客户端是一个java客户端，用来简化与服务器的交互、作为轮询负载均衡器，并提供服务的故障切换支持。Netflix在其生产环境中使用的是另外的客户端，它提供基于流量、资源利用率以及出错状态的加权负载均衡。</p>
<p><strong>②. 客服端负载均衡——Netflix Ribbon</strong></p>
<p>Ribbon，主要提供客户侧的软件负载均衡算法。Ribbon客户端组件提供一系列完善的配置选项，比如连接超时、重试、重试算法等。Ribbon内置可插拔、可定制的负载均衡组件。</p>
<p><strong>③. 断路器——Netflix Hystrix</strong></p>
<p>断路器可以防止一个应用程序多次试图执行一个操作，即很可能失败，允许它继续而不等待故障恢复或者浪费 CPU 周期，而它确定该故障是持久的。断路器模式也使应用程序能够检测故障是否已经解决。如果问题似乎已经得到纠正，应用程序可以尝试调用操作。</p>
<p><strong>④. 服务网关——Netflix Zuul</strong></p>
<p>类似nginx，反向代理的功能，不过netflix自己增加了一些配合其他组件的特性。</p>
<p><strong>⑤. 分布式配置——Spring Cloud Config</strong></p>
<p>这个还是静态的，得配合Spring Cloud Bus实现动态的配置更新。</p>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <contributor>
      <name>南辞</name>
    </contributor>
    <published>2021-02-18T01:11:00.000Z</published>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">模块12—Hibernate</title>
    <id>http://qiqi.dreamagain.top/interview/Java208/%E6%A8%A1%E5%9D%9712%E2%80%94Hibernate/</id>
    <link href="http://qiqi.dreamagain.top/interview/Java208/%E6%A8%A1%E5%9D%9712%E2%80%94Hibernate/"/>
    <updated>2021-02-18T01:11:00.000Z</updated>
    <content type="html"><![CDATA[<h2 id="问题"> 问题：</h2>
<p>113.为什么要使用Hibernate?</p>
<p>114.什么是 ORM框架?</p>
<p>115.Hibernate 中如何在控制台查看打印的sql语句?</p>
<p>116.Hibernate有几种查询方式?</p>
<p>117.Hibernate 实体类可以被定义为final 吗?</p>
<p>118.在Hibernate中使用Integer和int做映射有什么区别?</p>
<p>119.Hibernate是如何工作的?</p>
<p>120.get()和load()的区别?</p>
<p>121.说一下 Hibernate 的缓存机制?</p>
<p>122.Hibernate对象有哪些状态?</p>
<p>123.在 Hibernate 中 getCurrentSession和openSession的区别是什么?</p>
<p>124.Hibernate 实体类必须要有无参构造函数吗?为什么?</p>
<h2 id="答案"> 答案：</h2>
<h3 id="_113-为什么要使用hibernate"> 113.为什么要使用Hibernate?</h3>
<ul>
<li>
<p>对JDBC访问数据库的代码做了封装，大大简化了数据访问层繁琐的重复性代码。</p>
</li>
<li>
<p>Hibernate是一个基于JDBC的主流持久化框架，是一个优秀的ORM实现。他很大程度的简化DAO层的编码工作</p>
</li>
<li>
<p>Hibernate使用Java反射机制，而不是字节码增强程序来实现透明性。</p>
</li>
<li>
<p>Hibernate的性能非常好，因为它是个轻量级框架。映射的灵活性很出色。它支持各种关系数据库，从一对一到多对多的各种复杂关系。</p>
</li>
</ul>
<h3 id="_114-什么是-orm框架"> 114.什么是 ORM框架?</h3>
<p>对象-关系映射（Object-Relational Mapping，简称ORM），面向对象的开发方法是当今企业级应用开发环境中的主流开发方法，关系数据库是企业级应用环境中永久存放数据的主流数据存储系统。</p>
<p>对象和关系数据是业务实体的两种表现形式，业务实体在内存中表现为对象，在数据库中表现为关系数据。内存中的对象之间存在关联和继承关系，而在数据库中，关系数据无法直接表达多对多关联和继承关系。因此，对象-关系映射(ORM)系统一般以中间件的形式存在，主要实现程序对象到关系数据库数据的映射。</p>
<h3 id="_115-hibernate-中如何在控制台查看打印的sql语句"> 115.Hibernate 中如何在控制台查看打印的sql语句?</h3>
<p>参考：blog.csdn.net/Randy_Wang_/article/details/79460306</p>
<h3 id="_116-hibernate有几种查询方式"> 116.Hibernate有几种查询方式?</h3>
<ul>
<li>hql查询</li>
<li>sql查询</li>
<li>条件查询</li>
</ul>
<div><pre><code>
hql查询，sql查询，条件查询

HQL<span>:</span>  <span>Hibernate</span> <span>Query</span> <span>Language</span><span>.</span> 面向对象的写法<span>:</span>
<span>Query</span> query <span>=</span> session<span>.</span><span>createQuery</span><span>(</span><span>"from Customer where name = ?"</span><span>)</span><span>;</span>
query<span>.</span><span>setParameter</span><span>(</span><span>0</span><span>,</span> <span>"苍老师"</span><span>)</span><span>;</span>
<span>Query</span><span>.</span><span>list</span><span>(</span><span>)</span><span>;</span>



QBC<span>:</span>  <span>Query</span> <span>By</span> <span>Criteria</span><span>.</span><span>(</span>条件查询<span>)</span>
<span>Criteria</span> criteria <span>=</span> session<span>.</span><span>createCriteria</span><span>(</span><span>Customer</span><span>.</span><span>class</span><span>)</span><span>;</span>
criteria<span>.</span><span>add</span><span>(</span><span>Restrictions</span><span>.</span><span>eq</span><span>(</span><span>"name"</span><span>,</span> <span>"花姐"</span><span>)</span><span>)</span><span>;</span>
<span>List</span><span><span>&lt;</span><span>Customer</span><span>></span></span> list <span>=</span> criteria<span>.</span><span>list</span><span>(</span><span>)</span><span>;</span>



SQL<span>:</span>
<span>SQLQuery</span> query <span>=</span> session<span>.</span><span>createSQLQuery</span><span>(</span><span>"select * from customer"</span><span>)</span><span>;</span>
<span>List</span><span>&lt;</span><span>Object</span><span>[</span><span>]</span><span>></span> list <span>=</span> query<span>.</span><span>list</span><span>(</span><span>)</span><span>;</span>

<span>SQLQuery</span> query <span>=</span> session<span>.</span><span>createSQLQuery</span><span>(</span><span>"select * from customer"</span><span>)</span><span>;</span>
query<span>.</span><span>addEntity</span><span>(</span><span>Customer</span><span>.</span><span>class</span><span>)</span><span>;</span>
<span>List</span><span><span>&lt;</span><span>Customer</span><span>></span></span> list <span>=</span> query<span>.</span><span>list</span><span>(</span><span>)</span><span>;</span>



<span>Hql</span>： 具体分类
<span>1</span>、 属性查询 <span>2</span>、 参数查询、命名参数查询 <span>3</span>、 关联查询 <span>4</span>、 分页查询 <span>5</span>、 统计函数



HQL和SQL的区别

HQL是面向对象查询操作的，SQL是结构化查询语言 是面向数据库表结构的
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br></div></div><h3 id="_117-hibernate-实体类可以被定义为final-吗"> 117.Hibernate 实体类可以被定义为final 吗?</h3>
<p>可以将Hibernate的实体类定义为final类，但这种做法并不好。因为Hibernate会使用代理模式在延迟关联的情况下提高性能，如果你把</p>
<p>实体类定义成final类之后，因为 Java不允许对final类进行扩展，所以Hibernate就无法再使用代理了，如此一来就限制了使用可以提升</p>
<p>性能的手段。不过，如果你的持久化类实现了一个接口而且在该接口中声明了所有定义于实体类中的所有public的方法轮到话，你就能</p>
<p>够避免出现前面所说的不利后果。</p>
<h3 id="_118-在hibernate中使用integer和int做映射有什么区别"> 118.在Hibernate中使用Integer和int做映射有什么区别?</h3>
<p>在Hibernate中，如果将OID定义为Integer类型，那么Hibernate就可以根据其值是否为null而判断一个对象是否是临时的，如果将OID</p>
<p>定义为了int类型，还需要在hbm映射文件中设置其unsaved-value属性为0。</p>
<h3 id="_119-hibernate是如何工作的"> 119.Hibernate是如何工作的?</h3>
<p>hibernate工作原理：</p>
<ol>
<li>通过Configuration config = new Configuration().configure();//读取并解析hibernate.cfg.xml配置文件</li>
<li>由hibernate.cfg.xml中的<mapping resource="com/xx/User.hbm.xml"/>读取并解析映射信息</li>
<li>通过SessionFactory sf = config.buildSessionFactory();//创建SessionFactory</li>
<li>Session session = sf.openSession();//打开Sesssion</li>
<li>Transaction tx = session.beginTransaction();//创建并启动事务Transation</li>
<li>persistent operate操作数据，持久化操作</li>
<li>tx.commit();//提交事务</li>
<li>关闭Session</li>
<li>关闭SesstionFactory</li>
</ol>
<h3 id="_120-get-和load-的区别"> 120.get()和load()的区别?</h3>
<ul>
<li>load() 没有使用对象的其他属性的时候，没有SQL  延迟加载</li>
<li>get() 没有使用对象的其他属性的时候，也生成了SQL  立即加载</li>
</ul>
<h3 id="_121-说一下-hibernate-的缓存机制"> 121.说一下 Hibernate 的缓存机制?</h3>
<p>Hibernate中的缓存分为一级缓存和二级缓存。</p>
<p>一级缓存就是 Session 级别的缓存，在事务范围内有效是,内置的不能被卸载。二级缓存是 SesionFactory级别的缓存，从应用启动到应用结束有效。是可选的，默认没有二级缓存，需要手动开启。保存数据库后，缓存在内存中保存一份，如果更新了数据库就要同步更新。</p>
<p>什么样的数据适合存放到第二级缓存中？</p>
<ul>
<li>很少被修改的数据  帖子的最后回复时间</li>
<li>经常被查询的数据  电商的地点</li>
<li>不是很重要的数据，允许出现偶尔并发的数据</li>
<li>不会被并发访问的数据</li>
<li>常量数据</li>
</ul>
<p>**扩展：**Hibernate的二级缓存默认是不支持分布式缓存的。使用 memcahe,redis等中央缓存来代替二级缓存。</p>
<h3 id="_122-hibernate对象有哪些状态"> 122.Hibernate对象有哪些状态?</h3>
<p>Hibernate里对象有三种状态：</p>
<ol>
<li>Transient（瞬时）：对象刚new出来，还没设id，设了其他值。</li>
<li>Persistent（持久）：调用了save()、saveOrUpdate()，就变成Persistent，有id。</li>
<li>Detached（脱管）：当session  close()完之后，变成Detached。</li>
</ol>
<p><img src="C:%5CUsers%5CMr%20Yang%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210110165420322.png" alt="image-20210110165420322"></p>
<h3 id="_123-在-hibernate-中-getcurrentsession和opensession的区别是什么"> 123.在 Hibernate 中 getCurrentSession和openSession的区别是什么?</h3>
<p>openSession 从字面上可以看得出来，是打开一个新的session对象，而且每次使用都是打开一个新的session，假如连续使用多次，则获得的session不是同一个对象，并且使用完需要调用close方法关闭session。</p>
<p>getCurrentSession ，从字面上可以看得出来，是获取当前上下文一个session对象，当第一次使用此方法时，会自动产生一个session对象，并且连续使用多次时，得到的session都是同一个对象，这就是与openSession的区别之一，简单而言，getCurrentSession 就是：如果有已经使用的，用旧的，如果没有，建新的。</p>
<p>注意：在实际开发中，往往使用getCurrentSession多，因为一般是处理同一个事务（即是使用一个数据库的情况），所以在一般情况下比较少使用openSession或者说openSession是比较老旧的一套接口了。</p>
<h3 id="_124-hibernate-实体类必须要有无参构造函数吗-为什么"> 124.Hibernate 实体类必须要有无参构造函数吗?为什么?</h3>
<p>必须，因为hibernate框架会调用这个默认构造方法来构造实例对象，即Class类的newInstance方法，这个方法就是通过调用默认构造方法来创建实例对象的。</p>
<p>另外再提醒一点，如果你没有提供任何构造方法，虚拟机会自动提供默认构造方法（无参构造器），但是如果你提供了其他有参数的构造方法的话，虚拟机就不再为你提供默认构造方法，这时必须手动把无参构造器写在代码里，否则new Xxxx()是会报错的，所以默认的构造方法不是必须的，只在有多个构造方法时才是必须的，这里“必须”指的是“必须手动写出来”。</p>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <contributor>
      <name>南辞</name>
    </contributor>
    <published>2021-02-18T01:11:00.000Z</published>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">模块13—MyBatis</title>
    <id>http://qiqi.dreamagain.top/interview/Java208/%E6%A8%A1%E5%9D%9713%E2%80%94MyBatis/</id>
    <link href="http://qiqi.dreamagain.top/interview/Java208/%E6%A8%A1%E5%9D%9713%E2%80%94MyBatis/"/>
    <updated>2021-02-18T01:11:00.000Z</updated>
    <content type="html"><![CDATA[<h2 id="问题"> 问题：</h2>
<p>125.MyBatis 中#{和$0的区别是什么?</p>
<p>126.MyBatis有几种分页方式?</p>
<p>127.RowBounds是一次性查询全部结果吗?为什么?</p>
<p>128.MyBatis逻辑分页和物理分页的区别是什么?</p>
<p>129.MyBatis 是否支持延迟加载?延迟加载的原理是什么?</p>
<p>130.说一下MyBatis的一级缓存和二级缓存?</p>
<p>131.MyBatis 和 hibernate的区别有哪些?</p>
<p>132.MyBatis有哪些执行器(Executor) ?</p>
<p>133.MyBatis分页插件的实现原理是什么?</p>
<p>134.MyBatis 如何编写一个自定义插件?</p>
<h2 id="答案"> 答案：</h2>
<h3 id="_125-mybatis-中-和-的区别是什么"> 125.MyBatis 中#{}和${}的区别是什么?</h3>
<ul>
<li>#{}是预编译处理，${}是字符串替换；</li>
<li>MyBatis在处理#{}时，会将sql中的#{}替换为?号，调用PreparedStatement的set方法来赋值；</li>
<li>MyBatis在处理<span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:0.68333em;vertical-align:0em;"></span><span></span><span>时，就是把</span></span></span></span>{}替换成变量的值；</li>
<li>使用**#{}可以有效的防止SQL注入**，提高系统安全性。</li>
</ul>
<h3 id="_126-mybatis有几种分页方式"> 126.MyBatis有几种分页方式?</h3>
<ol>
<li>数组分页</li>
<li>sql分页</li>
<li>拦截器分页</li>
<li>RowBounds分页</li>
</ol>
<h3 id="_127-rowbounds是一次性查询全部结果吗-为什么"> 127.RowBounds是一次性查询全部结果吗?为什么?</h3>
<p>RowBounds 表面是在“所有”数据中检索数据，其实并非是一次性查询出所有数据，因为 MyBatis 是对 jdbc 的封装，在 jdbc 驱动中有</p>
<p>一个 Fetch Size 的配置，它规定了每次最多从数据库查询多少条数据，假如你要查询更多数据，它会在你执行 next()的时候，去查询更</p>
<p>多的数据。就好比你去自动取款机取 10000 元，但取款机每次最多能取 2500 元，所以你要取 4 次才能把钱取完。只是对于 jdbc 来</p>
<p>说，当你调用 next()的时候会自动帮你完成查询工作。这样做的好处可以有效的防止内存溢出。</p>
<p>Fetch Size 官方相关文档：http://t. cn/EfSE2g3</p>
<h3 id="_128-mybatis逻辑分页和物理分页的区别是什么"> 128.MyBatis逻辑分页和物理分页的区别是什么?</h3>
<ul>
<li>物理分页速度上并不一定快于逻辑分页，逻辑分页速度上也并不一定快于物理分页。</li>
<li>物理分页总是优于逻辑分页：没有必要将属于数据库端的压力加诸到应用端来，就算速度上存在优势,然而其它性能上的优点足以弥补这个缺点。</li>
</ul>
<h3 id="_129-mybatis-是否支持延迟加载-延迟加载的原理是什么"> 129.MyBatis 是否支持延迟加载?延迟加载的原理是什么?</h3>
<p>MyBatis仅支持association关联对象和collection关联集合对象的延迟加载，association指的就是一对一，collection指的就是一对多查</p>
<p>询。在MyBatis配置文件中，可以配置是否启用延迟加载lazyLoadingEnabled=true|false。</p>
<p>它的<strong>原理是：</strong></p>
<ol>
<li>使用<strong>CGLIB</strong>创建目标对象的<strong>代理对象</strong>，当调用目标方法时，进入拦截器方法，比如调用a.getB().getName()，</li>
<li>拦截器invoke()方法发现a.getB()是null值，那么就会单独发送事先保存好的查询关联B对象的sql，把B查询上来，然后调用a.setB(b)，于是a的对象b属性就有值了，</li>
<li>接着完成a.getB().getName()方法的调用。这就是延迟加载的基本原理。</li>
</ol>
<p>当然了，不光是MyBatis，几乎所有的包括Hibernate，支持延迟加载的原理都是一样的。</p>
<h3 id="_130-说一下mybatis的一级缓存和二级缓存"> 130.说一下MyBatis的一级缓存和二级缓存?</h3>
<p><strong>一级缓存:</strong> 基于 PerpetualCache 的 HashMap 本地缓存，其存储作用域为 Session，当 Session flush 或 close 之后，该 Session 中的所有 Cache 就将清空，默认打开一级缓存。</p>
<p>二级缓存与一级缓存其机制相同，默认也是采用 PerpetualCache，HashMap 存储，不同在于其存储作用域为 Mapper(Namespace)，并且可自定义存储源，如 Ehcache。默认不打开二级缓存，要开启二级缓存，使用二级缓存属性类需要实现Serializable序列化接口(可用来保存对象的状态),可在它的映射文件中配置<cache/> ；</p>
<p>对于缓存数据更新机制，当某一个作用域(一级缓存 Session/二级缓存Namespaces)的进行了C/U/D 操作后，默认该作用域下所有 select 中的缓存将被 clear。</p>
<h3 id="_131-mybatis-和-hibernate的区别有哪些"> 131.MyBatis 和 Hibernate的区别有哪些?</h3>
<p>（1）Mybatis和hibernate不同，它不完全是一个ORM框架，因为MyBatis需要程序员自己编写Sql语句。</p>
<p>（2）Mybatis直接编写原生态sql，可以严格控制sql执行性能，灵活度高，非常适合对关系数据模型要求不高的软件开发，因为这类软</p>
<p>件需求变化频繁，一但需求变化要求迅速输出成果。但是灵活的前提是mybatis无法做到数据库无关性，如果需要实现支持多种数据库</p>
<p>的软件，则需要自定义多套sql映射文件，工作量大。</p>
<p>（3）Hibernate对象/关系映射能力强，数据库无关性好，对于关系模型要求高的软件，如果用Hibernate开发可以节省很多代码，提高</p>
<p>效率。</p>
<h3 id="_132-mybatis有哪些执行器-executor"> 132.MyBatis有哪些执行器(Executor) ?</h3>
<p><strong>Mybatis有三种基本的执行器（Executor）：</strong></p>
<ol>
<li><strong>SimpleExecutor</strong>：每执行一次update或select，就开启一个Statement对象，用完立刻关闭Statement对象。</li>
<li><strong>ReuseExecutor</strong>：执行update或select，以sql作为key查找Statement对象，存在就使用，不存在就创建，用完后，不关闭Statement对象，而是放置于Map内，供下一次使用。简言之，就是重复使用Statement对象。</li>
<li><strong>BatchExecutor</strong>：执行update（没有select，JDBC批处理不支持select），将所有sql都添加到批处理中（addBatch()），等待统一执行（executeBatch()），它缓存了多个Statement对象，每个Statement对象都是addBatch()完毕后，等待逐一执行executeBatch()批处理。与JDBC批处理相同。</li>
</ol>
<h3 id="_133-mybatis分页插件的实现原理是什么"> 133.MyBatis分页插件的实现原理是什么?</h3>
<p>分页插件的基本原理是使用Mybatis提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的sql，然后重写sql，根据</p>
<p>dialect方言，添加对应的物理分页语句和物理分页参数。</p>
<h3 id="_134-mybatis-如何编写一个自定义插件"> 134.MyBatis 如何编写一个自定义插件?</h3>
<p>转自：blog.csdn.net/qq_30051265/article/details/80266434</p>
<p>Mybatis自定义插件针对MyBatis四大对象（Executor、StatementHandler 、ParameterHandler 、ResultSetHandler ）进行拦截，具体拦截方式为：</p>
<ul>
<li>Executor：拦截执行器的方法(log记录)</li>
<li>StatementHandler ：拦截Sql语法构建的处理</li>
<li>ParameterHandler ：拦截参数的处理</li>
<li>ResultSetHandler ：拦截结果集的处理</li>
</ul>
<p>Mybatis自定义插件必须实现Interceptor接口：</p>
<div><pre><code>
<span>public</span> <span>interface</span> <span>Interceptor</span> <span>{</span>
    <span>Object</span> <span>intercept</span><span>(</span><span>Invocation</span> invocation<span>)</span> <span>throws</span> <span>Throwable</span><span>;</span>
    <span>Object</span> <span>plugin</span><span>(</span><span>Object</span> target<span>)</span><span>;</span>
    <span>void</span> <span>setProperties</span><span>(</span><span>Properties</span> properties<span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>intercept方法：拦截器具体处理逻辑方法</p>
<p>plugin方法：根据签名signatureMap生成动态代理对象</p>
<p>setProperties方法：设置Properties属性</p>
<p>自定义插件demo：</p>
<div><pre><code>
<span>// ExamplePlugin.java</span>
<span>@Intercepts</span><span>(</span><span>{</span><span>@Signature</span><span>(</span>
  type<span>=</span> <span>Executor</span><span>.</span><span>class</span><span>,</span>
  method <span>=</span> <span>"update"</span><span>,</span>
  args <span>=</span> <span>{</span><span>MappedStatement</span><span>.</span><span>class</span><span>,</span><span>Object</span><span>.</span><span>class</span><span>}</span><span>)</span><span>}</span><span>)</span>
<span>public</span> <span>class</span> <span>ExamplePlugin</span> <span>implements</span> <span>Interceptor</span> <span>{</span>
  <span>public</span> <span>Object</span> <span>intercept</span><span>(</span><span>Invocation</span> invocation<span>)</span> <span>throws</span> <span>Throwable</span> <span>{</span>
  <span>Object</span> target <span>=</span> invocation<span>.</span><span>getTarget</span><span>(</span><span>)</span><span>;</span> <span>//被代理对象</span>
  <span>Method</span> method <span>=</span> invocation<span>.</span><span>getMethod</span><span>(</span><span>)</span><span>;</span> <span>//代理方法</span>
  <span>Object</span><span>[</span><span>]</span> args <span>=</span> invocation<span>.</span><span>getArgs</span><span>(</span><span>)</span><span>;</span> <span>//方法参数</span>
  <span>// do something ...... 方法拦截前执行代码块</span>
  <span>Object</span> result <span>=</span> invocation<span>.</span><span>proceed</span><span>(</span><span>)</span><span>;</span>
  <span>// do something .......方法拦截后执行代码块</span>
  <span>return</span> result<span>;</span>
  <span>}</span>
  <span>public</span> <span>Object</span> <span>plugin</span><span>(</span><span>Object</span> target<span>)</span> <span>{</span>
    <span>return</span> <span>Plugin</span><span>.</span><span>wrap</span><span>(</span>target<span>,</span> <span>this</span><span>)</span><span>;</span>
  <span>}</span>
  <span>public</span> <span>void</span> <span>setProperties</span><span>(</span><span>Properties</span> properties<span>)</span> <span>{</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><p>一个@Intercepts可以配置多个@Signature，@Signature中的参数定义如下：</p>
<ul>
<li>type：表示拦截的类，这里是Executor的实现类；</li>
<li>method：表示拦截的方法，这里是拦截Executor的update方法；</li>
<li>args：表示方法参数。</li>
</ul>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <contributor>
      <name>南辞</name>
    </contributor>
    <published>2021-02-18T01:11:00.000Z</published>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">模块14—RabbitMQ</title>
    <id>http://qiqi.dreamagain.top/interview/Java208/%E6%A8%A1%E5%9D%9714%E2%80%94RabbitMQ/</id>
    <link href="http://qiqi.dreamagain.top/interview/Java208/%E6%A8%A1%E5%9D%9714%E2%80%94RabbitMQ/"/>
    <updated>2021-02-18T01:11:00.000Z</updated>
    <content type="html"><![CDATA[<h2 id="问题"> 问题：</h2>
<p>135.RabbitMQ的使用场景有哪些?</p>
<p>136.RabbitMQ有哪些重要的角色?</p>
<p>137.RabbitMQ有哪些重要的组件?</p>
<p>138.RabbitMQ中 vhost的作用是什么?</p>
<p>139.RabbitMQ的消息是怎么发送的?</p>
<p>140.RabbitMQ怎么保证消息的稳定性?</p>
<p>141.RabbitMQ怎么避免消息丢失?</p>
<p>142.要保证消息持久化成功的条件有哪些?</p>
<p>143.RabbitMQ持久化有什么缺点?</p>
<p>144.RabbitMQ有几种广播类型?</p>
<p>145.RabbitMQ怎么实现延迟消息队列?</p>
<p>146.RabbitMQ集群有什么用?</p>
<p>147.RabbitMQ节点的类型有哪些?</p>
<p>148.RabbitMQ集群搭建需要注意哪些问题?</p>
<p>149.RabbitMQ每个节点是其他节点的完整拷贝吗?为什么?</p>
<p>150.RabbitMQ集群中唯—一个磁盘节点崩溃了会发生什么情况?</p>
<h2 id="答案"> 答案：</h2>
<h3 id="_135-rabbitmq的使用场景有哪些"> 135.RabbitMQ的使用场景有哪些?</h3>
<h3 id="_136-rabbitmq有哪些重要的角色"> 136.RabbitMQ有哪些重要的角色?</h3>
<h3 id="_137-rabbitmq有哪些重要的组件"> 137.RabbitMQ有哪些重要的组件?</h3>
<h3 id="_138-rabbitmq中-vhost的作用是什么"> 138.RabbitMQ中 vhost的作用是什么?</h3>
<h3 id="_139-rabbitmq的消息是怎么发送的"> 139.RabbitMQ的消息是怎么发送的?</h3>
<h3 id="_140-rabbitmq怎么保证消息的稳定性"> 140.RabbitMQ怎么保证消息的稳定性?</h3>
<h3 id="_141-rabbitmq怎么避免消息丢失"> 141.RabbitMQ怎么避免消息丢失?</h3>
<h3 id="_142-要保证消息持久化成功的条件有哪些"> 142.要保证消息持久化成功的条件有哪些?</h3>
<h3 id="_143-rabbitmq持久化有什么缺点"> 143.RabbitMQ持久化有什么缺点?</h3>
<h3 id="_144-rabbitmq有几种广播类型"> 144.RabbitMQ有几种广播类型?</h3>
<h3 id="_145-rabbitmq怎么实现延迟消息队列"> 145.RabbitMQ怎么实现延迟消息队列?</h3>
<h3 id="_146-rabbitmq集群有什么用"> 146.RabbitMQ集群有什么用?</h3>
<h3 id="_147-rabbitmq节点的类型有哪些"> 147.RabbitMQ节点的类型有哪些?</h3>
<h3 id="_148-rabbitmq集群搭建需要注意哪些问题"> 148.RabbitMQ集群搭建需要注意哪些问题?</h3>
<h3 id="_149-rabbitmq每个节点是其他节点的完整拷贝吗-为什么"> 149.RabbitMQ每个节点是其他节点的完整拷贝吗?为什么?</h3>
<h3 id="_150-rabbitmq集群中唯-一个磁盘节点崩溃了会发生什么情况"> 150.RabbitMQ集群中唯—一个磁盘节点崩溃了会发生什么情况?</h3>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <contributor>
      <name>南辞</name>
    </contributor>
    <published>2021-02-18T01:11:00.000Z</published>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">模块15—Kafka</title>
    <id>http://qiqi.dreamagain.top/interview/Java208/%E6%A8%A1%E5%9D%9715%E2%80%94Kafka/</id>
    <link href="http://qiqi.dreamagain.top/interview/Java208/%E6%A8%A1%E5%9D%9715%E2%80%94Kafka/"/>
    <updated>2021-02-18T01:11:00.000Z</updated>
    <content type="html"><![CDATA[<h2 id="问题"> 问题：</h2>
<p>152.kafka可以脱离zookeeper单独使用吗?为什么?</p>
<p>153.kafka有几种数据保留的策略?</p>
<p>154.kafka同时设置了7天和10G清除数据，到第五天的时候消息达到了10G，这个时候 kafka将如何处理?</p>
<p>155.什么情况会导致kafka运行变慢?</p>
<p>156.使用kafka集群需要注意什么?</p>
<h2 id="答案"> 答案：</h2>
<h3 id="_152-kafka可以脱离zookeeper单独使用吗-为什么"> 152.kafka可以脱离zookeeper单独使用吗?为什么?</h3>
<h3 id="_153-kafka有几种数据保留的策略"> 153.kafka有几种数据保留的策略?</h3>
<h3 id="_154-kafka同时设置了7天和10g清除数据-到第五天的时候消息达到了10g-这个时候-kafka将如何处理"> 154.kafka同时设置了7天和10G清除数据，到第五天的时候消息达到了10G，这个时候 kafka将如何处理?</h3>
<h3 id="_155-什么情况会导致kafka运行变慢"> 155.什么情况会导致kafka运行变慢?</h3>
<h3 id="_156-使用kafka集群需要注意什么"> 156.使用kafka集群需要注意什么?</h3>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <contributor>
      <name>南辞</name>
    </contributor>
    <published>2021-02-18T01:11:00.000Z</published>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">模块16—Zookeeper</title>
    <id>http://qiqi.dreamagain.top/interview/Java208/%E6%A8%A1%E5%9D%9716%E2%80%94Zookeeper/</id>
    <link href="http://qiqi.dreamagain.top/interview/Java208/%E6%A8%A1%E5%9D%9716%E2%80%94Zookeeper/"/>
    <updated>2021-02-18T01:11:00.000Z</updated>
    <content type="html"><![CDATA[<h2 id="问题"> 问题：</h2>
<p>157.zookeeper是什么?</p>
<p>158.zookeeper都有哪些功能?</p>
<p>159.zookeeper有几种部署模式?</p>
<p>160.zookeeper怎么保证主从节点的状态同步?</p>
<p>161.集群中为什么要有主节点?</p>
<p>162.集群中有3台服务器，其中一个节点宕机，这个时候zookeeper还可以使用吗?</p>
<p>163.说一下zookeeper的通知机制?</p>
<h2 id="答案"> 答案：</h2>
<h3 id="_157-zookeeper是什么"> 157.zookeeper是什么?</h3>
<h3 id="_158-zookeeper都有哪些功能"> 158.zookeeper都有哪些功能?</h3>
<h3 id="_159-zookeeper有几种部署模式"> 159.zookeeper有几种部署模式?</h3>
<h3 id="_160-zookeeper怎么保证主从节点的状态同步"> 160.zookeeper怎么保证主从节点的状态同步?</h3>
<h3 id="_161-集群中为什么要有主节点"> 161.集群中为什么要有主节点?</h3>
<h3 id="_162-集群中有3台服务器-其中一个节点宕机-这个时候zookeeper还可以使用吗"> 162.集群中有3台服务器，其中一个节点宕机，这个时候zookeeper还可以使用吗?</h3>
<h3 id="_163-说一下zookeeper的通知机制"> 163.说一下zookeeper的通知机制?</h3>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <contributor>
      <name>南辞</name>
    </contributor>
    <published>2021-02-18T01:11:00.000Z</published>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">模块17—MySQL</title>
    <id>http://qiqi.dreamagain.top/interview/Java208/%E6%A8%A1%E5%9D%9717%E2%80%94MySQL/</id>
    <link href="http://qiqi.dreamagain.top/interview/Java208/%E6%A8%A1%E5%9D%9717%E2%80%94MySQL/"/>
    <updated>2021-03-31T05:51:25.000Z</updated>
    <content type="html"><![CDATA[<h2 id="_1、数据库的三范式是什么"> 1、数据库的三范式是什么?</h2>
<ul>
<li>第一范式：强调的是列的原子性，即数据库表的每一列都是不可分割的原子数据项。</li>
<li>第二范式：要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性。</li>
<li>第三范式：任何非主属性不依赖于其它非主属性。</li>
</ul>
<h2 id="_2、一张自增表里面总共有17条数据-删除了最后2-条数据-重启-mysql数据库-又插入了一条数据-此时id是几"> 2、一张自增表里面总共有17条数据，删除了最后⒉条数据，重启 MySQL数据库，又插入了一条数据，此时id是几?</h2>
<ul>
<li>表类型如果是 MyISAM ，那 id 就是 18。</li>
<li>表类型如果是 InnoDB，那 id 就是 15。</li>
</ul>
<p>InnoDB 表只会把自增主键的最大 id 记录在内存中，所以重启之后会导致最大 id 丢失。</p>
<h2 id="_3、如何获取当前数据库版本"> 3、如何获取当前数据库版本?</h2>
<p>使用 <code>select version();</code>获取当前 MySQL 数据库版本。</p>
<h2 id="_4、说一下acid是什么"> 4、说一下ACID是什么?⭐️</h2>
<ul>
<li>Atomicity（原子性）：一个事务（transaction）中的所有操作，或者全部完成，或者全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被恢复（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。即，事务不可分割、不可约简。</li>
<li>Consistency（一致性）：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设约束、触发器、级联回滚等。</li>
<li>Isolation（隔离性）：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。</li>
<li>Durability（持久性）：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</li>
</ul>
<h2 id="_5、char和varchar-的区别是什么"> 5、char和varchar 的区别是什么?</h2>
<p>char(n) ：固定长度类型，比如订阅 char(10)，当你输入&quot;abc&quot;三个字符的时候，它们占的空间还是 10 个字节，其他 7 个是空字节。</p>
<p>char 优点：效率高；缺点：占用空间；适用场景：存储密码的 md5 值，固定长度的，使用 char 非常合适。</p>
<p>varchar(n) ：可变长度，存储的值是每个值占用的字节再加上一个用来记录其长度的字节的长度。</p>
<p>所以，从空间上考虑 varchar 比较合适；从效率上考虑 char 比较合适，二者使用需要权衡。</p>
<h2 id="_6、char和varchar中的长度是指字节还是字符"> 6、char和varchar中的长度是指字节还是字符？</h2>
<p>是字符长度，具体占多少字节需要根据所设置的字符集：</p>
<div><pre><code>      unicode   utf8 
中文    2字节    3字节
英文    1字节    1字节
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>详细参考：https://blog.csdn.net/zyz511919766/article/details/51682407</p>
<h2 id="_7、float和double的区别是什么"> 7、float和double的区别是什么?</h2>
<h3 id="_1-变量类型不同"> （1）变量类型不同</h3>
<p>float属于单精度型浮点数据。</p>
<p>double属于双精度型浮点数据。</p>
<p><img src="./assets/java-11.png" alt=""></p>
<p>一个浮点数由三部分组成：符号位S、指数部分E（阶码）以及尾数部分M。</p>
<ul>
<li>
<p>单精度浮点数(float)总共用32位来表示浮点数，其中尾数用23位存储，加上小数点前有一位隐藏的1(IEEE754规约数表示法)，2^(23+1) = 16777216。因为 10^7 &lt; 16777216 &lt; 10^8，所以说单精度浮点数的有效位数是7位。考虑到第7位可能的四舍五入问题，所以单精度最少有6位有效数字（最小尺寸）。</p>
</li>
<li>
<p>同样地：双精度浮点数(double)总共用64位来表示浮点数，其中尾数用52位存储，   2^(52+1) = 9007199254740992，10^16 &lt; 9007199254740992 &lt; 10^17，所以双精度的有效位数是16位。同样四舍五入，最少15位。</p>
</li>
</ul>
<h3 id="_2-指数范围不同"> （2）指数范围不同</h3>
<p>float的指数范围为-127~128。</p>
<p>double而double的指数范围为-1023~1024</p>
<h3 id="_3-表达式指数位不同"> （3）表达式指数位不同</h3>
<p>float的表达式为1bit（符号位）+8bits（指数位）+23bits（尾数位）</p>
<p>double的表达式为1bit（符号位）+ 11bits（指数位）+ 52bits（尾数位）</p>
<h3 id="_4-占用内存空间不同"> （4）占用内存空间不同</h3>
<p>float占4个字节（32位）内存空间，其数值范围为3.4E-38～3.4E+38。</p>
<p>double占8 个字节（64位）内存空间，其数值范围为1.7E-308～1.7E+308。</p>
<h3 id="_5-有效位数不同"> （5）有效位数不同</h3>
<p>单精度浮点数的有效位数是7位。</p>
<p>双精度浮点数的有效位数是16位。</p>
<p>单精度最少有6位有效数字（最小尺寸）。</p>
<p>双精度的有效位数最少15位</p>
<h2 id="_8、mysql-的内连接、左连接、右连接有什么区别"> 8、MySQL 的内连接、左连接、右连接有什么区别?</h2>
<p>内连接关键字：inner join；左连接：left join；右连接：right join。</p>
<p>内连接是把匹配的关联数据显示出来；左连接是左边的表全部显示出来，右边的表显示出符合条件的数据；右连接正好相反。</p>
<h2 id="_9、mysql索引是怎么实现的"> 9、MySQL索引是怎么实现的?</h2>
<p>索引是满足某种特定查找算法的数据结构，而这些数据结构会以某种方式指向数据，从而实现高效查找数据。</p>
<p>具体来说 MySQL 中的索引，不同的数据引擎实现有所不同，但目前主流的数据库引擎的索引都是 B+ 树实现的，B+ 树的搜索效率，可</p>
<p>以到达二分法的性能，找到数据区域之后就找到了完整的数据结构了，所以性能也是更好的。</p>
<h2 id="_10、怎么验证-mysql的索引是否满足需求"> 10、怎么验证 MySQL的索引是否满足需求?</h2>
<p>使用 explain 查看 SQL 是如何执行查询语句的，从而分析你的索引是否满足需求。</p>
<p>explain 语法：explain select * from t_name where type=1。</p>
<h2 id="_11、说一下数据库的事务隔离"> 11、说一下数据库的事务隔离?</h2>
<p>MySQL 的事务隔离是在 配置文件里添加的，在文件的最后添加：transaction-isolation = REPEATABLE-READ</p>
<p>可用的配置值：READ-UNCOMMITTED、READ-COMMITTED、REPEATABLE-READ、SERIALIZABLE。</p>
<ul>
<li>READ-UNCOMMITTED：未提交读，最低隔离级别、事务未提交前，就可被其他事务读取（会出现幻读、脏读、不可重复读）。</li>
<li>READ-COMMITTED：提交读，一个事务提交后才能被其他事务读取到（会造成幻读、不可重复读）。</li>
<li>REPEATABLE-READ：可重复读，默认级别，保证多次读取同一个数据时，其值都和事务开始时候的内容是一致，禁止读取到别的事务未提交的数据（会造成幻读）。</li>
<li>SERIALIZABLE：序列化，代价最高最可靠的隔离级别，该隔离级别能防止脏读、不可重复读、幻读。</li>
</ul>
<p>**脏读 ：**表示一个事务能够读取另一个事务中还未提交的数据。比如，某个事务尝试插入记录 A，此时该事务还未提交，然后另一个事</p>
<p>务尝试读取到了记录 A。</p>
<p>**不可重复读 ：**是指在一个事务内，多次读同一数据。</p>
<p>**幻读 ：**指同一个事务内多次查询返回的结果集不一样。比如同一个事务 A 第一次查询时候有 n 条记录，但是第二次同等条件下查询却</p>
<p>有 n+1 条记录，这就好像产生了幻觉。发生幻读的原因也是另外一个事务新增或者删除或者修改了第一个事务结果集里面的数据，同一</p>
<p>个记录的数据内容被修改了，所有数据行的记录就变多或者变少了。</p>
<h2 id="_12、说一下mysql常用的引擎"> 12、说一下MySQL常用的引擎?</h2>
<h3 id="_1-innodb-引擎"> （1）InnoDB 引擎</h3>
<p>InnoDB 引擎提供了对数据库 ACID 事务的支持，并且还提供了行级锁和外键的约束，它的设计的目标就是处理大数据容量的数据库系统。MySQL 运行的时候，InnoDB 会在内存中建立缓冲池，用于缓冲数据和索引。但是该引擎是不支持全文搜索，同时启动也比较的慢，它是不<strong>会保存表的行数</strong>的，所以当进行 select count(*) from table 指令的时候，<strong>需要进行扫描全表</strong>。由于<strong>锁的粒度小，写操作是不会锁定全表的,所以在并发度较高的场景下使用会提升效率的。</strong></p>
<h3 id="_2-myiasm-引擎"> （2）MyIASM 引擎</h3>
<p>MySQL 的默认引擎，但不提供事务的支持，也不支持行级锁和外键。因此当执行插入和更新语句时，即执行写操作的时候需要锁定这个表，所以会导致效率会降低。不过和 InnoDB 不同的是，MyIASM 引擎是<strong>保存了表的行数</strong>，于是当进行 select count(*) from table 语句时，可以直接的读取已经保存的值而<strong>不需要进行扫描全表</strong>。所以，如果<strong>表的读操作远远多于写操作时，并且不需要事务的支持的，可以将 MyIASM 作为数据库引擎的首选。</strong></p>
<h3 id="_175-说一下mysql的行锁和表锁"> 175.说一下MySQL的行锁和表锁?</h3>
<p>MyISAM 只支持表锁，InnoDB 支持表锁和行锁，默认为行锁。</p>
<ul>
<li>表级锁：开销小，加锁快，不会出现死锁。锁粒度大，发生锁冲突的概率最高，并发量最低。</li>
<li>行级锁：开销大，加锁慢，会出现死锁。锁粒度小，发生锁冲突的概率小，并发度最高。</li>
</ul>
<h3 id="_176-说一下乐观锁和悲观锁"> 176.说一下乐观锁和悲观锁?</h3>
<ul>
<li>乐观锁：每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在提交更新的时候会判断一下在此期间别人有没有去更新这个数据。</li>
<li>悲观锁：每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻止，直到这个锁被释放。</li>
</ul>
<p>数据库的乐观锁需要自己实现，在表里面添加一个 version 字段，每次修改成功值加 1，这样每次修改的时候先对比一下，自己拥有的</p>
<p>version 和数据库现在的 version 是否一致，如果不一致就不修改，这样就实现了乐观锁。</p>
<h3 id="_177-mysql问题排查都有哪些手段"> 177.MySQL问题排查都有哪些手段?</h3>
<ul>
<li>使用 show processlist 命令查看当前所有连接信息。</li>
<li>使用 explain 命令查询 SQL 语句执行计划。</li>
<li>开启慢查询日志，查看慢查询的 SQL。</li>
</ul>
<h3 id="_178-如何做mysql的性能优化"> 178.如何做MySQL的性能优化?</h3>
<ul>
<li>为搜索字段创建索引。</li>
<li>避免使用 select *，列出需要查询的字段。</li>
<li>垂直分割分表。</li>
<li>选择正确的存储引擎。</li>
</ul>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <contributor>
      <name>南辞</name>
    </contributor>
    <published>2021-02-18T01:11:00.000Z</published>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">模块18—Redis</title>
    <id>http://qiqi.dreamagain.top/interview/Java208/%E6%A8%A1%E5%9D%9718%E2%80%94Redis/</id>
    <link href="http://qiqi.dreamagain.top/interview/Java208/%E6%A8%A1%E5%9D%9718%E2%80%94Redis/"/>
    <updated>2021-02-18T01:11:00.000Z</updated>
    <content type="html"><![CDATA[<h2 id="问题"> 问题：</h2>
<p>179.redis是什么?都有哪些使用场景?</p>
<p>180.redis有哪些功能?</p>
<p>181.redis和 memecache有什么区别?</p>
<p>182.redis为什么是单线程的?</p>
<p>183.什么是缓存穿透?怎么解决?</p>
<p>184.redis支持的数据类型有哪些?</p>
<p>185.redis支持的java客户端都有哪些?</p>
<p>186.jedis和redisson有哪些区别?</p>
<p>187.怎么保证缓存和数据库数据的一致性?</p>
<p>188.redis持久化有几种方式?</p>
<p>189.redis 怎么实现分布式锁?</p>
<p>190.redis分布式锁有什么缺陷?</p>
<p>191.redis如何做内存优化?</p>
<p>192.redis淘汰策略有哪些?</p>
<p>193.redis 常见的性能问题有哪些?该如何解决?</p>
<h2 id="答案"> 答案：</h2>
<h3 id="_179-redis是什么-都有哪些使用场景"> 179.redis是什么?都有哪些使用场景?</h3>
<p>Redis是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。-----</p>
<p>Redis 使用场景：</p>
<ul>
<li>数据高并发的读写</li>
<li>海量数据的读写</li>
<li>对扩展性要求高的数据</li>
</ul>
<h3 id="_180-redis有哪些功能"> 180.redis有哪些功能?</h3>
<ul>
<li>数据缓存功能</li>
<li>分布式锁的功能</li>
<li>支持数据持久化</li>
<li>支持事务</li>
<li>支持消息队列</li>
</ul>
<h3 id="_181-redis和-memecache有什么区别"> 181.redis和 memecache有什么区别?</h3>
<ul>
<li>memcached所有的值均是简单的字符串，redis作为其替代者，支持更为丰富的数据类型</li>
<li>redis的速度比memcached快很多</li>
<li>redis可以持久化其数据</li>
</ul>
<h3 id="_182-redis为什么是单线程的"> 182.redis为什么是单线程的?</h3>
<p>因为 cpu 不是 Redis 的瓶颈，Redis 的瓶颈最有可能是机器内存或者网络带宽。既然单线程容易实现，而且 cpu 又不会成为瓶颈，那就</p>
<p>顺理成章地采用单线程的方案了。</p>
<p>关于 Redis 的性能，官方网站也有，普通笔记本轻松处理每秒几十万的请求。</p>
<p>而且单线程并不代表就慢 nginx 和 nodejs 也都是高性能单线程的代表。</p>
<h3 id="_183-什么是缓存穿透-怎么解决"> 183.什么是缓存穿透?怎么解决?</h3>
<p>缓存穿透：指查询一个一定不存在的数据，由于缓存是不命中时需要从数据库查询，查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到数据库去查询，造成缓存穿透。</p>
<p>解决方案：最简单粗暴的方法如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），我们就把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。</p>
<h3 id="_184-redis支持的数据类型有哪些"> 184.redis支持的数据类型有哪些?</h3>
<p>string、list、hash、set、zset。</p>
<h3 id="_185-redis支持的java客户端都有哪些"> 185.redis支持的java客户端都有哪些?</h3>
<p>Redisson、Jedis、lettuce等等，官方推荐使用Redisson。</p>
<h3 id="_186-jedis和redisson有哪些区别"> 186.jedis和redisson有哪些区别?</h3>
<ul>
<li>
<p>Jedis是Redis的Java实现的客户端，其API提供了比较全面的Redis命令的支持。</p>
</li>
<li>
<p>Redisson实现了分布式和可扩展的Java数据结构，和Jedis相比，功能较为简单，不支持字符串操作，不支持排序、事务、管道、分区等Redis特性。Redisson的宗旨是促进使用者对Redis的关注分离，从而让使用者能够将精力更集中地放在处理业务逻辑上。</p>
</li>
</ul>
<h3 id="_187-怎么保证缓存和数据库数据的一致性"> 187.怎么保证缓存和数据库数据的一致性?</h3>
<ul>
<li>合理设置缓存的过期时间。</li>
<li>新增、更改、删除数据库操作时同步更新 Redis，可以使用事务机制来保证数据的一致性。</li>
</ul>
<h3 id="_188-redis持久化有几种方式"> 188.redis持久化有几种方式?</h3>
<p>Redis 的持久化有两种方式，或者说有两种策略：</p>
<ul>
<li>RDB（Redis Database）：指定的时间间隔能对你的数据进行快照存储。</li>
<li>AOF（Append Only File）：每一个收到的写命令都通过write函数追加到文件中。</li>
</ul>
<h3 id="_189-redis-怎么实现分布式锁"> 189.redis 怎么实现分布式锁?</h3>
<ul>
<li>
<p>Redis 分布式锁其实就是在系统里面占一个“坑”，其他程序也要占“坑”的时候，</p>
<p>占用成功了就可以继续执行，失败了就只能放弃或稍后重试。</p>
</li>
<li>
<p>占坑一般使用 setnx(set if not exists)指令，只允许被一个程序占有，使用完调用 del 释放锁。</p>
</li>
</ul>
<h3 id="_190-redis分布式锁有什么缺陷"> 190.redis分布式锁有什么缺陷?</h3>
<p>Redis 分布式锁不能解决超时的问题，分布式锁有一个超时时间，程序的执行如果超出了锁的超时时间就会出现问题。</p>
<h3 id="_191-redis如何做内存优化"> 191.redis如何做内存优化?</h3>
<p>尽可能使用散列表（hashes），散列表（是说散列表里面存储的数少）使用的内存非常小，所以你应该尽可能的将你的数据模型抽象到一个散列表里面。</p>
<p>比如你的web系统中有一个用户对象，不要为这个用户的名称，姓氏，邮箱，密码设置单独的key,而是应该把这个用户的所有信息存储到一张散列表里面。</p>
<h3 id="_192-redis淘汰策略有哪些"> 192.redis淘汰策略有哪些?</h3>
<ul>
<li>volatile-lru：从已设置过期时间的数据集（server. db[i]. expires）中挑选最近最少使用的数据淘汰。</li>
<li>volatile-ttl：从已设置过期时间的数据集（server. db[i]. expires）中挑选将要过期的数据淘汰。</li>
<li>volatile-random：从已设置过期时间的数据集（server. db[i]. expires）中任意选择数据淘汰。</li>
<li>allkeys-lru：从数据集（server. db[i]. dict）中挑选最近最少使用的数据淘汰。</li>
<li>allkeys-random：从数据集（server. db[i]. dict）中任意选择数据淘汰。</li>
<li>no-enviction（驱逐）：禁止驱逐数据。</li>
</ul>
<h3 id="_193-redis-常见的性能问题有哪些-该如何解决"> 193.redis 常见的性能问题有哪些?该如何解决?</h3>
<ul>
<li>主服务器写内存快照，会阻塞主线程的工作，当快照比较大时对性能影响是非常大的，会间断性暂停服务，所以主服务器最好不要写内存快照。</li>
<li>Redis 主从复制的性能问题，为了主从复制的速度和连接的稳定性，主从库最好在同一个局域网内。</li>
</ul>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <contributor>
      <name>南辞</name>
    </contributor>
    <published>2021-02-18T01:11:00.000Z</published>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">模块19—JVM</title>
    <id>http://qiqi.dreamagain.top/interview/Java208/%E6%A8%A1%E5%9D%9719%E2%80%94JVM/</id>
    <link href="http://qiqi.dreamagain.top/interview/Java208/%E6%A8%A1%E5%9D%9719%E2%80%94JVM/"/>
    <updated>2021-02-18T01:11:00.000Z</updated>
    <content type="html"><![CDATA[<h2 id="问题"> 问题：</h2>
<p>194.说一下 jvm的主要组成部分?及其作用?</p>
<p>195.说一下 jvm运行时数据区?</p>
<p>196.说一下堆栈的区别?</p>
<p>197.队列和栈是什么?有什么区别?</p>
<p>198.什么是双亲委派模型?</p>
<p>199.说一下类加载的执行过程?</p>
<p>200.怎么判断对象是否可以被回收?</p>
<p>201.java中都有哪些引用类型?</p>
<p>202.说一下 jvm有哪些垃圾回收算法?</p>
<p>203.说一下 jvm有哪些垃圾回收器?</p>
<p>204.详细介绍一下 CMS垃圾回收器?</p>
<p>205.新生代垃圾回收器和老生代垃圾回收器都有哪些?有什么区别?</p>
<p>206.简述分代垃圾回收器是怎么工作的?</p>
<p>207.说一下jvm调优的工具?</p>
<p>208.常用的jvm调优的参数都有哪些?</p>
<h2 id="答案"> 答案：</h2>
<h3 id="_194-说一下-jvm的主要组成部分-及其作用"> 194.说一下 jvm的主要组成部分?及其作用?</h3>
<ul>
<li>类加载器（ClassLoader）</li>
<li>运行时数据区（Runtime Data Area）</li>
<li>执行引擎（Execution Engine）</li>
<li>本地库接口（Native Interface）</li>
</ul>
<p>组件的作用： 首先通过类加载器（ClassLoader）会把 Java 代码转换成字节码，运行时数据区（Runtime Data Area）再把字节码加载</p>
<p>到内存中，而字节码文件只是 JVM 的一套指令集规范，并不能直接交给底层操作系统去执行，因此需要特定的命令解析器执行引擎</p>
<p>（Execution Engine），将字节码翻译成底层系统指令，再交由 CPU 去执行，而这个过程中需要调用其他语言的本地库接口（Native</p>
<p>Interface）来实现整个程序的功能。</p>
<h3 id="_195-说一下-jvm运行时数据区"> 195.说一下 jvm运行时数据区?</h3>
<ul>
<li>程序计数器</li>
<li>虚拟机栈</li>
<li>本地方法栈</li>
<li>堆</li>
<li>方法区</li>
</ul>
<p>有的区域随着虚拟机进程的启动而存在，有的区域则依赖用户进程的启动和结束而创建和销毁。</p>
<p><img src="./assets/java-12.png" alt=""></p>
<h3 id="_196-说一下堆栈的区别"> 196.说一下堆栈的区别?</h3>
<ol>
<li>
<p>栈内存存储的是局部变量而堆内存存储的是实体；</p>
</li>
<li>
<p>栈内存的更新速度要快于堆内存，因为局部变量的生命周期很短；</p>
</li>
<li>
<p>栈内存存放的变量生命周期一旦结束就会被释放，而堆内存存放的实体会被垃圾回收机制不定时的回收。</p>
</li>
</ol>
<h3 id="_197-队列和栈是什么-有什么区别"> 197.队列和栈是什么?有什么区别?</h3>
<ul>
<li>队列和栈都是被用来预存储数据的。</li>
<li>队列允许先进先出检索元素，但也有例外的情况，Deque 接口允许从两端检索元素。</li>
<li>栈和队列很相似，但它运行对元素进行后进先出进行检索。</li>
</ul>
<h3 id="_198-什么是双亲委派模型"> 198.什么是双亲委派模型?</h3>
<p>在介绍双亲委派模型之前先说下类加载器。对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立在 JVM 中的唯一性，每</p>
<p>一个类加载器，都有一个独立的类名称空间。类加载器就是根据指定全限定名称将 class 文件加载到 JVM 内存，然后再转化为 class 对</p>
<p>象。</p>
<p><strong>类加载器分类：</strong></p>
<ul>
<li>启动类加载器（Bootstrap ClassLoader），是虚拟机自身的一部分，用来加载Java_HOME/lib/目录中的，或者被 -Xbootclasspath 参数所指定的路径中并且被虚拟机识别的类库；</li>
<li>扩展类加载器（Extension ClassLoader）：负责加载&lt;java_home style=&quot;box-sizing: border-box; -webkit-tap-highlight-color: transparent; text-size-adjust: none; -webkit-font-smoothing: antialiased; outline: 0px !important;&quot;&gt;\lib\ext目录或Java. ext. dirs系统变量指定的路径中的所有类库；&lt;/java_home&gt;</li>
<li>应用程序类加载器（Application ClassLoader）。负责加载用户类路径（classpath）上的指定类库，我们可以直接使用这个类加载器。一般情况，如果我们没有自定义类加载器默认就是用这个加载器。</li>
<li>其他类加载器：</li>
</ul>
<p>双亲委派模型：如果一个类加载器收到了类加载的请求，它首先不会自己去加载这个类，而是把这个请求委派给父类加载器去完成，每</p>
<p>一层的类加载器都是如此，这样所有的加载请求都会被传送到顶层的启动类加载器中，只有当父加载无法完成加载请求（它的搜索范围</p>
<p>中没找到所需的类）时，子加载器才会尝试去加载类。</p>
<h3 id="_199-说一下类加载的执行过程"> 199.说一下类加载的执行过程?</h3>
<p>类加载分为以下 5 个步骤：</p>
<ol>
<li>加载：根据查找路径找到相应的 class 文件然后导入；</li>
<li>检查：检查加载的 class 文件的正确性；</li>
<li>准备：给类中的静态变量分配内存空间；</li>
<li>解析：虚拟机将常量池中的符号引用替换成直接引用的过程。符号引用就理解为一个标示，而在直接引用直接指向内存中的地址；</li>
<li>初始化：对静态变量和静态代码块执行初始化工作。</li>
</ol>
<h3 id="_200-怎么判断对象是否可以被回收"> 200.怎么判断对象是否可以被回收?</h3>
<p>一般有两种方法来判断：</p>
<ul>
<li>引用计数器：为每个对象创建一个引用计数，有对象引用时计数器 +1，引用被释放时计数 -1，当计数器为 0 时就可以被回收。它有一个缺点不能解决循环引用的问题；</li>
<li>可达性分析：从 GC Roots 开始向下搜索，搜索所走过的路径称为引用链。当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是可以被回收的。</li>
</ul>
<h3 id="_201-java中都有哪些引用类型"> 201.java中都有哪些引用类型?</h3>
<ul>
<li>强引用</li>
<li>软引用</li>
<li>弱引用</li>
<li>虚引用（幽灵引用/幻影引用）</li>
</ul>
<h3 id="_202-说一下-jvm有哪些垃圾回收算法"> 202.说一下 jvm有哪些垃圾回收算法?</h3>
<ul>
<li>标记-清除算法</li>
<li>标记-整理算法</li>
<li>复制算法</li>
<li>分代算法</li>
</ul>
<h3 id="_203-说一下-jvm有哪些垃圾回收器"> 203.说一下 jvm有哪些垃圾回收器?</h3>
<ul>
<li>Serial：最早的单线程串行垃圾回收器。</li>
<li>Serial Old：Serial 垃圾回收器的老年版本，同样也是单线程的，可以作为 CMS 垃圾回收器的备选预案。</li>
<li>ParNew：是 Serial 的多线程版本。</li>
<li>Parallel 和 ParNew 收集器类似是多线程的，但 Parallel 是吞吐量优先的收集器，可以牺牲等待时间换取系统的吞吐量。</li>
<li>Parallel Old 是 Parallel 老生代版本，Parallel 使用的是复制的内存回收算法，Parallel Old 使用的是标记-整理的内存回收算法。</li>
<li>CMS：一种以获得最短停顿时间为目标的收集器，非常适用 B/S 系统。</li>
<li>G1：一种兼顾吞吐量和停顿时间的 GC 实现，是 JDK 9 以后的默认 GC 选项。</li>
</ul>
<h3 id="_204-详细介绍一下-cms垃圾回收器"> 204.详细介绍一下 CMS垃圾回收器?</h3>
<p>CMS 是英文 Concurrent Mark-Sweep 的简称，是以牺牲吞吐量为代价来获得最短回收停顿时间的垃圾回收器。对于要求服务器响应速度的应用上，这种垃圾回收器非常适合。在启动 JVM 的参数加上“-XX:+UseConcMarkSweepGC”来指定使用 CMS 垃圾回收器。</p>
<p>CMS 使用的是标记-清除的算法实现的，所以在 gc 的时候回产生大量的内存碎片，当剩余内存不能满足程序运行要求时，系统将会出现 Concurrent Mode Failure，临时 CMS 会采用 Serial Old 回收器进行垃圾清除，此时的性能将会被降低。</p>
<h3 id="_205-新生代垃圾回收器和老生代垃圾回收器都有哪些-有什么区别"> 205.新生代垃圾回收器和老生代垃圾回收器都有哪些?有什么区别?</h3>
<ul>
<li>新生代回收器：Serial、ParNew、Parallel Scavenge</li>
<li>老年代回收器：Serial Old、Parallel Old、CMS</li>
<li>整堆回收器：G1</li>
</ul>
<p>新生代垃圾回收器一般采用的是复制算法，复制算法的优点是效率高，缺点是内存利用率低；老年代回收器一般采用的是标记-整理的算法进行垃圾回收。</p>
<h3 id="_206-简述分代垃圾回收器是怎么工作的"> 206.简述分代垃圾回收器是怎么工作的?</h3>
<p>分代回收器有两个分区：老生代和新生代，新生代默认的空间占比总空间的 1/3，老生代的默认占比是 2/3。</p>
<p>新生代使用的是复制算法，新生代里有 3 个分区：Eden、To Survivor、From Survivor，它们的默认占比是 8:1:1，它的执行流程如下：</p>
<ul>
<li>把 Eden + From Survivor 存活的对象放入 To Survivor 区；</li>
<li>清空 Eden 和 From Survivor 分区；</li>
<li>From Survivor 和 To Survivor 分区交换，From Survivor 变 To Survivor，To Survivor 变 From Survivor。</li>
</ul>
<p>每次在 From Survivor 到 To Survivor 移动时都存活的对象，年龄就 +1，当年龄到达 15（默认配置是 15）时，升级为老生代。大对象也会直接进入老生代。</p>
<p>老生代当空间占用到达某个值之后就会触发全局垃圾收回，一般使用标记整理的执行算法。以上这些循环往复就构成了整个分代垃圾回收的整体执行流程。</p>
<h3 id="_207-说一下jvm调优的工具"> 207.说一下jvm调优的工具?</h3>
<p>JDK 自带了很多监控工具，都位于 JDK 的 bin 目录下，其中最常用的是 jconsole 和 jvisualvm 这两款视图监控工具。</p>
<ul>
<li>jconsole：用于对 JVM 中的内存、线程和类等进行监控；</li>
<li>jvisualvm：JDK 自带的全能分析工具，可以分析：内存快照、线程快照、程序死锁、监控内存的变化、gc 变化等。</li>
</ul>
<h3 id="_208-常用的jvm调优的参数都有哪些"> 208.常用的jvm调优的参数都有哪些?</h3>
<ul>
<li>-Xms2g：初始化推大小为 2g；</li>
<li>-Xmx2g：堆最大内存为 2g；</li>
<li>-XX:NewRatio=4：设置年轻的和老年代的内存比例为 1:4；</li>
<li>-XX:SurvivorRatio=8：设置新生代 Eden 和 Survivor 比例为 8:2；</li>
<li>–XX:+UseParNewGC：指定使用 ParNew + Serial Old 垃圾回收器组合；</li>
<li>-XX:+UseParallelOldGC：指定使用 ParNew + ParNew Old 垃圾回收器组合；</li>
<li>-XX:+UseConcMarkSweepGC：指定使用 CMS + Serial Old 垃圾回收器组合；</li>
<li>-XX:+PrintGC：开启打印 gc 信息；</li>
<li>-XX:+PrintGCDetails：打印 gc 详细信息。</li>
</ul>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <contributor>
      <name>南辞</name>
    </contributor>
    <published>2021-02-18T01:11:00.000Z</published>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">面试准备</title>
    <id>http://qiqi.dreamagain.top/interview/</id>
    <link href="http://qiqi.dreamagain.top/interview/"/>
    <updated>2021-02-18T01:11:00.000Z</updated>
    <summary type="html"><![CDATA[<blockquote>
<p><img src="https://img.shields.io/badge/%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3-blue.svg" alt="img"></p>
</blockquote>
]]></summary>
    <content type="html"><![CDATA[<blockquote>
<p><img src="https://img.shields.io/badge/%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3-blue.svg" alt="img"></p>
</blockquote>

<h2 id="网上面试题"> 网上面试题</h2>
<p><a href="./Java208/">Java必备208道面试题</a></p>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <category term="面试"/>
    <contributor>
      <name>南辞</name>
    </contributor>
    <published>2021-02-18T01:11:00.000Z</published>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">Spring Security整合</title>
    <id>http://qiqi.dreamagain.top/program/backend/backframe/Spring%20Security/example/</id>
    <link href="http://qiqi.dreamagain.top/program/backend/backframe/Spring%20Security/example/"/>
    <updated>2021-02-18T01:11:00.000Z</updated>
    <content type="html"><![CDATA[<h1 id="spring-security"> Spring Security</h1>
<h1 id="spring-security整合"> Spring Security整合</h1>
<h2 id="一、创建spring-security模块"> 一、创建spring_security模块</h2>
<p><img src="Spring%20Security%E6%95%B4%E5%90%88.assets/423034c7-c21a-4555-8380-393ac7ebca4d.png" alt="img"></p>
<h2 id="二、在spring-security中引入相关依赖"> 二、在spring_security中引入相关依赖</h2>
<div><pre><code><span><span><span>&lt;</span>dependencies</span><span>></span></span>
    <span><span><span>&lt;</span>dependency</span><span>></span></span>
        <span><span><span>&lt;</span>groupId</span><span>></span></span>com.atguigu<span><span><span>&lt;/</span>groupId</span><span>></span></span>
        <span><span><span>&lt;</span>artifactId</span><span>></span></span>common_utils<span><span><span>&lt;/</span>artifactId</span><span>></span></span>
        <span><span><span>&lt;</span>version</span><span>></span></span>0.0.1-SNAPSHOT<span><span><span>&lt;/</span>version</span><span>></span></span>
    <span><span><span>&lt;/</span>dependency</span><span>></span></span>
    
    <span>&lt;!-- Spring Security依赖 --></span>
    <span><span><span>&lt;</span>dependency</span><span>></span></span>
        <span><span><span>&lt;</span>groupId</span><span>></span></span>org.springframework.boot<span><span><span>&lt;/</span>groupId</span><span>></span></span>
        <span><span><span>&lt;</span>artifactId</span><span>></span></span>spring-boot-starter-security<span><span><span>&lt;/</span>artifactId</span><span>></span></span>
    <span><span><span>&lt;/</span>dependency</span><span>></span></span>
    <span><span><span>&lt;</span>dependency</span><span>></span></span>
        <span><span><span>&lt;</span>groupId</span><span>></span></span>io.jsonwebtoken<span><span><span>&lt;/</span>groupId</span><span>></span></span>
        <span><span><span>&lt;</span>artifactId</span><span>></span></span>jjwt<span><span><span>&lt;/</span>artifactId</span><span>></span></span>
    <span><span><span>&lt;/</span>dependency</span><span>></span></span>
<span><span><span>&lt;/</span>dependencies</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><h2 id="三、在service-acl引入spring-security依赖"> 三、在service_acl引入spring_security依赖</h2>
<div><pre><code><span><span><span>&lt;</span>dependency</span><span>></span></span>
    <span><span><span>&lt;</span>groupId</span><span>></span></span>com.nanci<span><span><span>&lt;/</span>groupId</span><span>></span></span>
    <span><span><span>&lt;</span>artifactId</span><span>></span></span>spring_security<span><span><span>&lt;/</span>artifactId</span><span>></span></span>
    <span><span><span>&lt;</span>version</span><span>></span></span>0.0.1-SNAPSHOT<span><span><span>&lt;/</span>version</span><span>></span></span>
<span><span><span>&lt;/</span>dependency</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p><strong>1、代码结构说明：</strong></p>
<p>**<img src="Spring%20Security%E6%95%B4%E5%90%88.assets/6aafe337-8a5d-440c-b93d-ff60d4f9cef6.png" alt="img">
**</p>
<p><strong>2、创建spring security核心配置类</strong></p>
<p><em><strong>*<img src="Spring%20Security%E6%95%B4%E5%90%88.assets/553c05a4-ff6d-456c-a5f6-ee9db5e6954a.png" alt="img">*</strong></em></p>
<p>Spring Security的核心配置就是继承WebSecurityConfigurerAdapter并注解@EnableWebSecurity的配置。</p>
<p>这个配置指明了用户名密码的处理方式、请求路径的开合、登录登出控制等和安全相关的配置</p>
<div><pre><code><span>import</span> <span>com<span>.</span>atguigu<span>.</span>serurity<span>.</span>filter<span>.</span></span><span>TokenAuthenticationFilter</span><span>;</span>
<span>import</span> <span>com<span>.</span>atguigu<span>.</span>serurity<span>.</span>filter<span>.</span></span><span>TokenLoginFilter</span><span>;</span>
<span>import</span> <span>com<span>.</span>atguigu<span>.</span>serurity<span>.</span>security<span>.</span></span><span>DefaultPasswordEncoder</span><span>;</span>
<span>import</span> <span>com<span>.</span>atguigu<span>.</span>serurity<span>.</span>security<span>.</span></span><span>TokenLogoutHandler</span><span>;</span>
<span>import</span> <span>com<span>.</span>atguigu<span>.</span>serurity<span>.</span>security<span>.</span></span><span>TokenManager</span><span>;</span>
<span>import</span> <span>com<span>.</span>atguigu<span>.</span>serurity<span>.</span>security<span>.</span></span><span>UnauthorizedEntryPoint</span><span>;</span>
<span>import</span> <span>org<span>.</span>springframework<span>.</span>beans<span>.</span>factory<span>.</span>annotation<span>.</span></span><span>Autowired</span><span>;</span>
<span>import</span> <span>org<span>.</span>springframework<span>.</span>context<span>.</span>annotation<span>.</span></span><span>Configuration</span><span>;</span>
<span>import</span> <span>org<span>.</span>springframework<span>.</span>data<span>.</span>redis<span>.</span>core<span>.</span></span><span>RedisTemplate</span><span>;</span>
<span>import</span> <span>org<span>.</span>springframework<span>.</span>security<span>.</span>config<span>.</span>annotation<span>.</span>authentication<span>.</span>builders<span>.</span></span><span>AuthenticationManagerBuilder</span><span>;</span>
<span>import</span> <span>org<span>.</span>springframework<span>.</span>security<span>.</span>config<span>.</span>annotation<span>.</span>method<span>.</span>configuration<span>.</span></span><span>EnableGlobalMethodSecurity</span><span>;</span>
<span>import</span> <span>org<span>.</span>springframework<span>.</span>security<span>.</span>config<span>.</span>annotation<span>.</span>web<span>.</span>builders<span>.</span></span><span>HttpSecurity</span><span>;</span>
<span>import</span> <span>org<span>.</span>springframework<span>.</span>security<span>.</span>config<span>.</span>annotation<span>.</span>web<span>.</span>builders<span>.</span></span><span>WebSecurity</span><span>;</span>
<span>import</span> <span>org<span>.</span>springframework<span>.</span>security<span>.</span>config<span>.</span>annotation<span>.</span>web<span>.</span>configuration<span>.</span></span><span>EnableWebSecurity</span><span>;</span>
<span>import</span> <span>org<span>.</span>springframework<span>.</span>security<span>.</span>config<span>.</span>annotation<span>.</span>web<span>.</span>configuration<span>.</span></span><span>WebSecurityConfigurerAdapter</span><span>;</span>
<span>import</span> <span>org<span>.</span>springframework<span>.</span>security<span>.</span>core<span>.</span>userdetails<span>.</span></span><span>UserDetailsService</span><span>;</span>
<span>/**
 * &lt;p>
 * Security配置类
 * &lt;/p>
 */</span>
<span>@Configuration</span>
<span>@EnableWebSecurity</span>
<span>@EnableGlobalMethodSecurity</span><span>(</span>prePostEnabled <span>=</span> <span>true</span><span>)</span>
<span>public</span> <span>class</span> <span>TokenWebSecurityConfig</span> <span>extends</span> <span>WebSecurityConfigurerAdapter</span> <span>{</span>
    <span>private</span> <span>UserDetailsService</span> userDetailsService<span>;</span>
    <span>private</span> <span>TokenManager</span> tokenManager<span>;</span>
    <span>private</span> <span>DefaultPasswordEncoder</span> defaultPasswordEncoder<span>;</span>
    <span>private</span> <span>RedisTemplate</span> redisTemplate<span>;</span>
    <span>@Autowired</span>
    <span>public</span> <span>TokenWebSecurityConfig</span><span>(</span><span>UserDetailsService</span> userDetailsService<span>,</span> <span>DefaultPasswordEncoder</span> defaultPasswordEncoder<span>,</span>
                                  <span>TokenManager</span> tokenManager<span>,</span> <span>RedisTemplate</span> redisTemplate<span>)</span> <span>{</span>
        <span>this</span><span>.</span>userDetailsService <span>=</span> userDetailsService<span>;</span>
        <span>this</span><span>.</span>defaultPasswordEncoder <span>=</span> defaultPasswordEncoder<span>;</span>
        <span>this</span><span>.</span>tokenManager <span>=</span> tokenManager<span>;</span>
        <span>this</span><span>.</span>redisTemplate <span>=</span> redisTemplate<span>;</span>
    <span>}</span>
    <span>/**
     * 配置设置
     * @param http
     * @throws Exception
     */</span>
    <span>@Override</span>
    <span>protected</span> <span>void</span> <span>configure</span><span>(</span><span>HttpSecurity</span> http<span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>
        http<span>.</span><span>exceptionHandling</span><span>(</span><span>)</span>
                <span>.</span><span>authenticationEntryPoint</span><span>(</span><span>new</span> <span>UnauthorizedEntryPoint</span><span>(</span><span>)</span><span>)</span>
                <span>.</span><span>and</span><span>(</span><span>)</span><span>.</span><span>csrf</span><span>(</span><span>)</span><span>.</span><span>disable</span><span>(</span><span>)</span>
                <span>.</span><span>authorizeRequests</span><span>(</span><span>)</span>
                <span>.</span><span>anyRequest</span><span>(</span><span>)</span><span>.</span><span>authenticated</span><span>(</span><span>)</span>
                <span>.</span><span>and</span><span>(</span><span>)</span><span>.</span><span>logout</span><span>(</span><span>)</span><span>.</span><span>logoutUrl</span><span>(</span><span>"/admin/acl/index/logout"</span><span>)</span>
                <span>.</span><span>addLogoutHandler</span><span>(</span><span>new</span> <span>TokenLogoutHandler</span><span>(</span>tokenManager<span>,</span>redisTemplate<span>)</span><span>)</span><span>.</span><span>and</span><span>(</span><span>)</span>
                <span>.</span><span>addFilter</span><span>(</span><span>new</span> <span>TokenLoginFilter</span><span>(</span><span>authenticationManager</span><span>(</span><span>)</span><span>,</span> tokenManager<span>,</span> redisTemplate<span>)</span><span>)</span>
                <span>.</span><span>addFilter</span><span>(</span><span>new</span> <span>TokenAuthenticationFilter</span><span>(</span><span>authenticationManager</span><span>(</span><span>)</span><span>,</span> tokenManager<span>,</span> redisTemplate<span>)</span><span>)</span><span>.</span><span>httpBasic</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
    <span>/**
     * 密码处理
     * @param auth
     * @throws Exception
     */</span>
    <span>@Override</span>
    <span>public</span> <span>void</span> <span>configure</span><span>(</span><span>AuthenticationManagerBuilder</span> auth<span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>
        auth<span>.</span><span>userDetailsService</span><span>(</span>userDetailsService<span>)</span><span>.</span><span>passwordEncoder</span><span>(</span>defaultPasswordEncoder<span>)</span><span>;</span>
    <span>}</span>
    <span>/**
     * 配置哪些请求不拦截
     * @param web
     * @throws Exception
     */</span>
    <span>@Override</span>
    <span>public</span> <span>void</span> <span>configure</span><span>(</span><span>WebSecurity</span> web<span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>
        web<span>.</span><span>ignoring</span><span>(</span><span>)</span><span>.</span><span>antMatchers</span><span>(</span><span>"/api/**"</span><span>,</span>
                <span>"/swagger-resources/**"</span><span>,</span> <span>"/webjars/**"</span><span>,</span> <span>"/v2/**"</span><span>,</span> <span>"/swagger-ui.html/**"</span>
               <span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br></div></div><p><strong>5、创建认证授权相关的工具类</strong></p>
<p><img src="Spring%20Security%E6%95%B4%E5%90%88.assets/75ccbeef-10c1-45fd-8f68-b598019832b1.png" alt="img"></p>
<div><pre><code>（1）DefaultPasswordEncoder：密码处理的方法
</code></pre>
<div><span>1</span><br></div></div><div><pre><code>package com.atguigu.serurity.security;
import com.atguigu.commonutils.utils.MD5;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Component;
/**
 * &lt;p&gt;
 * 密码的处理方法类型
 * &lt;/p&gt;
 */
@Component
public class DefaultPasswordEncoder implements PasswordEncoder {
    public DefaultPasswordEncoder() {
        this(-1);
    }
    /**
     * @param strength
     *            the log rounds to use, between 4 and 31
     */
    public DefaultPasswordEncoder(int strength) {
    }
    public String encode(CharSequence rawPassword) {
        return MD5.encrypt(rawPassword.toString());
    }
    public boolean matches(CharSequence rawPassword, String encodedPassword) {
        return encodedPassword.equals(MD5.encrypt(rawPassword.toString()));
    }
}
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div><p><em><em><em>*</em>*（2）********<code>TokenManager：token操作的工具类</code>******</em>*</em>*</p>
<div><pre><code>import io.jsonwebtoken.CompressionCodecs;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.SignatureAlgorithm;
import org.springframework.stereotype.Component;
import java.util.Date;
/**
 * &lt;p&gt;
 * token管理
 * &lt;/p&gt;
 */
@Component
public class TokenManager {
    private long tokenExpiration = 24*60*60*1000;
    private String tokenSignKey = &quot;123456&quot;;
    public String createToken(String username) {
        String token = Jwts.builder().setSubject(username)
                .setExpiration(new Date(System.currentTimeMillis() + tokenExpiration))
                .signWith(SignatureAlgorithm.HS512, tokenSignKey).compressWith(CompressionCodecs.GZIP).compact();
        return token;
    }
    public String getUserFromToken(String token) {
        String user = Jwts.parser().setSigningKey(tokenSignKey).parseClaimsJws(token).getBody().getSubject();
        return user;
    }
    public void removeToken(String token) {
        //jwttoken无需删除，客户端扔掉即可。
    }
}
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br></div></div><p><em><em><em>*</em>*（3）**********<code>TokenLogoutHandler：退出实现</code>**********
**</em>*</em>*</p>
<div><pre><code>import com.atguigu.commonutils.R;
import com.atguigu.commonutils.utils.ResponseUtil;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.security.core.Authentication;
import org.springframework.security.web.authentication.logout.LogoutHandler;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
/**
 * &lt;p&gt;
 * 登出业务逻辑类
 * &lt;/p&gt;
 */
public class TokenLogoutHandler implements LogoutHandler {
    private TokenManager tokenManager;
    private RedisTemplate redisTemplate;
    public TokenLogoutHandler(TokenManager tokenManager, RedisTemplate redisTemplate) {
        this.tokenManager = tokenManager;
        this.redisTemplate = redisTemplate;
    }
    @Override
    public void logout(HttpServletRequest request, HttpServletResponse response, Authentication authentication) {
        String token = request.getHeader(&quot;token&quot;);
        if (token != null) {
            tokenManager.removeToken(token);
            //清空当前用户缓存中的权限数据
            String userName = tokenManager.getUserFromToken(token);
            redisTemplate.delete(userName);
        }
        ResponseUtil.out(response, R.ok());
    }
}
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br></div></div><p><em><strong>*（4）********<code>UnauthorizedEntryPoint：未授权统一处理</code>*********</strong></em></p>
<div><pre><code>import com.atguigu.commonutils.R;
import com.atguigu.commonutils.utils.ResponseUtil;
import org.springframework.security.core.AuthenticationException;
import org.springframework.security.web.AuthenticationEntryPoint;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
/**
 * &lt;p&gt;
 * 未授权的统一处理方式
 * &lt;/p&gt;
 */
public class UnauthorizedEntryPoint implements AuthenticationEntryPoint {
    @Override
    public void commence(HttpServletRequest request, HttpServletResponse response,
                         AuthenticationException authException) throws IOException, ServletException {
        ResponseUtil.out(response, R.error());
    }
}
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><p><strong><em>*</em>*********6、创建认证授权实体类**********
****<img src="Spring%20Security%E6%95%B4%E5%90%88.assets/76236594-2238-4d28-a15e-7cf743bb53e2.png" alt="img">（1）SecutityUser*****</strong>*</p>
<div><pre><code>import lombok.Data;
import lombok.extern.slf4j.Slf4j;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.util.StringUtils;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
/**
 * &lt;p&gt;
 * 安全认证用户详情信息
 * &lt;/p&gt;
 */
@Data
@Slf4j
public class SecurityUser implements UserDetails {
    //当前登录用户
    private transient User currentUserInfo;
    //当前权限
    private List&lt;String&gt; permissionValueList;
    public SecurityUser() {
    }
    public SecurityUser(User user) {
        if (user != null) {
            this.currentUserInfo = user;
        }
    }
    @Override
    public Collection&lt;? extends GrantedAuthority&gt; getAuthorities() {
        Collection&lt;GrantedAuthority&gt; authorities = new ArrayList&lt;&gt;();
        for(String permissionValue : permissionValueList) {
            if(StringUtils.isEmpty(permissionValue)) continue;
            SimpleGrantedAuthority authority = new SimpleGrantedAuthority(permissionValue);
            authorities.add(authority);
        }
        return authorities;
    }
    @Override
    public String getPassword() {
        return currentUserInfo.getPassword();
    }
    @Override
    public String getUsername() {
        return currentUserInfo.getUsername();
    }
    @Override
    public boolean isAccountNonExpired() {
        return true;
    }
    @Override
    public boolean isAccountNonLocked() {
        return true;
    }
    @Override
    public boolean isCredentialsNonExpired() {
        return true;
    }
    @Override
    public boolean isEnabled() {
        return true;
    }
}
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br></div></div><p><em><em><em>*</em>*****（2）User******</em>*</em>*</p>
<div><pre><code>import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import lombok.Data;
import java.io.Serializable;
/**
 * &lt;p&gt;
 * 用户实体类
 * &lt;/p&gt;
 */
@Data
@ApiModel(description = &quot;用户实体类&quot;)
public class User implements Serializable {
    private static final long serialVersionUID = 1L;
    @ApiModelProperty(value = &quot;微信openid&quot;)
    private String username;
    @ApiModelProperty(value = &quot;密码&quot;)
    private String password;
    @ApiModelProperty(value = &quot;昵称&quot;)
    private String nickName;
    @ApiModelProperty(value = &quot;用户头像&quot;)
    private String salt;
    @ApiModelProperty(value = &quot;用户签名&quot;)
    private String token;
}
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><p><strong><em>*</em>*******************7、创建认证和授权的filter**********
**********<img src="Spring%20Security%E6%95%B4%E5%90%88.assets/bee4d171-befe-4b08-a792-5f1d50a8642b.png" alt="img">
****（1）TokenLoginFilter：认证的filter*****</strong>*</p>
<div><pre><code>import com.atguigu.commonutils.R;
import com.atguigu.commonutils.utils.ResponseUtil;
import com.atguigu.serurity.entity.SecurityUser;
import com.atguigu.serurity.entity.User;
import com.atguigu.serurity.security.TokenManager;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.AuthenticationException;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;
import org.springframework.security.web.util.matcher.AntPathRequestMatcher;
import javax.servlet.FilterChain;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.util.ArrayList;
/**
 * &lt;p&gt;
 * 登录过滤器，继承UsernamePasswordAuthenticationFilter，对用户名密码进行登录校验
 * &lt;/p&gt;
 */
public class TokenLoginFilter extends UsernamePasswordAuthenticationFilter {
    private AuthenticationManager authenticationManager;
    private TokenManager tokenManager;
    private RedisTemplate redisTemplate;
    public TokenLoginFilter(AuthenticationManager authenticationManager, TokenManager tokenManager, RedisTemplate redisTemplate) {
        this.authenticationManager = authenticationManager;
        this.tokenManager = tokenManager;
        this.redisTemplate = redisTemplate;
        this.setPostOnly(false);
        this.setRequiresAuthenticationRequestMatcher(new AntPathRequestMatcher(&quot;/admin/acl/login&quot;,&quot;POST&quot;));
    }
    @Override
    public Authentication attemptAuthentication(HttpServletRequest req, HttpServletResponse res)
            throws AuthenticationException {
        try {
            User user = new ObjectMapper().readValue(req.getInputStream(), User.class);
            return authenticationManager.authenticate(new UsernamePasswordAuthenticationToken(user.getUsername(), user.getPassword(), new ArrayList&lt;&gt;()));
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }
    /**
     * 登录成功
     * @param req
     * @param res
     * @param chain
     * @param auth
     * @throws IOException
     * @throws ServletException
     */
    @Override
    protected void successfulAuthentication(HttpServletRequest req, HttpServletResponse res, FilterChain chain,
                                            Authentication auth) throws IOException, ServletException {
        SecurityUser user = (SecurityUser) auth.getPrincipal();
        String token = tokenManager.createToken(user.getCurrentUserInfo().getUsername());
        redisTemplate.opsForValue().set(user.getCurrentUserInfo().getUsername(), user.getPermissionValueList());
        ResponseUtil.out(res, R.ok().data(&quot;token&quot;, token));
    }
    /**
     * 登录失败
     * @param request
     * @param response
     * @param e
     * @throws IOException
     * @throws ServletException
     */
    @Override
    protected void unsuccessfulAuthentication(HttpServletRequest request, HttpServletResponse response,
                                              AuthenticationException e) throws IOException, ServletException {
        ResponseUtil.out(response, R.error());
    }
}
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br></div></div><p><strong><em>*</em>*******************************<code>（2）TokenAuthenticationFilter：</code>*********************************</strong>*</p>
<div><pre><code>授权filter
</code></pre>
<div><span>1</span><br></div></div><div><pre><code>package com.atguigu.serurity.filter;
import com.atguigu.commonutils.R;
import com.atguigu.commonutils.utils.ResponseUtil;
import com.atguigu.serurity.security.TokenManager;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.web.authentication.www.BasicAuthenticationFilter;
import org.springframework.util.StringUtils;
import javax.servlet.FilterChain;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
/**
 * &lt;p&gt;
 * 访问过滤器
 * &lt;/p&gt;
 */
public class TokenAuthenticationFilter extends BasicAuthenticationFilter {
    private TokenManager tokenManager;
    private RedisTemplate redisTemplate;
    public TokenAuthenticationFilter(AuthenticationManager authManager, TokenManager tokenManager,RedisTemplate redisTemplate) {
        super(authManager);
        this.tokenManager = tokenManager;
        this.redisTemplate = redisTemplate;
    }
    @Override
    protected void doFilterInternal(HttpServletRequest req, HttpServletResponse res, FilterChain chain)
            throws IOException, ServletException {
        logger.info(&quot;=================&quot;+req.getRequestURI());
        if(req.getRequestURI().indexOf(&quot;admin&quot;) == -1) {
            chain.doFilter(req, res);
            return;
        }
        UsernamePasswordAuthenticationToken authentication = null;
        try {
            authentication = getAuthentication(req);
        } catch (Exception e) {
            ResponseUtil.out(res, R.error());
        }
        if (authentication != null) {
            SecurityContextHolder.getContext().setAuthentication(authentication);
        } else {
            ResponseUtil.out(res, R.error());
        }
        chain.doFilter(req, res);
    }
    private UsernamePasswordAuthenticationToken getAuthentication(HttpServletRequest request) {
        // token置于header里
        String token = request.getHeader(&quot;token&quot;);
        if (token != null &amp;&amp; !&quot;&quot;.equals(token.trim())) {
            String userName = tokenManager.getUserFromToken(token);
            List&lt;String&gt; permissionValueList = (List&lt;String&gt;) redisTemplate.opsForValue().get(userName);
            Collection&lt;GrantedAuthority&gt; authorities = new ArrayList&lt;&gt;();
            for(String permissionValue : permissionValueList) {
                if(StringUtils.isEmpty(permissionValue)) continue;
                SimpleGrantedAuthority authority = new SimpleGrantedAuthority(permissionValue);
                authorities.add(authority);
            }
            if (!StringUtils.isEmpty(userName)) {
                return new UsernamePasswordAuthenticationToken(userName, token, authorities);
            }
            return null;
        }
        return null;
    }
}
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br></div></div>]]></content>
    <author>
      <name>南辞</name>
    </author>
    <category term="后端框架"/>
    <contributor>
      <name>南辞</name>
    </contributor>
    <published>2021-01-13T00:00:00.000Z</published>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">Spring Security介绍</title>
    <id>http://qiqi.dreamagain.top/program/backend/backframe/Spring%20Security/intro/</id>
    <link href="http://qiqi.dreamagain.top/program/backend/backframe/Spring%20Security/intro/"/>
    <updated>2021-02-18T01:11:00.000Z</updated>
    <content type="html"><![CDATA[<h1 id="spring-security"> Spring Security</h1>
<h2 id="一、框架介绍"> 一、框架介绍</h2>
<p>Spring 是一个非常流行和成功的 Java 应用开发框架。Spring Security 基于 Spring 框架，提供了一套 Web 应用安全性的完整解决方案。一般来说，Web 应用的安全性包括**用户认证（Authentication）和用户授权（Authorization）**两个部分。</p>
<p>（1）用户认证指的是：验证某个用户是否为系统中的合法主体，也就是说用户能否访问该系统。用户认证一般要求用户提供用户名和密码。系统通过校验用户名和密码来完成认证过程。</p>
<p>（2）用户授权指的是验证某个用户是否有权限执行某个操作。在一个系统中，不同用户所具有的权限是不同的。比如对一个文件来说，有的用户只能进行读取，而有的用户可以进行修改。一般来说，系统会为不同的用户分配不同的角色，而每个角色则对应一系列的权限。</p>
<p><strong>Spring Security其实就是用filter，对多请求的路径进行过滤。</strong></p>
<p>（1）如果是基于Session，那么Spring Security会对cookie里的sessionid进行解析，找到服务器存储的sesion信息，然后判断当前用户是否符合请求的要求。</p>
<p>（2）如果是token，则是解析出token，然后将当前请求加入到Spring Security管理的权限信息中去</p>
<h2 id="二、认证与授权实现思路"> 二、认证与授权实现思路</h2>
<p>如果系统的模块众多，每个模块都需要进行授权与认证，可以选择基于token的形式进行授权与认证，用户根据用户名密码认证成功，然后获取当前用户角色的一系列权限值，并以用户名为key，权限列表为value的形式存入redis缓存中，根据用户名相关信息生成token返回，浏览器将token记录到cookie中，每次调用api接口都默认将token携带到header请求头中，Spring Security解析header头获取token信息，解析token获取当前用户名，根据用户名就可以从redis中获取权限列表，这样Spring Security就能够判断当前请求是否有权限访问。</p>
<p>流程图：</p>
<p><img src="intro.assets/image-20210202105449950.png" alt="image-20210202105449950"></p>
<p>代码执行过程：</p>
<p><img src="intro.assets/image-20210202105704682.png" alt="image-20210202105704682"></p>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <category term="后端框架"/>
    <contributor>
      <name>南辞</name>
    </contributor>
    <published>2021-01-13T00:00:00.000Z</published>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">ORM相关框架</title>
    <id>http://qiqi.dreamagain.top/program/backend/backframe/orm/</id>
    <link href="http://qiqi.dreamagain.top/program/backend/backframe/orm/"/>
    <updated>2021-02-18T01:11:00.000Z</updated>
    <author>
      <name>南辞</name>
    </author>
    <contributor>
      <name>南辞</name>
    </contributor>
    <published>2021-02-18T01:11:00.000Z</published>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">后端框架</title>
    <id>http://qiqi.dreamagain.top/program/backend/backframe/</id>
    <link href="http://qiqi.dreamagain.top/program/backend/backframe/"/>
    <updated>2021-02-18T01:11:00.000Z</updated>
    <summary type="html"><![CDATA[<blockquote>
<p><img src="https://img.shields.io/badge/%E6%A1%86%E6%9E%B6-Spring-blue.svg" alt="img">  <img src="https://img.shields.io/badge/%E6%A1%86%E6%9E%B6-SpringMVC-blue.svg" alt="img">  <img src="https://img.shields.io/badge/%E6%A1%86%E6%9E%B6-SpringBoot-blue.svg" alt="img">  <img src="https://img.shields.io/badge/%E6%A1%86%E6%9E%B6-SpringCloud-blue.svg" alt="img"> <img src="https://img.shields.io/badge/%E6%A1%86%E6%9E%B6-SpringSecurity-blue.svg" alt="img"></p>
<p><img src="https://img.shields.io/badge/%E6%A1%86%E6%9E%B6-MyBatis-blue.svg" alt="img">  <img src="https://img.shields.io/badge/%E6%A1%86%E6%9E%B6-MyBatis--Plus-blue.svg" alt="img"></p>
</blockquote>
]]></summary>
    <content type="html"><![CDATA[<blockquote>
<p><img src="https://img.shields.io/badge/%E6%A1%86%E6%9E%B6-Spring-blue.svg" alt="img">  <img src="https://img.shields.io/badge/%E6%A1%86%E6%9E%B6-SpringMVC-blue.svg" alt="img">  <img src="https://img.shields.io/badge/%E6%A1%86%E6%9E%B6-SpringBoot-blue.svg" alt="img">  <img src="https://img.shields.io/badge/%E6%A1%86%E6%9E%B6-SpringCloud-blue.svg" alt="img"> <img src="https://img.shields.io/badge/%E6%A1%86%E6%9E%B6-SpringSecurity-blue.svg" alt="img"></p>
<p><img src="https://img.shields.io/badge/%E6%A1%86%E6%9E%B6-MyBatis-blue.svg" alt="img">  <img src="https://img.shields.io/badge/%E6%A1%86%E6%9E%B6-MyBatis--Plus-blue.svg" alt="img"></p>
</blockquote>

]]></content>
    <author>
      <name>南辞</name>
    </author>
    <category term="后端框架"/>
    <contributor>
      <name>南辞</name>
    </contributor>
    <published>2019-09-10T00:00:00.000Z</published>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">Spring家族框架体系</title>
    <id>http://qiqi.dreamagain.top/program/backend/backframe/spring/</id>
    <link href="http://qiqi.dreamagain.top/program/backend/backframe/spring/"/>
    <updated>2021-02-18T01:11:00.000Z</updated>
    <author>
      <name>南辞</name>
    </author>
    <contributor>
      <name>南辞</name>
    </contributor>
    <published>2021-02-18T01:11:00.000Z</published>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">后端框架</title>
    <id>http://qiqi.dreamagain.top/program/backend/framework/</id>
    <link href="http://qiqi.dreamagain.top/program/backend/framework/"/>
    <updated>2021-02-16T17:39:43.000Z</updated>
    <content type="html"><![CDATA[<h2 id="一、spring家族"> 一、Spring家族</h2>
<h3 id="一-spring-framework"> <a href="">（一）Spring Framework</a></h3>
<h3 id="二-spring-mvc"> <a href="">（二）Spring MVC</a></h3>
<h3 id="三-spring-boot"> <a href="">（三）Spring Boot</a></h3>
<h3 id="四-spring-security"> <a href="">（四）Spring Security</a></h3>
<h3 id="五-spring-cloud"> <a href="">（五）Spring Cloud</a></h3>
<h2 id="二、orm框架"> 二、ORM框架</h2>
<h3 id="一-mybatis"> <a href="">（一）MyBatis</a></h3>
<h3 id="二-mybatis-plus"> <a href="">（二）MyBatis-Plus</a></h3>
<h3 id="三-hibanate"> <a href="">（三）Hibanate</a></h3>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <category term="框架"/>
    <contributor>
      <name>南辞</name>
    </contributor>
    <published>2021-02-16T17:39:43.000Z</published>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">JavaSE-注解</title>
    <id>http://qiqi.dreamagain.top/program/backend/java/annotation/</id>
    <link href="http://qiqi.dreamagain.top/program/backend/java/annotation/"/>
    <updated>2021-02-16T17:39:43.000Z</updated>
    <content type="html"><![CDATA[<h2 id="一、理解注解"> 一、理解注解</h2>
<h3 id="一-为什么要引入注解"> （一）为什么要引入注解</h3>
<p>使用注解之前(甚至在使用之后)，XML被广泛的应用于描述元数据，得到各大框架的青睐，它以松耦合的方式完成了框架中几乎所有的配置，但是随着项目越来越庞大，XML的内容也越来越复杂，一些应用开发人员和架构师发现维护成本变高。他们希望使用一些和代码紧耦合的东西，于是就有人提出来一种标记式高耦合的配置方式注解。方法上可以进行注解，类上也可以注解，字段属性上也可以注解，反正几乎需要配置的地方都可以进行注解。</p>
<p>【注解】 VS 【XML】:</p>
<ul>
<li>注解可以提供更大的便捷性，易于维护修改，但耦合度高</li>
<li>XML相对于注解则是相反的。追求低耦合就要抛弃高效率，追求效率必然会遇到耦合。</li>
</ul>
<div><p>如何选择</p>
<p>假如你想为应用设置很多的常量或参数，这种情况下，【XML】是一个很好的选择，因为它不会同特定的代码耦合。</p>
<p>如果你想把某个方法声明为服务，那么使用【注解】会更好一些，因为这种情况下需要注解和方法紧密耦合起来，开发人员也必须认识到这点。</p>
<p>目前，许多框架将【XML】和【注解】两种方式结合使用，平衡两者之间的利弊。</p>
</div>
<h3 id="二-什么是注解"> （二）什么是注解</h3>
<p>注解也叫<strong>元数据</strong>，即一种描述数据的数据。例如我们常见的@Override和@Deprecated，注解是JDK1.5版本开始引入的一个特性，用于对代码进行说明，可以对包、类、接口、字段、方法参数、局部变量等进行注解</p>
<p>实际上Java注解与普通修饰符(public、static、void等)的使用方式并没有多大区别，<strong>一个注解准确意义上来说，只不过是一种特殊的注释而已</strong>， <mark>如果没有解析它的代码，它可能连注释都不如</mark>   。下面的例子是常见的注解：</p>
<div><pre><code><span>public</span> <span>class</span> <span>MyAnnotation</span> <span>{</span>
    <span>//@Test注解修饰方法A</span>
    <span>@Test</span>
    <span>public</span> <span>static</span> <span>void</span> <span>A</span><span>(</span><span>)</span><span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"Test....."</span><span>)</span><span>;</span>
    <span>}</span>

    <span>//一个方法上可以拥有多个不同的注解</span>
    <span>@Deprecated</span>
    <span>@SuppressWarnings</span><span>(</span><span>"uncheck"</span><span>)</span>
    <span>public</span> <span>static</span> <span>void</span> <span>B</span><span>(</span><span>)</span><span>{</span>

    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>通过在方法上使用@Test注解后，在运行该方法时，测试框架会自动识别该方法并单独调用，@Test实际上是一种标记注解，起标记作用，运行时告诉测试框架该方法为测试方法。而对于<code>@Deprecated</code>和<code>@SuppressWarnings(“uncheck”)</code>，则是Java本身内置的注解，在代码中，可以经常看见它们，但这并不是一件好事，毕竟当方法或是类上面有<code>@Deprecated</code>注解时，说明该方法或是类都已经过期不建议再用，<code>@SuppressWarnings</code> 则表示忽略指定警告，比如<code>@SuppressWarnings(“uncheck”)</code>，这就是注解的最简单的使用方式。</p>
<div><p>提示</p>
<p>解析一个类或者方法的注解往往有两种形式：</p>
<ul>
<li>一种是编译期直接的扫描</li>
<li>一种是运行期反射</li>
</ul>
</div>
<p>反射的事情先不讨论，而编译器的扫描指的是编译器在对 Java 代码编译成字节码的过程中会检测到某个类或者方法被一些注解修饰，这时它就会对于这些注解进行某些处理。</p>
<p>再来看一个例子:</p>
<div><pre><code><span>@Override</span>
<span>public</span> <span>String</span> <span>toString</span><span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span>"Hello Annotation"</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>上面的代码中重写了<code>toString()</code>方法并使用了<code>@Override</code>注解。但是，即使不使用<code>@Override</code>注解标记代码，程序也能够正常执行。</p>
<p>那么，该注解表示什么？这么写有什么好处吗？</p>
<p>事实上，<code>@Override</code>告诉编译器这个方法是一个重写方法(描述方法的元数据)，如果父类中不存在该方法，编译器便会报错，提示该方法没有重写父类中的方法。如果不小心拼写错误，例如将<code>toString()</code>写成了<code>toStrring()</code>，而且也没有使用<code>@Override</code>注解，那程序依然能编译运行。但运行结果会和期望的大不相同。现在我们了解了什么是注解，并且使用注解有助于提高代码的可读性。</p>
<h2 id="二、注解的用途"> 二、注解的用途</h2>
<ol>
<li>生成文档，通过代码里标识的元数据生成javadoc文档。</li>
<li>编译检查，通过代码里标识的元数据让编译器在编译期间进行检查验证。</li>
<li>编译时动态处理，编译时通过代码里标识的元数据动态处理，例如动态生成代码。</li>
<li>运行时动态处理，运行时通过代码里标识的元数据动态处理，例如使用反射注入实例</li>
</ol>
<h2 id="三、注解的分类"> 三、注解的分类</h2>
<p>Java 定义了一套注解，共有 7 个，3 个在 java.lang 中，剩下 4 个在 java.lang.annotation 中。</p>
<p><strong>作用在代码的注解</strong> ( <mark>使用这些注解后编译器就会进行检查</mark> )</p>
<ol>
<li>
<p>@Override ：检查该方法是否是重写方法。如果发现其父类，或者是引用的接口中并没有该方法时，会报编译错误。</p>
</li>
<li>
<p>@Deprecated ：标记过时方法。如果使用该方法，会报编译警告。</p>
</li>
<li>
<p>@SuppressWarnings ：指示编译器去忽略注解中声明的警告。</p>
</li>
</ol>
<p><strong>元注解</strong>（ <mark>用于定义注解的注解</mark> ）</p>
<ol>
<li>@Retention ：标识这个注解怎么保存，是只在代码中，还是编入class文件中，或者是在运行时可以通过反射访问。</li>
<li>@Documented ： 标记这些注解是否包含在用户文档中。</li>
<li>@Target ：标记这个注解应该是哪种 Java 成员。</li>
<li>@Inherited ： 标记这个注解是继承于哪个注解类(默认 注解并没有继承于任何子类)</li>
</ol>
<p><strong>Java7之后额外添加了 3 个注解</strong></p>
<ul>
<li>@SafeVarargs ： Java 7 开始支持，忽略任何使用参数为泛型变量的方法或构造函数调用产生的警告。</li>
<li>@FunctionalInterface ： Java 8 开始支持，标识一个匿名函数或函数式接口。</li>
<li>@Repeatable： Java 8 开始支持，标识某注解可以在同一个声明上使用多次，属于元注解，使用较少。</li>
</ul>
<p><strong>自定义注解</strong></p>
<p>​         可以根据自己的需求定义注解</p>
<h2 id="四、声明注解与元注解"> 四、声明注解与元注解</h2>
<p>要想真正掌握怎么使用注解，还需要先学习一下元注解。元注解(meta annotation)是用于标注其他注解的注解，学习元注解之后我们就可以利用元注解来自定义注解。</p>
<p>元注解有 @Retention、@Target、@Inherited、@Repeatable、@Documented 5 种。</p>
<p>我们先来看看前面的Test注解是如何声明的：</p>
<div><pre><code><span>//声明Test注解</span>
<span>@Target</span><span>(</span><span>ElementType</span><span>.</span>METHOD<span>)</span>
<span>@Retention</span><span>(</span><span>RetentionPolicy</span><span>.</span>RUNTIME<span>)</span>
<span>public</span> <span>@interface</span> <span>Test</span> <span>{</span>

<span>}</span> 
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>我们使用了<code>@interface</code>声明了Test注解，并使用<code>@Target</code>注解传入<code>ElementType.METHOD</code>参数来标明@Test只能用于方法上，<code>@Retention(RetentionPolicy.RUNTIME)</code>则用来表示该注解生存期是运行时，从代码上看注解的定义很像接口的定义，确实如此，毕竟在编译后也会生成Test.class文件。对于<code>@Target</code>和<code>@Retention</code>是由Java提供的元注解，所谓元注解就是标记其他注解的注解，下面分别介绍</p>
<h3 id="target"> @Target</h3>
<p>Target 是目标的意思，@Target 用来约束注解可以应用于源码的哪些位置（如方法、类或字段）</p>
<p>可以这样理解，当一个注解被 @Target 注解时，这个注解就被限定了 <mark>运用场景</mark>。</p>
<p>@Target 参数是ElementType是枚举类型，其定义如下，也代表可能的取值范围</p>
<div><pre><code><span>public</span> <span>enum</span> <span>ElementType</span> <span>{</span>
    <span>/**标明该注解可以用于类、接口（包括注解类型）或enum声明*/</span>
    TYPE<span>,</span>

    <span>/** 标明该注解可以用于字段(域)声明，包括enum实例 */</span>
    FIELD<span>,</span>

    <span>/** 标明该注解可以用于方法声明 */</span>
    METHOD<span>,</span>

    <span>/** 标明该注解可以用于参数声明 */</span>
    PARAMETER<span>,</span>

    <span>/** 标明注解可以用于构造函数声明 */</span>
    CONSTRUCTOR<span>,</span>

    <span>/** 标明注解可以用于局部变量声明 */</span>
    LOCAL_VARIABLE<span>,</span>

    <span>/** 标明注解可以用于注解声明(应用于另一个注解上)*/</span>
    ANNOTATION_TYPE<span>,</span>

    <span>/** 标明注解可以用于包声明 */</span>
    PACKAGE<span>,</span>

    <span>/**
     * 标明注解可以用于类型参数声明（1.8新加入）
     * @since 1.8
     */</span>
    TYPE_PARAMETER<span>,</span>

    <span>/**
     * 类型使用声明（1.8新加入)
     * @since 1.8
     */</span>
    TYPE_USE
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br></div></div><p><code>@Target</code>注解参数可以是数组，当注解未指定Target值时，则此注解可以用于任何元素之上，多个值使用{}包含并用逗号隔开，如：<code>{ ElementType.METHOD, ElementType.FIELD }</code></p>
<div><pre><code><span>// Java语言使用@interface语法来定义注解（Annotation）</span>
<span>// 参数表明此注解可以用在方法或字段上</span>
<span>@Target</span><span>(</span><span>{</span><span>ElementType</span><span>.</span>METHOD<span>,</span><span>ElementType</span><span>.</span>FIELD<span>}</span><span>)</span>
<span>public</span> <span>@interface</span> <span>MyAnnotation</span> <span>{</span>
    <span>.</span><span>.</span><span>.</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h3 id="retention"> @Retention</h3>
<p>Retention 的英文意为保留期的意思。当 @Retention 应用到一个注解上的时候，它解释说明了这个注解的的 <mark>生命周期</mark>。</p>
<p>它的取值如下：</p>
<ul>
<li><code>SOURCE</code>：注解将被编译器丢弃（该类型的注解信息只会保留在源码里，源码经过编译后，注解信息会被丢弃，不会保留在编译好的class文件里）</li>
<li><code>CLASS</code>：注解在class文件中可用，但会被VM丢弃（该类型的注解信息会保留在源码里和class文件里，在执行的时候，不会加载到虚拟机中），请注意，当注解未定义Retention值时，默认值是CLASS，如Java内置注解，@Override、@Deprecated、@SuppressWarnning等</li>
<li><code>RUNTIME</code>：注解信息将在运行期(JVM)也保留，因此可以通过反射机制读取注解的信息（源码、class文件和执行的时候都有注解的信息），如SpringMVC中的@Controller、@Autowired、@RequestMapping等。</li>
</ul>
<div><p>提示</p>
<p>如果<code>@Retention</code>不存在，则该<code>Annotation</code>默认为<code>CLASS</code>。</p>
<p>因为通常我们自定义的<code>Annotation</code>都是<code>RUNTIME</code>，所以，务必要加上<code>@Retention(RetentionPolicy.RUNTIME)</code>这个元注解</p>
</div>
<h3 id="repeatable"> @Repeatable</h3>
<p>Repeatable 自然是可重复的意思。@Repeatable 是 Java 1.8 才加进来的，所以算是一个新的特性。这个注解应用不是特别广泛。</p>
<p>Repeatable使用场景：在需要对同一种注解多次使用时，往往需要借助@Repeatable。</p>
<p>下面举例说明一下，在生活中一个人往往是具有多种身份，如果我把每种身份当成一种注解该如何使用</p>
<p>先声明一个Persons类用来包含所有的身份</p>
<div><pre><code><span>@Target</span><span>(</span><span>ElementType</span><span>.</span>TYPE<span>)</span> 
<span>@Retention</span><span>(</span><span>RetentionPolicy</span><span>.</span>RUNTIME<span>)</span>
<span>public</span> <span>@interface</span> <span>Persons</span> <span>{</span>
	<span>Person</span><span>[</span><span>]</span> <span>value</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>这里@Target是声明Persons注解的作用范围，参数ElementType.Type代表可以给一个类进行注解</p>
<p>@Retention是注解的有效时间，RetentionPolicy.RUNTIME是指程序运行的时候。</p>
<p>Person注解</p>
<div><pre><code><span>@Repeatable</span><span>(</span><span>Persons</span><span>.</span><span>class</span><span>)</span>
<span>public</span> <span>@interface</span> <span>Person</span><span>{</span>
	<span>String</span> <span>role</span><span>(</span><span>)</span> <span>default</span> <span>""</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>@Repeatable括号内的就相当于用来保存该注解内容的容器。</p>
<p>声明一个Man类，给该类加上一些身份。</p>
<div><pre><code><span>@Person</span><span>(</span>role<span>=</span><span>"CEO"</span><span>)</span>
<span>@Person</span><span>(</span>role<span>=</span><span>"husband"</span><span>)</span>
<span>@Person</span><span>(</span>role<span>=</span><span>"father"</span><span>)</span>
<span>public</span>   <span>class</span> <span>Man</span> <span>{</span>
	<span>String</span> name<span>=</span><span>""</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>在主方法中访问该注解。</p>
<div><pre><code><span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
    <span>Annotation</span><span>[</span><span>]</span> annotations <span>=</span> <span>Man</span><span>.</span><span>class</span><span>.</span><span>getAnnotations</span><span>(</span><span>)</span><span>;</span>  
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>annotations<span>.</span>length<span>)</span><span>;</span>
    <span>Persons</span> p<span>=</span><span>(</span><span>Persons</span><span>)</span> annotations<span>[</span><span>0</span><span>]</span><span>;</span>
    <span>for</span><span>(</span><span>Person</span> t<span>:</span>p<span>.</span><span>value</span><span>(</span><span>)</span><span>)</span><span>{</span>
    	<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>t<span>.</span><span>role</span><span>(</span><span>)</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>运行结果</p>
<div><pre><code><span>1</span>
CEO
husband
father
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id="inherited"> @Inherited</h3>
<p>@Inherited 可以让注解被继承，但这并不是真的继承，只是通过使用@Inherited，可以让子类Class对象使用getAnnotations()获取父类被@Inherited修饰的注解。<code>@Inherited</code>仅针对<code>@Target(ElementType.TYPE)</code>类型的<code>annotation</code>有效，并且仅针对<code>class</code>的继承，对<code>interface</code>的继承无效：</p>
<div><pre><code><span>package</span> <span>test</span><span>;</span>

<span>import</span> <span>java<span>.</span>lang<span>.</span>annotation<span>.</span></span><span>*</span><span>;</span>
<span>import</span> <span>java<span>.</span>util<span>.</span></span><span>Arrays</span><span>;</span>

<span>@Inherited</span>
<span>@Documented</span>
<span>@Target</span><span>(</span><span>ElementType</span><span>.</span>TYPE<span>)</span>
<span>@Retention</span><span>(</span><span>RetentionPolicy</span><span>.</span>RUNTIME<span>)</span>
<span>@interface</span> <span>DocumentA</span> <span>{</span>
<span>}</span>

<span>@Target</span><span>(</span><span>ElementType</span><span>.</span>TYPE<span>)</span>
<span>@Retention</span><span>(</span><span>RetentionPolicy</span><span>.</span>RUNTIME<span>)</span>
<span>@interface</span> <span>DocumentB</span> <span>{</span>
<span>}</span>

<span>@DocumentA</span>
<span>class</span> <span>A</span><span>{</span> <span>}</span>

<span>class</span> <span>B</span> <span>extends</span> <span>A</span><span>{</span> <span>}</span>

<span>@DocumentB</span>
<span>class</span> <span>C</span><span>{</span> <span>}</span>

<span>class</span> <span>D</span> <span>extends</span> <span>C</span><span>{</span> <span>}</span>

<span>/**
 * 测试
 */</span>
<span>public</span> <span>class</span> <span>DocumentedTest</span> <span>{</span>

    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>.</span><span>.</span><span>.</span> args<span>)</span><span>{</span>
        <span>B</span> b <span>=</span> <span>new</span> <span>B</span><span>(</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"使用了@Inherited注解:"</span><span>+</span> <span>Arrays</span><span>.</span><span>toString</span><span>(</span>b<span>.</span><span>getClass</span><span>(</span><span>)</span><span>.</span><span>getAnnotations</span><span>(</span><span>)</span><span>)</span><span>)</span><span>;</span>

        <span>D</span> d <span>=</span> <span>new</span> <span>D</span><span>(</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"没有使用@Inherited注解:"</span><span>+</span><span>Arrays</span><span>.</span><span>toString</span><span>(</span>d<span>.</span><span>getClass</span><span>(</span><span>)</span><span>.</span><span>getAnnotations</span><span>(</span><span>)</span><span>)</span><span>)</span><span>;</span>
    <span>}</span>

    <span>/**
     运行结果:
     使用了@Inherited注解:[@test.DocumentA()]
     没有使用@Inherited注解:[]
     */</span>
<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br></div></div><h3 id="documented"> @Documented</h3>
<p>顾名思义，这个元注解肯定是和文档有关。它的作用是能够将注解中的元素包含到 Javadoc 中去。</p>
<p>如果使用@Documented标注了，在生成javadoc的时候就会把@Documented注解给显示出来。</p>
<p>@Documented注解只是用来做标识，没什么实际作用，了解就好。</p>
<p>（一）类上添加注解@DocumentA、@DocumentB</p>
<div><pre><code><span>/**
 * 测试
 */</span>
<span>@DocumentA</span>
<span>@DocumentB</span>
<span>public</span> <span>class</span> <span>DocumentedTest</span> <span>{</span>

    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>.</span><span>.</span><span>.</span> args<span>)</span><span>{</span>
        <span>B</span> b <span>=</span> <span>new</span> <span>B</span><span>(</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"使用了@Inherited注解:"</span><span>+</span> <span>Arrays</span><span>.</span><span>toString</span><span>(</span>b<span>.</span><span>getClass</span><span>(</span><span>)</span><span>.</span><span>getAnnotations</span><span>(</span><span>)</span><span>)</span><span>)</span><span>;</span>

        <span>D</span> d <span>=</span> <span>new</span> <span>D</span><span>(</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"没有使用@Inherited注解:"</span><span>+</span><span>Arrays</span><span>.</span><span>toString</span><span>(</span>d<span>.</span><span>getClass</span><span>(</span><span>)</span><span>.</span><span>getAnnotations</span><span>(</span><span>)</span><span>)</span><span>)</span><span>;</span>
    <span>}</span>

    <span>/**
     运行结果:
     使用了@Inherited注解:[@test.DocumentA()]
     没有使用@Inherited注解:[]
     */</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><p>（二）执行命令 javadoc  DocumentedTest.java</p>
<p>生成的文档：</p>
<p><img src="./assets/java-01.png" alt=""></p>
<h2 id="五、注解属性及其数据类型"> 五、注解属性及其数据类型</h2>
<h3 id="一-注解的属性"> （一）注解的属性</h3>
<p>注解的属性也叫做成员变量。注解只有成员变量，没有方法。注解的成员变量在注解的定义中以“无形参的方法”形式来声明，其方法名定义了该成员变量的名字，其返回值定义了该成员变量的类型。</p>
<p>@Test内部没有定义其他元素，所以@Test也称为标记注解（marker annotation），但在自定义注解中，一般都会包含一些元素以表示某些值，方便处理器使用。</p>
<div><pre><code><span>@Target</span><span>(</span><span>ElementType</span><span>.</span>TYPE<span>)</span><span>//只能应用于类上</span>
<span>@Retention</span><span>(</span><span>RetentionPolicy</span><span>.</span>RUNTIME<span>)</span><span>//保存到运行时</span>
<span>public</span> <span>@interface</span> <span>MyAnnotation</span> <span>{</span>
    <span>int</span> <span>id</span><span>(</span><span>)</span> <span>default</span> <span>0</span><span>;</span>
    <span>String</span> <span>name</span><span>(</span><span>)</span> <span>default</span> <span>""</span><span>;</span> <span>//注解元素 String类型</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>上面代码定义了 @TestAnnotation 这个注解中拥有 id 和 msg 两个属性。在使用的时候，我们应该给它们进行赋值。</p>
<div><pre><code><span>@MyAnnotation</span><span>(</span>id<span>=</span><span>3</span><span>,</span> name<span>=</span><span>"hello annotation"</span><span>)</span>
<span>public</span> <span>class</span> <span>Test</span> <span>{</span>

<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id="二-注解的数据类型"> （二）注解的数据类型</h3>
<p><strong>注解支持的元素数据类型</strong>：</p>
<ul>
<li>所有基本类型（int,float,boolean,byte,double,char,long,short）</li>
<li>String</li>
<li>Class</li>
<li>enum</li>
<li>Annotation</li>
<li>上述类型的数组</li>
</ul>
<p>倘若使用了其他数据类型，编译器将会丢出一个编译错误，注意，声明注解元素时可以使用基本类型但不允许使用任何包装类型，同时还应该注意到注解也可以作为元素的类型，也就是嵌套注解，下面的代码演示了上述类型的使用过程：</p>
<div><pre><code><span>package</span> <span>com<span>.</span>zejian<span>.</span>annotationdemo</span><span>;</span>

<span>import</span> <span>java<span>.</span>lang<span>.</span>annotation<span>.</span></span><span>ElementType</span><span>;</span>
<span>import</span> <span>java<span>.</span>lang<span>.</span>annotation<span>.</span></span><span>Retention</span><span>;</span>
<span>import</span> <span>java<span>.</span>lang<span>.</span>annotation<span>.</span></span><span>RetentionPolicy</span><span>;</span>
<span>import</span> <span>java<span>.</span>lang<span>.</span>annotation<span>.</span></span><span>Target</span><span>;</span>

<span>/**
 * 数据类型使用Demo
 */</span>

<span>@Target</span><span>(</span><span>ElementType</span><span>.</span>TYPE<span>)</span>
<span>@Retention</span><span>(</span><span>RetentionPolicy</span><span>.</span>RUNTIME<span>)</span>
<span>@interface</span> <span>Reference</span><span>{</span>
    <span>boolean</span> <span>next</span><span>(</span><span>)</span> <span>default</span> <span>false</span><span>;</span>
<span>}</span>

<span>public</span> <span>@interface</span> <span>AnnotationElementDemo</span> <span>{</span>
    <span>//枚举类型</span>
    <span>enum</span> <span>Status</span> <span>{</span>FIXED<span>,</span>NORMAL<span>}</span><span>;</span>

    <span>//声明枚举</span>
    <span>Status</span> <span>status</span><span>(</span><span>)</span> <span>default</span> <span>Status</span><span>.</span>FIXED<span>;</span>

    <span>//布尔类型</span>
    <span>boolean</span> <span>showSupport</span><span>(</span><span>)</span> <span>default</span> <span>false</span><span>;</span>

    <span>//String类型</span>
    <span>String</span> <span>name</span><span>(</span><span>)</span><span>default</span> <span>""</span><span>;</span>

    <span>//class类型</span>
    <span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> <span>testCase</span><span>(</span><span>)</span> <span>default</span> <span>Void</span><span>.</span><span>class</span><span>;</span>

    <span>//注解嵌套</span>
    <span>Reference</span> <span>reference</span><span>(</span><span>)</span> <span>default</span> <span>@Reference</span><span>(</span>next<span>=</span><span>true</span><span>)</span><span>;</span>

    <span>//数组类型</span>
    <span>long</span><span>[</span><span>]</span> <span>value</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br></div></div><h2 id="六、编译器对默认值的限制"> 六、编译器对默认值的限制</h2>
<p>编译器对元素的默认值有些过分挑剔。首先，元素不能有不确定的值。也就是说，元素必须要么具有默认值，要么在使用注解时提供元素的值。其次，对于非基本类型的元素，无论是在源代码中声明，还是在注解接口中定义默认值，都不能以null作为值，这就是限制，没有什么利用可言，但造成一个元素的存在或缺失状态，因为每个注解的声明中，所有的元素都存在，并且都具有相应的值，为了绕开这个限制，只能定义一些特殊的值，例如空字符串或负数，表示某个元素不存在。</p>
<h2 id="七、注解不支持继承"> 七、注解不支持继承</h2>
<p>注解是不支持继承的，因此不能使用关键字extends来继承某个@interface，但注解在编译后，编译器会自动继承java.lang.annotation.Annotation接口，这里我们反编译前面定义的MyAnnotation注解</p>
<div><pre><code><span>package</span> <span>com<span>.</span>zejian<span>.</span>annotationdemo</span><span>;</span>

<span>import</span> <span>java<span>.</span>lang<span>.</span>annotation<span>.</span></span><span>Annotation</span><span>;</span>
<span>//反编译后的代码</span>
<span>public</span> <span>interface</span> <span>MyAnnotation</span> <span>extends</span> <span>Annotation</span>
<span>{</span>
    <span>public</span> <span>abstract</span> <span>String</span> <span>name</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>虽然反编译后发现MyAnnotation注解继承了Annotation接口，请记住，即使Java的接口可以实现多继承，但定义注解时依然无法使用extends关键字继承@interface。</p>
<h2 id="八、自定义注解"> 八、自定义注解</h2>
<p>由于@Test内部没有定义其他元素，所以@Test也称为标记注解（marker annotation），但在自定义注解中，一般都会包含一些元素以表示某些值，方便处理器使用，</p>
<h3 id="第一步-用-interface定义注解"> 第一步，用<code>@interface</code>定义注解：</h3>
<div><pre><code><span>public</span> <span>@interface</span> <span>MyAnnotation</span> <span>{</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h3 id="第二步-添加参数、默认值"> 第二步，添加参数、默认值：</h3>
<div><pre><code><span>public</span> <span>@interface</span> <span>MyAnnotation</span> <span>{</span>
    <span>int</span> <span>type</span><span>(</span><span>)</span> <span>default</span> <span>0</span><span>;</span>
    <span>String</span> <span>level</span><span>(</span><span>)</span> <span>default</span> <span>"info"</span><span>;</span>
    <span>String</span> <span>value</span><span>(</span><span>)</span> <span>default</span> <span>""</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>注解的参数类似无参数方法，可以用<code>default</code>设定一个默认值（强烈推荐）。把最常用的参数定义为<code>value()</code>，推荐所有参数都尽量设置默认值。</p>
<h3 id="第三步-用元注解配置注解"> 第三步，用元注解配置注解：</h3>
<div><pre><code><span>@Target</span><span>(</span><span>ElementType</span><span>.</span>TYPE<span>)</span>
<span>@Retention</span><span>(</span><span>RetentionPolicy</span><span>.</span>RUNTIME<span>)</span>
<span>public</span> <span>@interface</span> <span>MyAnnotation</span> <span>{</span>
    <span>int</span> <span>type</span><span>(</span><span>)</span> <span>default</span> <span>0</span><span>;</span>
    <span>String</span> <span>level</span><span>(</span><span>)</span> <span>default</span> <span>"info"</span><span>;</span>
    <span>String</span> <span>value</span><span>(</span><span>)</span> <span>default</span> <span>""</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>其中，必须设置<code>@Target</code>和<code>@Retention</code>，<code>@Retention</code>一般设置为<code>RUNTIME</code>，因为我们自定义的注解通常要求在运行期读取。一般情况下，不必写<code>@Inherited</code>和<code>@Repeatable</code>。</p>
<div><p>小结</p>
<ul>
<li>Java使用<code>@interface</code>定义注解;</li>
<li>可定义多个参数和默认值，核心参数使用<code>value</code>名称；</li>
<li>必须设置<code>@Target</code>来指定<code>Annotation</code>可以应用的范围；</li>
<li>应当设置<code>@Retention(RetentionPolicy.RUNTIME)</code>便于运行期读取该<code>Annotation</code>。</li>
</ul>
</div>
<h2 id="九、快捷方式"> 九、快捷方式</h2>
<p>所谓的快捷方式就是注解中定义了名为value的元素，并且在使用该注解时，如果该元素是唯一需要赋值的一个元素，那么此时无需使用key=value的语法，而只需在括号内给出value元素所需的值即可。这可以应用于任何合法类型的元素，记住，这限制了 <mark>元素名必须为value</mark>，<strong>推荐设置默认值</strong>，简单案例如下</p>
<div><pre><code><span>package</span> <span>com<span>.</span>zejian<span>.</span>annotationdemo</span><span>;</span>

<span>import</span> <span>java<span>.</span>lang<span>.</span>annotation<span>.</span></span><span>ElementType</span><span>;</span>
<span>import</span> <span>java<span>.</span>lang<span>.</span>annotation<span>.</span></span><span>Retention</span><span>;</span>
<span>import</span> <span>java<span>.</span>lang<span>.</span>annotation<span>.</span></span><span>RetentionPolicy</span><span>;</span>
<span>import</span> <span>java<span>.</span>lang<span>.</span>annotation<span>.</span></span><span>Target</span><span>;</span>

<span>//定义注解</span>
<span>@Target</span><span>(</span><span>ElementType</span><span>.</span>FIELD<span>)</span>
<span>@Retention</span><span>(</span><span>RetentionPolicy</span><span>.</span>RUNTIME<span>)</span>
<span>@interface</span> <span>IntegerVaule</span><span>{</span>
    <span>int</span> <span>value</span><span>(</span><span>)</span> <span>default</span> <span>0</span><span>;</span>
    <span>String</span> <span>name</span><span>(</span><span>)</span> <span>default</span> <span>""</span><span>;</span>
<span>}</span>

<span>//使用注解</span>
<span>public</span> <span>class</span> <span>QuicklyWay</span> <span>{</span>

    <span>//当只想给value赋值时,可以使用以下快捷方式</span>
    <span>@IntegerVaule</span><span>(</span><span>20</span><span>)</span>
    <span>public</span> <span>int</span> age<span>;</span>

    <span>//当name也需要赋值时必须采用key=value的方式赋值</span>
    <span>@IntegerVaule</span><span>(</span>value <span>=</span> <span>10000</span><span>,</span>name <span>=</span> <span>"MONEY"</span><span>)</span>
    <span>public</span> <span>int</span> money<span>;</span>

<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div><h2 id="十、使用注解"> 十、使用注解</h2>
<h3 id="一-注解的声明"> （一）注解的声明</h3>
<ol>
<li>定义一个可以注解在Class，interface，enum上的注解</li>
<li>定义一个可以注解在METHOD上的注解</li>
<li>定义一个可以注解在FIELD上的注解</li>
<li>定义一个可以注解在PARAMETER上的注解</li>
</ol>
<div><pre><code><span>@Target</span><span>(</span><span>ElementType</span><span>.</span>TYPE<span>)</span>
<span>@Retention</span><span>(</span><span>RetentionPolicy</span><span>.</span>RUNTIME<span>)</span>
<span>public</span> <span>@interface</span> <span>MyAnTargetType</span> <span>{</span>

    <span>/**
     * 定义注解的一个元素 并给定默认值
     * @return
     */</span>
    <span>String</span> <span>value</span><span>(</span><span>)</span> <span>default</span> <span>"定义在类、接口、枚举类上的注解元素value的默认值"</span><span>;</span>

<span>}</span>
<span>@Target</span><span>(</span><span>{</span><span>ElementType</span><span>.</span>METHOD<span>}</span><span>)</span>
<span>@Retention</span><span>(</span><span>RetentionPolicy</span><span>.</span>RUNTIME<span>)</span>
<span>public</span> <span>@interface</span> <span>MyAnTargetMethod</span> <span>{</span>

    <span>/**
     * 定义注解的一个元素 并给定默认值
     * @return
     */</span>
    <span>String</span> <span>value</span><span>(</span><span>)</span> <span>default</span> <span>"定义在方法上的注解元素value的默认值"</span><span>;</span>

<span>}</span>
<span>@Target</span><span>(</span><span>{</span><span>ElementType</span><span>.</span>FIELD<span>}</span><span>)</span>
<span>@Retention</span><span>(</span><span>RetentionPolicy</span><span>.</span>RUNTIME<span>)</span>
<span>public</span> <span>@interface</span> <span>MyAnTargetField</span> <span>{</span>

    <span>/**
     * 定义注解的一个元素 并给定默认值
     * @return
     */</span>
    <span>String</span> <span>value</span><span>(</span><span>)</span> <span>default</span> <span>"定义在字段上的注解元素value的默认值"</span><span>;</span>

<span>}</span>
<span>@Target</span><span>(</span><span>{</span><span>ElementType</span><span>.</span>PARAMETER<span>}</span><span>)</span>
<span>@Retention</span><span>(</span><span>RetentionPolicy</span><span>.</span>RUNTIME<span>)</span>
<span>public</span> <span>@interface</span> <span>MyAnTargetParameter</span> <span>{</span>

    <span>/**
     * 定义注解的一个元素 并给定默认值
     * @return
     */</span>
    <span>String</span> <span>value</span><span>(</span><span>)</span> <span>default</span> <span>"定义在参数上的注解元素value的默认值"</span><span>;</span>

<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br></div></div><h3 id="二-注解的读取"> （二）注解的读取</h3>
<p>因为注解定义后也是一种<code>class</code>，所有的注解都继承自<code>java.lang.annotation.Annotation</code>，因此，读取注解，需要使用反射API。</p>
<p><strong>Java提供的使用反射API读取<code>Annotation</code>的方法包括</strong>：</p>
<p>（1）判断某个注解是否存在于<code>Class</code>、<code>Field</code>、<code>Method</code>或<code>Constructor</code>：</p>
<ul>
<li><code>Class.isAnnotationPresent(Class)</code></li>
<li><code>Field.isAnnotationPresent(Class)</code></li>
<li><code>Method.isAnnotationPresent(Class)</code></li>
<li><code>Constructor.isAnnotationPresent(Class)</code></li>
</ul>
<p>（2）使用反射API读取Annotation：</p>
<ul>
<li><code>Class.getAnnotation(Class)</code></li>
<li><code>Field.getAnnotation(Class)</code></li>
<li><code>Method.getAnnotation(Class)</code></li>
<li><code>Constructor.getAnnotation(Class)</code></li>
</ul>
<p><strong>使用反射API读取<code>Annotation</code>有两种方法</strong>：</p>
<p>方法一：先判断<code>Annotation</code>是否存在，如果存在，就直接读取：</p>
<div><pre><code><span>Class</span> test <span>=</span> <span>Test</span><span>.</span><span>class</span><span>;</span>
<span>if</span> <span>(</span>cls<span>.</span><span>isAnnotationPresent</span><span>(</span><span>MyAnnotation</span><span>.</span><span>class</span><span>)</span><span>)</span> <span>{</span>
    <span>MyAnnotation</span> <span>MyAnnotation</span> <span>=</span> test<span>.</span><span>getAnnotation</span><span>(</span><span>MyAnnotation</span><span>.</span><span>class</span><span>)</span><span>;</span>
    <span>.</span><span>.</span><span>.</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>方法二：直接读取<code>Annotation</code>，如果<code>Annotation</code>不存在，将返回<code>null</code>：</p>
<div><pre><code><span>Class</span> test <span>=</span> <span>Test</span><span>.</span><span>class</span><span>;</span>
<span>MyAnnotation</span> <span>MyAnnotation</span> <span>=</span> test<span>.</span><span>getAnnotation</span><span>(</span><span>MyAnnotation</span><span>.</span><span>class</span><span>)</span><span>;</span>
<span>if</span> <span>(</span><span>MyAnnotation</span> <span>!=</span> <span>null</span><span>)</span> <span>{</span>
   <span>.</span><span>.</span><span>.</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>知道如何获取注解后可以接下来的测试了</p>
<div><pre><code><span>package</span> <span>test</span><span>;</span>

<span>import</span> <span>java<span>.</span>lang<span>.</span>annotation<span>.</span></span><span>Annotation</span><span>;</span>
<span>import</span> <span>java<span>.</span>lang<span>.</span>reflect<span>.</span></span><span>Method</span><span>;</span>

<span>@MyAnTargetType</span>
<span>public</span> <span>class</span> <span>AnnotationTest</span> <span>{</span>

    <span>@MyAnTargetField</span>
    <span>private</span> <span>String</span> field <span>=</span> <span>"我是字段"</span><span>;</span>

    <span>@MyAnTargetMethod</span><span>(</span><span>"测试方法"</span><span>)</span>
    <span>public</span> <span>void</span> <span>test</span><span>(</span><span>@MyAnTargetParameter</span> <span>String</span> args<span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"参数值 === "</span> <span>+</span> args<span>)</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>// 1、先获取Class实例</span>
        <span>Class</span><span><span>&lt;</span><span>AnnotationTest</span><span>></span></span> testClass <span>=</span> <span>AnnotationTest</span><span>.</span><span>class</span><span>;</span>

        <span>// 2、反射获取类上的注解MyAnTargetType</span>
        <span>MyAnTargetType</span> t <span>=</span> testClass<span>.</span><span>getAnnotation</span><span>(</span><span>MyAnTargetType</span><span>.</span><span>class</span><span>)</span><span>;</span>
        <span>if</span> <span>(</span>t <span>!=</span> <span>null</span><span>)</span><span>{</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"类上的注解值 === "</span> <span>+</span> t<span>.</span><span>value</span><span>(</span><span>)</span><span>)</span><span>;</span>
        <span>}</span>

        <span>MyAnTargetMethod</span> tm <span>=</span> <span>null</span><span>;</span>
        <span>try</span> <span>{</span>
            <span>// 3、反射获取AnnotationTest类上的test方法</span>
            <span>Method</span> method <span>=</span> testClass<span>.</span><span>getDeclaredMethod</span><span>(</span><span>"test"</span><span>,</span> <span>String</span><span>.</span><span>class</span><span>)</span><span>;</span>
            <span>// 获取方法上的注解MyAnTargetMethod</span>
            tm <span>=</span> method<span>.</span><span>getAnnotation</span><span>(</span><span>MyAnTargetMethod</span><span>.</span><span>class</span><span>)</span><span>;</span>
            <span>if</span> <span>(</span>tm <span>!=</span> <span>null</span><span>)</span><span>{</span>
                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"方法上的注解值 === "</span> <span>+</span> tm<span>.</span><span>value</span><span>(</span><span>)</span><span>)</span><span>;</span>
            <span>}</span>

            <span>// 4、获取方法上的所有参数注解  循环所有注解找到MyAnTargetParameter注解</span>
            <span>// 要读取方法参数的Annotation就比较麻烦一点，因为方法参数本身可以看成一个数组，</span>
            <span>// 而每个参数又可以定义多个注解，所以，一次获取方法参数的所有注解就必须用一个二维数组来表示。</span>
            <span>// 获取所有参数的Annotation:</span>
            <span>Annotation</span><span>[</span><span>]</span><span>[</span><span>]</span> annotations <span>=</span> method<span>.</span><span>getParameterAnnotations</span><span>(</span><span>)</span><span>;</span>
            <span>for</span> <span>(</span><span>Annotation</span><span>[</span><span>]</span> tt <span>:</span> annotations<span>)</span> <span>{</span>
                <span>for</span> <span>(</span><span>Annotation</span> t1 <span>:</span> tt<span>)</span> <span>{</span>
                    <span>if</span> <span>(</span>t1 <span>instanceof</span> <span>MyAnTargetParameter</span><span>)</span> <span>{</span>
                        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"参数上的注解值 === "</span> <span>+</span> <span>(</span><span>(</span><span>MyAnTargetParameter</span><span>)</span> t1<span>)</span><span>.</span><span>value</span><span>(</span><span>)</span><span>)</span><span>;</span>
                    <span>}</span>
                <span>}</span>
            <span>}</span>
            method<span>.</span><span>invoke</span><span>(</span><span>new</span> <span>AnnotationTest</span><span>(</span><span>)</span><span>,</span> <span>"改变默认参数"</span><span>)</span><span>;</span>
            <span>// 获取AnnotationTest类上字段field的注解MyAnTargetField</span>
            <span>MyAnTargetField</span> fieldAn <span>=</span> testClass<span>.</span><span>getDeclaredField</span><span>(</span><span>"field"</span><span>)</span><span>.</span><span>getAnnotation</span><span>(</span><span>MyAnTargetField</span><span>.</span><span>class</span><span>)</span><span>;</span>
            <span>if</span> <span>(</span>fieldAn <span>!=</span> <span>null</span><span>)</span><span>{</span>
                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"字段上的注解值 === "</span> <span>+</span> fieldAn<span>.</span><span>value</span><span>(</span><span>)</span><span>)</span><span>;</span>
            <span>}</span>
        <span>}</span> <span>catch</span> <span>(</span><span>Exception</span> e<span>)</span> <span>{</span>
            e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>

<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br></div></div><p>输出结果</p>
<div><pre><code>类上的注解值 === 定义在类接口枚举类上的注解元素value的默认值
方法上的注解值 === 测试方法
参数上的注解值 === 定义在参数上的注解元素value的默认值
参数值 === 改变默认参数
字段上的注解值 === 定义在字段上的注解元素value的默认值
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h3 id="四-注解的使用"> （四）注解的使用</h3>
<p>注解如何使用，完全由程序自己决定。例如，JUnit是一个测试框架，它会自动运行所有标记为<code>@Test</code>的方法。</p>
<p>我们来看一个<code>@Range</code>注解，我们希望用它来定义一个<code>String</code>字段的规则：字段长度满足<code>@Range</code>的参数定义：</p>
<div><pre><code><span>@Retention</span><span>(</span><span>RetentionPolicy</span><span>.</span>RUNTIME<span>)</span>
<span>@Target</span><span>(</span><span>ElementType</span><span>.</span>FIELD<span>)</span>
<span>public</span> <span>@interface</span> <span>Range</span> <span>{</span>
    <span>int</span> <span>min</span><span>(</span><span>)</span> <span>default</span> <span>0</span><span>;</span>
    <span>int</span> <span>max</span><span>(</span><span>)</span> <span>default</span> <span>255</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>在某个JavaBean中，我们可以使用该注解：</p>
<div><pre><code><span>public</span> <span>class</span> <span>Person</span> <span>{</span>
    <span>@Range</span><span>(</span>min<span>=</span><span>1</span><span>,</span> max<span>=</span><span>20</span><span>)</span>
    <span>public</span> <span>String</span> name<span>;</span>

    <span>@Range</span><span>(</span>max<span>=</span><span>10</span><span>)</span>
    <span>public</span> <span>String</span> city<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>但是，定义了注解，本身对程序逻辑没有任何影响。我们必须自己编写代码来使用注解。这里，我们编写一个<code>Person</code>实例的检查方法，它可以检查<code>Person</code>实例的<code>String</code>字段长度是否满足<code>@Range</code>的定义：</p>
<div><pre><code><span>void</span> <span>check</span><span>(</span><span>Person</span> person<span>)</span> <span>throws</span> <span>IllegalArgumentException</span><span>,</span> <span>ReflectiveOperationException</span> <span>{</span>
    <span>// 遍历所有Field:</span>
    <span>for</span> <span>(</span><span>Field</span> field <span>:</span> person<span>.</span><span>getClass</span><span>(</span><span>)</span><span>.</span><span>getFields</span><span>(</span><span>)</span><span>)</span> <span>{</span>
        <span>// 获取Field定义的@Range:</span>
        <span>Range</span> range <span>=</span> field<span>.</span><span>getAnnotation</span><span>(</span><span>Range</span><span>.</span><span>class</span><span>)</span><span>;</span>
        <span>// 如果@Range存在:</span>
        <span>if</span> <span>(</span>range <span>!=</span> <span>null</span><span>)</span> <span>{</span>
            <span>// 获取Field的值:</span>
            <span>Object</span> value <span>=</span> field<span>.</span><span>get</span><span>(</span>person<span>)</span><span>;</span>
            <span>// 如果值是String:</span>
            <span>if</span> <span>(</span>value <span>instanceof</span> <span>String</span><span>)</span> <span>{</span>
                <span>String</span> s <span>=</span> <span>(</span><span>String</span><span>)</span> value<span>;</span>
                <span>// 判断值是否满足@Range的min/max:</span>
                <span>if</span> <span>(</span>s<span>.</span><span>length</span><span>(</span><span>)</span> <span>&lt;</span> range<span>.</span><span>min</span><span>(</span><span>)</span> <span>||</span> s<span>.</span><span>length</span><span>(</span><span>)</span> <span>></span> range<span>.</span><span>max</span><span>(</span><span>)</span><span>)</span> <span>{</span>
                    <span>throw</span> <span>new</span> <span>IllegalArgumentException</span><span>(</span><span>"Invalid field: "</span> <span>+</span> field<span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>
                <span>}</span>
            <span>}</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><p>这样一来，我们通过<code>@Range</code>注解，配合<code>check()</code>方法，就可以完成<code>Person</code>实例的检查。注意检查逻辑完全是我们自己编写的，JVM不会自动给注解添加任何额外的逻辑。</p>
<h2 id="十一、annotation"> 十一、Annotation</h2>
<p>如果一来就看Annotation 架构可能就很懵逼了，但是学习了上面的相关知识再来看就很清晰了</p>
<p>Annotation接口中有下面这句话来描述注解：Annotation 是所有注解继承的公共接口</p>
<div><pre><code><span>The</span> common <span>interface</span> extended by all annotation types<span>.</span>
</code></pre>
<div><span>1</span><br></div></div><p>注解本质是一个继承了Annotation的特殊接口，其具体实现类是Java运行时生成的动态代理类。而我们通过反射获取注解时，返回的是Java运行时生成的动态代理对象$Proxy1。通过代理对象调用自定义注解（接口）的方法，会最终调用AnnotationInvocationHandler的invoke方法。该方法会从memberValues这个Map中索引出对应的值。而memberValues的来源是Java常量池。</p>
<h3 id="一-annotation-架构图"> （一）Annotation 架构图</h3>
<img src="./assets/java-03.png" style="zoom:80%;" />
<p>从图看出：</p>
<p>1、 <mark>所有注解本质上都继承自Annotation</mark></p>
<p>2、1 个 Annotation 和 1 个 RetentionPolicy 关联</p>
<ul>
<li>RetentionPolicy 是 Enum 枚举类型，它用来指定 Annotation 的策略。通俗点说，就是不同 RetentionPolicy 类型的 Annotation 的作用域不同</li>
<li>可以理解为：每1个Annotation对象，都会有唯一的RetentionPolicy属性</li>
</ul>
<p>3、 1 个 Annotation 和 1~n 个 ElementType 关联</p>
<ul>
<li>ElementType 是 Enum 枚举类型，它用来指定 Annotation 的类型</li>
<li>可以理解为：对于每 1 个 Annotation 对象，可以有若干个 ElementType 属性。</li>
</ul>
<h3 id="二-annotation-组成部分"> （二）Annotation 组成部分</h3>
<div><pre><code><span>//Annotation.java</span>

<span>package</span> <span>java<span>.</span>lang<span>.</span>annotation</span><span>;</span>
<span>public</span> <span>interface</span> <span>Annotation</span> <span>{</span>

    <span>boolean</span> <span>equals</span><span>(</span><span>Object</span> obj<span>)</span><span>;</span>

    <span>int</span> <span>hashCode</span><span>(</span><span>)</span><span>;</span>

    <span>String</span> <span>toString</span><span>(</span><span>)</span><span>;</span>

    <span>Class</span><span><span>&lt;</span><span>?</span> <span>extends</span> <span>Annotation</span><span>></span></span> <span>annotationType</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><div><pre><code><span>//ElementType.java</span>

<span>package</span> <span>java<span>.</span>lang<span>.</span>annotation</span><span>;</span>
<span>public</span> <span>enum</span> <span>ElementType</span> <span>{</span>
   <span>/**标明该注解可以用于类、接口（包括注解类型）或enum声明*/</span>
   TYPE<span>,</span>
 
   <span>/** 标明该注解可以用于字段(域)声明，包括enum实例 */</span>
   FIELD<span>,</span>
 
   <span>/** 标明该注解可以用于方法声明 */</span>
   METHOD<span>,</span>
 
   <span>/** 标明该注解可以用于参数声明 */</span>
   PARAMETER<span>,</span>
 
   <span>/** 标明注解可以用于构造函数声明 */</span>
   CONSTRUCTOR<span>,</span>
 
   <span>/** 标明注解可以用于局部变量声明 */</span>
   LOCAL_VARIABLE<span>,</span>
 
   <span>/** 标明注解可以用于注解声明(应用于另一个注解上)*/</span>
   ANNOTATION_TYPE<span>,</span>
 
   <span>/** 标明注解可以用于包声明 */</span>
   PACKAGE<span>,</span>
 
   <span>/**
    * 标明注解可以用于类型参数声明（1.8新加入）
    * @since 1.8
    */</span>
   TYPE_PARAMETER<span>,</span>
 
   <span>/**
    * 类型使用声明（1.8新加入)
    * @since 1.8
    */</span>
   TYPE_USE
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br></div></div><div><pre><code><span>//RetentionPolicy.java</span>

<span>package</span> <span>java<span>.</span>lang<span>.</span>annotation</span><span>;</span>
<span>public</span> <span>enum</span> <span>RetentionPolicy</span> <span>{</span>
   <span>/** Annotation信息仅存在于编译器处理期间，编译器处理完之后就没有该Annotation信息了 */</span>
    SOURCE<span>,</span>            

    <span>/** 编译器将Annotation存储于类对应的.class文件中。默认行为 */</span>
    CLASS<span>,</span>             

    <span>/** 编译器将Annotation存储于class文件中，并且可由JVM读入 */</span>
    RUNTIME           
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h2 id="十二、注解与反射机制"> 十二、注解与反射机制</h2>
<p>前面经过反编译后，我们知道Java所有注解都继承了Annotation接口，也就是说　Java使用Annotation接口代表注解元素，该接口是所有Annotation类型的父接口。同时为了运行时能准确获取到注解的相关信息，Java在java.lang.reflect 反射包下新增了AnnotatedElement接口，它主要用于表示目前正在 VM 中运行的程序中已使用注解的元素，通过该接口提供的方法可以利用反射技术地读取注解的信息，如反射包的Constructor类、Field类、Method类、Package类和Class类都实现了AnnotatedElement接口，它简要含义如下：</p>
<p>Class：类的Class对象定义</p>
<p>Constructor：代表类的构造器定义</p>
<p>Field：代表类的成员变量定义</p>
<p>Method：代表类的方法定义</p>
<p>Package：代表类的包定义</p>
<p>下面是AnnotatedElement中相关的API方法，以上5个类都实现以下的方法</p>
<table>
<thead>
<tr>
<th>返回值</th>
<th>方法名称</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>&lt;A extends Annotation&gt;</code></td>
<td><code>getAnnotation(Class&lt;A&gt; annotationClass)</code></td>
<td>该元素如果存在指定类型的注解，则返回这些注解，否则返回 null。</td>
</tr>
<tr>
<td><code>Annotation[]</code></td>
<td><code>getAnnotations()</code></td>
<td>返回此元素上存在的所有注解，包括从父类继承的</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>isAnnotationPresent(Class&lt;? extends Annotation&gt; annotationClass)</code></td>
<td>如果指定类型的注解存在于此元素上，则返回 true，否则返回 false。</td>
</tr>
<tr>
<td><code>Annotation[]</code></td>
<td><code>getDeclaredAnnotations()</code></td>
<td>返回直接存在于此元素上的所有注解，注意，不包括父类的注解，调用者可以随意修改返回的数组；这不会对其他调用者返回的数组产生任何影响，没有则返回长度为0的数组</td>
</tr>
</tbody>
</table>
<p>简单案例演示如下：</p>
<div><pre><code>
<span>//继承了A类</span>
<span>@DocumentB</span>
<span>public</span> <span>class</span> <span>DocumentDemo</span> <span>extends</span> <span>A</span><span>{</span>

    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>.</span><span>.</span><span>.</span> args<span>)</span><span>{</span>

        <span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> clazz <span>=</span> <span>DocumentDemo</span><span>.</span><span>class</span><span>;</span>
        <span>//根据指定注解类型获取该注解</span>
        <span>DocumentA</span> documentA<span>=</span>clazz<span>.</span><span>getAnnotation</span><span>(</span><span>DocumentA</span><span>.</span><span>class</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"A:"</span><span>+</span>documentA<span>)</span><span>;</span>

        <span>//获取该元素上的所有注解，包含从父类继承</span>
        <span>Annotation</span><span>[</span><span>]</span> an<span>=</span> clazz<span>.</span><span>getAnnotations</span><span>(</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"an:"</span><span>+</span> <span>Arrays</span><span>.</span><span>toString</span><span>(</span>an<span>)</span><span>)</span><span>;</span>
        <span>//获取该元素上的所有注解，但不包含继承！</span>
        <span>Annotation</span><span>[</span><span>]</span> an2<span>=</span>clazz<span>.</span><span>getDeclaredAnnotations</span><span>(</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"an2:"</span><span>+</span> <span>Arrays</span><span>.</span><span>toString</span><span>(</span>an2<span>)</span><span>)</span><span>;</span>

        <span>//判断注解DocumentA是否在该元素上</span>
        <span>boolean</span> b<span>=</span>clazz<span>.</span><span>isAnnotationPresent</span><span>(</span><span>DocumentA</span><span>.</span><span>class</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"b:"</span><span>+</span>b<span>)</span><span>;</span>

        <span>/**
         执行结果:
         A:@test.DocumentA()
         an:[@test.DocumentA(), @test.DocumentB()]
         an2:[@test.DocumentB()]
         b:true
         */</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br></div></div><h2 id="十三、运行时注解处理器"> 十三、运行时注解处理器</h2>
<p>了解完注解与反射的相关API后，现在通过一个实例来演示利用运行时注解来组装数据库SQL的构建语句的过程</p>
<div><pre><code><span>/**
 * 表注解
 */</span>
<span>@Target</span><span>(</span><span>ElementType</span><span>.</span>TYPE<span>)</span><span>//只能应用于类上</span>
<span>@Retention</span><span>(</span><span>RetentionPolicy</span><span>.</span>RUNTIME<span>)</span><span>//保存到运行时</span>
<span>public</span> <span>@interface</span> <span>DBTable</span> <span>{</span>
    <span>String</span> <span>name</span><span>(</span><span>)</span> <span>default</span> <span>""</span><span>;</span>
<span>}</span>


<span>/**
 * 注解Integer类型的字段
 */</span>
<span>@Target</span><span>(</span><span>ElementType</span><span>.</span>FIELD<span>)</span>
<span>@Retention</span><span>(</span><span>RetentionPolicy</span><span>.</span>RUNTIME<span>)</span>
<span>public</span> <span>@interface</span> <span>SQLInteger</span> <span>{</span>
    <span>//该字段对应数据库表列名</span>
    <span>String</span> <span>name</span><span>(</span><span>)</span> <span>default</span> <span>""</span><span>;</span>
    <span>//嵌套注解</span>
    <span>Constraints</span> <span>constraint</span><span>(</span><span>)</span> <span>default</span> <span>@Constraints</span><span>;</span>
<span>}</span>


<span>/**
 * 注解String类型的字段
 */</span>
<span>@Target</span><span>(</span><span>ElementType</span><span>.</span>FIELD<span>)</span>
<span>@Retention</span><span>(</span><span>RetentionPolicy</span><span>.</span>RUNTIME<span>)</span>
<span>public</span> <span>@interface</span> <span>SQLString</span> <span>{</span>

    <span>//对应数据库表的列名</span>
    <span>String</span> <span>name</span><span>(</span><span>)</span> <span>default</span> <span>""</span><span>;</span>

    <span>//列类型分配的长度，如varchar(30)的30</span>
    <span>int</span> <span>value</span><span>(</span><span>)</span> <span>default</span> <span>0</span><span>;</span>

    <span>Constraints</span> <span>constraint</span><span>(</span><span>)</span> <span>default</span> <span>@Constraints</span><span>;</span>
<span>}</span>


<span>/**
 * 约束注解
 */</span>

<span>@Target</span><span>(</span><span>ElementType</span><span>.</span>FIELD<span>)</span><span>//只能应用在字段上</span>
<span>@Retention</span><span>(</span><span>RetentionPolicy</span><span>.</span>RUNTIME<span>)</span>
<span>public</span> <span>@interface</span> <span>Constraints</span> <span>{</span>
    <span>//判断是否作为主键约束</span>
    <span>boolean</span> <span>primaryKey</span><span>(</span><span>)</span> <span>default</span> <span>false</span><span>;</span>
    <span>//判断是否允许为null</span>
    <span>boolean</span> <span>allowNull</span><span>(</span><span>)</span> <span>default</span> <span>false</span><span>;</span>
    <span>//判断是否唯一</span>
    <span>boolean</span> <span>unique</span><span>(</span><span>)</span> <span>default</span> <span>false</span><span>;</span>
<span>}</span>

<span>/**
 * 数据库表Member对应实例类bean
 */</span>
<span>@DBTable</span><span>(</span>name <span>=</span> <span>"MEMBER"</span><span>)</span>
<span>public</span> <span>class</span> <span>Member</span> <span>{</span>
    <span>//主键ID</span>
    <span>@SQLString</span><span>(</span>name <span>=</span> <span>"ID"</span><span>,</span>value <span>=</span> <span>50</span><span>,</span> constraint <span>=</span> <span>@Constraints</span><span>(</span>primaryKey <span>=</span> <span>true</span><span>)</span><span>)</span>
    <span>private</span> <span>String</span> id<span>;</span>

    <span>@SQLString</span><span>(</span>name <span>=</span> <span>"NAME"</span> <span>,</span> value <span>=</span> <span>30</span><span>)</span>
    <span>private</span> <span>String</span> name<span>;</span>

    <span>@SQLInteger</span><span>(</span>name <span>=</span> <span>"AGE"</span><span>)</span>
    <span>private</span> <span>int</span> age<span>;</span>

    <span>@SQLString</span><span>(</span>name <span>=</span> <span>"DESCRIPTION"</span> <span>,</span>value <span>=</span> <span>150</span> <span>,</span> constraint <span>=</span> <span>@Constraints</span><span>(</span>allowNull <span>=</span> <span>true</span><span>)</span><span>)</span>
    <span>private</span> <span>String</span> description<span>;</span><span>//个人描述</span>

   <span>//省略set get.....</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br></div></div><p>上述定义4个注解，分别是@DBTable(用于类上)、@Constraints(用于字段上)、 @SQLString(用于字段上)、@SQLString(用于字段上)并在Member类中使用这些注解，这些注解的作用的是用于帮助注解处理器生成创建数据库表MEMBER的构建语句，在这里有点需要注意的是，我们使用了嵌套注解@Constraints，该注解主要用于判断字段是否为null或者字段是否唯一。必须清楚认识到上述提供的注解生命周期必须为<code>@Retention(RetentionPolicy.RUNTIME)</code>，即运行时，这样才可以使用反射机制获取其信息。有了上述注解和使用，剩余的就是编写上述的注解处理器了，前面我们聊了很多注解，其处理器要么是Java自身已提供、要么是框架已提供的，我们自己都没有涉及到注解处理器的编写，但上述定义处理SQL的注解，其处理器必须由我们自己编写了，如下</p>
<div><pre><code><span>package</span> <span>test</span><span>;</span>
<span>import</span> <span>java<span>.</span>lang<span>.</span>annotation<span>.</span></span><span>Annotation</span><span>;</span>
<span>import</span> <span>java<span>.</span>lang<span>.</span>reflect<span>.</span></span><span>Field</span><span>;</span>
<span>import</span> <span>java<span>.</span>util<span>.</span></span><span>ArrayList</span><span>;</span>
<span>import</span> <span>java<span>.</span>util<span>.</span></span><span>List</span><span>;</span>

<span>/**
 * 运行时注解处理器，构造表创建语句
 */</span>
<span>public</span> <span>class</span> <span>TableCreator</span> <span>{</span>

  <span>public</span> <span>static</span> <span>String</span> <span>createTableSql</span><span>(</span><span>String</span> className<span>)</span> <span>throws</span> <span>ClassNotFoundException</span> <span>{</span>
    <span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> cl <span>=</span> <span>Class</span><span>.</span><span>forName</span><span>(</span>className<span>)</span><span>;</span>
    <span>DBTable</span> dbTable <span>=</span> cl<span>.</span><span>getAnnotation</span><span>(</span><span>DBTable</span><span>.</span><span>class</span><span>)</span><span>;</span>
    <span>//如果没有表注解，直接返回</span>
    <span>if</span><span>(</span>dbTable <span>==</span> <span>null</span><span>)</span> <span>{</span>
      <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>
              <span>"No DBTable annotations in class "</span> <span>+</span> className<span>)</span><span>;</span>
      <span>return</span> <span>null</span><span>;</span>
    <span>}</span>
    <span>String</span> tableName <span>=</span> dbTable<span>.</span><span>name</span><span>(</span><span>)</span><span>;</span>
    <span>// If the name is empty, use the Class name:</span>
    <span>if</span><span>(</span>tableName<span>.</span><span>length</span><span>(</span><span>)</span> <span>&lt;</span> <span>1</span><span>)</span>
      tableName <span>=</span> cl<span>.</span><span>getName</span><span>(</span><span>)</span><span>.</span><span>toUpperCase</span><span>(</span><span>)</span><span>;</span>
    <span>List</span><span><span>&lt;</span><span>String</span><span>></span></span> columnDefs <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>String</span><span>></span></span><span>(</span><span>)</span><span>;</span>
    <span>//通过Class类API获取到所有成员字段</span>
    <span>for</span><span>(</span><span>Field</span> field <span>:</span> cl<span>.</span><span>getDeclaredFields</span><span>(</span><span>)</span><span>)</span> <span>{</span>
      <span>String</span> columnName <span>=</span> <span>null</span><span>;</span>
      <span>//获取字段上的注解</span>
      <span>Annotation</span><span>[</span><span>]</span> anns <span>=</span> field<span>.</span><span>getDeclaredAnnotations</span><span>(</span><span>)</span><span>;</span>
      <span>if</span><span>(</span>anns<span>.</span>length <span>&lt;</span> <span>1</span><span>)</span>
        <span>continue</span><span>;</span> <span>// Not a db table column</span>

      <span>//判断注解类型</span>
      <span>if</span><span>(</span>anns<span>[</span><span>0</span><span>]</span> <span>instanceof</span> <span>SQLInteger</span><span>)</span> <span>{</span>
        <span>SQLInteger</span> sInt <span>=</span> <span>(</span><span>SQLInteger</span><span>)</span> anns<span>[</span><span>0</span><span>]</span><span>;</span>
        <span>//获取字段对应列名称，如果没有就是使用字段名称替代</span>
        <span>if</span><span>(</span>sInt<span>.</span><span>name</span><span>(</span><span>)</span><span>.</span><span>length</span><span>(</span><span>)</span> <span>&lt;</span> <span>1</span><span>)</span>
          columnName <span>=</span> field<span>.</span><span>getName</span><span>(</span><span>)</span><span>.</span><span>toUpperCase</span><span>(</span><span>)</span><span>;</span>
        <span>else</span>
          columnName <span>=</span> sInt<span>.</span><span>name</span><span>(</span><span>)</span><span>;</span>
        <span>//构建语句</span>
        columnDefs<span>.</span><span>add</span><span>(</span>columnName <span>+</span> <span>" INT"</span> <span>+</span>
                <span>getConstraints</span><span>(</span>sInt<span>.</span><span>constraint</span><span>(</span><span>)</span><span>)</span><span>)</span><span>;</span>
      <span>}</span>
      <span>//判断String类型</span>
      <span>if</span><span>(</span>anns<span>[</span><span>0</span><span>]</span> <span>instanceof</span> <span>SQLString</span><span>)</span> <span>{</span>
        <span>SQLString</span> sString <span>=</span> <span>(</span><span>SQLString</span><span>)</span> anns<span>[</span><span>0</span><span>]</span><span>;</span>
        <span>// Use field name if name not specified.</span>
        <span>if</span><span>(</span>sString<span>.</span><span>name</span><span>(</span><span>)</span><span>.</span><span>length</span><span>(</span><span>)</span> <span>&lt;</span> <span>1</span><span>)</span>
          columnName <span>=</span> field<span>.</span><span>getName</span><span>(</span><span>)</span><span>.</span><span>toUpperCase</span><span>(</span><span>)</span><span>;</span>
        <span>else</span>
          columnName <span>=</span> sString<span>.</span><span>name</span><span>(</span><span>)</span><span>;</span>
        columnDefs<span>.</span><span>add</span><span>(</span>columnName <span>+</span> <span>" VARCHAR("</span> <span>+</span>
                sString<span>.</span><span>value</span><span>(</span><span>)</span> <span>+</span> <span>")"</span> <span>+</span>
                <span>getConstraints</span><span>(</span>sString<span>.</span><span>constraint</span><span>(</span><span>)</span><span>)</span><span>)</span><span>;</span>
      <span>}</span>


    <span>}</span>
    <span>//数据库表构建语句</span>
    <span>StringBuilder</span> createCommand <span>=</span> <span>new</span> <span>StringBuilder</span><span>(</span>
            <span>"CREATE TABLE "</span> <span>+</span> tableName <span>+</span> <span>"("</span><span>)</span><span>;</span>
    <span>for</span><span>(</span><span>String</span> columnDef <span>:</span> columnDefs<span>)</span>
      createCommand<span>.</span><span>append</span><span>(</span><span>"\n    "</span> <span>+</span> columnDef <span>+</span> <span>","</span><span>)</span><span>;</span>

    <span>// Remove trailing comma</span>
    <span>String</span> tableCreate <span>=</span> createCommand<span>.</span><span>substring</span><span>(</span>
            <span>0</span><span>,</span> createCommand<span>.</span><span>length</span><span>(</span><span>)</span> <span>-</span> <span>1</span><span>)</span> <span>+</span> <span>");"</span><span>;</span>
    <span>return</span> tableCreate<span>;</span>
  <span>}</span>


    <span>/**
     * 判断该字段是否有其他约束
     * @param con
     * @return
     */</span>
  <span>private</span> <span>static</span> <span>String</span> <span>getConstraints</span><span>(</span><span>Constraints</span> con<span>)</span> <span>{</span>
    <span>String</span> constraints <span>=</span> <span>""</span><span>;</span>
    <span>if</span><span>(</span><span>!</span>con<span>.</span><span>allowNull</span><span>(</span><span>)</span><span>)</span>
      constraints <span>+=</span> <span>" NOT NULL"</span><span>;</span>
    <span>if</span><span>(</span>con<span>.</span><span>primaryKey</span><span>(</span><span>)</span><span>)</span>
      constraints <span>+=</span> <span>" PRIMARY KEY"</span><span>;</span>
    <span>if</span><span>(</span>con<span>.</span><span>unique</span><span>(</span><span>)</span><span>)</span>
      constraints <span>+=</span> <span>" UNIQUE"</span><span>;</span>
    <span>return</span> constraints<span>;</span>
  <span>}</span>

  <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>
    <span>String</span><span>[</span><span>]</span> arg<span>=</span><span>{</span><span>"test.Member"</span><span>}</span><span>;</span>
    <span>for</span><span>(</span><span>String</span> className <span>:</span> arg<span>)</span> <span>{</span>
      <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"Table Creation SQL for "</span> <span>+</span>
              className <span>+</span> <span>" is :\n"</span> <span>+</span> <span>createTableSql</span><span>(</span>className<span>)</span><span>)</span><span>;</span>
    <span>}</span>

    <span>/**
     * 输出结果：
     Table Creation SQL for test.Member is :
     CREATE TABLE MEMBER(
     ID VARCHAR(50) NOT NULL PRIMARY KEY,
     NAME VARCHAR(30) NOT NULL,
     AGE INT NOT NULL,
     DESCRIPTION VARCHAR(150)
     );
     */</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br><span>96</span><br><span>97</span><br><span>98</span><br><span>99</span><br><span>100</span><br><span>101</span><br><span>102</span><br><span>103</span><br><span>104</span><br><span>105</span><br><span>106</span><br><span>107</span><br><span>108</span><br></div></div><p>如果对反射比较熟悉的同学，上述代码就相对简单了，我们通过传递Member的全路径后通过Class.forName()方法获取到Member的class对象，然后利用Class对象中的方法获取所有成员字段Field，最后利用<code>field.getDeclaredAnnotations()</code>遍历每个Field上的注解再通过注解的类型判断来构建建表的SQL语句。这便是利用注解结合反射来构建SQL语句的简单的处理器模型，是否已回想起Hibernate？</p>
<h2 id="十四、java-8中注解增强"> 十四、Java 8中注解增强</h2>
<h3 id="一-元注解-repeatable"> （一）元注解@Repeatable</h3>
<p>元注解@Repeatable是JDK1.8新加入的，它表示在同一个位置重复相同的注解。在没有该注解前，一般是无法在同一个类型上使用相同的注解的</p>
<div><pre><code><span>//Java8前无法这样使用</span>
<span>@FilterPath</span><span>(</span><span>"/web/update"</span><span>)</span>
<span>@FilterPath</span><span>(</span><span>"/web/add"</span><span>)</span>
<span>public</span> <span>class</span> <span>A</span> <span>{</span>
    
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>Java8前如果是想实现类似的功能，我们需要在定义@FilterPath注解时定义一个数组元素接收多个值如下</p>
<div><pre><code><span>@Target</span><span>(</span><span>ElementType</span><span>.</span>TYPE<span>)</span>
<span>@Retention</span><span>(</span><span>RetentionPolicy</span><span>.</span>RUNTIME<span>)</span>
<span>public</span> <span>@interface</span> <span>FilterPath</span> <span>{</span>
    <span>String</span> <span>[</span><span>]</span> <span>value</span><span>(</span><span>)</span><span>;</span>
<span>}</span>

<span>//使用</span>
<span>@FilterPath</span><span>(</span><span>{</span><span>"/update"</span><span>,</span><span>"/add"</span><span>}</span><span>)</span>
<span>public</span> <span>class</span> <span>A</span> <span>{</span> 
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>但在Java8新增了@Repeatable注解后就可以采用如下的方式定义并使用了</p>
<div><pre><code><span>//使用Java8新增@Repeatable原注解</span>
<span>@Target</span><span>(</span><span>{</span><span>ElementType</span><span>.</span>TYPE<span>,</span><span>ElementType</span><span>.</span>FIELD<span>,</span><span>ElementType</span><span>.</span>METHOD<span>}</span><span>)</span>
<span>@Retention</span><span>(</span><span>RetentionPolicy</span><span>.</span>RUNTIME<span>)</span>
<span>@Repeatable</span><span>(</span><span>FilterPaths</span><span>.</span><span>class</span><span>)</span><span>//参数指明接收的注解class</span>
<span>public</span> <span>@interface</span> <span>FilterPath</span> <span>{</span>
    <span>String</span>  <span>value</span><span>(</span><span>)</span><span>;</span>
<span>}</span>

<span>@Target</span><span>(</span><span>ElementType</span><span>.</span>TYPE<span>)</span>
<span>@Retention</span><span>(</span><span>RetentionPolicy</span><span>.</span>RUNTIME<span>)</span>
<span>@interface</span> <span>FilterPaths</span> <span>{</span>
    <span>FilterPath</span><span>[</span><span>]</span> <span>value</span><span>(</span><span>)</span><span>;</span>
<span>}</span>

<span>//使用案例</span>
<span>@FilterPath</span><span>(</span><span>"/web/update"</span><span>)</span>
<span>@FilterPath</span><span>(</span><span>"/web/add"</span><span>)</span>
<span>@FilterPath</span><span>(</span><span>"/web/delete"</span><span>)</span>
<span>class</span> <span>A</span><span>{</span> 
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><p>我们可以简单理解为通过使用@Repeatable后，将使用@FilterPaths注解作为接收同一个类型上重复注解的容器，而每个@FilterPath则负责保存指定的路径串。</p>
<p>为了处理上述的新增注解，Java8还在<code>AnnotatedElement</code>接口新增了<code>getDeclaredAnnotationsByType()</code>和 <code>getAnnotationsByType()</code>两个方法并在接口给出了默认实现，在指定@Repeatable的注解时，可以通过这两个方法获取到注解相关信息。</p>
<p>但请注意:</p>
<ul>
<li>旧版API中的getDeclaredAnnotation()和 getAnnotation()是不对@Repeatable注解的处理的(除非该注解没有在同一个声明上重复出现)。</li>
<li>getDeclaredAnnotationsByType方法获取到的注解不包括父类，其实当 getAnnotationsByType()方法调用时，其内部先执行了getDeclaredAnnotationsByType方法，只有当前类不存在指定注解时，getAnnotationsByType()才会继续从其父类寻找，但请注意如果@FilterPath和@FilterPaths没有使用了@Inherited的话，仍然无法获取。下面通过代码来演示：</li>
</ul>
<div><pre><code>
<span>//使用Java8新增@Repeatable原注解</span>
<span>@Target</span><span>(</span><span>{</span><span>ElementType</span><span>.</span>TYPE<span>,</span><span>ElementType</span><span>.</span>FIELD<span>,</span><span>ElementType</span><span>.</span>METHOD<span>}</span><span>)</span>
<span>@Retention</span><span>(</span><span>RetentionPolicy</span><span>.</span>RUNTIME<span>)</span>
<span>@Repeatable</span><span>(</span><span>FilterPaths</span><span>.</span><span>class</span><span>)</span>
<span>public</span> <span>@interface</span> <span>FilterPath</span> <span>{</span>
    <span>String</span>  <span>value</span><span>(</span><span>)</span><span>;</span>
<span>}</span>


<span>@Target</span><span>(</span><span>ElementType</span><span>.</span>TYPE<span>)</span>
<span>@Retention</span><span>(</span><span>RetentionPolicy</span><span>.</span>RUNTIME<span>)</span>
<span>@interface</span> <span>FilterPaths</span> <span>{</span>
    <span>FilterPath</span><span>[</span><span>]</span> <span>value</span><span>(</span><span>)</span><span>;</span>
<span>}</span>

<span>@FilterPath</span><span>(</span><span>"/web/list"</span><span>)</span>
<span>class</span> <span>C</span> <span>{</span> <span>}</span>

<span>//使用案例</span>
<span>@FilterPath</span><span>(</span><span>"/web/update"</span><span>)</span>
<span>@FilterPath</span><span>(</span><span>"/web/add"</span><span>)</span>
<span>@FilterPath</span><span>(</span><span>"/web/delete"</span><span>)</span>
<span>class</span> <span>A</span> <span>extends</span> <span>C</span><span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>

        <span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> clazz <span>=</span> <span>A</span><span>.</span><span>class</span><span>;</span>
        <span>//通过getAnnotationsByType方法获取所有重复注解</span>
        <span>FilterPath</span><span>[</span><span>]</span> annotationsByType <span>=</span> clazz<span>.</span><span>getAnnotationsByType</span><span>(</span><span>FilterPath</span><span>.</span><span>class</span><span>)</span><span>;</span>
        <span>FilterPath</span><span>[</span><span>]</span> annotationsByType2 <span>=</span> clazz<span>.</span><span>getDeclaredAnnotationsByType</span><span>(</span><span>FilterPath</span><span>.</span><span>class</span><span>)</span><span>;</span>
        <span>if</span> <span>(</span>annotationsByType <span>!=</span> <span>null</span><span>)</span> <span>{</span>
            <span>for</span> <span>(</span><span>FilterPath</span> filter <span>:</span> annotationsByType<span>)</span> <span>{</span>
                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"1:"</span><span>+</span>filter<span>.</span><span>value</span><span>(</span><span>)</span><span>)</span><span>;</span>
            <span>}</span>
        <span>}</span>

        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"-----------------"</span><span>)</span><span>;</span>

        <span>if</span> <span>(</span>annotationsByType2 <span>!=</span> <span>null</span><span>)</span> <span>{</span>
            <span>for</span> <span>(</span><span>FilterPath</span> filter <span>:</span> annotationsByType2<span>)</span> <span>{</span>
                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"2:"</span><span>+</span>filter<span>.</span><span>value</span><span>(</span><span>)</span><span>)</span><span>;</span>
            <span>}</span>
        <span>}</span>


        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"使用getAnnotation的结果:"</span><span>+</span>clazz<span>.</span><span>getAnnotation</span><span>(</span><span>FilterPath</span><span>.</span><span>class</span><span>)</span><span>)</span><span>;</span>


        <span>/**
         * 执行结果(当前类拥有该注解FilterPath,则不会从C父类寻找)
         1:/web/update
         1:/web/add
         1:/web/delete
         -----------------
         2:/web/update
         2:/web/add
         2:/web/delete
         使用getAnnotation的结果:null
         */</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br></div></div><p>从执行结果来看如果当前类拥有该注解@FilterPath,则getAnnotationsByType方法不会从C父类寻找，下面看看另外一种情况，即A类上没有@FilterPath注解</p>
<div><pre><code>
<span>//使用Java8新增@Repeatable原注解</span>
<span>@Target</span><span>(</span><span>{</span><span>ElementType</span><span>.</span>TYPE<span>,</span><span>ElementType</span><span>.</span>FIELD<span>,</span><span>ElementType</span><span>.</span>METHOD<span>}</span><span>)</span>
<span>@Retention</span><span>(</span><span>RetentionPolicy</span><span>.</span>RUNTIME<span>)</span>
<span>@Inherited</span> <span>//添加可继承元注解</span>
<span>@Repeatable</span><span>(</span><span>FilterPaths</span><span>.</span><span>class</span><span>)</span>
<span>public</span> <span>@interface</span> <span>FilterPath</span> <span>{</span>
    <span>String</span>  <span>value</span><span>(</span><span>)</span><span>;</span>
<span>}</span>


<span>@Target</span><span>(</span><span>ElementType</span><span>.</span>TYPE<span>)</span>
<span>@Retention</span><span>(</span><span>RetentionPolicy</span><span>.</span>RUNTIME<span>)</span>
<span>@Inherited</span> <span>//添加可继承元注解</span>
<span>@interface</span> <span>FilterPaths</span> <span>{</span>
    <span>FilterPath</span><span>[</span><span>]</span> <span>value</span><span>(</span><span>)</span><span>;</span>
<span>}</span>

<span>@FilterPath</span><span>(</span><span>"/web/list"</span><span>)</span>
<span>@FilterPath</span><span>(</span><span>"/web/getList"</span><span>)</span>
<span>class</span> <span>C</span> <span>{</span> <span>}</span>

<span>//A上不使用@FilterPath注解,getAnnotationsByType将会从父类查询</span>
<span>class</span> <span>A</span> <span>extends</span> <span>C</span><span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>

        <span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> clazz <span>=</span> <span>A</span><span>.</span><span>class</span><span>;</span>
        <span>//通过getAnnotationsByType方法获取所有重复注解</span>
        <span>FilterPath</span><span>[</span><span>]</span> annotationsByType <span>=</span> clazz<span>.</span><span>getAnnotationsByType</span><span>(</span><span>FilterPath</span><span>.</span><span>class</span><span>)</span><span>;</span>
        <span>FilterPath</span><span>[</span><span>]</span> annotationsByType2 <span>=</span> clazz<span>.</span><span>getDeclaredAnnotationsByType</span><span>(</span><span>FilterPath</span><span>.</span><span>class</span><span>)</span><span>;</span>
        <span>if</span> <span>(</span>annotationsByType <span>!=</span> <span>null</span><span>)</span> <span>{</span>
            <span>for</span> <span>(</span><span>FilterPath</span> filter <span>:</span> annotationsByType<span>)</span> <span>{</span>
                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"1:"</span><span>+</span>filter<span>.</span><span>value</span><span>(</span><span>)</span><span>)</span><span>;</span>
            <span>}</span>
        <span>}</span>

        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"-----------------"</span><span>)</span><span>;</span>

        <span>if</span> <span>(</span>annotationsByType2 <span>!=</span> <span>null</span><span>)</span> <span>{</span>
            <span>for</span> <span>(</span><span>FilterPath</span> filter <span>:</span> annotationsByType2<span>)</span> <span>{</span>
                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"2:"</span><span>+</span>filter<span>.</span><span>value</span><span>(</span><span>)</span><span>)</span><span>;</span>
            <span>}</span>
        <span>}</span>


        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"使用getAnnotation的结果:"</span><span>+</span>clazz<span>.</span><span>getAnnotation</span><span>(</span><span>FilterPath</span><span>.</span><span>class</span><span>)</span><span>)</span><span>;</span>


        <span>/**
         * 执行结果(当前类没有@FilterPath,getAnnotationsByType方法从C父类寻找)
         1:/web/list
         1:/web/getList
         -----------------
         使用getAnnotation的结果:null
         */</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br></div></div><p>注意定义@FilterPath和@FilterPath时必须指明@Inherited，getAnnotationsByType方法否则依旧无法从父类获取@FilterPath注解，这是为什么呢，不妨看看getAnnotationsByType方法的实现源码：</p>
<div><pre><code><span>//接口默认实现方法</span>
<span>default</span> <span><span>&lt;</span><span>T</span> <span>extends</span> <span>Annotation</span><span>></span></span> <span>T</span><span>[</span><span>]</span> <span>getAnnotationsByType</span><span>(</span><span>Class</span><span><span>&lt;</span><span>T</span><span>></span></span> annotationClass<span>)</span> <span>{</span>
<span>//先调用getDeclaredAnnotationsByType方法</span>
<span>T</span><span>[</span><span>]</span> result <span>=</span> <span>getDeclaredAnnotationsByType</span><span>(</span>annotationClass<span>)</span><span>;</span>

<span>//判断当前类获取到的注解数组是否为0</span>
<span>if</span> <span>(</span>result<span>.</span>length <span>==</span> <span>0</span> <span>&amp;&amp;</span> <span>this</span> <span>instanceof</span> <span>Class</span> <span>&amp;&amp;</span> 
<span>//判断定义注解上是否使用了@Inherited元注解 </span>
 <span>AnnotationType</span><span>.</span><span>getInstance</span><span>(</span>annotationClass<span>)</span><span>.</span><span>isInherited</span><span>(</span><span>)</span><span>)</span> <span>{</span> <span>// Inheritable</span>
        <span>//从父类获取</span>
       <span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> superClass <span>=</span> <span>(</span><span>(</span><span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span><span>)</span> <span>this</span><span>)</span><span>.</span><span>getSuperclass</span><span>(</span><span>)</span><span>;</span>
   <span>if</span> <span>(</span>superClass <span>!=</span> <span>null</span><span>)</span> <span>{</span>
      result <span>=</span> superClass<span>.</span><span>getAnnotationsByType</span><span>(</span>annotationClass<span>)</span><span>;</span>
       <span>}</span>
   <span>}</span>

   <span>return</span> result<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><h3 id="二-新增的两种elementtype"> （二）新增的两种ElementType</h3>
<p>在Java8中 ElementType 新增两个枚举成员，TYPE_PARAMETER 和 TYPE_USE ，在Java8前注解只能标注在一个声明(如字段、类、方法)上，Java8后，新增的TYPE_PARAMETER可以用于标注类型参数，而TYPE_USE则可以用于标注任意类型(不包括class)。如下所示</p>
<div><pre><code><span>//TYPE_PARAMETER 标注在类型参数上</span>
<span>class</span> <span>D</span><span>&lt;</span><span>@Parameter</span> <span>T</span><span>></span> <span>{</span> <span>}</span>

<span>//TYPE_USE则可以用于标注任意类型(不包括class)</span>
<span>//用于父类或者接口</span>
<span>class</span> <span>Image</span> <span>implements</span> <span>@Rectangular</span> <span>Shape</span> <span>{</span> <span>}</span>

<span>//用于构造函数</span>
<span>new</span> <span>@Path</span> <span>String</span><span>(</span><span>"/usr/bin"</span><span>)</span>

<span>//用于强制转换和instanceof检查,注意这些注解中用于外部工具，它们不会对类型转换或者instanceof的检查行为带来任何影响。</span>
<span>String</span> path<span>=</span><span>(</span><span>@Path</span> <span>String</span><span>)</span>input<span>;</span>
<span>if</span><span>(</span>input <span>instanceof</span> <span>@Path</span> <span>String</span><span>)</span>

<span>//用于指定异常</span>
<span>public</span> <span>Person</span> <span>read</span><span>(</span><span>)</span> <span>throws</span> <span>@Localized</span> <span>IOException</span><span>.</span>

<span>//用于通配符绑定</span>
<span>List</span><span>&lt;</span><span>@ReadOnly</span> <span>?</span> <span>extends</span> <span>Person</span><span>></span>
<span>List</span><span>&lt;</span><span>?</span> <span>extends</span> <span>@ReadOnly</span> <span>Person</span><span>></span>

<span>@NotNull</span> <span>String</span><span>.</span><span>class</span> <span>//非法，不能标注class</span>
<span>import</span> <span>java<span>.</span>lang<span>.</span></span>@<span>NotNull</span> <span>String</span> <span>//非法，不能标注</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><p>这里主要说明一下TYPE_USE，类型注解用来支持在Java的程序中做强类型检查，配合第三方插件工具（如Checker Framework），可以在编译期检测出runtime error（如UnsupportedOperationException、NullPointerException异常），避免异常延续到运行期才发现，从而提高代码质量，这就是类型注解的主要作用。</p>
<p>总之Java 8 新增加了两个注解的元素类型ElementType.TYPE_USE 和ElementType.TYPE_PARAMETER ，通过它们，我们可以把注解应用到各种新场合中。</p>
<div><p>参考</p>
<p><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1255945389098144" target="_blank" rel="noopener noreferrer">廖雪峰Java教程 - 注解</a></p>
<p><a href="https://www.runoob.com/w3cnote/java-annotation.html" target="_blank" rel="noopener noreferrer">菜鸟教程 - 注解</a></p>
<p><a href="https://blog.csdn.net/javazejian/article/details/71860633?ops_request_misc=%25257B%252522request%25255Fid%252522%25253A%252522161283974716780262542169%252522%25252C%252522scm%252522%25253A%25252220140713.130102334..%252522%25257D&amp;request_id=161283974716780262542169&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-4-71860633.pc_search_result_no_baidu_js&amp;utm_term=java%25E6%25B3%25A8%25E8%25A7%25A3" target="_blank" rel="noopener noreferrer">zejian的博客</a></p>
</div>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <category term="Java"/>
    <contributor>
      <name>南辞</name>
    </contributor>
    <published>2021-02-16T17:39:43.000Z</published>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">JavaSE-集合</title>
    <id>http://qiqi.dreamagain.top/program/backend/java/collection/</id>
    <link href="http://qiqi.dreamagain.top/program/backend/java/collection/"/>
    <updated>2021-02-18T01:11:00.000Z</updated>
    <summary type="html"><![CDATA[<blockquote>
<p><img src="https://img.shields.io/badge/collection-blue.svg" alt=""> <img src="https://img.shields.io/badge/List-blue.svg" alt=""> <img src="https://img.shields.io/badge/Set-blue.svg" alt=""> <img src="https://img.shields.io/badge/Map-blue.svg" alt=""></p>
</blockquote>
]]></summary>
    <content type="html"><![CDATA[<blockquote>
<p><img src="https://img.shields.io/badge/collection-blue.svg" alt=""> <img src="https://img.shields.io/badge/List-blue.svg" alt=""> <img src="https://img.shields.io/badge/Set-blue.svg" alt=""> <img src="https://img.shields.io/badge/Map-blue.svg" alt="">
</p>
</blockquote>
<h2 id="集合概要"> 集合概要</h2>
<p>Java的<code>java.util</code>包主要提供了以下三种类型的集合（也可以叫作容器，用来存储对象）</p>
<ul>
<li><code>List</code>：一种有序列表的集合</li>
<li><code>Set</code>：一种保证没有重复元素的集合</li>
<li><code>Map</code>：一种通过键值（key-value）查找的映射表集合</li>
</ul>
<p>Java集合的设计有几个特点：</p>
<ol>
<li>
<p>一是实现了接口和实现类相分离，例如，有序表的接口是<code>List</code>，具体的实现类有<code>ArrayList</code>，<code>LinkedList</code>等，</p>
</li>
<li>
<p>二是支持泛型，我们可以限制在一个集合中只能放入同一种数据类型的元素，如：</p>
<div><pre><code><span>List</span><span><span>&lt;</span><span>String</span><span>></span></span> list <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span> <span>// 只能放入String类型</span>
</code></pre>
<div><span>1</span><br></div></div></li>
<li>
<p>三是Java访问集合总是通过统一的方式——迭代器（Iterator）来实现，它最明显的好处在于无需知道集合内部元素是按什么方式存储</p>
</li>
</ol>
<div><p>提示</p>
<p>由于Java的集合设计非常久远，中间经历过大规模改进，我们要注意到有一小部分集合类是遗留类，不应该继续使用：</p>
<ul>
<li><code>Hashtable</code>：一种线程安全的<code>Map</code>实现；</li>
<li><code>Vector</code>：一种线程安全的<code>List</code>实现；</li>
<li><code>Stack</code>：基于<code>Vector</code>实现的<code>LIFO</code>的栈。</li>
</ul>
<p>还有一小部分接口是遗留接口，也不应该继续使用：</p>
<ul>
<li><code>Enumeration&lt;E&gt;</code>：已被<code>Iterator&lt;E&gt;</code>取代。</li>
</ul>
</div>
<h2 id="泛型"> 泛型</h2>
<p>泛型是JDK1.5以后增加的，它可以帮助我们建立类型安全的集合。在使用了泛型的集合中，遍历时不必进行强制类型转换。JDK提供了支持泛型的编译器，将运行时的类型检查提前到了编译时执行，提高了代码可读性和安全性。</p>
<p>泛型的本质就是“数据类型的参数化”。 我们可以把“泛型”理解为数据类型的一个占位符(形式参数)，即告诉编译器，在调用泛型时必须传入实际类型。</p>
<p>为了能够更好的学习集合，建议先学习<strong>泛型</strong>。</p>
<ul>
<li><a href="./generics.html">Java泛型学习笔记</a></li>
<li><a href="https://www.w3cschool.cn/java/java-generics.html" target="_blank" rel="noopener noreferrer">w3cschool教程</a></li>
</ul>
<h2 id="collection接口"> Collection接口</h2>
<p>Collection 表示一组对象，它是集中、收集的意思。Collection接口是List、Set接口的父接口，也就是List、Set都包含Collection中的方法，可以在List、Set接口的实现类中进行测试。</p>
<p>Collection的功能:</p>
<p>1、添加功能</p>
<p><code>boolean add (objcet obj)</code>:添加一个元素</p>
<p><code>boolean addAll(Collection c)</code>:添加一个集合的元素</p>
<p>2、删除功能:</p>
<p><code>void clear ()</code>:清除所有的元素</p>
<p><code>boolean remove (object)</code>:移除一个元素</p>
<p><code>boolean removeAll(Collection c)</code>:移除本集合和集合c中都包含的元素</p>
<p>3、判断功能:</p>
<p><code>boolean contains (0bject o)</code>:判断集合是否包含该元素</p>
<p><code>boolean containsAll(Collection c)</code>:判断集合中是否包含指定的集合元素，只有包含所有的元素,才叫包含</p>
<p><code>boolean isEmpty()</code>:判断集合是否为空</p>
<p>4、获取功能:</p>
<p><code>Iterator&lt;E&gt;iterator()</code>:迭代器</p>
<p><code>Object[] toArray()</code>:转化成Object数组</p>
<p>5、长度功能:</p>
<p><code>int size()</code>:元素的个数</p>
<p>6、交集功能:</p>
<p><code>boolean retainAll(Collection c)</code>:取本集合和集合c都包含的元素</p>
<p>Collection 类图（工作中需要掌握一些常用的集合类就行了）</p>
<h2 id="list接口及其实现类"> List接口及其实现类</h2>
<p>List是有序、可重复的容器。</p>
<p><strong>有序</strong>：List中每个元素都有索引标记。可以根据元素的索引标记(在List中的位置)访问元素，从而精确控制这些元素。</p>
<p><strong>可重复</strong>：List允许加入重复的元素。更确切地讲，List通常允许满足 e1.equals(e2) 的元素重复加入容器。</p>
<p>除了Collection接口中的方法，List多了一些跟顺序(索引)有关的方法</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>void add (int index, Object element)</td>
<td>在指定位置插入元素，以前元素全部后移一位</td>
</tr>
<tr>
<td>Object set (int index,Object element)</td>
<td>修改指定位置的元素</td>
</tr>
<tr>
<td>Object get (int index)</td>
<td>返回指定位置的元素</td>
</tr>
<tr>
<td>Object remove (int index)</td>
<td>删除指定位置的元素，后面元素全部前移一位</td>
</tr>
<tr>
<td>int indexOf (Object o)</td>
<td>返回第一个匹配元素的索引，如果没有该元素，返回-1.</td>
</tr>
<tr>
<td>int lastIndexOf (Object o)</td>
<td>返回最后一个匹配元素的索引，如果没有该元素，返回-1</td>
</tr>
</tbody>
</table>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <category term="Java"/>
    <contributor>
      <name>南辞</name>
    </contributor>
    <published>2021-02-18T01:11:00.000Z</published>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">JavaSE-泛型</title>
    <id>http://qiqi.dreamagain.top/program/backend/java/generics/</id>
    <link href="http://qiqi.dreamagain.top/program/backend/java/generics/"/>
    <updated>2021-02-16T17:39:43.000Z</updated>
    <content type="html"><![CDATA[<h2 id="一、前言"> 一、前言</h2>
<p>Java 泛型（Generic）的引入加强了参数类型的安全性，减少了类型的转换，但有一点需要注意：Java 的泛型在编译器有效，在运行期被删除，也就是说所有泛型参数类型在编译后都会被清除掉，看下面一个列子，代码如下：</p>
<div><pre><code><span>public</span> <span>class</span> <span>Foo</span> <span>{</span>
    <span>public</span> <span>void</span> <span>listMethod</span><span>(</span><span>List</span><span><span>&lt;</span><span>String</span><span>></span></span> stringList<span>)</span><span>{</span>
    <span>}</span>
    <span>public</span> <span>void</span> <span>listMethod</span><span>(</span><span>List</span><span><span>&lt;</span><span>Integer</span><span>></span></span> intList<span>)</span> <span>{</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>代码很简单，看起来没什么问题，但是编译器却报出如下错误信息：</p>
<div><pre><code><span>Method</span> <span>listMethod</span><span>(</span><span>List</span><span><span>&lt;</span><span>String</span><span>></span></span><span>)</span> has the same erasure <span>listMethod</span><span>(</span><span>List</span><span><span>&lt;</span><span>E</span><span>></span></span><span>)</span> as another method in type <span>Foo</span>
</code></pre>
<div><span>1</span><br></div></div><p>此错误的意思是说<code>listMethod(List&lt;String&gt;)</code>方法在编译时擦除类型后的方法是<code>listMethod(List&lt;E&gt;)</code>，它与另外一个方法重复，也就是方法签名重复。反编译之后的方法代码如下：</p>
<div><pre><code><span>public</span> <span>void</span> <span>listMethod</span><span>(</span><span>List</span> list<span>)</span><span>{</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>从上面代码可以看出 Java 编译后的字节码中已经没有泛型的任何信息，在编译后所有的泛型类型都会做相应的转化，转化如下：</p>
<ul>
<li><code>List&lt;String&gt;</code>、<code>List&lt;T&gt;</code>擦除后的类型为 List。</li>
<li><code>List&lt;String&gt;</code>、<code>List&lt;T&gt;[]</code> 擦除后的类型为 List[]。</li>
<li><code>List&lt;? extends E&gt;、List&lt;? super E&gt;</code> 擦除后的类型为 <code>List&lt;E&gt;</code>。</li>
<li><code>List&lt;T extends Serialzable &amp; Cloneable&gt;</code> 擦除后类型为 <code>List&lt;Serializable&gt;</code>。</li>
</ul>
<p>Java 为什么这么处理呢？有以下两个原因：</p>
<p>避免 JVM 的大换血（如果 JVM 将泛型类型延续到运行期，那么到运行期时 JVM 就需要进行大量的重构工作了），提高了运行期的效率。  版本兼容。 在编译期擦除可以更好地支持原生类型（Raw Type）。</p>
<p>明白了 Java 泛型是类型擦除的，下面的问题就很好理解了：</p>
<h2 id="二、使用泛型注意点"> 二、使用泛型注意点</h2>
<h3 id="一-泛型的-class-对象是相同的"> （一）泛型的 class 对象是相同的</h3>
<p>每个类都有一个 class 属性，泛型化不会改变 class 属性的返回值，例如：</p>
<div><pre><code><span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
	<span>List</span><span><span>&lt;</span><span>String</span><span>></span></span> ls <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>String</span><span>></span></span><span>(</span><span>)</span><span>;</span>
	<span>List</span><span><span>&lt;</span><span>Integer</span><span>></span></span> li <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>Integer</span><span>></span></span><span>(</span><span>)</span><span>;</span>
	<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>ls<span>.</span><span>getClass</span><span>(</span><span>)</span> <span>==</span> li<span>.</span><span>getClass</span><span>(</span><span>)</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>代码返回值为 true，原因很简单，<code>List&lt;String&gt;</code> 和<code>List&lt;Integer&gt;</code> 擦除后的类型都是 List。</p>
<h3 id="二-泛型数组初始化时不能声明泛型类型"> （二）泛型数组初始化时不能声明泛型类型</h3>
<p>如下代码编译时通不过：</p>
<div><pre><code><span>List</span><span><span>&lt;</span><span>String</span><span>></span></span><span>[</span><span>]</span> list <span>=</span> <span>new</span> <span>List</span><span><span>&lt;</span><span>String</span><span>></span></span><span>[</span><span>]</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div><p>在这里可以声明一个带有泛型参数的数组，但是不能初始化该数组，因为执行了类型擦除操作后，<code>List&lt;Object&gt;[]</code>与 <code>List&lt;String&gt;[]</code>就是同一回事了，编译器拒绝如此声明。</p>
<h3 id="三-instanceof-不允许存在泛型参数"> （三）instanceof 不允许存在泛型参数</h3>
<p>以下代码不能通过编译，原因一样，泛型类型被擦除了。</p>
<div><pre><code><span>List</span><span><span>&lt;</span><span>String</span><span>></span></span> list <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>String</span><span>></span></span><span>(</span><span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>list <span>instanceof</span> <span>List</span><span><span>&lt;</span><span>String</span><span>></span></span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>错误信息如下：<br>
<code>Cannot perform instanceof check against parameterized type List&lt;String&gt;. Use the form List&lt;?&gt; instead since further generic type information will be erased at runtime</code></p>
<h2 id="三、类型擦除"> 三、类型擦除</h2>
<p>正确理解泛型概念的首要前提是理解类型擦除（type erasure）。 Java中的泛型基本上都是在编译器这个层次来实现的。在生成的Java字节代码中是不包含泛型中的类型信息的。使用泛型的时候加上的类型参数，会被编译器在编译的时候去掉。这个过程就称为类型擦除。</p>
<p>如在代码中定义的<code>List&lt;Object&gt;</code>和<code>List&lt;String&gt;</code>等类型，在编译之后都会变成List。JVM看到的只是List，而由泛型附加的类型信息对JVM来说是不可见的。Java编译器会在编译时尽可能的发现可能出错的地方，但是仍然无法避免在运行时刻出现类型转换异常的情况。类型擦除也是Java的泛型实现方式与<a href="http://www.cplusplus.com/doc/tutorial/templates/" target="_blank" rel="noopener noreferrer">C++模板机制</a>实现方式之间的重要区别。</p>
<p>很多泛型的奇怪特性都与这个类型擦除的存在有关，包括：</p>
<ul>
<li>泛型类并没有自己独有的Class类对象。比如并不存在<code>List&lt;String&gt;.class</code>或是<code>List&lt;Integer&gt;.class</code>，而只有<code>List.class</code>。</li>
<li>静态变量是被泛型类的所有实例所共享的。对于声明为<code>MyClass&lt;T&gt;</code>的类，访问其中的静态变量的方法仍然是 <code>MyClass.myStaticVar</code>。不管是通过<code>new MyClass&lt;String&gt;</code>还是<code>new MyClass&lt;Integer&gt;</code>创建的对象，都是共享一个静态变量。</li>
<li><mark>泛型的类型参数不能用在Java异常处理的catch语句中。因为异常处理是由JVM在运行时刻来进行的。由于类型信息被擦除，JVM是无法区分两个异常类型<code>MyException&lt;String&gt;</code>和<code>MyException&lt;Integer&gt;</code>的。对于JVM来说，它们都是 MyException类型的。也就无法执行与异常对应的catch语句。</mark></li>
</ul>
<p>类型擦除的基本过程也比较简单，首先是找到用来替换类型参数的具体类。这个具体类一般是Object。如果指定了类型参数的上界的话，则使用这个上界。把代码中的类型参数都替换成具体的类。同时去掉出现的类型声明，即去掉<code>&lt;&gt;</code>的内容。比如<code>T get()</code>方法声明就变成了<code>Object get()</code>；<code>List&lt;String&gt;</code>就变成了List。接下来就可能需要生成一些桥接方法<code>（bridge method）</code>。这是由于擦除了类型之后的类可能缺少某些必须的方法。比如考虑下面的代码：</p>
<div><pre><code><span>class</span> <span>MyString</span> <span>implements</span> <span>Comparable</span><span><span>&lt;</span><span>String</span><span>></span></span> <span>{</span>
    <span>public</span> <span>int</span> <span>compareTo</span><span>(</span><span>String</span> str<span>)</span> <span>{</span>        
        <span>return</span> <span>0</span><span>;</span>    
    <span>}</span>
<span>}</span> 
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>当类型信息被擦除之后，上述类的声明变成了<code>class MyString implements Comparable</code>。但是这样的话，类MyString就会有编译错误，因为没有实现接口Comparable声明的<code>String compareTo(Object)</code>方法。这个时候就由编译器来动态生成这个方法。</p>
<h3 id="一-实例分析"> （一）实例分析</h3>
<p>了解了类型擦除机制之后，就会明白编译器承担了全部的类型检查工作。编译器禁止某些泛型的使用方式，正是为了确保类型的安全性。以上面提到的<code>List&lt;Object&gt;</code>和<code>List&lt;String&gt;</code>为例来具体分析：</p>
<div><pre><code><span>public</span> <span>void</span> <span>inspect</span><span>(</span><span>List</span><span><span>&lt;</span><span>Object</span><span>></span></span> list<span>)</span> <span>{</span>    
    <span>for</span> <span>(</span><span>Object</span> obj <span>:</span> list<span>)</span> <span>{</span>        
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>obj<span>)</span><span>;</span>    
    <span>}</span>    
    list<span>.</span><span>add</span><span>(</span><span>1</span><span>)</span><span>;</span> <span>//这个操作在当前方法的上下文是合法的。 </span>
<span>}</span>
<span>public</span> <span>void</span> <span>test</span><span>(</span><span>)</span> <span>{</span>    
    <span>List</span><span><span>&lt;</span><span>String</span><span>></span></span> strs <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>String</span><span>></span></span><span>(</span><span>)</span><span>;</span>    
    <span>inspect</span><span>(</span>strs<span>)</span><span>;</span> <span>//编译错误 </span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>这段代码中，inspect方法接受<code>List&lt;Object&gt;</code>作为参数，当在test方法中试图传入<code>List&lt;String&gt;</code>的时候，会出现编译错误。假设这样的做法是允许的，那么在inspect方法就可以通过list.add(1)来向集合中添加一个数字。这样在test方法看来，其声明为<code>List&lt;String&gt;</code>的集合中却被添加了一个Integer类型的对象。这显然是违反类型安全的原则的，在某个时候肯定会抛出<a href="http://download.oracle.com/javase/1.5.0/docs/api/java/lang/ClassCastException.html" target="_blank" rel="noopener noreferrer">ClassCastException</a>。因此，编译器禁止这样的行为。编译器会尽可能的检查可能存在的类型安全问题。对于确定是违反相关原则的地方，会给出编译错误。当编译器无法判断类型的使用是否正确的时候，会给出警告信息。</p>
<h3 id="二-通配符与上下界"> （二）通配符与上下界</h3>
<p>在使用泛型类的时候，既可以指定一个具体的类型，如：</p>
<p><code>List&lt;String&gt;</code>就声明了具体的类型是String；也可以用通配符<code>?</code>来表示未知类型，如<code>List&lt;?&gt;</code>就声明了List中包含的元素类型是未知的。 通配符所代表的其实是一组类型，但具体的类型是未知的。<code>List&lt;?&gt;</code>所声明的就是所有类型都是可以的。但是<code>List&lt;?&gt;</code>并不等同于<code>List&lt;Object&gt;</code>。<code>List&lt;Object&gt;</code>实际上确定了List中包含的是Object及其子类，在使用的时候都可以通过Object来进行引用。而<code>List&lt;?&gt;</code>则其中所包含的元素类型是不确定。其中可能包含的是String，也可能是 Integer。如果它包含了String的话，往里面添加Integer类型的元素就是错误的。正因为类型未知，就不能通过<code>new ArrayList&lt;?&gt;()</code>的方法来创建一个新的ArrayList对象。因为编译器无法知道具体的类型是什么。但是对于<code>List&lt;?&gt;</code>中的元素确总是可以用Object来引用的，因为虽然类型未知，但肯定是Object及其子类。考虑下面的代码：</p>
<div><pre><code><span>public</span> <span>void</span> <span>wildcard</span><span>(</span><span>List</span><span><span>&lt;</span><span>?</span><span>></span></span> list<span>)</span> <span>{</span>
    list<span>.</span><span>add</span><span>(</span><span>1</span><span>)</span><span>;</span><span>//编译错误 </span>
<span>}</span> 
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>如上所示，试图对一个带通配符的泛型类进行操作的时候，总是会出现编译错误。其原因在于通配符所表示的类型是未知的。</p>
<p>因为对于<code>List&lt;?&gt;</code>中的元素只能用Object来引用，在有些情况下不是很方便。在这些情况下，<mark>可以使用上下界来限制未知类型的范围。</mark> 如<code>List&lt;? extends Number&gt;</code>说明List中可能包含的元素类型是Number及其子类。而<code>List&lt;? super Number&gt;</code>则说明List中包含的是Number及其父类。当引入了上界之后，在使用类型的时候就可以使用上界类中定义的方法。比如访问 <code>List&lt;? extends Number&gt;</code>的时候，就可以使用Number类的intValue等方法。</p>
<h3 id="三-类型系统"> （三）类型系统</h3>
<p>在Java中，大家比较熟悉的是通过继承机制而产生的类型体系结构。比如String继承自Object。根据<a href="http://en.wikipedia.org/wiki/Liskov_substitution_principle" target="_blank" rel="noopener noreferrer">Liskov替换原则</a>，子类是可以替换父类的。当需要Object类的引用的时候，如果传入一个String对象是没有任何问题的。但是反过来的话，即用父类的引用替换子类引用的时候，就需要进行强制类型转换。编译器并不能保证运行时刻这种转换一定是合法的。这种自动的子类替换父类的类型转换机制，对于数组也是适用的。 String[]可以替换Object[]。但是泛型的引入，对于这个类型系统产生了一定的影响。正如前面提到的<code>List&lt;String&gt;</code>是不能替换掉<code>List&lt;Object&gt;</code>的。</p>
<p>引入泛型之后的类型系统增加了两个维度：一个是类型参数自身的继承体系结构，另外一个是泛型类或接口自身的继承体系结构。第一个指的是对于<code>List&lt;String&gt;</code>和<code>List&lt;Object&gt;</code>这样的情况，类型参数String是继承自Object的。而第二种指的是 List接口继承自Collection接口。对于这个类型系统，有如下的一些规则：</p>
<ul>
<li>相同类型参数的泛型类的关系取决于泛型类自身的继承体系结构。即<code>List&lt;String&gt;</code>是<code>Collection&lt;String&gt;</code> 的子类型，<code>List&lt;String&gt;</code>可以替换<code>Collection&lt;String&gt;</code>。这种情况也适用于带有上下界的类型声明。</li>
<li>当泛型类的类型声明中使用了通配符的时候， 其子类型可以在两个维度上分别展开。如对<code>Collection&lt;? extends Number&gt;</code>来说，其子类型可以在Collection这个维度上展开，即<code>List&lt;? extends Number&gt;</code>和<code>Set&lt;? extends Number&gt;</code>等；也可以在Number这个层次上展开，即<code>Collection&lt;Double&gt;</code>和<code>Collection&lt;Integer&gt;</code>等。如此循环下去，<code>ArrayList&lt;Long&gt;</code>和<code>HashSet&lt;Double&gt;</code>等也都算是<code>Collection&lt;? extends Number&gt;</code>的子类型。</li>
<li>如果泛型类中包含多个类型参数，则对于每个类型参数分别应用上面的规则。</li>
</ul>
<p>理解了上面的规则之后，就可以很容易的修正实例分析中给出的代码了。只需要把<code>List&lt;Object&gt;</code>改成<code>List&lt;?&gt;</code>即可。<code>List&lt;String&gt;</code>是<code>List&lt;?&gt;</code>的子类型，因此传递参数时不会发生错误。</p>
<h3 id="四-泛型传递"> （四）泛型传递</h3>
<p>即泛型可以当作参数在不同的实例化的类中传递，理论上来说可以无限制层次的传递下去。最终会约束每一层的方法或者类型的泛型确定，在《<a href="http://www.raychase.net/2446" target="_blank" rel="noopener noreferrer">泛型传递</a>》这篇文章中对具体的用法进行详尽的描述。</p>
<h3 id="五-最佳实践"> （五）最佳实践</h3>
<p>在使用泛型的时候可以遵循一些基本的原则，从而避免一些常见的问题。</p>
<ul>
<li>在代码中避免泛型类和原始类型的混用。比如<code>List&lt;String&gt;</code>和List不应该共同使用。这样会产生一些编译器警告和潜在的运行时异常。当需要利用JDK 5之前开发的遗留代码，而不得不这么做时，也尽可能的隔离相关的代码。</li>
<li>在使用带通配符的泛型类的时候，需要明确通配符所代表的一组类型的概念。由于具体的类型是未知的，很多操作是不允许的。</li>
<li>泛型类最好不要同数组一块使用。你只能创建<code>new List&lt;?&gt;[10]</code>这样的数组，无法创建<code>new List&lt;String&gt;[10]</code>这样的。这限制了数组的使用能力，而且会带来很多费解的问题。因此，当需要类似数组的功能时候，使用集合类即可。</li>
<li>不要忽视编译器给出的警告信息。</li>
</ul>
<h2 id="四、集合中使用泛型"> 四、集合中使用泛型</h2>
<p>集合相关类都定义了泛型，我们在开发和工作中，在使用集合类时都要使用泛型。这样，在集合的存储数据、读取数据时都避免了大量的类型判断，非常便捷。</p>
<p>泛型类的在集合中的使用</p>
<div><pre><code><span>public</span> <span>class</span> <span>Test</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>// 以下代码中List、Set、Map、Iterator都是与容器相关的接口;</span>
        <span>List</span><span><span>&lt;</span><span>String</span><span>></span></span> list <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>String</span><span>></span></span><span>(</span><span>)</span><span>;</span>
        <span>Set</span><span><span>&lt;</span><span>Man</span><span>></span></span> mans <span>=</span> <span>new</span> <span>HashSet</span><span><span>&lt;</span><span>Man</span><span>></span></span><span>(</span><span>)</span><span>;</span>
        <span>Map</span><span><span>&lt;</span><span>Integer</span><span>,</span> <span>Man</span><span>></span></span> maps <span>=</span> <span>new</span> <span>HashMap</span><span><span>&lt;</span><span>Integer</span><span>,</span> <span>Man</span><span>></span></span><span>(</span><span>)</span><span>;</span>
        <span>Iterator</span><span><span>&lt;</span><span>Man</span><span>></span></span> iterator <span>=</span> mans<span>.</span><span>iterator</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>阅读源码，发现Collection、List、Set、Map、Iterator接口都定义了泛型</p>
<div><pre><code><span>public</span> <span>interface</span> <span>Collection</span><span><span>&lt;</span><span>E</span><span>></span></span> <span>extends</span> <span>Iterable</span><span><span>&lt;</span><span>E</span><span>></span></span>
<span>public</span> <span>interface</span> <span>List</span><span><span>&lt;</span><span>E</span><span>></span></span> <span>extends</span> <span>Collection</span><span><span>&lt;</span><span>E</span><span>></span></span> 
<span>public</span> <span>interface</span> <span>Set</span><span><span>&lt;</span><span>E</span><span>></span></span> <span>extends</span> <span>Collection</span><span><span>&lt;</span><span>E</span><span>></span></span> 
<span>public</span> <span>interface</span> <span>Map</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> 
<span>public</span> <span>interface</span> <span>Iterator</span><span><span>&lt;</span><span>E</span><span>></span></span>    
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><div><p>注意</p>
<p>因此，我们在使用这些接口及其实现类时，都要使用泛型。</p>
</div>
<h2 id="五、自定义泛型"> 五、自定义泛型</h2>
<p>泛型类与一般的Java类基本相同，只是在类和接口定义上多出来了用&lt;&gt;声明的类型参数。</p>
<p>一个类可以有多个类型参数，我们可以在类的声明处增加泛型列表，如：&lt;T,E,V&gt;。此处，字符可以是任何标识符，一般采用这3个字母。 每个类型参数在声明的时候可以指定上界。所声明的类型参数在Java类中可以像一般的类型一样作为方法的参数和返回值，或是作为域和局部变量的类型。</p>
<h3 id="一-泛型类的声明"> （一）泛型类的声明</h3>
<div><pre><code><span>class</span> <span>MyCollection</span><span><span>&lt;</span><span>E</span><span>></span></span> <span>{</span><span>// E:表示泛型;</span>
    <span>Object</span><span>[</span><span>]</span> objs <span>=</span> <span>new</span> <span>Object</span><span>[</span><span>5</span><span>]</span><span>;</span>
 
    <span>public</span> <span>E</span> <span>get</span><span>(</span><span>int</span> index<span>)</span> <span>{</span><span>// E:表示泛型;</span>
        <span>return</span> <span>(</span><span>E</span><span>)</span> objs<span>[</span>index<span>]</span><span>;</span>
    <span>}</span>
    <span>public</span> <span>void</span> <span>set</span><span>(</span><span>E</span> e<span>,</span> <span>int</span> index<span>)</span> <span>{</span><span>// E:表示泛型;</span>
        objs<span>[</span>index<span>]</span> <span>=</span> e<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>泛型E像一个占位符一样表示“未知的某个数据类型”，我们在真正调用的时候传入这个“数据类型”</p>
<p>但是由于类型擦除机制，<mark>类型参数并不能用来创建对象或是作为静态变量的类型</mark>。考虑下面的泛型类中的正确和错误的用法。</p>
<div><pre><code><span>class</span> <span>ClassTest</span><span><span>&lt;</span><span>X</span> <span>extends</span> <span>Number</span><span>,</span> <span>Y</span><span>,</span> <span>Z</span><span>></span></span> <span>{</span>    
    <span>private</span> <span>X</span> x<span>;</span>    
    <span>private</span> <span>static</span> <span>Y</span> y<span>;</span> <span>//编译错误，不能用在静态变量中    </span>
    <span>public</span> <span>X</span> <span>getFirst</span><span>(</span><span>)</span> <span>{</span>
        <span>//正确用法        </span>
        <span>return</span> x<span>;</span>    
    <span>}</span>    
    <span>public</span> <span>void</span> <span>wrong</span><span>(</span><span>)</span> <span>{</span>        
        <span>Z</span> z <span>=</span> <span>new</span> <span>Z</span><span>(</span><span>)</span><span>;</span> <span>//编译错误，不能创建对象    </span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h3 id="二-泛型类的应用"> （二）泛型类的应用</h3>
<div><pre><code><span>public</span> <span>class</span> <span>TestGenerics</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>// 这里的”String”就是实际传入的数据类型；</span>
        <span>MyCollection</span><span><span>&lt;</span><span>String</span><span>></span></span> mc <span>=</span> <span>new</span> <span>MyCollection</span><span><span>&lt;</span><span>String</span><span>></span></span><span>(</span><span>)</span><span>;</span>
        mc<span>.</span><span>set</span><span>(</span><span>"aaa"</span><span>,</span> <span>0</span><span>)</span><span>;</span>
        mc<span>.</span><span>set</span><span>(</span><span>"bbb"</span><span>,</span> <span>1</span><span>)</span><span>;</span>
        <span>String</span> str <span>=</span> mc<span>.</span><span>get</span><span>(</span><span>1</span><span>)</span><span>;</span> <span>//加了泛型，直接返回String类型，不用强制转换;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>str<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div>]]></content>
    <author>
      <name>南辞</name>
    </author>
    <category term="Java"/>
    <contributor>
      <name>南辞</name>
    </contributor>
    <published>2021-02-16T17:39:43.000Z</published>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">Java</title>
    <id>http://qiqi.dreamagain.top/program/backend/java/</id>
    <link href="http://qiqi.dreamagain.top/program/backend/java/"/>
    <updated>2021-02-16T17:39:43.000Z</updated>
    <summary type="html"><![CDATA[<blockquote>
<p><img src="https://img.shields.io/badge/Java%E7%AE%80%E4%BB%8B-blue.svg" alt=""> <img src="https://img.shields.io/badge/%E5%AD%A6%E4%B9%A0%E6%95%99%E7%A8%8B-blue.svg" alt=""> <img src="https://img.shields.io/badge/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-blue.svg" alt=""></p>
</blockquote>
]]></summary>
    <content type="html"><![CDATA[<blockquote>
<p><img src="https://img.shields.io/badge/Java%E7%AE%80%E4%BB%8B-blue.svg" alt=""> <img src="https://img.shields.io/badge/%E5%AD%A6%E4%B9%A0%E6%95%99%E7%A8%8B-blue.svg" alt=""> <img src="https://img.shields.io/badge/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-blue.svg" alt="">
</p>
</blockquote>
<h2 id="java简介"> Java简介</h2>
<h3 id="java语言的诞生"> Java语言的诞生</h3>
<p>Java 是由 Sun Microsystems 公司于 1995 年 5 月推出的 Java 面向对象程序设计语言和 Java 平台的总称。由 James Gosling（Javaz之父）和同事们共同研发，并在 1995 年正式推出。</p>
<p>后来 Sun 公司被 Oracle （甲骨文）公司收购，Java 也随之成为 Oracle 公司的产品。</p>
<h3 id="java的三个体系"> Java的三个体系</h3>
<ul>
<li>
<p>JavaSE（J2SE）（Java2 Platform Standard Edition，java平台标准版）</p>
</li>
<li>
<p>JavaEE(J2EE)(Java 2 Platform,Enterprise Edition，java平台企业版)</p>
</li>
<li>
<p>JavaME(J2ME)(Java 2 Platform Micro Edition，java平台微型版)。</p>
<img src="./assets/java-00.png" style="zoom:120%;" align="left"/>
</li>
</ul>
<p>2005 年 6 月，JavaOne 大会召开，SUN 公司公开 Java SE 6。此时，Java 的各种版本已经更名，以取消其中的数字 &quot;2&quot;：</p>
<ul>
<li>J2EE 更名为 Java EE</li>
<li>J2SE 更名为Java SE，</li>
<li>J2ME 更名为 Java ME。</li>
</ul>
<br/>
<ol>
<li>Java SE就是标准版，包含标准的JVM和标准库</li>
<li>Java EE是企业版，它只是在Java SE的基础上加上了大量的API和库，以便方便开发Web应用、数据库、消息服务等，Java EE的应用使用的虚拟机和Java SE完全相同。</li>
<li>Java ME就和Java SE不同，它是一个针对嵌入式设备的“瘦身版”，Java SE的标准库无法在Java ME上使用，Java ME的虚拟机也是“瘦身版”。业界以Android开发成为了移动平台的标准之一，Java ME的使用相当少，不建议学习</li>
</ol>
<div><p>学习指南</p>
<ol>
<li>首先要学习Java SE，掌握Java语言本身、Java核心开发技术以及Java标准库的使用；</li>
<li>如果继续学习Java EE，那么Spring框架、数据库开发、分布式架构就是需要学习的；</li>
<li>如果要学习大数据开发，那么Hadoop、Spark、Flink这些大数据平台就是需要学习的，他们都基于Java或Scala开发；</li>
<li>如果想要学习移动开发，那么就深入Android平台，掌握Android App开发。</li>
</ol>
<p>Java SE是整个Java平台的核心，要成为真正的Java程序猿需要学习更多Java底层原理，精通Java SE</p>
</div>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <category term="Java"/>
    <contributor>
      <name>南辞</name>
    </contributor>
    <published>2021-02-16T17:39:43.000Z</published>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">JavaSE-反射</title>
    <id>http://qiqi.dreamagain.top/program/backend/java/reflect/</id>
    <link href="http://qiqi.dreamagain.top/program/backend/java/reflect/"/>
    <updated>2021-02-16T17:39:43.000Z</updated>
    <content type="html"><![CDATA[<h2 id="一、什么是反射"> 一、什么是反射：</h2>
<p>（1）Java反射机制的核心是在程序运行时动态加载类并获取类的详细信息，从而操作类或对象的属性和方法。本质是JVM得到class对象之后，再通过class对象进行反编译，从而获取对象的各种信息。</p>
<p>（2）Java属于先编译再运行的语言，程序中对象的类型在编译期就确定下来了，而当程序在运行时可能需要动态加载某些类，这些类因为之前用不到，所以没有被加载到JVM。通过反射，可以在运行时动态地创建对象并调用其属性，不需要提前在编译期知道运行的对象是谁。</p>
<p><strong>反射是框架设计的灵魂</strong>：（使用的前提条件：必须先得到代表的字节码的Class，Class类用于表示.class文件（字节码））</p>
<div><p>小结</p>
<p>反射就是把java类中的各种成分映射成一个个的Java对象</p>
<p>例如：一个类有：成员变量、方法、构造方法、包等等信息，利用反射技术可以对一个类进行解剖，把各个组成部分映射成一个个对象。</p>
</div>
<h2 id="二、反射的原理"> 二、反射的原理：</h2>
<p>如图是类的正常加载过程：反射的原理在于class对象。</p>
<p>加载的时候：Class对象的由来是将class文件读入内存，并为之创建一个Class对象。</p>
<p><img src="./assets/java-02.png" alt=""></p>
<p>了解<a href="./calssloader.html">类加载机制与双亲委派模型</a></p>
<h2 id="三、反射的优缺点"> 三、反射的优缺点：</h2>
<p>1、优点：</p>
<p>在运行时获得类的各种内容，进行反编译，对于Java这种先编译再运行的语言，能够让我们很方便的创建灵活的代码</p>
<p>这些代码可以在运行时装配，无需在组件之间进行源代码的链接，更加容易实现面向对象。</p>
<p>2、缺点：</p>
<p>（1）反射会消耗一定的系统资源，因此，如果不需要动态地创建一个对象，那么就不需要用反射；</p>
<p>（2）<mark>反射调用方法时可以忽略权限检查，因此可能会破坏封装性而导致安全问题。</mark></p>
<h2 id="四、反射的用途"> 四、反射的用途：</h2>
<p>1、反编译：.class--&gt;.java</p>
<p>2、通过反射机制访问java对象的属性，方法，构造方法等</p>
<p>3、当我们在使用IDE,比如InteliJ IDEA时，当我们输入一个对象或者类，并想调用他的属性和方法是，一按点号，编译器就会自动列出他的属性或者方法，这里就是用到反射。</p>
<p>4、反射最重要的用途就是开发各种通用框架。比如很多框架（Spring）都是配置化的（比如通过XML文件配置Bean），为了保证框架的通用性，他们可能需要根据配置文件加载不同的类或者对象，调用不同的方法，这个时候就必须使用到反射了，运行时动态加载需要的加载的对象。</p>
<p>5、比如，加载数据库驱动的，用到的也是反射。</p>
<div><pre><code><span>Class</span><span>.</span><span>forName</span><span>(</span><span>"com.mysql.jdbc.Driver"</span><span>)</span><span>;</span> <span>// 动态加载mysql驱动</span>
</code></pre>
<div><span>1</span><br></div></div><h2 id="五、反射机制常用的类"> 五、反射机制常用的类</h2>
<p>Java.lang.Class;</p>
<p>Java.lang.reflect.Constructor;</p>
<p>Java.lang.reflect.Field;</p>
<p>Java.lang.reflect.Method;</p>
<p>Java.lang.reflect.Modifier;</p>
<h2 id="六、反射的基本使用"> 六、反射的基本使用</h2>
<p>假设我们现在有一个<code>Hero类</code></p>
<div><pre><code><span>package</span> <span>reflect</span><span>;</span>
<span>public</span> <span>class</span> <span>Hero</span> <span>{</span>
	<span>public</span> <span>String</span> name<span>;</span> <span>//昵称</span>
    <span>public</span> <span>float</span> hp<span>;</span> <span>//血量</span>
    <span>public</span> <span>float</span> armor<span>;</span> <span>//护甲</span>
    <span>public</span> <span>int</span> moveSpeed<span>;</span> <span>//移动速度</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h3 id="一-获取类对象"> （一）获取类对象</h3>
<p>获取类对象有3种方式</p>
<ol>
<li><code>Class.forName（）</code>（<strong>常用</strong>）</li>
<li><code>Hero.class</code></li>
<li><code>new Hero().getClass()</code></li>
</ol>
<p>在一个JVM中，一种类，只会有一个类对象存在。所以以上三种方式取出来的类对象，都是一样。</p>
<p>（此处准确是在ClassLoader下,只有一个类对象）</p>
<p><strong>示例：</strong></p>
<div><pre><code><span>package</span> <span>reflect</span><span>;</span>
<span>public</span> <span>class</span> <span>ReflectTest</span> <span>{</span>

	<span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>String</span> className <span>=</span> <span>"reflect.Hero"</span><span>;</span>
		<span>try</span> <span>{</span>
        	<span>//获取类对象的第一种方式</span>
            <span>Class</span> hClass1 <span>=</span> <span>Class</span><span>.</span><span>forName</span><span>(</span>className<span>)</span><span>;</span>
            <span>//获取类对象的第二种方式</span>
            <span>Class</span> hClass2 <span>=</span> <span>Hero</span><span>.</span><span>class</span><span>;</span>
            <span>//获取类对象的第三种方式</span>
            <span>Class</span> hClass3 <span>=</span> <span>new</span> <span>Hero</span><span>(</span><span>)</span><span>.</span><span>getClass</span><span>(</span><span>)</span><span>;</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>hClass1<span>==</span>hClass2<span>)</span><span>;</span><span>//输出true</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>hClass1<span>==</span>hClass3<span>)</span><span>;</span><span>//输出true</span>
        <span>}</span> <span>catch</span> <span>(</span><span>ClassNotFoundException</span> e<span>)</span> <span>{</span>
            <span>// TODO Auto-generated catch block</span>
            e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>
        <span>}</span>
 <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><p>三种方式中，常用第一种，第二种需要导入类的包，依赖太强，不导包就抛编译错误。第三种对象都有了还要反射干什么。</p>
<p>一般都第一种，参数可以传入一个字符串，也可写在配置文件中等多种方法。</p>
<hr>
<h3 id="二-反射机制创建对象"> （二）反射机制创建对象</h3>
<p><strong>通过反射来生成对象主要有两种方法：</strong></p>
<p>（1）使用Class对象的newInstance()方法来创建Class对象对应类的实例。</p>
<div><pre><code><span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> clazz <span>=</span> <span>String</span><span>.</span><span>class</span><span>;</span>
<span>Object</span> str <span>=</span> clazz<span>.</span><span>newInstance</span><span>(</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>（2）先通过Class对象获取指定的Constructor对象，再调用Constructor对象的newInstance()方法来创建对象，这种方法可以用指定的构造器构造类的实例。</p>
<div><pre><code><span>//获取String的Class对象</span>
<span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> clazz <span>=</span> <span>String</span><span>.</span><span>class</span><span>;</span>
<span>//通过Class对象获取指定的Constructor构造器对象</span>
<span>//String.class指明构造器的形参是String类型</span>
<span>Constructor</span> constructor<span>=</span>clazz<span>.</span><span>getConstructor</span><span>(</span><span>String</span><span>.</span><span>class</span><span>)</span><span>;</span>
<span>//根据构造器创建实例：</span>
<span>Object</span> obj <span>=</span> constructor<span>.</span><span>newInstance</span><span>(</span>“hello reflection”<span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p><strong>演示通过构造器创建实例</strong></p>
<p>基本步骤</p>
<p>1、获取类对象 <code>Class class = Class.forName(&quot;reflect.Hero&quot;);</code></p>
<p>2、获取构造器对象 <code>Constructor con = clazz.getConstructor(形参.class);</code></p>
<p>3、获取对象 <code>Hero hero =con.newInstance(实参);</code></p>
<p>上面是最简单的获取方法，当Hero的构造方法不是无参构造方法时，获取构造器对象略有不同，见下面测试：</p>
<p><strong>构造方法不同时，获取构造器对象的方法</strong></p>
<p>1、Hero类添加6种构造方法</p>
<div><pre><code><span>//---------------构造方法-------------------</span>
	<span>//（默认的构造方法）</span>
	<span>Hero</span><span>(</span><span>String</span> str<span>)</span><span>{</span>
		<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"(默认)的构造方法 s = "</span> <span>+</span> str<span>)</span><span>;</span>
	<span>}</span>
	
	<span>//无参构造方法</span>
	<span>public</span> <span>Hero</span><span>(</span><span>)</span><span>{</span>
		<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"调用了公有、无参构造方法执行了。。。"</span><span>)</span><span>;</span>
	<span>}</span>
	
	<span>//有一个参数的构造方法</span>
	<span>public</span> <span>Hero</span><span>(</span><span>char</span> name<span>)</span><span>{</span>
		<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"姓名："</span> <span>+</span> name<span>)</span><span>;</span>
	<span>}</span>
	
	<span>//有多个参数的构造方法</span>
	<span>public</span> <span>Hero</span><span>(</span><span>String</span> name <span>,</span><span>float</span> hp<span>)</span><span>{</span>
		<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"姓名："</span><span>+</span>name<span>+</span><span>"血量："</span><span>+</span> hp<span>)</span><span>;</span>
	<span>}</span>
	
	<span>//受保护的构造方法</span>
	<span>protected</span> <span>Hero</span><span>(</span><span>boolean</span> n<span>)</span><span>{</span>
		<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"受保护的构造方法 n = "</span> <span>+</span> n<span>)</span><span>;</span>
	<span>}</span>
	
	<span>//私有构造方法</span>
	<span>private</span> <span>Hero</span><span>(</span><span>float</span> hp<span>)</span><span>{</span>
		<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"私有的构造方法   血量："</span><span>+</span> hp<span>)</span><span>;</span>
	<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br></div></div><p>2、通过反射机制获取对象</p>
<div><pre><code><span>package</span> <span>reflect</span><span>;</span>

<span>import</span> <span>java<span>.</span>lang<span>.</span>reflect<span>.</span></span><span>Constructor</span><span>;</span>

<span>public</span> <span>class</span> <span>ConstructorTest</span> <span>{</span>


	<span>/*
	 * 通过Class对象可以获取某个类中的：构造方法、成员变量、成员方法；并访问成员；
	 *
	 * 1.获取构造方法：
	 * 		1).批量的方法：
	 * 			public Constructor[] getConstructors()：所有"公有的"构造方法
	            public Constructor[] getDeclaredConstructors()：获取所有的构造方法(包括私有、受保护、默认、公有)

	 * 		2).获取单个的方法，并调用：
	 * 			public Constructor getConstructor(Class... parameterTypes):获取单个的"公有的"构造方法：
	 * 			public Constructor getDeclaredConstructor(Class... parameterTypes):获取"某个构造方法"可以是私有的，或受保护、默认、公有；
	 *
	 * 2.创建对象
	 * 		Constructor对象调用newInstance(Object... initargs)
	 */</span>


	<span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>
		<span>//1.获取Class对象</span>
		<span>Class</span> clazz <span>=</span> <span>Class</span><span>.</span><span>forName</span><span>(</span><span>"reflect.Hero"</span><span>)</span><span>;</span>


		<span>//2.获取所有公有构造方法</span>
		<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"**********************所有公有构造方法*********************************"</span><span>)</span><span>;</span>
		<span>Constructor</span><span>[</span><span>]</span> conArray <span>=</span> clazz<span>.</span><span>getConstructors</span><span>(</span><span>)</span><span>;</span>
		<span>for</span><span>(</span><span>Constructor</span> c <span>:</span> conArray<span>)</span><span>{</span>
			<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>c<span>)</span><span>;</span>
		<span>}</span>


		<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"************所有的构造方法(包括：私有、受保护、默认、公有)***************"</span><span>)</span><span>;</span>
		conArray <span>=</span> clazz<span>.</span><span>getDeclaredConstructors</span><span>(</span><span>)</span><span>;</span>
		<span>for</span><span>(</span><span>Constructor</span> c <span>:</span> conArray<span>)</span><span>{</span>
			<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>c<span>)</span><span>;</span>
		<span>}</span>

		<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"*****************获取公有、无参的构造方法*******************************"</span><span>)</span><span>;</span>
		<span>Constructor</span> con <span>=</span> clazz<span>.</span><span>getConstructor</span><span>(</span><span>null</span><span>)</span><span>;</span>
		<span>//1>、因为是无参的构造方法所以类型是一个null,不写也可以：这里需要的是一个参数的类型，切记是类型</span>
		<span>//2>、返回的是描述这个无参构造函数的类对象。</span>
		<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"con = "</span> <span>+</span> con<span>)</span><span>;</span>
		<span>//调用构造方法</span>
		<span>Object</span> obj <span>=</span> con<span>.</span><span>newInstance</span><span>(</span><span>)</span><span>;</span>
		

		<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"******************获取私有构造方法，并调用*******************************"</span><span>)</span><span>;</span>
		con <span>=</span> clazz<span>.</span><span>getDeclaredConstructor</span><span>(</span><span>float</span><span>.</span><span>class</span><span>)</span><span>;</span>
		<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>con<span>)</span><span>;</span>
		<span>//调用构造方法</span>
		con<span>.</span><span>setAccessible</span><span>(</span><span>true</span><span>)</span><span>;</span><span>//暴力访问(忽略掉访问修饰符)</span>
		obj <span>=</span> con<span>.</span><span>newInstance</span><span>(</span><span>100</span><span>)</span><span>;</span>
	<span>}</span>


<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br></div></div><p>输出：</p>
<div><pre><code><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span>所有公有构造方法<span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span>
<span>public</span> <span><span>reflect<span>.</span></span>Hero</span><span>(</span><span><span>java<span>.</span>lang<span>.</span></span>String</span><span>,</span><span>float</span><span>)</span>
<span>public</span> <span><span>reflect<span>.</span></span>Hero</span><span>(</span><span>char</span><span>)</span>
<span>public</span> <span><span>reflect<span>.</span></span>Hero</span><span>(</span><span>)</span>
<span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span>所有的构造方法<span>(</span>包括：私有、受保护、默认、公有<span>)</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span>
<span>private</span> <span><span>reflect<span>.</span></span>Hero</span><span>(</span><span>float</span><span>)</span>
<span>protected</span> <span><span>reflect<span>.</span></span>Hero</span><span>(</span><span>boolean</span><span>)</span>
<span>public</span> <span><span>reflect<span>.</span></span>Hero</span><span>(</span><span><span>java<span>.</span>lang<span>.</span></span>String</span><span>,</span><span>float</span><span>)</span>
<span>public</span> <span><span>reflect<span>.</span></span>Hero</span><span>(</span><span>char</span><span>)</span>
<span>public</span> <span><span>reflect<span>.</span></span>Hero</span><span>(</span><span>)</span>
<span><span>reflect<span>.</span></span>Hero</span><span>(</span><span><span>java<span>.</span>lang<span>.</span></span>String</span><span>)</span>
<span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span>获取公有、无参的构造方法<span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span>
con <span>=</span> <span>public</span> <span><span>reflect<span>.</span></span>Hero</span><span>(</span><span>)</span>
调用了公有、无参构造方法执行了。。。
<span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span>获取私有构造方法，并调用<span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span>
<span>private</span> <span><span>reflect<span>.</span></span>Hero</span><span>(</span><span>float</span><span>)</span>
私有的构造方法   血量：<span>100.0</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><div><p>小结</p>
<p>1.获取构造器对象方法：</p>
<p>1).批量的方法：</p>
<p>​	public Constructor[] getConstructors()：所有&quot;公有的&quot;构造方法
​			public Constructor[] getDeclaredConstructors()：获取所有的构造方法(包括私有、受保护、默认、公有)</p>
<p>2).获取单个的方法:</p>
<p>​	public Constructor getConstructor(Class… parameterTypes): 获取单个的&quot;公有的&quot;构造方法</p>
<p>​	public Constructor getDeclaredConstructor(Class…parameterTypes):获取&quot;某个构造方法&quot;可以是私有的，或受保护、默认、公有；</p>
</div>
<hr>
<h3 id="三-获取成员变量并使用"> （三）获取成员变量并使用</h3>
<p><strong>基本步骤</strong></p>
<p>创建HeroPlus的对象 <code>new/反射</code></p>
<p>获取属性 <code>Field f1 = h.getDeclaredField(&quot;属性名&quot;)</code></p>
<p>修改属性 <code>f1.set(h，实参)</code>，注意这里的h是对象，不是类对象</p>
<p>1、新增HeroPlus类</p>
<div><pre><code><span>package</span> <span>reflect</span><span>;</span>
<span>public</span> <span>class</span> <span>HeroPlus</span> <span>{</span>
	<span>public</span> <span>String</span> name<span>;</span>
    <span>public</span> <span>float</span> hp<span>;</span>
    <span>public</span> <span>int</span> damage<span>;</span>
    <span>public</span> <span>int</span> id<span>;</span>
     
    <span>public</span> <span>String</span> <span>getName</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> name<span>;</span>
    <span>}</span>
    <span>public</span> <span>void</span> <span>setName</span><span>(</span><span>String</span> name<span>)</span> <span>{</span>
        <span>this</span><span>.</span>name <span>=</span> name<span>;</span>
    <span>}</span>
    <span>public</span> <span>HeroPlus</span><span>(</span><span>)</span><span>{</span>
         
    <span>}</span>
    <span>public</span> <span>HeroPlus</span><span>(</span><span>String</span> string<span>)</span> <span>{</span>
        name <span>=</span>string<span>;</span>
    <span>}</span>
 
    <span>@Override</span>
    <span>public</span> <span>String</span> <span>toString</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> <span>"Hero [name="</span> <span>+</span> name <span>+</span> <span>"]"</span><span>;</span>
    <span>}</span>
    <span>public</span> <span>boolean</span> <span>isDead</span><span>(</span><span>)</span> <span>{</span>
        <span>// TODO Auto-generated method stub</span>
        <span>return</span> <span>false</span><span>;</span>
    <span>}</span>
    <span>public</span> <span>void</span> <span>attackHero</span><span>(</span><span>HeroPlus</span> h2<span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>this</span><span>.</span>name<span>+</span> <span>" 正在攻击 "</span> <span>+</span> h2<span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br></div></div><p>2、获取属性并修改</p>
<div><pre><code><span>package</span> <span>reflect</span><span>;</span>

<span>import</span> <span>java<span>.</span>lang<span>.</span>reflect<span>.</span></span><span>Constructor</span><span>;</span>
<span>import</span> <span>java<span>.</span>lang<span>.</span>reflect<span>.</span></span><span>Field</span><span>;</span>

<span>public</span> <span>class</span> <span>ParaTest</span> <span>{</span>
	 <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
         <span>//HeroPlus h =new HeroPlus();</span>
         <span>//使用传统方式修改name的值为garen</span>
         <span>//h.name = "garen";</span>

         <span>try</span> <span>{</span>
             <span>// 获取Class对象</span>
             <span>Class</span> clazz <span>=</span> <span>Class</span><span>.</span><span>forName</span><span>(</span><span>"reflect.HeroPlus"</span><span>)</span><span>;</span>
             <span>// 获取HeroPlus的无参构造函数</span>
             <span>Constructor</span> con <span>=</span> clazz<span>.</span><span>getDeclaredConstructor</span><span>(</span><span>null</span><span>)</span><span>;</span>
             <span>// 创建一个HeroPlus对象</span>
             <span>HeroPlus</span> h <span>=</span> <span>(</span><span>HeroPlus</span><span>)</span> con<span>.</span><span>newInstance</span><span>(</span><span>)</span><span>;</span>
             <span>//使用传统方式修改name的值为garen</span>
             h<span>.</span>name <span>=</span> <span>"garen"</span><span>;</span>
             <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>h<span>)</span><span>;</span>

             <span>//获取类HeroPlus的名字叫做name的字段</span>
             <span>//Field f1= h.getClass().getDeclaredField("name");</span>
             <span>Field</span> f1<span>=</span> clazz<span>.</span><span>getDeclaredField</span><span>(</span><span>"name"</span><span>)</span><span>;</span>
             <span>//修改h对象的name字段</span>
             f1<span>.</span><span>set</span><span>(</span>h<span>,</span> <span>"teemo"</span><span>)</span><span>;</span>
             <span>//打印被修改后的值</span>
             <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>h<span>)</span><span>;</span>

         <span>}</span> <span>catch</span> <span>(</span><span>Exception</span> e<span>)</span> <span>{</span>
             <span>// TODO Auto-generated catch block</span>
             e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>
         <span>}</span>
 <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br></div></div><div><p>补充</p>
<p><strong>getField和getDeclaredField的区别</strong></p>
<p>getField 只能获取public的，包括从父类继承来的字段。</p>
<p>getDeclaredField 可以获取本类所有的字段，包括private的，但是 不能获取继承来的字段。 (注： 这里只能获取到private的字段，但</p>
<p>并不能访问该private字段的值,除非加上setAccessible(true))</p>
</div>
<hr>
<h3 id="四-获取成员方法并使用"> （四）获取成员方法并使用</h3>
<p><strong>基本步骤</strong></p>
<ol>
<li>
<p>创建HeroPlus的对象 <code>h</code></p>
</li>
<li>
<p>获取成员方法</p>
<p>public Method getMethod(String name ，Class&lt;?&gt;… parameterTypes):获取&quot;公有方法&quot;；（包含了父类的方法也包含Object类）</p>
<p>public Method getDeclaredMethods(String name ，Class&lt;?&gt;… parameterTypes) :获取成员方法，包括私有的(不包括继承的)</p>
<p><strong>参数解释</strong>：name : 方法名； Class … : 形参的Class类型对象</p>
</li>
<li>
<p>调用方法</p>
<p>Method --&gt; public Object invoke(Object obj,Object… args):</p>
<p><strong>参数说明</strong>： obj : 要调用方法的对象；args:调用方式时所传递的实参；</p>
</li>
</ol>
<div><pre><code><span>package</span> <span>reflect</span><span>;</span>

<span>import</span> <span>java<span>.</span>lang<span>.</span>reflect<span>.</span></span><span>Field</span><span>;</span>
<span>import</span> <span>java<span>.</span>lang<span>.</span>reflect<span>.</span></span><span>Method</span><span>;</span>

<span>public</span> <span>class</span> <span>MethodTest</span> <span>{</span>
	<span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>

	 <span>HeroPlus</span> h <span>=</span> <span>new</span> <span>HeroPlus</span><span>(</span><span>)</span><span>;</span>

     <span>try</span> <span>{</span>
         <span>// 获取这个名字叫做setName，参数类型是String的方法</span>
         <span>Method</span> m <span>=</span> h<span>.</span><span>getClass</span><span>(</span><span>)</span><span>.</span><span>getMethod</span><span>(</span><span>"setName"</span><span>,</span> <span>String</span><span>.</span><span>class</span><span>)</span><span>;</span>
         <span>// 对h对象，调用这个方法</span>
         m<span>.</span><span>invoke</span><span>(</span>h<span>,</span> <span>"盖伦"</span><span>)</span><span>;</span>
         <span>// 使用传统的方式，调用getName方法</span>
         <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>h<span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>
         <span>// 使用反射读取</span>
         <span>Field</span> f <span>=</span> h<span>.</span><span>getClass</span><span>(</span><span>)</span><span>.</span><span>getDeclaredField</span><span>(</span><span>"name"</span><span>)</span><span>;</span>
         <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>f<span>.</span><span>get</span><span>(</span>h<span>)</span><span>)</span><span>;</span>

     <span>}</span> <span>catch</span> <span>(</span><span>Exception</span> e<span>)</span> <span>{</span>
         <span>// TODO Auto-generated catch block</span>
         e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>
     <span>}</span>

 <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br></div></div><hr>
<h3 id="五-获取main方法并使用"> （五）获取main方法并使用</h3>
<p>1、HeroPlus 新增main方法</p>
<div><pre><code><span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
		<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"执行main方法"</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>2、通过下面步骤获取main方法<a href="https://blog.csdn.net/lililuni/article/details/83449088?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161284956016780274151023%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=161284956016780274151023&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-7-83449088.pc_search_result_no_baidu_js&amp;utm_term=java%E5%8F%8D%E5%B0%84#fn1" target="_blank" rel="noopener noreferrer">1</a></p>
<div><pre><code><span>package</span> <span>reflect</span><span>;</span>

<span>import</span> <span>java<span>.</span>lang<span>.</span>reflect<span>.</span></span><span>Method</span><span>;</span>

<span>public</span> <span>class</span> <span>MainTest</span> <span>{</span>
	<span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
		<span>try</span> <span>{</span>
			<span>//1、获取HeroPlus对象的Class实例</span>
			<span>Class</span> clazz <span>=</span> <span>Class</span><span>.</span><span>forName</span><span>(</span><span>"reflect.HeroPlus"</span><span>)</span><span>;</span>

			<span>//2、获取main方法,第一个参数：方法名称，第二个参数：方法形参的类型，</span>
			 <span>Method</span> methodMain <span>=</span> clazz<span>.</span><span>getMethod</span><span>(</span><span>"main"</span><span>,</span> <span>String</span><span>[</span><span>]</span><span>.</span><span>class</span><span>)</span><span>;</span>
			<span>//3、调用main方法</span>
			<span>// methodMain.invoke(null, new String[]{"a","b","c"});</span>
			<span>//第一个参数，对象类型，因为方法是static静态的，所以为null可以，第二个参数是String数组，这里要注意在jdk1.4时是数组，jdk1.5之后是可变参数</span>
			<span>//这里拆的时候将  new String[]{"a","b","c"} 拆成3个对象。所以需要将它强转。</span>
			 methodMain<span>.</span><span>invoke</span><span>(</span><span>null</span><span>,</span> <span>(</span><span>Object</span><span>)</span><span>new</span> <span>String</span><span>[</span><span>]</span><span>{</span><span>"a"</span><span>,</span><span>"b"</span><span>,</span><span>"c"</span><span>}</span><span>)</span><span>;</span><span>//方式一</span>
			<span>// methodMain.invoke(null, new Object[]{new String[]{"a","b","c"}});//方式二</span>

		<span>}</span> <span>catch</span> <span>(</span><span>Exception</span> e<span>)</span> <span>{</span>
			e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>
		<span>}</span>


	<span>}</span>
<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div><h2 id="七、关于反射的用法举例"> 七、关于反射的用法举例</h2>
<p>反射非常强大，但是从上面的记录来看，反而觉得还不如直接调用方法来的直接和方便。</p>
<p>通常来说，需要在学习了Spring 的依赖注入，反转控制之后，才会对反射有更好的理解，所以先这里举两个例子，来演示一下反射的一种实际运用。</p>
<h3 id="一-通过反射读取配置文件内容"> （一）通过反射读取配置文件内容</h3>
<p>1、首先准备两个业务类</p>
<div><pre><code><span>package</span> <span>service</span><span>;</span>
<span>public</span> <span>class</span> <span>Service1</span> <span>{</span>
    <span>public</span> <span>void</span> <span>doService1</span><span>(</span><span>)</span><span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"业务方法1"</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>

<span>package</span> <span>service</span><span>;</span>
<span>public</span> <span>class</span> <span>Service2</span> <span>{</span>
	<span>public</span> <span>void</span> <span>doService2</span><span>(</span><span>)</span><span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"业务方法2"</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>2、当需要从第一个业务方法切换到第二个业务方法的时候，使用非反射方式，必须修改代码，并且重新编译运行，才可以达到效果</p>
<div><pre><code><span>package</span> <span>service</span><span>;</span>
<span>public</span> <span>class</span> <span>CommonTest</span> <span>{</span>
	  <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
		  <span>//new Service1().doService1();</span>
		  <span>//必须重新修改代码</span>
	        <span>new</span> <span>Service2</span><span>(</span><span>)</span><span>.</span><span>doService2</span><span>(</span><span>)</span><span>;</span>
	    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>3、使用反射方式则方便很多</p>
<ol>
<li>首先准备一个配置文件，叫做config.properties, 放在resource目录下，里面存放的是类的名称和要调用的方法名。</li>
<li>在测试类Test中，首先取出类名称和方法名，然后通过反射去调用这个方法。</li>
<li>当需要从调用第一个业务方法，切换到调用第二个业务方法的时候，不需要修改一行代码，也不需要重新编译，只需要修改配置文件spring.txt，再运行即可。</li>
</ol>
<p>config.properties内容</p>
<div><pre><code><span>class</span><span>=</span><span><span>service<span>.</span></span>Service1</span>
method<span>=</span>doService1
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>测试类</p>
<div><pre><code><span>package</span> <span>service</span><span>;</span>

<span>import</span> <span>java<span>.</span>io<span>.</span></span><span>IOException</span><span>;</span>
<span>import</span> <span>java<span>.</span>io<span>.</span></span><span>InputStream</span><span>;</span>
<span>import</span> <span>java<span>.</span>lang<span>.</span>reflect<span>.</span></span><span>Constructor</span><span>;</span>
<span>import</span> <span>java<span>.</span>lang<span>.</span>reflect<span>.</span></span><span>Method</span><span>;</span>
<span>import</span> <span>java<span>.</span>util<span>.</span></span><span>Properties</span><span>;</span>

<span>public</span> <span>class</span> <span>ReflectTest</span> <span>{</span>
	<span>@SuppressWarnings</span><span>(</span><span>{</span> <span>"rawtypes"</span><span>,</span> <span>"unchecked"</span> <span>}</span><span>)</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>

        <span>//从spring.txt中获取类名称和方法名称</span>
        <span>InputStream</span> in <span>=</span> <span>ReflectTest</span><span>.</span><span>class</span><span>.</span><span>getResourceAsStream</span><span>(</span><span>"/config.properties"</span><span>)</span><span>;</span>
        <span>Properties</span> properties <span>=</span> <span>new</span> <span>Properties</span><span>(</span><span>)</span><span>;</span>
        <span>try</span> <span>{</span>
            properties<span>.</span><span>load</span><span>(</span>in<span>)</span><span>;</span>
        <span>}</span> <span>catch</span> <span>(</span><span>IOException</span> e<span>)</span> <span>{</span>
            e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>
        <span>}</span>
        <span>String</span> className <span>=</span> <span>(</span><span>String</span><span>)</span> properties<span>.</span><span>get</span><span>(</span><span>"class"</span><span>)</span><span>;</span>
        <span>String</span> methodName <span>=</span> <span>(</span><span>String</span><span>)</span> properties<span>.</span><span>get</span><span>(</span><span>"method"</span><span>)</span><span>;</span>

        <span>//根据类名称获取类对象</span>
        <span>Class</span> clazz <span>=</span> <span>Class</span><span>.</span><span>forName</span><span>(</span>className<span>)</span><span>;</span>
        <span>//根据方法名称，获取方法对象</span>
        <span>Method</span> m <span>=</span> clazz<span>.</span><span>getMethod</span><span>(</span>methodName<span>)</span><span>;</span>
        <span>//获取构造器</span>
        <span>Constructor</span> c <span>=</span> clazz<span>.</span><span>getConstructor</span><span>(</span><span>)</span><span>;</span>
        <span>//根据构造器，实例化出对象</span>
        <span>Object</span> service <span>=</span> c<span>.</span><span>newInstance</span><span>(</span><span>)</span><span>;</span>
        <span>//调用对象的指定方法</span>
        m<span>.</span><span>invoke</span><span>(</span>service<span>)</span><span>;</span>

    <span>}</span>
<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br></div></div><h3 id="二-通过反射越过泛型检查"> （二）通过反射越过泛型检查</h3>
<p>泛型是在编译期间起作用的。在编译后的.class文件中是没有泛型的。所有比如T或者E类型啊，本质都是通过Object处理的。所以可以通过使用反射来越过泛型。</p>
<div><pre><code><span>package</span> <span>reflect</span><span>;</span>

<span>import</span> <span>java<span>.</span>lang<span>.</span>reflect<span>.</span></span><span>Method</span><span>;</span>
<span>import</span> <span>java<span>.</span>util<span>.</span></span><span>ArrayList</span><span>;</span>

<span>public</span> <span>class</span> <span>GenericityTest</span> <span>{</span>
	<span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>throws</span> <span>Exception</span><span>{</span>

	<span>ArrayList</span><span><span>&lt;</span><span>String</span><span>></span></span> list <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
	list<span>.</span><span>add</span><span>(</span><span>"this"</span><span>)</span><span>;</span>
	list<span>.</span><span>add</span><span>(</span><span>"is"</span><span>)</span><span>;</span>

   <span>//list.add(5); //报错</span>

	<span>/********** 越过泛型检查    **************/</span>

	<span>//获取ArrayList的Class对象，反向的调用add()方法，添加数据</span>
	<span>Class</span> listClass <span>=</span> list<span>.</span><span>getClass</span><span>(</span><span>)</span><span>;</span>
	<span>//获取add()方法</span>
	<span>Method</span> m <span>=</span> listClass<span>.</span><span>getMethod</span><span>(</span><span>"add"</span><span>,</span> <span>Object</span><span>.</span><span>class</span><span>)</span><span>;</span>
	<span>//调用add()方法</span>
	m<span>.</span><span>invoke</span><span>(</span>list<span>,</span> <span>5</span><span>)</span><span>;</span>

	<span>//遍历集合</span>
	<span>for</span><span>(</span><span>Object</span> obj <span>:</span> list<span>)</span><span>{</span>
		<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>obj<span>)</span><span>;</span>
		<span>}</span>
	<span>}</span>

<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br></div></div><div><p>参考</p>
<p><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1255945389098144" target="_blank" rel="noopener noreferrer">廖雪峰Java教程 - 反射</a></p>
<p><a href="https://blog.csdn.net/lililuni/article/details/83449088?ops_request_misc=%25257B%252522request%25255Fid%252522%25253A%252522161284956016780274151023%252522%25252C%252522scm%252522%25253A%25252220140713.130102334..%252522%25257D&amp;request_id=161284956016780274151023&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-7-83449088.pc_search_result_no_baidu_js&amp;utm_term=java%25E5%258F%258D%25E5%25B0%2584" target="_blank" rel="noopener noreferrer">皮卡卡西- Java 反射</a></p>
</div>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <category term="Java"/>
    <contributor>
      <name>南辞</name>
    </contributor>
    <published>2021-02-16T17:39:43.000Z</published>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">JavaSE-正则表达式</title>
    <id>http://qiqi.dreamagain.top/program/backend/java/regex/</id>
    <link href="http://qiqi.dreamagain.top/program/backend/java/regex/"/>
    <updated>2021-02-16T17:39:43.000Z</updated>
    <content type="html"><![CDATA[<h2 id="一、概述"> 一、概述</h2>
<ul>
<li>用来描述或者匹配一系列符合某个语句规则的字符串</li>
</ul>
<h2 id="二、单字符匹配"> 二、单字符匹配</h2>
<p>单个字符的匹配规则主要有:</p>
<table>
<thead>
<tr>
<th style="text-align:left">正则表达式</th>
<th style="text-align:left">规则</th>
<th style="text-align:left">可以匹配</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>A</code></td>
<td style="text-align:left">指定字符</td>
<td style="text-align:left"><code>A</code></td>
</tr>
<tr>
<td style="text-align:left"><code>\u548c</code></td>
<td style="text-align:left">指定Unicode字符</td>
<td style="text-align:left"><code>和</code></td>
</tr>
<tr>
<td style="text-align:left"><code>.</code></td>
<td style="text-align:left">任意字符</td>
<td style="text-align:left"><code>a</code>，<code>b</code>，<code>&amp;</code>，<code>0</code></td>
</tr>
<tr>
<td style="text-align:left"><code>\d</code></td>
<td style="text-align:left">数字0~9</td>
<td style="text-align:left"><code>0</code>~<code>9</code></td>
</tr>
<tr>
<td style="text-align:left"><code>\w</code></td>
<td style="text-align:left">大小写字母，数字和下划线</td>
<td style="text-align:left"><code>a</code>~<code>z</code>，<code>A</code>~<code>Z</code>，<code>0</code>~<code>9</code>，<code>_</code></td>
</tr>
<tr>
<td style="text-align:left"><code>\s</code></td>
<td style="text-align:left">空格、Tab键</td>
<td style="text-align:left">空格，Tab</td>
</tr>
<tr>
<td style="text-align:left"><code>\D</code></td>
<td style="text-align:left">非数字</td>
<td style="text-align:left"><code>a</code>，<code>A</code>，<code>&amp;</code>，<code>_</code>，……</td>
</tr>
<tr>
<td style="text-align:left"><code>\W</code></td>
<td style="text-align:left">非\w</td>
<td style="text-align:left"><code>&amp;</code>，<code>@</code>，<code>中</code>，……</td>
</tr>
<tr>
<td style="text-align:left"><code>\S</code></td>
<td style="text-align:left">非\s</td>
<td style="text-align:left"><code>a</code>，<code>A</code>，<code>&amp;</code>，<code>_</code>，……</td>
</tr>
</tbody>
</table>
<p><strong>快捷符号</strong></p>
<p>1、<code>\d</code>表示<code>[0—9]</code></p>
<p>2、<code>\D</code>表示<code>[^0—9]</code></p>
<p>3、<code>\w</code>表示<code>[0—9A—Z_a—z]</code></p>
<p>4、<code>\W</code>表示<code>[^0—9A—Z_a—z]</code></p>
<p>5、<code>\s</code>表示<code>[\t\n\r\f]</code></p>
<p>6、<code>\S</code>表示<code>[^\t\n\r\f]</code></p>
<h2 id="三、多字符匹配"> 三、多字符匹配</h2>
<p>多个字符的匹配规则主要有：</p>
<table>
<thead>
<tr>
<th style="text-align:left">正则表达式</th>
<th style="text-align:left">规则</th>
<th style="text-align:left">可以匹配</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>A*</code></td>
<td style="text-align:left">任意个数字符</td>
<td style="text-align:left">空，<code>A</code>，<code>AA</code>，<code>AAA</code>，……</td>
</tr>
<tr>
<td style="text-align:left"><code>A+</code></td>
<td style="text-align:left">至少1个字符</td>
<td style="text-align:left"><code>A</code>，<code>AA</code>，<code>AAA</code>，……</td>
</tr>
<tr>
<td style="text-align:left"><code>A?</code></td>
<td style="text-align:left">0个或1个字符</td>
<td style="text-align:left">空，<code>A</code></td>
</tr>
<tr>
<td style="text-align:left"><code>A{3}</code></td>
<td style="text-align:left">指定个数字符</td>
<td style="text-align:left"><code>AAA</code></td>
</tr>
<tr>
<td style="text-align:left"><code>A{2,3}</code></td>
<td style="text-align:left">指定范围个数字符</td>
<td style="text-align:left"><code>AA</code>，<code>AAA</code></td>
</tr>
<tr>
<td style="text-align:left"><code>A{2,}</code></td>
<td style="text-align:left">至少n个字符</td>
<td style="text-align:left"><code>AA</code>，<code>AAA</code>，<code>AAAA</code>，……</td>
</tr>
<tr>
<td style="text-align:left"><code>A{0,3}</code></td>
<td style="text-align:left">最多n个字符</td>
<td style="text-align:left">空，<code>A</code>，<code>AA</code>，<code>AAA</code></td>
</tr>
</tbody>
</table>
<h2 id="四、复杂匹配"> 四、复杂匹配</h2>
<p>复杂匹配规则主要有：</p>
<table>
<thead>
<tr>
<th style="text-align:left">正则表达式</th>
<th style="text-align:left">规则</th>
<th style="text-align:left">可以匹配</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">^</td>
<td style="text-align:left">开头</td>
<td style="text-align:left">字符串开头</td>
</tr>
<tr>
<td style="text-align:left">$</td>
<td style="text-align:left">结尾</td>
<td style="text-align:left">字符串结束</td>
</tr>
<tr>
<td style="text-align:left">[ABC]</td>
<td style="text-align:left">[…]内任意字符</td>
<td style="text-align:left">A，B，C</td>
</tr>
<tr>
<td style="text-align:left">[A-F0-9xy]</td>
<td style="text-align:left">指定范围的字符</td>
<td style="text-align:left"><code>A</code>，……，<code>F</code>，<code>0</code>，……，<code>9</code>，<code>x</code>，<code>y</code></td>
</tr>
<tr>
<td style="text-align:left">[^A-F]</td>
<td style="text-align:left">指定范围外的任意字符</td>
<td style="text-align:left">非<code>A</code>~<code>F</code></td>
</tr>
<tr>
<td style="text-align:left">AB|CD|EF</td>
<td style="text-align:left">AB或CD或EF</td>
<td style="text-align:left"><code>AB</code>，<code>CD</code>，<code>EF</code></td>
</tr>
</tbody>
</table>
<h2 id="五、分组匹配"> 五、分组匹配</h2>
<p><code>(...)</code>可以用来把一个子规则括起来，这样写<code>learn\s(java|php|go)</code>就可以更方便地匹配</p>
<p><code>learn java</code>、<code>learn php</code>  、 <code>learn go</code>这样的长字符串了</p>
<p>除此以外，<code>(...)</code>还有一个重要作用，就是分组匹配</p>
<p>用<code>(...)</code>先把要提取的规则分组，把上述正则表达式变为像<code>(^0\d{2})-(\d{6,8})</code>这样。</p>
<p>现在问题又来了：匹配后，如何按括号提取子串？</p>
<p>现在我们没办法用<code>String.matches()</code>这样简单的判断方法了，必须引入<code>java.util.regex</code>包，用<code>Pattern</code>对象匹配，匹配后获得一个<code>Matcher</code>对象，如果匹配成功，就可以直接从<code>Matcher.group(index)</code>返回子串：</p>
<div><pre><code><span>public</span> <span>class</span> <span>Main</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>//匹配国内的电话号码规则：3~4位区号加7~8位电话，中间用-连接，且国内区号必须以0开头</span>
        <span>//例如：010-12345678</span>
        <span>Pattern</span> p <span>=</span> <span>Pattern</span><span>.</span><span>compile</span><span>(</span><span>"(^0\\d{2,3})-(\\d{7,8})"</span><span>)</span><span>;</span>
        <span>Matcher</span> m <span>=</span> p<span>.</span><span>matcher</span><span>(</span><span>"010-12345678"</span><span>)</span><span>;</span>
        <span>if</span> <span>(</span>m<span>.</span><span>matches</span><span>(</span><span>)</span><span>)</span> <span>{</span>
            <span>String</span> g1 <span>=</span> m<span>.</span><span>group</span><span>(</span><span>1</span><span>)</span><span>;</span>
            <span>String</span> g2 <span>=</span> m<span>.</span><span>group</span><span>(</span><span>2</span><span>)</span><span>;</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>g1<span>)</span><span>;</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>g2<span>)</span><span>;</span>
        <span>}</span> <span>else</span> <span>{</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"匹配失败!"</span><span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><div><p>注意</p>
<p>区分三个概念，原串，正则表达式，java字符串</p>
<p>原串是a&amp;c，那么由于&amp;在正则表达式中属于特殊字符，因此正则表达式中需要转义，即写为a&amp;c</p>
<p>又因为java字符串中，\也是特殊字符，因此需要转义写成\，综合写就是a\&amp;c</p>
<p>所以java字符串&quot;a\&amp;c&quot;表示的正则表达式为&quot;a&amp;c&quot;，表示的原串内容为&quot;a&amp;c&quot;</p>
</div>
<div><p>相关信息</p>
<p>正则表达式代码可以使用<code>String.matches()</code>方法，而我们在分组提取的代码中用的是<code>java.util.regex</code>包里面的<code>Pattern</code>类和<code>Matcher</code>类。实际上这两种代码本质上是一样的，因为<code>String.matches()</code>方法内部调用的就是<code>Pattern</code>和<code>Matcher</code>类的方法。</p>
</div>
<p>但是反复使用<code>String.matches()</code>对同一个正则表达式进行多次匹配效率较低，因为每次都会创建出一样的<code>Pattern</code>对象。完全可以先创建出一个<code>Pattern</code>对象，然后反复使用，就可以实现编译一次，多次匹配,如下示例：</p>
<div><pre><code><span>public</span> <span>class</span> <span>Main</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>Pattern</span> pattern <span>=</span> <span>Pattern</span><span>.</span><span>compile</span><span>(</span><span>"(^0\\d{2,3})-(\\d{7,8})"</span><span>)</span><span>;</span>
        pattern<span>.</span><span>matcher</span><span>(</span><span>"010-12345678"</span><span>)</span><span>.</span><span>matches</span><span>(</span><span>)</span><span>;</span> <span>// true</span>
        pattern<span>.</span><span>matcher</span><span>(</span><span>"021-123456"</span><span>)</span><span>.</span><span>matches</span><span>(</span><span>)</span><span>;</span> <span>// true</span>
        pattern<span>.</span><span>matcher</span><span>(</span><span>"022#1234567"</span><span>)</span><span>.</span><span>matches</span><span>(</span><span>)</span><span>;</span> <span>// false</span>
        <span>// 获得Matcher对象:</span>
        <span>Matcher</span> matcher <span>=</span> pattern<span>.</span><span>matcher</span><span>(</span><span>"010-12345678"</span><span>)</span><span>;</span>
        <span>if</span> <span>(</span>matcher<span>.</span><span>matches</span><span>(</span><span>)</span><span>)</span> <span>{</span>
            <span>String</span> whole <span>=</span> matcher<span>.</span><span>group</span><span>(</span><span>0</span><span>)</span><span>;</span> <span>// "010-12345678", 0表示匹配的整个字符串</span>
            <span>String</span> area <span>=</span> matcher<span>.</span><span>group</span><span>(</span><span>1</span><span>)</span><span>;</span> <span>// "010", 1表示匹配的第1个子串</span>
            <span>String</span> tel <span>=</span> matcher<span>.</span><span>group</span><span>(</span><span>2</span><span>)</span><span>;</span> <span>// "12345678", 2表示匹配的第2个子串</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>area<span>)</span><span>;</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>tel<span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><h2 id="六、非贪婪匹配"> 六、非贪婪匹配</h2>
<h3 id="一-贪婪匹配"> （一）贪婪匹配</h3>
<p>在介绍非贪婪匹配之前必须了解什么是贪婪匹配：</p>
<div><p>贪婪匹配</p>
<p>正则表达式默认使用贪婪匹配：任何一个规则，它总是尽可能多地向后匹配</p>
</div>
<p><strong>案例分析：</strong></p>
<p>期望将将字符串末尾的所有0提取，想到使用分组匹配，正则：<code>(\d+)(0*)</code></p>
<div><pre><code><span>public</span> <span>class</span> <span>Main</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>Pattern</span> pattern <span>=</span> <span>Pattern</span><span>.</span><span>compile</span><span>(</span><span>"(\\d+)(0*)"</span><span>)</span><span>;</span>
        <span>Matcher</span> matcher <span>=</span> pattern<span>.</span><span>matcher</span><span>(</span><span>"1230000"</span><span>)</span><span>;</span>
        <span>if</span> <span>(</span>matcher<span>.</span><span>matches</span><span>(</span><span>)</span><span>)</span> <span>{</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"group1="</span> <span>+</span> matcher<span>.</span><span>group</span><span>(</span><span>1</span><span>)</span><span>)</span><span>;</span> <span>// "1230000"</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"group2="</span> <span>+</span> matcher<span>.</span><span>group</span><span>(</span><span>2</span><span>)</span><span>)</span><span>;</span> <span>// ""</span>
        <span>}</span>
    <span>}</span>
<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>我们期望分组匹配结果是：</p>
<table>
<thead>
<tr>
<th style="text-align:left">input</th>
<th style="text-align:left"><code>\d+</code></th>
<th style="text-align:left"><code>0*</code></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">123000</td>
<td style="text-align:left">&quot;123&quot;</td>
<td style="text-align:left">&quot;000&quot;</td>
</tr>
<tr>
<td style="text-align:left">10100</td>
<td style="text-align:left">&quot;101&quot;</td>
<td style="text-align:left">&quot;00&quot;</td>
</tr>
<tr>
<td style="text-align:left">1001</td>
<td style="text-align:left">&quot;1001&quot;</td>
<td style="text-align:left">&quot;&quot;</td>
</tr>
</tbody>
</table>
<p>但实际的分组匹配结果是这样的：</p>
<table>
<thead>
<tr>
<th style="text-align:left">input</th>
<th style="text-align:left"><code>\d+</code></th>
<th style="text-align:left"><code>0*</code></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">123000</td>
<td style="text-align:left">&quot;123000&quot;</td>
<td style="text-align:left">&quot;&quot;</td>
</tr>
<tr>
<td style="text-align:left">10100</td>
<td style="text-align:left">&quot;10100&quot;</td>
<td style="text-align:left">&quot;&quot;</td>
</tr>
<tr>
<td style="text-align:left">1001</td>
<td style="text-align:left">&quot;1001&quot;</td>
<td style="text-align:left">&quot;&quot;</td>
</tr>
</tbody>
</table>
<p>分析原因：</p>
<p>因为<code>\d+</code>确实可以匹配后面任意个<code>0</code>。正则表达式默认使用贪婪匹配，因此，<code>\d+</code>总是会把后面的<code>0</code>包含进来。</p>
<p>要让<code>\d+</code>尽量少匹配，让<code>0*</code>尽量多匹配，我们就必须让<code>\d+</code>使用非贪婪匹配。在规则<code>\d+</code>后面加个<code>?</code>即可表示非贪婪匹配。我们改写正则表达式为<code>(\d+?)(0*)</code>即可得到我们期望的结果。</p>
<h3 id="二-非贪婪匹配"> （二）非贪婪匹配</h3>
<blockquote>
<p>正则表达式<code>(\d??)(9*)</code></p>
</blockquote>
<p>注意<code>\d?</code>表示匹配0个或1个数字，后面第二个<code>?</code>表示非贪婪匹配。</p>
<p>给定字符串<code>&quot;9999&quot;</code>，匹配到的两个子串分别是<code>&quot;&quot;</code>和<code>&quot;9999&quot;</code>，因为对于<code>\d?</code>来说，可以匹配1个<code>9</code>，也可以匹配0个<code>9</code>，但是因为后面的<code>?</code>表示非贪婪匹配，它就会尽可能少的匹配，结果是匹配了0个<code>9</code>。</p>
<div><p>小结</p>
<p>正则表达式匹配默认使用贪婪匹配，给定一个匹配规则，加上<code>?</code>后就变成了非贪婪匹配。</p>
<p>注意区分<code>?</code>的含义：<code>\d??</code>。</p>
</div>
<h2 id="七、正则相关类"> 七、正则相关类</h2>
<h3 id="一-类"> （一）类</h3>
<p>java.util.regex 包主要包括以下三个类：</p>
<ul>
<li>
<p>Pattern 类：</p>
<p>pattern 对象是一个正则表达式的编译表示。Pattern 类没有公共构造方法。要创建一个 Pattern 对象，你必须首先调用其公共静态编译方法，它返回一个 Pattern 对象。该方法接受一个正则表达式作为它的第一个参数。如：</p>
<div><pre><code> <span>Pattern</span> p <span>=</span> <span>Pattern</span><span>.</span><span>compile</span><span>(</span><span>"\\wo\\w"</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div></li>
<li>
<p>Matcher 类：</p>
<p>Matcher 对象是对输入字符串进行解释和匹配操作的引擎。与Pattern 类一样，Matcher 也没有公共构造方法。你需要调用 Pattern 对象的 matcher 方法来获得一个 Matcher 对象。如：</p>
<div><pre><code> <span>Matcher</span> m <span>=</span> p<span>.</span><span>matcher</span><span>(</span><span>"hello regex"</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div></li>
<li>
<p>PatternSyntaxException：</p>
<p>PatternSyntaxException 是一个非强制异常类，它表示一个正则表达式模式中的语法错误。</p>
</li>
</ul>
<h3 id="二-捕获组"> （二）捕获组</h3>
<p>正是上文提到的分组匹配，这里补充一些相关概念以及方法的使用</p>
<p>捕获组是通过从左至右计算其开括号来编号。例如，在表达式（（A）（B（C））），有四个这样的组：</p>
<ul>
<li>((A)(B(C)))</li>
<li>(A)</li>
<li>(B(C))</li>
<li>(C)</li>
</ul>
<p>可以通过调用 matcher 对象的 groupCount 方法来查看表达式有多少个分组。groupCount 方法返回一个 int 值，表示matcher对象当前有多个捕获组。其实很简单，就是 <mark>看括号的层数，跟数据结构中提到的广义表深度类似</mark>。</p>
<p>还有一个特殊的组（group(0)），它总是代表整个表达式。<strong>该组不包括在 groupCount 的返回值中</strong>。</p>
<p><strong>示例</strong>：</p>
<div><pre><code><span>package</span> <span>regex</span><span>;</span>


<span>import</span> <span>org<span>.</span>junit<span>.</span>jupiter<span>.</span>api<span>.</span></span><span>Test</span><span>;</span>

<span>import</span> <span>java<span>.</span>util<span>.</span></span><span>HashMap</span><span>;</span>
<span>import</span> <span>java<span>.</span>util<span>.</span></span><span>Map</span><span>;</span>
<span>import</span> <span>java<span>.</span>util<span>.</span>regex<span>.</span></span><span>Matcher</span><span>;</span>
<span>import</span> <span>java<span>.</span>util<span>.</span>regex<span>.</span></span><span>Pattern</span><span>;</span>

<span>import</span> <span>static</span> <span>org<span>.</span>junit<span>.</span>jupiter<span>.</span>api<span>.</span></span><span>Assertions</span><span>.</span>assertEquals<span>;</span>


<span>class</span> <span>TemplateTest</span> <span>{</span>

	<span>@Test</span>
	<span>public</span> <span>void</span> <span>testIsValidTel</span><span>(</span><span>)</span> <span>{</span>
		<span>Template</span> t <span>=</span> <span>new</span> <span>Template</span><span>(</span><span>"Hello, ${name}! You are learning ${lang}!"</span><span>)</span><span>;</span>
		<span>Map</span><span><span>&lt;</span><span>String</span><span>,</span> <span>Object</span><span>></span></span> data <span>=</span> <span>new</span> <span>HashMap</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
		data<span>.</span><span>put</span><span>(</span><span>"name"</span><span>,</span> <span>"Bob"</span><span>)</span><span>;</span>
		data<span>.</span><span>put</span><span>(</span><span>"lang"</span><span>,</span> <span>"Java"</span><span>)</span><span>;</span>
		<span>assertEquals</span><span>(</span><span>"Hello, Bob! You are learning Java!"</span><span>,</span> t<span>.</span><span>render</span><span>(</span>data<span>)</span><span>)</span><span>;</span>
	<span>}</span>
	<span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span> <span>String</span><span>[</span><span>]</span> args <span>)</span><span>{</span>

		<span>// 按指定模式在字符串查找</span>
		<span>String</span> line <span>=</span> <span>"This order was placed for QT3000! OK?"</span><span>;</span>
		<span>String</span> pattern <span>=</span> <span>"(\\D*)(\\d+)(.*)"</span><span>;</span>

		<span>// 创建 Pattern 对象</span>
		<span>Pattern</span> r <span>=</span> <span>Pattern</span><span>.</span><span>compile</span><span>(</span>pattern<span>)</span><span>;</span>

		<span>// 现在创建 matcher 对象</span>
		<span>Matcher</span> m <span>=</span> r<span>.</span><span>matcher</span><span>(</span>line<span>)</span><span>;</span>
		<span>if</span> <span>(</span>m<span>.</span><span>find</span><span>(</span> <span>)</span><span>)</span> <span>{</span>
			<span>// 多少个分组</span>
			<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>m<span>.</span><span>groupCount</span><span>(</span><span>)</span><span>)</span><span>;</span>
			<span>//特殊的组group(0)，它总是代表整个表达式。该组不包括在 groupCount 的返回值中</span>
			<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"Found value: "</span> <span>+</span> m<span>.</span><span>group</span><span>(</span><span>0</span><span>)</span> <span>)</span><span>;</span>
			<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"Found value: "</span> <span>+</span> m<span>.</span><span>group</span><span>(</span><span>1</span><span>)</span> <span>)</span><span>;</span>
			<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"Found value: "</span> <span>+</span> m<span>.</span><span>group</span><span>(</span><span>2</span><span>)</span> <span>)</span><span>;</span>
			<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"Found value: "</span> <span>+</span> m<span>.</span><span>group</span><span>(</span><span>3</span><span>)</span> <span>)</span><span>;</span>
		<span>}</span> <span>else</span> <span>{</span>
			<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"NO MATCH"</span><span>)</span><span>;</span>
		<span>}</span>
	<span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br></div></div><div><pre><code>结果：
3
Found value: This order was placed for QT3000! OK?
Found value: This order was placed for QT
Found value: 3000
Found value: ! OK?
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h2 id="八、java-中正则表达式的应用"> 八、Java 中正则表达式的应用</h2>
<h3 id="一-判断功能"> （一）判断功能</h3>
<ul>
<li><code>public boolean matches(String regex)</code></li>
</ul>
<p>案例：判断录入的手机号是否为13或者18开头</p>
<div><pre><code><span>package</span> <span>Lemon</span><span>;</span>

<span>import</span> <span>java<span>.</span>util<span>.</span></span><span>Scanner</span><span>;</span>

<span>public</span> <span>class</span> <span>RegexDm</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span><span>{</span>
        <span>Scanner</span> sc <span>=</span> <span>new</span> <span>Scanner</span><span>(</span><span>System</span><span>.</span>in<span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"请输入手机号："</span><span>)</span><span>;</span>
        <span>String</span> s <span>=</span> sc<span>.</span><span>nextLine</span><span>(</span><span>)</span><span>;</span>

        <span>String</span> regex <span>=</span> <span>"1[38]\\d{9}"</span><span>;</span><span>//定义手机好规则</span>
        <span>boolean</span> flag <span>=</span> s<span>.</span><span>matches</span><span>(</span>regex<span>)</span><span>;</span><span>//判断功能</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"flag:"</span><span>+</span>flag<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><h3 id="二-分割功能"> （二）分割功能</h3>
<ul>
<li><code>public String[] split(String regex)</code></li>
</ul>
<div><pre><code><span>"a b c"</span><span>.</span><span>split</span><span>(</span><span>"\\s"</span><span>)</span><span>;</span> <span>// { "a", "b", "c" }</span>
<span>"a b  c"</span><span>.</span><span>split</span><span>(</span><span>"\\s"</span><span>)</span><span>;</span> <span>// { "a", "b", "", "c" }</span>
<span>"a, b ;; c"</span><span>.</span><span>split</span><span>(</span><span>"[\\,\\;\\s]+"</span><span>)</span><span>;</span> <span>// { "a", "b", "c" }</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>案例：</p>
<div><pre><code><span>package</span> <span>Lemon</span><span>;</span>

<span>import</span> <span>java<span>.</span>util<span>.</span></span><span>Scanner</span><span>;</span>

<span>public</span> <span>class</span> <span>RegexDm</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span><span>{</span>
        <span>String</span> age <span>=</span> <span>"18-24"</span><span>;</span><span>//定义年龄范围</span>
        <span>String</span> regex <span>=</span> <span>"-"</span><span>;</span>
        <span>String</span><span>[</span><span>]</span> strArr <span>=</span> age<span>.</span><span>split</span><span>(</span>regex<span>)</span><span>;</span><span>//分割成字符串数组</span>

        <span>int</span> startAge <span>=</span> <span>Integer</span><span>.</span><span>parseInt</span><span>(</span>strArr<span>[</span><span>0</span><span>]</span><span>)</span><span>;</span>
        <span>int</span> endAge <span>=</span> <span>Integer</span><span>.</span><span>parseInt</span><span>(</span>strArr<span>[</span><span>1</span><span>]</span><span>)</span><span>;</span>

        <span>Scanner</span> sc <span>=</span> <span>new</span> <span>Scanner</span><span>(</span><span>System</span><span>.</span>in<span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"请输入您的年龄："</span><span>)</span><span>;</span>
        <span>int</span> a <span>=</span> sc<span>.</span><span>nextInt</span><span>(</span><span>)</span><span>;</span>
        <span>if</span> <span>(</span>a <span>>=</span> startAge <span>&amp;&amp;</span> a <span>&lt;=</span> endAge<span>)</span><span>{</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"你就是我想找的"</span><span>)</span><span>;</span>
        <span>}</span><span>else</span><span>{</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"滚"</span><span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><h3 id="三-搜索功能"> （三）搜索功能</h3>
<ul>
<li><code>Matcher.find()</code></li>
</ul>
<div><pre><code><span>public</span> <span>class</span> <span>Main</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>String</span> s <span>=</span> <span>"the quick brown fox jumps over the lazy dog."</span><span>;</span>
        <span>Pattern</span> p <span>=</span> <span>Pattern</span><span>.</span><span>compile</span><span>(</span><span>"\\wo\\w"</span><span>)</span><span>;</span>
        <span>Matcher</span> m <span>=</span> p<span>.</span><span>matcher</span><span>(</span>s<span>)</span><span>;</span>
        <span>while</span> <span>(</span>m<span>.</span><span>find</span><span>(</span><span>)</span><span>)</span> <span>{</span>
            <span>String</span> sub <span>=</span> s<span>.</span><span>substring</span><span>(</span>m<span>.</span><span>start</span><span>(</span><span>)</span><span>,</span> m<span>.</span><span>end</span><span>(</span><span>)</span><span>)</span><span>;</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>sub<span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
<span>/**
 * 输出结果：
 *row
 *fox
 *dog
 */</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p>我们获取到<code>Matcher</code>对象后，不需要调用<code>matches()</code>方法（因为匹配整个串肯定返回false），而是反复调用<code>find()</code>方法，在整个串中搜索能匹配上<code>\\wo\\w</code>规则的子串，并打印出来。这种方式比<code>String.indexOf()</code>要灵活得多，因为我们搜索的规则是3个字符：中间必须是<code>o</code>，前后两个必须是字符<code>[A-Za-z0-9_]</code>。</p>
<h3 id="四-替换功能"> （四）替换功能</h3>
<ul>
<li><code>public String replaceAll(String regex,String replacement)</code></li>
</ul>
<p>案例：</p>
<div><pre><code><span>package</span> <span>Lemon</span><span>;</span>

<span>public</span> <span>class</span> <span>RegexDm</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span><span>{</span>
        <span>String</span> s <span>=</span> <span>"12342jasfkgnas234"</span><span>;</span>
        <span>//把字符串里面的数字替换成*</span>
        <span>String</span> regex <span>=</span> <span>"\\d"</span><span>;</span>
        <span>String</span> ss <span>=</span> <span>"*"</span><span>;</span>
        <span>String</span> result <span>=</span> s<span>.</span><span>replaceAll</span><span>(</span>regex<span>,</span>ss<span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>result<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h3 id="五-反向引用"> （五）反向引用</h3>
<p>如果我们要把搜索到的指定字符串按规则替换，比如前后各加一个<code>&lt;b&gt;xxxx&lt;/b&gt;</code>，这个时候，使用<code>replaceAll()</code>的时候，我们传入的第二个参数可以使用<code>$1</code>、<code>$2</code>来反向引用匹配到的子串。例如：</p>
<div><pre><code><span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
    <span>String</span> s <span>=</span> <span>"the quick brown fox jumps over the lazy dog."</span><span>;</span>
    <span>String</span> r <span>=</span> s<span>.</span><span>replaceAll</span><span>(</span><span>"\\s([a-z]{4})\\s"</span><span>,</span> <span>" &lt;b>$1&lt;/b> "</span><span>)</span><span>;</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>r<span>)</span><span>;</span>
<span>}</span>
<span>}</span>
<span>// 运行结果：</span>
<span>// the quick brown fox jumps &lt;b>over&lt;/b> the &lt;b>lazy&lt;/b> dog.</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><div><p>提示</p>
<p>实现替换的关键就在于<code>&quot; &lt;b&gt;$1&lt;/b&gt; &quot;</code>，它用匹配的分组子串<code>([a-z]{4})</code>替换了<code>$1</code></p>
</div>
<h3 id="六-练习"> （六）练习</h3>
<p>模板引擎是指，定义一个字符串作为模板：</p>
<div><pre><code><span>Hello</span><span>,</span> $<span>{</span>name<span>}</span><span>!</span> <span>You</span> are learning $<span>{</span>lang<span>}</span><span>!</span>
</code></pre>
<div><span>1</span><br></div></div><p>其中，以<code>${key}</code>表示的是变量，也就是将要被替换的内容</p>
<p>当传入一个<code>Map&lt;String, String&gt;</code>给模板后，需要把对应的key替换为Map的value。</p>
<p>例如，传入<code>Map</code>为：</p>
<div><pre><code><span>{</span>
    <span>"name"</span><span>:</span> <span>"Bob"</span><span>,</span>
    <span>"lang"</span><span>:</span> <span>"Java"</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>然后，<code>${name}</code>被替换为<code>Map</code>对应的值&quot;Bob”，<code>${lang}</code>被替换为<code>Map</code>对应的值&quot;Java&quot;，最终输出的结果为：</p>
<div><pre><code><span>Hello</span><span>,</span> <span>Bob</span><span>!</span> <span>You</span> are learning <span>Java</span><span>!</span>
</code></pre>
<div><span>1</span><br></div></div><p>请编写一个简单的模板引擎，利用正则表达式实现这个功能。</p>
<div><pre><code><span>package</span> <span>regex</span><span>;</span>

<span>import</span> <span>java<span>.</span>util<span>.</span></span><span>Map</span><span>;</span>
<span>import</span> <span>java<span>.</span>util<span>.</span>regex<span>.</span></span><span>Matcher</span><span>;</span>
<span>import</span> <span>java<span>.</span>util<span>.</span>regex<span>.</span></span><span>Pattern</span><span>;</span>

<span>/**
 * Learn Java from https://www.liaoxuefeng.com/
 *
 * @author liaoxuefeng
 */</span>
<span>public</span> <span>class</span> <span>Template</span> <span>{</span>

	<span>final</span> <span>String</span> template<span>;</span>
	<span>final</span> <span>Pattern</span> pattern <span>=</span> <span>Pattern</span><span>.</span><span>compile</span><span>(</span><span>"\\$\\{(\\w+)\\}"</span><span>)</span><span>;</span>

	<span>public</span> <span>Template</span><span>(</span><span>String</span> template<span>)</span> <span>{</span>
		<span>this</span><span>.</span>template <span>=</span> template<span>;</span>
	<span>}</span>
	<span>public</span> <span>String</span> <span>render</span><span>(</span><span>Map</span><span><span>&lt;</span><span>String</span><span>,</span> <span>Object</span><span>></span></span> data<span>)</span> <span>{</span>
	    <span>Matcher</span> m <span>=</span> pattern<span>.</span><span>matcher</span><span>(</span>template<span>)</span><span>;</span>
	    <span>StringBuffer</span> sb<span>=</span><span>new</span> <span>StringBuffer</span><span>(</span><span>)</span><span>;</span>
	    <span>while</span> <span>(</span>m<span>.</span><span>find</span><span>(</span><span>)</span><span>)</span> <span>{</span>
            <span>//从头开始将template的字符复制到sb上直到有字符被替换。第一次复制完成，sb里面存的是“Hello, Bob”</span>
            m<span>.</span><span>appendReplacement</span><span>(</span>sb<span>,</span>data<span>.</span><span>get</span><span>(</span>m<span>.</span><span>group</span><span>(</span><span>1</span><span>)</span><span>)</span><span>.</span><span>toString</span><span>(</span><span>)</span><span>)</span><span>;</span>
	    <span>}</span>
	    <span>//循环结束时sb里面存的是“Hello, Bob! You are learning java”</span>
        m<span>.</span><span>appendTail</span><span>(</span>sb<span>)</span><span>;</span><span>//将最后一次替换后剩下的字符复制到sb上</span>
        <span>return</span> sb<span>.</span><span>toString</span><span>(</span><span>)</span><span>;</span><span>//“Hello, Bob! You are learning java!”</span>

	<span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br></div></div><p>测试：</p>
<div><pre><code><span>package</span> <span>regex</span><span>;</span>


<span>import</span> <span>org<span>.</span>junit<span>.</span>jupiter<span>.</span>api<span>.</span></span><span>Test</span><span>;</span>

<span>import</span> <span>java<span>.</span>util<span>.</span></span><span>HashMap</span><span>;</span>
<span>import</span> <span>java<span>.</span>util<span>.</span></span><span>Map</span><span>;</span>

<span>import</span> <span>static</span> <span>org<span>.</span>junit<span>.</span>jupiter<span>.</span>api<span>.</span></span><span>Assertions</span><span>.</span>assertEquals<span>;</span>


<span>class</span> <span>TemplateTest</span> <span>{</span>

	<span>@Test</span>
	<span>public</span> <span>void</span> <span>testIsValidTel</span><span>(</span><span>)</span> <span>{</span>
		<span>Template</span> t <span>=</span> <span>new</span> <span>Template</span><span>(</span><span>"Hello, ${name}! You are learning ${lang}!"</span><span>)</span><span>;</span>
		<span>Map</span><span><span>&lt;</span><span>String</span><span>,</span> <span>Object</span><span>></span></span> data <span>=</span> <span>new</span> <span>HashMap</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
		data<span>.</span><span>put</span><span>(</span><span>"name"</span><span>,</span> <span>"Bob"</span><span>)</span><span>;</span>
		data<span>.</span><span>put</span><span>(</span><span>"lang"</span><span>,</span> <span>"Java"</span><span>)</span><span>;</span>
		<span>assertEquals</span><span>(</span><span>"Hello, Bob! You are learning Java!"</span><span>,</span> t<span>.</span><span>render</span><span>(</span>data<span>)</span><span>)</span><span>;</span>
	<span>}</span>
<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><h2 id="九、常用正则表达式"> 九、常用正则表达式</h2>
<h4 id="元字符及其在正则表达式上下文中的行为"> 元字符及其在正则表达式上下文中的行为</h4>
<ul>
<li><code>\</code> 将下一个字符标记为一个特殊字符、或一个原义字符、或一个后向引用、或一个八进制转义符。</li>
<li><code>^</code> 匹配输入字符串的开始位置。如果设置了 RegExp 对象的Multiline 属性，<code>^</code> 也匹配 <code>\n</code>或 <code>\r</code>之后的位置。</li>
<li><code>$</code> 匹配输入字符串的结束位置。如果设置了 RegExp 对象的Multiline 属性，<code>$</code> 也匹配 <code>\n</code>或 <code>\r</code>之前的位置。</li>
<li><code>*</code> 匹配前面的子表达式零次或多次。</li>
<li><code>+</code> 匹配前面的子表达式一次或多次。<code>+</code> 等价于 <code>{1,}</code>。</li>
<li><code>?</code> 匹配前面的子表达式零次或一次。<code>?</code> 等价于 <code>{0,1}</code>。</li>
<li><code>{n}</code> n 是一个非负整数，匹配确定的n 次。</li>
<li><code>{n,}</code> n 是一个非负整数，至少匹配n 次。</li>
<li><code>{n,m}</code> m 和 n 均为非负整数，其中n &lt;= m。最少匹配 n 次且最多匹配 m 次。在逗号和两个数之间不能有空格。</li>
<li><code>?</code> 当该字符紧跟在任何一个其他限制符 <code>(*, +, ?, {n}, {n,}, {n,m})</code> 后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。</li>
<li><code>.</code> 匹配除 <code>\n</code>之外的任何单个字符。要匹配包括 <code>\n</code> 在内的任何字符，请使用象 <code>[.\n]</code>的模式。</li>
<li><code>(pattern)</code> 匹配pattern 并获取这一匹配。</li>
<li><code>(?:pattern)</code> 匹配pattern 但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。</li>
<li><code>(?=pattern)</code> 正向预查，在任何匹配 pattern 的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。</li>
<li><code>(?!pattern)</code> 负向预查，与<code>(?=pattern)</code>作用相反</li>
<li><code>x|y</code> 匹配 <code>x</code> 或 <code>y</code>。</li>
<li><code>[xyz]</code> 字符集合。</li>
<li><code>[^xyz]</code> 负值字符集合。</li>
<li><code>[a-z]</code> 字符范围，匹配指定范围内的任意字符。</li>
<li><code>[^a-z]</code> 负值字符范围，匹配任何不在指定范围内的任意字符。</li>
<li><code>\b</code> 匹配一个单词边界，也就是指单词和空格间的位置。</li>
<li><code>\B</code> 匹配非单词边界。</li>
<li><code>\cx</code> 匹配由x指明的控制字符。</li>
<li><code>\d</code> 匹配一个数字字符。等价于 <code>[0-9]</code>。</li>
<li><code>\D</code> 匹配一个非数字字符。等价于 <code>[^0-9]</code>。</li>
<li><code>\f</code> 匹配一个换页符。等价于 <code>\x0c</code> 和 <code>\cL</code>。</li>
<li><code>\n</code> 匹配一个换行符。等价于 <code>\x0a</code> 和 <code>\cJ</code>。</li>
<li><code>\r</code> 匹配一个回车符。等价于 <code>\x0d</code> 和 <code>\cM</code>。</li>
<li><code>\s</code> 匹配任何空白字符，包括空格、制表符、换页符等等。等价于<code>[ \f\n\r\t\v]</code>。</li>
<li><code>\S</code> 匹配任何非空白字符。等价于 <code>[^ \f\n\r\t\v]</code>。</li>
<li><code>\t</code> 匹配一个制表符。等价于 <code>\x09</code> 和 <code>\cI</code>。</li>
<li><code>\v</code> 匹配一个垂直制表符。等价于 <code>\x0b</code> 和 <code>\cK</code>。</li>
<li><code>\w</code> 匹配包括下划线的任何单词字符。等价于<code>[A-Za-z0-9_]</code>。</li>
<li><code>\W</code> 匹配任何非单词字符。等价于 <code>[^A-Za-z0-9_]</code>。</li>
<li><code>\xn</code> 匹配 <code>n</code>，其中 <code>n</code> 为十六进制转义值。十六进制转义值必须为确定的两个数字长。</li>
<li><code>\num</code> 匹配 <code>num</code>，其中<code>num</code>是一个正整数。对所获取的匹配的引用。</li>
<li><code>\n</code> 标识一个八进制转义值或一个后向引用。如果 <code>\n</code> 之前至少 n 个获取的子表达式，则 n 为后向引用。否则，如果 n 为八进制数字 (0-7)，则 n 为一个八进制转义值</li>
<li><code>\nm</code> 标识一个八进制转义值或一个后向引用。如果 <code>\nm</code> 之前至少有is preceded by at least nm 个获取得子表达式，则 nm 为后向引用。如果 <code>\nm</code> 之前至少有 n 个获取，则 n 为一个后跟文字 m 的后向引用。如果前面的条件都不满足，若 n 和 m 均为八进制数字 (0-7)，则 <code>\nm</code> 将匹配八进制转义值 <code>nm</code></li>
<li><code>\nml</code> 如果 <code>n</code> 为八进制数字 (0-3)，且 <code>m</code> 和 <code>l</code> 均为八进制数字 (0-7)，则匹配八进制转义值 <code>nml</code></li>
<li><code>\un</code> 匹配 <code>n</code>，其中 <code>n</code> 是一个用四个十六进制数字表示的Unicode字符。</li>
<li>匹配中文字符的正则表达式： <code>[u4e00-u9fa5]</code></li>
<li>匹配双字节字符(包括汉字在内)：<code>[^x00-xff]</code></li>
<li>匹配空行的正则表达式：<code>n[s| ]*r</code></li>
<li>匹配HTML标记的正则表达式：<code>/&lt;(.*)&gt;.*&lt;/1&gt;|&lt;(.*) /&gt;/</code></li>
<li>匹配首尾空格的正则表达式：<code>(^s*)|(s*$)</code></li>
<li>匹配Email地址的正则表达式：<code>w+([-+.]w+)*@w+([-.]w+)*.w+([-.]w+)*</code></li>
<li>匹配网址URL的正则表达式：<code>http://([w-]+.)+[w-]+(/[w- ./?%&amp;=]*)?</code></li>
</ul>
<div><p>参考</p>
<p><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1255945288020320" target="_blank" rel="noopener noreferrer">廖雪峰Java教程 - 正则表达式</a></p>
<p><a href="https://www.runoob.com/java/java-regular-expressions.html" target="_blank" rel="noopener noreferrer">菜鸟教程 - 正则表达式</a></p>
</div>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <category term="Java"/>
    <contributor>
      <name>南辞</name>
    </contributor>
    <published>2021-02-16T17:39:43.000Z</published>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">Java基础</title>
    <id>http://qiqi.dreamagain.top/program/backend/java/solution/Java%E5%9F%BA%E7%A1%80/</id>
    <link href="http://qiqi.dreamagain.top/program/backend/java/solution/Java%E5%9F%BA%E7%A1%80/"/>
    <updated>2021-02-16T17:39:43.000Z</updated>
    <content type="html"><![CDATA[<h2 id="问题"> 问题：</h2>
<h3 id="一、java概述"> 一、Java概述</h3>
<p>1、何为编程</p>
<p>2、什么是Java</p>
<p>3、jdk1.5之后的三大版本</p>
<p>4、JVM、JRE和JDK的关系</p>
<p>5、什么是跨平台性？原理是什么</p>
<p>6、Java语言有哪些特点？</p>
<p>7、什么是字节码？采用字节码的最大好处是什么</p>
<p>8、什么是Java程序的主类？应用程序和小程序的主类有何不同？</p>
<p>9、Java应用程序与小程序之间有那些差别？</p>
<p>10、Java和C++的区别</p>
<p>11、Oracle JDK 和 OpenJDK 的对比</p>
<h3 id="二、基础语法"> 二、基础语法</h3>
<h4 id="一-数据类型"> （一）数据类型</h4>
<p>1、Java有哪些数据类型</p>
<p>2、switch 是否能作用在 byte 上，是否能作用在 long 上，是否能作用在 String 上</p>
<p>3、用最有效率的方法计算 2 乘以 8</p>
<p>4、Math.round(11.5) 等于多少？Math.round(-11.5)等于多少</p>
<p>5、float f=3.4;是否正确</p>
<p>6、short s1 = 1; s1 = s1 + 1;有错吗?short s1 = 1; s1 += 1;有错吗</p>
<h4 id="二-编码"> （二）编码</h4>
<p>1、Java语言采用何种编码方案？有何特点？</p>
<h4 id="三-注释"> （三）注释</h4>
<p>1、什么Java注释</p>
<h4 id="四-访问修饰符"> （四）访问修饰符</h4>
<p>1、访问修饰符 public,private,protected,以及不写（默认）时的区别</p>
<h4 id="五-运算符"> （五）运算符</h4>
<p>1、&amp;和&amp;&amp;的区别</p>
<h4 id="六-关键字"> （六）关键字</h4>
<p>1、Java 有没有 goto</p>
<p>2、final 有什么用？</p>
<p>3、final finally finalize区别</p>
<p>4、this关键字的用法</p>
<p>5、super关键字的用法</p>
<p>6、this与super的区别</p>
<p>7、static存在的主要意义</p>
<p>8、static的独特之处</p>
<p>9、static应用场景</p>
<p>10、static注意事项</p>
<h4 id="七-流程控制"> （七）流程控制</h4>
<p>1、break ,continue ,return 的区别及作用</p>
<p>2、在 Java 中，如何跳出当前的多重嵌套循环</p>
<h3 id="三、面向对象"> 三、面向对象</h3>
<h4 id="一-面向对象概述"> （一）面向对象概述</h4>
<p>1、面向对象和面向过程的区别</p>
<h4 id="二-面向对象三大特性"> （二）面向对象三大特性</h4>
<p>2、面向对象的特征有哪些方面</p>
<p>3、什么是多态机制？Java语言是如何实现多态的？</p>
<p>4、面向对象七大基本原则是什么？</p>
<h4 id="三-类与接口"> （三）类与接口</h4>
<p>1、抽象类和接口的对比</p>
<p>2、普通类和抽象类有哪些区别？</p>
<p>3、抽象类能使用 final 修饰吗？</p>
<p>4、创建一个对象用什么关键字？对象实例与对象引用有何不同？</p>
<h4 id="四-变量与方法"> （四）变量与方法</h4>
<p>1、成员变量与局部变量的区别有哪些？</p>
<p>2、在Java中定义一个不做事且没有参数的构造方法的作用</p>
<p>3、在调用子类构造方法之前会先调用父类没有参数的构造方法，其目的是？</p>
<p>4、一个类的构造方法的作用是什么？若一个类没有声明构造方法，该程序能正确执行吗？为什么？</p>
<p>5、构造方法有哪些特点？</p>
<p>6、静态变量和实例变量区别</p>
<p>7、静态变量与普通变量区别</p>
<p>8、静态方法和实例方法有何不同？</p>
<p>9、在一个静态方法内调用一个非静态成员为什么是非法的？</p>
<p>10、什么是方法的返回值？返回值的作用是什么？</p>
<h4 id="五-内部类"> （五）内部类</h4>
<p>1、什么是内部类？</p>
<p>2、内部类的分类有哪些？</p>
<p>3、内部类的优点</p>
<p>4、内部类有哪些应用场景</p>
<p>5、局部内部类和匿名内部类访问局部变量的时候，为什么变量必须要加上final？</p>
<p>6、内部类相关，看程序说出运行结果</p>
<h4 id="六-重写与重载"> （六）重写与重载</h4>
<p>1、构造器（constructor）是否可被重写（override）</p>
<p>2、重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？</p>
<h4 id="七-对象相等判断"> （七）对象相等判断</h4>
<p>1、== 和 equals 的区别是什么</p>
<p>2、hashCode与 equals 方法 (<mark>重要</mark>)</p>
<p>4、对象的相等与指向他们的引用相等，两者有什么不同？</p>
<h4 id="八-值传递"> （八）值传递</h4>
<p>1、当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递</p>
<p>2、Java 中对象作为形参为什么还是值传递</p>
<p>3、值传递和引用传递有什么区别</p>
<h4 id="九-java包"> （九）Java包</h4>
<p>1、JDK 中常用的包有哪些</p>
<p>2、import java和javax有什么区别</p>
<h3 id="四、常用api"> 四、常用API</h3>
<h4 id="一-string相关"> （一）String相关</h4>
<p>1、字符型常量和字符串常量的区别</p>
<p>2、什么是字符串常量池？</p>
<p>3、String 是最基本的数据类型吗</p>
<p>4、String有哪些特性</p>
<p>5、String为什么是不可变的吗？</p>
<p>6、String真的是不可变的吗？</p>
<p>7、是否可以继承 String 类</p>
<p>8、String str=&quot;i&quot;与 String str=new String(&quot;i&quot;)一样吗？</p>
<p>9、String s = new String(&quot;xyz&quot;);创建了几个字符串对象</p>
<p>10、如何将字符串反转？</p>
<p>11、数组有没有 length()方法？String 有没有 length()方法</p>
<p>12、String 类的常用方法都有那些？</p>
<p>13、在使用 HashMap 的时候，用 String 做 key 有什么好处？</p>
<p>14、String和StringBuffer、StringBuilder的区别是什么？String为什么是不可变的</p>
<h4 id="二-date相关"> （二）Date相关</h4>
<h4 id="三-包装类相关"> （三）包装类相关</h4>
<p>1、自动装箱与拆箱</p>
<p>2、int 和 Integer 有什么区别</p>
<p>3、Integer a= 127 与 Integer b = 127相等吗</p>
<h2 id="参考答案"> 参考答案：</h2>
<h3 id="一、java概述-2"> 一、Java概述</h3>
<blockquote>
<p>1、何为编程</p>
</blockquote>
<p>编程就是让计算机为解决某个问题而使用某种程序设计语言编写程序代码，并最终得到结果的过程。为了使计算机能够理解人的意图，</p>
<p>人类就必须要将需解决的问题的思路、方法、和手段通过计算机能够理解的形式告诉计算机，使得计算机能够根据人的指令一步一步去</p>
<p>工作，完成某种特定的任务。这种人和计算机之间交流的过程就是编程。</p>
<blockquote>
<p>2、什么是Java</p>
</blockquote>
<p>Java是一门面向对象编程语言，不仅吸收了C++语言的各种优点，还摒弃了C++里难以理解的多继承、指针等概念，因此Java语言具有功</p>
<p>能强大和简单易用两个特征。Java语言作为静态面向对象编程语言的代表，极好地实现了面向对象理论，允许程序员以优雅的思维方式</p>
<p>进行复杂的编程 。</p>
<blockquote>
<p>3、jdk1.5之后的三大版本</p>
</blockquote>
<ol>
<li><strong>Java SE</strong>（J2SE，Java 2 Platform Standard Edition，标准版）
Java SE 以前称为 J2SE。它允许开发和部署在桌面、服务器、嵌入式环境和实时环境中使用的 Java 应用程序。Java SE 包含了支持 Java Web 服务开发的类，并为Java EE和Java ME提供基础。</li>
<li><strong>Java EE</strong>（J2EE，Java 2 Platform Enterprise Edition，企业版）
Java EE 以前称为 J2EE。企业版本帮助开发和部署可移植、健壮、可伸缩且安全的服务器端Java 应用程序。Java EE 是在 Java SE 的基础上构建的，它提供 Web 服务、组件模型、管理和通信 API，可以用来实现企业级的面向服务体系结构（service-oriented architecture，SOA）和 Web2.0应用程序。2018年2月，Eclipse 宣布正式将 JavaEE 更名为 JakartaEE</li>
<li><strong>Java ME</strong>（J2ME，Java 2 Platform Micro Edition，微型版）
Java ME 以前称为 J2ME。Java ME 为在移动设备和嵌入式设备（比如手机、PDA、电视机顶盒和打印机）上运行的应用程序提供一个健壮且灵活的环境。Java ME 包括灵活的用户界面、健壮的安全模型、许多内置的网络协议以及对可以动态下载的连网和离线应用程序的丰富支持。基于 Java ME 规范的应用程序只需编写一次，就可以用于许多设备，而且可以利用每个设备的本机功能。</li>
</ol>
<blockquote>
<p>4、JVM、JRE和JDK的关系</p>
</blockquote>
<p><strong>JVM:</strong></p>
<ul>
<li>Java Virtual Machine是Java虚拟机，Java程序需要运行在虚拟机上</li>
<li>不同的平台有自己的虚拟机，因此Java语言可以实现跨平台。</li>
</ul>
<p><strong>JRE:</strong></p>
<ul>
<li>Java Runtime Environment包括Java虚拟机和Java程序所需的核心类库等。</li>
<li>核心类库主要是java.lang包：包含了运行Java程序必不可少的系统类，如基本数据类型、基本数学函数、字符串处理、线程、异常处理类等，系统缺省加载这个包</li>
<li>如果想要运行一个开发好的Java程序，计算机中只需要安装JRE即可。</li>
</ul>
<p><strong>JDK：</strong></p>
<ul>
<li>Java Development Kit是提供给Java开发人员使用的</li>
<li>JDK包含了Java的开发工具，也包括了JRE。所以安装了JDK，就无需再单独安装JRE了。</li>
<li>JDK的开发工具：编译工具(javac.exe)，打包工具(jar.exe)等</li>
</ul>
<p>JVM&amp;JRE&amp;JDK关系图</p>
<img src="./assets/01.jpg" style="zoom:80%;" />
<blockquote>
<p>5、什么是跨平台性？原理是什么</p>
</blockquote>
<p>所谓跨平台性，是指java语言编写的程序，一次编译后，可以在多个系统平台上运行。</p>
<p>实现原理：Java程序是通过java虚拟机在系统平台上运行的，只要该系统可以安装相应的java虚拟机，该系统就可以运行java程序。</p>
<blockquote>
<p>6、Java语言有哪些特点</p>
</blockquote>
<p>简单易学（Java语言的语法与C语言和C++语言很接近）</p>
<p>面向对象（封装，继承，多态）</p>
<p>平台无关性（Java虚拟机实现平台无关性）</p>
<p>支持网络编程并且很方便（Java语言诞生本身就是为简化网络编程设计的）</p>
<p>支持多线程（多线程机制使应用程序在同一时间并行执行多项任）</p>
<p>健壮性（Java语言的强类型机制、异常处理、垃圾的自动收集等）</p>
<p>安全性</p>
<blockquote>
<p>7、什么是字节码？采用字节码的最大好处是什么</p>
</blockquote>
<p><strong>字节码</strong>：</p>
<p>Java源代码经过虚拟机编译器编译后产生的文件（即扩展为 <mark>.class的文件</mark> ），它不面向任何特定的处理器，只面向虚拟机。</p>
<p><strong>采用字节码的好处：</strong></p>
<p>Java语言通过字节码的方式，在一定程度上 <mark>解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。</mark> 所以Java程序运行时比较高效，而且，由于字节码并不专对一种特定的机器，因此，Java程序无须重新编译便可在多种不同的计算机上运行。</p>
<p>先看下java中的编译器和解释器：</p>
<div><pre><code><span>Java</span>源代码<span>--</span><span>--</span><span>></span>编译器<span>--</span><span>--</span><span>></span>jvm可执行的<span>Java</span>字节码<span>(</span>即虚拟指令<span>)</span><span>--</span><span>--</span><span>></span>jvm<span>--</span><span>--</span><span>></span>jvm中解释器<span>--</span><span>--</span><span>-></span>机器可执行的二进制机器码<span>--</span><span>--</span><span>></span>程序运行。

</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><ol>
<li>
<p>Java中引入了虚拟机的概念，即在机器和编译程序之间加入了一层抽象的虚拟机器。</p>
</li>
<li>
<p>这台虚拟的机器在任何平台上都提供给编译程序一个共同的接口。</p>
</li>
<li>
<p>编译程序只需要面向虚拟机，生成虚拟机能够理解的代码，然后由解释器来将虚拟机代码转换为特定系统的机器码执行。</p>
</li>
<li>
<p>在Java中，这种供虚拟机理解的代码叫做字节码（即扩展为.class的文件），它不面向任何特定的处理器，只面向虚拟机。</p>
</li>
<li>
<p>每一种平台的解释器是不同的，但是实现的虚拟机是相同的。</p>
</li>
<li>
<p>Java源程序经过编译器编译后变成字节码，字节码由虚拟机解释执行，虚拟机将每一条要执行的字节码送给解释器，解释器将其翻译成特定机器上的机器码，然后在特定的机器上运行，这就是上面提到的<strong>Java的特点的编译与解释并存</strong>的解释。</p>
</li>
</ol>
<blockquote>
<p>8、什么是Java程序的主类？应用程序和小程序的主类有何不同？</p>
</blockquote>
<ol>
<li>
<p>一个程序中可以有多个类，但只能有一个类是主类。</p>
</li>
<li>
<p>在Java应用程序中，这个主类是指包含main()方法的类。</p>
</li>
<li>
<p>而在Java小程序中，这个主类是一个继承自系统类JApplet或Applet的子类。</p>
</li>
<li>
<p>应用程序的主类不一定要求是public类，但小程序的主类要求必须是public类。主类是Java程序执行的入口点。</p>
</li>
</ol>
<blockquote>
<p>9、Java应用程序与小程序之间有那些差别？</p>
</blockquote>
<ol>
<li>
<p>简单说应用程序是从主线程启动(也就是main()方法)。</p>
</li>
<li>
<p>applet小程序没有main方法，主要是嵌在浏览器页面上运行(调用init()线程或者run()来启动)，嵌入浏览器这点跟flash的小游戏类似</p>
</li>
</ol>
<blockquote>
<p>10、Java和C++的区别</p>
</blockquote>
<ul>
<li>都是面向对象的语言，都支持封装、继承和多态</li>
<li>Java不提供指针来直接访问内存，程序内存更加安全</li>
<li>Java的类是单继承的，C++支持多重继承；虽然Java的类不可以多继承，但是接口可以多继承。</li>
<li>Java有自动内存管理机制，不需要程序员手动释放无用内存</li>
</ul>
<blockquote>
<p>11、Oracle JDK 和 OpenJDK 的对比</p>
</blockquote>
<ol>
<li>
<p>Oracle JDK版本将每三年发布一次，而OpenJDK版本每三个月发布一次；</p>
</li>
<li>
<p>OpenJDK 是一个参考模型并且是完全开源的，而Oracle JDK是OpenJDK的一个实现，并不是完全开源的；</p>
</li>
<li>
<p>Oracle JDK 比 OpenJDK 更稳定。OpenJDK和Oracle JDK的代码几乎相同，但Oracle JDK有更多的类和一些错误修复。因此，如果您想开发企业/商业软件，我建议您选择Oracle JDK，因为它经过了彻底的测试和稳定。某些情况下，有些人提到在使用OpenJDK 可能会遇到了许多应用程序崩溃的问题，但是，只需切换到Oracle JDK就可以解决问题；</p>
</li>
<li>
<p>在响应性和JVM性能方面，Oracle JDK与OpenJDK相比提供了更好的性能；</p>
</li>
<li>
<p>Oracle JDK不会为即将发布的版本提供长期支持，用户每次都必须通过更新到最新版本获得支持来获取最新版本；</p>
</li>
<li>
<p>Oracle JDK根据<strong>二进制代码许可协议</strong>获得许可，而OpenJDK根据<strong>GPL v2许可</strong>获得许可。</p>
</li>
</ol>
<h3 id="二、基础语法-2"> 二、基础语法</h3>
<h4 id="一-数据类型-2"> （一）数据类型</h4>
<p>定义：Java语言是强类型语言，对于每一种数据都定义了明确的具体的数据类型，在内存中分配了不同大小的内存空间。</p>
<p><strong>分类：</strong></p>
<p><strong>（1）基本数据类型：</strong></p>
<ol>
<li>数值型
<ul>
<li>整数类型(byte,short,int,long)</li>
<li>浮点类型(float,double)</li>
</ul>
</li>
<li>字符型(char)</li>
<li>布尔型(boolean)</li>
</ol>
<p><strong>（2）引用数据类型：</strong></p>
<ol>
<li>类(class)</li>
<li>接口(interface)</li>
<li>数组([])</li>
</ol>
<blockquote>
<p>1、Java有哪些数据类型</p>
</blockquote>
<p><img src="./assets/02.jpg" alt=""></p>
<blockquote>
<p>2、switch 是否能作用在 byte 上，是否能作用在 long 上，是否能作用在 String 上</p>
</blockquote>
<ol>
<li>在 Java 5 以前，switch(expr)中，expr 只能是 byte、short、char、int。</li>
<li>从 Java5 开始，Java 中引入了枚举类型，expr 也可以是 enum 类型，</li>
<li>从 Java 7 开始，expr 还可以是字符串（String），但是长整型（long）在目前所有的版本中都是不可以的。</li>
<li></li>
</ol>
<blockquote>
<p>3、用最有效率的方法计算 2 乘以 8</p>
</blockquote>
<p><code>2 &lt;&lt; 3</code>（左移 3 位相当于乘以 2 的 3 次方，右移 3 位相当于除以 2 的 3 次方）。</p>
<blockquote>
<p>4、Math.round(11.5) 等于多少？Math.round(-11.5)等于多少</p>
</blockquote>
<p>Math.round(11.5)的返回值是 12，Math.round(-11.5)的返回值是-11。</p>
<p>四舍五入的原理是在参数上加 0.5 然后进行下取整。</p>
<blockquote>
<p>5、float f=3.4;是否正确</p>
</blockquote>
<p>不正确。</p>
<p>3.4 是双精度数，将双精度型（double）赋值给浮点型（float）属于下转型（down-casting，也称为窄化）会造成精度损失。</p>
<p>因此需要强制类型转换float f =(float)3.4; 或者写成 float f =3.4F;。</p>
<blockquote>
<p>6、short s1 = 1; s1 = s1 + 1;有错吗?short s1 = 1; s1 += 1;有错吗</p>
</blockquote>
<p>对于 short s1 = 1; s1 = s1 + 1;由于 1 是 int 类型，因此 s1+1 运算结果也是 int型，需要强制转换类型才能赋值给 short 型。</p>
<p>而 short s1 = 1; s1 += 1;可以正确编译，因为 s1+= 1;相当于 s1 = (short(s1 + 1);其中有隐含的强制类型转换。</p>
<h4 id="二-编码-2"> （二）编码</h4>
<blockquote>
<p>1、Java语言采用何种编码方案？有何特点？</p>
</blockquote>
<p>Java语言采用Unicode编码标准</p>
<p>Unicode（标准码），它为每个字符制订了一个唯一的数值，因此在任何的语言，平台，程序都可以放心的使用。</p>
<h4 id="三-注释-2"> （三）注释</h4>
<blockquote>
<p>1、什么Java注释</p>
</blockquote>
<p>定义：用于解释说明程序的文字</p>
<p>Java的三种注释：</p>
<ul>
<li>单行注释: // 注释文字</li>
<li>多行注释: /* 注释文字 */</li>
<li>文档注释：/** 注释文字 */</li>
</ul>
<p><strong>作用</strong>：在程序中，尤其是复杂的程序中，适当地加入注释可以 <mark>增加程序的可读性，有利于程序的修改、调试和交流</mark></p>
<p>注释的内容在程序编译的时候会被忽视，不会产生目标代码，注释的部分不会对程序的执行结果产生任何影响。</p>
<p><strong>注意事项</strong>：多行和文档注释都不能嵌套使用。</p>
<h4 id="四-访问修饰符-2"> （四）访问修饰符</h4>
<blockquote>
<p>1、访问修饰符 public,private,protected,以及不写（默认）时的区别</p>
</blockquote>
<p><strong>定义</strong>：Java中，可以使用访问修饰符来保护对类、变量、方法和构造方法的访问。</p>
<p>​			 Java 支持 4 种不同的访问权限，为实现封装性提供了条件。</p>
<p><strong>分类：</strong></p>
<p>private : 在同一类内可见。使用对象：变量、方法。 注意：不能修饰类（外部类）</p>
<p>default (即缺省，什么也不写，不使用任何关键字）: 在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法。</p>
<p>protected : 对同一包内的类和所有子类可见。使用对象：变量、方法。 注意：不能修饰类（外部类）。</p>
<p>public : 对所有类可见。使用对象：类、接口、变量、方法</p>
<p>访问修饰符图
<img src="./assets/03.jpg" alt=""></p>
<h4 id="五-运算符-2"> （五）运算符</h4>
<blockquote>
<p>1、&amp;和&amp;&amp;的区别</p>
</blockquote>
<p>&amp;运算符有两种用法：(1)按位与；(2)逻辑与。</p>
<ul>
<li>&amp;&amp;是短路与</li>
<li>&amp;是逻辑与</li>
</ul>
<p><strong>相同点</strong>：二者都要求运算符左右两端的布尔值都是true 整个表达式的值才是 true</p>
<p><strong>不同的</strong>：&amp;&amp;之所以称为短路运算，是因为如果&amp;&amp;左边的表达式的值是 false，右边的表达式会被直接短路掉，不会进行运算。</p>
<p>注意：逻辑或运算符（|）和短路或运算符（||）的差别也是如此。</p>
<h4 id="六-关键字-2"> （六）关键字</h4>
<blockquote>
<p>1、Java 有没有 goto</p>
</blockquote>
<p>goto 是 Java 中的保留字，在目前版本的 Java 中没有使用。</p>
<blockquote>
<p>2、final 有什么用？</p>
</blockquote>
<p>用于修饰类、属性和方法；</p>
<ul>
<li>被final修饰的类不可以被继承,如String类</li>
<li>被final修饰的方法不可以被重写</li>
<li>被final修饰的变量不可以被改变，被final修饰不可变的是变量的引用，而不是引用指向的内容，引用指向的内容是可以改变的</li>
</ul>
<blockquote>
<p>3、final finally finalize区别</p>
</blockquote>
<ul>
<li>
<p>final可以修饰类、变量、方法，修饰类表示该类不能被继承、修饰方法表示该方法不能被重写、修饰变量表
示该变量是一个常量不能被重新赋值。</p>
</li>
<li>
<p>finally一般作用在try-catch代码块中，在处理异常的时候，通常我们将一定要执行的代码方法finally代码块
中，表示不管是否出现异常，该代码块都会执行，一般用来存放一些关闭资源的代码。</p>
</li>
<li>
<p>finalize是一个方法，属于Object类的一个方法，而Object类是所有类的父类，该方法一般由垃圾回收器来调
用，当我们调用System.gc() 方法的时候,只是提醒垃圾回收器作一次垃圾回收的操作，由垃圾回收器调用finalize()，</p>
<p>回收垃圾，一个对象是否可回收的最后判断。</p>
</li>
</ul>
<blockquote>
<p>4、this关键字的用法</p>
</blockquote>
<p>this是自身的一个对象，代表对象本身，可以理解为：指向对象本身的一个指针。</p>
<p>this的用法在java中大体可以分为3种：</p>
<ul>
<li>
<p>普通的直接引用，this相当于是指向当前对象本身。</p>
</li>
<li>
<p>形参与成员名字重名，用this来区分：</p>
</li>
<li>
<p>引用本类的构造函数</p>
</li>
</ul>
<div><pre><code><span>public</span> <span>Person</span><span>(</span><span>String</span> name<span>,</span> <span>int</span> age<span>)</span> <span>{</span>
    <span>this</span><span>.</span>name <span>=</span> name<span>;</span>
    <span>this</span><span>.</span>age <span>=</span> age<span>;</span>
<span>}</span>

<span>class</span> <span>Person</span><span>{</span>
    <span>private</span> <span>String</span> name<span>;</span>
    <span>private</span> <span>int</span> age<span>;</span>
    
    <span>public</span> <span>Person</span><span>(</span><span>)</span> <span>{</span>
    <span>}</span>
 
    <span>public</span> <span>Person</span><span>(</span><span>String</span> name<span>)</span> <span>{</span>
        <span>this</span><span>.</span>name <span>=</span> name<span>;</span>
    <span>}</span>
    <span>public</span> <span>Person</span><span>(</span><span>String</span> name<span>,</span> <span>int</span> age<span>)</span> <span>{</span>
        <span>this</span><span>(</span>name<span>)</span><span>;</span>
        <span>this</span><span>.</span>age <span>=</span> age<span>;</span>
    <span>}</span>
<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><blockquote>
<p>5、super关键字的用法</p>
</blockquote>
<p>super可以理解为是指向自己超（父）类对象的一个指针，而这个超类指的是离自己最近的一个父类。</p>
<p>super也有三种用法：</p>
<ol>
<li>
<p>普通的调用</p>
<p>与this类似，super相当于是指向当前对象的父类的引用，这样就可以用<code>super.xxx</code>来引用父类的成员。</p>
<p>（注意：super不是一个对象的引用，这里 <mark>只是说作用类似，不能将它赋值给另一个变量</mark> ，它只是指示编译器去调用父类方法的一个特殊关键词，这是super与this的区别所在）</p>
</li>
<li>
<p>子类中的成员变量或方法与父类中的成员变量或方法同名时，用super进行区分</p>
</li>
<li>
<p>引用父类构造函数</p>
<ul>
<li>
<p>super（参数）：调用父类中的某一个构造函数（应该为构造函数中的第一条语句）。</p>
</li>
<li>
<p>this（参数）：调用本类中另一种形式的构造函数（应该为构造函数中的第一条语句）。</p>
<p><mark>因此在同意构造函数中不能同时有super和this关键字</mark></p>
</li>
</ul>
</li>
</ol>
<div><pre><code><span>class</span> <span>Person</span><span>{</span>
    <span>protected</span> <span>String</span> name<span>;</span>
 
    <span>public</span> <span>Person</span><span>(</span><span>String</span> name<span>)</span> <span>{</span>
        <span>this</span><span>.</span>name <span>=</span> name<span>;</span>
    <span>}</span>
 
<span>}</span>
 
<span>class</span> <span>Student</span> <span>extends</span> <span>Person</span><span>{</span>
    <span>private</span> <span>String</span> name<span>;</span>
 
    <span>public</span> <span>Student</span><span>(</span><span>String</span> name<span>,</span> <span>String</span> name1<span>)</span> <span>{</span>
        <span>super</span><span>(</span>name<span>)</span><span>;</span>
        <span>this</span><span>.</span>name <span>=</span> name1<span>;</span>
    <span>}</span>
 
    <span>public</span> <span>void</span> <span>getInfo</span><span>(</span><span>)</span><span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>this</span><span>.</span>name<span>)</span><span>;</span>      <span>//Child</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>super</span><span>.</span>name<span>)</span><span>;</span>     <span>//Father</span>
    <span>}</span>
 
<span>}</span>

<span>public</span> <span>class</span> <span>Test</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
       <span>Student</span> s1 <span>=</span> <span>new</span> <span>Student</span><span>(</span><span>"Father"</span><span>,</span><span>"Child"</span><span>)</span><span>;</span>
       s1<span>.</span><span>getInfo</span><span>(</span><span>)</span><span>;</span>
 
    <span>}</span>
<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br></div></div><blockquote>
<p>6、this与super的区别</p>
</blockquote>
<ul>
<li>
<p>super:　它引用当前对象的直接父类中的成员（用来 <mark>访问直接父类中被隐藏的父类中成员数据或函数</mark> ），基类与派生类中有相同成员定义时如：super.变量名 super.成员函数据名（实参）</p>
</li>
<li>
<p>this：它代表当前对象名（在程序中易产生二义性之处，应使用this来指明当前对象；如果函数的形参与类中的成员数据同名，这时需用this来指明成员变量名）</p>
</li>
<li>
<p>super()和this()类似,区别是，super()在子类中调用父类的构造方法，this()在本类内调用本类的其它构造方法。</p>
</li>
<li>
<p><strong>super()和this()均需放在构造方法内第一行。</strong></p>
</li>
<li>
<p>尽管可以用this调用一个构造器，但却不能调用两个。</p>
</li>
<li>
<p><mark>this和super不能同时出现在一个构造函数里面</mark> ，因为this必然会调用其它的构造函数，其它的构造函数必然也会有super语句的存在，所以在同一个构造函数里面有相同的语句，就失去了语句的意义，编译器也不会通过。</p>
</li>
<li>
<p>this()和super()都指的是对象，所以，<mark>均不可以在static环境中使用</mark>。包括：static变量,static方法，static语句块。</p>
</li>
<li>
<p>从本质上讲，<mark>this是一个指向本对象的指针</mark>, 然而 <mark>super是一个Java关键字</mark>。</p>
</li>
</ul>
<blockquote>
<p>7、static存在的主要意义</p>
</blockquote>
<ul>
<li>
<p>static的主要意义是在于<strong>创建独立于具体对象的域变量或者方法</strong>。以致于即使没有创建对象，也能使用属性和调用方法！</p>
</li>
<li>
<p>static关键字还有一个比较关键的作用就是 用来形成<strong>静态代码块以优化程序性能</strong>。static块可以置于类中的任何地方，类中可以有多个static块。在类初次被加载的时候，会按照static块的顺序来执行每个static块，并且只会执行一次。</p>
</li>
<li>
<p>为什么说static块可以用来优化程序性能，是因为它的特性:<strong>只会在类加载的时候执行一次</strong>。因此，很多时候会将一些只需要进行一次的初始化操作都放在static代码块中进行。</p>
</li>
</ul>
<blockquote>
<p>8、static的独特之处</p>
</blockquote>
<p>1、被static修饰的变量或者方法是独立于该类的任何对象，也就是说，这些变量和方法不属于任何一个实例对象，而是<strong>被类的实例对</strong></p>
<p><strong>象所共享。</strong></p>
<p>怎么理解 “被类的实例对象所共享” 这句话呢？就是说，一个类的静态成员，它是属于大伙的【大伙指的是这个类的多个对象实例，我们</p>
<p>都知道一个类可以创建多个实例！】，所有的类对象共享的，不像成员变量是自个的【自个指的是这个类的单个实例对象】</p>
<p>2、在该类被第一次加载的时候，就会去加载被static修饰的部分，而且<strong>只在类第一次使用时加载并进行初始化</strong>，注意这是第</p>
<p>一次用就要初始化，后面根据需要是可以再次赋值的。</p>
<p>3、static变量值在<strong>类加载的时候分配空间</strong>，以后创建类对象的时候不会重新分配。赋值的话，是<strong>可以任意赋值</strong>的！</p>
<p>4、<strong>被static修饰的变量或者方法是优先于对象存在</strong>的，也就是说当一个类加载完毕之后，即便没有创建对象，也可以去访问。</p>
<blockquote>
<p>9、static应用场景</p>
</blockquote>
<p>因为static是被类的实例对象所共享，因此如果某个成员变量是被所有对象所共享的，那么这个成员变量就应该定义为静态变量。</p>
<p>因此比较常见的static应用场景有：</p>
<ol>
<li>修饰成员变量</li>
<li>修饰成员方法</li>
<li>静态代码块</li>
<li>修饰类【只能修饰内部类也就是静态内部类】</li>
<li>静态导包</li>
</ol>
<blockquote>
<p>10、static注意事项</p>
</blockquote>
<p>1、静态只能访问静态。</p>
<p>2、非静态既可以访问非静态的，也可以访问静态的。</p>
<h4 id="七-流程控制-2"> （七）流程控制</h4>
<blockquote>
<p>1、break ,continue ,return 的区别及作用</p>
</blockquote>
<p>break 跳出总上一层循环，不再执行循环(结束当前的循环体)</p>
<p>continue 跳出本次循环，继续执行下次循环(结束正在执行的循环 进入下一个循环条件)</p>
<p>return 程序返回，不再执行下面的代码(结束当前的方法 直接返回)</p>
<blockquote>
<p>2、在 Java 中，如何跳出当前的多重嵌套循环</p>
</blockquote>
<p>在Java中，要想跳出多重循环，可以在外面的循环语句前定义一个标签，然后在里层循环体的代码中使用带有标号的break 语句，即可跳出外层循环。例如：</p>
<div><pre><code><span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
    ok<span>:</span>
    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>10</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>
        <span>for</span> <span>(</span><span>int</span> j <span>=</span> <span>0</span><span>;</span> j <span>&lt;</span> <span>10</span><span>;</span> j<span>++</span><span>)</span> <span>{</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"i="</span> <span>+</span> i <span>+</span> <span>",j="</span> <span>+</span> j<span>)</span><span>;</span>
            <span>if</span> <span>(</span>j <span>==</span> <span>5</span><span>)</span> <span>{</span>
                <span>break</span> ok<span>;</span>
            <span>}</span>

        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h3 id="三、面向对象-2"> 三、面向对象</h3>
<h4 id="一-面向对象概述-2"> （一）面向对象概述</h4>
<blockquote>
<p>1、面向对象和面向过程的区别</p>
</blockquote>
<p><strong>(1)面向过程：</strong></p>
<p>​		优点：性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源;比如单片机、嵌入式开发、Linux/Unix等一般采用面向过程开发，性能是最重要的因素。</p>
<p>​		缺点：没有面向对象易维护、易复用、易扩展</p>
<p><strong>(2)面向对象：</strong></p>
<p>​		优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统更加灵活、更加易于维护</p>
<p>​		缺点：性能比面向过程低</p>
<p>面向过程是具体化的，流程化的，解决一个问题，你需要一步一步的分析，一步一步的实现。</p>
<p>面向对象是模型化的，你只需抽象出一个类，这是一个封闭的盒子，在这里你拥有数据也拥有解决问题的方法。需要什么功能直接使用就可以了，不必去一步一步的实现，至于这个功能是如何实现的，管我们什么事？我们会用就可以了。</p>
<p>面向对象的<strong>底层其实还是面向过程</strong>，把面向过程抽象成类，然后封装，方便我们使用的就是面向对象了。</p>
<h4 id="二-面向对象三大特性-2"> （二）面向对象三大特性</h4>
<blockquote>
<p>1、面向对象的特征有哪些方面</p>
</blockquote>
<p><strong>抽象：</strong></p>
<p>​		抽象是将一类对象的共同特征总结出来构造类的过程，包括数据抽象和行为抽象两方面。抽象只关注对象有哪些属性和行为，并不关注这些行为的细节是什么。</p>
<p><strong>封装:</strong></p>
<p>​		封装把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法，如果属性不想被外界访问，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。</p>
<p><strong>继承:</strong></p>
<p>​		继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承我们能够非常方便地复用以前的代码。</p>
<p>关于继承记住如下 3 点：</p>
<ul>
<li>
<p>子类拥有父类非 private 的属性和方法。</p>
</li>
<li>
<p>子类可以拥有自己属性和方法，即子类可以对父类进行扩展。</p>
</li>
<li>
<p>子类可以用自己的方式实现父类的方法。</p>
</li>
</ul>
<p><strong>多态:</strong></p>
<p>​		所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编译时并不确定，而是在程序运行期间才确定，即一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。</p>
<p>在Java中有两种形式可以实现多态：<strong>继承</strong>（多个子类对同一方法的重写）和 <strong>接口</strong>（实现接口并覆盖接口中同一方法）。</p>
<p>其中Java 面向对象编程三大特性：<mark>封装 、继承、 多态</mark></p>
<p><strong>封装</strong>：隐藏对象的属性和实现细节，仅对外提供公共访问方式，将变化隔离，便于使用，提高复用性和安全性。</p>
<p><strong>继承</strong>：继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但					不能选择性地继承父类。通过使用继承可以提高代码复用性。继承是多态的前提。</p>
<p><strong>多态性</strong>：父类或接口定义的引用变量可以指向子类或具体实现类的实例对象。提高了程序的拓展性。在Java中有两种形式可以实现多						态：继承（多个子类对同一方法的重写）和接口（实现接口并覆盖接口中同一方法）。</p>
<p><mark>方法重载</mark>(overload)实现的是编译时的多态性（也称为前绑定/<strong>静态绑定</strong>），而 <mark>方法重写</mark> 实现的是运行时的多态性（也		称为后绑定/<strong>动态绑定</strong>）。</p>
<p>一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。运行时的多态是面向对象最精髓的东西。</p>
<p>要实现<strong>多态的条件</strong>：</p>
<ul>
<li>方法重写（子类继承父类并重写父类中已有的或抽象的方法）；</li>
<li>对象造型（用父类型引用子类型对象，这样同样的引用调用同样的方法就会根据子类对象的不同而表现出不同的行为）。</li>
</ul>
<blockquote>
<p>2、什么是多态机制？Java语言是如何实现多态的？</p>
</blockquote>
<p>所谓多态就是指:程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编译时并不确定，而是在程序运行期间才确定，即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。因为在程序运行时才确定具体的类，这样，不用修改源程序代码，就可以让引用变量绑定到各种不同的类实现上，从而导致该引用调用的具体方法随之改变，即不修改程序代码就可以改变程序运行时所绑定的具体代码，让程序可以选择多个运行状态，这就是多态性。</p>
<p>多态分为<strong>编译时多态</strong>和<strong>运行时多态</strong>。</p>
<ul>
<li>
<p>其中编译时多态是静态的，主要是指方法的重载，它是根据参数列表的不同来区分不同的函数，通过编译之后会变成两个不同的函数，在运行时谈不上多态。</p>
</li>
<li>
<p>而运行时多态是动态的，它是通过动态绑定来实现的，也就是我们所说的多态性。</p>
</li>
</ul>
<p><strong>多态的实现</strong></p>
<p>Java实现多态有三个必要条件：<mark>继承、重写、向上转型。</mark></p>
<p>继承：在多态中必须存在有继承关系的子类和父类。</p>
<p>重写：子类对父类中某些方法进行重新定义，在调用这些方法时就会调用子类的方法。</p>
<p>向上转型：在多态中需要 <mark>将子类的对象赋给父类引用</mark>，只有这样该引用才能够具备技能调用父类的方法和子类的方法。</p>
<p>只有满足了上述三个条件，我们才能够在同一个继承结构中使用统一的逻辑实现代码处理不同的对象，从而达到执行不同的行为。</p>
<p>对于Java而言，它多态的实现机制遵循一个【<strong>原则</strong>】：<mark>当超类对象引用子类对象时，被引用对象的类型决定了调用谁的成员方法，但是这个被调用的方法必须是在超类中定义过的，也就是说被子类覆盖的方法。</mark></p>
<blockquote>
<p>3、面向对象七大基本原则是什么（可选）</p>
</blockquote>
<ol>
<li>
<p><strong>单一职责原则</strong>SRP(Single Responsibility Principle)
类的功能要单一，不能包罗万象，跟杂货铺似的。</p>
</li>
<li>
<p><strong>开放封闭原则</strong>OCP(Open－Close Principle)
一个模块对于拓展是开放的，对于修改是封闭的，想要增加功能热烈欢迎，想要修改，哼，一万个不乐意。</p>
</li>
<li>
<p><strong>里式替换原则</strong>LSP(the Liskov Substitution Principle LSP)
子类可以替换父类，出现在父类能够出现的任何地方。比如你能代表你爸去你姥姥家干活。</p>
</li>
<li>
<p><strong>依赖倒置原则</strong>DIP(the Dependency Inversion Principle DIP)
高层次的模块不应该依赖于低层次的模块，他们都应该依赖于抽象。<mark>抽象不应该依赖于具体实现，具体实现应该依赖于抽象</mark>。就是你出国要说你是中国人，而不能说你是哪个村子的。比如说中国人是抽象的，下面有具体的xx省，xx市，xx县。你要依赖的抽象是中国人，而不是你是xx村的。</p>
</li>
<li>
<p><strong>接口分离原则</strong>ISP(the Interface Segregation Principle ISP)
设计时采用多个与特定客户类有关的接口比采用一个通用的接口要好。就比如一个手机拥有打电话，看视频，玩游戏等功能，把这几个功能拆分成不同的接口，比在一个接口里要好的多。</p>
</li>
<li>
<p><strong>迪米特法则</strong></p>
<p>只与你的朋友交谈，不与“陌生人”说话，（降低耦合度）</p>
</li>
<li>
<p><strong>合成复用原则</strong></p>
<p>尽量使用组合和聚合的关系来实现，然后才考虑使用继承，使用继承时要考虑里氏替换</p>
</li>
</ol>
<h4 id="三-类与接口-2"> （三）类与接口</h4>
<blockquote>
<p>1、抽象类和接口的对比</p>
</blockquote>
<p>抽象类是用来捕捉子类的通用特性的。接口是抽象方法的集合。</p>
<p>从设计层面来说，<mark>抽象类是对类的抽象</mark>，是一种模板设计，<mark>接口是行为的抽象</mark>，是一种行为的规范。</p>
<p><strong>相同点</strong></p>
<ul>
<li>接口和抽象类都不能实例化</li>
<li>都位于继承的顶端，用于被其他实现或继承</li>
<li>都包含抽象方法，其子类都必须覆写这些抽象方法</li>
</ul>
<p><strong>不同点</strong></p>
<table>
<thead>
<tr>
<th>参数</th>
<th>抽象类</th>
<th>接口</th>
</tr>
</thead>
<tbody>
<tr>
<td>声明</td>
<td>抽象类使用abstract关键字声明</td>
<td>接口使用interface关键字声明</td>
</tr>
<tr>
<td>实现</td>
<td>子类使用<strong>extends</strong>关键字来继承抽象类。如果子类不是抽象类的话，它需要提供抽象类中所有声明的方法的实现</td>
<td>子类使用implements关键字来实现接口。它需要提供接口中所有声明的方法的实现</td>
</tr>
<tr>
<td>构造器</td>
<td>抽象类可以有构造器</td>
<td>接口没有构造器</td>
</tr>
<tr>
<td>访问修饰符</td>
<td>抽象类中的方法可以是任意访问修饰符</td>
<td>接口方法默认修饰符是public。并且不允许定义为 private 或者 protected</td>
</tr>
<tr>
<td>多继承</td>
<td>一个类最多只能继承一个抽象类</td>
<td>一个类可以实现多个接口</td>
</tr>
<tr>
<td>字段声明</td>
<td>抽象类的字段声明可以是任意的</td>
<td>接口的字段默认都是 static 和 final 的</td>
</tr>
</tbody>
</table>
<p><strong>备注</strong>：Java8中的接口引入默认方法和静态方法，以此来减少抽象类和接口之间的差异。</p>
<p>现在，我们可以为接口提供默认实现的方法了，并且不用强制子类来实现它。</p>
<p>接口和抽象类各有优缺点，在接口和抽象类的选择上，必须遵守这样一个原则：</p>
<p><mark>行为模型应该总是通过接口而不是抽象类定义，所以通常是优先选用接口，尽量少用抽象类。</mark></p>
<p>选择抽象类的时候通常是如下情况：需要定义子类的行为，又要为子类提供通用的功能。</p>
<blockquote>
<p>2、普通类和抽象类有哪些区别？</p>
</blockquote>
<ul>
<li>普通类不能包含抽象方法，抽象类可以包含抽象方法。</li>
<li>抽象类不能直接实例化，普通类可以直接实例化。</li>
</ul>
<blockquote>
<p>3、抽象类能使用 final 修饰吗？</p>
</blockquote>
<p>不能</p>
<p>定义抽象类就是让其他类继承的，如果定义为 final 该类就不能被继承，这样彼此就会产生矛盾，所以 final 不能修饰抽象类</p>
<blockquote>
<p>4、创建一个对象用什么关键字？对象实例与对象引用有何不同？</p>
</blockquote>
<p>new关键字</p>
<ol>
<li>new创建对象实例（<mark>对象</mark> 实例在 <mark>堆内存</mark> 中）</li>
<li>对象引用指向对象实例（对象 <mark>引用</mark> 存放在 <mark>栈内存</mark> 中）。</li>
<li>一个对象引用可以指向0个或1个对象（一根绳子可以不系气球，也可以系一个气球）</li>
<li>一个对象可以有n个引用指向它（可以用n条绳子系住一个气球）</li>
</ol>
<h4 id="四-变量与方法-2"> （四）变量与方法</h4>
<blockquote>
<p>1、成员变量与局部变量的区别有哪些</p>
</blockquote>
<p>变量：在程序执行的过程中，在某个范围内其值可以发生改变的量。从本质上讲，变量其实是内存中的一小块区域</p>
<p>成员变量：方法外部，类内部定义的变量</p>
<p>局部变量：类的方法中的变量。</p>
<p><strong>成员变量和局部变量的区别</strong></p>
<ul>
<li>
<p><strong>作用域</strong></p>
<p>成员变量：针对整个类有效。
局部变量：只在某个范围内有效。(一般指的就是方法,语句体内)</p>
</li>
<li>
<p><strong>存储位置</strong></p>
<p>成员变量：随着对象的创建而存在，随着对象的消失而消失，存储在 <mark>堆内存</mark> 中。
局部变量：在方法被调用，或者语句被执行的时候存在，存储在 <mark>栈内存</mark> 中。当方法调用完，或者语句结束后，就自动释放。</p>
</li>
<li>
<p><strong>生命周期</strong></p>
<p>成员变量：随着对象的创建而存在，随着对象的消失而消失
局部变量：当方法调用完，或者语句结束后，就自动释放。</p>
</li>
<li>
<p><strong>初始值</strong></p>
<p>成员变量：有默认初始值。</p>
<p>局部变量：没有默认初始值，使用前必须赋值。</p>
</li>
<li>
<p><strong>使用原则</strong></p>
<p>在使用变量时需要遵循的原则为：就近原则
首先在局部范围找，有就使用；接着在成员位置找。</p>
</li>
</ul>
<blockquote>
<p>2、在Java中定义一个不做事且没有参数的构造方法的作用</p>
</blockquote>
<ul>
<li>Java程序在执行子类的构造方法之前，如果没有用super()来调用父类特定的构造方法，则会调用父类中“没有参数的构造方法”。</li>
<li>因此，如果父类中只定义了有参数的构造方法，而在子类的构造方法中又没有用super()来调用父类中特定的构造方法，则编译时将发生错误，因为Java程序在父类中找不到没有参数的构造方法可供执行。解决办法是在父类里加上一个不做事且没有参数的构造方法。</li>
</ul>
<blockquote>
<p>3、在调用子类构造方法之前会先调用父类没有参数的构造方法，其目的是？</p>
</blockquote>
<p>帮助子类做初始化工作。</p>
<blockquote>
<p>4、一个类的构造方法的作用是什么？若一个类没有声明构造方法，该程序能正确执行吗？为什么？</p>
</blockquote>
<ul>
<li>主要作用是完成对类对象的初始化工作。</li>
<li>可以执行。因为一个类即使没有声明构造方法也会有默认的不带参数的构造方法。</li>
</ul>
<blockquote>
<p>5、构造方法有哪些特点？</p>
</blockquote>
<ol>
<li>
<p>名字与类名相同；</p>
</li>
<li>
<p>没有返回值，但不能用void声明构造函数；</p>
</li>
<li>
<p>生成类的对象时自动执行，无需调用。</p>
</li>
</ol>
<blockquote>
<p>6、静态变量和实例变量区别</p>
</blockquote>
<ul>
<li>
<p>静态变量：</p>
<p>1、静态变量由于不属于任何实例对象，属于类的，所以在内存中只会有一份</p>
<p>2、在类的加载过程中，JVM只为静态变量分配一次内存空间。</p>
</li>
<li>
<p>实例变量：</p>
<p>每次创建对象，都会为每个对象分配成员变量内存空间，实例变量是属于实例对象的，</p>
<p>在内存中，创建几次对象，就有几份成员变量。</p>
</li>
</ul>
<blockquote>
<p>7、静态变量与普通变量区别</p>
</blockquote>
<p>static变量也称作静态变量</p>
<p>静态变量和非静态变量的<strong>区别</strong>是：</p>
<ol>
<li>静态变量被所有的对象所共享，在内存中只有一个副本，它当且仅当在类初次加载时会被初始化。</li>
<li>而非静态变量是对象所拥有的，在创建对象的时候被初始化，存在多个副本，各个对象拥有的副本互不影响。</li>
<li>还有一点就是<strong>static成员变量的初始化顺序按照定义的顺序进行初始化</strong></li>
</ol>
<blockquote>
<p>8、静态方法和实例方法有何不同？</p>
</blockquote>
<p>静态方法和实例方法的区别主要体现在两个方面：</p>
<ul>
<li>
<p>在外部调用静态方法时，可以使用&quot;类名.方法名&quot;的方式，也可以使用&quot;对象名.方法名&quot;的方式。而实例方法只有后面这种方式。也就是说，调用静态方法可以无需创建对象。</p>
</li>
<li>
<p>静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），而不允许访问实例成员变量和实例方法；实例方法则无此限制</p>
</li>
</ul>
<blockquote>
<p>9、在一个静态方法内调用一个非静态成员为什么是非法的？</p>
</blockquote>
<p>由于静态方法可以不通过对象进行调用，因此在静态方法里，不能调用其他非静态变量，也不可以访问非静态变量成员。</p>
<blockquote>
<p>10、什么是方法的返回值？返回值的作用是什么？</p>
</blockquote>
<ul>
<li>方法的返回值是指我们获取到的某个方法体中的代码执行后产生的结果！（前提是该方法可能产生结果）。</li>
<li>返回值的作用：接收出结果，使得它可以用于其他的操作！</li>
</ul>
<h4 id="五-内部类-2"> （五）内部类</h4>
<blockquote>
<p>1、什么是内部类？</p>
</blockquote>
<ul>
<li>在Java中，可以将一个类的定义放在另外一个类的定义内部，这就是<strong>内部类</strong>。</li>
<li>内部类本身就是类的一个属性，与其他属性定义方式一致。</li>
</ul>
<blockquote>
<p>2、内部类的分类有哪些</p>
</blockquote>
<p>内部类可以分为四种：<strong>成员内部类、局部内部类、匿名内部类和静态内部类</strong>。</p>
<p><strong>（1）静态内部类</strong></p>
<p>定义在类内部的静态类，就是静态内部类。</p>
<div><pre><code><span>public</span> <span>class</span> <span>Outer</span> <span>{</span>

    <span>private</span> <span>static</span> <span>int</span> radius <span>=</span> <span>1</span><span>;</span>

    <span>static</span> <span>class</span> <span>StaticInner</span> <span>{</span>
        <span>public</span> <span>void</span> <span>visit</span><span>(</span><span>)</span> <span>{</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"visit outer static  variable:"</span> <span>+</span> radius<span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>静态内部类可以访问外部类所有的静态变量，而不可访问外部类的非静态变量；</p>
<p>静态内部类的创建方式，<code>new 外部类.静态内部类()</code>，如下：</p>
<div><pre><code><span>Outer<span>.</span>StaticInner</span> inner <span>=</span> <span>new</span> <span>Outer<span>.</span>StaticInner</span><span>(</span><span>)</span><span>;</span>
inner<span>.</span><span>visit</span><span>(</span><span>)</span><span>;</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><strong>（2）成员内部类</strong></p>
<p>定义在类内部，成员位置上的非静态类，就是成员内部类</p>
<div><pre><code><span>public</span> <span>class</span> <span>Outer</span> <span>{</span>

    <span>private</span> <span>static</span>  <span>int</span> radius <span>=</span> <span>1</span><span>;</span>
    <span>private</span> <span>int</span> count <span>=</span><span>2</span><span>;</span>
    
     <span>class</span> <span>Inner</span> <span>{</span>
        <span>public</span> <span>void</span> <span>visit</span><span>(</span><span>)</span> <span>{</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"visit outer static  variable:"</span> <span>+</span> radius<span>)</span><span>;</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"visit outer   variable:"</span> <span>+</span> count<span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>成员内部类可以访问外部类所有的变量和方法，包括静态和非静态，私有和公有。成员内部类依赖于外部类的实例，</p>
<p>它的创建方式<code>外部类实例.new 内部类()</code>，如下：</p>
<div><pre><code><span>Outer</span> outer <span>=</span> <span>new</span> <span>Outer</span><span>(</span><span>)</span><span>;</span>
<span>Outer<span>.</span>Inner</span> inner <span>=</span> outer<span>.</span><span>new</span> <span>Inner</span><span>(</span><span>)</span><span>;</span>
inner<span>.</span><span>visit</span><span>(</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><strong>（3）局部内部类</strong></p>
<p>定义在方法中的内部类，就是局部内部类。</p>
<div><pre><code><span>public</span> <span>class</span> <span>Outer</span> <span>{</span>

    <span>private</span>  <span>int</span> out_a <span>=</span> <span>1</span><span>;</span>
    <span>private</span> <span>static</span> <span>int</span> <span>STATIC_b</span> <span>=</span> <span>2</span><span>;</span>

    <span>public</span> <span>void</span> <span>testFunctionClass</span><span>(</span><span>)</span><span>{</span>
        <span>int</span> inner_c <span>=</span><span>3</span><span>;</span>
        <span>class</span> <span>Inner</span> <span>{</span>
            <span>private</span> <span>void</span> <span>fun</span><span>(</span><span>)</span><span>{</span>
                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>out_a<span>)</span><span>;</span>
                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>STATIC_b</span><span>)</span><span>;</span>
                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>inner_c<span>)</span><span>;</span>
            <span>}</span>
        <span>}</span>
        <span>Inner</span>  inner <span>=</span> <span>new</span> <span>Inner</span><span>(</span><span>)</span><span>;</span>
        inner<span>.</span><span>fun</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
    <span>public</span> <span>static</span> <span>void</span> <span>testStaticFunctionClass</span><span>(</span><span>)</span><span>{</span>
        <span>int</span> d <span>=</span><span>3</span><span>;</span>
        <span>class</span> <span>Inner</span> <span>{</span>
            <span>private</span> <span>void</span> <span>fun</span><span>(</span><span>)</span><span>{</span>
                <span>// System.out.println(out_a); 编译错误，定义在静态方法中的局部类不可以访问外部类的实例变量</span>
                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>STATIC_b</span><span>)</span><span>;</span>
                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>d<span>)</span><span>;</span>
            <span>}</span>
        <span>}</span>
        <span>Inner</span>  inner <span>=</span> <span>new</span> <span>Inner</span><span>(</span><span>)</span><span>;</span>
        inner<span>.</span><span>fun</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br></div></div><p>定义在实例方法中的局部类可以访问外部类的所有变量和方法，定义在静态方法中的局部类只能访问外部类的静态变量和方法。</p>
<p>局部内部类的创建方式，在对应方法内，<code>new 内部类()</code>，如下：</p>
<div><pre><code> <span>public</span> <span>static</span> <span>void</span> <span>testStaticFunctionClass</span><span>(</span><span>)</span><span>{</span>
    <span>class</span> <span>Inner</span> <span>{</span>
    <span>}</span>
    <span>Inner</span>  inner <span>=</span> <span>new</span> <span>Inner</span><span>(</span><span>)</span><span>;</span>
 <span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p><strong>（4）匿名内部类</strong></p>
<p>匿名内部类就是没有名字的内部类，日常开发中使用的比较多。</p>
<div><pre><code><span>public</span> <span>class</span> <span>Outer</span> <span>{</span>

    <span>private</span> <span>void</span> <span>test</span><span>(</span><span>final</span> <span>int</span> i<span>)</span> <span>{</span>
        <span>new</span> <span>Service</span><span>(</span><span>)</span> <span>{</span>
            <span>public</span> <span>void</span> <span>method</span><span>(</span><span>)</span> <span>{</span>
                <span>for</span> <span>(</span><span>int</span> j <span>=</span> <span>0</span><span>;</span> j <span>&lt;</span> i<span>;</span> j<span>++</span><span>)</span> <span>{</span>
                    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"匿名内部类"</span> <span>)</span><span>;</span>
                <span>}</span>
            <span>}</span>
        <span>}</span><span>.</span><span>method</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
 <span>}</span>
 <span>//匿名内部类必须继承或实现一个已有的接口 </span>
 <span>interface</span> <span>Service</span><span>{</span>
    <span>void</span> <span>method</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>除了没有名字，匿名内部类还有以下特点：</p>
<ul>
<li><mark>匿名内部类必须继承一个抽象类或者实现一个接口。</mark></li>
<li>匿名内部类不能定义任何静态成员和静态方法。</li>
<li>当所在的方法的形参需要被匿名内部类使用时，必须声明为 final。</li>
<li>匿名内部类不能是抽象的，它必须要实现继承的类或者实现的接口的所有抽象方法。</li>
</ul>
<p>匿名内部类创建方式：</p>
<div><pre><code><span>new</span> 类<span>/</span>接口<span>{</span> 
  <span>//匿名内部类实现部分</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><blockquote>
<p>3、内部类的优点</p>
</blockquote>
<p>我们为什么要使用内部类呢？因为它有以下优点：</p>
<ul>
<li>一个内部类对象可以访问创建它的外部类对象的内容，包括私有数据！</li>
<li>内部类不为同一包的其他类所见，具有很好的封装性；</li>
<li>内部类有效实现了“多重继承”，优化 java 单继承的缺陷。</li>
<li>匿名内部类可以很方便的定义回调。</li>
</ul>
<blockquote>
<p>4、内部类有哪些应用场景</p>
</blockquote>
<ol>
<li>一些多算法场合</li>
<li>解决一些非面向对象的语句块。</li>
<li>适当使用内部类，使得代码更加灵活和富有扩展性。</li>
<li>当某个类除了它的外部类，不再被其他的类使用时。</li>
</ol>
<blockquote>
<p>5、局部内部类和匿名内部类访问 <mark>局部变量</mark> 的时候，为什么变量必须 <mark>要加上final</mark> ？</p>
</blockquote>
<p>先看这段代码：</p>
<div><pre><code><span>public</span> <span>class</span> <span>Outer</span> <span>{</span>

    <span>void</span> <span>outMethod</span><span>(</span><span>)</span><span>{</span>
        <span>final</span> <span>int</span> a <span>=</span><span>10</span><span>;</span>
        <span>class</span> <span>Inner</span> <span>{</span>
            <span>void</span> <span>innerMethod</span><span>(</span><span>)</span><span>{</span>
                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>a<span>)</span><span>;</span>
            <span>}</span>

        <span>}</span>
    <span>}</span>
<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>以上例子，为什么要加final呢？是因为生命周期不一致， 局部变量直接存储在栈中，当方法执行结束后，非final的局部变量就被销毁。</p>
<p>而局部内部类对局部变量的引用依然存在，如果局部内部类要调用局部变量时，就会出错。加了final，可以确保局部内部类使用的变量</p>
<p>与外层的局部变量区分开，解决了这个问题。</p>
<blockquote>
<p>6、内部类相关，看程序说出运行结果</p>
</blockquote>
<div><pre><code><span>public</span> <span>class</span> <span>Outer</span> <span>{</span>
    <span>private</span> <span>int</span> age <span>=</span> <span>12</span><span>;</span>

    <span>class</span> <span>Inner</span> <span>{</span>
        <span>private</span> <span>int</span> age <span>=</span> <span>13</span><span>;</span>
        <span>public</span> <span>void</span> <span>print</span><span>(</span><span>)</span> <span>{</span>
            <span>int</span> age <span>=</span> <span>14</span><span>;</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"局部变量："</span> <span>+</span> age<span>)</span><span>;</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"内部类变量："</span> <span>+</span> <span>this</span><span>.</span>age<span>)</span><span>;</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"外部类变量："</span> <span>+</span> <span>Outer</span><span>.</span><span>this</span><span>.</span>age<span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>

    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>Outer<span>.</span>Inner</span> in <span>=</span> <span>new</span> <span>Outer</span><span>(</span><span>)</span><span>.</span><span>new</span> <span>Inner</span><span>(</span><span>)</span><span>;</span>
        in<span>.</span><span>print</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>

<span>}</span>
运行结果
局部变量：<span>14</span>
内部类变量：<span>13</span>
外部类变量：<span>12</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><h4 id="六-重写与重载-2"> （六）重写与重载</h4>
<blockquote>
<p>1、构造器（constructor）是否可被重写（override）</p>
</blockquote>
<p>构造器不能被继承，因此不能被重写，但可以被重载。</p>
<blockquote>
<p>2、重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？</p>
</blockquote>
<p><mark>方法的重载和重写都是实现多态的方式</mark>，区别在于前者实现的是 <mark>编译时的多态性</mark> ，而后者实现的是 <mark>运行时的多态性</mark>。</p>
<ul>
<li>
<p><strong>重载：</strong></p>
<p>1、发生在同一个类中，方法名相同参数列表不同（参数类型不同、个数不同、顺序不同），</p>
<p>2、与方法返回值和访问修饰符无关，即重载的方法不能根据返回类型进行区分</p>
</li>
<li>
<p><strong>重写：</strong></p>
<p>1、发生在父子类中，方法名、参数列表必须相同，</p>
<p>2、返回值小于等于父类，抛出的异常小于等于父类，</p>
<p>3、访问修饰符大于等于父类（里氏替换原则）</p>
<p>4、如果父类方法访问修饰符为private则子类中就不是重写。</p>
</li>
</ul>
<h4 id="七-对象相等判断-2"> （七）对象相等判断</h4>
<blockquote>
<p>1、== 和 equals 的区别是什么</p>
</blockquote>
<p><mark>==和equals都是值比较</mark></p>
<p><strong>（1）==</strong></p>
<ul>
<li>
<p>基本数据类型 == 比较的是值</p>
</li>
<li>
<p>引用数据类型 == 比较的是内存地址值</p>
</li>
</ul>
<p><strong>（2）equals() :</strong></p>
<p>​	对象之间进行比较的方法</p>
<ul>
<li>
<p>equals内部先进行的还是==，判断是否是同一个对象</p>
</li>
<li>
<p>接着才会是对象内容的比较（重写过equals方法）</p>
</li>
</ul>
<p><strong>equals() 一般有两种使用情况：</strong></p>
<ul>
<li>
<p>情况1：类没有覆盖 equals() 方法。则通过 equals() 比较该类的两个对象时，等价于通过“==”比较这两个对象。</p>
</li>
<li>
<p>情况2：类覆盖了 equals() 方法。一般，我们都覆盖 equals() 方法来两个对象的内容相等；若它们的内容相等，则返回 true (即认   为这两个对象相等)。</p>
</li>
</ul>
<div><pre><code><span>public</span> <span>class</span> test1 <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>String</span> a <span>=</span> <span>new</span> <span>String</span><span>(</span><span>"ab"</span><span>)</span><span>;</span> <span>// a 为一个引用</span>
        <span>String</span> b <span>=</span> <span>new</span> <span>String</span><span>(</span><span>"ab"</span><span>)</span><span>;</span> <span>// b为另一个引用,对象的内容一样</span>
        <span>String</span> aa <span>=</span> <span>"ab"</span><span>;</span> <span>// 放在常量池中</span>
        <span>String</span> bb <span>=</span> <span>"ab"</span><span>;</span> <span>// 从常量池中查找</span>
        <span>if</span> <span>(</span>aa <span>==</span> bb<span>)</span> <span>// true</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"aa==bb"</span><span>)</span><span>;</span>
        <span>if</span> <span>(</span>a <span>==</span> b<span>)</span> <span>// false，非同一对象</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"a==b"</span><span>)</span><span>;</span>
        <span>if</span> <span>(</span>a<span>.</span><span>equals</span><span>(</span>b<span>)</span><span>)</span> <span>// true</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"aEQb"</span><span>)</span><span>;</span>
        <span>if</span> <span>(</span><span>42</span> <span>==</span> <span>42.0</span><span>)</span> <span>{</span> <span>// true</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"true"</span><span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p>说明：</p>
<ul>
<li>String中的equals方法是被重写过的，因为object的equals方法是比较的对象的内存地址，而String的equals方法比较的是对象的内容。</li>
<li>当创建String类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个String对象。</li>
</ul>
<blockquote>
<p>2、hashCode 与 equals 方法 ( <mark>重要</mark> )</p>
</blockquote>
<p><strong>HashSet如何检查重复？</strong></p>
<p>两个对象的 hashCode() 相同，则 equals() 也一定为 true，对吗？</p>
<p>hashCode和equals方法的关系</p>
<p>面试官可能会问你：“你重写过 hashcode 和 equals 么，为什么重写equals时必须重写hashCode方法？”</p>
<p><strong>（1）hashCode()介绍</strong></p>
<p>hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个int整数。这个哈希码的作用是确定该对象在哈希表中的索引位</p>
<p>置。hashCode() 定义在JDK的Object.java中，这就意味着Java中的任何类都包含有hashCode()函数。散列表存储的是键值对(key-</p>
<p>value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）</p>
<p><strong>（2）为什么要有 hashCode</strong></p>
<p>我们以“HashSet 如何检查重复”为例子来说明为什么要有 hashCode：</p>
<p>当你把对象加入 HashSet 时，HashSet 会先计算对象的 hashcode 值来判断对象加入的位置，同时也会与其他已经加入的对象的</p>
<p>hashcode 值作比较，如果没有相符的hashcode，HashSet会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时</p>
<p>会调用 equals()方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让加入操作成功。如果不同的话，就</p>
<p>会重新散列到其他位置。（摘自我的Java启蒙书《Head first java》第二版）。这样我们就 <mark>大大减少了 equals 的次数</mark> ，相应就大大提高</p>
<p>了执行速度。</p>
<p><strong>（3）hashCode()与equals()的相关规定</strong></p>
<ul>
<li>
<p>如果两个对象相等，则hashcode一定也是相同的</p>
</li>
<li>
<p>两个对象相等，对两个对象分别调用equals方法都返回true</p>
</li>
<li>
<p>两个对象有相同的hashcode值，它们也不一定是相等的</p>
</li>
<li>
<p>hashCode() 的默认行为是对堆上的对象产生独特值。如果没有重写 hashCode()，</p>
<p>则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）</p>
</li>
<li>
<p><mark>因此，equals 方法被覆盖过，则 hashCode 方法也必须被覆盖</mark></p>
</li>
</ul>
<blockquote>
<p>3、对象的相等与指向他们的引用相等，两者有什么不同？</p>
</blockquote>
<p>对象的相等比的是内存中存放的内容是否相等，而引用相等 比较的是他们指向的内存地址是否相等。</p>
<h4 id="八-值传递-2"> （八）值传递</h4>
<blockquote>
<p>1、当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递</p>
</blockquote>
<p>是值传递。</p>
<ul>
<li>
<p>Java 语言的方法调用只支持参数的值传递。</p>
</li>
<li>
<p>当一个对象实例作为一个参数被传递到方法中时，<mark>参数的值就是对该对象的引用</mark> 。</p>
</li>
<li>
<p>对象的属性可以在被调用过程中被改变，但对对象引用的改变是不会影响到调用者的</p>
</li>
</ul>
<blockquote>
<p>2、 Java 中对象作为形参为什么还是值传递</p>
</blockquote>
<p>首先回顾一下在程序设计语言中有关将参数传递给方法（或函数）的一些专业术语。</p>
<ul>
<li>按值调用(call by value)表示方法接收的是调用者提供的值，</li>
<li>而按引用调用（call by reference)表示方法接收的是调用者提供的变量地址。</li>
<li><mark>一个方法可以修改传递引用所对应的变量值，而不能修改传递值所对应的变量值</mark> 。 它用来描述各种程序设计语言（不只是Java)中方法参数传递方式。</li>
<li>Java程序设计语言总是采用按值调用。也就是说，<mark>方法得到的是所有参数值的一个拷贝</mark> ，也就是说，方法不能修改传递给它的任何参数变量的内容。</li>
</ul>
<p>下面通过 3 个例子来说明</p>
<p>example1：</p>
<div><pre><code><span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
    <span>int</span> num1 <span>=</span> <span>10</span><span>;</span>
    <span>int</span> num2 <span>=</span> <span>20</span><span>;</span>

    <span>swap</span><span>(</span>num1<span>,</span> num2<span>)</span><span>;</span>

    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"num1 = "</span> <span>+</span> num1<span>)</span><span>;</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"num2 = "</span> <span>+</span> num2<span>)</span><span>;</span>
<span>}</span>

<span>public</span> <span>static</span> <span>void</span> <span>swap</span><span>(</span><span>int</span> a<span>,</span> <span>int</span> b<span>)</span> <span>{</span>
    <span>int</span> temp <span>=</span> a<span>;</span>
    a <span>=</span> b<span>;</span>
    b <span>=</span> temp<span>;</span>

    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"a = "</span> <span>+</span> a<span>)</span><span>;</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"b = "</span> <span>+</span> b<span>)</span><span>;</span>
<span>}</span>
a <span>=</span> <span>20</span>
b <span>=</span> <span>10</span>
num1 <span>=</span> <span>10</span>
num2 <span>=</span> <span>20</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><p><img src="./assets/04.jpg" alt=""></p>
<p>在swap方法中，a、b的值进行交换，并不会影响到 num1、num2。因为，a、b中的值，只是从 num1、num2 的复制过来的。也就是说，a、b相当于num1、num2 的副本，副本的内容无论怎么修改，都不会影响到原件本身。</p>
<p>通过上面例子，我们已经知道了一个方法不能修改一个基本数据类型的参数，而 <mark>对象引用作为参数就不一样</mark></p>
<p>example2 ：</p>
<div><pre><code>    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>int</span><span>[</span><span>]</span> arr <span>=</span> <span>{</span> <span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>4</span><span>,</span> <span>5</span> <span>}</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>arr<span>[</span><span>0</span><span>]</span><span>)</span><span>;</span>
        <span>change</span><span>(</span>arr<span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>arr<span>[</span><span>0</span><span>]</span><span>)</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>static</span> <span>void</span> <span>change</span><span>(</span><span>int</span><span>[</span><span>]</span> array<span>)</span> <span>{</span>
        <span>// 将数组的第一个元素变为0</span>
        array<span>[</span><span>0</span><span>]</span> <span>=</span> <span>0</span><span>;</span>
    <span>}</span>
结果：
    <span>0</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p><img src="./assets/05.jpg" alt=""></p>
<ul>
<li>
<p>array 被初始化 arr 的拷贝也就是一个对象的引用，也就是说 array 和 arr 指向的时同一个数组对象。 因此，外部对引用对象的改变会反映到所对应的对象上。</p>
</li>
<li>
<p>通过 example2 我们已经看到，实现一个改变对象参数状态的方法并不是一件难事。理由很简单，方法得到的是 <mark>对象引用的拷贝</mark>，对象引用及其他的拷贝同时引用同一个对象。</p>
</li>
<li>
<p>很多程序设计语言（特别是，C++和Pascal)提供了两种参数传递的方式：值调用和引用调用。有些程序员 <mark>认为Java程序设计语言对对象采用的是引用调用，实际上，这种理解是不对的</mark>。由于这种误解具有一定的普遍性，所以下面给出一个反例来详细地阐述一下这个问题。</p>
</li>
</ul>
<p>example3:</p>
<div><pre><code><span>public</span> <span>class</span> <span>Test</span> <span>{</span>

    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>// TODO Auto-generated method stub</span>
        <span>Student</span> s1 <span>=</span> <span>new</span> <span>Student</span><span>(</span><span>"小张"</span><span>)</span><span>;</span>
        <span>Student</span> s2 <span>=</span> <span>new</span> <span>Student</span><span>(</span><span>"小李"</span><span>)</span><span>;</span>
        <span>//s1,s2都是对象的引用，有自己的地址，它们各自存储这相应对象的地址</span>
        <span>Test</span><span>.</span><span>swap</span><span>(</span>s1<span>,</span> s2<span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"s1:"</span> <span>+</span> s1<span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"s2:"</span> <span>+</span> s2<span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>static</span> <span>void</span> <span>swap</span><span>(</span><span>Student</span> x<span>,</span> <span>Student</span> y<span>)</span> <span>{</span>
        <span>Student</span> temp <span>=</span> x<span>;</span>
        x <span>=</span> y<span>;</span>
        y <span>=</span> temp<span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"x:"</span> <span>+</span> x<span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"y:"</span> <span>+</span> y<span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
结果：
    x<span>:</span>小李
	y<span>:</span>小张
	s1<span>:</span>小张
	s2<span>:</span>小李

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><p>交换前：</p>
<p><img src="./assets/06.jpg" alt=""></p>
<p>交换后：</p>
<p><img src="./assets/07.jpg" alt=""></p>
<p>通过上面两张图可以很清晰的看出： 方法并没有改变存储在变量 s1 和 s2 中的对象引用。swap方法的参数x和y被初始化为两个对象引用的拷贝，这个方法交换的是这两个拷贝</p>
<p><strong>总结</strong></p>
<ol>
<li>
<p>Java程序设计语言对对象采用的不是引用调用，实际上，对象引用是按值传递的，只不过这个值是对应的内存地址，与基本数据类型稍微不同而已</p>
</li>
<li>
<p>或者只需要记住传参都是进行拷贝，  <mark>对象引用的拷贝与引用传递不一样</mark></p>
</li>
<li>
<p>一个引用有自己的地址，它还存储着所引用对象的地址。</p>
</li>
<li>
<p><strong>对象引用的拷贝</strong>就是是 <mark>传递引用里存储的内存地址</mark> ，而<strong>引用传递</strong>是 <mark>传递引用自己本身的地址</mark>。</p>
<div><pre><code> <span>Student</span> s1 <span>=</span> <span>new</span> <span>Student</span><span>(</span><span>"小张"</span><span>)</span><span>;</span>
<span>//假设s1地址为123,所指向的对象的地址为456</span>
<span>//Java的值传递:将地址456拷贝给形参</span>
<span>//引用传递:将地址123拷贝给形参</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div></li>
</ol>
<p><strong>总结一下Java中方法参数的使用情况：</strong></p>
<ul>
<li>一个方法不能修改一个基本数据类型的参数（即数值型或布尔型》</li>
<li>一个方法可以改变一个对象参数的状态。</li>
<li><mark>一个方法不能让对象参数引用一个新的对象。</mark></li>
</ul>
<blockquote>
<p>3、值传递和引用传递有什么区别</p>
</blockquote>
<p><strong>值传递</strong> ：指的是在方法调用时，传递的参数是按值的拷贝传递，传递的是值的拷贝，也就是说传递后就互不相关了。</p>
<p><strong>引用传递</strong>：指的是在方法调用时，传递的参数是按引用进行传递，<mark>传递的是引用的地址</mark>，也就是变量所对应的内存空间的地址。传递							 的是值的引用，也就是说传递前和传递后都指向同一个引用（也就是同一个内存空间）。</p>
<h4 id="九-java包-2"> （九）Java包</h4>
<blockquote>
<p>1、JDK 中常用的包有哪些</p>
</blockquote>
<p>java.lang：这个是系统的基础类，不用显示导入</p>
<p>java.io：这里面是所有输入输出有关的类，比如文件操作等；</p>
<p>java.nio：为了完善 io 包中的功能，提高 io 包中性能而写的一个新包；</p>
<p>java.net：这里面是与网络有关的类；</p>
<p>java.util：这个是系统辅助类，特别是集合类；</p>
<p>java.sql：这个是数据库操作的类。</p>
<blockquote>
<p>2、import java和javax有什么区别</p>
</blockquote>
<p>刚开始的时候 JavaAPI 所必需的包是 java 开头的包，javax 当时只是作为扩展 API 包来使用。后来考虑到将扩展从 javax 包移动到 java</p>
<p>包太麻烦了，最终会破坏一堆现有的代码，最终决定将 javax 包作为标准API的一部分。</p>
<p>所以，实际上java和javax没有区别。这都是一个名字。</p>
<h3 id="四、常用api-2"> 四、常用API</h3>
<h4 id="一-string相关-2"> （一）String相关</h4>
<blockquote>
<p>1、字符型常量和字符串常量的区别</p>
</blockquote>
<ul>
<li>形式上: 字符常量是单引号引起的一个字符 字符串常量是双引号引起的若干个字符</li>
<li>含义上: 字符常量相当于一个整形值(ASCII值),可以参加表达式运算 ,字符串常量代表一个地址值(该字符串在内存中存放位置)</li>
<li>占内存大小: 字符常量只占一个字节 字符串常量占若干个字节(至少一个字符结束标志)</li>
</ul>
<blockquote>
<p>2、什么是字符串常量池？</p>
</blockquote>
<ul>
<li>字符串常量池位于<strong>堆内存</strong>中，专门用来存储字符串常量，可以提高内存的使用率，避免开辟多块空间存储相同的字符串</li>
<li>在创建字符串时 JVM 会首先检查字符串常量池，如果该字符串已经存在池中，则返回它的引用，如果不存在，则实例化一个字符串放到池中，并返回其引用。</li>
</ul>
<blockquote>
<p>3、String 是最基本的数据类型吗</p>
</blockquote>
<p>不是。</p>
<ul>
<li>
<p>Java 中的基本数据类型只有 8 个 ：byte、short、int、long、float、double、char、boolean；</p>
</li>
<li>
<p>除了基本类型（primitive type），剩下的都是引用类型（referencetype），Java 5 以后引入的枚举类型也算是一种比较特殊的引用类型。</p>
</li>
<li>
<p>这是很基础的东西，但是很多初学者却容易忽视，Java 的 8 种基本数据类型中不包括 String，基本数据类型中用来描述文本数据的是 char，但是它只能表示单个字符，比如 ‘a’,‘好’ 之类的，如果要描述一段文本，就需要用多个 char 类型的变量，也就是一个 char 类型数组，比如“你好” 就是长度为2的数组 char[] chars = {‘你’,‘好’};</p>
</li>
<li>
<p>但是使用数组过于麻烦，所以就有了 String，String 底层就是一个 char 类型的数组，只是使用的时候开发者不需要直接操作底层数组，用更加简便的方式即可完成对字符串的使用。</p>
</li>
</ul>
<blockquote>
<p>4、String有哪些特性</p>
</blockquote>
<ul>
<li>
<p>不变性：String 是只读字符串，是一个典型的 immutable 对象，对它进行任何操作，其实都是创建一个新的对象，再把引用指向该对象。不变模式的主要作用在于当一个对象需要被多线程共享并频繁访问时，可以保证数据的一致性。</p>
</li>
<li>
<p>常量池优化：String 对象创建之后，会在字符串常量池中进行缓存，如果下次创建同样的对象时，会直接返回缓存的引用。</p>
</li>
<li>
<p>final：使用 final 来定义 String 类，表示 String 类不能被继承，提高了系统的安全性。</p>
</li>
</ul>
<blockquote>
<p>5、String为什么是不可变的吗？</p>
</blockquote>
<p>简单来说就是String类利用了final修饰的char类型数组存储字符，源码如下图所以：</p>
<div><pre><code><span>/** The value is used for character storage. */</span>
<span>private</span> <span>final</span> <span>char</span> value<span>[</span><span>]</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><blockquote>
<p>6、String真的是不可变的吗？</p>
</blockquote>
<p>我觉得如果别人问这个问题的话，回答不可变就可以了。 下面只是给大家看两个有代表性的例子：</p>
<p><strong>1) String不可变但不代表引用(句柄)不可以变</strong></p>
<div><pre><code><span>String</span> str <span>=</span> <span>"Hello"</span><span>;</span>
str <span>=</span> str <span>+</span> <span>" World"</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"str="</span> <span>+</span> str<span>)</span><span>;</span>
结果：
    str<span>=</span><span>Hello</span> <span>World</span>
实际上，原来<span>String</span>的内容是不变的，只是str由原来指向<span>"Hello"</span>的内存地址转为指向<span>"Hello World"</span>的内存地址而已，也就是说多开辟了一块内存区域给<span>"Hello World"</span>字符串。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p><strong>2) 通过反射是可以修改所谓的“不可变”对象</strong></p>
<div><pre><code><span>// 创建字符串"Hello World"， 并赋给引用s</span>
<span>String</span> s <span>=</span> <span>"Hello World"</span><span>;</span>

<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"s = "</span> <span>+</span> s<span>)</span><span>;</span> <span>// Hello World</span>

<span>// 获取String类中的value字段</span>
<span>Field</span> valueFieldOfString <span>=</span> <span>String</span><span>.</span><span>class</span><span>.</span><span>getDeclaredField</span><span>(</span><span>"value"</span><span>)</span><span>;</span>

<span>// 改变value属性的访问权限</span>
valueFieldOfString<span>.</span><span>setAccessible</span><span>(</span><span>true</span><span>)</span><span>;</span>

<span>// 获取s对象上的value属性的值</span>
<span>char</span><span>[</span><span>]</span> value <span>=</span> <span>(</span><span>char</span><span>[</span><span>]</span><span>)</span> valueFieldOfString<span>.</span><span>get</span><span>(</span>s<span>)</span><span>;</span>

<span>// 改变value所引用的数组中的第5个字符</span>
value<span>[</span><span>5</span><span>]</span> <span>=</span> <span>'_'</span><span>;</span>

<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"s = "</span> <span>+</span> s<span>)</span><span>;</span> <span>// Hello_World</span>
结果：
    s <span>=</span> <span>Hello</span> <span>World</span>
	s <span>=</span> <span>Hello_World</span>
用反射可以访问私有成员， 然后反射出<span>String</span>对象中的value属性， 进而改变通过获得的value引用改变数组的结构。但是一般我们不会这么做，这里只是简单提一下有这个东西。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><blockquote>
<p>7、是否可以继承 String 类</p>
</blockquote>
<p>String 类是 final 类，不可以被继承。</p>
<blockquote>
<p>8、String str=&quot;i&quot;与 String str=new String(&quot;i&quot;)一样吗？</p>
</blockquote>
<p>不一样，因为内存的分配方式不一样。</p>
<ul>
<li>String str=&quot;i&quot;的方式，java 虚拟机会将其分配到常量池中</li>
<li>而 String str=new String(“i”) 则会被分到堆内存中。</li>
</ul>
<blockquote>
<p>9、String s = new String(&quot;xyz&quot;);创建了几个字符串对象</p>
</blockquote>
<p>两个对象，一个是静态区的&quot;xyz&quot;，一个是用new创建在堆上的对象。（前提是之前字符串常量池中没有&quot;xyz&quot;）</p>
<div><pre><code><span>String</span> str1 <span>=</span> <span>"hello"</span><span>;</span> <span>//str1指向静态区</span>
<span>String</span> str2 <span>=</span> <span>new</span> <span>String</span><span>(</span><span>"hello"</span><span>)</span><span>;</span>  <span>//str2指向堆上的对象</span>
<span>String</span> str3 <span>=</span> <span>"hello"</span><span>;</span>
<span>String</span> str4 <span>=</span> <span>new</span> <span>String</span><span>(</span><span>"hello"</span><span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>str1<span>.</span><span>equals</span><span>(</span>str2<span>)</span><span>)</span><span>;</span> <span>//true</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>str2<span>.</span><span>equals</span><span>(</span>str4<span>)</span><span>)</span><span>;</span> <span>//true</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>str1 <span>==</span> str3<span>)</span><span>;</span> <span>//true</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>str1 <span>==</span> str2<span>)</span><span>;</span> <span>//false</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>str2 <span>==</span> str4<span>)</span><span>;</span> <span>//false</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>str2 <span>==</span> <span>"hello"</span><span>)</span><span>;</span> <span>//false</span>
str2 <span>=</span> str1<span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>str2 <span>==</span> <span>"hello"</span><span>)</span><span>;</span> <span>//true</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><blockquote>
<p>10、如何将字符串反转？</p>
</blockquote>
<p>使用 StringBuilder 或者 stringBuffer 的 reverse() 方法</p>
<div><pre><code><span>// StringBuffer reverse</span>
<span>StringBuffer</span> stringBuffer <span>=</span> <span>new</span> <span>StringBuffer</span><span>(</span><span>)</span><span>;</span>
stringBuffer<span>.</span> <span>append</span><span>(</span><span>"abcdefg"</span><span>)</span><span>;</span>
<span>System</span><span>.</span> out<span>.</span> <span>println</span><span>(</span>stringBuffer<span>.</span> <span>reverse</span><span>(</span><span>)</span><span>)</span><span>;</span> <span>// gfedcba</span>
<span>// StringBuilder reverse</span>
<span>StringBuilder</span> stringBuilder <span>=</span> <span>new</span> <span>StringBuilder</span><span>(</span><span>)</span><span>;</span>
stringBuilder<span>.</span> <span>append</span><span>(</span><span>"abcdefg"</span><span>)</span><span>;</span>
<span>System</span><span>.</span> out<span>.</span> <span>println</span><span>(</span>stringBuilder<span>.</span> <span>reverse</span><span>(</span><span>)</span><span>)</span><span>;</span> <span>// gfedcba</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><blockquote>
<p>11、数组有没有 length()方法？String 有没有 length()方法</p>
</blockquote>
<ul>
<li>数组没有 length()方法 ，有 length 的属性。</li>
<li>String 有 length()方法。</li>
<li>JavaScript中，获得字符串的长度是通过 length 属性得到的，这一点容易和 Java 混淆。</li>
</ul>
<blockquote>
<p>12、String 类的常用方法都有那些？</p>
</blockquote>
<ul>
<li>
<p>indexOf()：返回指定字符的索引。</p>
</li>
<li>
<p>charAt()：返回指定索引处的字符。</p>
</li>
<li>
<p>replace()：字符串替换。</p>
</li>
<li>
<p>trim()：去除字符串两端空白。</p>
</li>
<li>
<p>split()：分割字符串，返回一个分割后的字符串数组。</p>
</li>
<li>
<p>getBytes()：返回字符串的 byte 类型数组。</p>
</li>
<li>
<p>length()：返回字符串长度。</p>
</li>
<li>
<p>toLowerCase()：将字符串转成小写字母。</p>
</li>
<li>
<p>toUpperCase()：将字符串转成大写字符。</p>
</li>
<li>
<p>substring()：截取字符串。</p>
</li>
<li>
<p>equals()：字符串比较。</p>
</li>
</ul>
<blockquote>
<p>13、在使用 HashMap 的时候，用 String 做 key 有什么好处？</p>
</blockquote>
<p>HashMap 内部实现是通过 key 的 hashcode 来确定 value 的存储位置，因为字符串是不可变的，所以当创建字符串时，它的</p>
<p>hashcode 被缓存下来，不需要再次计算，所以相比于其他对象更快。</p>
<blockquote>
<p>14、String和StringBuffer、StringBuilder的区别是什么？String为什么是不可变的</p>
</blockquote>
<p><strong>可变性</strong></p>
<p>String类中使用字符数组保存字符串，private　final　char　value[]，所以string对象是不可变的。StringBuilder与StringBuffer都继承自AbstractStringBuilder类，在AbstractStringBuilder中也是使用字符数组保存字符串，char[] value，这两种对象都是可变的。</p>
<p><strong>线程安全性</strong></p>
<p>String中的对象是不可变的，也就可以理解为常量，线程安全。AbstractStringBuilder是StringBuilder与StringBuffer的公共父类，定义了一些字符串的基本操作，如expandCapacity、append、insert、indexOf等公共方法。StringBuffer对方法加了<strong>同步锁</strong>或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder并没有对方法进行加同步锁，所以是非线程安全的。</p>
<p><strong>性能</strong></p>
<p>每次对String 类型进行改变的时候，都会生成一个新的String对象，然后将指针指向新的String 对象。StringBuffer每次都会对StringBuffer对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用StirngBuilder 相比使用StringBuffer 仅能获得10%~15% 左右的性能提升，但却要冒多线程不安全的风险。</p>
<p><strong>对于三者使用的总结</strong></p>
<p>如果要操作少量的数据用   String</p>
<p>单线程操作字符串缓冲区 下操作大量数据  StringBuilder</p>
<p>多线程操作字符串缓冲区 下操作大量数据  StringBuffer</p>
<h4 id="二-date相关-2"> （二）Date相关</h4>
<h4 id="三-包装类相关-2"> （三）包装类相关</h4>
<blockquote>
<p>1、自动装箱与拆箱</p>
</blockquote>
<p><strong>装箱</strong>：将基本类型用它们对应的引用类型包装起来；</p>
<p><strong>拆箱</strong>：将包装类型转换为基本数据类型；</p>
<blockquote>
<p>2、int 和 Integer 有什么区别</p>
</blockquote>
<ul>
<li>Java 是一个近乎纯洁的面向对象编程语言，但是为了编程的方便还是引入了基本数据类型，</li>
<li><mark>为了能够将这些基本数据类型当成对象操作</mark>，Java 为每一个基本数据类型都引入了对应的包装类型（wrapper class），</li>
<li>从 Java 5 开始引入了自动装箱/拆箱机制，使得二者可以相互转换。</li>
</ul>
<p>Java 为每个原始类型提供了<strong>包装类型</strong>：</p>
<ul>
<li>
<p>原始类型: boolean，char，byte，short，int，long，float，double</p>
</li>
<li>
<p>包装类型：Boolean，Character，Byte，Short，Integer，Long，Float，Double</p>
</li>
</ul>
<blockquote>
<p>3、Integer a= 127 与 Integer b = 127相等吗</p>
</blockquote>
<p>相等。</p>
<ul>
<li>对于对象引用类型：== 比较的是对象的内存地址。</li>
<li>对于基本数据类型：==比较的是值。</li>
</ul>
<p>如果整型字面量的值在-128到127之间，那么自动装箱时不会new新的Integer对象，而是直接引用 <mark>常量池</mark> 中的Integer对象，</p>
<p>超过范围 a==b的结果是false</p>
<div><pre><code><span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
    <span>Integer</span> a <span>=</span> <span>new</span> <span>Integer</span><span>(</span><span>3</span><span>)</span><span>;</span>
    <span>Integer</span> b <span>=</span> <span>3</span><span>;</span>  <span>// 将3自动装箱成Integer类型</span>
    <span>int</span> c <span>=</span> <span>3</span><span>;</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>a <span>==</span> b<span>)</span><span>;</span> <span>// false 两个引用没有引用同一对象</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>a <span>==</span> c<span>)</span><span>;</span> <span>// true a自动拆箱成int类型再和c比较</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>b <span>==</span> c<span>)</span><span>;</span> <span>// true</span>

    <span>Integer</span> a1 <span>=</span> <span>128</span><span>;</span>
    <span>Integer</span> b1 <span>=</span> <span>128</span><span>;</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>a1 <span>==</span> b1<span>)</span><span>;</span> <span>// false</span>

    <span>Integer</span> a2 <span>=</span> <span>127</span><span>;</span>
    <span>Integer</span> b2 <span>=</span> <span>127</span><span>;</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>a2 <span>==</span> b2<span>)</span><span>;</span> <span>// true</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><h3 id="五、常用工具类库"> 五、常用工具类库</h3>
<h3 id="六、单元测试"> 六、单元测试</h3>
<h3 id="七、日志"> 七、日志</h3>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <contributor>
      <name>南辞</name>
    </contributor>
    <published>2021-02-16T17:39:43.000Z</published>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">Java进阶</title>
    <id>http://qiqi.dreamagain.top/program/backend/java/solution/Java%E8%BF%9B%E9%98%B6/</id>
    <link href="http://qiqi.dreamagain.top/program/backend/java/solution/Java%E8%BF%9B%E9%98%B6/"/>
    <updated>2021-02-16T17:39:43.000Z</updated>
    <content type="html"><![CDATA[<h2 id="问题"> 问题：</h2>
<h3 id="一、集合-容器"> 一、集合/容器</h3>
<h4 id="一-概述"> （一）概述</h4>
<ol>
<li>
<p>什么是集合</p>
</li>
<li>
<p>集合的特点</p>
</li>
<li>
<p>集合和数组的区别</p>
</li>
<li>
<p>使用集合框架的好处</p>
</li>
<li>
<p>常用的集合类有哪些？</p>
</li>
<li>
<p>List，Set，Map三者的区别？List、Set、Map 是否继承自 Collection 接口？List、Map、Set 三个接口存取元素时，各有什么特点？</p>
</li>
<li>
<p>哪些集合类是线程安全的？</p>
</li>
<li>
<p>Java集合的快速失败机制 “fail-fast”？</p>
</li>
<li>
<p>怎么确保一个集合不能被修改？</p>
</li>
</ol>
<h4 id="二-collection接口"> （二）Collection接口</h4>
<h5 id="_1-list接口"> （1）List接口</h5>
<ol>
<li>迭代器 Iterator 是什么？</li>
<li>Iterator 怎么使用？有什么特点？</li>
<li>如何边遍历边移除 Collection 中的元素？</li>
<li>Iterator 和 ListIterator 有什么区别？</li>
<li>遍历一个 List 有哪些不同的方式？每种方法的实现原理是什么？Java 中 List 遍历的最佳实践是什么？</li>
<li>说一下 ArrayList 的优缺点</li>
<li>如何实现数组和 List 之间的转换？</li>
<li>ArrayList 和 LinkedList 的区别是什么？</li>
<li>ArrayList 和 Vector 的区别是什么？</li>
<li>插入数据时，ArrayList、LinkedList、Vector谁速度较快？阐述 ArrayList、Vector、LinkedList 的存储性能和特性？</li>
<li>多线程场景下如何使用 ArrayList？</li>
<li>为什么 ArrayList 的 elementData 加上 transient 修饰？</li>
<li>List 和 Set 的区别</li>
</ol>
<h5 id="_2-set接口"> （2）Set接口</h5>
<ol>
<li>说一下 HashSet 的实现原理？</li>
<li>HashSet如何检查重复？HashSet是如何保证数据不可重复的？</li>
<li>HashSet与HashMap的区别</li>
</ol>
<h5 id="_3-queue接口"> （3）Queue接口</h5>
<ol>
<li>BlockingQueue是什么？</li>
<li>在 Queue 中 poll()和 remove()有什么区别？</li>
</ol>
<h4 id="三-map接口"> （三）Map接口</h4>
<ol>
<li>说一下 HashMap 的实现原理？</li>
<li>HashMap在JDK1.7和JDK1.8中有哪些不同？HashMap的底层实现</li>
<li>HashMap的put方法的具体流程？</li>
<li>HashMap的扩容操作是怎么实现的？</li>
<li>HashMap是怎么解决哈希冲突的？</li>
<li>能否使用任何类作为 Map 的 key？</li>
<li>为什么HashMap中String、Integer这样的包装类适合作为K？</li>
<li>如果使用Object作为HashMap的Key，应该怎么办呢？</li>
<li>HashMap为什么不直接使用hashCode()处理后的哈希值直接作为table的下标？</li>
<li>HashMap 的长度为什么是2的幂次方</li>
<li>HashMap 与 HashTable 有什么区别？</li>
<li>如何决定使用 HashMap 还是 TreeMap？</li>
<li>HashMap 和 ConcurrentHashMap 的区别</li>
<li>ConcurrentHashMap 和 Hashtable 的区别？</li>
</ol>
<h4 id="四-辅助工具类"> （四）辅助工具类</h4>
<ol>
<li>Array 和 ArrayList 有何区别？</li>
<li>如何实现 Array 和 List 之间的转换？</li>
<li>comparable 和 comparator的区别？</li>
<li>Collection 和 Collections 有什么区别？</li>
<li>TreeMap 和 TreeSet 在排序时如何比较元素？Collections 工具类中的 sort()方法如何比较元素？</li>
</ol>
<h3 id="二、泛型"> 二、泛型</h3>
<h3 id="三、异常"> 三、异常</h3>
<ol>
<li>Error 和 Exception 区别是什么？</li>
<li>运行时异常和一般异常(受检异常)区别是什么？</li>
<li>JVM 是如何处理异常的？</li>
<li>throw 和 throws 的区别是什么？</li>
<li>final、finally、finalize 有什么区别？</li>
<li>NoClassDefFoundError 和 ClassNotFoundException 区别？</li>
<li>try-catch-finally 中哪个部分可以省略？</li>
<li>try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？</li>
<li>类 ExampleA 继承 Exception，类 ExampleB 继承ExampleA。</li>
<li>常见的 RuntimeException 有哪些？</li>
<li>Java常见异常有哪些？</li>
</ol>
<h3 id="四、io流"> 四、IO流</h3>
<ol>
<li>Java 中 IO 流分为几种?</li>
<li>BIO,NIO,AIO 有什么区别?</li>
<li>Files的常用方法都有哪些？</li>
</ol>
<h3 id="五、注解"> 五、注解</h3>
<ol>
<li>谈谈你对Java中注解的理解</li>
<li>Java中的元注解有哪些？</li>
</ol>
<h3 id="六、反射"> 六、反射</h3>
<ol>
<li>什么是反射机制？</li>
<li>反射机制优缺点</li>
<li>反射机制的应用场景有哪些？</li>
<li>Java获取反射的三种方法</li>
</ol>
<h3 id="七、网络"> 七、网络</h3>
<ol>
<li>
<p>为什么TCP连接的时候是3次？2次不可以吗？</p>
</li>
<li>
<p>为什么TCP连接的时候是3次，关闭的时候却是4次？</p>
</li>
<li>
<p>为什么客户端发出第四次挥手的确认报文后要等2MSL的时间才能释放TCP连接？</p>
</li>
<li>
<p>如果已经建立了连接，但是客户端突然出现故障了怎么办？</p>
</li>
<li>
<p>什么是HTTP，HTTP 与 HTTPS 的区别</p>
</li>
<li>
<p>常用HTTP状态码</p>
</li>
<li>
<p>GET和POST区别</p>
</li>
<li>
<p>什么是对称加密与非对称加密</p>
</li>
<li>
<p>什么是HTTP2</p>
</li>
<li>
<p>Session、Cookie和Token的主要区别</p>
</li>
<li>
<p>Servlet是线程安全的吗</p>
</li>
<li>
<p>Servlet接口中有哪些方法及Servlet生命周期探秘</p>
</li>
<li>
<p>如果客户端禁止 cookie 能实现 session 还能用吗？</p>
</li>
</ol>
<h3 id="八、并发"> 八、并发</h3>
<h4 id="一-基础知识"> （一）基础知识</h4>
<h5 id="_1-并发编程的优缺点"> （1）并发编程的优缺点</h5>
<ol>
<li>为什么要使用并发编程（并发编程的优点）</li>
<li>并发编程有什么缺点</li>
<li>并发编程三要素是什么？在 Java 程序中怎么保证多线程的运行安全？</li>
<li>并行和并发有什么区别？</li>
<li>什么是多线程，多线程的优劣？</li>
</ol>
<h5 id="_2-线程和进程区别"> （2）线程和进程区别</h5>
<ol>
<li>什么是线程和进程?</li>
<li>进程与线程的区别</li>
<li>什么是上下文切换?</li>
<li>守护线程和用户线程有什么区别呢？</li>
<li>如何在 Windows 和 Linux 上查找哪个线程cpu利用率最高？</li>
<li>什么是线程死锁</li>
<li>形成死锁的四个必要条件是什么</li>
<li>如何避免线程死锁</li>
</ol>
<h5 id="_3-创建线程的四种方式"> （3）创建线程的四种方式</h5>
<ul>
<li>创建线程有哪几种方式？</li>
<li>说一下 runnable 和 callable 有什么区别？</li>
<li>线程的 run()和 start()有什么区别？</li>
<li>为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？</li>
<li>什么是 Callable 和 Future?</li>
<li>什么是 FutureTask？</li>
</ul>
<h5 id="_4-线程的状态和基本操作"> （4）线程的状态和基本操作</h5>
<ol>
<li>说说线程的生命周期及五种基本状态？</li>
<li>Java 中用到的线程调度算法是什么？</li>
<li>线程的调度策略？</li>
<li>什么是线程调度器(Thread Scheduler)和时间分片(Time Slicing )？</li>
<li>请说出与线程同步以及线程调度相关的方法。</li>
<li>sleep() 和 wait() 有什么区别？</li>
<li>你是如何调用 wait() 方法的？使用 if 块还是循环？为什么？</li>
<li>为什么线程通信的方法 wait(), notify()和 notifyAll()被定义在 Object 类里？</li>
<li>为什么 wait(), notify()和 notifyAll()必须在同步方法或者同步块中被调用？</li>
<li>Thread 类中的 yield 方法有什么作用？</li>
<li>为什么 Thread 类的 sleep()和 yield ()方法是静态的？</li>
<li>线程的 sleep()方法和 yield()方法有什么区别？</li>
<li>如何停止一个正在运行的线程？</li>
<li>Java 中 interrupted 和 isInterrupted 方法的区别？</li>
<li>什么是阻塞式方法？</li>
<li>Java 中你怎样唤醒一个阻塞的线程？</li>
<li>notify() 和 notifyAll() 有什么区别？</li>
<li>如何在两个线程间共享数据？</li>
<li>Java 如何实现多线程之间的通讯和协作？</li>
<li>同步方法和同步块，哪个是更好的选择？</li>
<li>什么是线程同步和线程互斥，有哪几种实现方式？</li>
<li>在监视器(Monitor)内部，是如何做线程同步的？程序应该做哪种级别的同步？</li>
<li>如果你提交任务时，线程池队列已满，这时会发生什么</li>
<li>什么叫线程安全？servlet 是线程安全吗?</li>
<li>在 Java 程序中怎么保证多线程的运行安全？</li>
<li>你对线程优先级的理解是什么？</li>
<li>线程类的构造方法、静态块是被哪个线程调用的</li>
<li>Java 中怎么获取一份线程 dump 文件？你如何在 Java 中获取线程堆栈？</li>
<li>一个线程运行时发生异常会怎样？</li>
<li>Java 线程数过多会造成什么异常？</li>
</ol>
<h4 id="二-并发理论"> （二）并发理论</h4>
<h5 id="_1-java内存模型"> （1）Java内存模型</h5>
<ol>
<li>Java中垃圾回收有什么目的？什么时候进行垃圾回收？</li>
<li>如果对象的引用被置为null，垃圾收集器是否会立即释放对象占用的内存？</li>
<li>finalize()方法什么时候被调用？析构函数(finalization)的目的是什么？</li>
</ol>
<h5 id="_2-重排序与数据依赖性"> （2）重排序与数据依赖性</h5>
<ol>
<li>为什么代码会重排序？</li>
</ol>
<h5 id="_3-as-if-serial规则和happens-before规则的区别"> （3）as-if-serial规则和happens-before规则的区别</h5>
<h4 id="三-并发关键字"> （三）并发关键字</h4>
<h5 id="_1-synchronized"> （1）synchronized</h5>
<ol>
<li>synchronized 的作用？</li>
<li>说说自己是怎么使用 synchronized 关键字，在项目中用到了吗</li>
<li>说一下 synchronized 底层实现原理？</li>
<li>什么是自旋</li>
<li>多线程中 synchronized 锁升级的原理是什么？</li>
<li>线程 B 怎么知道线程 A 修改了变量</li>
<li>当一个线程进入一个对象的 synchronized 方法 A 之后，其它线程是否可进入此对象的 synchronized 方法 B？</li>
<li>synchronized、volatile、CAS 比较</li>
<li>synchronized 和 Lock 有什么区别？</li>
<li>synchronized 和 ReentrantLock 区别是什么？</li>
</ol>
<h5 id="_2-volatile"> （2）volatile</h5>
<ol>
<li>volatile 关键字的作用</li>
<li>Java 中能创建 volatile 数组吗？</li>
<li>volatile 变量和 atomic 变量有什么不同？</li>
<li>volatile 能使得一个非原子操作变成原子操作吗？</li>
<li>volatile 修饰符的有过什么实践？</li>
<li>synchronized 和 volatile 的区别是什么？</li>
</ol>
<h5 id="_3-final"> （3）final</h5>
<ol>
<li>什么是不可变对象，它对写并发应用有什么帮助？</li>
</ol>
<h4 id="四-lock体系"> （四）Lock体系</h4>
<h5 id="_1-lock简介与初识aqs"> （1）Lock简介与初识AQS</h5>
<ol>
<li>Java Concurrency API 中的 Lock 接口(Lock interface)是什么？对比同步它有什么优势？</li>
<li>乐观锁和悲观锁的理解及如何实现，有哪些实现方式？</li>
<li>什么是 CAS</li>
<li>CAS 的会产生什么问题？</li>
<li>什么是死锁？</li>
<li>产生死锁的条件是什么？怎么防止死锁？</li>
<li>死锁与活锁的区别，死锁与饥饿的区别？</li>
<li>多线程锁的升级原理是什么？</li>
</ol>
<h5 id="_2-aqs-abstractqueuedsynchronizer-详解与源码分析"> （2）AQS(AbstractQueuedSynchronizer)详解与源码分析</h5>
<ol>
<li>AQS 介绍</li>
<li>AQS 原理分析</li>
</ol>
<h5 id="_3-reentrantlock-重入锁-实现原理与公平锁非公平锁区别"> （3）ReentrantLock(重入锁)实现原理与公平锁非公平锁区别</h5>
<ol>
<li>什么是可重入锁（ReentrantLock）？</li>
</ol>
<h5 id="_4-读写锁reentrantreadwritelock源码分析"> （4）读写锁ReentrantReadWriteLock源码分析</h5>
<ol>
<li>ReadWriteLock 是什么</li>
</ol>
<h5 id="_5-condition源码分析与等待通知机制"> （5）Condition源码分析与等待通知机制</h5>
<h5 id="_6-locksupport详解"> （6）LockSupport详解</h5>
<h4 id="五-并发容器"> （五）并发容器</h4>
<h5 id="_1-并发容器之concurrenthashmap详解-jdk1-8版本-与源码分析"> （1）并发容器之ConcurrentHashMap详解(JDK1.8版本)与源码分析</h5>
<ol>
<li>什么是ConcurrentHashMap？</li>
<li>Java 中 ConcurrentHashMap 的并发度是什么？</li>
<li>什么是并发容器的实现？</li>
<li>Java 中的同步集合与并发集合有什么区别？</li>
<li>SynchronizedMap 和 ConcurrentHashMap 有什么区别？</li>
</ol>
<h5 id="_2-并发容器之copyonwritearraylist详解"> （2）并发容器之CopyOnWriteArrayList详解</h5>
<ol>
<li>CopyOnWriteArrayList 是什么，可以用于什么应用场景？有哪些优缺点？</li>
</ol>
<h5 id="_3-并发容器之threadlocal详解"> （3）并发容器之ThreadLocal详解</h5>
<ol>
<li>ThreadLocal 是什么？有哪些使用场景？</li>
<li>什么是线程局部变量？</li>
</ol>
<h5 id="_4-threadlocal内存泄漏分析与解决方案"> （4）ThreadLocal内存泄漏分析与解决方案</h5>
<ol>
<li>ThreadLocal造成内存泄漏的原因？</li>
<li>ThreadLocal内存泄漏解决方案？</li>
</ol>
<h5 id="_5-并发容器之blockingqueue详解"> （5）并发容器之BlockingQueue详解</h5>
<ol>
<li>什么是阻塞队列？阻塞队列的实现原理是什么？如何使用阻塞队列来实现生产者-消费者模型？</li>
</ol>
<h5 id="_6-并发容器之concurrentlinkedqueue详解与源码分析"> （6）并发容器之ConcurrentLinkedQueue详解与源码分析</h5>
<h5 id="_7-并发容器之arrayblockingqueue与linkedblockingqueue详解"> （7）并发容器之ArrayBlockingQueue与LinkedBlockingQueue详解</h5>
<h4 id="六-线程池"> （六）线程池</h4>
<h5 id="_1-executors类创建四种常见线程池"> （1）Executors类创建四种常见线程池</h5>
<ol>
<li>什么是线程池？有哪几种创建方式？</li>
<li>线程池有什么优点？</li>
<li>线程池都有哪些状态？</li>
<li>什么是 Executor 框架？为什么使用 Executor 框架？</li>
<li>在 Java 中 Executor 和 Executors 的区别？</li>
<li>线程池中 submit() 和 execute() 方法有什么区别？</li>
<li>什么是线程组，为什么在 Java 中不推荐使用？</li>
</ol>
<h5 id="_2-线程池之threadpoolexecutor详解"> （2）线程池之ThreadPoolExecutor详解</h5>
<ol>
<li>Executors和ThreaPoolExecutor创建线程池的区别</li>
<li>你知道怎么创建线程池吗？</li>
<li>ThreadPoolExecutor构造函数重要参数分析</li>
<li>ThreadPoolExecutor饱和策略</li>
<li>一个简单的线程池Demo:<code>Runnable</code>+<code>ThreadPoolExecutor</code></li>
</ol>
<h5 id="_3-线程池之scheduledthreadpoolexecutor详解"> （3）线程池之ScheduledThreadPoolExecutor详解</h5>
<h5 id="_4-futuretask详解"> （4）FutureTask详解</h5>
<h4 id="七-原子操作类"> （七）原子操作类</h4>
<ol>
<li>什么是原子操作？在 Java Concurrency API 中有哪些原子类(atomic classes)？</li>
<li>说一下 atomic 的原理？</li>
</ol>
<h4 id="八-并发工具"> （八）并发工具</h4>
<h5 id="_1-countdownlatch与cyclicbarrier"> （1）CountDownLatch与CyclicBarrier</h5>
<ol>
<li>在 Java 中 CycliBarriar 和 CountdownLatch 有什么区别？</li>
</ol>
<h5 id="_2-semaphore与exchanger"> （2）Semaphore与Exchanger</h5>
<ol>
<li>Semaphore 有什么作用</li>
<li>什么是线程间交换数据的工具Exchanger</li>
<li>常用的并发工具类有哪些？</li>
</ol>
<h3 id="九、jvm"> 九、JVM</h3>
<p>（一）JVM 的主要组成部分及其作用</p>
<h2 id="参考答案"> 参考答案：</h2>
<h3 id="一、集合-容器-2"> 一、集合/容器</h3>
<h4 id="一-概述-2"> （一）概述</h4>
<blockquote>
<p>1、什么是集合</p>
</blockquote>
<p>集合框架：<strong>用于存储数据的容器</strong>。集合框架是为表示和操作集合而规定的一种统一的标准的体系结构。</p>
<p>任何集合框架都包含三大块内容：对外的接口、接口的实现和对集合运算的算法。</p>
<ul>
<li><strong>接口</strong>：表示集合的抽象数据类型。接口允许我们操作集合时不必关注具体实现，从而达到“多态”。在面向对象编程语言中，接口通常用来形成规范。</li>
<li><strong>实现</strong>：集合接口的具体实现，是重用性很高的数据结构。</li>
<li><strong>算法</strong>：在一个实现了某个集合框架中的接口的对象身上完成某种有用的计算的方法，例如查找、排序等。这些算法通常是多态的，因为相同的方法可以在同一个接口被多个类实现时有不同的表现。事实上，算法是可复用的函数。
它减少了程序设计的辛劳。</li>
</ul>
<p><strong>设计集合的目的</strong>：</p>
<ol>
<li>集合框架通过提供有用的数据结构和算法使你能集中注意力于你的程序的重要部分上，而不是为了让程序能正常运转而将注意力于低层设计上。</li>
<li>通过这些在无关API之间的简易的互用性，使你免除了为改编对象或转换代码以便联合这些API而去写大量的代码。 它提高了程序速度和质量。</li>
</ol>
<blockquote>
<p>2、集合的特点</p>
</blockquote>
<p>集合的特点主要有如下两点：</p>
<ul>
<li>
<p>对象封装数据，对象多了也需要存储。集合用于存储对象。</p>
</li>
<li>
<p>对象的个数确定可以使用数组，对象的个数不确定的可以用集合。因为集合是可变长度的。</p>
</li>
</ul>
<blockquote>
<p>3、集合和数组的区别</p>
</blockquote>
<ul>
<li>
<p>数组是固定长度的；集合可变长度的。</p>
</li>
<li>
<p>数组可以存储基本数据类型，也可以存储引用数据类型；集合只能存储引用数据类型。</p>
</li>
<li>
<p>数组存储的元素必须是同一个数据类型；集合存储的对象可以是不同数据类型。</p>
</li>
</ul>
<p><strong>数据结构</strong>：就是容器中存储数据的方式。</p>
<p>对于集合容器，有很多种。因为每一个容器的自身特点不同，其实原理在于每个容器的内部数据结构不同。</p>
<p>集合容器在不断向上抽取过程中，出现了集合体系。在使用一个体系的<strong>原则</strong>： <mark>参阅顶层内容。建立底层对象。</mark></p>
<blockquote>
<p>4、使用集合框架的好处</p>
</blockquote>
<ul>
<li>容量自增长；</li>
<li>提供了高性能的数据结构和算法，使编码更轻松，提高了程序速度和质量；</li>
<li>允许不同 API 之间的互操作，API之间可以来回传递集合；</li>
<li>可以方便地扩展或改写集合，提高代码复用性和可操作性。</li>
<li>通过使用JDK自带的集合类，可以降低代码维护和学习新API成本。</li>
</ul>
<blockquote>
<p>5、常用的集合类有哪些？</p>
</blockquote>
<p><strong>Map接口和Collection接口是所有集合框架的父接口</strong></p>
<p><strong>Collection接口</strong>的子接口包括：<strong>Set</strong>接口和List接口</p>
<ul>
<li>
<p>Set接口的实现类主要有：</p>
<p>1、HashSet</p>
<p>2、TreeSet</p>
<p>3、LinkedHashSet等</p>
</li>
<li>
<p>List接口的实现类主要有：</p>
<p>1、ArrayList</p>
<p>2、LinkedList</p>
<p>3、Stack</p>
<p>4、Vector等</p>
</li>
</ul>
<p><strong>Map接口</strong>的实现类主要有：</p>
<ol>
<li>HashMap</li>
<li>TreeMap</li>
<li>Hashtable</li>
<li>ConcurrentHashMap</li>
<li>Properties</li>
</ol>
<p><img src="./assets/08.jpg" alt=""></p>
<blockquote>
<p>6、List，Set，Map三者的区别？List、Set、Map 是否继承自 Collection 接口？List、Map、Set 三个接口存取元素时，各有什么特点？</p>
</blockquote>
<p>Java 容器分为 Collection 和 Map 两大类，Collection集合的子接口有Set、List、Queue三种子接口。</p>
<p>我们比较常用的是Set、List。Map接口不是collection的子接口。</p>
<p><strong>Collection集合</strong>主要有List和Set两大接口</p>
<ul>
<li>List：一个有序（元素存入集合的顺序和取出的顺序一致）容器，元素可以重复，可以插入多个null元素，元素都有索引。常用的实现类有 ArrayList、LinkedList 和 Vector。</li>
<li>Set：一个无序（存入和取出顺序有可能不一致）容器，不可以存储重复元素，只允许存入一个null元素，必须保证元素唯一性。Set 接口常用实现类是 HashSet、LinkedHashSet 以及 TreeSet。</li>
</ul>
<p><strong>Map集合</strong></p>
<ul>
<li>
<p>Map没有继承于Collection接口，从Map集合中检索元素时，只要给出键对象，就会返回对应的值对象。</p>
</li>
<li>
<p>Map是一个键值对集合，存储键、值和之间的映射。 Key无序，唯一；value 不要求有序，允许重复。</p>
</li>
<li>
<p>Map 的常用实现类：HashMap、TreeMap、HashTable、LinkedHashMap、ConcurrentHashMap</p>
</li>
</ul>
<blockquote>
<p>7、集合框架底层数据结构</p>
</blockquote>
<p><strong>List接口</strong>：</p>
<ul>
<li>Arraylist： Object数组</li>
<li>Vector： Object数组</li>
<li>LinkedList： 双向循环链表</li>
</ul>
<p><strong>Set接口</strong>：</p>
<ul>
<li>HashSet（无序，唯一）：基于 HashMap 实现的，底层采用 HashMap 来保存元素</li>
<li>LinkedHashSet： LinkedHashSet 继承与 HashSet，并且其内部是通过 LinkedHashMap 来实现的。有点类似于我们之前说的LinkedHashMap 其内部是基于 HashMap 实现一样，不过还是有一点点区别的。</li>
<li>TreeSet（有序，唯一）： 红黑树(自平衡的排序二叉树。)</li>
</ul>
<p><strong>Map接口</strong>：</p>
<ul>
<li>
<p>HashMap： JDK1.8之前HashMap由<strong>数组+链表</strong>组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）.JDK1.8以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间</p>
</li>
<li>
<p>LinkedHashMap：LinkedHashMap 继承自 HashMap，所以它的底层仍然是基于<strong>拉链式散列结构</strong>即由数组和链表或红黑树组成。另外，LinkedHashMap 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。</p>
</li>
<li>
<p>HashTable： HashTable除了实现同步外跟HashMap没什么区别，在实际应用中很少用到</p>
</li>
<li>
<p>TreeMap： 红黑树（自平衡的排序二叉树）</p>
</li>
</ul>
<blockquote>
<p>8、Java集合的快速失败机制 “fail-fast”？</p>
</blockquote>
<p>是java集合的一种<strong>错误检测机制</strong>，当多个线程对集合进行结构上的改变的操作时，有可能会产生 fail-fast 机制。</p>
<ul>
<li>例如：假设存在两个线程（线程1、线程2），线程1通过Iterator在遍历集合A中的元素，在某个时候线程2修改了集合A的结构（是结构上面的修改，而不是简单的修改集合元素的内容），那么这个时候程序就会抛出 ConcurrentModificationException 异常，从而产生fail-fast机制。</li>
<li>原因：迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个 <strong>modCount</strong> 变量。集合在被遍历期间如果内容发生变化，就会改变modCount的值。每当迭代器使用hashNext()/next()遍历下一个元素之前，都会检测modCount变量是否为expectedmodCount值，是的话就返回遍历；否则抛出异常，终止遍历。</li>
</ul>
<p><strong>解决办法</strong>：</p>
<ol>
<li>在遍历过程中，所有涉及到改变modCount值得地方全部加上synchronized。</li>
<li>使用CopyOnWriteArrayList来替换ArrayList</li>
</ol>
<blockquote>
<p>9、怎么确保一个集合不能被修改？</p>
</blockquote>
<p>可以使用 Collections. unmodifiableCollection(Collection c) 方法来创建一个只读集合，这样改变集合的任何操作都会抛出 Java. lang. UnsupportedOperationException 异常。</p>
<p>示例代码如下：</p>
<div><pre><code><span>List</span><span><span>&lt;</span><span>String</span><span>></span></span> list <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
list<span>.</span> <span>add</span><span>(</span><span>"x"</span><span>)</span><span>;</span>
<span>Collection</span><span><span>&lt;</span><span>String</span><span>></span></span> clist <span>=</span> <span>Collections</span><span>.</span> <span>unmodifiableCollection</span><span>(</span>list<span>)</span><span>;</span>
clist<span>.</span> <span>add</span><span>(</span><span>"y"</span><span>)</span><span>;</span> <span>// 运行时此行报错</span>
<span>System</span><span>.</span> out<span>.</span> <span>println</span><span>(</span>list<span>.</span> <span>size</span><span>(</span><span>)</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h4 id="二-collection接口-2"> （二）Collection接口</h4>
<h5 id="_1-list接口-2"> （1）List接口</h5>
<blockquote>
<p>1、迭代器 Iterator 是什么？</p>
</blockquote>
<ul>
<li>Iterator 接口提供遍历任何 Collection 接口的方法。</li>
<li>我们可以从一个 Collection 中使用迭代器方法来获取迭代器实例。</li>
<li>迭代器取代了 Java 集合框架中的 Enumeration，迭代器允许调用者在迭代过程中移除元素。</li>
</ul>
<blockquote>
<p>2、Iterator 怎么使用？有什么特点？</p>
</blockquote>
<p>Iterator 使用代码如下：</p>
<div><pre><code><span>List</span><span><span>&lt;</span><span>String</span><span>></span></span> list <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
<span>Iterator</span><span><span>&lt;</span><span>String</span><span>></span></span> it <span>=</span> list<span>.</span> <span>iterator</span><span>(</span><span>)</span><span>;</span>
<span>while</span><span>(</span>it<span>.</span> <span>hasNext</span><span>(</span><span>)</span><span>)</span><span>{</span>
  <span>String</span> obj <span>=</span> it<span>.</span> <span>next</span><span>(</span><span>)</span><span>;</span>
  <span>System</span><span>.</span> out<span>.</span> <span>println</span><span>(</span>obj<span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>Iterator 的特点是只能单向遍历，但是更加安全，因为它可以确保，在当前遍历的集合元素被更改的时候，就会抛出</p>
<p>ConcurrentModificationException 异常。</p>
<blockquote>
<p>3、如何边遍历边移除 Collection 中的元素？</p>
</blockquote>
<p>边遍历边修改 Collection 的唯一正确方式是使用 Iterator.remove() 方法，如下：</p>
<div><pre><code><span>Iterator</span><span><span>&lt;</span><span>Integer</span><span>></span></span> it <span>=</span> list<span>.</span><span>iterator</span><span>(</span><span>)</span><span>;</span>
<span>while</span><span>(</span>it<span>.</span><span>hasNext</span><span>(</span><span>)</span><span>)</span><span>{</span>
   <span>*</span><span>// do something*</span>
   it<span>.</span><span>remove</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>一种最常见的<strong>错误</strong>代码如下：</p>
<div><pre><code><span>for</span><span>(</span><span>Integer</span> i <span>:</span> list<span>)</span><span>{</span>
   list<span>.</span><span>remove</span><span>(</span>i<span>)</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>运行以上错误代码会报 <strong>ConcurrentModificationException 异常</strong>。</p>
<p>这是因为当使用 foreach(for(Integer i : list)) 语句时，会自动生成一个iterator 来遍历该 list，但同时该 list 正在被 Iterator.remove() 修</p>
<p>改。Java 一般不允许一个线程在遍历 Collection 时另一个线程修改它。</p>
<blockquote>
<p>4、Iterator 和 ListIterator 有什么区别？</p>
</blockquote>
<ul>
<li>Iterator 可以遍历 Set 和 List 集合，而 ListIterator 只能遍历 List。</li>
<li>Iterator 只能单向遍历，而 ListIterator 可以双向遍历（向前/后遍历）。</li>
<li>ListIterator 实现 Iterator 接口，然后添加了一些额外的功能，比如添加一个元素、替换一个元素、获取前面或后面元素的索引位置。</li>
</ul>
<blockquote>
<p>5、遍历一个 List 有哪些不同的方式？每种方法的实现原理是什么？Java 中 List 遍历的最佳实践是什么？</p>
</blockquote>
<p>遍历方式有以下几种：</p>
<ol>
<li>for 循环遍历，基于计数器。在集合外部维护一个计数器，然后依次读取每一个位置的元素，当读取到最后一个元素后停止。</li>
<li>迭代器遍历，Iterator。Iterator 是面向对象的一个设计模式，目的是屏蔽不同数据集合的特点，统一遍历集合的接口。Java 在 Collections 中支持了 Iterator 模式。</li>
<li>foreach 循环遍历。foreach 内部也是采用了 Iterator 的方式实现，使用时不需要显式声明 Iterator 或计数器。优点是代码简洁，不易出错；缺点是只能做简单的遍历，不能在遍历过程中操作数据集合，例如删除、替换。</li>
</ol>
<p>最佳实践：Java Collections 框架中提供了一个 RandomAccess 接口，用来标记 List 实现是否支持 Random Access。</p>
<ul>
<li>如果一个数据集合实现了该接口，就意味着它支持 Random Access，按位置读取元素的平均时间复杂度为 O(1)，如ArrayList。</li>
<li>如果没有实现该接口，表示不支持 Random Access，如LinkedList。</li>
</ul>
<p>推荐的做法就是，支持 Random Access 的列表可用 for 循环遍历，否则建议用 Iterator 或 foreach 遍历。</p>
<blockquote>
<p>6、说一下 ArrayList 的优缺点</p>
</blockquote>
<p>ArrayList的优点如下：</p>
<ul>
<li>ArrayList 底层以数组实现，是一种随机访问模式。ArrayList 实现了 RandomAccess 接口，因此查找的时候非常快。</li>
<li>ArrayList 在顺序添加一个元素的时候非常方便。</li>
</ul>
<p>ArrayList 的缺点如下：</p>
<ul>
<li>删除元素的时候，需要做一次元素复制操作。如果要复制的元素很多，那么就会比较耗费性能。</li>
<li>插入元素的时候，也需要做一次元素复制操作，缺点同上。</li>
</ul>
<p>ArrayList 比较适合顺序添加、随机访问的场景。</p>
<blockquote>
<p>7、如何实现数组和 List 之间的转换？</p>
</blockquote>
<ul>
<li>数组转 List：使用 Arrays. asList(array) 进行转换。</li>
<li>List 转数组：使用 List 自带的 toArray() 方法。</li>
</ul>
<p>代码示例：</p>
<div><pre><code><span>// list to array</span>
<span>List</span><span><span>&lt;</span><span>String</span><span>></span></span> list <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>String</span><span>></span></span><span>(</span><span>)</span><span>;</span>
list<span>.</span><span>add</span><span>(</span><span>"123"</span><span>)</span><span>;</span>
list<span>.</span><span>add</span><span>(</span><span>"456"</span><span>)</span><span>;</span>
list<span>.</span><span>toArray</span><span>(</span><span>)</span><span>;</span>

<span>// array to list</span>
<span>String</span><span>[</span><span>]</span> array <span>=</span> <span>new</span> <span>String</span><span>[</span><span>]</span><span>{</span><span>"123"</span><span>,</span><span>"456"</span><span>}</span><span>;</span>
<span>Arrays</span><span>.</span><span>asList</span><span>(</span>array<span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><blockquote>
<p>8、ArrayList 和 LinkedList 的区别是什么？</p>
</blockquote>
<ul>
<li>数据结构实现：ArrayList 是动态数组的数据结构实现，而 LinkedList 是双向链表的数据结构实现。</li>
<li>随机访问效率：ArrayList 比 LinkedList 在随机访问的时候效率要高，因为 LinkedList 是线性的数据存储方式，所以需要移动指针从前往后依次查找。</li>
<li>增加和删除效率：在非首尾的增加和删除操作，LinkedList 要比 ArrayList 效率要高，因为 ArrayList 增删操作要影响数组内的其他数据的下标。</li>
<li>内存空间占用：LinkedList 比 ArrayList 更占内存，因为 LinkedList 的节点除了存储数据，还存储了两个引用，一个指向前一个元素，一个指向后一个元素。</li>
<li>线程安全：ArrayList 和 LinkedList 都是不同步的，也就是不保证线程安全；</li>
</ul>
<p>综合来说，在需要频繁读取集合中的元素时，更推荐使用 ArrayList，而在插入和删除操作较多时，更推荐使用 LinkedList。</p>
<p>补充：数据结构基础之双向链表</p>
<p>双向链表也叫双链表，是链表的一种，它的每个数据结点中都有两个指针，分别指向直接后继和直接前驱。所以，从双向链表中的任意一个结点开始，都可以很方便地访问它的前驱结点和后继结点。</p>
<blockquote>
<p>9、ArrayList 和 Vector 的区别是什么？</p>
</blockquote>
<p>这两个类都实现了 List 接口（List 接口继承了 Collection 接口），他们都是有序集合</p>
<ul>
<li>线程安全：Vector 使用了 Synchronized 来实现线程同步，是线程安全的，而 ArrayList 是非线程安全的。</li>
<li>性能：ArrayList 在性能方面要优于 Vector。</li>
<li>扩容：ArrayList 和 Vector 都会根据实际的需要动态的调整容量，只不过在 Vector 扩容每次会增加 1 倍，而 ArrayList 只会增加 50%。</li>
</ul>
<p>Vector类的所有方法都是同步的。可以由两个线程安全地访问一个Vector对象、但是一个线程访问Vector的话代码要在同步操作上耗费大量的时间。</p>
<p>Arraylist不是同步的，所以在不需要保证线程安全时时建议使用Arraylist。</p>
<blockquote>
<p>10、插入数据时，ArrayList、LinkedList、Vector谁速度较快？阐述 ArrayList、Vector、LinkedList 的存储性能和特性？</p>
</blockquote>
<ul>
<li>ArrayList、Vector 底层的实现都是使用数组方式存储数据。数组元素数大于实际存储的数据以便增加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入数据慢。</li>
<li>Vector 中的方法由于加了 synchronized 修饰，因此 <strong>Vector</strong> <strong>是线程安全容器，但性能上较ArrayList差</strong>。</li>
<li>LinkedList 使用双向链表实现存储，按序号索引数据需要进行前向或后向遍历，但插入数据时只需要记录当前项的前后项即可，所以 <strong>LinkedList</strong> <strong>插入速度较快</strong>。</li>
</ul>
<blockquote>
<p>11、多线程场景下如何使用 ArrayList？</p>
</blockquote>
<p>ArrayList 不是线程安全的，如果遇到多线程场景，可以通过 Collections 的 synchronizedList 方法将其转换成线程安全的容器后再使</p>
<p>用。例如像下面这样：</p>
<div><pre><code><span>List</span><span><span>&lt;</span><span>String</span><span>></span></span> synchronizedList <span>=</span> <span>Collections</span><span>.</span><span>synchronizedList</span><span>(</span>list<span>)</span><span>;</span>
synchronizedList<span>.</span><span>add</span><span>(</span><span>"aaa"</span><span>)</span><span>;</span>
synchronizedList<span>.</span><span>add</span><span>(</span><span>"bbb"</span><span>)</span><span>;</span>

<span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> synchronizedList<span>.</span><span>size</span><span>(</span><span>)</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>synchronizedList<span>.</span><span>get</span><span>(</span>i<span>)</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><blockquote>
<p>12、为什么 ArrayList 的 elementData 加上 transient 修饰？</p>
</blockquote>
<p>ArrayList 中的数组定义如下：</p>
<div><pre><code><span>private</span> <span>transient</span> <span>Object</span><span>[</span><span>]</span> elementData<span>;</span>

</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>再看一下 ArrayList 的定义：</p>
<div><pre><code><span>public</span> <span>class</span> <span>ArrayList</span><span><span>&lt;</span><span>E</span><span>></span></span> <span>extends</span> <span>AbstractList</span><span><span>&lt;</span><span>E</span><span>></span></span>
     <span>implements</span> <span>List</span><span><span>&lt;</span><span>E</span><span>></span></span><span>,</span> <span>RandomAccess</span><span>,</span> <span>Cloneable</span><span>,</span> <span><span>java<span>.</span>io<span>.</span></span>Serializable</span>
    
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>可以看到 ArrayList 实现了 Serializable 接口，这意味着 ArrayList 支持序列化。transient 的作用是说不希望 elementData 数组被序列化，重写了 writeObject 实现：</p>
<div><pre><code><span>private</span> <span>void</span> <span>writeObject</span><span>(</span><span><span>java<span>.</span>io<span>.</span></span>ObjectOutputStream</span> s<span>)</span> <span>throws</span> <span><span>java<span>.</span>io<span>.</span></span>IOException</span><span>{</span>
    <span>*</span><span>// Write out element count, and any hidden stuff*</span>
        <span>int</span> expectedModCount <span>=</span> modCount<span>;</span>
    s<span>.</span><span>defaultWriteObject</span><span>(</span><span>)</span><span>;</span>
    <span>*</span><span>// Write out array length*</span>
        s<span>.</span><span>writeInt</span><span>(</span>elementData<span>.</span>length<span>)</span><span>;</span>
    <span>*</span><span>// Write out all elements in the proper order.*</span>
        <span>for</span> <span>(</span><span>int</span> i<span>=</span><span>0</span><span>;</span> i<span>&lt;</span>size<span>;</span> i<span>++</span><span>)</span>
            s<span>.</span><span>writeObject</span><span>(</span>elementData<span>[</span>i<span>]</span><span>)</span><span>;</span>
    <span>if</span> <span>(</span>modCount <span>!=</span> expectedModCount<span>)</span> <span>{</span>
        <span>throw</span> <span>new</span> <span>ConcurrentModificationException</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>每次序列化时，先调用 defaultWriteObject() 方法序列化 ArrayList 中的非 transient 元素，然后遍历 elementData，只序列化已存入的元素，这样既加快了序列化的速度，又减小了序列化之后的文件大小。</p>
<blockquote>
<p>13、List 和 Set 的区别</p>
</blockquote>
<ul>
<li>List , Set 都是继承自Collection 接口</li>
<li>List 特点：一个有序（元素存入集合的顺序和取出的顺序一致）容器，元素可以重复，可以插入多个null元素，元素都有索引。常用的实现类有 ArrayList、LinkedList 和 Vector。</li>
<li>Set 特点：一个无序（存入和取出顺序有可能不一致）容器，不可以存储重复元素，只允许存入一个null元素，必须保证元素唯一性。Set 接口常用实现类是 HashSet、LinkedHashSet 以及 TreeSet。</li>
<li>另外 List 支持for循环，也就是通过下标来遍历，也可以用迭代器，但是set只能用迭代，因为他无序，无法用下标来取得想要的值。</li>
<li>Set：检索元素效率低下，删除和插入效率高，插入和删除不会引起元素位置改变。List：和数组类似，List可以动态增长，查找元素效率高，插入删除元素效率低，因为会引起其他元素位置改变</li>
</ul>
<h5 id="_2-set接口-2"> （2）Set接口</h5>
<blockquote>
<p>1、说一下 HashSet 的实现原理？</p>
</blockquote>
<p>HashSet 是基于 HashMap 实现的，HashSet的值存放于HashMap的key上，HashMap的value统一为PRESENT，因此 HashSet 的实</p>
<p>现比较简单，相关 HashSet 的操作，基本上都是直接调用底层 HashMap 的相关方法来完成，HashSet 不允许重复的值。</p>
<blockquote>
<p>2、HashSet如何检查重复？HashSet是如何保证数据不可重复的？</p>
</blockquote>
<ul>
<li>向HashSet 中add ()元素时，判断元素是否存在的依据，不仅要比较hash值，同时还要结合equles 方法比较。HashSet 中的add ()方法会使用HashMap 的put()方法。</li>
<li>HashMap 的 key 是唯一的，由源码可以看出 HashSet 添加进去的值就是作为HashMap 的key，并且在HashMap中如果K/V相同时，会用新的V覆盖掉旧的V，然后返回旧的V。所以不会重复（ HashMap 比较key是否相等是先比较hashcode 再比较equals ）。</li>
</ul>
<p>以下是HashSet 部分源码：</p>
<div><pre><code><span>private</span> <span>static</span> <span>final</span> <span>Object</span> PRESENT <span>=</span> <span>new</span> <span>Object</span><span>(</span><span>)</span><span>;</span>
<span>private</span> <span>transient</span> <span>HashMap</span><span><span>&lt;</span><span>E</span><span>,</span><span>Object</span><span>></span></span> map<span>;</span>

<span>public</span> <span>HashSet</span><span>(</span><span>)</span> <span>{</span>
    map <span>=</span> <span>new</span> <span>HashMap</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
<span>}</span>

<span>public</span> <span>boolean</span> <span>add</span><span>(</span><span>E</span> e<span>)</span> <span>{</span>
    <span>// 调用HashMap的put方法,PRESENT是一个至始至终都相同的虚值</span>
	<span>return</span> map<span>.</span><span>put</span><span>(</span>e<span>,</span> PRESENT<span>)</span><span>==</span><span>null</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p><strong>hashCode（）与equals（）的相关规定</strong>：</p>
<ol>
<li>如果两个对象相等，则hashcode一定也是相同的</li>
<li>两个对象相等,对两个equals方法返回true</li>
<li>两个对象有相同的hashcode值，它们也不一定是相等的</li>
<li>综上，equals方法被覆盖过，则hashCode方法也必须被覆盖</li>
<li>hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写hashCode()，则该class的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）。</li>
</ol>
<p><strong>==与equals的区别</strong></p>
<ol>
<li>==是判断两个变量或实例是不是指向同一个内存空间 equals是判断两个变量或实例所指向的内存空间的值是不是相同</li>
<li>==是指对内存地址进行比较 equals()是对字符串的内容进行比较</li>
<li>==指引用是否相同 equals()指的是值是否相同</li>
</ol>
<blockquote>
<p>3、HashSet与HashMap的区别</p>
</blockquote>
<table>
<thead>
<tr>
<th>HashMap</th>
<th>HashSet</th>
</tr>
</thead>
<tbody>
<tr>
<td>实现了Map接口</td>
<td>实现Set接口</td>
</tr>
<tr>
<td>存储键值对</td>
<td>仅存储对象</td>
</tr>
<tr>
<td>调用put（）向map中添加元素</td>
<td>调用add（）方法向Set中添加元素</td>
</tr>
<tr>
<td>HashMap使用键（Key）计算Hashcode</td>
<td>HashSet使用成员对象来计算hashcode值，对于两个对象来说hashcode可能相同，所以equals()方法用来判断对象的相等性，如果两个对象不同的话，那么返回false</td>
</tr>
<tr>
<td>HashMap相对于HashSet较快，因为它是使用唯一的键获取对象</td>
<td>HashSet较HashMap来说比较慢</td>
</tr>
</tbody>
</table>
<h5 id="_3-queue"> （3）Queue</h5>
<blockquote>
<p>1、BlockingQueue是什么？</p>
</blockquote>
<p>Java.util.concurrent.BlockingQueue是一个队列，在进行检索或移除一个元素的时候，它会等待队列变为非空；当在添加一个元素时，它会等待队列中的可用空间。</p>
<p>BlockingQueue接口是Java集合框架的一部分，主要用于<strong>实现生产者-消费者模式</strong>。我们不需要担心等待生产者有可用的空间，或消费者有可用的对象，因为它都在BlockingQueue的实现类中被处理了。Java提供了几种BlockingQueue的实现，比如ArrayBlockingQueue、LinkedBlockingQueue、PriorityBlockingQueue,、SynchronousQueue等。</p>
<blockquote>
<p>2、在 Queue 中 poll()和 remove()有什么区别？</p>
</blockquote>
<ul>
<li>相同点：都是返回第一个元素，并在队列中删除返回的对象。</li>
<li>不同点：如果没有元素 poll()会返回 null，而 remove()会直接抛出 NoSuchElementException 异常。</li>
</ul>
<p>代码示例：</p>
<div><pre><code><span>Queue</span><span><span>&lt;</span><span>String</span><span>></span></span> queue <span>=</span> <span>new</span> <span>LinkedList</span><span><span>&lt;</span><span>String</span><span>></span></span><span>(</span><span>)</span><span>;</span>
queue<span>.</span> <span>offer</span><span>(</span><span>"string"</span><span>)</span><span>;</span> <span>// add</span>
<span>System</span><span>.</span> out<span>.</span> <span>println</span><span>(</span>queue<span>.</span> <span>poll</span><span>(</span><span>)</span><span>)</span><span>;</span>
<span>System</span><span>.</span> out<span>.</span> <span>println</span><span>(</span>queue<span>.</span> <span>remove</span><span>(</span><span>)</span><span>)</span><span>;</span>
<span>System</span><span>.</span> out<span>.</span> <span>println</span><span>(</span>queue<span>.</span> <span>size</span><span>(</span><span>)</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h4 id="三-map接口-2"> （三）Map接口</h4>
<blockquote>
<p>1、说一下 HashMap 的实现原理？</p>
</blockquote>
<p>HashMap概述： HashMap是基于哈希表的Map接口的非同步实现。此实现提供所有可选的映射操作，并允许使用null值和null键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。</p>
<p>HashMap的数据结构： 在Java编程语言中，最基本的结构就是两种，一个是数组，另外一个是模拟指针（引用），所有的数据结构都可以用这两个基本结构来构造的，HashMap也不例外。HashMap实际上是一个“链表散列”的数据结构，即数组和链表的结合体。</p>
<p>HashMap 基于 Hash 算法实现的</p>
<ol>
<li>
<p>当我们往HashMap中put元素时，利用key的hashCode重新hash，计算出当前对象的元素在数组中的下标</p>
</li>
<li>
<p>存储时，如果出现hash值相同的key，此时有两种情况。</p>
<p>(1)如果key相同，则覆盖原始值；</p>
<p>(2)如果key不同（出现冲突），则将当前的key-value放入链表中</p>
</li>
<li>
<p>获取时，直接找到hash值对应的下标，在进一步判断key是否相同，从而找到对应值。</p>
</li>
<li>
<p>理解了以上过程就不难明白HashMap是如何解决hash冲突的问题，核心就是使用了数组的存储方式，然后将冲突的key的对象放入链表中，一旦发现冲突就在链表中做进一步的对比。</p>
</li>
</ol>
<p>需要注意<strong>Jdk 1.8中对HashMap的实现做了优化</strong>： <mark>当链表中的节点数据超过八个之后，该链表会转为红黑树来提高查询效率，从原来的O(n)到O(logn)</mark></p>
<blockquote>
<p>2、HashMap在JDK1.7和JDK1.8中有哪些不同？HashMap的底层实现</p>
</blockquote>
<p>在Java中，保存数据有两种比较简单的数据结构：数组和链表。数组的特点是：寻址容易，插入和删除困难；链表的特点是：寻址困难，但插入和删除容易；所以我们将数组和链表结合在一起，发挥两者各自的优势，使用一种叫做<strong>拉链法</strong>的方式可以解决哈希冲突。</p>
<p><strong>（1）JDK1.8之前</strong></p>
<p>JDK1.8之前采用的是拉链法。<strong>拉链法</strong>：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。</p>
<p><img src="./assets/09.png" alt="jdk1.7中HashMap数据结构"></p>
<p><strong>（2）JDK1.8之后</strong></p>
<p>相比于之前的版本，jdk1.8在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。</p>
<p><img src="./assets/10.png" alt="jdk1.8中HashMap数据结构"></p>
<p><strong>（3）JDK1.7 VS JDK1.8</strong></p>
<p>JDK1.8主要解决或优化了一下问题：</p>
<ol>
<li>resize 扩容优化</li>
<li>引入了红黑树，目的是避免单条链表过长而影响查询效率，<a href="">红黑树算法</a></li>
<li>解决了多线程死循环问题，但仍是非线程安全的，多线程时可能会造成数据丢失问题。</li>
</ol>
<table>
<thead>
<tr>
<th>不同</th>
<th>JDK 1.7</th>
<th>JDK 1.8</th>
</tr>
</thead>
<tbody>
<tr>
<td>存储结构</td>
<td>数组 + 链表</td>
<td>数组 + 链表 + 红黑树</td>
</tr>
<tr>
<td>初始化方式</td>
<td>单独函数：<code>inflateTable()</code></td>
<td>直接集成到了扩容函数<code>resize()</code>中</td>
</tr>
<tr>
<td>hash值计算方式</td>
<td>扰动处理 = 9次扰动 = 4次位运算 + 5次异或运算</td>
<td>扰动处理 = 2次扰动 = 1次位运算 + 1次异或运算</td>
</tr>
<tr>
<td>存放数据的规则</td>
<td>无冲突时，存放数组；冲突时，存放链表</td>
<td>无冲突时，存放数组；冲突 &amp; 链表长度 &lt; 8：存放单链表；冲突 &amp; 链表长度 &gt; 8：树化并存放红黑树</td>
</tr>
<tr>
<td>插入数据方式</td>
<td>头插法（先讲原位置的数据移到后1位，再插入数据到该位置）</td>
<td>尾插法（直接插入到链表尾部/红黑树）</td>
</tr>
<tr>
<td>扩容后存储位置的计算方式</td>
<td>全部按照原来方法进行计算（即hashCode -&gt;&gt; 扰动函数 -&gt;&gt; (h&amp;length-1)）</td>
<td>按照扩容后的规律计算（即扩容后的位置=原位置 or 原位置 + 旧容量）</td>
</tr>
</tbody>
</table>
<blockquote>
<p>3、HashMap的put方法的具体流程？</p>
</blockquote>
<p>当我们put的时候，首先计算 <code>key</code>的<code>hash</code>值，这里调用了 <code>hash</code>方法，<code>hash</code>方法实际是让<code>key.hashCode()</code>与<code>key.hashCode()&gt;&gt;&gt;16</code>进行异或操作，高16bit补0，一个数和0异或不变，所以 hash 函数大概的作用就是：<strong>高16bit不变，低16bit和高16bit做了一个异或，目的是减少碰撞</strong>。按照函数注释，因为bucket数组大小是2的幂，计算下标<code>index = (table.length - 1) &amp; hash</code>，如果不做 hash 处理，相当于散列生效的只有几个低 bit 位，为了减少散列的碰撞，设计者综合考虑了速度、作用、质量之后，使用高16bit和低16bit异或来简单处理减少碰撞，而且JDK8中用了复杂度 O（logn）的树结构来提升碰撞下的性能。</p>
<p>putVal方法执行流程图</p>
<p><img src="./assets/11.png" alt="putVal方法执行流程图"></p>
<div><pre><code><span>public</span> <span>V</span> <span>put</span><span>(</span><span>K</span> key<span>,</span> <span>V</span> value<span>)</span> <span>{</span>
    <span>return</span> <span>putVal</span><span>(</span><span>hash</span><span>(</span>key<span>)</span><span>,</span> key<span>,</span> value<span>,</span> <span>false</span><span>,</span> <span>true</span><span>)</span><span>;</span>
<span>}</span>

<span>static</span> <span>final</span> <span>int</span> <span>hash</span><span>(</span><span>Object</span> key<span>)</span> <span>{</span>
    <span>int</span> h<span>;</span>
    <span>return</span> <span>(</span>key <span>==</span> <span>null</span><span>)</span> <span>?</span> <span>0</span> <span>:</span> <span>(</span>h <span>=</span> key<span>.</span><span>hashCode</span><span>(</span><span>)</span><span>)</span> <span>^</span> <span>(</span>h <span>>>></span> <span>16</span><span>)</span><span>;</span>
<span>}</span>

<span>//实现Map.put和相关方法</span>
<span>final</span> <span>V</span> <span>putVal</span><span>(</span><span>int</span> hash<span>,</span> <span>K</span> key<span>,</span> <span>V</span> value<span>,</span> <span>boolean</span> onlyIfAbsent<span>,</span>
                   <span>boolean</span> evict<span>)</span> <span>{</span>
    <span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span><span>[</span><span>]</span> tab<span>;</span> <span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> p<span>;</span> <span>int</span> n<span>,</span> i<span>;</span>
    <span>// 步骤①：tab为空则创建 </span>
    <span>// table未初始化或者长度为0，进行扩容</span>
    <span>if</span> <span>(</span><span>(</span>tab <span>=</span> table<span>)</span> <span>==</span> <span>null</span> <span>||</span> <span>(</span>n <span>=</span> tab<span>.</span>length<span>)</span> <span>==</span> <span>0</span><span>)</span>
        n <span>=</span> <span>(</span>tab <span>=</span> <span>resize</span><span>(</span><span>)</span><span>)</span><span>.</span>length<span>;</span>
    <span>// 步骤②：计算index，并对null做处理  </span>
    <span>// (n - 1) &amp; hash 确定元素存放在哪个桶中(相当于取余)，桶为空，新生成结点放入桶中(此时，这个结点是放在数组中)</span>
    <span>if</span> <span>(</span><span>(</span>p <span>=</span> tab<span>[</span>i <span>=</span> <span>(</span>n <span>-</span> <span>1</span><span>)</span> <span>&amp;</span> hash<span>]</span><span>)</span> <span>==</span> <span>null</span><span>)</span>
        tab<span>[</span>i<span>]</span> <span>=</span> <span>newNode</span><span>(</span>hash<span>,</span> key<span>,</span> value<span>,</span> <span>null</span><span>)</span><span>;</span>
    <span>// 桶中已经存在元素</span>
    <span>else</span> <span>{</span>
        <span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> e<span>;</span> <span>K</span> k<span>;</span>
        <span>// 步骤③：节点key存在，直接覆盖value </span>
        <span>// 比较桶中第一个元素(数组中的结点)的hash值相等，key相等</span>
        <span>if</span> <span>(</span>p<span>.</span>hash <span>==</span> hash <span>&amp;&amp;</span>
            <span>(</span><span>(</span>k <span>=</span> p<span>.</span>key<span>)</span> <span>==</span> key <span>||</span> <span>(</span>key <span>!=</span> <span>null</span> <span>&amp;&amp;</span> key<span>.</span><span>equals</span><span>(</span>k<span>)</span><span>)</span><span>)</span><span>)</span>
                <span>// 将第一个元素赋值给e，用e来记录</span>
                e <span>=</span> p<span>;</span>
        <span>// 步骤④：判断该链为红黑树 </span>
        <span>// hash值不相等，即key不相等；为红黑树结点</span>
        <span>// 如果当前元素类型为TreeNode，表示为红黑树，putTreeVal返回待存放的node, e可能为null</span>
        <span>else</span> <span>if</span> <span>(</span>p <span>instanceof</span> <span>TreeNode</span><span>)</span>
            <span>// 放入树中</span>
            e <span>=</span> <span>(</span><span>(</span><span>TreeNode</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span><span>)</span>p<span>)</span><span>.</span><span>putTreeVal</span><span>(</span><span>this</span><span>,</span> tab<span>,</span> hash<span>,</span> key<span>,</span> value<span>)</span><span>;</span>
        <span>// 步骤⑤：该链为链表 </span>
        <span>// 为链表结点</span>
        <span>else</span> <span>{</span>
            <span>// 在链表最末插入结点</span>
            <span>for</span> <span>(</span><span>int</span> binCount <span>=</span> <span>0</span><span>;</span> <span>;</span> <span>++</span>binCount<span>)</span> <span>{</span>
                <span>// 到达链表的尾部</span>
                
                <span>//判断该链表尾部指针是不是空的</span>
                <span>if</span> <span>(</span><span>(</span>e <span>=</span> p<span>.</span>next<span>)</span> <span>==</span> <span>null</span><span>)</span> <span>{</span>
                    <span>// 在尾部插入新结点</span>
                    p<span>.</span>next <span>=</span> <span>newNode</span><span>(</span>hash<span>,</span> key<span>,</span> value<span>,</span> <span>null</span><span>)</span><span>;</span>
                    <span>//判断链表的长度是否达到转化红黑树的临界值，临界值为8</span>
                    <span>if</span> <span>(</span>binCount <span>>=</span> TREEIFY_THRESHOLD <span>-</span> <span>1</span><span>)</span> <span>// -1 for 1st</span>
                        <span>//链表结构转树形结构</span>
                        <span>treeifyBin</span><span>(</span>tab<span>,</span> hash<span>)</span><span>;</span>
                    <span>// 跳出循环</span>
                    <span>break</span><span>;</span>
                <span>}</span>
                <span>// 判断链表中结点的key值与插入的元素的key值是否相等</span>
                <span>if</span> <span>(</span>e<span>.</span>hash <span>==</span> hash <span>&amp;&amp;</span>
                    <span>(</span><span>(</span>k <span>=</span> e<span>.</span>key<span>)</span> <span>==</span> key <span>||</span> <span>(</span>key <span>!=</span> <span>null</span> <span>&amp;&amp;</span> key<span>.</span><span>equals</span><span>(</span>k<span>)</span><span>)</span><span>)</span><span>)</span>
                    <span>// 相等，跳出循环</span>
                    <span>break</span><span>;</span>
                <span>// 用于遍历桶中的链表，与前面的e = p.next组合，可以遍历链表</span>
                p <span>=</span> e<span>;</span>
            <span>}</span>
        <span>}</span>
        <span>//判断当前的key已经存在的情况下，再来一个相同的hash值、key值时，返回新来的value这个值</span>
        <span>if</span> <span>(</span>e <span>!=</span> <span>null</span><span>)</span> <span>{</span> 
            <span>// 记录e的value</span>
            <span>V</span> oldValue <span>=</span> e<span>.</span>value<span>;</span>
            <span>// onlyIfAbsent为false或者旧值为null</span>
            <span>if</span> <span>(</span><span>!</span>onlyIfAbsent <span>||</span> oldValue <span>==</span> <span>null</span><span>)</span>
                <span>//用新值替换旧值</span>
                e<span>.</span>value <span>=</span> value<span>;</span>
            <span>// 访问后回调</span>
            <span>afterNodeAccess</span><span>(</span>e<span>)</span><span>;</span>
            <span>// 返回旧值</span>
            <span>return</span> oldValue<span>;</span>
        <span>}</span>
    <span>}</span>
    <span>// 结构性修改</span>
    <span>++</span>modCount<span>;</span>
    <span>// 步骤⑥：超过最大容量就扩容 </span>
    <span>// 实际大小大于阈值则扩容</span>
    <span>if</span> <span>(</span><span>++</span>size <span>></span> threshold<span>)</span>
        <span>resize</span><span>(</span><span>)</span><span>;</span>
    <span>// 插入后回调</span>
    <span>afterNodeInsertion</span><span>(</span>evict<span>)</span><span>;</span>
    <span>return</span> <span>null</span><span>;</span>
<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br></div></div><p>①.判断键值对数组table[i]是否为空或为null，否则执行resize()进行扩容；</p>
<p>②.根据键值key计算hash值得到插入的数组索引i，如果table[i]==null，直接新建节点添加，转向⑥，如果table[i]不为空，转向③；</p>
<p>③.判断table[i]的首个元素是否和key一样，如果相同直接覆盖value，否则转向④，这里的相同指的是hashCode以及equals；</p>
<p>④.判断table[i] 是否为treeNode，即table[i] 是否是红黑树，如果是红黑树，则直接在树中插入键值对，否则转向⑤；</p>
<p>⑤.遍历table[i]，判断链表长度是否大于8，大于8的话把链表转换为红黑树，在红黑树中执行插入操作，否则进行链表的插入操作；遍历过程中若发现key已经存在直接覆盖value即可；</p>
<p>⑥.插入成功后，判断实际存在的键值对数量size是否超多了最大容量threshold，如果超过，进行扩容。</p>
<blockquote>
<p>4、HashMap的扩容操作是怎么实现的？</p>
</blockquote>
<p>①.在jdk1.8中，resize()方法是在hashmap中的键值对大于阀值时或者初始化时，就调用resize()方法进行扩容；</p>
<p>②.每次扩展的时候，都是扩展2倍；</p>
<p>③.扩展后Node对象的位置要么在原位置，要么移动到原偏移量两倍的位置。</p>
<p>在putVal()中，我们看到在这个函数里面使用到了2次resize()方法，resize()方法表示的在进行第一次<strong>初始化时</strong>会对其进行扩容，或者当该<strong>数组的实际大小大于其临界值值(第一次为12),</strong></p>
<p>这个时候在扩容的同时也会伴随的桶上面的元素进行重新分发，这也是JDK1.8版本的一个优化的地方，</p>
<ul>
<li>在1.7中，扩容之后需要重新去计算其Hash值，根据Hash值对其进行分发</li>
<li>但在1.8版本中，则是根据在同一个桶的位置中进行判断(e.hash &amp; oldCap)是否为0，重新进行hash分配后，该元素的位置要么停留在原始位置，要么移动到原始位置+增加的数组大小这个位置上</li>
</ul>
<div><pre><code><span>final</span> <span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span><span>[</span><span>]</span> <span>resize</span><span>(</span><span>)</span> <span>{</span>
    <span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span><span>[</span><span>]</span> oldTab <span>=</span> table<span>;</span><span>//oldTab指向hash桶数组</span>
    <span>int</span> oldCap <span>=</span> <span>(</span>oldTab <span>==</span> <span>null</span><span>)</span> <span>?</span> <span>0</span> <span>:</span> oldTab<span>.</span>length<span>;</span>
    <span>int</span> oldThr <span>=</span> threshold<span>;</span>
    <span>int</span> newCap<span>,</span> newThr <span>=</span> <span>0</span><span>;</span>
    <span>if</span> <span>(</span>oldCap <span>></span> <span>0</span><span>)</span> <span>{</span><span>//如果oldCap不为空的话，就是hash桶数组不为空</span>
        <span>if</span> <span>(</span>oldCap <span>>=</span> MAXIMUM_CAPACITY<span>)</span> <span>{</span><span>//如果大于最大容量了，就赋值为整数最大的阀值</span>
            threshold <span>=</span> <span>Integer</span><span>.</span>MAX_VALUE<span>;</span>
            <span>return</span> oldTab<span>;</span><span>//返回</span>
        <span>}</span><span>//如果当前hash桶数组的长度在扩容后仍然小于最大容量 并且oldCap大于默认值16</span>
        <span>else</span> <span>if</span> <span>(</span><span>(</span>newCap <span>=</span> oldCap <span>&lt;&lt;</span> <span>1</span><span>)</span> <span><span>&lt;</span> MAXIMUM_CAPACITY <span>&amp;</span><span>&amp;</span>
                 oldCap <span>></span></span><span>=</span> DEFAULT_INITIAL_CAPACITY<span>)</span>
            newThr <span>=</span> oldThr <span>&lt;&lt;</span> <span>1</span><span>;</span> <span>// double threshold 双倍扩容阀值threshold</span>
    <span>}</span>
    <span>// 旧的容量为0，但threshold大于零，代表有参构造有cap传入，threshold已经被初始化成最小2的n次幂</span>
    <span>// 直接将该值赋给新的容量</span>
    <span>else</span> <span>if</span> <span>(</span>oldThr <span>></span> <span>0</span><span>)</span> <span>// initial capacity was placed in threshold</span>
        newCap <span>=</span> oldThr<span>;</span>
    <span>// 无参构造创建的map，给出默认容量和threshold 16, 16*0.75</span>
    <span>else</span> <span>{</span>               <span>// zero initial threshold signifies using defaults</span>
        newCap <span>=</span> DEFAULT_INITIAL_CAPACITY<span>;</span>
        newThr <span>=</span> <span>(</span><span>int</span><span>)</span><span>(</span>DEFAULT_LOAD_FACTOR <span>*</span> DEFAULT_INITIAL_CAPACITY<span>)</span><span>;</span>
    <span>}</span>
    <span>// 新的threshold = 新的cap * 0.75</span>
    <span>if</span> <span>(</span>newThr <span>==</span> <span>0</span><span>)</span> <span>{</span>
        <span>float</span> ft <span>=</span> <span>(</span><span>float</span><span>)</span>newCap <span>*</span> loadFactor<span>;</span>
        newThr <span>=</span> <span>(</span>newCap <span>&lt;</span> MAXIMUM_CAPACITY <span>&amp;&amp;</span> ft <span>&lt;</span> <span>(</span><span>float</span><span>)</span>MAXIMUM_CAPACITY <span>?</span>
                  <span>(</span><span>int</span><span>)</span>ft <span>:</span> <span>Integer</span><span>.</span>MAX_VALUE<span>)</span><span>;</span>
    <span>}</span>
    threshold <span>=</span> newThr<span>;</span>
    <span>// 计算出新的数组长度后赋给当前成员变量table</span>
    <span>@SuppressWarnings</span><span>(</span><span>{</span><span>"rawtypes"</span><span>,</span><span>"unchecked"</span><span>}</span><span>)</span>
        <span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span><span>[</span><span>]</span> newTab <span>=</span> <span>(</span><span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span><span>[</span><span>]</span><span>)</span><span>new</span> <span>Node</span><span>[</span>newCap<span>]</span><span>;</span><span>//新建hash桶数组</span>
    table <span>=</span> newTab<span>;</span><span>//将新数组的值复制给旧的hash桶数组</span>
    <span>// 如果原先的数组没有初始化，那么resize的初始化工作到此结束，否则进入扩容元素重排逻辑，使其均匀的分散</span>
    <span>if</span> <span>(</span>oldTab <span>!=</span> <span>null</span><span>)</span> <span>{</span>
        <span>// 遍历新数组的所有桶下标</span>
        <span>for</span> <span>(</span><span>int</span> j <span>=</span> <span>0</span><span>;</span> j <span>&lt;</span> oldCap<span>;</span> <span>++</span>j<span>)</span> <span>{</span>
            <span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> e<span>;</span>
            <span>if</span> <span>(</span><span>(</span>e <span>=</span> oldTab<span>[</span>j<span>]</span><span>)</span> <span>!=</span> <span>null</span><span>)</span> <span>{</span>
                <span>// 旧数组的桶下标赋给临时变量e，并且解除旧数组中的引用，否则就数组无法被GC回收</span>
                oldTab<span>[</span>j<span>]</span> <span>=</span> <span>null</span><span>;</span>
                <span>// 如果e.next==null，代表桶中就一个元素，不存在链表或者红黑树</span>
                <span>if</span> <span>(</span>e<span>.</span>next <span>==</span> <span>null</span><span>)</span>
                    <span>// 用同样的hash映射算法把该元素加入新的数组</span>
                    newTab<span>[</span>e<span>.</span>hash <span>&amp;</span> <span>(</span>newCap <span>-</span> <span>1</span><span>)</span><span>]</span> <span>=</span> e<span>;</span>
                <span>// 如果e是TreeNode并且e.next!=null，那么处理树中元素的重排</span>
                <span>else</span> <span>if</span> <span>(</span>e <span>instanceof</span> <span>TreeNode</span><span>)</span>
                    <span>(</span><span>(</span><span>TreeNode</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span><span>)</span>e<span>)</span><span>.</span><span>split</span><span>(</span><span>this</span><span>,</span> newTab<span>,</span> j<span>,</span> oldCap<span>)</span><span>;</span>
                <span>// e是链表的头并且e.next!=null，那么处理链表中元素重排</span>
                <span>else</span> <span>{</span> <span>// preserve order</span>
                    <span>// loHead,loTail 代表扩容后不用变换下标，见注1</span>
                    <span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> loHead <span>=</span> <span>null</span><span>,</span> loTail <span>=</span> <span>null</span><span>;</span>
                    <span>// hiHead,hiTail 代表扩容后变换下标，见注1</span>
                    <span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> hiHead <span>=</span> <span>null</span><span>,</span> hiTail <span>=</span> <span>null</span><span>;</span>
                    <span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> next<span>;</span>
                    <span>// 遍历链表</span>
                    <span>do</span> <span>{</span>             
                        next <span>=</span> e<span>.</span>next<span>;</span>
                        <span>if</span> <span>(</span><span>(</span>e<span>.</span>hash <span>&amp;</span> oldCap<span>)</span> <span>==</span> <span>0</span><span>)</span> <span>{</span>
                            <span>if</span> <span>(</span>loTail <span>==</span> <span>null</span><span>)</span>
                                <span>// 初始化head指向链表当前元素e，e不一定是链表的第一个元素，初始化后loHead</span>
                                <span>// 代表下标保持不变的链表的头元素</span>
                                loHead <span>=</span> e<span>;</span>
                            <span>else</span>                                
                                <span>// loTail.next指向当前e</span>
                                loTail<span>.</span>next <span>=</span> e<span>;</span>
                            <span>// loTail指向当前的元素e</span>
                            <span>// 初始化后，loTail和loHead指向相同的内存，所以当loTail.next指向下一个元素时，</span>
                            <span>// 底层数组中的元素的next引用也相应发生变化，造成lowHead.next.next.....</span>
                            <span>// 跟随loTail同步，使得lowHead可以链接到所有属于该链表的元素。</span>
                            loTail <span>=</span> e<span>;</span>                           
                        <span>}</span>
                        <span>else</span> <span>{</span>
                            <span>if</span> <span>(</span>hiTail <span>==</span> <span>null</span><span>)</span>
                                <span>// 初始化head指向链表当前元素e, 初始化后hiHead代表下标更改的链表头元素</span>
                                hiHead <span>=</span> e<span>;</span>
                            <span>else</span>
                                hiTail<span>.</span>next <span>=</span> e<span>;</span>
                            hiTail <span>=</span> e<span>;</span>
                        <span>}</span>
                    <span>}</span> <span>while</span> <span>(</span><span>(</span>e <span>=</span> next<span>)</span> <span>!=</span> <span>null</span><span>)</span><span>;</span>
                    <span>// 遍历结束, 将tail指向null，并把链表头放入新数组的相应下标，形成新的映射。</span>
                    <span>if</span> <span>(</span>loTail <span>!=</span> <span>null</span><span>)</span> <span>{</span>
                        loTail<span>.</span>next <span>=</span> <span>null</span><span>;</span>
                        newTab<span>[</span>j<span>]</span> <span>=</span> loHead<span>;</span>
                    <span>}</span>
                    <span>if</span> <span>(</span>hiTail <span>!=</span> <span>null</span><span>)</span> <span>{</span>
                        hiTail<span>.</span>next <span>=</span> <span>null</span><span>;</span>
                        newTab<span>[</span>j <span>+</span> oldCap<span>]</span> <span>=</span> hiHead<span>;</span>
                    <span>}</span>
                <span>}</span>
            <span>}</span>
        <span>}</span>
    <span>}</span>
    <span>return</span> newTab<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br><span>96</span><br><span>97</span><br></div></div><blockquote>
<p>5、HashMap是怎么解决哈希冲突的？</p>
</blockquote>
<p>在解决这个问题之前，我们首先需要知道<strong>什么是哈希冲突</strong>，而在了解哈希冲突之前我们还要知道<strong>什么是哈希</strong>才行；</p>
<p><strong>（1）什么是哈希？</strong></p>
<p>Hash，一般翻译为“散列”，也有直接音译为“哈希”的，这就是把任意长度的输入通过散列算法，变换成固定长度的输出，该输出就是散列值（哈希值）；这种转换是一种压缩映射，也就是，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，所以不可能从散列值来唯一的确定输入值。<strong>简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数</strong>。</p>
<p>所有散列函数都有如下一个基本特性：<strong>一定不同根据同一散列函数计算出的散列值如果不同，那么输入值肯定也不同；输入值不同，根据同一散列函数计算出的散列值可能相同</strong>。</p>
<p><strong>（2）什么是哈希冲突？</strong></p>
<p>当两个不同的输入值，根据同一散列函数计算出相同的散列值的现象，我们就把它叫做碰撞（哈希碰撞）。</p>
<p><strong>（3）HashMap的数据结构</strong></p>
<p>HashMap使用一种叫做<strong>链地址法</strong>的方式可以解决哈希冲突：</p>
<p><img src="./assets/12.png" alt="image-20210115113459601"></p>
<p>这样我们就可以将拥有相同哈希值的对象组织成一个链表放在hash值所对应的bucket下， <strong>但相比于hashCode返回的int类型，我们HashMap初始的容量大小<code>DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4</code>（即2的四次方16）要远小于int类型的范围，所以我们如果只是单纯的用hashCode取余来获取对应的bucket这将会大大增加哈希碰撞的概率，并且最坏情况下还会将HashMap变成一个单链表，所以我们还需要对hashCode作一定的优化</strong></p>
<p><strong>（4）hash()函数</strong></p>
<p>上面提到的问题，主要是因为如果使用hashCode取余，那么相当于<strong>参与运算的只有hashCode的低位</strong>，高位是没有起到任何作用的，所以我们的思路就是让hashCode取值出的高位也参与运算，进一步降低hash碰撞的概率，使得数据分布更平均，我们把这样的操作称为<strong>扰动</strong>，在<strong>JDK 1.8</strong>中的hash()函数如下：</p>
<div><pre><code><span>static</span> <span>final</span> <span>int</span> <span>hash</span><span>(</span><span>Object</span> key<span>)</span> <span>{</span>
    <span>int</span> h<span>;</span>
    <span>return</span> <span>(</span>key <span>==</span> <span>null</span><span>)</span> <span>?</span> <span>0</span> <span>:</span> <span>(</span>h <span>=</span> key<span>.</span><span>hashCode</span><span>(</span><span>)</span><span>)</span> <span>^</span> <span>(</span>h <span>>>></span> <span>16</span><span>)</span><span>;</span><span>// 与自己右移16位进行异或运算（高低位异或）</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>这比在<strong>JDK 1.7</strong>中，更为简洁，<strong>相比在1.7中的4次位运算，5次异或运算（9次扰动），在1.8中，只进行了1次位运算和1次异或运算（2次扰动）</strong>；</p>
<p><strong>（5）JDK1.8新增红黑树</strong></p>
<p><img src="./assets/13.png" alt="img"></p>
<p>通过上面的<strong>链地址法（使用散列表）<strong>和</strong>扰动函数</strong>我们成功让我们的数据分布更平均，哈希碰撞减少，但是当我们的HashMap中存在大量数据时，加入我们某个bucket下对应的链表有n个元素，那么遍历时间复杂度就为O(n)，为了针对这个问题，JDK1.8在HashMap中新增了红黑树的数据结构，进一步使得遍历复杂度降低至O(logn)；</p>
<p><strong>（4）总结</strong></p>
<p>简单总结一下HashMap是使用了哪些方法来有效解决哈希冲突的：</p>
<ol>
<li>
<p>使用链地址法（使用散列表）来链接拥有相同hash值的数据；</p>
</li>
<li>
<p>使用2次扰动函数（hash函数）来降低哈希冲突的概率，使得数据分布更平均；</p>
</li>
<li>
<p>引入红黑树进一步降低遍历的时间复杂度，使得遍历更快；</p>
</li>
</ol>
<blockquote>
<p>6、能否使用任何类作为Map的 key？</p>
</blockquote>
<p><strong>可以，</strong> 然而在使用之前，需要考虑以下几点：</p>
<ul>
<li>如果类重写了 equals() 方法，也应该重写 hashCode() 方法。</li>
<li>类的所有实例需要遵循与 equals() 和 hashCode() 相关的规则。</li>
<li>如果一个类没有使用 equals()，不应该在 hashCode() 中使用它。</li>
<li>用户自定义 Key 类最佳实践是使之为不可变的，这样 hashCode() 值可以被缓存起来，拥有更好的性能。不可变的类也可以确保 hashCode() 和 equals() 在未来不会改变，这样就会解决与可变相关的问题了。</li>
</ul>
<blockquote>
<p>7、为什么HashMap中String、Integer这样的包装类适合作为K？</p>
</blockquote>
<p>String、Integer等包装类的特性能够保证Hash值的不可更改性和计算准确性，能够有效的减少Hash碰撞的几率</p>
<ol>
<li>都是final类型，即不可变性，保证key的不可更改性，不会存在获取hash值不同的情况</li>
<li>内部已重写了<code>equals()</code>、<code>hashCode()</code>等方法，遵守了HashMap内部的规范，不容易出现Hash值计算错误的情况；</li>
</ol>
<blockquote>
<p>8、如果使用Object作为HashMap的Key，应该怎么办呢？</p>
</blockquote>
<p>重写hashCode()和equals()方法</p>
<ol>
<li><strong>重写hashCode()是因为需要计算存储数据的存储位置</strong>，需要注意不要试图从散列码计算中排除掉一个对象的关键部分来提高性能，这样虽然能更快但可能会导致更多的Hash碰撞；</li>
<li><strong>重写equals()方法</strong>，需要遵守自反性、对称性、传递性、一致性以及对于任何非null的引用值x，x.equals(null)必须返回false的这几个特性，<strong>目的是为了保证key在哈希表中的唯一性</strong>；</li>
</ol>
<blockquote>
<p>9、HashMap为什么不直接使用hashCode()处理后的哈希值直接作为table的下标？</p>
</blockquote>
<ul>
<li>hashCode()方法返回的是int整数类型，其范围为-(2 ^ 31)~(2 ^ 31 - 1)，约有40亿个映射空间，</li>
<li>而HashMap的容量范围是在16（初始化默认值）~2 ^ 30，</li>
<li>HashMap通常情况下是取不到最大值的，并且设备上也难以提供这么多的存储空间，</li>
<li>通过hashCode()计算出的哈希值可能不在数组大小范围内，进而无法匹配存储位置，因此不能直接作为下标</li>
</ul>
<blockquote>
<p>10、HashMap 的长度为什么是2的幂次方</p>
</blockquote>
<p>为了能让 HashMap 存取高效，尽量较少碰撞，也就是要尽量把数据分配均匀，</p>
<p>每个链表/红黑树长度大致相同。这个实现就是把数据存到哪个链表/红黑树中的算法。</p>
<p><strong>这个算法应该如何设计呢？</strong></p>
<p>我们首先可能会想到采用%取余的操作来实现。但是，重点来了：“取余(%)操作中如果除数是2的幂次则等价于与其除数减一的与(&amp;)操</p>
<p>作（也就是说 hash%length==hash&amp;(length-1)的前提是 length 是2的 n 次方；）。” 并且 采用二进制位操作 &amp;，相对于%能够提高运</p>
<p>算效率，这就解释了 HashMap 的长度为什么是2的幂次方。</p>
<p><strong>那为什么是两次扰动呢？</strong></p>
<p>这样就是加大哈希值低位的随机性，使得分布更均匀，从而提高对应数组存储下标位置的随机性&amp;均匀性，最终减少Hash冲突，</p>
<p>两次就够了，已经达到了高位低位同时参与运算的目的；</p>
<blockquote>
<p>11、HashMap 与 HashTable 有什么区别？</p>
</blockquote>
<ol>
<li><strong>线程安全</strong>： HashMap 是非线程安全的，HashTable 是线程安全的；HashTable 内部的方法基本都经过 <code>synchronized</code> 修饰。HashTable已经不推荐使用（如果你要保证线程安全的话就使用 <code>ConcurrentHashMap</code>！）；</li>
<li><strong>效率</strong>： 因为线程安全的问题，HashMap 要比 HashTable 效率高一点。另外，HashTable 基本被淘汰，不要在代码中使用它；</li>
<li><strong>对Null key 和Null value的支持</strong>： HashMap 中，null 可以作为键，这样的键只有一个，可以有一个或多个键所对应的值为 null。但是在 HashTable 中 put 进的键值只要有一个 null，直接抛NullPointerException。</li>
<li><strong>初始容量大小和每次扩充容量大小的不同</strong>  ： ①创建时如果不指定容量初始值，Hashtable 默认的初始大小为11，之后每次扩充，容量变为原来的2n+1。HashMap 默认的初始化大小为16。之后每次扩充，容量变为原来的2倍。②创建时如果给定了容量初始值，那么 Hashtable 会直接使用你给定的大小，而 HashMap 会将其扩充为2的幂次方大小。也就是说 HashMap 总是使用2的幂作为哈希表的大小，后面会介绍到为什么是2的幂次方。</li>
<li><strong>底层数据结构</strong>： JDK1.8 以后的 HashMap 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。Hashtable 没有这样的机制。</li>
<li>推荐使用：在 Hashtable 的类注释可以看到，Hashtable 是保留类不建议使用，推荐在单线程环境下使用 HashMap 替代，如果需要多线程使用则用 ConcurrentHashMap 替代。</li>
</ol>
<blockquote>
<p>12、如何决定使用 HashMap 还是 TreeMap？</p>
</blockquote>
<ul>
<li>对于在Map中插入、删除和定位元素这类操作，HashMap是最好的选择。</li>
<li>然而，假如你需要对一个有序的key集合进行遍历，TreeMap是更好的选择。</li>
<li>基于你的collection的大小，也许向HashMap中添加元素会更快，将map换为TreeMap进行有序key的遍历。</li>
</ul>
<blockquote>
<p>13、HashMap 和 ConcurrentHashMap 的区别</p>
</blockquote>
<ul>
<li>
<p>ConcurrentHashMap对整个桶数组进行了分割分段(Segment)，然后在每一个分段上都用lock锁进行保护，</p>
<p>相对于HashTable的synchronized锁的粒度更精细了一些，并发性能更好，</p>
<p>而HashMap没有锁机制，不是线程安全的。（JDK1.8之后ConcurrentHashMap启用了一种全新的方式实现,利用<strong>CAS算法</strong>。）</p>
</li>
<li>
<p>HashMap的键值对允许有null，但是ConCurrentHashMap都不允许。</p>
</li>
</ul>
<blockquote>
<p>14、 ConcurrentHashMap 和 Hashtable 的区别？</p>
</blockquote>
<p>ConcurrentHashMap 结合了 HashMap 和 HashTable 二者的优势。HashMap 没有考虑同步，HashTable 考虑了同步的问题。但是</p>
<p>HashTable 在每次同步执行时都要锁住整个结构。 ConcurrentHashMap 锁的方式是稍微细粒度的。</p>
<p>ConcurrentHashMap 和 Hashtable 的区别主要体现在实现线程安全的方式上不同。</p>
<ul>
<li>
<p><strong>底层数据结构</strong>： JDK1.7的 ConcurrentHashMap 底层采用 <strong>分段的数组+链表</strong> 实现，JDK1.8 采用的数据结构跟HashMap1.8的结构一样，数组+链表/红黑二叉树。Hashtable 和 JDK1.8 之前的 HashMap 的底层数据结构类似都是采用 <strong>数组+链表</strong> 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的；</p>
</li>
<li>
<p><strong>实现线程安全的方式（重要）</strong>：</p>
<p>① <strong>在JDK1.7的时候，ConcurrentHashMap（分段锁）</strong> 对整个桶数组进行了分割分段(Segment)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。（默认分配16个Segment，比Hashtable效率提高16倍。） <strong>到了 JDK1.8 的时候已经摒弃了Segment的概念，而是直接用 Node 数组+链表+红黑树的数据结构来实现，并发控制使用 synchronized 和 CAS 来操作。（JDK1.6以后 对 synchronized锁做了很多优化）</strong> 整个看起来就像是优化过且线程安全的 HashMap，虽然在JDK1.8中还能看到 Segment 的数据结构，但是已经简化了属性，只是为了兼容旧版本；</p>
<p>② <strong>Hashtable(同一把锁)</strong> :使用 synchronized 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。</p>
</li>
</ul>
<p><strong>两者的对比图</strong>：</p>
<p>HashTable:</p>
<p><img src="./assets/14.png" alt="img"></p>
<p>JDK1.7的ConcurrentHashMap：</p>
<p><img src="./assets/15.png" alt="img"></p>
<p>JDK1.8的ConcurrentHashMap（TreeBin: 红黑二叉树节点 Node: 链表节点）：</p>
<p><img src="./assets/16.png" alt="img"></p>
<blockquote>
<p>15、ConcurrentHashMap 底层具体实现知道吗？实现原理是什么？</p>
</blockquote>
<p><strong>JDK1.7</strong></p>
<p>首先将数据分为一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问。</p>
<p>在JDK1.7中，ConcurrentHashMap采用Segment + HashEntry的方式进行实现，结构如下：</p>
<ul>
<li>一个 ConcurrentHashMap 里包含一个 Segment 数组。Segment 的结构和HashMap类似，是一种数组和链表结构，</li>
<li>一个 Segment 包含一个 HashEntry 数组，每个 HashEntry 是一个链表结构的元素，每个 Segment 守护着一个HashEntry数组里的元素，</li>
<li>当对 HashEntry 数组的数据进行修改时，必须首先获得对应的 Segment的锁。</li>
</ul>
<p><img src="./assets/17.png" alt="img"></p>
<ol>
<li>该类包含两个<strong>静态内部类</strong> HashEntry 和 Segment ；前者用来封装映射表的键值对，后者用来充当锁的角色；</li>
<li>Segment 是一种<strong>可重入的锁</strong> ReentrantLock，每个 Segment 守护一个HashEntry 数组里的元素，当对 HashEntry 数组的数据进行修改时，必须首先获得对应的 Segment 锁。</li>
</ol>
<p><strong>JDK1.8</strong></p>
<p>在<strong>JDK1.8中，放弃了Segment臃肿的设计，取而代之的是采用Node + CAS + Synchronized来保证并发安全进行实现</strong>，synchronized只锁定当前链表或红黑二叉树的首节点，这样只要hash不冲突，就不会产生并发，效率又提升N倍。</p>
<p>结构如下：</p>
<p><img src="./assets/18.png" alt="img"></p>
<p><strong>附加源码，有需要的可以看看</strong></p>
<p>插入元素过程（建议去看看源码）：</p>
<p>如果相应位置的Node还没有初始化，则调用CAS插入相应的数据；</p>
<div><pre><code><span>else</span> <span>if</span> <span>(</span><span>(</span>f <span>=</span> <span>tabAt</span><span>(</span>tab<span>,</span> i <span>=</span> <span>(</span>n <span>-</span> <span>1</span><span>)</span> <span>&amp;</span> hash<span>)</span><span>)</span> <span>==</span> <span>null</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span><span>casTabAt</span><span>(</span>tab<span>,</span> i<span>,</span> <span>null</span><span>,</span> <span>new</span> <span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span><span>(</span>hash<span>,</span> key<span>,</span> value<span>,</span> <span>null</span><span>)</span><span>)</span><span>)</span>
        <span>break</span><span>;</span>                   <span>// no lock when adding to empty bin</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>如果相应位置的Node不为空，且当前该节点不处于移动状态，则对该节点加synchronized锁，如果该节点的hash不小于0，则遍历链表更新节点或插入新节点；</p>
<div><pre><code><span>if</span> <span>(</span>fh <span>>=</span> <span>0</span><span>)</span> <span>{</span>
    binCount <span>=</span> <span>1</span><span>;</span>
    <span>for</span> <span>(</span><span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> e <span>=</span> f<span>;</span><span>;</span> <span>++</span>binCount<span>)</span> <span>{</span>
        <span>K</span> ek<span>;</span>
        <span>if</span> <span>(</span>e<span>.</span>hash <span>==</span> hash <span>&amp;&amp;</span>
            <span>(</span><span>(</span>ek <span>=</span> e<span>.</span>key<span>)</span> <span>==</span> key <span>||</span>
             <span>(</span>ek <span>!=</span> <span>null</span> <span>&amp;&amp;</span> key<span>.</span><span>equals</span><span>(</span>ek<span>)</span><span>)</span><span>)</span><span>)</span> <span>{</span>
            oldVal <span>=</span> e<span>.</span>val<span>;</span>
            <span>if</span> <span>(</span><span>!</span>onlyIfAbsent<span>)</span>
                e<span>.</span>val <span>=</span> value<span>;</span>
            <span>break</span><span>;</span>
        <span>}</span>
        <span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> pred <span>=</span> e<span>;</span>
        <span>if</span> <span>(</span><span>(</span>e <span>=</span> e<span>.</span>next<span>)</span> <span>==</span> <span>null</span><span>)</span> <span>{</span>
            pred<span>.</span>next <span>=</span> <span>new</span> <span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span><span>(</span>hash<span>,</span> key<span>,</span> value<span>,</span> <span>null</span><span>)</span><span>;</span>
            <span>break</span><span>;</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><ol>
<li>如果该节点是TreeBin类型的节点，说明是红黑树结构，则通过putTreeVal方法往红黑树中插入节点；如果binCount不为0，说明put操作对数据产生了影响，如果当前链表的个数达到8个，则通过treeifyBin方法转化为红黑树，如果oldVal不为空，说明是一次更新操作，没有对元素个数产生影响，则直接返回旧值；</li>
<li>如果插入的是一个新节点，则执行addCount()方法尝试更新元素个数baseCount；</li>
</ol>
<h4 id="四-辅助工具类-2"> （四）辅助工具类</h4>
<blockquote>
<p>1、Array 和 ArrayList 有何区别？</p>
</blockquote>
<ul>
<li>Array 可以存储基本数据类型和对象，ArrayList 只能存储对象。</li>
<li>Array 是指定固定大小的，而 ArrayList 大小是自动扩展的。</li>
<li>Array 内置方法没有 ArrayList 多，比如 addAll、removeAll、iteration 等方法只有 ArrayList 有。</li>
</ul>
<p>对于基本类型数据，集合使用自动装箱来减少编码工作量。但是，当处理固定大小的基本数据类型的时候，这种方式相对比较慢。</p>
<blockquote>
<p>2、如何实现 Array 和 List 之间的转换？</p>
</blockquote>
<ul>
<li>Array 转 List： Arrays. asList(array) ；</li>
<li>List 转 Array：List 的 toArray() 方法。</li>
</ul>
<blockquote>
<p>3、comparable 和 comparator的区别？</p>
</blockquote>
<ul>
<li>comparable接口实际上是出自java.lang包，它有一个 compareTo(Object obj)方法用来排序</li>
<li>comparator接口实际上是出自 java.util 包，它有一个compare(Object obj1, Object obj2)方法用来排序</li>
</ul>
<ol>
<li>
<p>一般我们需要对一个集合使用自定义排序时，我们就要重写compareTo方法或compare方法，</p>
</li>
<li>
<p>当我们需要对某一个集合实现两种排序方式，</p>
<p>比如一个song对象中的歌名和歌手名分别采用一种排序方法的话，我们可以</p>
<p>①重写compareTo方法和使用自制的Comparator方法</p>
<p>②以两个Comparator来实现歌名排序和歌星名排序</p>
<p>第二种代表我们只能使用两个参数版的Collections.sort().</p>
</li>
</ol>
<blockquote>
<p>4、Collection 和 Collections 有什么区别？</p>
</blockquote>
<ul>
<li>java.util.Collection 是一个集合接口（集合类的一个顶级接口）。它提供了对集合对象进行基本操作的通用接口方法。Collection接口在Java 类库中有很多具体的实现。Collection接口的意义是为各种具体的集合提供了最大化的统一操作方式，其直接继承接口有List与Set。</li>
<li>Collections则是集合类的一个工具类/帮助类，其中提供了一系列静态方法，用于对集合中元素进行排序、搜索以及线程安全等各种操作。</li>
</ul>
<blockquote>
<p>5、TreeMap 和 TreeSet 在排序时如何比较元素？Collections 工具类中的 sort()方法如何比较元素？</p>
</blockquote>
<ol>
<li>TreeSet 要求存放的<strong>对象</strong>所属的类必须实现 <strong>Comparable 接口</strong>，该接口提供了比较元素的 compareTo()方法，当插入元素时会回调该方法比较元素的大小。</li>
<li>TreeMap 要求存放的键值对映射的<strong>键</strong>必须实现 <strong>Comparable 接口</strong>从而根据键对元素进行排序。</li>
</ol>
<p>Collections 工具类的 sort 方法有两种重载的形式，</p>
<ul>
<li>第一种：要求传入的待排序容器中存放的<strong>对象</strong>比较实现 <strong>Comparable 接口</strong>以实现元素的比较；</li>
<li>第二种：不强制性的要求容器中的元素必须可比较，但是要求传入第二个参数，<strong>参数是Comparator 接口的子类型</strong>（需要重写 compare 方法实现元素的比较），相当于一个临时定义的排序规则，其实就是通过 <mark>接口注入</mark> 比较元素大小的算法，也是对 <mark>回调模式</mark> 的应用（Java 中对函数式编程的支持）。</li>
</ul>
<h3 id="二、泛型-2"> 二、泛型</h3>
<h3 id="三、异常-2"> 三、异常</h3>
<blockquote>
<p>1、Error 和 Exception 区别是什么？</p>
</blockquote>
<ol>
<li>Error 类型的错误通常为虚拟机相关错误，如系统崩溃，内存不足，堆栈溢出等，编译器不会对这类错误进行检测，JAVA 应用程序也不应对这类错误进行捕获，一旦这类错误发生，通常应用程序会被终止，仅靠应用程序本身无法恢复；</li>
<li>Exception 类的错误是可以在应用程序中进行捕获并处理的，通常遇到这种错误，应对其进行处理，使应用程序可以继续正常运行。</li>
</ol>
<blockquote>
<p>2、运行时异常和一般异常(受检异常)区别是什么？</p>
</blockquote>
<p>运行时异常包括 RuntimeException 类及其子类，表示 JVM 在运行期间可能出现的异常。 Java 编译器不会检查运行时异常。</p>
<p>受检异常是Exception 中除 RuntimeException 及其子类之外的异常。 Java 编译器会检查受检异常。</p>
<p><strong>RuntimeException异常和受检异常之间的区别</strong>：</p>
<ul>
<li>是否强制要求调用者必须处理此异常，如果强制要求调用者必须进行处理，那么就使用受检异常，</li>
<li>否则就选择非受检异常(RuntimeException)。一般来讲，如果没有特殊的要求，我们建议使用RuntimeException异常。</li>
</ul>
<blockquote>
<p>3、JVM 是如何处理异常的？</p>
</blockquote>
<ol>
<li>在一个方法中如果发生异常，这个方法会创建一个异常对象，并转交给 JVM，该异常对象包含异常名称，异常描述以及异常发生时应用程序的状态。创建异常对象并转交给 JVM 的过程称为<strong>抛出异常</strong>。可能有一系列的方法调用，最终才进入抛出异常的方法，这一系列方法调用的有序列表叫做调用栈。</li>
<li>JVM 会顺着调用栈去查找看是否有可以处理异常的代码，如果有，则调用异常处理代码。当 JVM 发现可以处理异常的代码时，会把发生的异常传递给它。如果 JVM 没有找到可以处理该异常的代码块，JVM 就会将该异常转交给默认的异常处理器（默认处理器为 JVM 的一部分），默认异常处理器打印出异常信息并终止应用程序。</li>
</ol>
<blockquote>
<p>4、throw 和 throws 的区别是什么？</p>
</blockquote>
<p>Java 中的异常处理除了包括捕获异常和处理异常之外，还包括声明异常和拋出异常，可以通过 throws 关键字在方法上声明该方法要拋</p>
<p>出的异常，或者在方法内部通过 throw 拋出异常对象。</p>
<p><strong>throws 关键字和 throw 关键字在使用上的几点区别如下</strong>：</p>
<ul>
<li>throw 关键字用在方法内部，只能用于抛出一种异常，用来抛出方法或代码块中的异常，受查异常和非受查异常都可以被抛出。</li>
<li>throws 关键字用在方法声明上，可以抛出多个异常，用来标识该方法可能抛出的异常列表。一个方法用 throws 标识了可能抛出的异常列表，调用该方法的方法中必须包含可处理异常的代码，否则也要在方法签名中用 throws 关键字声明相应的异常。</li>
</ul>
<blockquote>
<p>5、final、finally、finalize 有什么区别？</p>
</blockquote>
<ul>
<li>final可以修饰类、变量、方法，修饰类表示该类不能被继承、修饰方法表示该方法不能被重写、修饰变量表示该变量是一个常量不能被重新赋值。</li>
<li>finally一般作用在try-catch代码块中，在处理异常的时候，通常我们将一定要执行的代码方法finally代码块中，表示不管是否出现异常，该代码块都会执行，一般用来存放一些关闭资源的代码。</li>
<li>finalize是一个方法，属于Object类的一个方法，而Object类是所有类的父类，Java 中允许使用 finalize()方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。</li>
</ul>
<blockquote>
<p>6、NoClassDefFoundError 和 ClassNotFoundException 区别？</p>
</blockquote>
<ul>
<li>
<p>NoClassDefFoundError 是一个 Error 类型的异常，是由 JVM 引起的，不应该尝试捕获这个异常。</p>
<p>1、引起该异常的原因是 JVM 或 ClassLoader 尝试加载某类时在内存中找不到该类的定义，</p>
<p>2、该动作发生在运行期间，即编译时该类存在，但是在运行时却找不到了，可能是编译后被删除了等原因导致；</p>
</li>
<li>
<p>ClassNotFoundException 是一个受查异常，需要显式地使用 try-catch 对其进行捕获和处理，或在方法签名中用 throws 关键字进行声明。</p>
<p>1、当使用 Class.forName, ClassLoader.loadClass 或 ClassLoader.findSystemClass 动态加载类到内存的时候，通过传入的类路径参数没有找到该类，就会抛出该异常；</p>
<p>2、另一种抛出该异常的可能原因是某个类已经由一个类加载器加载至内存中，另一个加载器又尝试去加载它。</p>
</li>
</ul>
<blockquote>
<p>7、try-catch-finally 中哪个部分可以省略？</p>
</blockquote>
<p>catch 可以省略</p>
<p><strong>原因</strong></p>
<ol>
<li>更为严格的说法其实是：try只适合处理运行时异常，try+catch适合处理运行时异常+普通异常。也就是说，如果你只用try去处理普通异常却不加以catch处理，编译是通不过的，因为编译器硬性规定，普通异常如果选择捕获，则必须用catch显示声明以便进一步处理。而运行时异常在编译时没有如此规定，所以catch可以省略，你加上catch编译器也觉得无可厚非。</li>
<li>理论上，编译器看任何代码都不顺眼，都觉得可能有潜在的问题，所以你即使对所有代码加上try，代码在运行期时也只不过是在正常运行的基础上加一层皮。但是你一旦对一段代码加上try，就等于显示地承诺编译器，对这段代码可能抛出的异常进行捕获而非向上抛出处理。如果是普通异常，编译器要求必须用catch捕获以便进一步处理；如果运行时异常，捕获然后丢弃并且+finally扫尾处理，或者加上catch捕获以便进一步处理。</li>
<li>至于加上finally，则是在不管有没捕获异常，都要进行的“扫尾”处理。</li>
</ol>
<blockquote>
<p>8、try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？</p>
</blockquote>
<p>答：会执行，在 return 前执行。</p>
<p><strong>注意</strong>：在 finally 中改变返回值的做法是不好的，因为如果存在 finally 代码块，<strong>try中的 return 语句不会立马返回调用者</strong>，而是</p>
<p>记录下返回值待 finally 代码块执行完毕之后再向调用者返回其值，然后如果在 finally 中修改了返回值，就会返回修改后的值。显然，</p>
<p>在 finally 中返回或者修改返回值会对程序造成很大的困扰，C#中直接用编译错误的方式来阻止程序员干这种龌龊的事情，Java 中也可</p>
<p>以通过提升编译器的语法检查级别来产生警告或错误。</p>
<p><strong>代码示例1：</strong></p>
<div><pre><code><span>public</span> <span>static</span> <span>int</span> <span>getInt</span><span>(</span><span>)</span> <span>{</span>
    <span>int</span> a <span>=</span> <span>10</span><span>;</span>
    <span>try</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>a <span>/</span> <span>0</span><span>)</span><span>;</span>
        a <span>=</span> <span>20</span><span>;</span>
    <span>}</span> <span>catch</span> <span>(</span><span>ArithmeticException</span> e<span>)</span> <span>{</span>
        a <span>=</span> <span>30</span><span>;</span>
        <span>return</span> a<span>;</span>
        <span>/*
         * return a 在程序执行到这一步的时候，这里不是return a 而是 return 30；这个返回路径就形成了
         * 但是呢，它发现后面还有finally，所以继续执行finally的内容，a=40
         * 再次回到以前的路径,继续走return 30，形成返回路径之后，这里的a就不是a变量了，而是常量30
         */</span>
    <span>}</span> <span>finally</span> <span>{</span>
        a <span>=</span> <span>40</span><span>;</span>
    <span>}</span>
	<span>return</span> a<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><p>执行结果：30</p>
<p><strong>代码示例2：</strong></p>
<div><pre><code><span>public</span> <span>static</span> <span>int</span> <span>getInt</span><span>(</span><span>)</span> <span>{</span>
    <span>int</span> a <span>=</span> <span>10</span><span>;</span>
    <span>try</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>a <span>/</span> <span>0</span><span>)</span><span>;</span>
        a <span>=</span> <span>20</span><span>;</span>
    <span>}</span> <span>catch</span> <span>(</span><span>ArithmeticException</span> e<span>)</span> <span>{</span>
        a <span>=</span> <span>30</span><span>;</span>
        <span>return</span> a<span>;</span>
    <span>}</span> <span>finally</span> <span>{</span>
        a <span>=</span> <span>40</span><span>;</span>
        <span>//如果这样，就又重新形成了一条返回路径，由于只能通过1个return返回，所以这里直接返回40</span>
        <span>return</span> a<span>;</span> 
    <span>}</span>

<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>执行结果：40</p>
<blockquote>
<p>9、类 ExampleA 继承 Exception，类 ExampleB 继承ExampleA。</p>
</blockquote>
<p>有如下代码片断：</p>
<div><pre><code><span>try</span> <span>{</span>
	<span>throw</span> <span>new</span> <span>ExampleB</span><span>(</span><span>"b"</span><span>)</span>
<span>}</span> <span>catch</span>（<span>ExampleA</span> e）<span>{</span>
	<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"ExampleA"</span><span>)</span><span>;</span>
<span>}</span> <span>catch</span>（<span>Exception</span> e）<span>{</span>
	<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"Exception"</span><span>)</span><span>;</span>
<span>}</span>
<span>1234567</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>请问执行此段代码的输出是什么？</p>
<p><strong>答</strong>：</p>
<p>输出：ExampleA。（根据里<strong>氏代换原则</strong>[能使用父类型的地方一定能使用子类型]，抓取 ExampleA 类型异常的 catch 块能够抓住 try 块中抛出的 ExampleB 类型的异常）</p>
<p>面试题 - 说出下面代码的运行结果。（此题的出处是《Java 编程思想》一书）</p>
<div><pre><code><span>class</span> <span>Annoyance</span> <span>extends</span> <span>Exception</span> <span>{</span>
<span>}</span>
<span>class</span> <span>Sneeze</span> <span>extends</span> <span>Annoyance</span> <span>{</span>
<span>}</span>
<span>class</span> <span>Human</span> <span>{</span>
	<span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span>
	<span>throws</span> <span>Exception</span> <span>{</span>
		<span>try</span> <span>{</span>
			<span>try</span> <span>{</span>
				<span>throw</span> <span>new</span> <span>Sneeze</span><span>(</span><span>)</span><span>;</span>
			<span>}</span> <span>catch</span> <span>(</span> <span>Annoyance</span> a <span>)</span> <span>{</span>
				<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"Caught Annoyance"</span><span>)</span><span>;</span>
				<span>throw</span> a<span>;</span>
			<span>}</span>
		<span>}</span> <span>catch</span> <span>(</span> <span>Sneeze</span> s <span>)</span> <span>{</span>
			<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"Caught Sneeze"</span><span>)</span><span>;</span>
			<span>return</span> <span>;</span>
		<span>}</span> <span>finally</span> <span>{</span>
			<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"Hello World!"</span><span>)</span><span>;</span>
		<span>}</span>
	<span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><p>结果</p>
<div><pre><code><span>Caught</span> <span>Annoyance</span>
<span>Caught</span> <span>Sneeze</span>
<span>Hello</span> <span>World</span><span>!</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><blockquote>
<p>10、常见的 RuntimeException 有哪些？</p>
</blockquote>
<ul>
<li>ClassCastException(类转换异常)</li>
<li>IndexOutOfBoundsException(数组越界)</li>
<li>NullPointerException(空指针)</li>
<li>ArrayStoreException(数据存储异常，操作数组时类型不一致)</li>
<li>还有IO操作的BufferOverflowException异常</li>
</ul>
<blockquote>
<p>11、Java常见异常有哪些？</p>
</blockquote>
<ul>
<li>java.lang.<strong>IllegalAccessError</strong>：违法访问错误。当一个应用试图访问、修改某个类的域（Field）或者调用其方法，但是又违反域或方法的可见性声明，则抛出该异常。</li>
<li>java.lang.<strong>InstantiationError</strong>：实例化错误。当一个应用试图通过Java的new操作符构造一个抽象类或者接口时抛出该异常.</li>
<li>java.lang.<strong>OutOfMemoryError</strong>：内存不足错误。当可用内存不足以让Java虚拟机分配给一个对象时抛出该错误。</li>
<li>java.lang.<strong>StackOverflowError</strong>：堆栈溢出错误。当一个应用递归调用的层次太深而导致堆栈溢出或者陷入死循环时抛出该错误。</li>
<li>java.lang.<strong>ClassCastException</strong>：类造型异常。假设有类A和B（A不是B的父类或子类），O是A的实例，那么当强制将O构造为类B的实例时抛出该异常。该异常经常被称为强制类型转换异常。</li>
<li>java.lang.<strong>ClassNotFoundException</strong>：找不到类异常。当应用试图根据字符串形式的类名构造类，而在遍历CLASSPAH之后找不到对应名称的class文件时，抛出该异常。</li>
<li>java.lang.<strong>ArithmeticException</strong>：算术条件异常。譬如：整数除零等。</li>
<li>java.lang.<strong>ArrayIndexOutOfBoundsExceptio</strong>n：数组索引越界异常。当对数组的索引值为负数或大于等于数组大小时抛出。</li>
<li>java.lang.<strong>IndexOutOfBoundsException</strong>：索引越界异常。当访问某个序列的索引值小于0或大于等于序列大小时，抛出该异常。</li>
<li>java.lang.<strong>InstantiationException</strong>：实例化异常。当试图通过newInstance()方法创建某个类的实例，而该类是一个抽象类或接口时，抛出该异常。</li>
<li>java.lang.<strong>NoSuchFieldException</strong>：属性不存在异常。当访问某个类的不存在的属性时抛出该异常。</li>
<li>java.lang.<strong>NoSuchMethodException</strong>：方法不存在异常。当访问某个类的不存在的方法时抛出该异常。</li>
<li>java.lang.<strong>NullPointerException</strong>：空指针异常。当应用试图在要求使用对象的地方使用了null时，抛出该异常。譬如：调用null对象的实例方法、访问null对象的属性、计算null对象的长度、使用throw语句抛出null等等。</li>
<li>java.lang.<strong>NumberFormatException</strong>：数字格式异常。当试图将一个String转换为指定的数字类型，而该字符串确不满足数字类型要求的格式时，抛出该异常。</li>
<li>java.lang.<strong>StringIndexOutOfBoundsException</strong>：字符串索引越界异常。当使用索引值访问某个字符串中的字符，而该索引值小于0或大于等于序列大小时，抛出该异常。</li>
</ul>
<h3 id="四、io流-2"> 四、IO流</h3>
<blockquote>
<p>1、Java 中 IO 流分为几种?</p>
</blockquote>
<ul>
<li>
<p>按照流的流向分，可以分为输入流和输出流；</p>
</li>
<li>
<p>按照操作单元划分，可以划分为字节流和字符流；</p>
</li>
<li>
<p>按照流的角色划分为节点流和处理流。
Java IO流共涉及40多个类，这些类看上去很杂乱，但实际上很有规则，而且彼此之间存在非常紧密的联系， Java IO流的40多个类都是从如下4个抽象类基类中派生出来的。</p>
</li>
<li>
<p>InputStream/Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。</p>
</li>
<li>
<p>OutputStream/Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流。</p>
</li>
</ul>
<p>按操作方式分类结构图：
<img src="./assets/19.jpg" alt=""></p>
<p>按操作对象分类结构图：</p>
<p>​	<img src="./assets/20.jpg" alt=""></p>
<blockquote>
<p>2、BIO,NIO,AIO 有什么区别?</p>
</blockquote>
<p><strong>简答</strong></p>
<ul>
<li>
<p>BIO：Blocking IO 同步<strong>阻塞式 IO</strong>，就是我们平常使用的<strong>传统 IO</strong>，它的特点是模式简单使用方便，<strong>并发处理能力低</strong>。</p>
</li>
<li>
<p>NIO：New IO 同步<strong>非阻塞 IO</strong>，是传统 IO 的升级，客户端和服务器端通过 Channel（通道）通讯，实现了<strong>多路复用</strong>。</p>
</li>
<li>
<p>AIO：Asynchronous IO 是 NIO 的升级，也叫 NIO2，实现了<strong>异步非堵塞 IO</strong> ，异步 IO 的操作基于<strong>事件和回调机制</strong>。</p>
</li>
</ul>
<p><strong>使用场景：</strong></p>
<ul>
<li>对于低负载、低并发的应用程序，可以使用同步阻塞I/O来提升开发速率和更好的维护性；</li>
<li>对于高负载、高并发的（网络）应用，应使用 NIO 的非阻塞模式来开发</li>
</ul>
<p><strong>详细回答</strong></p>
<ul>
<li>BIO (Blocking I/O): 同步阻塞I/O模式，数据的读取写入必须阻塞在一个线程内等待其完成。在活动连接数不是特别高（小于单机1000）的情况下，这种模型是比较不错的，可以让每一个连接专注于自己的 I/O 并且编程模型简单，也不用过多考虑系统的过载、限流等问题。线程池本身就是一个天然的漏斗，可以缓冲一些系统处理不了的连接或请求。但是，当面对十万甚至百万级连接的时候，传统的 BIO 模型是无能为力的。因此，我们需要一种更高效的 I/O 处理模型来应对更高的并发量。</li>
<li>NIO (New I/O): NIO是一种同步非阻塞的I/O模型，在<strong>Java 1.4</strong> 中引入了NIO框架，对应 java.nio 包，提供了 <strong>Channel , Selector，Buffer</strong>等抽象。NIO中的N可以理解为Non-blocking，不单纯是New。它支持面向缓冲的，基于通道的I/O操作方法。 NIO提供了与传统BIO模型中的 Socket 和 ServerSocket 相对应的 SocketChannel 和 ServerSocketChannel 两种不同的套接字通道实现,两种通道都支持阻塞和非阻塞两种模式。阻塞模式使用就像传统中的支持一样，比较简单，但是性能和可靠性都不好；非阻塞模式正好与之相反。</li>
<li>AIO (Asynchronous I/O): AIO 也就是 NIO 2。在 <strong>Java 7</strong> 中引入了 NIO 的改进版 NIO 2,它是异步非阻塞的IO模型。异步 IO 是<strong>基于事件和回调机制</strong>实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。AIO 是异步IO的缩写，虽然 NIO 在网络操作中，提供了非阻塞的方法，但是 NIO 的 IO 行为还是同步的。对于 NIO 来说，我们的业务线程是在 IO 操作准备好时，得到通知，接着就由这个线程自行进行 IO 操作，IO操作本身是同步的。查阅网上相关资料，我发现就目前来说 AIO 的应用还不是很广泛，Netty 之前也尝试使用过 AIO，不过又放弃了。</li>
</ul>
<blockquote>
<p>3、Files的常用方法都有哪些？</p>
</blockquote>
<p>Files. exists()：检测文件路径是否存在。</p>
<p>Files. createFile()：创建文件。</p>
<p>Files. createDirectory()：创建文件夹。</p>
<p>Files. delete()：删除一个文件或目录。</p>
<p>Files. copy()：复制文件。</p>
<p>Files. move()：移动文件。</p>
<p>Files. size()：查看文件个数。</p>
<p>Files. read()：读取文件。</p>
<p>Files. write()：写入文件。</p>
<h3 id="五、注解-2"> 五、注解</h3>
<h3 id="六、反射-2"> 六、反射</h3>
<blockquote>
<p>1、什么是反射机制？</p>
</blockquote>
<p>JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种<strong>动态获取的信息以及动态调用对象的方法的功能</strong>称为java语言的反射机制。</p>
<p>静态编译和动态编译</p>
<p><strong>静态编译</strong>：在编译时确定类型，绑定对象</p>
<p><strong>动态编译</strong>：运行时确定类型，绑定对象</p>
<blockquote>
<p>2、反射机制优缺点</p>
</blockquote>
<p>优点： 运行期类型的判断，动态加载类，提高代码灵活度。</p>
<p>缺点： 性能瓶颈：反射相当于一系列解释操作，通知 JVM 要做的事情，性能比直接的java代码要慢很多。</p>
<blockquote>
<p>3、反射机制的应用场景有哪些？</p>
</blockquote>
<p><strong>反射是框架设计的灵魂。</strong></p>
<p>在我们平时的项目开发过程中，基本上很少会直接使用到反射机制，但这不能说明反射机制没有用，实际上有很多设计、开发都与反射机制有关，例如：</p>
<ul>
<li>模块化的开发，通过反射去调用对应的字节码；</li>
<li>动态代理设计模式也采用了反射机制，</li>
<li>还有我们日常使用的 Spring／Hibernate 等框架也大量使用到了反射机制。</li>
</ul>
<p><strong>举例：</strong></p>
<p>1、我们在使用JDBC连接数据库时使用Class.forName()通过反射加载数据库的驱动程序；</p>
<p>2、Spring框架也用到很多反射机制，最经典的就是xml的配置模式。</p>
<p>Spring 通过 XML 配置模式装载 Bean 的过程：</p>
<ul>
<li>1）将程序内所有 XML 或 Properties 配置文件加载入内存中;</li>
<li>2）Java类里面解析xml或properties里面的内容，得到对应实体类的字节码字符串以及相关的属性信息;</li>
<li>3）使用反射机制，根据这个字符串获得某个类的Class实例;</li>
<li>4）动态配置实例的属性</li>
</ul>
<blockquote>
<p>4、Java获取反射的三种方法</p>
</blockquote>
<p>1.通过new对象实现反射机制</p>
<p>2.通过路径实现反射机制</p>
<p>3.通过类名实现反射机制</p>
<div><pre><code><span>public</span> <span>class</span> <span>Student</span> <span>{</span>
    <span>private</span> <span>int</span> id<span>;</span>
    <span>String</span> name<span>;</span>
    <span>protected</span> <span>boolean</span> sex<span>;</span>
    <span>public</span> <span>float</span> score<span>;</span>
<span>}</span>

<span>public</span> <span>class</span> <span>Get</span> <span>{</span>
    <span>//获取反射机制三种方式</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>throws</span> <span>ClassNotFoundException</span> <span>{</span>
        <span>//方式一(通过建立对象)</span>
        <span>Student</span> stu <span>=</span> <span>new</span> <span>Student</span><span>(</span><span>)</span><span>;</span>
        <span>Class</span> classobj1 <span>=</span> stu<span>.</span><span>getClass</span><span>(</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>classobj1<span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>
        <span>//方式二（通过所在路径-相对路径）</span>
        <span>Class</span> classobj2 <span>=</span> <span>Class</span><span>.</span><span>forName</span><span>(</span><span>"fanshe.Student"</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>classobj2<span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>
        <span>//方式三（通过类名）</span>
        <span>Class</span> classobj3 <span>=</span> <span>Student</span><span>.</span><span>class</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>classobj3<span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><h3 id="七、网络-2"> 七、网络</h3>
<blockquote>
<p>1、为什么TCP连接的时候是3次？2次不可以吗？</p>
</blockquote>
<ol>
<li>因为需要考虑连接时丢包的问题，如果只握手2次，第二次握手时如果服务端发给客户端的确认报文段丢失，此时服务端已经准备好了收发数(可以理解服务端已经连接成功)据，而客户端一直没收到服务端的确认报文，所以客户端就不知道服务端是否已经准备好了(可以理解为客户端未连接成功)，这种情况下客户端不会给服务端发数据，也会忽略服务端发过来的数据。</li>
<li>如果是三次握手，即便发生丢包也不会有问题，比如如果第三次握手客户端发的确认ack报文丢失，服务端在一段时间内没有收到确认ACK报文的话就会重新进行第二次握手，也就是服务端会重发SYN报文段，客户端收到重发的报文段后会再次给服务端发送确认ACK报文。</li>
</ol>
<p>客户端：兄弟，在吗？</p>
<p>服务端：在的，老铁</p>
<p>客户端：回个消息磨磨唧唧，都等你半天了</p>
<p><img src="./assets/21.png" alt=""></p>
<ul>
<li><strong>第一次握手</strong>：客户端要向服务端发起连接请求，首先客户端随机生成一个起始序列号ISN(比如是100)，那客户端向服务端发送的报文段包含SYN标志位(也就是SYN=1)，序列号seq=100。</li>
<li><strong>第二次握手</strong>：服务端收到客户端发过来的报文后，发现SYN=1，知道这是一个连接请求，于是将客户端的起始序列号100存起来，并且随机生成一个服务端的起始序列号(比如是300)。然后给客户端回复一段报文，回复报文包含SYN和ACK标志(也就是SYN=1,ACK=1)、序列号seq=300、确认号ack=101(客户端发过来的序列号+1)。</li>
<li><strong>第三次握手</strong>：客户端收到服务端的回复后发现ACK=1并且ack=101,于是知道服务端已经收到了序列号为100的那段报文；同时发现SYN=1，知道了服务端同意了这次连接，于是就将服务端的序列号300给存下来。然后客户端再回复一段报文给服务端，报文包含ACK标志位(ACK=1)、ack=301(服务端序列号+1)、seq=101(第一次握手时发送报文是占据一个序列号的，所以这次seq就从101开始，需要注意的是不携带数据的ACK报文是不占据序列号的，所以后面第一次正式发送数据时seq还是101)。当服务端收到报文后发现ACK=1并且ack=301，就知道客户端收到序列号为300的报文了，就这样客户端和服务端通过TCP建立了连接。</li>
</ul>
<blockquote>
<p>2、为什么TCP连接的时候是3次，关闭的时候却是4次？</p>
</blockquote>
<p>因为只有在客户端和服务端都没有数据要发送的时候才能断开TCP。而客户端发出FIN报文时只能保证客户端没有数据发了，服务端还有没有数据发客户端是不知道的。而服务端收到客户端的FIN报文后只能先回复客户端一个确认报文来告诉客户端我服务端已经收到你的FIN报文了，但我服务端还有一些数据没发完，等这些数据发完了服务端才能给客户端发FIN报文(所以不能一次性将确认报文和FIN报文发给客户端，就是这里多出来了一次)。</p>
<p>客户端：我要准备溜了</p>
<p>服务端：收到，老铁。不过等一下，我还有点东西要发你</p>
<p>服务端：也不是啥重要的，算了，不发了，滚你</p>
<p>客户端：****</p>
<p>服务端断开连接....</p>
<p>2MSL后</p>
<p>客户端断开连接......</p>
<p><img src="./assets/22.png" alt=""></p>
<p>比如客户端初始化的序列号ISA=100，服务端初始化的序列号ISA=300。TCP连接成功后客户端总共发送了1000个字节的数据，服务端在客户端发FIN报文前总共回复了2000个字节的数据。</p>
<ul>
<li>
<p><strong>第一次挥手</strong>：当客户端的数据都传输完成后，客户端向服务端发出连接释放报文(当然数据没发完时也可以发送连接释放报文并停止发送数据)，释放连接报文包含FIN标志位(FIN=1)、序列号seq=1101(100+1+1000，其中的1是建立连接时占的一个序列号)。需要注意的是客户端发出FIN报文段后只是不能发数据了，但是还可以正常收数据；另外FIN报文段即使不携带数据也要占据一个序列号。</p>
</li>
<li>
<p><strong>第二次挥手</strong>：服务端收到客户端发的FIN报文后给客户端回复确认报文，确认报文包含ACK标志位(ACK=1)、确认号ack=1102(客户端FIN报文序列号1101+1)、序列号seq=2300(300+2000)。此时服务端处于关闭等待状态，而不是立马给客户端发FIN报文，这个状态还要持续一段时间，因为服务端可能还有数据没发完。</p>
</li>
<li>
<p><strong>第三次挥手</strong>：服务端将最后数据(比如50个字节)发送完毕后就向客户端发出连接释放报文，报文包含FIN和ACK标志位(FIN=1,ACK=1)、确认号和第二次挥手一样ack=1102、序列号seq=2350(2300+50)。</p>
</li>
<li>
<p><strong>第四次挥手</strong>：客户端收到服务端发的FIN报文后，向服务端发出确认报文，确认报文包含ACK标志位(ACK=1)、确认号ack=2351、序列号seq=1102。注意客户端发出确认报文后不是立马释放TCP连接，而是要经过2MSL(最长报文段寿命的2倍时长)后才释放TCP连接。而服务端一旦收到客户端发出的确认报文就会立马释放TCP连接，所以服务端结束TCP连接的时间要比客户端早一些。</p>
</li>
</ul>
<blockquote>
<p>3、为什么客户端发出第四次挥手的确认报文后要等2MSL的时间才能释放TCP连接？</p>
</blockquote>
<p>这里同样是要考虑丢包的问题，如果第四次挥手的报文丢失，服务端就收到确认ACK报文，这样服务端就会就会重发第三次挥手的报文。这样以来，客户端从发出第四次挥手的报文到再次收到第三次挥手的报文经历的最长时间就是2MSL，所以需要等这么长时间来确认服务端确实已经收到了。</p>
<blockquote>
<p>4、如果已经建立了连接，但是客户端突然出现故障了怎么办？</p>
</blockquote>
<p>TCP设有一个<strong>保活计时器</strong>，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为<strong>2小时</strong>，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后<strong>每隔75秒</strong>钟发送一次。若一连发送<strong>10个探测报文</strong>仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。</p>
<blockquote>
<p>5、什么是HTTP，HTTP 与 HTTPS 的区别</p>
</blockquote>
<p>HTTP 是一个在计算机世界里专门在两点之间传输文字、图片、音频、视频等<strong>超文本数据的约定和规范</strong></p>
<table>
<thead>
<tr>
<th>区别</th>
<th>HTTP</th>
<th>HTTPS</th>
</tr>
</thead>
<tbody>
<tr>
<td>协议</td>
<td>运行在 TCP 之上，明文传输，<strong>客户端与服务器端都无法验证对方的身份</strong></td>
<td>身披 SSL( Secure Socket Layer )外壳的 HTTP，运行于 SSL 上，SSL 运行于 TCP 之上， <strong>是添加了加密和认证机制的 HTTP</strong>。</td>
</tr>
<tr>
<td>端口</td>
<td>80</td>
<td>443</td>
</tr>
<tr>
<td>资源消耗</td>
<td>较少</td>
<td>由于加解密处理，会消耗更多的 CPU 和内存资源</td>
</tr>
<tr>
<td>开销</td>
<td>无需证书</td>
<td>需要证书，而证书一般需要向认证机构购买</td>
</tr>
<tr>
<td>加密机制</td>
<td>无</td>
<td>共享密钥加密和公开密钥加密并用的混合加密机制</td>
</tr>
<tr>
<td>安全性</td>
<td>弱</td>
<td>由于加密机制，安全性强</td>
</tr>
</tbody>
</table>
<blockquote>
<p>6、常用HTTP状态码</p>
</blockquote>
<p>HTTP状态码表示客户端HTTP请求的返回结果、标识服务器处理是否正常、表明请求出现的错误等。</p>
<p><strong>状态码的类别：</strong></p>
<table>
<thead>
<tr>
<th>类别</th>
<th>原因短语</th>
</tr>
</thead>
<tbody>
<tr>
<td>1XX</td>
<td>Informational（信息性状态码） 接受的请求正在处理</td>
</tr>
<tr>
<td>2XX</td>
<td>Success（成功状态码） 请求正常处理完毕</td>
</tr>
<tr>
<td>3XX</td>
<td>Redirection（重定向状态码） 需要进行附加操作以完成请求</td>
</tr>
<tr>
<td>4XX</td>
<td>Client Error（客户端错误状态码） 服务器无法处理请求</td>
</tr>
<tr>
<td>5XX</td>
<td>Server Error（服务器错误状态码） 服务器处理请求出错</td>
</tr>
</tbody>
</table>
<p><strong>常用HTTP状态码：</strong></p>
<table>
<thead>
<tr>
<th>2XX</th>
<th>成功（这系列表明请求被正常处理了）</th>
</tr>
</thead>
<tbody>
<tr>
<td>200</td>
<td>OK，表示从客户端发来的请求在服务器端被正确处理</td>
</tr>
<tr>
<td>204</td>
<td>No content，表示请求成功，但响应报文不含实体的主体部分</td>
</tr>
<tr>
<td>206</td>
<td>Partial Content，进行范围请求成功</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>3XX</th>
<th>重定向（表明浏览器要执行特殊处理）</th>
</tr>
</thead>
<tbody>
<tr>
<td>301</td>
<td>moved permanently，永久性重定向，表示资源已被分配了新的 URL</td>
</tr>
<tr>
<td>302</td>
<td>found，临时性重定向，表示资源临时被分配了新的 URL</td>
</tr>
<tr>
<td>303</td>
<td>see other，表示资源存在着另一个 URL，应使用 GET 方法获取资源（对于301/302/303响应，几乎所有浏览器都会删除报文主体并自动用GET重新请求）</td>
</tr>
<tr>
<td>304</td>
<td>not modified，表示服务器允许访问资源，但请求未满足条件的情况（与重定向无关）</td>
</tr>
<tr>
<td>307</td>
<td>temporary redirect，临时重定向，和302含义类似，但是期望客户端保持请求方法不变向新的地址发出请求</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>4XX</th>
<th>客户端错误</th>
</tr>
</thead>
<tbody>
<tr>
<td>400</td>
<td>bad request，请求报文存在语法错误</td>
</tr>
<tr>
<td>401</td>
<td>unauthorized，表示发送的请求需要有通过 HTTP 认证的认证信息</td>
</tr>
<tr>
<td>403</td>
<td>forbidden，表示对请求资源的访问被服务器拒绝，可在实体主体部分返回原因描述</td>
</tr>
<tr>
<td>404</td>
<td>not found，表示在服务器上没有找到请求的资源</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>5XX</th>
<th>服务器错误</th>
</tr>
</thead>
<tbody>
<tr>
<td>500</td>
<td>internal sever error，表示服务器端在执行请求时发生了错误</td>
</tr>
<tr>
<td>501</td>
<td>Not Implemented，表示服务器不支持当前请求所需要的某个功能</td>
</tr>
<tr>
<td>503</td>
<td>service unavailable，表明服务器暂时处于超负载或正在停机维护，无法处理请求</td>
</tr>
</tbody>
</table>
<blockquote>
<p>7、GET和POST区别</p>
</blockquote>
<p>1、说到GET和POST，就不得不提HTTP协议，因为浏览器和服务器的交互是通过HTTP协议执行的，而GET和POST也是HTTP协议中的			  两种方法。</p>
<p>2、HTTP全称为Hyper Text Transfer Protocol，中文翻译为超文本传输协议，目的是保证浏览器与服务器之间的通信。HTTP的工作方			 式是客户端与服务器之间的请求-应答协议。</p>
<p>3、HTTP协议中定义了浏览器和服务器进行交互的不同方法，基本方法有4种，分别是GET，POST，PUT，DELETE。这四种方法可以理         	          解为，对服务器资源的查，改，增，删。</p>
<ul>
<li>GET：从服务器上获取数据，也就是所谓的查，仅仅是获取服务器资源，不进行修改。</li>
<li>POST：向服务器提交数据，这就涉及到了数据的更新，也就是更改服务器的数据。</li>
<li>PUT：英文含义是放置，也就是向服务器新添加数据，就是所谓的增。</li>
<li>DELETE：从字面意思也能看出，这种方式就是删除服务器数据的过程。</li>
</ul>
<p><strong>GET和POST区别</strong></p>
<ol>
<li>
<p><strong>Get是不安全的</strong>，因为在传输过程，数据被放在请求的URL中；Post的所有操作对用户来说都是不可见的。 但是这种做法也不时绝对的，大部分人的做法也是按照上面的说法来的，但是也可以在get请求加上 request body，给 post请求带上 URL 参数。</p>
</li>
<li>
<p>Get请求提交的url中的数据<strong>最多只能是2048字节</strong>，这个限制是<strong>浏览器或者服务器给添加的</strong>，http协议并没有对url长度进行限制，目的是为了保证服务器和浏览器能够正常运行，防止有人恶意发送请求。POST请求则没有大小限制。</p>
</li>
<li>
<p>Get限制Form表单的数据集的值必须为ASCII字符；而POST支持整个ISO10646字符集。</p>
</li>
<li>
<p>Get执行效率却比POST方法好。Get是Form提交的默认方法。</p>
</li>
<li>
<p>GET产生一个TCP数据包；POST产生两个TCP数据包。</p>
<p>对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；</p>
<p>而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。</p>
</li>
</ol>
<blockquote>
<p>8、什么是对称加密与非对称加密</p>
</blockquote>
<ul>
<li>对称密钥加密是指加密和解密使用同一个密钥的方式，<strong>这种方式存在的最大问题就是密钥发送问题，即如何安全地将密钥发给对方；</strong></li>
<li>而非对称加密是指使用一对非对称密钥，即公钥和私钥，公钥可以随意发布，但私钥只有自己知道。发送密文的一方使用对方的公钥进行加密处理，对方接收到加密信息后，使用自己的私钥进行解密。</li>
<li>由于非对称加密的方式不需要发送用来解密的私钥，所以可以保证安全性；但是和对称加密比起来，非常的慢</li>
</ul>
<blockquote>
<p>9、什么是HTTP2</p>
</blockquote>
<ul>
<li>HTTP2 可以提高了网页的性能。</li>
<li>在 HTTP1 中浏览器限制了同一个域名下的请求数量（Chrome 下一般是六个），当在请求很多资源的时候，由于队头阻塞，此时当浏览器达到最大请求数量，剩余的资源只能等待当前的六个请求完成后才能发起请求。</li>
<li>HTTP2 中引入了<strong>多路复用</strong>的技术，这个技术可以只通过一个 TCP 连接就可以传输所有的请求数据。多路复用可以<strong>绕过浏览器限制同一个域名下的请求数量的问题</strong>，进而提高了网页的性能。</li>
</ul>
<blockquote>
<p>10、Session、Cookie和Token的主要区别</p>
</blockquote>
<p>HTTP协议本身是 <mark>无状态</mark> 的。什么是无状态呢，<mark>即服务器无法判断用户身份。</mark></p>
<p><strong>（1）什么是cookie</strong></p>
<ul>
<li>cookie是<strong>由Web服务器保存在用户浏览器上的小文件（key-value格式）</strong>，包含用户相关的信息。</li>
<li>客户端向服务器发起请求，如果服务器需要记录该用户状态，就使用response向客户端浏览器颁发一个Cookie。</li>
<li>客户端浏览器会把Cookie保存起来。当浏览器再请求该网站时，浏览器把请求的网址连同该Cookie一同提交给服务器。服务器检查该Cookie，以此来辨认用户身份。</li>
</ul>
<p><strong>（2）什么是session</strong></p>
<ul>
<li>session是<strong>依赖Cookie实现</strong>的。session是服务器端对象</li>
<li>session 是浏览器和服务器会话过程中，服务器分配的一块储存空间。服务器默认浏览器在cookie中设置 sessionid，浏览器在向服务器请求过程中传输 cookie 包含 sessionid ，服务器根据 sessionid 获取出会话中存储的信息，然后确定会话的身份信息。</li>
</ul>
<p><strong>（3）cookie与session区别</strong></p>
<ul>
<li>存储位置与安全性：cookie数据存放在客户端上，安全性较差，session数据放在服务器上，安全性相对更高；</li>
<li>存储空间：单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie，session无此限制</li>
<li>占用服务器资源：session一定时间内保存在服务器上，当访问增多，占用服务器性能，考虑到服务器性能方面，应当使用cookie。</li>
</ul>
<p><strong>（4）什么是Token</strong></p>
<ul>
<li>Token的引入：Token是在客户端频繁向服务端请求数据，服务端频繁的去数据库查询用户名和密码并进行对比，判断用户名和密码正确与否，并作出相应提示，在这样的背景下，Token便应运而生。</li>
<li>Token的定义：<strong>Token是服务端生成的一串字符串</strong>，以作客户端进行请求的一个<strong>令牌</strong>，当第一次登录后，服务器生成一个Token便将此Token返回给客户端，以后客户端只需带上这个Token前来请求数据即可，无需再次带上用户名和密码。</li>
<li>使用Token的目的：Token的目的是<strong>为了减轻服务器的压力，减少频繁的查询数据库，使服务器更加健壮。</strong></li>
<li>Token 是在服务端产生的。如果前端使用用户名/密码向服务端请求认证，服务端认证成功，那么在服务端会返回 Token 给前端。前端可以在每次请求的时候带上 Token 证明自己的合法地位</li>
</ul>
<p><strong>（5）session与token区别</strong></p>
<ul>
<li>session机制存在服务器压力增大，CSRF跨站伪造请求攻击，扩展性不强等问题；</li>
<li>session存储在服务器端，token存储在客户端</li>
<li>token提供<strong>认证和授权</strong>功能，作为身份认证，<strong>token安全性比session好</strong>；</li>
<li>session这种会话存储方式方式只适用于客户端代码和服务端代码运行在同一台服务器上，token适用于项目级的前后端分离（前后端代码运行在不同的服务器下）</li>
</ul>
<blockquote>
<p>11、Servlet是线程安全的吗</p>
</blockquote>
<p><strong>Servlet不是线程安全的，多线程并发的读写会导致数据不同步的问题。</strong></p>
<ul>
<li>
<p>解决的办法是尽量不要定义name属性，而是要把name变量分别定义在doGet()和doPost()方法内。</p>
<p>虽然使用synchronized(name){}语句块可以解决问题，但是会造成线程的等待，不是很科学的办法。</p>
</li>
<li>
<p>注意：</p>
<p>1、多线程的并发的读写Servlet类属性会导致数据不同步。</p>
<p>2、但是如果只是并发地读取属性而不写入，则不存在数据不同步的问题。因此Servlet里的只读属性最好定义为final类型的。</p>
</li>
</ul>
<blockquote>
<p>12、Servlet接口中有哪些方法及Servlet生命周期探秘</p>
</blockquote>
<p>在Java Web程序中，<strong>Servlet</strong>主要负责接收用户请求<strong>HttpServletRequest</strong>，在doGet()、doPost()中做相应的处理，并将回应HttpServletResponse反馈给用户。Servlet可以设置初始化参数，供Servlet内部使用。</p>
<p>Servlet接口定义了5个方法，其中<strong>前三个方法与Servlet生命周期相关</strong>：</p>
<ul>
<li>
<p>void <strong>init</strong>(ServletConfig config) throws ServletException</p>
</li>
<li>
<p>void <strong>service</strong>(ServletRequest req, ServletResponse resp) throws ServletException, java.io.IOException</p>
</li>
<li>
<p>void <strong>destory</strong>()</p>
</li>
<li>
<p>java.lang.String <strong>getServletInfo()</strong></p>
</li>
<li>
<p>ServletConfig <strong>getServletConfig()</strong></p>
</li>
</ul>
<p><strong>生命周期：</strong></p>
<ul>
<li>
<p><strong>Web容器加载Servlet并将其实例化后，Servlet生命周期开始</strong>，容器运行其<strong>init()方法</strong>进行Servlet的初始化；</p>
</li>
<li>
<p>请求到达时调用Servlet的<strong>service()方法</strong>，service()方法会根据需要调用与请求对应的<strong>doGet或doPost</strong>等方法；</p>
</li>
<li>
<p>当服务器关闭或项目被卸载时服务器会将Servlet实例销毁，此时会调用Servlet的<strong>destroy()方法</strong>。</p>
</li>
<li>
<p><strong>init方法和destory方法只会执行一次，service方法客户端每次请求Servlet都会执行</strong>。Servlet中有时会用到一些需要初始化与销毁的资源，因此可以把初始化资源的代码放入init方法中，销毁资源的代码放入destroy方法中，这样就不需要每次处理客户端的请求都要初始化与销毁资源。</p>
</li>
</ul>
<blockquote>
<p>13、如果客户端禁止 cookie 能实现 session 还能用吗？</p>
</blockquote>
<p><strong>不能。</strong></p>
<ul>
<li>Cookie 与 Session，一般认为是两个独立的东西，Session采用的是在服务器端保持状态的方案，而Cookie采用的是在客户端保持状态的方案。</li>
<li>但为什么禁用Cookie就不能得到Session呢？因为Session是用Session ID来确定当前对话所对应的服务器Session，而Session ID是通过Cookie来传递的，禁用Cookie相当于失去了Session ID，也就得不到Session了。</li>
</ul>
<p>假定用户关闭Cookie的情况下使用Session，其实现途径有以下几种：</p>
<ol>
<li>手动通过URL传值、隐藏表单传递Session ID。</li>
<li>用文件、数据库等形式保存Session ID，在跨页过程中手动调用。</li>
</ol>
<h3 id="八、并发-2"> 八、并发</h3>
<h3 id="九、jvm-2"> 九、JVM</h3>
<h6 id=""> </h6>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <contributor>
      <name>南辞</name>
    </contributor>
    <published>2021-02-16T17:39:43.000Z</published>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">JavaSE-时间与日期</title>
    <id>http://qiqi.dreamagain.top/program/backend/java/time/</id>
    <link href="http://qiqi.dreamagain.top/program/backend/java/time/"/>
    <updated>2021-02-16T17:39:43.000Z</updated>
    <content type="html"><![CDATA[<h2 id="一、基本概念"> 一、基本概念</h2>
<p>在计算机中，我们经常需要处理日期和时间。</p>
<p>这是日期：</p>
<ul>
<li>2019-11-20</li>
<li>2020-1-1</li>
</ul>
<p>这是时间：</p>
<ul>
<li>12:30:59</li>
<li>2020-1-1 20:21:59</li>
</ul>
<p>日期是指某一天，它不是连续变化的，而是应该被看成离散的。</p>
<p>而时间有两种概念，一种是不带日期的时间，例如，12:30:59。另一种是带日期的时间，例如，2020-1-1 20:21:59，只有这种带日期的时间能唯一确定某个时刻，不带日期的时间是无法确定一个唯一时刻的。</p>
<h3 id="一-本地时间"> （一）本地时间</h3>
<p>当我们说当前时刻是2019年11月20日早上8:15的时候，我们说的实际上是本地时间。在国内就是北京时间。在这个时刻，如果地球上不同地方的人们同时看一眼手表，他们各自的本地时间是不同的：</p>
<p><img src="./assets/java-05.png" alt=""></p>
<p>所以，不同的时区，在同一时刻，本地时间是不同的。全球一共分为24个时区，伦敦所在的时区称为标准时区，其他时区按东／西偏移的小时区分，北京所在的时区是东八区。</p>
<h3 id="二-时区"> （二）时区</h3>
<p>因为光靠本地时间还无法唯一确定一个准确的时刻，所以我们还需要给本地时间加上一个时区。时区有好几种表示方式。</p>
<p>一种是以<code>GMT</code>或者<code>UTC</code>加时区偏移表示，例如：<code>GMT+08:00</code>或者<code>UTC+08:00</code>表示东八区。</p>
<p><code>GMT</code>和<code>UTC</code>可以认为基本是等价的，只是<code>UTC</code>使用更精确的原子钟计时，每隔几年会有一个闰秒，我们在开发程序的时候可以忽略两者的误差，因为计算机的时钟在联网的时候会自动与时间服务器同步时间。</p>
<p>另一种是缩写，例如，<code>CST</code>表示<code>China Standard Time</code>，也就是中国标准时间。但是<code>CST</code>也可以表示美国中部时间<code>Central Standard Time USA</code>，因此，缩写容易产生混淆，我们尽量不要使用缩写。</p>
<p>最后一种是以洲／城市表示，例如，<code>Asia/Shanghai</code>，表示上海所在地的时区。特别注意城市名称不是任意的城市，而是由国际标准组织规定的城市。</p>
<p>因为时区的存在，东八区的2019年11月20日早上8:15，和西五区的2019年11月19日晚上19:15，他们的时刻是相同的：</p>
<p><img src="./assets/java-06.png" alt=""></p>
<p>时刻相同的意思就是，分别在两个时区的两个人，如果在这一刻通电话，他们各自报出自己手表上的时间，虽然本地时间是不同的，但是这两个时间表示的时刻是相同的。</p>
<h3 id="三-夏令时"> （三）夏令时</h3>
<p>时区还不是最复杂的，更复杂的是夏令时。所谓夏令时，就是夏天开始的时候，把时间往后拨1小时，夏天结束的时候，再把时间往前拨1小时。我们国家实行过一段时间夏令时，1992年就废除了，但是矫情的美国人到现在还在使用，所以时间换算更加复杂。</p>
<p><img src="./assets/java-07.png" alt=""></p>
<p>因为涉及到夏令时，相同的时区，如果表示的方式不同，转换出的时间是不同的。我们举个栗子：</p>
<p>对于2019-11-20和2019-6-20两个日期来说，假设北京人在纽约：</p>
<ul>
<li>如果以<code>GMT</code>或者<code>UTC</code>作为时区，无论日期是多少，时间都是<code>19:00</code>；</li>
<li>如果以国家／城市表示，例如<code>America／NewYork</code>，虽然纽约也在西五区，但是，因为夏令时的存在，在不同的日期，<code>GMT</code>时间和纽约时间可能是不一样的：</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">时区</th>
<th style="text-align:left">2019-11-20</th>
<th style="text-align:left">2019-6-20</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">GMT-05:00</td>
<td style="text-align:left">19:00</td>
<td style="text-align:left">19:00</td>
</tr>
<tr>
<td style="text-align:left">UTC-05:00</td>
<td style="text-align:left">19:00</td>
<td style="text-align:left">19:00</td>
</tr>
<tr>
<td style="text-align:left">America/New_York</td>
<td style="text-align:left">19:00</td>
<td style="text-align:left">20:00</td>
</tr>
</tbody>
</table>
<p>实行夏令时的不同地区，进入和退出夏令时的时间很可能是不同的。同一个地区，根据历史上是否实行过夏令时，标准时间在不同年份换算成当地时间也是不同的。因此，计算夏令时，没有统一的公式，必须按照一组给定的规则来算，并且，该规则要定期更新。</p>
<p>计算夏令时请使用标准库提供的相关类，不要试图自己计算夏令时。</p>
<h3 id="四-本地化"> （四）本地化</h3>
<p>在计算机中，通常使用<code>Locale</code>表示一个国家或地区的日期、时间、数字、货币等格式。<code>Locale</code>由<code>语言_国家</code>的字母缩写构成，例如，<code>zh_CN</code>表示中文+中国，<code>en_US</code>表示英文+美国。语言使用小写，国家使用大写。</p>
<p>对于日期来说，不同的Locale，例如，中国和美国的表示方式如下：</p>
<ul>
<li>zh_CN：2016-11-30</li>
<li>en_US：11/30/2016</li>
</ul>
<p>计算机用<code>Locale</code>在日期、时间、货币和字符串之间进行转换。一个电商网站会根据用户所在的<code>Locale</code>对用户显示如下：</p>
<table>
<thead>
<tr>
<th style="text-align:left"></th>
<th style="text-align:left">中国用户</th>
<th style="text-align:left">美国用户</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">购买价格</td>
<td style="text-align:left">12000.00</td>
<td style="text-align:left">12,000.00</td>
</tr>
<tr>
<td style="text-align:left">购买日期</td>
<td style="text-align:left">2016-11-30</td>
<td style="text-align:left">11/30/2016</td>
</tr>
</tbody>
</table>
<div><p>小结</p>
<p>在编写日期和时间的程序前，我们要准确理解日期、时间和时刻的概念。</p>
<p>由于存在本地时间，我们需要理解时区的概念，并且必须牢记由于夏令时的存在，同一地区用<code>GMT/UTC</code>和城市表示的时区可能导致时间不同。</p>
<p>计算机通过<code>Locale</code>来针对当地用户习惯格式化日期、时间、数字、货币等。</p>
</div>
<h2 id="二、日期和时间的存储与表示"> 二、日期和时间的存储与表示</h2>
<p><strong>在计算机中，应该如何表示日期和时间呢？</strong></p>
<p>我们经常看到的日期和时间表示方式如下：</p>
<ul>
<li>2019-11-20 0:15:00 GMT+00:00</li>
<li>2019年11月20日8:15:00</li>
<li>11/19/2019 19:15:00 America/New_York</li>
</ul>
<p>如果直接以字符串的形式存储，那么不同的格式，不同的语言会让表示方式非常繁琐。</p>
<p>在理解日期和时间的表示方式之前，我们先要理解数据的存储和展示。</p>
<p>当我们定义一个整型变量并赋值时：</p>
<div><pre><code><span>int</span> n <span>=</span> <span>123400</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div><p>编译器会把上述字符串（程序源码就是一个字符串）编译成字节码。在程序的运行期，变量<code>n</code>指向的内存实际上是一个4字节区域：</p>
<div><pre><code>┌──┬──┬──┬──┐
│00│01│e2│08│
└──┴──┴──┴──┘
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>注意到计算机内存除了二进制的<code>0</code>/<code>1</code>外没有其他任何格式。上述十六进制是为了简化表示。（回顾计算机组成原理）</p>
<p>当我们用<code>System.out.println(n)</code>打印这个整数的时候，实际上<code>println()</code>这个方法在内部把<code>int</code>类型转换成<code>String</code>类型，然后打印出字符串<code>123400</code>。</p>
<p>类似的，我们也可以以十六进制的形式打印这个整数，或者，如果<code>n</code>表示一个价格，我们就以<code>$123,400.00</code>的形式来打印它：</p>
<div><pre><code><span>import</span> <span>java<span>.</span>text<span>.</span></span><span>*</span><span>;</span> 
<span>import</span> <span>java<span>.</span>util<span>.</span></span><span>*</span><span>;</span> 
<span>public</span> <span>class</span> <span>Main</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>int</span> n <span>=</span> <span>123400</span><span>;</span>
        <span>// 123400</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>n<span>)</span><span>;</span>
        <span>// 1e208</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Integer</span><span>.</span><span>toHexString</span><span>(</span>n<span>)</span><span>)</span><span>;</span>
        <span>// $123,400.00</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>NumberFormat</span><span>.</span><span>getCurrencyInstance</span><span>(</span><span>Locale</span><span>.</span>US<span>)</span><span>.</span><span>format</span><span>(</span>n<span>)</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>可见，整数<code>123400</code>是数据的存储格式，它的存储格式非常简单。而我们打印的各种各样的字符串，则是数据的展示格式。展示格式有多种形式，但本质上它就是一个转换方法：</p>
<div><pre><code><span>String</span> <span>toDisplay</span><span>(</span><span>int</span> n<span>)</span> <span>{</span> <span>.</span><span>.</span><span>.</span> <span>}</span>
</code></pre>
<div><span>1</span><br></div></div><p>理解了数据的存储和展示，我们回头看看以下几种日期和时间：</p>
<ul>
<li>2019-11-20 0:15:01 GMT+00:00</li>
<li>2019年11月20日8:15:01</li>
<li>11/19/2019 19:15:01 America/New_York</li>
</ul>
<p>它们实际上是数据的展示格式，分别按英国时区、中国时区、纽约时区对同一个时刻进行展示。而这个“同一个时刻”在计算机中存储的本质上只是一个整数，我们称它为<code>Epoch Time</code>。</p>
<p><code>Epoch Time</code>是计算从1970年1月1日零点（格林威治时区／GMT+00:00）到现在所经历的秒数，例如：</p>
<p><code>1574208900</code>表示从从1970年1月1日零点GMT时区到该时刻一共经历了1574208900秒，换算成伦敦、北京和纽约时间分别是：</p>
<div><pre><code>1574208900 = 北京时间2019-11-20 8:15:00
           = 伦敦时间2019-11-20 0:15:00
           = 纽约时间2019-11-19 19:15:00
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><img src="./assets/java-08.png" alt=""></p>
<p>因此，在计算机中，只需要存储一个整数<code>1574208900</code>表示某一时刻。当需要显示为某一地区的当地时间时，我们就把它格式化为一个字符串：</p>
<div><pre><code>String displayDateTime(int n, String timezone) { ... }
</code></pre>
<div><span>1</span><br></div></div><p><code>Epoch Time</code>又称为 <mark>时间戳</mark> ，在不同的编程语言中，会有几种存储方式：</p>
<ul>
<li>以秒为单位的整数：1574208900，缺点是精度只能到秒；</li>
<li>以毫秒为单位的整数：1574208900123，最后3位表示毫秒数；</li>
<li>以秒为单位的浮点数：1574208900.123，小数点后面表示零点几秒。</li>
</ul>
<p>它们之间转换非常简单。而在Java程序中，时间戳通常是用<code>long</code>表示的毫秒数，即：</p>
<div><pre><code><span>long</span> t <span>=</span> <span>1574208900123L</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div><p>转换成北京时间就是<code>2019-11-20T8:15:00.123</code>。要获取当前时间戳，可以使用<code>System.currentTimeMillis()</code>，这是Java程序获取时间戳最常用的方法。</p>
<h2 id="三、标准库api"> 三、标准库API</h2>
<p>我们再来看一下Java标准库提供的API。Java标准库有两套处理日期和时间的API：</p>
<ul>
<li>一套定义在<code>java.util</code>这个包里面，主要包括<code>Date</code>、<code>Calendar</code>和<code>TimeZone</code>这几个类；</li>
<li>一套新的API是在Java 8引入的，定义在<code>java.time</code>这个包里面，主要包括<code>LocalDateTime</code>、<code>ZonedDateTime</code>、<code>ZoneId</code>等。</li>
</ul>
<p>为什么会有新旧两套API呢？因为历史遗留原因，旧的API存在很多问题，所以引入了新的API。</p>
<p>那么我们能不能跳过旧的API直接用新的API呢？如果涉及到遗留代码就不行，因为很多遗留代码仍然使用旧的API，所以目前仍然需要对旧的API有一定了解，很多时候还需要在新旧两种对象之间进行转换。</p>
<h3 id="一-旧api的常用类型和方法"> （一）旧API的常用类型和方法</h3>
<blockquote>
<h4 id="_1、date"> 1、Date</h4>
</blockquote>
<p><code>java.util.Date</code>是用于表示一个日期和时间的对象，注意与<code>java.sql.Date</code>区分，后者用在数据库中。如果观察Date的源码，可以发现它实际上存储了一个long类型的以毫秒表示的时间戳：</p>
<div><pre><code><span>public</span> <span>class</span> <span>Date</span> <span>implements</span> <span>Serializable</span><span>,</span> <span>Cloneable</span><span>,</span> <span>Comparable</span><span><span>&lt;</span><span>Date</span><span>></span></span> <span>{</span>

    <span>private</span> <span>transient</span> <span>long</span> fastTime<span>;</span>

    <span>.</span><span>.</span><span>.</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>Date的基本用法：</p>
<div><pre><code><span>public</span> <span>class</span> <span>Main</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>// 获取当前时间:</span>
        <span>Date</span> date <span>=</span> <span>new</span> <span>Date</span><span>(</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>date<span>.</span><span>getYear</span><span>(</span><span>)</span> <span>+</span> <span>1900</span><span>)</span><span>;</span> <span>// 必须加上1900</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>date<span>.</span><span>getMonth</span><span>(</span><span>)</span> <span>+</span> <span>1</span><span>)</span><span>;</span> <span>// 0~11，必须加上1</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>date<span>.</span><span>getDate</span><span>(</span><span>)</span><span>)</span><span>;</span> <span>// 1~31，不能加1</span>
        <span>// 转换为String:</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>date<span>.</span><span>toString</span><span>(</span><span>)</span><span>)</span><span>;</span>
        <span>// 转换为GMT时区:</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>date<span>.</span><span>toGMTString</span><span>(</span><span>)</span><span>)</span><span>;</span>
        <span>// 转换为本地时区:</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>date<span>.</span><span>toLocaleString</span><span>(</span><span>)</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><div><p>注意点</p>
<ul>
<li><code>getYear()</code>返回的年份必须加上<code>1900</code>;</li>
<li><code>getMonth()</code>返回的月份是<code>0</code>~<code>11</code>分别表示1~12月，所以要加1;</li>
<li><code>getDate()</code>返回的日期范围是<code>1</code>~<code>31</code>，又不能加1。</li>
</ul>
</div>
<p>打印本地时区表示的日期和时间时，不同的计算机可能会有不同的结果。</p>
<p>如果我们想要针对用户的偏好精确地控制日期和时间的格式，就可以使用<code>SimpleDateFormat</code>对一个<code>Date</code>进行转换。它用预定义的字符串表示格式化：</p>
<ul>
<li>yyyy：年</li>
<li>MM：月</li>
<li>dd: 日</li>
<li>HH: 小时</li>
<li>mm: 分钟</li>
<li>ss: 秒</li>
</ul>
<p>我们来看如何以自定义的格式输出</p>
<div><pre><code><span>public</span> <span>class</span> <span>Main</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>// 获取当前时间:</span>
        <span>Date</span> date <span>=</span> <span>new</span> <span>Date</span><span>(</span><span>)</span><span>;</span>
        <span>var</span> sdf <span>=</span> <span>new</span> <span>SimpleDateFormat</span><span>(</span><span>"yyyy-MM-dd HH:mm:ss"</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>sdf<span>.</span><span>format</span><span>(</span>date<span>)</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
输出结果：
    <span>2020</span><span>-</span><span>02</span><span>-</span><span>10</span> <span>04</span><span>:</span><span>50</span><span>:</span><span>13</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>Java的格式化预定义了许多不同的格式，以<code>MMM</code>和<code>E</code>为例</p>
<div><pre><code><span>public</span> <span>class</span> <span>Main</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>// 获取当前时间:</span>
        <span>Date</span> date <span>=</span> <span>new</span> <span>Date</span><span>(</span><span>)</span><span>;</span>
        <span>var</span> sdf <span>=</span> <span>new</span> <span>SimpleDateFormat</span><span>(</span><span>"E MMM dd, yyyy"</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>sdf<span>.</span><span>format</span><span>(</span>date<span>)</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>上述代码在不同的语言环境会打印出类似<code>Sun Sep 15, 2019</code>这样的日期。可以从<a href="https://docs.oracle.com/en/java/javase/12/docs/api/java.base/java/text/SimpleDateFormat.html" target="_blank" rel="noopener noreferrer">JDK文档</a>查看详细的格式说明。一般来说，字母越长，输出越长。以<code>M</code>为例，假设当前月份是9月：</p>
<ul>
<li><code>M</code>：输出<code>9</code></li>
<li><code>MM</code>：输出<code>09</code></li>
<li><code>MMM</code>：输出<code>Sep</code></li>
<li><code>MMMM</code>：输出<code>September</code></li>
</ul>
<div><p>注意</p>
<p><code>Date</code>对象有几个严重的问题：</p>
<ul>
<li>它不能转换时区，除了<code>toGMTString()</code>可以按<code>GMT+0:00</code>输出外，Date总是以当前计算机系统的默认时区为基础进行输出。</li>
<li>此外，我们也很难对日期和时间进行加减，计算两个日期相差多少天，计算某个月第一个星期一的日期等。</li>
</ul>
</div>
<br/>
<blockquote>
<h4 id="_2、calendar"> 2、Calendar</h4>
</blockquote>
<p><code>Calendar</code>可以用于获取并设置年、月、日、时、分、秒，它和<code>Date</code>比，主要多了一个可以做简单的日期和时间运算的功能。</p>
<p><code>Calendar</code>的基本用法：</p>
<div><pre><code><span>public</span> <span>class</span> <span>Main</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>// 获取当前时间:</span>
        <span>Calendar</span> c <span>=</span> <span>Calendar</span><span>.</span><span>getInstance</span><span>(</span><span>)</span><span>;</span>
        <span>int</span> y <span>=</span> c<span>.</span><span>get</span><span>(</span><span>Calendar</span><span>.</span>YEAR<span>)</span><span>;</span>
        <span>int</span> m <span>=</span> <span>1</span> <span>+</span> c<span>.</span><span>get</span><span>(</span><span>Calendar</span><span>.</span>MONTH<span>)</span><span>;</span>
        <span>int</span> d <span>=</span> c<span>.</span><span>get</span><span>(</span><span>Calendar</span><span>.</span>DAY_OF_MONTH<span>)</span><span>;</span>
        <span>int</span> w <span>=</span> c<span>.</span><span>get</span><span>(</span><span>Calendar</span><span>.</span>DAY_OF_WEEK<span>)</span><span>;</span>
        <span>int</span> hh <span>=</span> c<span>.</span><span>get</span><span>(</span><span>Calendar</span><span>.</span>HOUR_OF_DAY<span>)</span><span>;</span>
        <span>int</span> mm <span>=</span> c<span>.</span><span>get</span><span>(</span><span>Calendar</span><span>.</span>MINUTE<span>)</span><span>;</span>
        <span>int</span> ss <span>=</span> c<span>.</span><span>get</span><span>(</span><span>Calendar</span><span>.</span>SECOND<span>)</span><span>;</span>
        <span>int</span> ms <span>=</span> c<span>.</span><span>get</span><span>(</span><span>Calendar</span><span>.</span>MILLISECOND<span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>y <span>+</span> <span>"-"</span> <span>+</span> m <span>+</span> <span>"-"</span> <span>+</span> d <span>+</span> <span>" "</span> <span>+</span> w <span>+</span> <span>" "</span> <span>+</span> hh <span>+</span> <span>":"</span> <span>+</span> mm <span>+</span> <span>":"</span> <span>+</span> ss <span>+</span> <span>"."</span> <span>+</span> ms<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
运行结果：
    <span>2020</span><span>-</span><span>2</span><span>-</span><span>10</span> <span>4</span> <span>4</span><span>:</span><span>55</span><span>:</span><span>54.418</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><div><p>注意到</p>
<ul>
<li><code>Calendar</code>获取年月日这些信息变成了<code>get(int field)</code>;</li>
<li>返回的年份不必转换，返回的月份仍然要加1;</li>
<li>返回的星期要特别注意，<code>1</code>~<code>7</code>分别表示周日，周一，……，周六。</li>
</ul>
</div>
<p><code>Calendar</code>只有一种方式获取，即<code>Calendar.getInstance()</code>，而且一获取到就是当前时间。如果我们想给它设置成特定的一个日期和时间，就必须先清除所有字段：</p>
<div><pre><code><span>public</span> <span>class</span> <span>Main</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>// 当前时间:</span>
        <span>Calendar</span> c <span>=</span> <span>Calendar</span><span>.</span><span>getInstance</span><span>(</span><span>)</span><span>;</span>
        <span>// 清除所有:</span>
        c<span>.</span><span>clear</span><span>(</span><span>)</span><span>;</span>
        <span>// 设置2019年:</span>
        c<span>.</span><span>set</span><span>(</span><span>Calendar</span><span>.</span>YEAR<span>,</span> <span>2019</span><span>)</span><span>;</span>
        <span>// 设置9月:注意8表示9月:</span>
        c<span>.</span><span>set</span><span>(</span><span>Calendar</span><span>.</span>MONTH<span>,</span> <span>8</span><span>)</span><span>;</span>
        <span>// 设置2日:</span>
        c<span>.</span><span>set</span><span>(</span><span>Calendar</span><span>.</span>DATE<span>,</span> <span>2</span><span>)</span><span>;</span>
        <span>// 设置时间:</span>
        c<span>.</span><span>set</span><span>(</span><span>Calendar</span><span>.</span>HOUR_OF_DAY<span>,</span> <span>21</span><span>)</span><span>;</span>
        c<span>.</span><span>set</span><span>(</span><span>Calendar</span><span>.</span>MINUTE<span>,</span> <span>22</span><span>)</span><span>;</span>
        c<span>.</span><span>set</span><span>(</span><span>Calendar</span><span>.</span>SECOND<span>,</span> <span>23</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>new</span> <span>SimpleDateFormat</span><span>(</span><span>"yyyy-MM-dd HH:mm:ss"</span><span>)</span><span>.</span><span>format</span><span>(</span>c<span>.</span><span>getTime</span><span>(</span><span>)</span><span>)</span><span>)</span><span>;</span>
        <span>// 2019-09-02 21:22:23</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><div><p>提示</p>
<p>利用<code>Calendar.getTime()</code>可以将一个<code>Calendar</code>对象转换成<code>Date</code>对象，然后就可以用<code>SimpleDateFormat</code>进行格式化了。</p>
</div>
<br/>
<blockquote>
<h4 id="_3、timezone"> 3、TimeZone</h4>
</blockquote>
<p><code>Calendar</code>和<code>Date</code>相比，它提供了时区转换的功能。时区用<code>TimeZone</code>对象表示：</p>
<div><pre><code><span>public</span> <span>class</span> <span>Main</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>TimeZone</span> tzDefault <span>=</span> <span>TimeZone</span><span>.</span><span>getDefault</span><span>(</span><span>)</span><span>;</span> <span>// 当前时区</span>
        <span>TimeZone</span> tzGMT9 <span>=</span> <span>TimeZone</span><span>.</span><span>getTimeZone</span><span>(</span><span>"GMT+09:00"</span><span>)</span><span>;</span> <span>// GMT+9:00时区</span>
        <span>TimeZone</span> tzNY <span>=</span> <span>TimeZone</span><span>.</span><span>getTimeZone</span><span>(</span><span>"America/New_York"</span><span>)</span><span>;</span> <span>// 纽约时区</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>tzDefault<span>.</span><span>getID</span><span>(</span><span>)</span><span>)</span><span>;</span> <span>// Etc/UTC</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>tzGMT9<span>.</span><span>getID</span><span>(</span><span>)</span><span>)</span><span>;</span> <span>// GMT+09:00</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>tzNY<span>.</span><span>getID</span><span>(</span><span>)</span><span>)</span><span>;</span> <span>// America/New_York</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>时区的唯一标识是以字符串表示的ID，我们获取指定<code>TimeZone</code>对象也是以这个ID为参数获取，<code>GMT+09:00</code>、<code>Asia/Shanghai</code>都是有效的时区ID。要列出系统支持的所有ID，请使用<code>TimeZone.getAvailableIDs()</code>。</p>
<p>有了时区，我们就可以对指定时间进行转换。</p>
<p>例如，下面的例子演示了如何将北京时间<code>2019-11-20 8:15:00</code>转换为纽约时间：</p>
<div><pre><code><span>public</span> <span>class</span> <span>Main</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>// 当前时间:</span>
        <span>Calendar</span> c <span>=</span> <span>Calendar</span><span>.</span><span>getInstance</span><span>(</span><span>)</span><span>;</span>
        <span>// 清除所有:</span>
        c<span>.</span><span>clear</span><span>(</span><span>)</span><span>;</span>
        <span>// 设置为北京时区:</span>
        c<span>.</span><span>setTimeZone</span><span>(</span><span>TimeZone</span><span>.</span><span>getTimeZone</span><span>(</span><span>"Asia/Shanghai"</span><span>)</span><span>)</span><span>;</span>
        <span>// 设置年月日时分秒:</span>
        c<span>.</span><span>set</span><span>(</span><span>2019</span><span>,</span> <span>10</span> <span>/* 11月 */</span><span>,</span> <span>20</span><span>,</span> <span>8</span><span>,</span> <span>15</span><span>,</span> <span>0</span><span>)</span><span>;</span>
        <span>// 显示时间:</span>
        <span>var</span> sdf <span>=</span> <span>new</span> <span>SimpleDateFormat</span><span>(</span><span>"yyyy-MM-dd HH:mm:ss"</span><span>)</span><span>;</span>
        sdf<span>.</span><span>setTimeZone</span><span>(</span><span>TimeZone</span><span>.</span><span>getTimeZone</span><span>(</span><span>"America/New_York"</span><span>)</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>sdf<span>.</span><span>format</span><span>(</span>c<span>.</span><span>getTime</span><span>(</span><span>)</span><span>)</span><span>)</span><span>;</span> <span>// 利用Calendar.getTime()可以将一个Calendar对象转换成Date对象</span>
       
        <span>// 2019-11-19 19:15:00</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><p>可见，利用<code>Calendar</code>进行时区转换的步骤是：</p>
<ol>
<li>清除所有字段；</li>
<li>设定指定时区；</li>
<li>设定日期和时间；</li>
<li>创建<code>SimpleDateFormat</code>并设定目标时区；</li>
<li>格式化获取的<code>Date</code>对象（注意<code>Date</code>对象无时区信息，时区信息存储在<code>SimpleDateFormat</code>中）。</li>
</ol>
<p>因此，本质上时区转换只能通过<code>SimpleDateFormat</code>在显示的时候完成</p>
<p><code>Calendar</code>也可以对日期和时间进行简单的加减：</p>
<div><pre><code><span>public</span> <span>class</span> <span>Main</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>// 当前时间:</span>
        <span>Calendar</span> c <span>=</span> <span>Calendar</span><span>.</span><span>getInstance</span><span>(</span><span>)</span><span>;</span>
        <span>// 清除所有:</span>
        c<span>.</span><span>clear</span><span>(</span><span>)</span><span>;</span>
        <span>// 设置年月日时分秒:</span>
        c<span>.</span><span>set</span><span>(</span><span>2019</span><span>,</span> <span>10</span> <span>/* 11月 */</span><span>,</span> <span>20</span><span>,</span> <span>8</span><span>,</span> <span>15</span><span>,</span> <span>0</span><span>)</span><span>;</span>
        <span>// 加5天并减去2小时:</span>
        c<span>.</span><span>add</span><span>(</span><span>Calendar</span><span>.</span>DAY_OF_MONTH<span>,</span> <span>5</span><span>)</span><span>;</span>
        c<span>.</span><span>add</span><span>(</span><span>Calendar</span><span>.</span>HOUR_OF_DAY<span>,</span> <span>-</span><span>2</span><span>)</span><span>;</span>
        <span>// 显示时间:</span>
        <span>var</span> sdf <span>=</span> <span>new</span> <span>SimpleDateFormat</span><span>(</span><span>"yyyy-MM-dd HH:mm:ss"</span><span>)</span><span>;</span>
        <span>Date</span> d <span>=</span> c<span>.</span><span>getTime</span><span>(</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>sdf<span>.</span><span>format</span><span>(</span>d<span>)</span><span>)</span><span>;</span>
        <span>// 2019-11-25 6:15:00</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><h3 id="二-新api常用类型和方法"> （二）新API常用类型和方法</h3>
<p>从Java 8开始，<code>java.time</code>包提供了新的日期和时间API，主要涉及的类型有：</p>
<ul>
<li>本地日期和时间：<code>LocalDateTime</code>，<code>LocalDate</code>，<code>LocalTime</code>；</li>
<li>带时区的日期和时间：<code>ZonedDateTime</code>；</li>
<li>时刻：<code>Instant</code>；</li>
<li>时区：<code>ZoneId</code>，<code>ZoneOffset</code>；</li>
<li>时间间隔：<code>Duration</code>。</li>
</ul>
<p>以及一套新的用于取代<code>SimpleDateFormat</code>的格式化类型<code>DateTimeFormatter</code>。</p>
<p>和旧的API相比，新API严格区分了时刻、本地日期、本地时间和带时区的日期时间，并且，对日期和时间进行运算更加方便。</p>
<p>此外，新API修正了旧API不合理的常量设计：</p>
<ul>
<li>Month的范围用1~12表示1月到12月；</li>
<li>Week的范围用1~7表示周一到周日。</li>
</ul>
<p>最后，新API的类型几乎全部是不变类型（和String类似），可以放心使用不必担心被修改</p>
<blockquote>
<h4 id="_1、localdatetime"> 1、LocalDateTime</h4>
</blockquote>
<p>最常用的<code>LocalDateTime</code>，它表示一个本地日期和时间：</p>
<div><pre><code><span>public</span> <span>class</span> <span>Main</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>LocalDate</span> d <span>=</span> <span>LocalDate</span><span>.</span><span>now</span><span>(</span><span>)</span><span>;</span> <span>// 当前日期</span>
        <span>LocalTime</span> t <span>=</span> <span>LocalTime</span><span>.</span><span>now</span><span>(</span><span>)</span><span>;</span> <span>// 当前时间</span>
        <span>LocalDateTime</span> dt <span>=</span> <span>LocalDateTime</span><span>.</span><span>now</span><span>(</span><span>)</span><span>;</span> <span>// 当前日期和时间</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>d<span>)</span><span>;</span> <span>// 严格按照ISO 8601格式打印</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>t<span>)</span><span>;</span> <span>// 严格按照ISO 8601格式打印</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>dt<span>)</span><span>;</span> <span>// 严格按照ISO 8601格式打印</span>
    <span>}</span>
<span>}</span>
打印结果<span>:</span>
<span>2020</span><span>-</span><span>02</span><span>-</span><span>10</span>
<span>05</span><span>:</span><span>26</span><span>:</span><span>43.439104583</span>
<span>2020</span><span>-</span><span>02</span><span>-</span><span>10</span>T05<span>:</span><span>26</span><span>:</span><span>43.439140240</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>本地日期和时间通过now()获取到的总是以当前默认时区返回的，和旧API不同，<code>LocalDateTime</code>、<code>LocalDate</code>和<code>LocalTime</code>默认严格按照<a href="https://www.iso.org/iso-8601-date-and-time-format.html" target="_blank" rel="noopener noreferrer">ISO 8601</a>规定的日期和时间格式进行打印。</p>
<p>上述代码其实有一个小问题，在获取3个类型的时候，由于执行一行代码总会消耗一点时间，因此，3个类型的日期和时间很可能对不上（时间的毫秒数基本上不同）。为了保证获取到同一时刻的日期和时间，可以改写如下：</p>
<div><pre><code><span>LocalDateTime</span> dt <span>=</span> <span>LocalDateTime</span><span>.</span><span>now</span><span>(</span><span>)</span><span>;</span> <span>// 当前日期和时间</span>
<span>LocalDate</span> d <span>=</span> dt<span>.</span><span>toLocalDate</span><span>(</span><span>)</span><span>;</span> <span>// 转换到当前日期</span>
<span>LocalTime</span> t <span>=</span> dt<span>.</span><span>toLocalTime</span><span>(</span><span>)</span><span>;</span> <span>// 转换到当前时间</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>反过来，通过指定的日期和时间创建<code>LocalDateTime</code>可以通过<code>of()</code>方法：</p>
<div><pre><code><span>// 指定日期和时间:</span>
<span>LocalDate</span> d2 <span>=</span> <span>LocalDate</span><span>.</span><span>of</span><span>(</span><span>2019</span><span>,</span> <span>11</span><span>,</span> <span>30</span><span>)</span><span>;</span> <span>// 2019-11-30, 注意11=11月</span>
<span>LocalTime</span> t2 <span>=</span> <span>LocalTime</span><span>.</span><span>of</span><span>(</span><span>15</span><span>,</span> <span>16</span><span>,</span> <span>17</span><span>)</span><span>;</span> <span>// 15:16:17</span>
<span>LocalDateTime</span> dt2 <span>=</span> <span>LocalDateTime</span><span>.</span><span>of</span><span>(</span><span>2019</span><span>,</span> <span>11</span><span>,</span> <span>30</span><span>,</span> <span>15</span><span>,</span> <span>16</span><span>,</span> <span>17</span><span>)</span><span>;</span>
<span>LocalDateTime</span> dt3 <span>=</span> <span>LocalDateTime</span><span>.</span><span>of</span><span>(</span>d2<span>,</span> t2<span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>因为严格按照ISO 8601的格式，因此，将字符串转换为<code>LocalDateTime</code>就可以传入标准格式：</p>
<div><pre><code><span>LocalDateTime</span> dt <span>=</span> <span>LocalDateTime</span><span>.</span><span>parse</span><span>(</span><span>"2019-11-19T15:16:17"</span><span>)</span><span>;</span>
<span>LocalDate</span> d <span>=</span> <span>LocalDate</span><span>.</span><span>parse</span><span>(</span><span>"2019-11-19"</span><span>)</span><span>;</span>
<span>LocalTime</span> t <span>=</span> <span>LocalTime</span><span>.</span><span>parse</span><span>(</span><span>"15:16:17"</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>注意ISO 8601规定的日期和时间分隔符是<code>T</code>。标准格式如下：</p>
<ul>
<li>日期：yyyy-MM-dd</li>
<li>时间：HH:mm:ss</li>
<li>带毫秒的时间：HH:mm:ss.SSS</li>
<li>日期和时间：yyyy-MM-dd'T'HH:mm:ss</li>
<li>带毫秒的日期和时间：yyyy-MM-dd'T'HH:mm:ss.SSS</li>
</ul>
<p><strong>日期和时间的加减</strong></p>
<p><code>LocalDateTime</code>提供了对日期和时间进行加减的非常简单的链式调用：</p>
<div><pre><code><span>public</span> <span>class</span> <span>Main</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>LocalDateTime</span> dt <span>=</span> <span>LocalDateTime</span><span>.</span><span>of</span><span>(</span><span>2019</span><span>,</span> <span>10</span><span>,</span> <span>26</span><span>,</span> <span>20</span><span>,</span> <span>30</span><span>,</span> <span>59</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>dt<span>)</span><span>;</span>
        <span>// 加5天减3小时:</span>
        <span>LocalDateTime</span> dt2 <span>=</span> dt<span>.</span><span>plusDays</span><span>(</span><span>5</span><span>)</span><span>.</span><span>minusHours</span><span>(</span><span>3</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>dt2<span>)</span><span>;</span> <span>// 2019-10-31T17:30:59</span>
        <span>// 减1月:</span>
        <span>LocalDateTime</span> dt3 <span>=</span> dt2<span>.</span><span>minusMonths</span><span>(</span><span>1</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>dt3<span>)</span><span>;</span> <span>// 2019-09-30T17:30:59</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>注意到月份加减会自动调整日期，例如从<code>2019-10-31</code>减去1个月得到的结果是<code>2019-09-30</code>，因为9月没有31日。</p>
<p><strong>日期和时间的调整</strong></p>
<p>对日期和时间进行调整则使用<code>withXxx()</code>方法，例如：<code>withHour(15)</code>会把<code>10:11:12</code>变为<code>15:11:12</code>：</p>
<ul>
<li>调整年：withYear()</li>
<li>调整月：withMonth()</li>
<li>调整日：withDayOfMonth()</li>
<li>调整时：withHour()</li>
<li>调整分：withMinute()</li>
<li>调整秒：withSecond()</li>
</ul>
<div><pre><code><span>public</span> <span>class</span> <span>Main</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>LocalDateTime</span> dt <span>=</span> <span>LocalDateTime</span><span>.</span><span>of</span><span>(</span><span>2019</span><span>,</span> <span>10</span><span>,</span> <span>26</span><span>,</span> <span>20</span><span>,</span> <span>30</span><span>,</span> <span>59</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>dt<span>)</span><span>;</span>
        <span>// 日期变为31日:</span>
        <span>LocalDateTime</span> dt2 <span>=</span> dt<span>.</span><span>withDayOfMonth</span><span>(</span><span>31</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>dt2<span>)</span><span>;</span> <span>// 2019-10-31T20:30:59</span>
        <span>// 月份变为9:</span>
        <span>LocalDateTime</span> dt3 <span>=</span> dt2<span>.</span><span>withMonth</span><span>(</span><span>9</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>dt3<span>)</span><span>;</span> <span>// 2019-09-30T20:30:59</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>同样注意到调整月份时，会相应地调整日期，即把<code>2019-10-31</code>的月份调整为<code>9</code>时，日期也自动变为<code>30</code>。</p>
<p>实际上，<code>LocalDateTime</code>还有一个通用的<code>with()</code>方法允许我们做更复杂的运算。例如：</p>
<div><pre><code><span>public</span> <span>class</span> <span>Main</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>// 本月第一天0:00时刻:</span>
        <span>LocalDateTime</span> firstDay <span>=</span> <span>LocalDate</span><span>.</span><span>now</span><span>(</span><span>)</span><span>.</span><span>withDayOfMonth</span><span>(</span><span>1</span><span>)</span><span>.</span><span>atStartOfDay</span><span>(</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>firstDay<span>)</span><span>;</span>

        <span>// 本月最后1天:</span>
        <span>LocalDate</span> lastDay <span>=</span> <span>LocalDate</span><span>.</span><span>now</span><span>(</span><span>)</span><span>.</span><span>with</span><span>(</span><span>TemporalAdjusters</span><span>.</span><span>lastDayOfMonth</span><span>(</span><span>)</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>lastDay<span>)</span><span>;</span>

        <span>// 下月第1天:</span>
        <span>LocalDate</span> nextMonthFirstDay <span>=</span> <span>LocalDate</span><span>.</span><span>now</span><span>(</span><span>)</span><span>.</span><span>with</span><span>(</span><span>TemporalAdjusters</span><span>.</span><span>firstDayOfNextMonth</span><span>(</span><span>)</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>nextMonthFirstDay<span>)</span><span>;</span>

        <span>// 本月第1个周一:</span>
        <span>LocalDate</span> firstWeekday <span>=</span> <span>LocalDate</span><span>.</span><span>now</span><span>(</span><span>)</span><span>.</span><span>with</span><span>(</span><span>TemporalAdjusters</span><span>.</span><span>firstInMonth</span><span>(</span><span>DayOfWeek</span><span>.</span>MONDAY<span>)</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>firstWeekday<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><p>对于计算某个月第1个周日这样的问题，新的API可以轻松完成。</p>
<p>要判断两个<code>LocalDateTime</code>的先后，可以使用<code>isBefore()</code>、<code>isAfter()</code>方法，对于<code>LocalDate</code>和<code>LocalTime</code>类似：</p>
<div><pre><code><span>public</span> <span>class</span> <span>Main</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>LocalDateTime</span> now <span>=</span> <span>LocalDateTime</span><span>.</span><span>now</span><span>(</span><span>)</span><span>;</span>
        <span>LocalDateTime</span> target <span>=</span> <span>LocalDateTime</span><span>.</span><span>of</span><span>(</span><span>2019</span><span>,</span> <span>11</span><span>,</span> <span>19</span><span>,</span> <span>8</span><span>,</span> <span>15</span><span>,</span> <span>0</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>now<span>.</span><span>isBefore</span><span>(</span>target<span>)</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>LocalDate</span><span>.</span><span>now</span><span>(</span><span>)</span><span>.</span><span>isBefore</span><span>(</span><span>LocalDate</span><span>.</span><span>of</span><span>(</span><span>2019</span><span>,</span> <span>11</span><span>,</span> <span>19</span><span>)</span><span>)</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>LocalTime</span><span>.</span><span>now</span><span>(</span><span>)</span><span>.</span><span>isAfter</span><span>(</span><span>LocalTime</span><span>.</span><span>parse</span><span>(</span><span>"08:15:00"</span><span>)</span><span>)</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><div><p>提示</p>
<p>注意到<code>LocalDateTime</code>无法与时间戳进行转换，因为<code>LocalDateTime</code>没有时区，无法确定某一时刻。</p>
<p>后面要介绍的<code>ZonedDateTime</code>相当于<code>LocalDateTime</code>加时区的组合，它具有时区，可以与<code>long</code>表示的时间戳进行转换。</p>
</div>
<p><strong>自定义格式</strong></p>
<p>如果要自定义输出的格式，或者要把一个非ISO 8601格式的字符串解析成<code>LocalDateTime</code>，可以使用新的<code>DateTimeFormatter</code>：</p>
<div><pre><code><span>public</span> <span>class</span> <span>Main</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>// 自定义格式化:</span>
        <span>DateTimeFormatter</span> dtf <span>=</span> <span>DateTimeFormatter</span><span>.</span><span>ofPattern</span><span>(</span><span>"yyyy/MM/dd HH:mm:ss"</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>dtf<span>.</span><span>format</span><span>(</span><span>LocalDateTime</span><span>.</span><span>now</span><span>(</span><span>)</span><span>)</span><span>)</span><span>;</span>

        <span>// 用自定义格式解析成ISO 8601格式:</span>
        <span>LocalDateTime</span> dt2 <span>=</span> <span>LocalDateTime</span><span>.</span><span>parse</span><span>(</span><span>"2019/11/30 15:16:17"</span><span>,</span> dtf<span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>dt2<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
运行结果<span>:</span>
<span>2020</span><span>/</span><span>02</span><span>/</span><span>10</span> <span>05</span><span>:</span><span>31</span><span>:</span><span>57</span>
<span>2019</span><span>-</span><span>11</span><span>-</span><span>30</span>T15<span>:</span><span>16</span><span>:</span><span>17</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><br/>
<blockquote>
<h4 id="_2、duration和period"> 2、Duration和Period</h4>
</blockquote>
<p><code>Duration</code>表示两个时刻之间的时间间隔。另一个类似的<code>Period</code>表示两个日期之间的天数：</p>
<div><pre><code><span>public</span> <span>class</span> <span>Main</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>LocalDateTime</span> start <span>=</span> <span>LocalDateTime</span><span>.</span><span>of</span><span>(</span><span>2019</span><span>,</span> <span>11</span><span>,</span> <span>19</span><span>,</span> <span>8</span><span>,</span> <span>15</span><span>,</span> <span>0</span><span>)</span><span>;</span>
        <span>LocalDateTime</span> end <span>=</span> <span>LocalDateTime</span><span>.</span><span>of</span><span>(</span><span>2020</span><span>,</span> <span>1</span><span>,</span> <span>9</span><span>,</span> <span>19</span><span>,</span> <span>25</span><span>,</span> <span>30</span><span>)</span><span>;</span>
        <span>Duration</span> d <span>=</span> <span>Duration</span><span>.</span><span>between</span><span>(</span>start<span>,</span> end<span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>d<span>)</span><span>;</span> <span>// PT1235H10M30S</span>

        <span>Period</span> p <span>=</span> <span>LocalDate</span><span>.</span><span>of</span><span>(</span><span>2019</span><span>,</span> <span>11</span><span>,</span> <span>19</span><span>)</span><span>.</span><span>until</span><span>(</span><span>LocalDate</span><span>.</span><span>of</span><span>(</span><span>2020</span><span>,</span> <span>1</span><span>,</span> <span>9</span><span>)</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>p<span>)</span><span>;</span> <span>// P1M21D</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><ul>
<li>注意到两个<code>LocalDateTime</code>之间的差值使用<code>Duration</code>表示，类似<code>PT1235H10M30S</code>，表示1235小时10分钟30秒。</li>
<li>而两个<code>LocalDate</code>之间的差值用<code>Period</code>表示，类似<code>P1M21D</code>，表示1个月21天。</li>
</ul>
<p><code>Duration</code>和<code>Period</code>的表示方法也符合ISO 8601的格式，它以<code>P...T...</code>的形式表示，<code>P...T</code>之间表示日期间隔，<code>T</code>后面表示时间间隔。如果是<code>PT...</code>的格式表示仅有时间间隔。利用<code>ofXxx()</code>或者<code>parse()</code>方法也可以直接创建<code>Duration</code>：</p>
<div><pre><code><span>Duration</span> d1 <span>=</span> <span>Duration</span><span>.</span><span>ofHours</span><span>(</span><span>10</span><span>)</span><span>;</span> <span>// 10 hours</span>
<span>Duration</span> d2 <span>=</span> <span>Duration</span><span>.</span><span>parse</span><span>(</span><span>"P1DT2H3M"</span><span>)</span><span>;</span> <span>// 1 day, 2 hours, 3 minutes</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>有的童鞋可能发现Java 8引入的<code>java.time</code>API。怎么和一个开源的<a href="https://www.joda.org/" target="_blank" rel="noopener noreferrer">Joda Time</a>很像？难道JDK也开始抄袭开源了？其实正是因为开源的Joda Time设计很好，应用广泛，所以JDK团队邀请Joda Time的作者Stephen Colebourne共同设计了<code>java.time</code>API。</p>
<br/>
<blockquote>
<h4 id="_3、zoneddatetime"> 3、ZonedDateTime</h4>
</blockquote>
<p><code>LocalDateTime</code>总是表示本地日期和时间，要表示一个带时区的日期和时间，我们就需要<code>ZonedDateTime</code>。</p>
<p>可以简单地把<code>ZonedDateTime</code>理解成<code>LocalDateTime</code>加<code>ZoneId</code>。<code>ZoneId</code>是<code>java.time</code>引入的新的时区类，注意和旧的<code>java.util.TimeZone</code>区别。</p>
<p>要创建一个<code>ZonedDateTime</code>对象，有以下几种方法，一种是通过<code>now()</code>方法返回当前时间：</p>
<div><pre><code><span>public</span> <span>class</span> <span>Main</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>ZonedDateTime</span> zbj <span>=</span> <span>ZonedDateTime</span><span>.</span><span>now</span><span>(</span><span>)</span><span>;</span> <span>// 默认时区</span>
        <span>ZonedDateTime</span> zny <span>=</span> <span>ZonedDateTime</span><span>.</span><span>now</span><span>(</span><span>ZoneId</span><span>.</span><span>of</span><span>(</span><span>"America/New_York"</span><span>)</span><span>)</span><span>;</span> <span>// 用指定时区获取当前时间</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>zbj<span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>zny<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>观察打印的两个<code>ZonedDateTime</code>，发现它们时区不同，但表示的时间都是同一时刻（毫秒数不同是执行语句时的时间差）：</p>
<div><pre><code>2019-09-15T20:58:18.786182+08:00[Asia/Shanghai]
2019-09-15T08:58:18.788860-04:00[America/New_York]
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>另一种方式是通过给一个<code>LocalDateTime</code>附加一个<code>ZoneId</code>，就可以变成<code>ZonedDateTime</code>：</p>
<div><pre><code><span>public</span> <span>class</span> <span>Main</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>LocalDateTime</span> ldt <span>=</span> <span>LocalDateTime</span><span>.</span><span>of</span><span>(</span><span>2019</span><span>,</span> <span>9</span><span>,</span> <span>15</span><span>,</span> <span>15</span><span>,</span> <span>16</span><span>,</span> <span>17</span><span>)</span><span>;</span>
        <span>ZonedDateTime</span> zbj <span>=</span> ldt<span>.</span><span>atZone</span><span>(</span><span>ZoneId</span><span>.</span><span>systemDefault</span><span>(</span><span>)</span><span>)</span><span>;</span>
        <span>ZonedDateTime</span> zny <span>=</span> ldt<span>.</span><span>atZone</span><span>(</span><span>ZoneId</span><span>.</span><span>of</span><span>(</span><span>"America/New_York"</span><span>)</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>zbj<span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>zny<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>以这种方式创建的<code>ZonedDateTime</code>，它的日期和时间与<code>LocalDateTime</code>相同，但附加的时区不同，因此是两个不同的时刻：</p>
<div><pre><code>2019-09-15T15:16:17+08:00[Asia/Shanghai]
2019-09-15T15:16:17-04:00[America/New_York]
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><strong>时区转换</strong></p>
<p>要转换时区，首先我们需要有一个<code>ZonedDateTime</code>对象，然后，通过<code>withZoneSameInstant()</code>将关联时区转换到另一个时区，转换后日期和时间都会相应调整。</p>
<p>下面的代码演示了如何将北京时间转换为纽约时间：</p>
<div><pre><code><span>public</span> <span>class</span> <span>Main</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>// 以中国时区获取当前时间:</span>
        <span>ZonedDateTime</span> zbj <span>=</span> <span>ZonedDateTime</span><span>.</span><span>now</span><span>(</span><span>ZoneId</span><span>.</span><span>of</span><span>(</span><span>"Asia/Shanghai"</span><span>)</span><span>)</span><span>;</span>
        <span>// 转换为纽约时间:</span>
        <span>ZonedDateTime</span> zny <span>=</span> zbj<span>.</span><span>withZoneSameInstant</span><span>(</span><span>ZoneId</span><span>.</span><span>of</span><span>(</span><span>"America/New_York"</span><span>)</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>zbj<span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>zny<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>要特别注意，时区转换的时候，由于夏令时的存在，不同的日期转换的结果很可能是不同的。这是北京时间9月15日的转换结果：</p>
<div><pre><code>2019-09-15T21:05:50.187697+08:00[Asia/Shanghai]
2019-09-15T09:05:50.187697-04:00[America/New_York]
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>这是北京时间11月15日的转换结果：</p>
<div><pre><code>2019-11-15T21:05:50.187697+08:00[Asia/Shanghai]
2019-11-15T08:05:50.187697-05:00[America/New_York]
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>两次转换后的纽约时间有1小时的夏令时时差。</p>
<p>涉及到时区时，千万不要自己计算时差，否则难以正确处理夏令时。</p>
<p>有了<code>ZonedDateTime</code>，将其转换为本地时间就非常简单：</p>
<div><pre><code>ZonedDateTime zdt = ...
LocalDateTime ldt = zdt.toLocalDateTime();
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>转换为<code>LocalDateTime</code>时，直接丢弃了时区信息。</p>
<blockquote>
<h4 id="_4、datetimeformatter"> 4、DateTimeFormatter</h4>
</blockquote>
<p>使用旧的<code>Date</code>对象时，我们用<code>SimpleDateFormat</code>进行格式化显示。使用新的<code>LocalDateTime</code>或<code>ZonedLocalDateTime</code>时，我们要进行格式化显示，就要使用<code>DateTimeFormatter</code>。</p>
<p>和<code>SimpleDateFormat</code>不同的是，<code>DateTimeFormatter</code>不但是不变对象，它还是线程安全的。因为<code>SimpleDateFormat</code>不是线程安全的，使用的时候，只能在方法内部创建新的局部变量。而<code>DateTimeFormatter</code>可以只创建一个实例，到处引用。</p>
<p>创建<code>DateTimeFormatter</code>时，我们仍然通过传入格式化字符串实现：</p>
<div><pre><code><span>DateTimeFormatter</span> formatter <span>=</span> <span>DateTimeFormatter</span><span>.</span><span>ofPattern</span><span>(</span><span>"yyyy-MM-dd HH:mm"</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div><p>格式化字符串的使用方式与<code>SimpleDateFormat</code>完全一致。</p>
<p>另一种创建<code>DateTimeFormatter</code>的方法是，传入格式化字符串时，同时指定<code>Locale</code>：</p>
<div><pre><code><span>DateTimeFormatter</span> formatter <span>=</span> <span>DateTimeFormatter</span><span>.</span><span>ofPattern</span><span>(</span><span>"E, yyyy-MMMM-dd HH:mm"</span><span>,</span> <span>Locale</span><span>.</span>US<span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div><p>这种方式可以按照<code>Locale</code>默认习惯格式化。我们来看实际效果：</p>
<div><pre><code><span>public</span> <span>class</span> <span>Main</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>ZonedDateTime</span> zdt <span>=</span> <span>ZonedDateTime</span><span>.</span><span>now</span><span>(</span><span>)</span><span>;</span>
        <span>var</span> formatter <span>=</span> <span>DateTimeFormatter</span><span>.</span><span>ofPattern</span><span>(</span><span>"yyyy-MM-dd'T'HH:mm ZZZZ"</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>formatter<span>.</span><span>format</span><span>(</span>zdt<span>)</span><span>)</span><span>;</span>

        <span>var</span> zhFormatter <span>=</span> <span>DateTimeFormatter</span><span>.</span><span>ofPattern</span><span>(</span><span>"yyyy MMM dd EE HH:mm"</span><span>,</span> <span>Locale</span><span>.</span>CHINA<span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>zhFormatter<span>.</span><span>format</span><span>(</span>zdt<span>)</span><span>)</span><span>;</span>

        <span>var</span> usFormatter <span>=</span> <span>DateTimeFormatter</span><span>.</span><span>ofPattern</span><span>(</span><span>"E, MMMM/dd/yyyy HH:mm"</span><span>,</span> <span>Locale</span><span>.</span>US<span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>usFormatter<span>.</span><span>format</span><span>(</span>zdt<span>)</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>在格式化字符串中，如果需要输出固定字符，可以用<code>'xxx'</code>表示。</p>
<p>运行上述代码，分别以默认方式、中国地区和美国地区对当前时间进行显示，结果如下：</p>
<div><pre><code>2019-09-15T23:16 GMT+08:00
2019 9月 15 周日 23:16
Sun, September/15/2019 23:16
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>当我们直接调用<code>System.out.println()</code>对一个<code>ZonedDateTime</code>或者<code>LocalDateTime</code>实例进行打印的时候，实际上，调用的是它们的<code>toString()</code>方法，默认的<code>toString()</code>方法显示的字符串就是按照<code>ISO 8601</code>格式显示的，我们可以通过<code>DateTimeFormatter</code>预定义的几个静态变量来引用：</p>
<div><pre><code>var ldt = LocalDateTime.now();
System.out.println(DateTimeFormatter.ISO_DATE.format(ldt));
System.out.println(DateTimeFormatter.ISO_DATE_TIME.format(ldt));
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>得到的输出和<code>toString()</code>类似：</p>
<div><pre><code>2019-09-15
2019-09-15T23:16:51.56217
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><br/>
<blockquote>
<h4 id="_5、instant"> 5、Instant</h4>
</blockquote>
<p>我们已经讲过，计算机存储的当前时间，本质上只是一个不断递增的整数。Java提供的<code>System.currentTimeMillis()</code>返回的就是以毫秒表示的当前时间戳。</p>
<p>这个当前时间戳在<code>java.time</code>中以<code>Instant</code>类型表示，我们用<code>Instant.now()</code>获取当前时间戳，效果和<code>System.currentTimeMillis()</code>类似：</p>
<div><pre><code><span>public</span> <span>class</span> <span>Main</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>Instant</span> now <span>=</span> <span>Instant</span><span>.</span><span>now</span><span>(</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>now<span>.</span><span>getEpochSecond</span><span>(</span><span>)</span><span>)</span><span>;</span> <span>// 秒</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>now<span>.</span><span>toEpochMilli</span><span>(</span><span>)</span><span>)</span><span>;</span> <span>// 毫秒</span>
    <span>}</span>
<span>}</span>
打印的结果类似：
<span>1568568760</span>
<span>1568568760316</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>实际上，<code>Instant</code>内部只有两个核心字段：</p>
<div><pre><code>public final class Instant implements ... {
    private final long seconds;
    private final int nanos;
}
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>一个是以秒为单位的时间戳，一个是更精确的纳秒精度。它和<code>System.currentTimeMillis()</code>返回的<code>long</code>相比，只是多了更高精度的纳秒。</p>
<p>既然<code>Instant</code>就是时间戳，那么，给它附加上一个时区，就可以创建出<code>ZonedDateTime</code>：</p>
<div><pre><code><span>// 以指定时间戳创建Instant:</span>
<span>Instant</span> ins <span>=</span> <span>Instant</span><span>.</span><span>ofEpochSecond</span><span>(</span><span>1568568760</span><span>)</span><span>;</span>
<span>ZonedDateTime</span> zdt <span>=</span> ins<span>.</span><span>atZone</span><span>(</span><span>ZoneId</span><span>.</span><span>systemDefault</span><span>(</span><span>)</span><span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>zdt<span>)</span><span>;</span> <span>// 2019-09-16T01:32:40+08:00[Asia/Shanghai]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>可见，对于某一个时间戳，给它关联上指定的<code>ZoneId</code>，就得到了<code>ZonedDateTime</code>，继而可以获得了对应时区的<code>LocalDateTime</code>。</p>
<p>所以，<code>LocalDateTime</code>，<code>ZoneId</code>，<code>Instant</code>，<code>ZonedDateTime</code>和<code>long</code>都可以互相转换：</p>
<div><pre><code>┌─────────────┐
│LocalDateTime│────┐
└─────────────┘    │    ┌─────────────┐
                   ├───&gt;│ZonedDateTime│
┌─────────────┐    │    └─────────────┘
│   ZoneId    │────┘           ▲
└─────────────┘      ┌─────────┴─────────┐
                     │                   │
                     ▼                   ▼
              ┌─────────────┐     ┌─────────────┐
              │   Instant   │&lt;───&gt;│    long     │
              └─────────────┘     └─────────────┘
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>转换的时候，只需要留意<code>long</code>类型以毫秒还是秒为单位即可。</p>
<h3 id="三-旧api-──-新api"> （三）旧API&lt;──&gt;新API</h3>
<p>由于Java提供了新旧两套日期和时间的API，除非涉及到遗留代码，否则我们应该坚持使用新的API。</p>
<p>如果需要与遗留代码打交道，如何在新旧API之间互相转换呢？</p>
<blockquote>
<h4 id="_1、旧api转新api"> 1、旧API转新API</h4>
</blockquote>
<p>如果要把旧式的<code>Date</code>或<code>Calendar</code>转换为新API对象，可以通过<code>toInstant()</code>方法转换为<code>Instant</code>对象，再继续转换为<code>ZonedDateTime</code>：</p>
<div><pre><code><span>// Date -> Instant:</span>
<span>Instant</span> ins1 <span>=</span> <span>new</span> <span>Date</span><span>(</span><span>)</span><span>.</span><span>toInstant</span><span>(</span><span>)</span><span>;</span>

<span>// Calendar -> Instant -> ZonedDateTime:</span>
<span>Calendar</span> calendar <span>=</span> <span>Calendar</span><span>.</span><span>getInstance</span><span>(</span><span>)</span><span>;</span>
<span>Instant</span> ins2 <span>=</span> calendar<span>.</span><span>toInstant</span><span>(</span><span>)</span><span>;</span>
<span>ZonedDateTime</span> zdt <span>=</span> ins2<span>.</span><span>atZone</span><span>(</span>calendar<span>.</span><span>getTimeZone</span><span>(</span><span>)</span><span>.</span><span>toZoneId</span><span>(</span><span>)</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>从上面的代码还可以看到，旧的<code>TimeZone</code>提供了一个<code>toZoneId()</code>，可以把自己变成新的<code>ZoneId</code>。</p>
<br/>
<blockquote>
<h4 id="_2、新api转旧api"> 2、新API转旧API</h4>
</blockquote>
<p>如果要把新的<code>ZonedDateTime</code>转换为旧的API对象，只能借助<code>long</code>型时间戳做一个“中转”：</p>
<div><pre><code>// ZonedDateTime -&gt; long:
ZonedDateTime zdt = ZonedDateTime.now();
long ts = zdt.toEpochSecond() * 1000;

// long -&gt; Date:
Date date = new Date(ts);

// long -&gt; Calendar:
Calendar calendar = Calendar.getInstance();
calendar.clear();
calendar.setTimeZone(TimeZone.getTimeZone(zdt.getZone().getId()));
calendar.setTimeInMillis(zdt.toEpochSecond() * 1000);
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>从上面的代码还可以看到，新的<code>ZoneId</code>转换为旧的<code>TimeZone</code>，需要借助<code>ZoneId.getId()</code>返回的<code>String</code>完成。</p>
<br/>
<blockquote>
<h4 id="_3、在数据库中存储日期和时间"> 3、在数据库中存储日期和时间</h4>
</blockquote>
<p>除了旧式的<code>java.util.Date</code>，我们还可以找到另一个<code>java.sql.Date</code>，它继承自<code>java.util.Date</code>，但会自动忽略所有时间相关信息,仅保留日期。这个奇葩的设计原因要追溯到数据库的日期与时间类型。</p>
<p>在数据库中，也存在几种日期和时间类型：</p>
<ul>
<li><code>DATETIME</code>：表示日期和时间；</li>
<li><code>DATE</code>：仅表示日期；</li>
<li><code>TIME</code>：仅表示时间；</li>
<li><code>TIMESTAMP</code>：和<code>DATETIME</code>类似，但是数据库会在创建或者更新记录的时候同时修改<code>TIMESTAMP</code>。</li>
</ul>
<p>在使用Java程序操作数据库时，我们需要把数据库类型与Java类型映射起来。下表是数据库类型与Java新旧API的映射关系：</p>
<table>
<thead>
<tr>
<th style="text-align:left">数据库</th>
<th style="text-align:left">对应Java类（旧）</th>
<th style="text-align:left">对应Java类（新）</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">DATETIME</td>
<td style="text-align:left">java.util.Date</td>
<td style="text-align:left">LocalDateTime</td>
</tr>
<tr>
<td style="text-align:left">DATE</td>
<td style="text-align:left">java.sql.Date</td>
<td style="text-align:left">LocalDate</td>
</tr>
<tr>
<td style="text-align:left">TIME</td>
<td style="text-align:left">java.sql.Time</td>
<td style="text-align:left">LocalTime</td>
</tr>
<tr>
<td style="text-align:left">TIMESTAMP</td>
<td style="text-align:left">java.sql.Timestamp</td>
<td style="text-align:left">LocalDateTime</td>
</tr>
</tbody>
</table>
<p>实际上，在数据库中，我们需要存储的最常用的是时刻（<code>Instant</code>），因为有了时刻信息，就可以根据用户自己选择的时区，显示出正确的本地时间。所以，最好的方法是直接用长整数<code>long</code>表示，在数据库中存储为<code>BIGINT</code>类型。</p>
<p>通过存储一个<code>long</code>型时间戳，我们可以编写一个<code>timestampToString()</code>的方法，非常简单地为不同用户以不同的偏好来显示不同的本地时间：</p>
<h2 id="总结"> 总结</h2>
<p><strong>基本概念:</strong></p>
<ul>
<li>在编写日期和时间的程序前，我们要准确理解日期、时间和时刻的概念</li>
<li>由于存在本地时间，我们需要理解时区的概念，并且必须牢记由于夏令时的存在，同一地区用<code>GMT/UTC</code>和城市表示的时区可能导致时间不同</li>
<li>计算机通过<code>Locale</code>来针对当地用户习惯格式化日期、时间、数字、货币等</li>
</ul>
<p><strong>存储和表示：</strong></p>
<ul>
<li>
<p>计算机表示的时间是以整数表示的时间戳存储的，即<code>Epoch Time</code></p>
</li>
<li>
<p>Java使用<code>long</code>型来表示以毫秒为单位的时间戳，可以通过<code>System.currentTimeMillis()</code>获取当前时间戳</p>
</li>
<li>
<p>Java有两套日期和时间的API：</p>
<ul>
<li>
<p>旧的Date、Calendar和TimeZone；</p>
</li>
<li>
<p>新的LocalDateTime、ZonedDateTime、ZoneId等</p>
</li>
</ul>
<p>分别位于<code>java.util</code>和<code>java.time</code>包中</p>
</li>
</ul>
<p><strong>标准库API：</strong></p>
<ul>
<li>
<p>Java 8引入了新的日期和时间API，它们是不变类，默认按ISO 8601标准格式化和解析</p>
</li>
<li>
<p>使用<code>LocalDateTime</code>可以非常方便地对日期和时间进行加减，或者调整日期和时间，它总是返回新对象</p>
</li>
<li>
<p>使用<code>isBefore()</code>和<code>isAfter()</code>可以判断日期和时间的先后</p>
</li>
<li>
<p>使用<code>Duration</code>和<code>Period</code>可以表示两个日期和时间的“区间间隔”</p>
</li>
<li>
<p><code>ZonedDateTime</code>是带时区的日期和时间，可用于时区转换</p>
</li>
<li>
<p><code>ZonedDateTime</code>和<code>LocalDateTime</code>可以相互转换</p>
</li>
<li>
<p>对<code>ZonedDateTime</code>或<code>LocalDateTime</code>进行格式化，需要使用<code>DateTimeFormatter</code>类</p>
</li>
<li>
<p><code>DateTimeFormatter</code>可以通过格式化字符串和<code>Locale</code>对日期和时间进行定制输出</p>
</li>
<li>
<p><code>Instant</code>表示高精度时间戳，它可以和<code>ZonedDateTime</code>以及<code>long</code>互相转换</p>
</li>
<li>
<p>处理日期和时间时，尽量使用新的<code>java.time</code>包</p>
</li>
<li>
<p>在数据库中存储时间戳时，尽量使用<code>long</code>型时间戳，它具有省空间，效率高，不依赖数据库的优点</p>
</li>
</ul>
<h2 id="练习"> 练习</h2>
<p>1、某航线从北京飞到纽约需要13小时20分钟，请根据北京起飞日期和时间计算到达纽约的当地日期和时间。</p>
<div><pre><code><span>public</span> <span>class</span> <span>Main</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>LocalDateTime</span> departureAtBeijing <span>=</span> <span>LocalDateTime</span><span>.</span><span>of</span><span>(</span><span>2019</span><span>,</span> <span>9</span><span>,</span> <span>15</span><span>,</span> <span>13</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>)</span><span>;</span>
        <span>int</span> hours <span>=</span> <span>13</span><span>;</span>
        <span>int</span> minutes <span>=</span> <span>20</span><span>;</span>
        <span>LocalDateTime</span> arrivalAtNewYork <span>=</span> <span>calculateArrivalAtNY</span><span>(</span>departureAtBeijing<span>,</span> hours<span>,</span> minutes<span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>departureAtBeijing <span>+</span> <span>" -> "</span> <span>+</span> arrivalAtNewYork<span>)</span><span>;</span>
        <span>// test:</span>
        <span>if</span> <span>(</span><span>!</span><span>LocalDateTime</span><span>.</span><span>of</span><span>(</span><span>2019</span><span>,</span> <span>10</span><span>,</span> <span>15</span><span>,</span> <span>14</span><span>,</span> <span>20</span><span>,</span> <span>0</span><span>)</span>
                <span>.</span><span>equals</span><span>(</span><span>calculateArrivalAtNY</span><span>(</span><span>LocalDateTime</span><span>.</span><span>of</span><span>(</span><span>2019</span><span>,</span> <span>10</span><span>,</span> <span>15</span><span>,</span> <span>13</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>)</span><span>,</span> <span>13</span><span>,</span> <span>20</span><span>)</span><span>)</span><span>)</span> <span>{</span>
            <span>System</span><span>.</span>err<span>.</span><span>println</span><span>(</span><span>"测试失败!"</span><span>)</span><span>;</span>
        <span>}</span> <span>else</span> <span>if</span> <span>(</span><span>!</span><span>LocalDateTime</span><span>.</span><span>of</span><span>(</span><span>2019</span><span>,</span> <span>11</span><span>,</span> <span>15</span><span>,</span> <span>13</span><span>,</span> <span>20</span><span>,</span> <span>0</span><span>)</span>
                <span>.</span><span>equals</span><span>(</span><span>calculateArrivalAtNY</span><span>(</span><span>LocalDateTime</span><span>.</span><span>of</span><span>(</span><span>2019</span><span>,</span> <span>11</span><span>,</span> <span>15</span><span>,</span> <span>13</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>)</span><span>,</span> <span>13</span><span>,</span> <span>20</span><span>)</span><span>)</span><span>)</span> <span>{</span>
            <span>System</span><span>.</span>err<span>.</span><span>println</span><span>(</span><span>"测试失败!"</span><span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>

    <span>static</span> <span>LocalDateTime</span> <span>calculateArrivalAtNY</span><span>(</span><span>LocalDateTime</span> bj<span>,</span> <span>int</span> h<span>,</span> <span>int</span> m<span>)</span> <span>{</span>
        <span>return</span> bj<span>.</span><span>atZone</span><span>(</span><span>ZoneId</span><span>.</span><span>of</span><span>(</span><span>"Asia/Shanghai"</span><span>)</span><span>)</span><span>.</span><span>withZoneSameInstant</span><span>(</span><span>ZoneId</span><span>.</span><span>of</span><span>(</span><span>"America/New_York"</span><span>)</span><span>)</span><span>.</span><span>plusHours</span><span>(</span>h<span>)</span><span>.</span><span>plusMinutes</span><span>(</span>m<span>)</span><span>.</span><span>toLocalDateTime</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><div><p>整理自</p>
<p><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1255943660631584" target="_blank" rel="noopener noreferrer">Java教程 - 日期与时间</a></p>
</div>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <category term="Java"/>
    <contributor>
      <name>南辞</name>
    </contributor>
    <published>2021-02-16T17:39:43.000Z</published>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">编程语言</title>
    <id>http://qiqi.dreamagain.top/program/backend/language/</id>
    <link href="http://qiqi.dreamagain.top/program/backend/language/"/>
    <updated>2021-02-16T17:39:43.000Z</updated>
    <content type="html"><![CDATA[<h2 id="一、如何快速入门"> 一、如何快速入门</h2>
<p>一门编程语言的入门学习最好参考网上优质网站教程、视频教程和参考书籍，尤其对于有编程基础的人而言，通过网站教程和参考书是最快的入门方式，虽然没有视频教程来得直观，但是学完后印象会比较深刻。</p>
<div><p>提示</p>
<p>学习一门语言的基本顺序是:</p>
<ul>
<li>了解数据结构</li>
<li>了解变量声明与赋值</li>
<li>了解判断和循环体结构</li>
<li>了解函数声明</li>
<li>了解输入输出</li>
</ul>
</div>
<h2 id="二、java"> 二、<a href="./java/">Java</a></h2>
<h3 id="一-学习教程"> （一）学习教程</h3>
<h4 id="网站"> 网站：</h4>
<ul>
<li><a href="https://www.liaoxuefeng.com/wiki/1252599548343744" target="_blank" rel="noopener noreferrer">廖雪峰 - Java教程</a> <MyBadge text="真大佬" /><MyBadge text="推荐" /></li>
<li><a href="https://www.runoob.com/java/java-tutorial.html" target="_blank" rel="noopener noreferrer">菜鸟教程</a> <MyBadge text="内容比较新" /></li>
<li><a href="https://www.w3cschool.cn/java/" target="_blank" rel="noopener noreferrer">w3cschool</a> <MyBadge text="内容最新" /> <MyBadge text="有手机APP" /> <MyBadge text="广告信息多" type="warn" /></li>
<li><a href="https://www.sxt.cn/Java_jQuery_in_action/History_Direction.html" target="_blank" rel="noopener noreferrer">速学堂 Java教程</a><MyBadge text="内容比较简洁" /> <MyBadge text="需结合视频学习" /></li>
</ul>
<h4 id="视频"> 视频</h4>
<ul>
<li><a href="https://www.bilibili.com/video/BV1Kb411W75N" target="_blank" rel="noopener noreferrer">宋红康老师 - Java零基础教程</a></li>
<li><a href="https://www.bilibili.com/video/BV137411V7Y1?from=search&amp;seid=12229606472951180090" target="_blank" rel="noopener noreferrer">尚学堂 - Java教程</a></li>
<li><a href="https://www.bilibili.com/video/BV187411B7iv?from=search&amp;seid=6206316045477009865" target="_blank" rel="noopener noreferrer">圣思园张龙 - 深入理解JVM虚拟机</a></li>
</ul>
<h3 id="二-学习笔记"> （二）学习笔记</h3>
<p>Java基础重点掌握面向对象、泛型、集合、IO流、反射、异常处理、多线程</p>
<ul>
<li><a href="./java/generics.html">JavaSE 泛型</a></li>
<li><a href="./java/collection.html">JavaSE 集合</a></li>
<li><a href="./java/annotation.html">JavaSE 注解</a></li>
</ul>
<h3 id="三-基础知识-面试"> （三）基础知识/面试</h3>
<p>因为我们平时都是基于框架编程，有的基础知识时间长后很容易忘记。 虽然网上分享的面试题总结都是为了营销，但用来查缺补漏也不失为一种不错的方式。整理自互联网，仅供参考</p>
<ul>
<li><a href="./java/solution/Java基础.html">Java基础</a></li>
<li><a href="./java/solution/Java进阶.html">Java进阶</a></li>
</ul>
<h2 id="三、python"> 三、Python</h2>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <category term="编程语言"/>
    <contributor>
      <name>南辞</name>
    </contributor>
    <published>2021-02-16T17:39:43.000Z</published>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">后端指南</title>
    <id>http://qiqi.dreamagain.top/program/backend/</id>
    <link href="http://qiqi.dreamagain.top/program/backend/"/>
    <updated>2021-02-18T01:11:00.000Z</updated>
    <summary type="html"><![CDATA[<blockquote>
<p><img src="https://img.shields.io/badge/%E5%90%8E%E7%AB%AF-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80-blue.svg" alt="img">   <img src="https://img.shields.io/badge/%E5%90%8E%E7%AB%AF-%E6%A1%86%E6%9E%B6-blue.svg" alt="img"></p>
</blockquote>
]]></summary>
    <content type="html"><![CDATA[<blockquote>
<p><img src="https://img.shields.io/badge/%E5%90%8E%E7%AB%AF-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80-blue.svg" alt="img">   <img src="https://img.shields.io/badge/%E5%90%8E%E7%AB%AF-%E6%A1%86%E6%9E%B6-blue.svg" alt="img"></p>
</blockquote>

<h2 id="编程语言"> 编程语言</h2>
<ul>
<li><a href="./java/">Java</a></li>
</ul>
<h2 id="后端框架"> 后端框架</h2>
<ul>
<li><a href="./backframe/spring.html">Spring framework</a></li>
</ul>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <contributor>
      <name>南辞</name>
    </contributor>
    <published>2021-02-16T17:39:43.000Z</published>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">JavaScript</title>
    <id>http://qiqi.dreamagain.top/program/frontend/js/</id>
    <link href="http://qiqi.dreamagain.top/program/frontend/js/"/>
    <updated>2021-02-16T17:39:43.000Z</updated>
    <content type="html"><![CDATA[<h2 id="初学者教程"> 初学者教程</h2>
<ul>
<li><a href="./../language/js/guide/">快速上手</a></li>
</ul>
<h3 id="javascript-手册"> JavaScript 手册</h3>
<ul>
<li><a href="./../language/js/">JavaScript 学习教程</a></li>
</ul>
<h3 id="在线教程"> 在线教程</h3>
<ul>
<li>
<p><a href="http://www.w3school.com.cn/js/index.asp" target="_blank" rel="noopener noreferrer">W3School 教程</a></p>
</li>
<li>
<p><a href="https://www.runoob.com/js/js-tutorial.html" target="_blank" rel="noopener noreferrer">菜鸟教程</a></p>
</li>
<li>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript" target="_blank" rel="noopener noreferrer">MDN 教程</a></p>
</li>
</ul>
<h3 id="es6"> ES6</h3>
<p>ES6 是 JavaScript 的 2015 标注，现已基本被广泛使用和支持；</p>
<ul>
<li><a href="./../language/js/es6/">ES6 教程</a></li>
</ul>
<div><p>提示</p>
<p>此教程由阮一峰老师书写(<strong>真·大佬</strong>)，建议深刻理解 JavaScript 原理(大概一年左右)之后再看。</p>
</div>
<blockquote>
<p>开始下一章学习前，您需要跳转到 <a href="./../language/js/guide/">JS 快速入门章节</a> 了解 JavaScript，或 <a href="./../language/js/">深入学习 JavaScript</a> 后，方能进入 jQuery 学习。</p>
</blockquote>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <category term="JavaScript"/>
    <contributor>
      <name>南辞</name>
    </contributor>
    <published>2019-09-01T00:00:00.000Z</published>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">前端指南</title>
    <id>http://qiqi.dreamagain.top/program/frontend/</id>
    <link href="http://qiqi.dreamagain.top/program/frontend/"/>
    <updated>2021-02-16T17:39:43.000Z</updated>
    <summary type="html"><![CDATA[<blockquote>
<p><img src="https://img.shields.io/badge/%E5%89%8D%E7%AB%AF-HTML-blue.svg" alt="img"> <img src="https://img.shields.io/badge/%E5%89%8D%E7%AB%AF-CSSL-blue.svg" alt="img"> <img src="https://img.shields.io/badge/%E5%89%8D%E7%AB%AF-JavaScript-blue.svg" alt="img"> <img src="https://img.shields.io/badge/%E5%89%8D%E7%AB%AF-jQuery-blue.svg" alt="img">  <img src="https://img.shields.io/badge/%E6%A1%86%E6%9E%B6-Vue-blue.svg" alt="img"> <img src="https://img.shields.io/badge/%E6%A1%86%E6%9E%B6-React-blue.svg" alt="img"> <img src="https://img.shields.io/badge/%E6%A1%86%E6%9E%B6-Angular-blue.svg" alt="img"></p>
</blockquote>
]]></summary>
    <content type="html"><![CDATA[<blockquote>
<p><img src="https://img.shields.io/badge/%E5%89%8D%E7%AB%AF-HTML-blue.svg" alt="img"> <img src="https://img.shields.io/badge/%E5%89%8D%E7%AB%AF-CSSL-blue.svg" alt="img"> <img src="https://img.shields.io/badge/%E5%89%8D%E7%AB%AF-JavaScript-blue.svg" alt="img"> <img src="https://img.shields.io/badge/%E5%89%8D%E7%AB%AF-jQuery-blue.svg" alt="img">  <img src="https://img.shields.io/badge/%E6%A1%86%E6%9E%B6-Vue-blue.svg" alt="img"> <img src="https://img.shields.io/badge/%E6%A1%86%E6%9E%B6-React-blue.svg" alt="img"> <img src="https://img.shields.io/badge/%E6%A1%86%E6%9E%B6-Angular-blue.svg" alt="img"></p>
</blockquote>

<p>编写前端网页需要掌握三件套: <strong>HTML</strong>、<strong>CSS</strong> 和 <strong>JavaScript</strong>。</p>
<ol>
<li>HTML 定义了网页的内容</li>
<li>CSS 描述了网页的样式</li>
<li>JavaScript 编写网页的行为</li>
</ol>
<div><p>提示</p>
<p>一个大型的网站，很少是直接使用原生代码写的。</p>
<p>最新的网站大多数都是用三大框架(、、)搭建，并引入 npm 上的 UI 库编写而成。</p>
<p>稍微老的网站会使用其他框架作为辅助，比如、等。</p>
</div>
<div><p>网页标准指定</p>
<p>互联网网页标准由 W3C 组织制定，它的全称是万维网联盟组织。</p>
</div>
<h2 id="html"> HTML</h2>
<p>HTML 指的是超文本标记语言 (Hyper Text Markup Language)，描述了网页的骨架(具体结构)。</p>
<ul>
<li><a href="./html/">HTML 教程</a></li>
</ul>
<h2 id="css"> CSS</h2>
<p>CSS 指层叠样式表 (Cascading Style Sheets)，声明了网页的样式(具体布局)。</p>
<ul>
<li><a href="./css/">CSS 教程</a></li>
</ul>
<h2 id="emmet"> Emmet</h2>
<p>Emmet 是一种快速输入 HTML 和 CSS 的语法。</p>
<ul>
<li><a href="./emmet/">Emmet 用法介绍</a></li>
</ul>
<h2 id="javascript"> JavaScript</h2>
<p>JavaScript 是一种编程语言，声明了网页的交互逻辑。</p>
<p>JavaScript 是一种轻量级的编程语言，为可插入 HTML 页面的编程代码。所有现代的 HTML 页面都使用 JavaScript。</p>
<ul>
<li><a href="./js.html">JS 教程</a></li>
</ul>
<h3 id="typescript"> TypeScript</h3>
<p>TypeScript 是 JavaScript 的一个超集，使得 JS 变成了一种强定义语言。TypeScript 由于其诸多优良特性，目前在前端的份额越来越大。</p>
<ul>
<li><a href="./../language/typescript/">TypeScript 教程</a></li>
</ul>
<h2 id="node-js"> Node.js</h2>
<p>在深入了解并进行前端开发后，就避不开 Node。</p>
<p>Node.js 是一款全球使用广泛的框架，可以用在前端与后端上，拥有大量的模块。Node.js 主要以其丰富并及其容易导入的 Node.js package，以及其方便管理 npm (Node.js Package Manager)闻名。</p>
<ul>
<li><a href="./src/program/language/node.js/">Node.js 教程</a></li>
</ul>
<h2 id="历史前端框架"> 历史前端框架</h2>
<h3 id="jquery"> jQuery</h3>
<p>jQuery 是一个 JavaScript 库，极大地简化了 JavaScript 编程，很容易学习。</p>
<p>jQuery 的优势在于它能够在互联网发展早期兼容各式各样的浏览器，并轻松的选定与操作 DOM。</p>
<p>由于 NVVM 的兴起，目前 jQuery 已逐步被前端三大框架所取代。</p>
<ul>
<li>
<p><a href="./jQuery/">jQuery 教程</a></p>
</li>
<li>
<p><a href="http://www.w3school.com.cn/jquery/index.asp" target="_blank" rel="noopener noreferrer">W3School</a></p>
</li>
<li>
<p><a href="https://www.runoob.com/jquery/jquery-tutorial.html" target="_blank" rel="noopener noreferrer">菜鸟教程</a></p>
</li>
</ul>
<h3 id="bootstrap4"> Bootstrap4</h3>
<p>Bootstrap 是全球最受欢迎的前端组件库，用于开发响应式布局、移动设备优先的 WEB 项目。</p>
<p>Bootstrap 是一套用于 HTML、CSS 和 JS 开发的开源工具集。利用提供的 Sass 变量和大量 mixin、响应式栅格系统、可扩展的预制组件、基于 jQuery 的强大的插件系统，能够快速为您的想法开发出原型或者构建整个 app 。</p>
<ul>
<li>
<p><a href="https://getbootstrap.com/docs/4.1/getting-started/introduction/" target="_blank" rel="noopener noreferrer">bootstrap 官方文档</a></p>
</li>
<li>
<p><a href="https://v4.bootcss.com/docs/4.0/getting-started/introduction/" target="_blank" rel="noopener noreferrer">bootstrap 4.0 中文文档</a></p>
</li>
</ul>
<h2 id="现代前端框架"> 现代前端框架</h2>
<h3 id="vue"> Vue</h3>
<p>Vue 是一套轻量化的前端渐进式框架框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。</p>
<p>Vue 与 React、Angular 一起合称前端三大框架。</p>
<ul>
<li>
<p><a href="./../vue/">Vue 学习教程</a></p>
</li>
<li>
<p><a href="https://cn.vuejs.org/v2/guide/" target="_blank" rel="noopener noreferrer">Vue 官方文档</a></p>
</li>
</ul>
<h3 id="react"> React</h3>
<ul>
<li><a href="./src/program/webframe/react/">React 教程</a></li>
</ul>
<h3 id="angular"> Angular</h3>
<ul>
<li><a href="./../angular/">Angular 教程</a></li>
</ul>
<h2 id="其他文档"> 其他文档</h2>
<ul>
<li><a href="./https.html">HTTPS 介绍</a></li>
</ul>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <category term="前端"/>
    <contributor>
      <name>南辞</name>
    </contributor>
    <published>2019-09-01T00:00:00.000Z</published>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">编程开发</title>
    <id>http://qiqi.dreamagain.top/program/</id>
    <link href="http://qiqi.dreamagain.top/program/"/>
    <updated>2021-02-16T17:39:43.000Z</updated>
    <summary type="html"><![CDATA[<blockquote>
<p><img src="https://img.shields.io/badge/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-blue.svg" alt=""> <img src="https://img.shields.io/badge/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80-blue.svg" alt=""> <img src="https://img.shields.io/badge/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91-blue.svg" alt="">  <img src="https://img.shields.io/badge/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91-blue.svg" alt=""> <img src="https://img.shields.io/badge/%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%91-blue.svg" alt=""> <img src="https://img.shields.io/badge/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91-blue.svg" alt=""> <img src="https://img.shields.io/badge/%E5%AD%A6%E4%B9%A0%E7%BD%91%E7%AB%99-blue.svg" alt=""></p>
</blockquote>
]]></summary>
    <content type="html"><![CDATA[<blockquote>
<p><img src="https://img.shields.io/badge/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-blue.svg" alt=""> <img src="https://img.shields.io/badge/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80-blue.svg" alt=""> <img src="https://img.shields.io/badge/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91-blue.svg" alt="">  <img src="https://img.shields.io/badge/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91-blue.svg" alt=""> <img src="https://img.shields.io/badge/%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%91-blue.svg" alt=""> <img src="https://img.shields.io/badge/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91-blue.svg" alt=""> <img src="https://img.shields.io/badge/%E5%AD%A6%E4%B9%A0%E7%BD%91%E7%AB%99-blue.svg" alt=""></p>
</blockquote>
 
<h2 id="目录"> 目录</h2>
<ul>
<li>
<p><a href="./backend/">后端开发</a></p>
</li>
<li>
<p><a href="./frontend/">前端开发</a></p>
</li>
</ul>
<h2 id="编程学习网站"> 编程学习网站</h2>
<h3 id="优质网站"> 优质网站</h3>
<ul>
<li>
<p><a href="https://wangdoc.com/" target="_blank" rel="noopener noreferrer">网道</a></p>
</li>
<li>
<p><a href="https://www.liaoxuefeng.com/" target="_blank" rel="noopener noreferrer">廖雪峰的网站</a></p>
</li>
<li>
<p><a href="https://developer.mozilla.org/zh-CN/" target="_blank" rel="noopener noreferrer">MDN</a></p>
<div><p>相关信息</p>
<p>MDN 的中文文档翻译很差，大多都是机翻，十分建议直接阅读英文文档。</p>
</div>
</li>
</ul>
<h3 id="杂牌网站"> 杂牌网站</h3>
<ul>
<li>
<p><a href="https://www.runoob.com/" target="_blank" rel="noopener noreferrer">菜鸟教程</a> <MyBadge text="内容比较新" /></p>
</li>
<li>
<p><a href="https://www.w3cschool.cn" target="_blank" rel="noopener noreferrer">w3cschool</a> <MyBadge text="内容最新" /> <MyBadge text="有手机APP" /> <MyBadge text="广告信息多" type="warn" /></p>
</li>
<li>
<p><a href="http://www.w3school.com.cn/" target="_blank" rel="noopener noreferrer">w3school</a> <MyBadge text="内容比较旧" type="warn" /></p>
</li>
</ul>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <category term="编程开发"/>
    <contributor>
      <name>南辞</name>
    </contributor>
    <published>2021-02-16T17:39:43.000Z</published>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">七七部落 | 主页</title>
    <id>http://qiqi.dreamagain.top/</id>
    <link href="http://qiqi.dreamagain.top/"/>
    <updated>2021-04-10T04:40:33.000Z</updated>
    <author>
      <name>南辞</name>
    </author>
    <contributor>
      <name>南辞</name>
    </contributor>
    <published>2021-02-16T17:39:43.000Z</published>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">非关系型数据库</title>
    <id>http://qiqi.dreamagain.top/software/database/NoSQL/</id>
    <link href="http://qiqi.dreamagain.top/software/database/NoSQL/"/>
    <updated>2021-03-31T05:51:25.000Z</updated>
    <content type="html"><![CDATA[<h2 id="一、redis"> 一、Redis</h2>
<p><img src="./assets/image-20210316153254142.png" alt="image-20210316153254142"></p>
<h3 id="一-redis是什么"> （一）redis是什么?</h3>
<ul>
<li>
<p>Redis是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。</p>
</li>
<li>
<p>和Memcached类似，它支持存储的value类型相对更多，包括 <mark>string(字符串)、list(链表)、set(集合)、zset(sorted set --有序集合)和hash（哈希类型）</mark> 。</p>
</li>
<li>
<p>redis的数据类型都支持push/pop、add/remove及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。在此基础上，redis支持各种不同方式的排序。</p>
</li>
<li>
<p>与memcached一样，为了保证效率，数据都是缓存在内存中。区别的是redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步。</p>
</li>
<li>
<p>redis的出现，很大程度补偿了memcached这类key/value存储的不足，在部分场合可以对关系数据库起到很好的补充作用。它提供了Java，C/C++，C#，PHP，JavaScript，Perl，Object-C，Python，Ruby，Erlang等客户端，使用很方便。</p>
</li>
<li>
<p>Redis支持主从同步。数据可以从主服务器向任意数量的从服务器上同步，从服务器可以是关联其他从服务器的主服务器。这使得Redis可执行==单层树复制==。存盘可以有意无意的对数据进行写操作。由于完全实现了==发布/订阅机制==，使得从数据库在任何地方同步树时，可订阅一个频道并接收主服务器完整的消息发布记录。同步对读取操作的可扩展性和数据冗余很有帮助。</p>
</li>
</ul>
<h3 id="二-redis性能"> （二）redis性能</h3>
<p>下面是官方的bench-mark数据：</p>
<p>测试完成了50个并发执行100000个请求。</p>
<p>设置和获取的值是一个256字节字符串。</p>
<p>Linux box是运行Linux 2.6,这是X3320 Xeon 2.5 ghz。</p>
<p>文本执行使用loopback接口(127.0.0.1)。</p>
<p>结果:读的速度是110000次/s,写的速度是81000次/s 。</p>
<h3 id="三-redis存储"> （三）redis存储</h3>
<p>redis使用了两种文件格式：全量数据和增量请求。</p>
<p>**全量数据：**全量数据格式是把内存中的数据写入磁盘，便于下次读取文件进行加载；</p>
<p>**增量请求：**增量请求文件则是把内存中的数据序列化为操作请求，用于读取文件进行replay得到数据，序列化的操作包括SET、RPUSH、SADD、ZADD。</p>
<p>redis的存储分为三部分：</p>
<ol>
<li>内存存储</li>
<li>磁盘存储</li>
<li>log文件</li>
</ol>
<p>配置文件中有三个参数对其进行配置。</p>
<p>save seconds updates，save配置，指出在多长时间内，有多少次更新操作，就将数据同步到数据文件。这个可以多个条件配合，比如默认配置文件中的设置，就设置了三个条件。</p>
<p>appendonly yes/no ，appendonly配置，指出是否在每次更新操作后进行日志记录，如果不开启，可能会在断电时导致一段时间内的数据丢失。因为redis本身同步数据文件是按上面的save条件来同步的，所以有的数据会在一段时间内只存在于内存中。</p>
<p>appendfsync no/always/everysec ，appendfsync配置，no表示等操作系统进行数据缓存同步到磁盘，always表示每次更新操作后手动调用fsync()将数据写到磁盘，everysec表示每秒同步一次。</p>
<h3 id="四-附加资料"> （四）附加资料</h3>
<p>redis官网:http://redis.io/</p>
<p>redis官方文档:http://redis.io/documentation</p>
<p>redis教程:<a href="https://www.w3cschool.cn/redis/redis-intro.html" target="_blank" rel="noopener noreferrer">http://www.w3cschool.cn/redis/redis-intro.html</a></p>
<p>redis下载:http://redis.io/download</p>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <contributor>
      <name>南辞</name>
    </contributor>
    <published>2021-02-18T01:11:00.000Z</published>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">Redis 进阶</title>
    <id>http://qiqi.dreamagain.top/software/database/NoSQL/Redis/redis-advance/</id>
    <link href="http://qiqi.dreamagain.top/software/database/NoSQL/Redis/redis-advance/"/>
    <updated>2021-03-31T05:51:25.000Z</updated>
    <content type="html"><![CDATA[<h2 id="redis-数据备份与恢复"> Redis 数据备份与恢复</h2>
<h3 id="一-数据备份"> （一）数据备份</h3>
<p>Redis <strong>SAVE</strong> 命令用于创建当前数据库的备份。</p>
<p>创建 Redis 备份文件也可以使用命令 <strong>BGSAVE</strong>，该命令在后台执行。</p>
<p>redis Save 命令基本语法如下：</p>
<div><pre><code>redis <span>127.0</span>.0.1:637<span><span>9</span>></span> SAVE 
<span># 或者</span>
<span>27.0</span>.0.1:637<span><span>9</span>></span> BGSAVE
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><strong>实例</strong></p>
<div><pre><code><span>127.0</span>.0.1:637<span><span>9</span>></span> SAVE 
OK
<span># or</span>
<span>27.0</span>.0.1:637<span><span>9</span>></span> BGSAVE
Background saving started
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>该命令将在 redis 安装目录中创建dump.rdb文件。</p>
<h3 id="二-数据恢复"> （二）数据恢复</h3>
<p>如果需要恢复数据，只需将备份文件 (dump.rdb) 移动到 redis 安装目录并启动服务即可。获取 redis 目录可以使用 <strong>CONFIG</strong> 命令，如下所示：</p>
<div><pre><code> 
redis <span>127.0</span>.0.1:637<span><span>9</span>></span> CONFIG GET <span>dir</span>
<span>1</span><span>)</span> <span>"dir"</span>
<span>2</span><span>)</span> <span>"/usr/local/redis/bin"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>以上命令 <strong>CONFIG GET dir</strong> 输出的 redis 安装目录为 /usr/local/redis/bin。</p>
<h2 id="redis-安全"> Redis 安全</h2>
<p>我们可以通过 redis 的配置文件设置密码参数，这样客户端连接到 redis 服务就需要密码验证，这样可以让你的 redis 服务更安全。</p>
<p><strong>实例</strong></p>
<p>我们可以通过以下命令查看是否设置了密码验证：</p>
<div><pre><code><span>127.0</span>.0.1:637<span><span>9</span>></span> CONFIG get requirepass
<span>1</span><span>)</span> <span>"requirepass"</span>
<span>2</span><span>)</span> <span>""</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>默认情况下 requirepass 参数是空的，这就意味着你无需通过密码验证就可以连接到 redis 服务。</p>
<p>你可以通过以下命令来修改该参数：</p>
<div><pre><code><span>127.0</span>.0.1:637<span><span>9</span>></span> CONFIG <span>set</span> requirepass <span>"redis2021"</span>
OK
<span>127.0</span>.0.1:637<span><span>9</span>></span> CONFIG get requirepass
<span>1</span><span>)</span> <span>"requirepass"</span>
<span>2</span><span>)</span> <span>"w3cschool.cn"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>设置密码后，客户端连接 redis 服务就需要密码验证，否则无法执行命令。</p>
<p><strong>语法</strong></p>
<p><strong>AUTH</strong> 命令基本语法格式如下：</p>
<div><pre><code><span>127.0</span>.0.1:637<span><span>9</span>></span> AUTH password
</code></pre>
<div><span>1</span><br></div></div><p><strong>实例</strong></p>
<div><pre><code><span>127.0</span>.0.1:637<span><span>9</span>></span> AUTH <span>"redis2021"</span>
OK
<span>127.0</span>.0.1:637<span><span>9</span>></span> CONFIG get requirepass
<span>1</span><span>)</span> <span>"requirepass"</span>
<span>2</span><span>)</span> <span>"redis2021"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h2 id="redis-性能测试"> Redis 性能测试</h2>
<p>Redis 性能测试是通过同时执行多个命令实现的。</p>
<p><strong>语法</strong></p>
<p>redis 性能测试的基本命令如下：</p>
<div><pre><code>redis-benchmark <span>[</span>option<span>]</span> <span>[</span>option value<span>]</span>
</code></pre>
<div><span>1</span><br></div></div><p><strong>实例</strong></p>
<p>以下实例同时执行 10000 个请求来检测性能：</p>
<div><pre><code>redis-benchmark -n <span>100000</span>

PING_INLINE: <span>141043.72</span> requests per second
PING_BULK: <span>142857.14</span> requests per second
SET: <span>141442.72</span> requests per second
GET: <span>145348.83</span> requests per second
INCR: <span>137362.64</span> requests per second
LPUSH: <span>145348.83</span> requests per second
LPOP: <span>146198.83</span> requests per second
SADD: <span>146198.83</span> requests per second
SPOP: <span>149253.73</span> requests per second
LPUSH <span>(</span>needed to benchmark LRANGE<span>)</span>: <span>148588.42</span> requests per second
LRANGE_100 <span>(</span>first <span>100</span> elements<span>)</span>: <span>58411.21</span> requests per second
LRANGE_300 <span>(</span>first <span>300</span> elements<span>)</span>: <span>21195.42</span> requests per second
LRANGE_500 <span>(</span>first <span>450</span> elements<span>)</span>: <span>14539.11</span> requests per second
LRANGE_600 <span>(</span>first <span>600</span> elements<span>)</span>: <span>10504.20</span> requests per second
MSET <span>(</span><span>10</span> keys<span>)</span>: <span>93283.58</span> requests per second
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p>redis 性能测试工具可选参数如下所示：</p>
<table>
<thead>
<tr>
<th style="text-align:left">序号</th>
<th style="text-align:left">选项</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left"><strong>-h</strong></td>
<td style="text-align:left">指定服务器主机名</td>
<td style="text-align:left">127.0.0.1</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left"><strong>-p</strong></td>
<td style="text-align:left">指定服务器端口</td>
<td style="text-align:left">6379</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left"><strong>-s</strong></td>
<td style="text-align:left">指定服务器 socket</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left"><strong>-c</strong></td>
<td style="text-align:left">指定并发连接数</td>
<td style="text-align:left">50</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left"><strong>-n</strong></td>
<td style="text-align:left">指定请求数</td>
<td style="text-align:left">10000</td>
</tr>
<tr>
<td style="text-align:left">6</td>
<td style="text-align:left"><strong>-d</strong></td>
<td style="text-align:left">以字节的形式指定 SET/GET 值的数据大小</td>
<td style="text-align:left">2</td>
</tr>
<tr>
<td style="text-align:left">7</td>
<td style="text-align:left"><strong>-k</strong></td>
<td style="text-align:left">1=keep alive 0=reconnect</td>
<td style="text-align:left">1</td>
</tr>
<tr>
<td style="text-align:left">8</td>
<td style="text-align:left"><strong>-r</strong></td>
<td style="text-align:left">SET/GET/INCR 使用随机 key, SADD 使用随机值</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">9</td>
<td style="text-align:left"><strong>-P</strong></td>
<td style="text-align:left">通过管道传输 <code>&lt;numreq&gt;</code> 请求</td>
<td style="text-align:left">1</td>
</tr>
<tr>
<td style="text-align:left">10</td>
<td style="text-align:left"><strong>-q</strong></td>
<td style="text-align:left">强制退出 redis。仅显示 query/sec 值</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">11</td>
<td style="text-align:left"><strong>--csv</strong></td>
<td style="text-align:left">以 CSV 格式输出</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">12</td>
<td style="text-align:left"><strong>-l</strong></td>
<td style="text-align:left">生成循环，永久执行测试</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">13</td>
<td style="text-align:left"><strong>-t</strong></td>
<td style="text-align:left">仅运行以逗号分隔的测试命令列表。</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">14</td>
<td style="text-align:left"><strong>-I</strong></td>
<td style="text-align:left">Idle 模式。仅打开 N 个 idle 连接并等待。</td>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
<p><strong>实例</strong></p>
<p>以下实例我们使用了多个参数来测试 redis 性能：</p>
<div><pre><code>redis-benchmark -h <span>127.0</span>.0.1 -p <span>6379</span> -t set,lpush -n <span>100000</span> -q
SET: <span>146198.83</span> requests per second
LPUSH: <span>145560.41</span> requests per second
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>以上实例中主机为 127.0.0.1，端口号为 6379，执行的命令为 set,lpush，请求数为 10000，通过 -q 参数让结果只显示每秒执行的请求数。</p>
<h2 id="redis-客户端连接"> Redis 客户端连接</h2>
<p>Redis 通过监听一个 TCP 端口或者 Unix socket 的方式来接收来自客户端的连接，当一个连接建立后，Redis 内部会进行以下一些操作：</p>
<ul>
<li>首先，客户端 socket 会被设置为非阻塞模式，因为 Redis 在网络事件处理上采用的是非阻塞多路复用模型。</li>
<li>然后为这个 socket 设置 TCP_NODELAY 属性，禁用 Nagle 算法</li>
<li>然后创建一个可读的文件事件用于监听这个客户端 socket 的数据发送</li>
</ul>
<p><strong>最大连接数</strong></p>
<p>在 Redis2.4 中，最大连接数是被直接硬编码在代码里面的，而在2.6版本中这个值变成可配置的。</p>
<p>maxclients 的默认值是 10000，你也可以在 redis.conf 中对这个值进行修改。</p>
<div><pre><code>config get maxclients
<span>1</span><span>)</span> <span>"maxclients"</span>
<span>2</span><span>)</span> <span>"10000"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><strong>实例</strong></p>
<p>以下实例我们在服务启动时设置最大连接数为 100000：</p>
<div><pre><code>redis-server --maxclients <span>100000</span>
</code></pre>
<div><span>1</span><br></div></div><p><strong>客户端命令</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left">S.N.</th>
<th style="text-align:left">命令</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left"><strong>CLIENT LIST</strong></td>
<td style="text-align:left">返回连接到 redis 服务的客户端列表</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left"><strong>CLIENT SETNAME</strong></td>
<td style="text-align:left">设置当前连接的名称</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left"><strong>CLIENT GETNAME</strong></td>
<td style="text-align:left">获取通过 CLIENT SETNAME 命令设置的服务名称</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left"><strong>CLIENT PAUSE</strong></td>
<td style="text-align:left">挂起客户端连接，指定挂起的时间以毫秒计</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left"><strong>CLIENT KILL</strong></td>
<td style="text-align:left">关闭客户端连接</td>
</tr>
</tbody>
</table>
<h2 id="redis-管道技术"> Redis 管道技术</h2>
<p>Redis是一种基于客户端-服务端模型以及请求/响应协议的TCP服务。这意味着通常情况下一个请求会遵循以下步骤：</p>
<ul>
<li>客户端向服务端发送一个查询请求，并监听Socket返回，通常是以阻塞模式，等待服务端响应。</li>
<li>服务端处理命令，并将结果返回给客户端。</li>
</ul>
<p><mark>Redis 管道技术可以在服务端未响应时，客户端可以继续向服务端发送请求，并最终一次性读取所有服务端的响应。</mark></p>
<p><strong>实例</strong></p>
<p>查看 redis 管道，只需要启动 redis 实例并输入以下命令：</p>
<div><pre><code><span><span>$(</span><span>echo</span> -en <span>"PING<span title="\r">\r</span><span title="\n">\n</span> SET pipekey redis<span title="\r">\r</span><span title="\n">\n</span>GET w3ckey<span title="\r">\r</span><span title="\n">\n</span>INCR visitor<span title="\r">\r</span><span title="\n">\n</span>INCR visitor<span title="\r">\r</span><span title="\n">\n</span>INCR visitor<span title="\r">\r</span><span title="\n">\n</span>"</span><span>;</span> <span>sleep</span> <span>10</span><span>)</span></span> <span>|</span> <span>nc</span> localhost <span>6379</span>

+PONG
+OK
redis
:1
:2
:3
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>以上实例中我们通过使用 <strong>PING</strong> 命令查看redis服务是否可用， 之后我们们设置了 pipekey的值为 redis，然后我们获取 pipekey的值并使得 visitor 自增 3 次。</p>
<p>在返回的结果中我们可以看到这些命令一次性向 redis 服务提交，并最终一次性读取所有服务端的响应</p>
<p>**管道技术的优势：**管道技术最显著的优势是提高了 redis 服务的性能。</p>
<p><strong>一些测试数据</strong></p>
<p>在下面的测试中，我们将使用Redis的Ruby客户端，支持管道技术特性，测试管道技术对速度的提升效果。</p>
<div><pre><code>require <span>'rubygems'</span> 
require <span>'redis'</span>
def bench<span>(</span>descr<span>)</span> 
start <span>=</span> Time.now 
yield 
puts <span>"#{descr} #{Time.now-start} seconds"</span> 
end
def without_pipelining 
r <span>=</span> Redis.new 
<span>10000</span>.times <span>{</span> 
  r.ping 
<span>}</span> 
end
def with_pipelining 
r <span>=</span> Redis.new 
r.pipelined <span>{</span> 
    <span>10000</span>.times <span>{</span> 
        r.ping 
   <span>}</span> 
<span>}</span> 
end
bench<span>(</span><span>"without pipelining"</span><span>)</span> <span>{</span> 
 without_pipelining 
<span>}</span> 
bench<span>(</span><span>"with pipelining"</span><span>)</span> <span>{</span> 
    with_pipelining 
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div><p>从处于局域网中的Mac OS X系统上执行上面这个简单脚本的数据表明，开启了管道操作后，往返时延已经被改善得相当低了。</p>
<div><pre><code>without pipelining 1.185238 seconds 
with pipelining 0.250783 seconds
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>如你所见，开启管道后，我们的速度效率提升了5倍。</p>
<h2 id="redis-分区"> Redis 分区</h2>
<p>分区是分割数据到多个Redis实例的处理过程，因此每个实例只保存key的一个子集。</p>
<p><strong>分区的优势</strong></p>
<ul>
<li>通过利用多台计算机内存的和值，允许我们构造更大的数据库。</li>
<li>通过多核和多台计算机，允许我们扩展计算能力；通过多台计算机和网络适配器，允许我们扩展网络带宽。</li>
</ul>
<p><strong>分区的不足</strong></p>
<p>redis的一些特性在分区方面表现的不是很好：</p>
<ul>
<li>涉及多个key的操作通常是不被支持的。举例来说，当两个set映射到不同的redis实例上时，你就不能对这两个set执行交集操作。</li>
<li>涉及多个key的redis事务不能使用。</li>
<li>当使用分区时，数据处理较为复杂，比如你需要处理多个rdb/aof文件，并且从多个实例和主机备份持久化文件。</li>
<li>增加或删除容量也比较复杂。redis集群大多数支持在运行时增加、删除节点的透明数据平衡的能力，但是类似于客户端分区、代理等其他系统则不支持这项特性。然而，一种叫做presharding的技术对此是有帮助的。</li>
</ul>
<p><strong>分区类型</strong></p>
<p>Redis 有两种类型分区。 假设有4个Redis实例 R0，R1，R2，R3，和类似user:1，user:2这样的表示用户的多个key，</p>
<p>对既定的key有多种不同方式来选择这个key存放在哪个实例中。也就是说，有不同的系统来映射某个key到某个Redis服务。</p>
<p><strong>①范围分区</strong></p>
<p>最简单的分区方式是按范围分区，就是映射一定范围的对象到特定的Redis实例。</p>
<p>比如，ID从0到10000的用户会保存到实例R0，ID从10001到 20000的用户会保存到R1，以此类推。</p>
<p>这种方式是可行的，并且在实际中使用，不足就是要有一个区间范围到实例的映射表。这个表要被管理，同时还需要各种对象的映射表，通常对Redis来说并非是好的方法。</p>
<p><strong>②哈希分区</strong></p>
<p>另外一种分区方法是hash分区。这对任何key都适用，也无需是object_name:这种形式，像下面描述的一样简单：</p>
<ul>
<li>用一个hash函数将key转换为一个数字，比如使用crc32 hash函数。对key foobar执行crc32(foobar)会输出类似93024922的整数。</li>
<li>对这个整数取模，将其转化为0-3之间的数字，就可以将这个整数映射到4个Redis实例中的一个了。93024922 % 4 = 2，就是说key foobar应该被存到R2实例中。注意：取模操作是取除的余数，通常在多种编程语言中用%操作符实现。</li>
</ul>
<h2 id="java-使用-redis"> Java 使用 Redis</h2>
<h3 id="一-安装"> （一）安装</h3>
<p>开始在 Java 中使用 Redis 前， 我们需要确保已经安装了 redis 服务及 Java redis 驱动，且你的机器上能正常使用 Java。 Java的安装配置可以参考 <a href="https://www.w3cschool.cn/java/java-environment-setup.html" target="_blank" rel="noopener noreferrer">Java开发环境配置 </a>接下来需要安装 Java redis 驱动：</p>
<ul>
<li>首先你需要下载驱动包，<a href="https://repo1.maven.org/maven2/redis/clients/jedis/2.1.0/jedis-2.1.0-sources.jar" target="_blank" rel="noopener noreferrer"><strong>下载 jedis.jar</strong></a>，确保下载最新驱动包。</li>
<li>在你的classpath中包含该驱动包。</li>
</ul>
<h3 id="二-连接到-redis-服务"> （二）连接到 redis 服务</h3>
<div><pre><code><span>import</span> <span>redis<span>.</span>clients<span>.</span>jedis<span>.</span></span><span>Jedis</span><span>;</span>
<span>public</span> <span>class</span> <span>RedisJava</span> <span>{</span>
   <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
      <span>//连接本地的 Redis 服务</span>
      <span>Jedis</span> jedis <span>=</span> <span>new</span> <span>Jedis</span><span>(</span><span>"localhost"</span><span>)</span><span>;</span>
      <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"连接成功"</span><span>)</span><span>;</span>
      <span>//查看服务是否运行</span>
      <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"服务器正在运行: "</span><span>+</span>jedis<span>.</span><span>ping</span><span>(</span><span>)</span><span>)</span><span>;</span>
 <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>编译以上 Java 程序，确保驱动包的路径是正确的。</p>
<div><pre><code>  连接成功
  服务正在运行：PONG
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h3 id="三-redis-java-string-字符串-实例"> （三）Redis Java String(字符串) 实例</h3>
<div><pre><code><span>import</span> <span>redis<span>.</span>clients<span>.</span>jedis<span>.</span></span><span>Jedis</span><span>;</span><span>public</span> <span>class</span> <span>RedisStringJava</span> <span>{</span>
   <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
      <span>//连接本地的 Redis 服务</span>
      <span>Jedis</span> jedis <span>=</span> <span>new</span> <span>Jedis</span><span>(</span><span>"localhost"</span><span>)</span><span>;</span>
      <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"连接成功"</span><span>)</span><span>;</span>
      <span>//设置 redis 字符串数据</span>
      jedis<span>.</span><span>set</span><span>(</span><span>"key_string"</span><span>,</span> <span>"redis"</span><span>)</span><span>;</span>
     <span>// 获取存储的数据并输出</span>
     <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"redis 存储的字符串为: "</span><span>+</span> jedis<span>.</span><span>get</span><span>(</span><span>"key_string"</span><span>)</span><span>)</span><span>;</span>
 <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>编译以上程序。</p>
<div><pre><code> 连接成功
 redis 存储的字符串为：redis
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h3 id="四-redis-java-list-列表-实例"> （四）Redis Java List(列表) 实例</h3>
<div><pre><code><span>import</span> <span>java<span>.</span>util<span>.</span></span><span>Listimport</span> <span><span>redis<span>.</span>clients<span>.</span>jedis<span>.</span></span>Jedis</span><span>;</span> <span>public</span> <span>class</span> <span>RedisListJava</span> <span>{</span>
   <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
      <span>//连接本地的 Redis 服务</span>
      <span>Jedis</span> jedis <span>=</span> <span>new</span> <span>Jedis</span><span>(</span><span>"localhost"</span><span>)</span><span>;</span>
      <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"连接成功"</span><span>)</span><span>;</span>
      <span>//存储数据到列表中</span>
      jedis<span>.</span><span>lpush</span><span>(</span><span>"tutorial-list"</span><span>,</span> <span>"Redis"</span><span>)</span><span>;</span>
      jedis<span>.</span><span>lpush</span><span>(</span><span>"tutorial-list"</span><span>,</span> <span>"Mongodb"</span><span>)</span><span>;</span>
      jedis<span>.</span><span>lpush</span><span>(</span><span>"tutorial-list"</span><span>,</span> <span>"Mysql"</span><span>)</span><span>;</span>
     <span>// 获取存储的数据并输出</span>
     <span>List</span><span><span>&lt;</span><span>String</span><span>></span></span> list <span>=</span> jedis<span>.</span><span>lrange</span><span>(</span><span>"tutorial-list"</span><span>,</span> <span>0</span> <span>,</span><span>2</span><span>)</span><span>;</span>
     <span>for</span><span>(</span><span>int</span> i<span>=</span><span>0</span><span>;</span> i<span>&lt;</span>list<span>.</span><span>size</span><span>(</span><span>)</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>
         <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"列表项为: "</span><span>+</span>list<span>.</span><span>get</span><span>(</span>i<span>)</span><span>)</span><span>;</span>           
     <span>}</span>    
   <span>}</span> 
<span>}</span> 
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>编译以上程序。</p>
<div><pre><code> 连接成功
 列表项为: Redis
 列表项为: Mongodb
 列表项为: Mysql
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id="五-redis-java-keys-实例"> （五）Redis Java Keys 实例</h3>
<div><pre><code><span>import</span> <span>java<span>.</span>util<span>.</span></span><span>Iterator</span><span>;</span><span>import</span> <span>java<span>.</span>util<span>.</span></span><span>Set</span><span>;</span><span>import</span> <span>redis<span>.</span>clients<span>.</span>jedis<span>.</span></span><span>Jedis</span><span>;</span> <span>public</span> <span>class</span> <span>RedisKeyJava</span> <span>{</span>
   <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
      <span>//连接本地的 Redis 服务</span>
      <span>Jedis</span> jedis <span>=</span> <span>new</span> <span>Jedis</span><span>(</span><span>"localhost"</span><span>)</span><span>;</span>
      <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"连接成功"</span><span>)</span><span>;</span>
      
     <span>// 获取数据并输出</span>
     <span>Set</span><span><span>&lt;</span><span>String</span><span>></span></span> keys<span>=</span> jedis<span>.</span><span>keys</span><span>(</span><span>"*"</span><span>)</span><span>;</span>     
     <span>Iterator</span><span><span>&lt;</span><span>String</span><span>></span></span> it<span>=</span>keys<span>.</span><span>iterator</span><span>(</span><span>)</span><span>;</span>     
     <span>while</span><span>(</span>it<span>.</span>hasNext<span>)</span> <span>{</span>         
         <span>String</span> key<span>=</span>it<span>.</span><span>next</span><span>(</span><span>)</span><span>;</span>       
         <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"key"</span><span>)</span><span>;</span>     
    <span>}</span>     
  <span>}</span>
<span>}</span> 
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>编译以上程序。</p>
<div><pre><code> 连接成功
 key_string
 tutorial-list 
 
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div>]]></content>
    <author>
      <name>南辞</name>
    </author>
    <category term="数据库"/>
    <contributor>
      <name>南辞</name>
    </contributor>
    <published>2021-03-31T05:51:25.000Z</published>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">Redis 基础</title>
    <id>http://qiqi.dreamagain.top/software/database/NoSQL/Redis/redis-base/</id>
    <link href="http://qiqi.dreamagain.top/software/database/NoSQL/Redis/redis-base/"/>
    <updated>2021-03-31T05:51:25.000Z</updated>
    <content type="html"><![CDATA[<h2 id="一、redis-简介"> 一、Redis 简介</h2>
<h3 id="一-redis-简介"> （一）Redis 简介</h3>
<p>Redis 是完全开源免费的，遵守BSD协议，是一个高性能的key-value数据库。</p>
<p>Redis 与其他 key - value 缓存产品有以下三个特点：</p>
<ul>
<li>Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用。</li>
<li>Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。</li>
<li>Redis支持数据的备份，即master-slave（主从）模式的数据备份。</li>
</ul>
<hr>
<h3 id="二-redis-优势"> （二）Redis 优势</h3>
<ul>
<li>
<p>性能极高 – Redis能读的速度是110000次/s,写的速度是81000次/s 。</p>
</li>
<li>
<p>丰富的数据类型 – Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。</p>
</li>
<li>
<p>原子 – Redis的所有操作都是原子性的，同时Redis还支持对几个操作合并后的原子性执行。</p>
<p>意思就是要么成功执行要么失败完全不执行。</p>
<p>单个操作是原子性的。多个操作也支持事务，即原子性，通过MULTI和EXEC指令包起来。</p>
</li>
<li>
<p>丰富的特性 – Redis还支持 publish/subscribe, 通知, key 过期等等特性。</p>
</li>
</ul>
<hr>
<h3 id="三-redis与其他key-value存储有什么不同"> （三）Redis与其他key-value存储有什么不同？</h3>
<ul>
<li>Redis有着更为复杂的数据结构并且提供对他们的原子性操作，这是一个不同于其他数据库的进化路径。Redis的数据类型都是基于基本数据结构的同时对程序员透明，无需进行额外的抽象。</li>
<li>Redis运行在内存中但是可以持久化到磁盘，所以在对不同数据集进行高速读写时需要权衡内存，应为数据量不能大于硬件内存。在内存数据库方面的另一个优点是， 相比在磁盘上相同的复杂的数据结构，在内存中操作起来非常简单，这样Redis可以做很多内部复杂性很强的事情。 同时，在磁盘格式方面他们是紧凑的以追加的方式产生的，因为他们并不需要进行随机访问。</li>
</ul>
<h2 id="二、redis的安装"> 二、Redis的安装</h2>
<p>参照：https://www.w3cschool.cn/redis/redis-install.html</p>
<p>启动命令</p>
<div><pre><code><span># 服务端</span>
redis-server.exe redis.conf
<span># 客户端</span>
redis-cli.exe -h <span>127.0</span>.0.1 -p <span>6379</span> 
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h2 id="三、redis-配置"> 三、Redis 配置</h2>
<p>Redis 的配置文件位于 Redis 安装目录下，文件名为 redis.conf。</p>
<h3 id="一-查看配置"> （一）查看配置</h3>
<p>你可以通过 <strong>CONFIG</strong> 命令查看或设置配置项。</p>
<p><strong>语法</strong></p>
<p>Redis CONFIG 命令格式如下：</p>
<div><pre><code><span># redis命令可以忽略大小写</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> CONFIG GET CONFIG_SETTING_NAME 
或
<span>127.0</span>.0.1:637<span><span>9</span>></span> config get CONFIG_SETTING_NAME 
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p><strong>实例</strong></p>
<div><pre><code><span>127.0</span>.0.1:637<span><span>9</span>></span> CONFIG GET loglevel
<span>1</span><span>)</span> <span>"loglevel"</span>
<span>2</span><span>)</span> <span>"notice"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>使用 ***** 号获取所有配置项：</p>
<p><strong>实例</strong></p>
<div><pre><code><span>127.0</span>.0.1:637<span><span>9</span>></span>CONFIG GET *
  <span>1</span><span>)</span> <span>"dbfilename"</span>
  <span>2</span><span>)</span> <span>"dump.rdb"</span>
  <span>3</span><span>)</span> <span>"requirepass"</span>
  <span>4</span><span>)</span> <span>""</span>
  <span>5</span><span>)</span> <span>"masterauth"</span>
  <span>6</span><span>)</span> <span>""</span>
  <span>7</span><span>)</span> <span>"unixsocket"</span>
  <span>8</span><span>)</span> <span>""</span>
  <span>9</span><span>)</span> <span>"logfile"</span>
 <span>10</span><span>)</span> <span>""</span>
 <span>11</span><span>)</span> <span>"pidfile"</span>
 <span>12</span><span>)</span> <span>"/var/run/redis.pid"</span>
 <span>13</span><span>)</span> <span>"maxmemory"</span>
 <span>14</span><span>)</span> <span>"0"</span>
 <span>15</span><span>)</span> <span>"maxmemory-samples"</span>
 <span>16</span><span>)</span> <span>"3"</span>
 <span>17</span><span>)</span> <span>"timeout"</span>
 <span>18</span><span>)</span> <span>"0"</span>
 <span>19</span><span>)</span> <span>"tcp-keepalive"</span>
 <span>20</span><span>)</span> <span>"0"</span>
 <span>21</span><span>)</span> <span>"auto-aof-rewrite-percentage"</span>
 <span>22</span><span>)</span> <span>"100"</span>
 <span>23</span><span>)</span> <span>"auto-aof-rewrite-min-size"</span>
 <span>24</span><span>)</span> <span>"67108864"</span>
 <span>25</span><span>)</span> <span>"hash-max-ziplist-entries"</span>
 <span>26</span><span>)</span> <span>"512"</span>
 <span>27</span><span>)</span> <span>"hash-max-ziplist-value"</span>
 <span>28</span><span>)</span> <span>"64"</span>
 <span>29</span><span>)</span> <span>"list-max-ziplist-entries"</span>
 <span>30</span><span>)</span> <span>"512"</span>
 <span>31</span><span>)</span> <span>"list-max-ziplist-value"</span>
 <span>32</span><span>)</span> <span>"64"</span>
 <span>33</span><span>)</span> <span>"set-max-intset-entries"</span>
 <span>34</span><span>)</span> <span>"512"</span>
 <span>35</span><span>)</span> <span>"zset-max-ziplist-entries"</span>
 <span>36</span><span>)</span> <span>"128"</span>
 <span>37</span><span>)</span> <span>"zset-max-ziplist-value"</span>
 <span>38</span><span>)</span> <span>"64"</span>
 <span>39</span><span>)</span> <span>"hll-sparse-max-bytes"</span>
 <span>40</span><span>)</span> <span>"3000"</span>
 <span>41</span><span>)</span> <span>"lua-time-limit"</span>
 <span>42</span><span>)</span> <span>"5000"</span>
 <span>43</span><span>)</span> <span>"slowlog-log-slower-than"</span>
 <span>44</span><span>)</span> <span>"10000"</span>
 <span>45</span><span>)</span> <span>"latency-monitor-threshold"</span>
 <span>46</span><span>)</span> <span>"0"</span>
 <span>47</span><span>)</span> <span>"slowlog-max-len"</span>
 <span>48</span><span>)</span> <span>"128"</span>
 <span>49</span><span>)</span> <span>"port"</span>
 <span>50</span><span>)</span> <span>"6379"</span>
 <span>51</span><span>)</span> <span>"tcp-backlog"</span>
 <span>52</span><span>)</span> <span>"511"</span>
 <span>53</span><span>)</span> <span>"databases"</span>
 <span>54</span><span>)</span> <span>"16"</span>
 <span>55</span><span>)</span> <span>"repl-ping-slave-period"</span>
 <span>56</span><span>)</span> <span>"10"</span>
 <span>57</span><span>)</span> <span>"repl-timeout"</span>
 <span>58</span><span>)</span> <span>"60"</span>
 <span>59</span><span>)</span> <span>"repl-backlog-size"</span>
 <span>60</span><span>)</span> <span>"1048576"</span>
 <span>61</span><span>)</span> <span>"repl-backlog-ttl"</span>
 <span>62</span><span>)</span> <span>"3600"</span>
 <span>63</span><span>)</span> <span>"maxclients"</span>
 <span>64</span><span>)</span> <span>"4064"</span>
 <span>65</span><span>)</span> <span>"watchdog-period"</span>
 <span>66</span><span>)</span> <span>"0"</span>
 <span>67</span><span>)</span> <span>"slave-priority"</span>
 <span>68</span><span>)</span> <span>"100"</span>
 <span>69</span><span>)</span> <span>"min-slaves-to-write"</span>
 <span>70</span><span>)</span> <span>"0"</span>
 <span>71</span><span>)</span> <span>"min-slaves-max-lag"</span>
 <span>72</span><span>)</span> <span>"10"</span>
 <span>73</span><span>)</span> <span>"hz"</span>
 <span>74</span><span>)</span> <span>"10"</span>
 <span>75</span><span>)</span> <span>"no-appendfsync-on-rewrite"</span>
 <span>76</span><span>)</span> <span>"no"</span>
 <span>77</span><span>)</span> <span>"slave-serve-stale-data"</span>
 <span>78</span><span>)</span> <span>"yes"</span>
 <span>79</span><span>)</span> <span>"slave-read-only"</span>
 <span>80</span><span>)</span> <span>"yes"</span>
 <span>81</span><span>)</span> <span>"stop-writes-on-bgsave-error"</span>
 <span>82</span><span>)</span> <span>"yes"</span>
 <span>83</span><span>)</span> <span>"daemonize"</span>
 <span>84</span><span>)</span> <span>"no"</span>
 <span>85</span><span>)</span> <span>"rdbcompression"</span>
 <span>86</span><span>)</span> <span>"yes"</span>
 <span>87</span><span>)</span> <span>"rdbchecksum"</span>
 <span>88</span><span>)</span> <span>"yes"</span>
 <span>89</span><span>)</span> <span>"activerehashing"</span>
 <span>90</span><span>)</span> <span>"yes"</span>
 <span>91</span><span>)</span> <span>"repl-disable-tcp-nodelay"</span>
 <span>92</span><span>)</span> <span>"no"</span>
 <span>93</span><span>)</span> <span>"aof-rewrite-incremental-fsync"</span>
 <span>94</span><span>)</span> <span>"yes"</span>
 <span>95</span><span>)</span> <span>"appendonly"</span>
 <span>96</span><span>)</span> <span>"no"</span>
 <span>97</span><span>)</span> <span>"dir"</span>
 <span>98</span><span>)</span> <span>"/home/deepak/Downloads/redis-2.8.13/src"</span>
 <span>99</span><span>)</span> <span>"maxmemory-policy"</span>
<span>100</span><span>)</span> <span>"volatile-lru"</span>
<span>101</span><span>)</span> <span>"appendfsync"</span>
<span>102</span><span>)</span> <span>"everysec"</span>
<span>103</span><span>)</span> <span>"save"</span>
<span>104</span><span>)</span> <span>"3600 1 300 100 60 10000"</span>
<span>105</span><span>)</span> <span>"loglevel"</span>
<span>106</span><span>)</span> <span>"notice"</span>
<span>107</span><span>)</span> <span>"client-output-buffer-limit"</span>
<span>108</span><span>)</span> <span>"normal 0 0 0 slave 268435456 67108864 60 pubsub 33554432 8388608 60"</span>
<span>109</span><span>)</span> <span>"unixsocketperm"</span>
<span>110</span><span>)</span> <span>"0"</span>
<span>111</span><span>)</span> <span>"slaveof"</span>
<span>112</span><span>)</span> <span>""</span>
<span>113</span><span>)</span> <span>"notify-keyspace-events"</span>
<span>114</span><span>)</span> <span>""</span>
<span>115</span><span>)</span> <span>"bind"</span>
<span>116</span><span>)</span> <span>""</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br><span>96</span><br><span>97</span><br><span>98</span><br><span>99</span><br><span>100</span><br><span>101</span><br><span>102</span><br><span>103</span><br><span>104</span><br><span>105</span><br><span>106</span><br><span>107</span><br><span>108</span><br><span>109</span><br><span>110</span><br><span>111</span><br><span>112</span><br><span>113</span><br><span>114</span><br><span>115</span><br><span>116</span><br><span>117</span><br></div></div><h3 id="二-编辑配置"> （二）编辑配置</h3>
<p>你可以通过修改 redis.conf 文件或使用 <strong>CONFIG set</strong> 命令来修改配置。</p>
<p><strong>语法</strong></p>
<p><strong>CONFIG SET</strong> 命令基本语法：</p>
<div><pre><code><span>127.0</span>.0.1:637<span><span>9</span>></span> CONFIG SET CONFIG_SETTING_NAME NEW_CONFIG_VALUE
</code></pre>
<div><span>1</span><br></div></div><p><strong>实例</strong></p>
<div><pre><code><span>127.0</span>.0.1:637<span><span>9</span>></span> CONFIG SET loglevel <span>"verbose"</span>
OK
<span>127.0</span>.0.1:637<span><span>9</span>></span> CONFIG GET loglevel

<span>1</span><span>)</span> <span>"loglevel"</span>
<span>2</span><span>)</span> <span>"verbose"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h3 id="三-参数说明"> （三）参数说明</h3>
<p>redis.conf 配置项说明如下：</p>
<ol>
<li>
<p>Redis默认不是以守护进程的方式运行，可以通过该配置项修改，使用yes启用守护进程</p>
<p><strong>daemonize no</strong></p>
</li>
<li>
<p>当Redis以守护进程方式运行时，Redis默认会把pid写入/var/run/redis.pid文件，可以通过pidfile指定</p>
<p><strong>pidfile /var/run/redis.pid</strong></p>
</li>
<li>
<p>指定Redis监听端口，默认端口为6379，作者在自己的一篇博文中解释了为什么选用6379作为默认端口，因为6379在手机按键上MERZ对应的号码，而MERZ取自意大利歌女Alessia Merz的名字</p>
<p><strong>port 6379</strong></p>
</li>
<li>
<p>绑定的主机地址</p>
<p><strong>bind 127.0.0.1</strong></p>
</li>
<li>
<p>当 客户端闲置多长时间后关闭连接，如果指定为0，表示关闭该功能</p>
<p><strong>timeout 300</strong></p>
</li>
<li>
<p>指定日志记录级别，Redis总共支持四个级别：debug、verbose、notice、warning，默认为verbose</p>
<p><strong>loglevel verbose</strong></p>
</li>
<li>
<p>日志记录方式，默认为标准输出，如果配置Redis为守护进程方式运行，而这里又配置为日志记录方式为标准输出，则日志将会发送给/dev/null</p>
<p><strong>logfile stdout</strong></p>
</li>
<li>
<p>设置数据库的数量，默认数据库为0，可以使用SELECT <code>&lt;dbid&gt;</code>命令在连接上指定数据库id</p>
<p><strong>databases 16</strong></p>
</li>
<li>
<p>指定在多长时间内，有多少次更新操作，就将数据同步到数据文件，可以多个条件配合</p>
<p><strong>save <code>&lt;seconds&gt;</code> <code>&lt;changes&gt;</code></strong></p>
<p>Redis默认配置文件中提供了三个条件：</p>
<p><strong>save 900 1</strong></p>
<p><strong>save 300 10</strong></p>
<p><strong>save 60 10000</strong></p>
<p>分别表示900秒（15分钟）内有1个更改，300秒（5分钟）内有10个更改以及60秒内有10000个更改。</p>
</li>
<li>
<p>指定存储至本地数据库时是否压缩数据，默认为yes，Redis采用LZF压缩，如果为了节省CPU时间，可以关闭该选项，但会导致数据库文件变的巨大</p>
<p><strong>rdbcompression yes</strong></p>
</li>
<li>
<p>指定本地数据库文件名，默认值为dump.rdb</p>
<p><strong>dbfilename dump.rdb</strong></p>
</li>
<li>
<p>指定本地数据库存放目录</p>
<p><strong>dir ./</strong></p>
</li>
<li>
<p>设置当本机为slav服务时，设置master服务的IP地址及端口，在Redis启动时，它会自动从master进行数据同步</p>
<p><strong>slaveof <code>&lt;masterip&gt;</code> <code>&lt;masterport&gt;</code></strong></p>
</li>
<li>
<p>当master服务设置了密码保护时，slav服务连接master的密码</p>
<p><strong>masterauth <code>&lt;master-password&gt;</code></strong></p>
</li>
<li>
<p>设置Redis连接密码，如果配置了连接密码，客户端在连接Redis时需要通过AUTH <code>&lt;password&gt;</code>命令提供密码，默认关闭<strong>requirepass foobared</strong></p>
</li>
<li>
<p>设置同一时间最大客户端连接数，默认无限制，Redis可以同时打开的客户端连接数为Redis进程可以打开的最大文件描述符数，如果设置 maxclients 0，表示不作限制。当客户端连接数到达限制时，Redis会关闭新的连接并向客户端返回max number of clients reached错误信息</p>
<p><strong>maxclients 128</strong></p>
</li>
<li>
<p>指定Redis最大内存限制，Redis在启动时会把数据加载到内存中，达到最大内存后，Redis会先尝试清除已到期或即将到期的Key，当此方法处理 后，仍然到达最大内存设置，将无法再进行写入操作，但仍然可以进行读取操作。Redis新的vm机制，会把Key存放内存，Value会存放在swap区</p>
<p><strong>maxmemory <code>&lt;bytes&gt;</code></strong></p>
</li>
<li>
<p>指定是否在每次更新操作后进行日志记录，Redis在默认情况下是异步的把数据写入磁盘，如果不开启，可能会在断电时导致一段时间内的数据丢失。因为 redis本身同步数据文件是按上面save条件来同步的，所以有的数据会在一段时间内只存在于内存中。默认为no</p>
<p><strong>appendonly no</strong></p>
</li>
<li>
<p>指定更新日志文件名，默认为appendonly.aof</p>
<p><strong>appendfilename appendonly.aof</strong></p>
</li>
<li>
<p>指定更新日志条件，共有3个可选值：
<strong>no</strong>：表示等操作系统进行数据缓存同步到磁盘（快）
<strong>always</strong>：表示每次更新操作后手动调用fsync()将数据写到磁盘（慢，安全）
<strong>everysec</strong>：表示每秒同步一次（折衷，默认值）</p>
<p><strong>appendfsync everysec</strong></p>
</li>
<li>
<p>指定是否启用虚拟内存机制，默认值为no，简单的介绍一下，VM机制将数据分页存放，由Redis将访问量较少的页即冷数据swap到磁盘上，访问多的页面由磁盘自动换出到内存中（在后面的文章我会仔细分析Redis的VM机制）</p>
<p><strong>vm-enabled no</strong></p>
</li>
<li>
<p>虚拟内存文件路径，默认值为/tmp/redis.swap，不可多个Redis实例共享</p>
<p><strong>vm-swap-file /tmp/redis.swap</strong></p>
</li>
<li>
<p>将所有大于vm-max-memory的数据存入虚拟内存,无论vm-max-memory设置多小,所有索引数据都是内存存储的(Redis的索引数据 就是keys),也就是说,当vm-max-memory设置为0的时候,其实是所有value都存在于磁盘。默认值为0</p>
<p><strong>vm-max-memory 0</strong></p>
</li>
<li>
<p>Redis swap文件分成了很多的page，一个对象可以保存在多个page上面，但一个page上不能被多个对象共享，vm-page-size是要根据存储的 数据大小来设定的，作者建议如果存储很多小对象，page大小最好设置为32或者64bytes；如果存储很大大对象，则可以使用更大的page，如果不 确定，就使用默认值</p>
<p><strong>vm-page-size 32</strong></p>
</li>
<li>
<p>设置swap文件中的page数量，由于页表（一种表示页面空闲或使用的bitmap）是在放在内存中的，，在磁盘上每8个pages将消耗1byte的内存。</p>
<p><strong>vm-pages 134217728</strong></p>
</li>
<li>
<p>设置访问swap文件的线程数,最好不要超过机器的核数,如果设置为0,那么所有对swap文件的操作都是串行的，可能会造成比较长时间的延迟。默认值为4</p>
<p><strong>vm-max-threads 4</strong></p>
</li>
<li>
<p>设置在向客户端应答时，是否把较小的包合并为一个包发送，默认为开启</p>
<p><strong>glueoutputbuf yes</strong></p>
</li>
<li>
<p>指定在超过一定的数量或者最大的元素超过某一临界值时，采用一种特殊的哈希算法</p>
<p><strong>hash-max-zipmap-entries 64</strong></p>
<p><strong>hash-max-zipmap-value 512</strong></p>
</li>
<li>
<p>指定是否激活重置哈希，默认为开启（后面在介绍Redis的哈希算法时具体介绍）</p>
<p><strong>activerehashing yes</strong></p>
</li>
<li>
<p>指定包含其它的配置文件，可以在同一主机上多个Redis实例之间使用同一份配置文件，而同时各个实例又拥有自己的特定配置文件</p>
<p><strong>include /path/to/local.conf</strong></p>
</li>
</ol>
<h2 id="四、redis数据类型"> 四、Redis数据类型</h2>
<p>Redis支持五种数据类型：<code>string（字符串）</code>，<code>hash（哈希）</code>，<code>list（列表）</code>，<code>set（集合）</code>及<code>zset(sorted set：有序集合)</code>。</p>
<h3 id="一-string-字符串"> （一）String（字符串）</h3>
<p>string是redis最基本的类型，你可以理解成与Memcached一模一样的类型，一个<code>key</code>对应一个<code>value</code>。</p>
<p>string类型是二进制安全的。意思是redis的string可以包含任何数据。比如<code>jpg</code>图片或者序列化的对象 。</p>
<p>string类型是Redis最基本的数据类型，一个键最大能存储512MB。</p>
<p><strong>实例</strong></p>
<div><pre><code><span>127.0</span>.0.1:637<span><span>9</span>></span> SET name <span>"redis-base"</span>
OK
<span>127.0</span>.0.1:637<span><span>9</span>></span> GET name
<span>"redis-base"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>在以上实例中我们使用了 Redis的 <strong>SET</strong> 和 <strong>GET</strong> 命令。键为 <code>name</code>，对应的值为<code>redis-base</code>。</p>
<p>**注意：**一个键最大能存储512MB。</p>
<h3 id="二-hash-哈希"> （二）Hash（哈希）</h3>
<p>Redis hash是一个键值 <code>(key=&gt;value)</code> 对集合。</p>
<p>Redis hash是一个 string类型的<code>field</code> 和 <code>value</code> 的映射表，<code>hash</code> 特别适合用于存储对象。</p>
<p><strong>实例</strong></p>
<div><pre><code><span>127.0</span>.0.1:637<span><span>9</span>></span> HMSET user:1 username password points <span>200</span>
OK
<span>127.0</span>.0.1:637<span><span>9</span>></span> HGETALL user:1
<span>1</span><span>)</span> <span>"username"</span>
<span>2</span><span>)</span> <span>"password"</span>
<span>3</span><span>)</span> <span>"points"</span>
<span>4</span><span>)</span> <span>"200"</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>以上实例中 <code>hash</code> 数据类型存储了包含用户脚本信息的用户对象。实例中我们使用了 Redis的 <strong><code>HMSET, HGETALL</code></strong> 命令，<strong><code>user:1</code></strong> 为键值。每个 <code>hash</code> 可以存储 2<sup>32</sup> - 1个键值对（40多亿）。</p>
<h3 id="三-list-列表"> （三）List（列表）</h3>
<p>Redis列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。</p>
<p><strong>实例</strong></p>
<div><pre><code><span>127.0</span>.0.1:637<span><span>9</span>></span> LPUSH list_1 redis
<span>(</span>integer<span>)</span> <span>1</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> LPUSH list_1 mongodb
<span>(</span>integer<span>)</span> <span>2</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> LPUSH list_1 rabitmq
<span>(</span>integer<span>)</span> <span>3</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> LRANGE list_1 <span>0</span> <span>10</span>
<span>1</span><span>)</span> <span>"rabitmq"</span>
<span>2</span><span>)</span> <span>"mongodb"</span>
<span>3</span><span>)</span> <span>"redis"</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>列表最多可存储 2<sup>32</sup> - 1 元素 (4294967295, 每个列表可存储40多亿)。</p>
<h3 id="四-set-集合"> （四）Set（集合）</h3>
<p>Redis的 <code>Set</code>是 <code>string</code> 类型的无序集合。</p>
<p><strong>sadd 命令</strong></p>
<p>添加一个 <code>string</code> 元素到<code>key</code> 对应的 <code>set</code> 集合中，成功返回1,如果元素已经在集合中返回0,<code>key</code> 对应的 <code>set</code> 不存在返回错误。</p>
<div><pre><code>sadd key member
</code></pre>
<div><span>1</span><br></div></div><p><strong>实例</strong></p>
<div><pre><code><span>127.0</span>.0.1:637<span><span>9</span>></span> sadd set_1 redis
<span>(</span>integer<span>)</span> <span>1</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> sadd set_1 mongodb
<span>(</span>integer<span>)</span> <span>1</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> sadd set_1 rabitmq
<span>(</span>integer<span>)</span> <span>1</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> sadd set_1 rabitmq
<span>(</span>integer<span>)</span> <span>0</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> smembers set_1
<span>1</span><span>)</span> <span>"rabitmq"</span>
<span>2</span><span>)</span> <span>"mongodb"</span>
<span>3</span><span>)</span> <span>"redis"</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>**注意：**以上实例中 <code>rabitmq</code> 添加了两次，但根据集合内元素的唯一性，第二次插入的元素将被忽略。</p>
<p>集合中最大的成员数为 2<sup>32</sup>- 1 (4294967295, 每个集合可存储40多亿个成员)。</p>
<h3 id="五-zset-sorted-set-有序集合"> （五）zset(sorted set：有序集合)</h3>
<p><code>Redis zset</code> 和<code>set</code> 一样也是 <code>string</code> 类型元素的集合,且不允许重复的成员。</p>
<p>不同的是每个元素都会关联一个 <code>double</code> 类型的分数。redis`正是通过分数来为集合中的成员进行从小到大的排序。</p>
<p><code>zset</code> 的成员是唯一的,但分数<code>(score)</code>却可以重复。</p>
<p><strong>zadd命令</strong></p>
<p>添加元素到集合，元素在集合中存在则更新对应 <code>score</code></p>
<div><pre><code>zadd key score member 
</code></pre>
<div><span>1</span><br></div></div><p><strong>实例</strong></p>
<div><pre><code><span>127.0</span>.0.1:637<span><span>9</span>></span> zadd zset_1 <span>0</span> redis
<span>(</span>integer<span>)</span> <span>1</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> zadd zset_1 <span>0</span> rabbitmq
<span>(</span>integer<span>)</span> <span>1</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> zadd zset_1 <span>0</span> mysql
<span>(</span>integer<span>)</span> <span>1</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> zrangebyscore zset_1 <span>0</span> <span>100</span>
<span>1</span><span>)</span> <span>"mysql"</span>
<span>2</span><span>)</span> <span>"rabbitmq"</span>
<span>3</span><span>)</span> <span>"redis"</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div>]]></content>
    <author>
      <name>南辞</name>
    </author>
    <category term="数据库"/>
    <contributor>
      <name>南辞</name>
    </contributor>
    <published>2021-03-31T05:51:25.000Z</published>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">Redis 命令</title>
    <id>http://qiqi.dreamagain.top/software/database/NoSQL/Redis/redis-cmd/</id>
    <link href="http://qiqi.dreamagain.top/software/database/NoSQL/Redis/redis-cmd/"/>
    <updated>2021-03-31T05:51:25.000Z</updated>
    <content type="html"><![CDATA[<h2 id="一、redis-命令"> 一、Redis 命令</h2>
<p>Redis 命令用于在 redis 服务上执行操作。</p>
<p>要在 redis 服务上执行命令需要一个 redis 客户端。Redis 客户端在我们之前下载的的 redis 的安装包中。</p>
<h3 id="一-在本地服务上执行命令"> （一）在本地服务上执行命令</h3>
<p><strong>语法</strong></p>
<p>Redis 客户端的基本语法为：</p>
<div><pre><code>redis-cli
</code></pre>
<div><span>1</span><br></div></div><p><strong>实例</strong></p>
<p>以下实例讲解了如何启动 redis 客户端：</p>
<p>启动 redis 客户端，打开终端并输入命令 <strong>redis-cli</strong>。该命令会连接本地的 redis 服务。</p>
<div><pre><code>C:<span>\</span>Users<span>\</span>Mr Yang<span>></span>redis-cli
<span>127.0</span>.0.1:637<span><span>9</span>></span> PING
PONG
<span>127.0</span>.0.1:637<span><span>9</span>></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>在以上实例中我们连接到本地的 redis 服务并执行 <strong>PING</strong> 命令，该命令用于检测 redis 服务是否启动。</p>
<h3 id="二-在远程服务上执行命令"> （二）在远程服务上执行命令</h3>
<p>如果需要在远程 redis 服务上执行命令，同样我们使用的也是 <strong>redis-cli</strong> 命令。</p>
<p><strong>语法</strong></p>
<div><pre><code>redis-cli -h <span>host</span> -p port -a password
</code></pre>
<div><span>1</span><br></div></div><p><strong>实例</strong></p>
<p>以下实例演示了如何连接到主机为 127.0.0.1，端口为 6379 ，密码为 mypass 的 redis 服务上。</p>
<div><pre><code>C:<span>\</span>Users<span>\</span>Mr Yang<span>></span>redis-cli -h <span>127.0</span>.0.1 -p <span>6379</span> -a <span>"mypass"</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> PING
PONG
<span>127.0</span>.0.1:637<span><span>9</span>></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h2 id="二、redis-键-key"> 二、Redis 键(key)</h2>
<p>Redis 键命令用于管理 redis 的键。</p>
<p><strong>语法</strong></p>
<p>Redis 键命令的基本语法如下：</p>
<div><pre><code><span>127.0</span>.0.1:637<span><span>9</span>></span> <span>command</span> key_name
</code></pre>
<div><span>1</span><br></div></div><p><strong>实例</strong></p>
<div><pre><code><span>127.0</span>.0.1:637<span><span>9</span>></span> SET key_1 redis
OK
<span>127.0</span>.0.1:637<span><span>9</span>></span> DEL key_1
<span>(</span>integer<span>)</span> <span>1</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>在以上实例中 <strong>DEL</strong> 是一个命令， <strong>key_1</strong> 是一个键。 如果键被删除成功，命令执行后输出 <strong>(integer) 1</strong>，否则将输出 <strong>(integer) 0</strong></p>
<h3>Redis keys 命令</h3>
<p>下表给出了与 Redis 键相关的基本命令：</p>
<table>
<thead>
<tr>
<th style="text-align:left">序号</th>
<th style="text-align:left">命令及描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left"><a href="https://www.w3cschool.cn/redis/keys-del.html" target="_blank" rel="noopener noreferrer">DEL key</a> 该命令用于在 key 存在时删除 key。</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left"><a href="https://www.w3cschool.cn/redis/keys-dump.html" target="_blank" rel="noopener noreferrer">DUMP key</a> 序列化给定 key ，并返回被序列化的值。</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left"><a href="https://www.w3cschool.cn/redis/keys-exists.html" target="_blank" rel="noopener noreferrer">EXISTS key</a> 检查给定 key 是否存在。</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left"><a href="https://www.w3cschool.cn/redis/keys-expire.html" target="_blank" rel="noopener noreferrer">EXPIRE key</a> seconds 为给定 key 设置过期时间。</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left"><a href="https://www.w3cschool.cn/redis/keys-expireat.html" target="_blank" rel="noopener noreferrer">EXPIREAT key timestamp</a> EXPIREAT 的作用和 EXPIRE 类似，都用于为 key 设置过期时间。 不同在于 EXPIREAT 命令接受的时间参数是 UNIX 时间戳(unix timestamp)。</td>
</tr>
<tr>
<td style="text-align:left">6</td>
<td style="text-align:left"><a href="https://www.w3cschool.cn/redis/keys-pexpire.html" target="_blank" rel="noopener noreferrer">PEXPIRE key milliseconds</a> 设置 key 的过期时间以毫秒计。</td>
</tr>
<tr>
<td style="text-align:left">7</td>
<td style="text-align:left"><a href="https://www.w3cschool.cn/redis/keys-pexpireat.html" target="_blank" rel="noopener noreferrer">PEXPIREAT key milliseconds-timestamp</a> 设置 key 过期时间的时间戳(unix timestamp) 以毫秒计</td>
</tr>
<tr>
<td style="text-align:left">8</td>
<td style="text-align:left"><a href="https://www.w3cschool.cn/redis/keys-keys.html" target="_blank" rel="noopener noreferrer">KEYS pattern</a> 查找所有符合给定模式( pattern)的 key 。</td>
</tr>
<tr>
<td style="text-align:left">9</td>
<td style="text-align:left"><a href="https://www.w3cschool.cn/redis/keys-move.html" target="_blank" rel="noopener noreferrer">MOVE key db</a> 将当前数据库的 key 移动到给定的数据库 db 当中。</td>
</tr>
<tr>
<td style="text-align:left">10</td>
<td style="text-align:left"><a href="https://www.w3cschool.cn/redis/keys-persist.html" target="_blank" rel="noopener noreferrer">PERSIST key</a> 移除 key 的过期时间，key 将持久保持。</td>
</tr>
<tr>
<td style="text-align:left">11</td>
<td style="text-align:left"><a href="https://www.w3cschool.cn/redis/keys-pttl.html" target="_blank" rel="noopener noreferrer">PTTL key</a> 以毫秒为单位返回 key 的剩余的过期时间。</td>
</tr>
<tr>
<td style="text-align:left">12</td>
<td style="text-align:left"><a href="https://www.w3cschool.cn/redis/keys-ttl.html" target="_blank" rel="noopener noreferrer">TTL key</a> 以秒为单位，返回给定 key 的剩余生存时间(TTL, time to live)。</td>
</tr>
<tr>
<td style="text-align:left">13</td>
<td style="text-align:left"><a href="https://www.w3cschool.cn/redis/keys-randomkey.html" target="_blank" rel="noopener noreferrer">RANDOMKEY</a> 从当前数据库中随机返回一个 key 。</td>
</tr>
<tr>
<td style="text-align:left">14</td>
<td style="text-align:left"><a href="https://www.w3cschool.cn/redis/keys-rename.html" target="_blank" rel="noopener noreferrer">RENAME key newkey</a> 修改 key 的名称</td>
</tr>
<tr>
<td style="text-align:left">15</td>
<td style="text-align:left"><a href="https://www.w3cschool.cn/redis/keys-renamenx.html" target="_blank" rel="noopener noreferrer">RENAMENX key newkey</a> 仅当 newkey 不存在时，将 key 改名为 newkey 。</td>
</tr>
<tr>
<td style="text-align:left">16</td>
<td style="text-align:left"><a href="https://www.w3cschool.cn/redis/keys-type.html" target="_blank" rel="noopener noreferrer">TYPE key</a> 返回 key 所储存的值的类型。</td>
</tr>
</tbody>
</table>
<h2 id="三、redis-字符串-string"> 三、Redis 字符串(String)</h2>
<p>Redis 字符串数据类型的相关命令用于管理 redis 字符串值，基本语法如下：</p>
<p><strong>语法</strong></p>
<div><pre><code><span>127.0</span>.0.1:637<span><span>9</span>></span> COMMAND KEY_NAME
</code></pre>
<div><span>1</span><br></div></div><p><strong>实例</strong></p>
<div><pre><code><span>127.0</span>.0.1:637<span><span>9</span>></span> SET key_2 redis
OK
<span>127.0</span>.0.1:637<span><span>9</span>></span> DEL key_2
<span>(</span>integer<span>)</span> <span>1</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>在以上实例中我们使用了 <strong>SET</strong> 和 <strong>GET</strong> 命令，键为 key_2。</p>
<h3>Redis 字符串命令</h3>
<p>下表列出了常用的 redis 字符串命令：</p>
<table>
<thead>
<tr>
<th style="text-align:left">序号</th>
<th style="text-align:left">命令及描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left"><a href="https://www.w3cschool.cn/redis/strings-set.html" target="_blank" rel="noopener noreferrer">SET key value</a> 设置指定 key 的值</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left"><a href="https://www.w3cschool.cn/redis/strings-get.html" target="_blank" rel="noopener noreferrer">GET key</a> 获取指定 key 的值。</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left"><a href="https://www.w3cschool.cn/redis/strings-getrange.html" target="_blank" rel="noopener noreferrer">GETRANGE key start end</a> 返回 key 中字符串值的子字符</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left"><a href="https://www.w3cschool.cn/redis/strings-getset.html" target="_blank" rel="noopener noreferrer">GETSET key value</a> 将给定 key 的值设为 value ，并返回 key 的旧值(old value)。</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left"><a href="https://www.w3cschool.cn/redis/strings-getbit.html" target="_blank" rel="noopener noreferrer">GETBIT key offset</a> 对 key 所储存的字符串值，获取指定偏移量上的位(bit)。</td>
</tr>
<tr>
<td style="text-align:left">6</td>
<td style="text-align:left"><a href="https://www.w3cschool.cn/redis/strings-mget.html" target="_blank" rel="noopener noreferrer">MGET key1 [key2..]</a> 获取所有(一个或多个)给定 key 的值。</td>
</tr>
<tr>
<td style="text-align:left">7</td>
<td style="text-align:left"><a href="https://www.w3cschool.cn/redis/strings-setbit.html" target="_blank" rel="noopener noreferrer">SETBIT key offset value</a> 对 key 所储存的字符串值，设置或清除指定偏移量上的位(bit)。</td>
</tr>
<tr>
<td style="text-align:left">8</td>
<td style="text-align:left"><a href="https://www.w3cschool.cn/redis/strings-setex.html" target="_blank" rel="noopener noreferrer">SETEX key seconds value</a> 将值 value 关联到 key ，并将 key 的过期时间设为 seconds (以秒为单位)。</td>
</tr>
<tr>
<td style="text-align:left">9</td>
<td style="text-align:left"><a href="https://www.w3cschool.cn/redis/strings-setnx.html" target="_blank" rel="noopener noreferrer">SETNX key value</a> 只有在 key 不存在时设置 key 的值。</td>
</tr>
<tr>
<td style="text-align:left">10</td>
<td style="text-align:left"><a href="https://www.w3cschool.cn/redis/strings-setrange.html" target="_blank" rel="noopener noreferrer">SETRANGE key offset value</a> 用 value 参数覆写给定 key 所储存的字符串值，从偏移量 offset 开始。</td>
</tr>
<tr>
<td style="text-align:left">11</td>
<td style="text-align:left"><a href="https://www.w3cschool.cn/redis/strings-strlen.html" target="_blank" rel="noopener noreferrer">STRLEN key</a> 返回 key 所储存的字符串值的长度。</td>
</tr>
<tr>
<td style="text-align:left">12</td>
<td style="text-align:left"><a href="https://www.w3cschool.cn/redis/strings-mset.html" target="_blank" rel="noopener noreferrer">MSET key value [key value ...]</a> 同时设置一个或多个 key-value 对。</td>
</tr>
<tr>
<td style="text-align:left">13</td>
<td style="text-align:left"><a href="https://www.w3cschool.cn/redis/strings-msetnx.html" target="_blank" rel="noopener noreferrer">MSETNX key value [key value ...]</a> 同时设置一个或多个 key-value 对，当且仅当所有给定 key 都不存在。</td>
</tr>
<tr>
<td style="text-align:left">14</td>
<td style="text-align:left"><a href="https://www.w3cschool.cn/redis/strings-psetex.html" target="_blank" rel="noopener noreferrer">PSETEX key milliseconds value</a> 这个命令和 SETEX 命令相似，但它以毫秒为单位设置 key 的生存时间，而不是像 SETEX 命令那样，以秒为单位。</td>
</tr>
<tr>
<td style="text-align:left">15</td>
<td style="text-align:left"><a href="https://www.w3cschool.cn/redis/strings-incr.html" target="_blank" rel="noopener noreferrer">INCR key</a> 将 key 中储存的数字值增一。</td>
</tr>
<tr>
<td style="text-align:left">16</td>
<td style="text-align:left"><a href="https://www.w3cschool.cn/redis/strings-incrby.html" target="_blank" rel="noopener noreferrer">INCRBY key increment</a> 将 key 所储存的值加上给定的增量值（increment） 。</td>
</tr>
<tr>
<td style="text-align:left">17</td>
<td style="text-align:left"><a href="https://www.w3cschool.cn/redis/strings-incrbyfloat.html" target="_blank" rel="noopener noreferrer">INCRBYFLOAT key increment</a> 将 key 所储存的值加上给定的浮点增量值（increment） 。</td>
</tr>
<tr>
<td style="text-align:left">18</td>
<td style="text-align:left"><a href="https://www.w3cschool.cn/redis/strings-decr.html" target="_blank" rel="noopener noreferrer">DECR key</a> 将 key 中储存的数字值减一。</td>
</tr>
<tr>
<td style="text-align:left">19</td>
<td style="text-align:left"><a href="https://www.w3cschool.cn/redis/strings-decrby.html" target="_blank" rel="noopener noreferrer">DECRBY key decrement</a> key 所储存的值减去给定的减量值（decrement） 。</td>
</tr>
<tr>
<td style="text-align:left">20</td>
<td style="text-align:left"><a href="https://www.w3cschool.cn/redis/strings-append.html" target="_blank" rel="noopener noreferrer">APPEND key value</a> 如果 key 已经存在并且是一个字符串， APPEND 命令将 value 追加到 key 原来的值的末尾。</td>
</tr>
</tbody>
</table>
<h2 id="四、redis-哈希-hash"> 四、Redis 哈希(Hash)</h2>
<p>Redis hash 是一个string类型的field和value的映射表，hash特别适合用于存储对象。</p>
<p>Redis 中每个 hash 可以存储 2<sup>32</sup> - 1 键值对（40多亿）。</p>
<p><strong>实例</strong></p>
<div><pre><code><span>127.0</span>.0.1:637<span><span>9</span>></span> HMSET key_redis name <span>"redis tutorial"</span> description <span>"redis basic commands for caching"</span> likes <span>20</span> visitors <span>23000</span>
OK
<span>127.0</span>.0.1:637<span><span>9</span>></span> HGETALL key_redis
<span>1</span><span>)</span> <span>"name"</span>
<span>2</span><span>)</span> <span>"redis tutorial"</span>
<span>3</span><span>)</span> <span>"description"</span>
<span>4</span><span>)</span> <span>"redis basic commands for caching"</span>
<span>5</span><span>)</span> <span>"likes"</span>
<span>6</span><span>)</span> <span>"20"</span>
<span>7</span><span>)</span> <span>"visitors"</span>
<span>8</span><span>)</span> <span>"23000"</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>在以上实例中，我们设置了 redis 的一些描述信息(name, description, likes, visitors) 到哈希表的 key_redis中。</p>
<h3>Redis hash 命令</h3>
<p>下表列出了 redis hash 基本的相关命令：</p>
<table>
<thead>
<tr>
<th style="text-align:left">序号</th>
<th style="text-align:left">命令及描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left"><a href="https://www.w3cschool.cn/redis/hashes-hdel.html" target="_blank" rel="noopener noreferrer">HDEL key field2 [field2]</a> 删除一个或多个哈希表字段</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left"><a href="https://www.w3cschool.cn/redis/hashes-hexists.html" target="_blank" rel="noopener noreferrer">HEXISTS key field</a> 查看哈希表 key 中，指定的字段是否存在。</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left"><a href="https://www.w3cschool.cn/redis/hashes-hget.html" target="_blank" rel="noopener noreferrer">HGET key field</a> 获取存储在哈希表中指定字段的值</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left"><a href="https://www.w3cschool.cn/redis/hashes-hgetall.html" target="_blank" rel="noopener noreferrer">HGETALL key</a> 获取在哈希表中指定 key 的所有字段和值</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left"><a href="https://www.w3cschool.cn/redis/hashes-hincrby.html" target="_blank" rel="noopener noreferrer">HINCRBY key field increment</a> 为哈希表 key 中的指定字段的整数值加上增量 increment 。</td>
</tr>
<tr>
<td style="text-align:left">6</td>
<td style="text-align:left"><a href="https://www.w3cschool.cn/redis/hashes-hincrbyfloat.html" target="_blank" rel="noopener noreferrer">HINCRBYFLOAT key field increment</a> 为哈希表 key 中的指定字段的浮点数值加上增量 increment 。</td>
</tr>
<tr>
<td style="text-align:left">7</td>
<td style="text-align:left"><a href="https://www.w3cschool.cn/redis/hashes-hkeys.html" target="_blank" rel="noopener noreferrer">HKEYS key</a> 获取所有哈希表中的字段</td>
</tr>
<tr>
<td style="text-align:left">8</td>
<td style="text-align:left"><a href="https://www.w3cschool.cn/redis/hashes-hlen.html" target="_blank" rel="noopener noreferrer">HLEN key</a> 获取哈希表中字段的数量</td>
</tr>
<tr>
<td style="text-align:left">9</td>
<td style="text-align:left"><a href="https://www.w3cschool.cn/redis/hashes-hmget.html" target="_blank" rel="noopener noreferrer">HMGET key field1 [field2]</a> 获取所有给定字段的值</td>
</tr>
<tr>
<td style="text-align:left">10</td>
<td style="text-align:left"><a href="https://www.w3cschool.cn/redis/hashes-hmset.html" target="_blank" rel="noopener noreferrer">HMSET key field1 value1 [field2 value2 ]</a> 同时将多个 field-value (域-值)对设置到哈希表 key 中。</td>
</tr>
<tr>
<td style="text-align:left">11</td>
<td style="text-align:left"><a href="https://www.w3cschool.cn/redis/hashes-hset.html" target="_blank" rel="noopener noreferrer">HSET key field value</a> 将哈希表 key 中的字段 field 的值设为 value 。</td>
</tr>
<tr>
<td style="text-align:left">12</td>
<td style="text-align:left"><a href="https://www.w3cschool.cn/redis/hashes-hsetnx.html" target="_blank" rel="noopener noreferrer">HSETNX key field value</a> 只有在字段 field 不存在时，设置哈希表字段的值。</td>
</tr>
<tr>
<td style="text-align:left">13</td>
<td style="text-align:left"><a href="https://www.w3cschool.cn/redis/hashes-hvals.html" target="_blank" rel="noopener noreferrer">HVALS key</a> 获取哈希表中所有值</td>
</tr>
<tr>
<td style="text-align:left">14</td>
<td style="text-align:left">HSCAN key cursor [MATCH pattern] [COUNT count] 迭代哈希表中的键值对。</td>
</tr>
</tbody>
</table>
<h2 id="五、redis-列表-list"> 五、Redis 列表(List)</h2>
<p>Redis列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素导列表的头部（左边）或者尾部（右边）</p>
<p>一个列表最多可以包含 2<sup>32</sup> - 1 个元素 (4294967295, 每个列表超过40亿个元素)。</p>
<p><strong>实例</strong></p>
<div><pre><code><span>127.0</span>.0.1:637<span><span>9</span>></span> LPUSH list_1 redis
<span>(</span>integer<span>)</span> <span>1</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> LPUSH list_1 mongodb
<span>(</span>integer<span>)</span> <span>2</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> LPUSH list_1 mysql
<span>(</span>integer<span>)</span> <span>3</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> LRANGE list_1 <span>0</span> <span>10</span>
<span>1</span><span>)</span> <span>"mysql"</span>
<span>2</span><span>)</span> <span>"mongodb"</span>
<span>3</span><span>)</span> <span>"redis"</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>在以上实例中我们使用了 <strong>LPUSH</strong> 将三个值插入了名为 list_1的列表当中。</p>
<h3>Redis 列表命令</h3>
<p>下表列出了列表相关的基本命令：</p>
<table>
<thead>
<tr>
<th style="text-align:left">序号</th>
<th style="text-align:left">命令及描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left"><a href="https://www.w3cschool.cn/redis/lists-blpop.html" target="_blank" rel="noopener noreferrer">BLPOP key1 [key2 ] timeout</a> 移出并获取列表的第一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left"><a href="https://www.w3cschool.cn/redis/lists-brpop.html" target="_blank" rel="noopener noreferrer">BRPOP key1 [key2 ] timeout</a> 移出并获取列表的最后一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left"><a href="https://www.w3cschool.cn/redis/lists-brpoplpush.html" target="_blank" rel="noopener noreferrer">BRPOPLPUSH source destination timeout</a> 从列表中弹出一个值，将弹出的元素插入到另外一个列表中并返回它； 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left"><a href="https://www.w3cschool.cn/redis/lists-lindex.html" target="_blank" rel="noopener noreferrer">LINDEX key index</a> 通过索引获取列表中的元素</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left"><a href="https://www.w3cschool.cn/redis/lists-linsert.html" target="_blank" rel="noopener noreferrer">LINSERT key BEFORE|AFTER pivot value</a> 在列表的元素前或者后插入元素</td>
</tr>
<tr>
<td style="text-align:left">6</td>
<td style="text-align:left"><a href="https://www.w3cschool.cn/redis/lists-llen.html" target="_blank" rel="noopener noreferrer">LLEN key</a> 获取列表长度</td>
</tr>
<tr>
<td style="text-align:left">7</td>
<td style="text-align:left"><a href="https://www.w3cschool.cn/redis/lists-lpop.html" target="_blank" rel="noopener noreferrer">LPOP key</a> 移出并获取列表的第一个元素</td>
</tr>
<tr>
<td style="text-align:left">8</td>
<td style="text-align:left"><a href="https://www.w3cschool.cn/redis/lists-lpush.html" target="_blank" rel="noopener noreferrer">LPUSH key value1 [value2]</a> 将一个或多个值插入到列表头部</td>
</tr>
<tr>
<td style="text-align:left">9</td>
<td style="text-align:left"><a href="https://www.w3cschool.cn/redis/lists-lpushx.html" target="_blank" rel="noopener noreferrer">LPUSHX key value</a> 将一个或多个值插入到已存在的列表头部</td>
</tr>
<tr>
<td style="text-align:left">10</td>
<td style="text-align:left"><a href="https://www.w3cschool.cn/redis/lists-lrange.html" target="_blank" rel="noopener noreferrer">LRANGE key start stop</a> 获取列表指定范围内的元素</td>
</tr>
<tr>
<td style="text-align:left">11</td>
<td style="text-align:left"><a href="https://www.w3cschool.cn/redis/lists-lrem.html" target="_blank" rel="noopener noreferrer">LREM key count value</a> 移除列表元素</td>
</tr>
<tr>
<td style="text-align:left">12</td>
<td style="text-align:left"><a href="https://www.w3cschool.cn/redis/lists-lset.html" target="_blank" rel="noopener noreferrer">LSET key index value</a> 通过索引设置列表元素的值</td>
</tr>
<tr>
<td style="text-align:left">13</td>
<td style="text-align:left"><a href="https://www.w3cschool.cn/redis/lists-ltrim.html" target="_blank" rel="noopener noreferrer">LTRIM key start stop</a> 对一个列表进行修剪(trim)，就是说，让列表只保留指定区间内的元素，不在指定区间之内的元素都将被删除。</td>
</tr>
<tr>
<td style="text-align:left">14</td>
<td style="text-align:left"><a href="https://www.w3cschool.cn/redis/lists-rpop.html" target="_blank" rel="noopener noreferrer">RPOP key</a> 移除并获取列表最后一个元素</td>
</tr>
<tr>
<td style="text-align:left">15</td>
<td style="text-align:left"><a href="https://www.w3cschool.cn/redis/lists-rpoplpush.html" target="_blank" rel="noopener noreferrer">RPOPLPUSH source destination</a> 移除列表的最后一个元素，并将该元素添加到另一个列表并返回</td>
</tr>
<tr>
<td style="text-align:left">16</td>
<td style="text-align:left"><a href="https://www.w3cschool.cn/redis/lists-rpush.html" target="_blank" rel="noopener noreferrer">RPUSH key value1 [value2]</a> 在列表中添加一个或多个值</td>
</tr>
<tr>
<td style="text-align:left">17</td>
<td style="text-align:left"><a href="https://www.w3cschool.cn/redis/lists-rpushx.html" target="_blank" rel="noopener noreferrer">RPUSHX key value</a> 为已存在的列表添加值</td>
</tr>
</tbody>
</table>
<h2 id="六、redis-集合-set"> 六、Redis 集合(Set)</h2>
<p>Redis的Set是string类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据。</p>
<p>Redis 中集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。</p>
<p>集合中最大的成员数为 2<sup>32</sup> - 1 (4294967295, 每个集合可存储40多亿个成员)。</p>
<p><strong>实例</strong></p>
<div><pre><code><span>127.0</span>.0.1:637<span><span>9</span>></span> SADD set_1 redis
<span>(</span>integer<span>)</span> <span>1</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> SADD set_1 mongodb
<span>(</span>integer<span>)</span> <span>1</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> SADD set_1 mysql
<span>(</span>integer<span>)</span> <span>1</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> SADD set_1 mysql
<span>(</span>integer<span>)</span> <span>0</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> SMEMBERS set_1
<span>1</span><span>)</span> <span>"mysql"</span>
<span>2</span><span>)</span> <span>"mongodb"</span>
<span>3</span><span>)</span> <span>"redis"</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>在以上实例中我们通过 <strong>SADD</strong> 命令向名为 set_1的集合插入的三个元素。</p>
<h3>Redis 集合命令</h3>
<p>下表列出了 Redis 集合基本命令：</p>
<table>
<thead>
<tr>
<th style="text-align:left">序号</th>
<th style="text-align:left">命令及描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left"><a href="https://www.w3cschool.cn/redis/sets-sadd.html" target="_blank" rel="noopener noreferrer">SADD key member1 [member2]</a> 向集合添加一个或多个成员</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left"><a href="https://www.w3cschool.cn/redis/sets-scard.html" target="_blank" rel="noopener noreferrer">SCARD key</a> 获取集合的成员数</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left"><a href="https://www.w3cschool.cn/redis/sets-sdiff.html" target="_blank" rel="noopener noreferrer">SDIFF key1 [key2]</a> 返回给定所有集合的差集</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left"><a href="https://www.w3cschool.cn/redis/sets-sdiffstore.html" target="_blank" rel="noopener noreferrer">SDIFFSTORE destination key1 [key2]</a> 返回给定所有集合的差集并存储在 destination 中</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left"><a href="https://www.w3cschool.cn/redis/sets-sinter.html" target="_blank" rel="noopener noreferrer">SINTER key1 [key2]</a> 返回给定所有集合的交集</td>
</tr>
<tr>
<td style="text-align:left">6</td>
<td style="text-align:left"><a href="https://www.w3cschool.cn/redis/sets-sinterstore.html" target="_blank" rel="noopener noreferrer">SINTERSTORE destination key1 [key2]</a> 返回给定所有集合的交集并存储在 destination 中</td>
</tr>
<tr>
<td style="text-align:left">7</td>
<td style="text-align:left"><a href="https://www.w3cschool.cn/redis/sets-sismember.html" target="_blank" rel="noopener noreferrer">SISMEMBER key member</a> 判断 member 元素是否是集合 key 的成员</td>
</tr>
<tr>
<td style="text-align:left">8</td>
<td style="text-align:left"><a href="https://www.w3cschool.cn/redis/sets-smembers.html" target="_blank" rel="noopener noreferrer">SMEMBERS key</a> 返回集合中的所有成员</td>
</tr>
<tr>
<td style="text-align:left">9</td>
<td style="text-align:left"><a href="https://www.w3cschool.cn/redis/sets-smove.html" target="_blank" rel="noopener noreferrer">SMOVE source destination member</a> 将 member 元素从 source 集合移动到 destination 集合</td>
</tr>
<tr>
<td style="text-align:left">10</td>
<td style="text-align:left"><a href="https://www.w3cschool.cn/redis/sets-spop.html" target="_blank" rel="noopener noreferrer">SPOP key</a> 移除并返回集合中的一个随机元素</td>
</tr>
<tr>
<td style="text-align:left">11</td>
<td style="text-align:left"><a href="https://www.w3cschool.cn/redis/sets-srandmember.html" target="_blank" rel="noopener noreferrer">SRANDMEMBER key [count]</a> 返回集合中一个或多个随机数</td>
</tr>
<tr>
<td style="text-align:left">12</td>
<td style="text-align:left"><a href="https://www.w3cschool.cn/redis/sets-srem.html" target="_blank" rel="noopener noreferrer">SREM key member1 [member2]</a> 移除集合中一个或多个成员</td>
</tr>
<tr>
<td style="text-align:left">13</td>
<td style="text-align:left"><a href="https://www.w3cschool.cn/redis/sets-sunion.html" target="_blank" rel="noopener noreferrer">SUNION key1 [key2]</a> 返回所有给定集合的并集</td>
</tr>
<tr>
<td style="text-align:left">14</td>
<td style="text-align:left"><a href="https://www.w3cschool.cn/redis/sets-sunionstore.html" target="_blank" rel="noopener noreferrer">SUNIONSTORE destination key1 [key2]</a> 所有给定集合的并集存储在 destination 集合中</td>
</tr>
<tr>
<td style="text-align:left">15</td>
<td style="text-align:left"><a href="https://www.w3cschool.cn/redis/sets-sscan.html" target="_blank" rel="noopener noreferrer">SSCAN key cursor [MATCH pattern] [COUNT count]</a> 迭代集合中的元素</td>
</tr>
</tbody>
</table>
<h2 id="七、redis-有序集合-sorted-set"> 七、Redis 有序集合(sorted set)</h2>
<p>Redis 有序集合和集合一样也是string类型元素的集合,且不允许重复的成员。</p>
<p>不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。</p>
<p>有序集合的成员是唯一的,但分数(score)却可以重复。</p>
<p>集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。 集合中最大的成员数为 2<sup>32</sup> - 1 (4294967295, 每个集合可存储40多亿个成员)。</p>
<p><strong>实例</strong></p>
<div><pre><code><span>127.0</span>.0.1:637<span><span>9</span>></span> ZADD zset_1 <span>1</span> redis
<span>(</span>integer<span>)</span> <span>1</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> ZADD zset_1 <span>2</span> mongodb
<span>(</span>integer<span>)</span> <span>1</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> ZADD zset_1 <span>3</span> mysql
<span>(</span>integer<span>)</span> <span>1</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> ZADD zset_1 <span>3</span> mysql
<span>(</span>integer<span>)</span> <span>0</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> ZADD zset_1 <span>4</span> mysql
<span>(</span>integer<span>)</span> <span>0</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> ZRANGE zset_1 <span>0</span> <span>10</span> WITHSCORES
<span>1</span><span>)</span> <span>"redis"</span>
<span>2</span><span>)</span> <span>"1"</span>
<span>3</span><span>)</span> <span>"mongodb"</span>
<span>4</span><span>)</span> <span>"2"</span>
<span>5</span><span>)</span> <span>"mysql"</span>
<span>6</span><span>)</span> <span>"4"</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><p>在以上实例中我们通过命令 <strong>ZADD</strong> 向 redis 的有序集合中添加了三个值并关联上分数。</p>
<h3>Redis 有序集合命令</h3>
<p>下表列出了 redis 有序集合的基本命令:</p>
<table>
<thead>
<tr>
<th style="text-align:left">序号</th>
<th style="text-align:left">命令及描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left"><a href="https://www.w3cschool.cn/redis/sorted-sets-zadd.html" target="_blank" rel="noopener noreferrer">ZADD key score1 member1 [score2 member2]</a> 向有序集合添加一个或多个成员，或者更新已存在成员的分数</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left"><a href="https://www.w3cschool.cn/redis/sorted-sets-zcard.html" target="_blank" rel="noopener noreferrer">ZCARD key</a> 获取有序集合的成员数</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left"><a href="https://www.w3cschool.cn/redis/sorted-sets-zcount.html" target="_blank" rel="noopener noreferrer">ZCOUNT key min max</a> 计算在有序集合中指定区间分数的成员数</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left"><a href="https://www.w3cschool.cn/redis/sorted-sets-zincrby.html" target="_blank" rel="noopener noreferrer">ZINCRBY key increment member</a> 有序集合中对指定成员的分数加上增量 increment</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left"><a href="https://www.w3cschool.cn/redis/sorted-sets-zinterstore.html" target="_blank" rel="noopener noreferrer">ZINTERSTORE destination numkeys key [key ...]</a> 计算给定的一个或多个有序集的交集并将结果集存储在新的有序集合 key 中</td>
</tr>
<tr>
<td style="text-align:left">6</td>
<td style="text-align:left"><a href="https://www.w3cschool.cn/redis/sorted-sets-zlexcount.html" target="_blank" rel="noopener noreferrer">ZLEXCOUNT key min max</a> 在有序集合中计算指定字典区间内成员数量</td>
</tr>
<tr>
<td style="text-align:left">7</td>
<td style="text-align:left"><a href="https://www.w3cschool.cn/redis/sorted-sets-zrange.html" target="_blank" rel="noopener noreferrer">ZRANGE key start stop [WITHSCORES]</a> 通过索引区间返回有序集合成指定区间内的成员</td>
</tr>
<tr>
<td style="text-align:left">8</td>
<td style="text-align:left"><a href="https://www.w3cschool.cn/redis/sorted-sets-zrangebylex.html" target="_blank" rel="noopener noreferrer">ZRANGEBYLEX key min max [LIMIT offset count]</a> 通过字典区间返回有序集合的成员</td>
</tr>
<tr>
<td style="text-align:left">9</td>
<td style="text-align:left"><a href="https://www.w3cschool.cn/redis/sorted-sets-zrangebyscore.html" target="_blank" rel="noopener noreferrer">ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT]</a> 通过分数返回有序集合指定区间内的成员</td>
</tr>
<tr>
<td style="text-align:left">10</td>
<td style="text-align:left"><a href="https://www.w3cschool.cn/redis/sorted-sets-zrank.html" target="_blank" rel="noopener noreferrer">ZRANK key member</a> 返回有序集合中指定成员的索引</td>
</tr>
<tr>
<td style="text-align:left">11</td>
<td style="text-align:left"><a href="https://www.w3cschool.cn/redis/sorted-sets-zrem.html" target="_blank" rel="noopener noreferrer">ZREM key member [member ...]</a> 移除有序集合中的一个或多个成员</td>
</tr>
<tr>
<td style="text-align:left">12</td>
<td style="text-align:left"><a href="https://www.w3cschool.cn/redis/sorted-sets-zremrangebylex.html" target="_blank" rel="noopener noreferrer">ZREMRANGEBYLEX key min max</a> 移除有序集合中给定的字典区间的所有成员</td>
</tr>
<tr>
<td style="text-align:left">13</td>
<td style="text-align:left"><a href="https://www.w3cschool.cn/redis/sorted-sets-zremrangebyrank.html" target="_blank" rel="noopener noreferrer">ZREMRANGEBYRANK key start stop</a> 移除有序集合中给定的排名区间的所有成员</td>
</tr>
<tr>
<td style="text-align:left">14</td>
<td style="text-align:left"><a href="https://www.w3cschool.cn/redis/sorted-sets-zremrangebyscore.html" target="_blank" rel="noopener noreferrer">ZREMRANGEBYSCORE key min max</a> 移除有序集合中给定的分数区间的所有成员</td>
</tr>
<tr>
<td style="text-align:left">15</td>
<td style="text-align:left"><a href="https://www.w3cschool.cn/redis/sorted-sets-zrevrange.html" target="_blank" rel="noopener noreferrer">ZREVRANGE key start stop [WITHSCORES]</a> 返回有序集中指定区间内的成员，通过索引，分数从高到底</td>
</tr>
<tr>
<td style="text-align:left">16</td>
<td style="text-align:left"><a href="https://www.w3cschool.cn/redis/sorted-sets-zrevrangebyscore.html" target="_blank" rel="noopener noreferrer">ZREVRANGEBYSCORE key max min [WITHSCORES]</a> 返回有序集中指定分数区间内的成员，分数从高到低排序</td>
</tr>
<tr>
<td style="text-align:left">17</td>
<td style="text-align:left"><a href="https://www.w3cschool.cn/redis/sorted-sets-zrevrank.html" target="_blank" rel="noopener noreferrer">ZREVRANK key member</a> 返回有序集合中指定成员的排名，有序集成员按分数值递减(从大到小)排序</td>
</tr>
<tr>
<td style="text-align:left">18</td>
<td style="text-align:left"><a href="https://www.w3cschool.cn/redis/sorted-sets-zscore.html" target="_blank" rel="noopener noreferrer">ZSCORE key member</a> 返回有序集中，成员的分数值</td>
</tr>
<tr>
<td style="text-align:left">19</td>
<td style="text-align:left"><a href="https://www.w3cschool.cn/redis/sorted-sets-zunionstore.html" target="_blank" rel="noopener noreferrer">ZUNIONSTORE destination numkeys key [key ...]</a> 计算给定的一个或多个有序集的并集，并存储在新的 key 中</td>
</tr>
<tr>
<td style="text-align:left">20</td>
<td style="text-align:left"><a href="https://www.w3cschool.cn/redis/sorted-sets-zscan.html" target="_blank" rel="noopener noreferrer">ZSCAN key cursor [MATCH pattern] [COUNT count]</a> 迭代有序集合中的元素（包括元素成员和元素分值）</td>
</tr>
</tbody>
</table>
<h2 id="八、redis-hyperloglog"> 八、Redis HyperLogLog</h2>
<p>Redis 在 2.8.9 版本添加了 HyperLogLog 结构。</p>
<p>Redis HyperLogLog 是用来做基数统计的算法，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定 的、并且是很小的。</p>
<p>在 Redis 里面，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。</p>
<p>但是，因为 HyperLogLog 只会根据输入元素来计算基数，而不会储存输入元素本身，所以 HyperLogLog 不能像集合那样，返回输入的各个元素。</p>
<p><strong>什么是基数?</strong></p>
<p>比如数据集 {1, 3, 5, 7, 5, 7, 8}， 那么这个数据集的基数集为 {1, 3, 5 ,7, 8}, 基数(不重复元素)为5。 基数估计就是在误差可接受的范围内，快速计算基数。</p>
<p><strong>实例</strong></p>
<p>以下实例演示了 HyperLogLog 的工作过程：</p>
<div><pre><code><span>127.0</span>.0.1:637<span><span>9</span>></span> PFADD hyperloglog <span>"redis"</span>
<span>1</span><span>)</span> <span>(</span>integer<span>)</span> <span>1</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> PFADD hyperloglog <span>"mongodb"</span>
<span>1</span><span>)</span> <span>(</span>integer<span>)</span> <span>1</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> PFADD hyperloglog <span>"mysql"</span>
<span>1</span><span>)</span> <span>(</span>integer<span>)</span> <span>1</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> PFCOUNT hyperloglog
<span>(</span>integer<span>)</span> <span>3</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h3>Redis HyperLogLog 命令</h3>
<p>下表列出了 redis HyperLogLog 的基本命令：</p>
<table>
<thead>
<tr>
<th style="text-align:left">序号</th>
<th style="text-align:left">命令及描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left"><a href="https://www.w3cschool.cn/redis/hyperloglog-pfadd.html" target="_blank" rel="noopener noreferrer">PFADD key element [element ...]</a> 添加指定元素到 HyperLogLog 中。</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left"><a href="https://www.w3cschool.cn/redis/hyperloglog-pfcount.html" target="_blank" rel="noopener noreferrer">PFCOUNT key [key ...]</a> 返回给定 HyperLogLog 的基数估算值。</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left"><a href="https://www.w3cschool.cn/redis/hyperloglog-pfmerge.html" target="_blank" rel="noopener noreferrer">PFMERGE destkey sourcekey [sourcekey ...]</a> 将多个 HyperLogLog 合并为一个 HyperLogLog</td>
</tr>
</tbody>
</table>
<h2 id="九、redis-发布订阅"> 九、Redis 发布订阅</h2>
<p>Redis 发布订阅(pub/sub)是一种消息通信模式：发送者(pub)发送消息，订阅者(sub)接收消息。</p>
<p>Redis 客户端可以订阅任意数量的频道。</p>
<p>下图展示了频道 channel1 ， 以及订阅这个频道的三个客户端 —— client2 、 client5 和 client1 之间的关系：</p>
<p><img src="./assets/subscribe.png" alt=""></p>
<p>当有新消息通过 PUBLISH 命令发送给频道 channel1 时， 这个消息就会被发送给订阅它的三个客户端：</p>
<p><img src="./assets/publish.png" alt="publish"></p>
<p><strong>实例</strong></p>
<p>以下实例演示了发布订阅是如何工作的。在我们实例中我们创建了订阅频道名为 <strong>redisChat</strong>:</p>
<div><pre><code><span>127.0</span>.0.1:637<span><span>9</span>></span> SUBSCRIBE redisChat
Reading messages<span>..</span>. <span>(</span>press Ctrl-C to quit<span>)</span>
<span>1</span><span>)</span> <span>"subscribe"</span>
<span>2</span><span>)</span> <span>"redisChat"</span>
<span>3</span><span>)</span> <span>(</span>integer<span>)</span> <span>1</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>现在，我们先重新开启个 redis 客户端，然后在同一个频道 redisChat 发布两次消息，订阅者就能接收到消息。</p>
<div><pre><code><span>127.0</span>.0.1:637<span><span>9</span>></span> PUBLISH redisChat <span>"Redis is a great caching technique"</span>
<span>(</span>integer<span>)</span> <span>1</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span> PUBLISH redisChat <span>"Learn redis by w3cschool.cn"</span>
<span>(</span>integer<span>)</span> <span>1</span>

<span># 订阅者的客户端会显示如下消息</span>
<span>1</span><span>)</span> <span>"message"</span>
<span>2</span><span>)</span> <span>"redisChat"</span>
<span>3</span><span>)</span> <span>"Redis is a great caching technique"</span>
<span>1</span><span>)</span> <span>"message"</span>
<span>2</span><span>)</span> <span>"redisChat"</span>
<span>3</span><span>)</span> <span>"Learn redis by w3cschool.cn"</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h3>Redis 发布订阅命令</h3>
<p>下表列出了 redis 发布订阅常用命令：</p>
<table>
<thead>
<tr>
<th style="text-align:left">序号</th>
<th style="text-align:left">命令及描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left"><a href="https://www.w3cschool.cn/redis/pub-sub-psubscribe.html" target="_blank" rel="noopener noreferrer">PSUBSCRIBE pattern [pattern ...]</a> 订阅一个或多个符合给定模式的频道。</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left"><a href="https://www.w3cschool.cn/redis/pub-sub-pubsub.html" target="_blank" rel="noopener noreferrer">PUBSUB subcommand [argument [argument ...]]</a> 查看订阅与发布系统状态。</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left"><a href="https://www.w3cschool.cn/redis/pub-sub-publish.html" target="_blank" rel="noopener noreferrer">PUBLISH channel message</a> 将信息发送到指定的频道。</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left"><a href="https://www.w3cschool.cn/redis/pub-sub-punsubscribe.html" target="_blank" rel="noopener noreferrer">PUNSUBSCRIBE [pattern [pattern ...]]</a> 退订所有给定模式的频道。</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left"><a href="https://www.w3cschool.cn/redis/pub-sub-subscribe.html" target="_blank" rel="noopener noreferrer">SUBSCRIBE channel [channel ...]</a> 订阅给定的一个或多个频道的信息。</td>
</tr>
<tr>
<td style="text-align:left">6</td>
<td style="text-align:left"><a href="https://www.w3cschool.cn/redis/pub-sub-unsubscribe.html" target="_blank" rel="noopener noreferrer">UNSUBSCRIBE [channel [channel ...]]</a> 指退订给定的频道。</td>
</tr>
</tbody>
</table>
<h2 id="十、redis-事务"> 十、Redis 事务</h2>
<p>Redis 事务可以一次执行多个命令， 并且带有以下两个重要的保证：</p>
<ul>
<li>事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</li>
<li>事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。</li>
</ul>
<p>一个事务从开始到执行会经历以下三个阶段：</p>
<ul>
<li>开始事务。</li>
<li>命令入队。</li>
<li>执行事务。</li>
</ul>
<p><strong>实例</strong></p>
<p>以下是一个事务的例子， 它先以 <strong>MULTI</strong> 开始一个事务， 然后将多个命令入队到事务中， 最后由 <strong>EXEC</strong> 命令触发事务， 一并执行事务中的所有命令：</p>
<div><pre><code><span>127.0</span>.0.1:637<span><span>9</span>></span> MULTI
OK
<span>127.0</span>.0.1:637<span><span>9</span>></span> SET book-name <span>"Mastering C++ in 21 days"</span>
QUEUED
<span>127.0</span>.0.1:637<span><span>9</span>></span> GET book-name
QUEUED
<span>127.0</span>.0.1:637<span><span>9</span>></span> SADD tag <span>"C++"</span> <span>"Programming"</span> <span>"Mastering Series"</span>
QUEUED
<span>127.0</span>.0.1:637<span><span>9</span>></span> SMEMBERS tag
QUEUED
<span>127.0</span>.0.1:637<span><span>9</span>></span> EXEC
<span>1</span><span>)</span> OK
<span>2</span><span>)</span> <span>"Mastering C++ in 21 days"</span>
<span>3</span><span>)</span> <span>(</span>integer<span>)</span> <span>3</span>
<span>4</span><span>)</span> <span>1</span><span>)</span> <span>"Mastering Series"</span>
   <span>2</span><span>)</span> <span>"Programming"</span>
   <span>3</span><span>)</span> <span>"C++"</span>
<span>127.0</span>.0.1:637<span><span>9</span>></span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><h3>Redis 事务命令</h3>
<p>下表列出了 redis 事务的相关命令：</p>
<table>
<thead>
<tr>
<th style="text-align:left">序号</th>
<th style="text-align:left">命令及描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left"><a href="https://www.w3cschool.cn/redis/transactions-discard.html" target="_blank" rel="noopener noreferrer">DISCARD</a> 取消事务，放弃执行事务块内的所有命令。</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left"><a href="https://www.w3cschool.cn/redis/transactions-exec.html" target="_blank" rel="noopener noreferrer">EXEC</a> 执行所有事务块内的命令。</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left"><a href="https://www.w3cschool.cn/redis/transactions-multi.html" target="_blank" rel="noopener noreferrer">MULTI</a> 标记一个事务块的开始。</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left"><a href="https://www.w3cschool.cn/redis/transactions-unwatch.html" target="_blank" rel="noopener noreferrer">UNWATCH</a> 取消 WATCH 命令对所有 key 的监视。</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left"><a href="https://www.w3cschool.cn/redis/transactions-watch.html" target="_blank" rel="noopener noreferrer">WATCH key [key ...]</a> 监视一个(或多个) key ，如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断。</td>
</tr>
</tbody>
</table>
<h2 id="十一、redis-脚本"> 十一、Redis 脚本</h2>
<p>Redis 脚本使用 Lua 解释器来执行脚本。 Reids 2.6 版本通过内嵌支持 Lua 环境。执行脚本的常用命令为 <strong>EVAL</strong>。</p>
<p><strong>语法</strong></p>
<p>Eval 命令的基本语法如下：</p>
<div><pre><code><span>127.0</span>.0.1:637<span><span>9</span>></span> EVAL script numkeys key <span>[</span>key <span>..</span>.<span>]</span> arg <span>[</span>arg <span>..</span>.<span>]</span>
</code></pre>
<div><span>1</span><br></div></div><p><strong>实例</strong></p>
<p>以下实例演示了 redis 脚本工作过程：</p>
<div><pre><code>redis <span>127.0</span>.0.1:637<span><span>9</span>></span> EVAL <span>"return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}"</span> <span>2</span> key1 key2 first second
<span>1</span><span>)</span> <span>"key1"</span>
<span>2</span><span>)</span> <span>"key2"</span>
<span>3</span><span>)</span> <span>"first"</span>
<span>4</span><span>)</span> <span>"second"</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h3>Redis 脚本命令</h3>
<p>下表列出了 redis 脚本常用命令：</p>
<table>
<thead>
<tr>
<th style="text-align:left">序号</th>
<th style="text-align:left">命令及描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left"><a href="https://www.w3cschool.cn/redis/scripting-eval.html" target="_blank" rel="noopener noreferrer">EVAL script numkeys key [key ...] arg [arg ...]</a> 执行 Lua 脚本。</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left"><a href="https://www.w3cschool.cn/redis/scripting-evalsha.html" target="_blank" rel="noopener noreferrer">EVALSHA sha1 numkeys key [key ...] arg [arg ...]</a> 执行 Lua 脚本。</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left"><a href="https://www.w3cschool.cn/redis/scripting-script-exists.html" target="_blank" rel="noopener noreferrer">SCRIPT EXISTS script [script ...]</a> 查看指定的脚本是否已经被保存在缓存当中。</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left"><a href="https://www.w3cschool.cn/redis/scripting-script-flush.html" target="_blank" rel="noopener noreferrer">SCRIPT FLUSH</a> 从脚本缓存中移除所有脚本。</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left"><a href="https://www.w3cschool.cn/redis/scripting-script-kill.html" target="_blank" rel="noopener noreferrer">SCRIPT KILL</a> 杀死当前正在运行的 Lua 脚本。</td>
</tr>
<tr>
<td style="text-align:left">6</td>
<td style="text-align:left"><a href="https://www.w3cschool.cn/redis/scripting-script-load.html" target="_blank" rel="noopener noreferrer">SCRIPT LOAD script</a> 将脚本 script 添加到脚本缓存中，但并不立即执行这个脚本。</td>
</tr>
</tbody>
</table>
<h2 id="十二、redis-连接"> 十二、Redis 连接</h2>
<p>Redis 连接命令主要是用于连接 redis 服务。</p>
<p><strong>实例</strong></p>
<p>以下实例演示了客户端如何通过密码验证连接到 redis 服务，并检测服务是否在运行：</p>
<div><pre><code><span>127.0</span>.0.1:637<span><span>9</span>></span> AUTH <span>"password"</span>
OK
<span>127.0</span>.0.1:637<span><span>9</span>></span> PING
PONG
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3>Redis 连接命令</h3>
<p>下表列出了 redis 连接的基本命令：</p>
<table>
<thead>
<tr>
<th style="text-align:left">序号</th>
<th style="text-align:left">命令及描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left"><a href="https://www.w3cschool.cn/redis/connection-auth.html" target="_blank" rel="noopener noreferrer">AUTH password</a> 验证密码是否正确</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left"><a href="https://www.w3cschool.cn/redis/connection-echo.html" target="_blank" rel="noopener noreferrer">ECHO message</a> 打印字符串</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left"><a href="https://www.w3cschool.cn/redis/connection-ping.html" target="_blank" rel="noopener noreferrer">PING</a> 查看服务是否运行</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left"><a href="https://www.w3cschool.cn/redis/connection-quit.html" target="_blank" rel="noopener noreferrer">QUIT</a> 关闭当前连接</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left"><a href="https://www.w3cschool.cn/redis/connection-select.html" target="_blank" rel="noopener noreferrer">SELECT index</a> 切换到指定的数据库</td>
</tr>
</tbody>
</table>
<h2 id="十三、redis-服务器"> 十三、Redis 服务器</h2>
<p>Redis 服务器命令主要是用于管理 redis 服务。</p>
<p><strong>实例</strong></p>
<p>以下实例演示了如何获取 redis 服务器的统计信息：</p>
<div><pre><code><span>127.0</span>.0.1:637<span><span>9</span>></span> INFO

<span># Server</span>
redis_version:2.8.13
redis_git_sha1:00000000
redis_git_dirty:0
redis_build_id:c2238b38b1edb0e2
redis_mode:standalone
os:Linux <span>3.5</span>.0-48-generic x86_64
arch_bits:64
multiplexing_api:epoll
gcc_version:4.7.2
process_id:3856
run_id:0e61abd297771de3fe812a3c21027732ac9f41fe
tcp_port:6379
uptime_in_seconds:11554
uptime_in_days:0
hz:10
lru_clock:16651447
config_file:

<span># Clients</span>
connected_clients:1
client-longest_output_list:0
client-biggest_input_buf:0
blocked_clients:0

<span># Memory</span>
used_memory:589016
used_memory_human:575.21K
used_memory_rss:2461696
used_memory_peak:667312
used_memory_peak_human:651.67K
used_memory_lua:33792
mem_fragmentation_ratio:4.18
mem_allocator:jemalloc-3.6.0

<span># Persistence</span>
loading:0
rdb_changes_since_last_save:3
rdb_bgsave_in_progress:0
rdb_last_save_time:1409158561
rdb_last_bgsave_status:ok
rdb_last_bgsave_time_sec:0
rdb_current_bgsave_time_sec:-1
aof_enabled:0
aof_rewrite_in_progress:0
aof_rewrite_scheduled:0
aof_last_rewrite_time_sec:-1
aof_current_rewrite_time_sec:-1
aof_last_bgrewrite_status:ok
aof_last_write_status:ok

<span># Stats</span>
total_connections_received:24
total_commands_processed:294
instantaneous_ops_per_sec:0
rejected_connections:0
sync_full:0
sync_partial_ok:0
sync_partial_err:0
expired_keys:0
evicted_keys:0
keyspace_hits:41
keyspace_misses:82
pubsub_channels:0
pubsub_patterns:0
latest_fork_usec:264

<span># Replication</span>
role:master
connected_slaves:0
master_repl_offset:0
repl_backlog_active:0
repl_backlog_size:1048576
repl_backlog_first_byte_offset:0
repl_backlog_histlen:0

<span># CPU</span>
used_cpu_sys:10.49
used_cpu_user:4.96
used_cpu_sys_children:0.00
used_cpu_user_children:0.01

<span># Keyspace</span>
db0:keys<span>=</span><span>94</span>,expires<span>=</span><span>1</span>,avg_ttl<span>=</span><span>41638810</span>
db1:keys<span>=</span><span>1</span>,expires<span>=</span><span>0</span>,avg_ttl<span>=</span><span>0</span>
db3:keys<span>=</span><span>1</span>,expires<span>=</span><span>0</span>,avg_ttl<span>=</span><span>0</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br></div></div><h3>Redis 服务器命令</h3>
<p>下表列出了 redis 服务器的相关命令:</p>
<table>
<thead>
<tr>
<th style="text-align:left">序号</th>
<th style="text-align:left">命令及描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left"><a href="https://www.w3cschool.cn/redis/server-bgrewriteaof.html" target="_blank" rel="noopener noreferrer">BGREWRITEAOF</a> 异步执行一个 AOF（AppendOnly File） 文件重写操作</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left"><a href="https://www.w3cschool.cn/redis/server-bgsave.html" target="_blank" rel="noopener noreferrer">BGSAVE</a> 在后台异步保存当前数据库的数据到磁盘</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left"><a href="https://www.w3cschool.cn/redis/server-client-kill.html" target="_blank" rel="noopener noreferrer">CLIENT KILL [ip:port] [ID client-id]</a> 关闭客户端连接</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left"><a href="https://www.w3cschool.cn/redis/server-client-list.html" target="_blank" rel="noopener noreferrer">CLIENT LIST</a> 获取连接到服务器的客户端连接列表</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left"><a href="https://www.w3cschool.cn/redis/server-client-getname.html" target="_blank" rel="noopener noreferrer">CLIENT GETNAME</a> 获取连接的名称</td>
</tr>
<tr>
<td style="text-align:left">6</td>
<td style="text-align:left"><a href="https://www.w3cschool.cn/redis/server-client-pause.html" target="_blank" rel="noopener noreferrer">CLIENT PAUSE timeout</a> 在指定时间内终止运行来自客户端的命令</td>
</tr>
<tr>
<td style="text-align:left">7</td>
<td style="text-align:left"><a href="https://www.w3cschool.cn/redis/server-client-setname.html" target="_blank" rel="noopener noreferrer">CLIENT SETNAME connection-name</a> 设置当前连接的名称</td>
</tr>
<tr>
<td style="text-align:left">8</td>
<td style="text-align:left"><a href="https://www.w3cschool.cn/redis/server-cluster-slots.html" target="_blank" rel="noopener noreferrer">CLUSTER SLOTS</a> 获取集群节点的映射数组</td>
</tr>
<tr>
<td style="text-align:left">9</td>
<td style="text-align:left"><a href="https://www.w3cschool.cn/redis/server-command.html" target="_blank" rel="noopener noreferrer">COMMAND</a> 获取 Redis 命令详情数组</td>
</tr>
<tr>
<td style="text-align:left">10</td>
<td style="text-align:left"><a href="https://www.w3cschool.cn/redis/server-command-count.html" target="_blank" rel="noopener noreferrer">COMMAND COUNT</a> 获取 Redis 命令总数</td>
</tr>
<tr>
<td style="text-align:left">11</td>
<td style="text-align:left"><a href="https://www.w3cschool.cn/redis/server-command-getkeys.html" target="_blank" rel="noopener noreferrer">COMMAND GETKEYS</a> 获取给定命令的所有键</td>
</tr>
<tr>
<td style="text-align:left">12</td>
<td style="text-align:left"><a href="https://www.w3cschool.cn/redis/server-time.html" target="_blank" rel="noopener noreferrer">TIME</a> 返回当前服务器时间</td>
</tr>
<tr>
<td style="text-align:left">13</td>
<td style="text-align:left"><a href="https://www.w3cschool.cn/redis/server-command-info.html" target="_blank" rel="noopener noreferrer">COMMAND INFO command-name [command-name ...]</a> 获取指定 Redis 命令描述的数组</td>
</tr>
<tr>
<td style="text-align:left">14</td>
<td style="text-align:left"><a href="https://www.w3cschool.cn/redis/server-config-get.html" target="_blank" rel="noopener noreferrer">CONFIG GET parameter</a> 获取指定配置参数的值</td>
</tr>
<tr>
<td style="text-align:left">15</td>
<td style="text-align:left"><a href="https://www.w3cschool.cn/redis/server-config-rewrite.html" target="_blank" rel="noopener noreferrer">CONFIG REWRITE</a> 对启动 Redis 服务器时所指定的 redis.conf 配置文件进行改写</td>
</tr>
<tr>
<td style="text-align:left">16</td>
<td style="text-align:left"><a href="https://www.w3cschool.cn/redis/server-config-set.html" target="_blank" rel="noopener noreferrer">CONFIG SET parameter value</a> 修改 redis 配置参数，无需重启</td>
</tr>
<tr>
<td style="text-align:left">17</td>
<td style="text-align:left"><a href="https://www.w3cschool.cn/redis/server-config-resetstat.html" target="_blank" rel="noopener noreferrer">CONFIG RESETSTAT</a> 重置 INFO 命令中的某些统计数据</td>
</tr>
<tr>
<td style="text-align:left">18</td>
<td style="text-align:left"><a href="https://www.w3cschool.cn/redis/server-dbsize.html" target="_blank" rel="noopener noreferrer">DBSIZE</a> 返回当前数据库的 key 的数量</td>
</tr>
<tr>
<td style="text-align:left">19</td>
<td style="text-align:left"><a href="https://www.w3cschool.cn/redis/server-debug-object.html" target="_blank" rel="noopener noreferrer">DEBUG OBJECT key</a> 获取 key 的调试信息</td>
</tr>
<tr>
<td style="text-align:left">20</td>
<td style="text-align:left"><a href="https://www.w3cschool.cn/redis/server-debug-segfault.html" target="_blank" rel="noopener noreferrer">DEBUG SEGFAULT</a> 让 Redis 服务崩溃</td>
</tr>
<tr>
<td style="text-align:left">21</td>
<td style="text-align:left"><a href="https://www.w3cschool.cn/redis/server-flushall.html" target="_blank" rel="noopener noreferrer">FLUSHALL</a> 删除所有数据库的所有key</td>
</tr>
<tr>
<td style="text-align:left">22</td>
<td style="text-align:left"><a href="https://www.w3cschool.cn/redis/server-flushdb.html" target="_blank" rel="noopener noreferrer">FLUSHDB</a> 删除当前数据库的所有key</td>
</tr>
<tr>
<td style="text-align:left">23</td>
<td style="text-align:left"><a href="https://www.w3cschool.cn/redis/server-info.html" target="_blank" rel="noopener noreferrer">INFO [section]</a> 获取 Redis 服务器的各种信息和统计数值</td>
</tr>
<tr>
<td style="text-align:left">24</td>
<td style="text-align:left"><a href="https://www.w3cschool.cn/redis/server-lastsave.html" target="_blank" rel="noopener noreferrer">LASTSAVE</a> 返回最近一次 Redis 成功将数据保存到磁盘上的时间，以 UNIX 时间戳格式表示</td>
</tr>
<tr>
<td style="text-align:left">25</td>
<td style="text-align:left"><a href="https://www.w3cschool.cn/redis/server-monitor.html" target="_blank" rel="noopener noreferrer">MONITOR</a> 实时打印出 Redis 服务器接收到的命令，调试用</td>
</tr>
<tr>
<td style="text-align:left">26</td>
<td style="text-align:left"><a href="https://www.w3cschool.cn/redis/server-role.html" target="_blank" rel="noopener noreferrer">ROLE</a> 返回主从实例所属的角色</td>
</tr>
<tr>
<td style="text-align:left">27</td>
<td style="text-align:left"><a href="https://www.w3cschool.cn/redis/server-save.html" target="_blank" rel="noopener noreferrer">SAVE</a> 异步保存数据到硬盘</td>
</tr>
<tr>
<td style="text-align:left">28</td>
<td style="text-align:left"><a href="https://www.w3cschool.cn/redis/server-shutdown.html" target="_blank" rel="noopener noreferrer">SHUTDOWN [NOSAVE] [SAVE]</a> 异步保存数据到硬盘，并关闭服务器</td>
</tr>
<tr>
<td style="text-align:left">29</td>
<td style="text-align:left"><a href="https://www.w3cschool.cn/redis/server-slaveof.html" target="_blank" rel="noopener noreferrer">SLAVEOF host port</a> 将当前服务器转变为指定服务器的从属服务器(slave server)</td>
</tr>
<tr>
<td style="text-align:left">30</td>
<td style="text-align:left"><a href="https://www.w3cschool.cn/redis/server-showlog.html" target="_blank" rel="noopener noreferrer">SLOWLOG subcommand [argument]</a> 管理 redis 的慢日志</td>
</tr>
<tr>
<td style="text-align:left">31</td>
<td style="text-align:left"><a href="https://www.w3cschool.cn/redis/server-sync.html" target="_blank" rel="noopener noreferrer">SYNC</a> 用于复制功能(replication)的内部命令</td>
</tr>
</tbody>
</table>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <category term="数据库"/>
    <contributor>
      <name>南辞</name>
    </contributor>
    <published>2021-03-31T05:51:25.000Z</published>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">MySQL-DDL</title>
    <id>http://qiqi.dreamagain.top/software/database/SQL/MySQL/MySQL-DDL/</id>
    <link href="http://qiqi.dreamagain.top/software/database/SQL/MySQL/MySQL-DDL/"/>
    <updated>2021-03-31T05:51:25.000Z</updated>
    <summary type="html"><![CDATA[<blockquote>
<p><img src="https://img.shields.io/badge/DDL-Data_Definition_Language-blue.svg" alt=""></p>
</blockquote>
]]></summary>
    <content type="html"><![CDATA[<blockquote>
<p><img src="https://img.shields.io/badge/DDL-Data_Definition_Language-blue.svg" alt=""></p>
</blockquote>

<h2 style="color:#ab4642" align="center">DDL语言</h2>
<p><strong>数据定义语言</strong></p>
<ul>
<li>
<p><strong>库的管理</strong></p>
<p>（1）创建库：create database</p>
<p>（2）修改库：alter database</p>
<p>（3）删除库：drop database</p>
</li>
<li>
<p><strong>表的管理</strong></p>
<p>（1）表的创建：create table</p>
<p>（2）表的修改：alter table</p>
<p>（3）表的删除：drop table</p>
<p>（4）表的复制：create table 表1 like 表2</p>
</li>
<li>
<p><strong>数据类型</strong></p>
<p>（1）数值型</p>
<p>（2）字符型</p>
<p>（3）日期型</p>
</li>
</ul>
<h2 id="一、库的管理"> 一、库的管理</h2>
<h3 id="一-创建库"> （一）创建库</h3>
<div><pre><code><span>create</span> <span>database</span> 【<span>if</span> <span>not</span> <span>exists</span>】 库名【 <span>character</span> <span>set</span> 字符集名】<span>;</span>
<span>#案例：创建库Books</span>
  <span>CREATE</span> <span>DATABASE</span> <span>IF</span> <span>NOT</span> <span>EXISTS</span> books <span>;</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id="二-修改库"> （二）修改库</h3>
<div><pre><code><span>alter</span> <span>database</span> 库名 <span>character</span> <span>set</span> 字符集名<span>;</span>
<span># 案例：更改库的字符集</span>
<span>ALTER</span> <span>DATABASE</span> books <span>CHARACTER</span> <span>SET</span> gbk<span>;</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id="三-删除库"> （三）删除库</h3>
<div><pre><code><span>drop</span> <span>database</span> 【<span>if</span> <span>exists</span>】 库名<span>;</span>
<span># 案例：库的删除</span>
<span>DROP</span> <span>DATABASE</span> <span>IF</span> <span>EXISTS</span> books<span>;</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h2 id="二、表的管理"> 二、表的管理</h2>
<h3 id="一-表的创建-★"> （一）表的创建 ★</h3>
<div><pre><code><span>/*
语法：
create table 表名(
	列名 列的类型【(长度) 约束】,
	列名 列的类型【(长度) 约束】,
	列名 列的类型【(长度) 约束】,
	...
	列名 列的类型【(长度) 约束】
)
*/</span>
<span>#案例：创建表Book</span>
<span>CREATE</span> <span>TABLE</span> book <span>(</span>
  id <span>INT</span><span>,</span>
  <span>#编号</span>
  bName <span>VARCHAR</span> <span>(</span><span>20</span><span>)</span><span>,</span>
  <span>#图书名</span>
  price <span>DOUBLE</span><span>,</span>
  <span>#价格</span>
  authorId <span>INT</span><span>,</span>
  <span>#作者编号</span>
  publishDate <span>DATETIME</span><span>#出版日期</span>
<span>)</span> <span>;</span>

<span>DESC</span> book<span>;</span>

<span>#案例：创建表author</span>
<span>CREATE</span> <span>TABLE</span> <span>IF</span> <span>NOT</span> <span>EXISTS</span> author <span>(</span>
  id <span>INT</span><span>,</span>
  au_n<span>`</span>author<span>`</span>ame <span>VARCHAR</span> <span>(</span><span>20</span><span>)</span><span>,</span>
  nation <span>VARCHAR</span> <span>(</span><span>10</span><span>)</span>
<span>)</span><span>;</span>
<span>DESC</span> author <span>;</span>
 
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br></div></div><h3 id="二-表的修改"> （二）表的修改</h3>
<div><pre><code><span>1.</span>添加列
<span>alter</span> <span>table</span> 表名 <span>add</span> <span>column</span> 列名 类型 【<span>first</span><span>|</span><span>after</span> 字段名】<span>;</span>
<span>2.</span>修改列的类型或约束
<span>alter</span> <span>table</span> 表名 <span>modify</span> <span>column</span> 列名 新类型 【新约束】<span>;</span>
<span>3.</span>修改列名
<span>alter</span> <span>table</span> 表名 change <span>column</span> 旧列名 新列名 类型<span>;</span>
<span>4.</span>删除列
<span>alter</span> <span>table</span> 表名 <span>drop</span> <span>column</span> 列名<span>;</span>
<span>5.</span>修改表名
<span>alter</span> <span>table</span> 表名 <span>rename</span> 【<span>to</span>】 新表名<span>;</span>

案例：
<span>#①修改列名</span>
<span>ALTER</span> <span>TABLE</span> book CHANGE <span>COLUMN</span> publishdate pubDate <span>DATETIME</span> <span>;</span>

<span>#②修改列的类型或约束</span>
<span>ALTER</span> <span>TABLE</span> book <span>MODIFY</span> <span>COLUMN</span> pubdate <span>TIMESTAMP</span><span>;</span>

<span>#③添加新列</span>
<span>ALTER</span> <span>TABLE</span> author <span>ADD</span> <span>COLUMN</span> annual <span>DOUBLE</span><span>;</span> 

<span>#④删除列</span>
<span>ALTER</span> <span>TABLE</span> book_author <span>DROP</span> <span>COLUMN</span>  annual<span>;</span>

<span>#⑤修改表名</span>
<span>ALTER</span> <span>TABLE</span> book_author <span>RENAME</span> <span>TO</span> author<span>;</span>

<span>DESC</span> book<span>;</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br></div></div><h3 id="三-表的删除"> （三）表的删除</h3>
<div><pre><code><span>drop</span> <span>table</span>【<span>if</span> <span>exists</span>】 表名<span>;</span>

案例：
<span>DROP</span> <span>TABLE</span> <span>IF</span> <span>EXISTS</span> book_author<span>;</span>

<span>SHOW</span> <span>TABLES</span><span>;</span>

<span>#通用的写法：</span>
<span>DROP</span> <span>DATABASE</span> <span>IF</span> <span>EXISTS</span> 旧库名<span>;</span>
<span>CREATE</span> <span>DATABASE</span> 新库名 <span>;</span>

<span>DROP</span> <span>TABLE</span> <span>IF</span> <span>EXISTS</span> 旧表名<span>;</span>
<span>CREATE</span> <span>TABLE</span>  表名<span>(</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h3 id="四-表的复制"> （四）表的复制</h3>
<div><pre><code><span>1</span>、复制表的结构
<span>create</span> <span>table</span> 表名 <span>like</span> 旧表<span>;</span>
<span>2</span>、复制表的结构<span>+</span>数据
<span>create</span> <span>table</span> 表名 
<span>select</span> 查询列表 <span>from</span> 旧表【<span>where</span> 筛选】<span>;</span>

案例
<span>INSERT</span> <span>INTO</span> author <span>VALUES</span>
<span>(</span><span>1</span><span>,</span><span>'村上春树'</span><span>,</span><span>'日本'</span><span>)</span><span>,</span>
<span>(</span><span>2</span><span>,</span><span>'莫言'</span><span>,</span><span>'中国'</span><span>)</span><span>,</span>
<span>(</span><span>3</span><span>,</span><span>'冯唐'</span><span>,</span><span>'中国'</span><span>)</span><span>,</span>
<span>(</span><span>4</span><span>,</span><span>'金庸'</span><span>,</span><span>'中国'</span><span>)</span><span>;</span>

<span>SELECT</span> <span>*</span> <span>FROM</span> Author<span>;</span>
<span>SELECT</span> <span>*</span> <span>FROM</span> copy2<span>;</span>

<span>#1.仅仅复制表的结构</span>
<span>CREATE</span> <span>TABLE</span> copy <span>LIKE</span> author<span>;</span>

<span>#2.复制表的结构+数据</span>
<span>CREATE</span> <span>TABLE</span> copy2 <span>SELECT</span> <span>*</span> <span>FROM</span> author<span>;</span>

<span>#只复制部分数据</span>
<span>CREATE</span> <span>TABLE</span> copy3 <span>SELECT</span> id<span>,</span>au_name
<span>FROM</span> author <span>WHERE</span> nation<span>=</span><span>'中国'</span><span>;</span>

<span>#仅仅复制某些字段</span>
<span>CREATE</span> <span>TABLE</span> copy4 <span>SELECT</span> id<span>,</span>au_name
<span>FROM</span> author <span>WHERE</span> <span>0</span><span>;</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br></div></div><h2 id="三、数据类型"> 三、数据类型</h2>
<h3 id="一-数值型"> （一）数值型</h3>
<p><strong>1、整型</strong></p>
<ul>
<li>
<p>分类：</p>
<div><pre><code><span>tinyint</span>、<span>smallint</span>、<span>mediumint</span>、<span>int</span><span>/</span><span>integer</span>、<span>bigint</span>
<span>1</span>	       <span>2</span>		   <span>3</span>	       <span>4</span>		 <span>8</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div></li>
<li>
<p>特点：</p>
<p>① 如果不设置无符号还是有符号，默认是有符号，如果想设置无符号，需要添加unsigned关键字</p>
<p>② 如果插入的数值超出了整型的范围,会报out of range异常，并且插入临界值</p>
<p>③ 如果不设置长度，会有默认的长度
长度代表了显示的最大宽度，如果不够会用0在左边填充，但必须搭配zerofill使用！</p>
</li>
<li>
<p>案例</p>
<div><pre><code>#1.如何设置无符号和有符号
DROP TABLE IF EXISTS tab_int ;

CREATE TABLE tab_int (t1 INT (7) ZEROFILL, t2 INT (7) ZEROFILL) ;

DESC tab_int ;

INSERT INTO tab_int VALUES (- 123456) ;

INSERT INTO tab_int VALUES (- 123456, - 123456) ;

INSERT INTO tab_int VALUES (2147483648, 4294967296) ;

INSERT INTO tab_int VALUES (123, 123) ;

SELECT * FROM tab_int ;
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div></li>
</ul>
<p><strong>2、浮点型</strong></p>
<ul>
<li>
<p>定点数：decimal(M,D)</p>
</li>
<li>
<p>浮点数：float(M,D) 4；double(M,D) 8</p>
</li>
<li>
<p>特点：</p>
<p>①M代表整数部位+小数部位的个数，D代表小数部位</p>
<p>②如果超出范围，则报out or range异常，并且插入临界值</p>
<p>③M和D都可以省略，但对于定点数，M默认为10，D默认为0</p>
<p>④如果精度要求较高，则优先考虑使用定点数</p>
</li>
<li>
<p>案例</p>
<div><pre><code>#测试M和D
DROP TABLE tab_float ;

CREATE TABLE tab_float (f1 FLOAT, f2 DOUBLE, f3 DECIMAL) ;

SELECT * FROM tab_float ;

DESC tab_float ;

INSERT INTO tab_float VALUES(123.4523,123.4523,123.4523);
INSERT INTO tab_float VALUES(123.456,123.456,123.456);
INSERT INTO tab_float VALUES(123.4,123.4,123.4);
INSERT INTO tab_float VALUES(1523.4,1523.4,1523.4);

#原则：
#所选择的类型越简单越好，能保存数值的类型越小越好
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div></li>
</ul>
<h3 id="二-字符型"> （二）字符型</h3>
<ul>
<li>
<p>较短的文本：char、varchar</p>
</li>
<li>
<p>其他：</p>
<p>①binary和varbinary用于保存较短的二进制</p>
<p>②enum用于保存枚举</p>
<p>③set用于保存集合</p>
</li>
<li>
<p>较长的文本：text、blob(较大的二进制)</p>
</li>
<li>
<p>特点</p>
<div><pre><code>写法			          M的意思						  特点		  空间的耗费	   效率
<span>char</span>	<span>char</span><span>(</span>M<span>)</span>		最大的字符数，可以省略，默认为<span>1</span>	 固定长度的字符	 比较耗费	   高

<span>varchar</span>	<span>varchar</span><span>(</span>M<span>)</span>	最大的字符数，不可以省略		   可变长度的字符	   比较节省		 低

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div></li>
<li>
<p>案例</p>
<div><pre><code>CREATE TABLE tab_char(
	c1 ENUM(&#39;a&#39;,&#39;b&#39;,&#39;c&#39;)
);

INSERT INTO tab_char VALUES(&#39;a&#39;);
INSERT INTO tab_char VALUES(&#39;b&#39;);
INSERT INTO tab_char VALUES(&#39;c&#39;);
INSERT INTO tab_char VALUES(&#39;m&#39;);
INSERT INTO tab_char VALUES(&#39;A&#39;);

SELECT * FROM tab_set;

CREATE TABLE tab_set(
	s1 SET(&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;)
);
INSERT INTO tab_set VALUES(&#39;a&#39;);
INSERT INTO tab_set VALUES(&#39;A,B&#39;);
INSERT INTO tab_set VALUES(&#39;a,c,d&#39;);
 
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div></li>
</ul>
<h3 id="三-日期型"> （三）日期型</h3>
<ul>
<li>
<p>分类：</p>
<p>①date只保存日期；</p>
<p>②time 只保存时间；</p>
<p>③year只保存年；</p>
<p>④datetime保存日期+时间；</p>
<p>⑤timestamp保存日期+时间；</p>
</li>
<li>
<p>特点</p>
<div><pre><code>			字节		范围			时区等的影响
<span>datetime</span>	 <span>8</span>		<span>1000</span>——<span>9999</span>	       不受
<span>timestamp</span>	 <span>4</span>	    <span>1970</span><span>-</span><span>2038</span>	        受
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div></li>
<li>
<p>案例</p>
<div><pre><code>CREATE TABLE tab_date(
	t1 DATETIME,
	t2 TIMESTAMP
);

INSERT INTO tab_date VALUES(NOW(),NOW());

SELECT * FROM tab_date;

SHOW VARIABLES LIKE &#39;time_zone&#39;;

SET time_zone=&#39;+9:00&#39;;
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div></li>
</ul>
<h2 id="四、常见的约束"> 四、常见的约束</h2>
<ul>
<li>
<p><strong>含义</strong>：一种限制，用于限制表中的数据，为了保证表中的数据的准确和可靠性。</p>
</li>
<li>
<p><strong>分类</strong></p>
<div><pre><code>六大约束
	<span>NOT</span> <span>NULL</span>：非空，用于保证该字段的值不能为空
	比如姓名、学号等
	<span>DEFAULT</span>:默认，用于保证该字段有默认值
	比如性别
	<span>PRIMARY</span> <span>KEY</span>:主键，用于保证该字段的值具有唯一性，并且非空
	比如学号、员工编号等
	<span>UNIQUE</span>:唯一，用于保证该字段的值具有唯一性，可以为空
	比如座位号
	<span>CHECK</span>:检查约束【mysql中不支持】
	比如年龄、性别
	<span>FOREIGN</span> <span>KEY</span>:外键，用于限制两个表的关系，用于保证该字段的值必须来自于主表的关联列的值
		在从表添加外键约束，用于引用主表中某列的值
	比如学生表的专业编号，员工表的部门编号，员工表的工种编号
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div></li>
<li>
<p><strong>添加约束的时机</strong>：</p>
<p>（1）创建表时；</p>
<p>（2）修改表时</p>
</li>
<li>
<p><strong>约束的添加分类</strong>：</p>
<p>（1）列级约束：六大约束语法上都支持，但外键约束没有效果</p>
<p>（2）表级约束：除了非空、默认，其他的都支持</p>
</li>
<li>
<p><strong>语法</strong></p>
<div><pre><code>CREATE TABLE 表名{
	字段名 字段类型 列级约束,
	字段名 字段类型,
	表级约束
};
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div></li>
</ul>
<hr>
<h3 id="一-创建表时添加约束"> （一）创建表时添加约束</h3>
<p><strong>1、添加列级约束</strong></p>
<ul>
<li>
<p>语法：直接在字段名和类型后面追加 约束类型即可。只支持：默认、非空、主键、唯一</p>
</li>
<li>
<p>案例</p>
<div><pre><code>#先新建一个库
CREATE DATABASE students;

USE students;

DROP TABLE stuinfo;

CREATE TABLE stuinfo(
	id INT PRIMARY KEY,#主键
	stuName VARCHAR(20) NOT NULL UNIQUE,#非空
	gender CHAR(1) CHECK(gender=&#39;男&#39; OR gender =&#39;女&#39;),#检查
	seat INT UNIQUE,#唯一
	age INT DEFAULT  18,#默认约束
	majorId INT REFERENCES major(id)#外键
);

CREATE TABLE major(
	id INT PRIMARY KEY,
	majorName VARCHAR(20)
);

#查看stuinfo中的所有索引，包括主键、外键、唯一
SHOW INDEX FROM stuinfo;
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div></li>
</ul>
<p><strong>2、添加表级约束</strong></p>
<ul>
<li>语法：在各个字段的最下面 【constraint 约束名】 约束类型(字段名)</li>
</ul>
<div><pre><code>  <span>TABLE</span> <span>IF</span> <span>EXISTS</span> stuinfo<span>;</span>
  <span>CREATE</span> <span>TABLE</span> stuinfo<span>(</span>
  	id <span>INT</span><span>,</span>
  	stuname <span>VARCHAR</span><span>(</span><span>20</span><span>)</span><span>,</span>
  	gender <span>CHAR</span><span>(</span><span>1</span><span>)</span><span>,</span>
  	seat <span>INT</span><span>,</span>
  	age <span>INT</span><span>,</span>
  	majorid <span>INT</span><span>,</span>
  	
  	<span>CONSTRAINT</span> pk <span>PRIMARY</span> <span>KEY</span><span>(</span>id<span>)</span><span>,</span><span>#主键</span>
  	<span>CONSTRAINT</span> uq <span>UNIQUE</span><span>(</span>seat<span>)</span><span>,</span><span>#唯一键</span>
  	<span>CONSTRAINT</span> ck <span>CHECK</span><span>(</span>gender <span>=</span><span>'男'</span> <span>OR</span> gender  <span>=</span> <span>'女'</span><span>)</span><span>,</span><span>#检查</span>
  	<span>CONSTRAINT</span> fk_stuinfo_major <span>FOREIGN</span> <span>KEY</span><span>(</span>majorid<span>)</span> <span>REFERENCES</span> major<span>(</span>id<span>)</span><span>#外键	</span>
  <span>)</span><span>;</span>
  
  <span>SHOW</span> <span>INDEX</span> <span>FROM</span> stuinfo<span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><ul>
<li>
<p>⭐️通用的写法：</p>
<div><pre><code>CREATE TABLE IF NOT EXISTS stuinfo(
	id INT PRIMARY KEY,
	stuname VARCHAR(20),
	sex CHAR(1),
	age INT DEFAULT 18,
	seat INT UNIQUE,
	majorid INT,
	CONSTRAINT fk_stuinfo_major FOREIGN KEY(majorid) REFERENCES major(id)
);

create table 表名(
  	字段名 字段类型 not null,#非空
  	字段名 字段类型 primary key,#主键
  	字段名 字段类型 unique,#唯一
  	字段名 字段类型 default 值,#默认
  	constraint 约束名 foreign key(字段名) references 主表（被引用列）
);

注意：
  			   支持类型		      可以起约束名			
列级约束		除了外键		     不可以
表级约束		除了非空和默认	  可以，但对主键无效
  
列级约束可以在一个字段上追加多个，中间用空格隔开，没有顺序要求
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div></li>
<li>
<p>主键和唯一的区别</p>
<div><pre><code>		保证唯一性  是否允许为空        一个表中可以有多少个                  是否允许组合
主键		√				×			至多有1个主键                       √，但不推荐
唯一		√				√			可以有多个字段设置为唯一              √，但不推荐
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div></li>
</ul>
<h3 id="二-修改表时添加约束"> （二）修改表时添加约束</h3>
<ul>
<li>
<p><strong>语法</strong></p>
<div><pre><code>1、添加列级约束
alter table 表名 modify column 字段名 字段类型 新约束;

2、添加表级约束
alter table 表名 add 【constraint 约束名】 约束类型(字段名) 【外键的引用】;
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div></li>
<li>
<p><strong>案例</strong></p>
<div><pre><code>DROP TABLE IF EXISTS stuinfo;
CREATE TABLE stuinfo(
	id INT,
	stuname VARCHAR(20),
	gender CHAR(1),
	seat INT,
	age INT,
	majorid INT
);

DESC stuinfo;
#1.添加非空约束
ALTER TABLE stuinfo MODIFY COLUMN stuname VARCHAR(20)  NOT NULL;

#2.添加默认约束
ALTER TABLE stuinfo MODIFY COLUMN age INT DEFAULT 18;

#3.添加主键
    #①列级约束
    ALTER TABLE stuinfo MODIFY COLUMN id INT PRIMARY KEY;
    #②表级约束
    ALTER TABLE stuinfo ADD PRIMARY KEY(id);

#4.添加唯一
    #①列级约束
    ALTER TABLE stuinfo MODIFY COLUMN seat INT UNIQUE;
    #②表级约束
    ALTER TABLE stuinfo ADD UNIQUE(seat);

#5.添加外键
ALTER TABLE stuinfo ADD CONSTRAINT fk_stuinfo_major FOREIGN KEY(majorid) REFERENCES major(id); 
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br></div></div></li>
</ul>
<h3 id="三-修改表时删除约束"> （三）修改表时删除约束</h3>
<ul>
<li>
<div><pre><code>#1.删除非空约束
ALTER TABLE stuinfo MODIFY COLUMN stuname VARCHAR(20) NULL;

#2.删除默认约束
ALTER TABLE stuinfo MODIFY COLUMN age INT ;

#3.删除主键
ALTER TABLE stuinfo DROP PRIMARY KEY;

#4.删除唯一
ALTER TABLE stuinfo DROP INDEX seat;

#5.删除外键
ALTER TABLE stuinfo DROP FOREIGN KEY fk_stuinfo_major;

SHOW INDEX FROM stuinfo;
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div></li>
</ul>
<h3 id="四-修改表时添加或删除约束的具体语法总结"> （四）修改表时添加或删除约束的具体语法总结</h3>
<ul>
<li>
<div><pre><code><span>1</span>、非空
添加非空
<span>alter</span> <span>table</span> 表名 <span>modify</span> <span>column</span> 字段名 字段类型 <span>not</span> <span>null</span><span>;</span>
删除非空
<span>alter</span> <span>table</span> 表名 <span>modify</span> <span>column</span> 字段名 字段类型 <span>;</span>

<span>2</span>、默认
添加默认
<span>alter</span> <span>table</span> 表名 <span>modify</span> <span>column</span> 字段名 字段类型 <span>default</span> 值<span>;</span>
删除默认
<span>alter</span> <span>table</span> 表名 <span>modify</span> <span>column</span> 字段名 字段类型 <span>;</span>

<span>3</span>、主键
添加主键
<span>alter</span> <span>table</span> 表名 <span>add</span>【 <span>constraint</span> 约束名】 <span>primary</span> <span>key</span><span>(</span>字段名<span>)</span><span>;</span>
删除主键
<span>alter</span> <span>table</span> 表名 <span>drop</span> <span>primary</span> <span>key</span><span>;</span>

<span>4</span>、唯一
添加唯一
<span>alter</span> <span>table</span> 表名 <span>add</span>【 <span>constraint</span> 约束名】 <span>unique</span><span>(</span>字段名<span>)</span><span>;</span>
删除唯一
<span>alter</span> <span>table</span> 表名 <span>drop</span> <span>index</span> 索引名<span>;</span>

<span>5</span>、外键
添加外键
<span>alter</span> <span>table</span> 表名 <span>add</span>【 <span>constraint</span> 约束名】 <span>foreign</span> <span>key</span><span>(</span>字段名<span>)</span> <span>references</span> 主表（被引用列）<span>;</span>
删除外键
<span>alter</span> <span>table</span> 表名 <span>drop</span> <span>foreign</span> <span>key</span> 约束名<span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br></div></div></li>
</ul>
<h3 id="五-自增长列-标识列"> （五）自增长列(标识列)</h3>
<ul>
<li>
<p><strong>含义</strong>：可以不用手动的插入值，系统提供默认的序列值</p>
</li>
<li>
<p><strong>特点</strong></p>
<div><pre><code><span>1.</span>不用手动插入值，可以自动提供序列值，默认从<span>1</span>开始，步长为<span>1</span>
  auto_increment_increment
  如果要更改起始值：手动插入值
  如果要更改步长：更改系统变量
  <span>set</span> auto_increment_increment<span>=</span>值<span>;</span>
<span>2.</span>一个表至多有一个自增长列
<span>3.</span>自增长列只能支持数值型
<span>4.</span>自增长列必须为一个<span>key</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div></li>
<li>
<p><strong>案例</strong></p>
<div><pre><code>#一、创建表时设置标识列
DROP TABLE IF EXISTS tab_identity;

CREATE TABLE tab_identity(
	id INT  ,
	NAME FLOAT UNIQUE AUTO_INCREMENT,
	seat INT 
) TRUNCATE TABLE tab_identity;

INSERT INTO tab_identity(id,NAME) VALUES(NULL,&#39;john&#39;);

INSERT INTO tab_identity(NAME) VALUES(&#39;lucy&#39;);

SELECT * FROM tab_identity;

SHOW VARIABLES LIKE &#39;%auto_increment%&#39;;

SET auto_increment_increment=3;
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div></li>
<li>
<p><strong>语法总结</strong></p>
<div><pre><code>一、创建表时设置自增长列
create table 表(
	字段名 字段类型 约束 auto_increment
);

二、修改表时设置自增长列
alter table 表 modify column 字段名 字段类型 约束 auto_increment;

三、删除自增长列
alter table 表 modify column 字段名 字段类型 约束;
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div></li>
</ul>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <category term="数据库"/>
    <contributor>
      <name>南辞</name>
    </contributor>
    <published>2021-03-31T05:51:25.000Z</published>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">MySQL-DML</title>
    <id>http://qiqi.dreamagain.top/software/database/SQL/MySQL/MySQL-DML/</id>
    <link href="http://qiqi.dreamagain.top/software/database/SQL/MySQL/MySQL-DML/"/>
    <updated>2021-03-31T05:51:25.000Z</updated>
    <summary type="html"><![CDATA[<blockquote>
<p><img src="https://img.shields.io/badge/DML-Data_Manipulation_Language-blue.svg" alt=""></p>
</blockquote>
]]></summary>
    <content type="html"><![CDATA[<blockquote>
<p><img src="https://img.shields.io/badge/DML-Data_Manipulation_Language-blue.svg" alt=""></p>
</blockquote>

<h2 style="color:#ab4642" align="center">DML语言</h2>
<p>数据操作语言</p>
<ul>
<li>插入：insert</li>
<li>修改：update</li>
<li>删除：delete</li>
</ul>
<h2 id="一、插入语句"> 一、插入语句</h2>
<h3 id="一-方式一"> （一）方式一</h3>
<p><mark>经典的插入(多行插入)</mark></p>
<ul>
<li>语法：insert into 表名(字段名,…) values(值,…);</li>
<li>特点
<ul>
<li>1、要求值的类型和字段的类型要一致或兼容；</li>
<li>2、字段的个数和顺序不一定与原始表中的字段个数和顺序一致但必须保证值和字段一一对应；</li>
<li>3、假如表中有可以为null的字段，注意可以通过以下两种方式插入null值
<ul>
<li>①字段和值都省略</li>
<li>②字段写上，值使用null</li>
</ul>
</li>
</ul>
</li>
<li>4、字段和值的个数必须一致</li>
<li>5、字段名可以省略，默认所有列</li>
<li>具体案例：</li>
</ul>
<div><pre><code><span>SELECT</span> <span>*</span> <span>FROM</span> beauty<span>;</span>
<span>#1.插入的值的类型要与列的类型一致或兼容</span>
<span>INSERT</span> <span>INTO</span> beauty<span>(</span>id<span>,</span>NAME<span>,</span>sex<span>,</span>borndate<span>,</span>phone<span>,</span>photo<span>,</span>boyfriend_id<span>)</span>
<span>VALUES</span><span>(</span><span>13</span><span>,</span><span>'唐艺昕'</span><span>,</span><span>'女'</span><span>,</span><span>'1990-4-23'</span><span>,</span><span>'1898888888'</span><span>,</span><span>NULL</span><span>,</span><span>2</span><span>)</span><span>;</span>

<span>#2.不可以为null的列必须插入值。可以为null的列如何插入值？</span>
    <span>#方法一：字段写上，值使用null</span>
    <span>INSERT</span> <span>INTO</span> beauty<span>(</span>id<span>,</span>NAME<span>,</span>sex<span>,</span>borndate<span>,</span>phone<span>,</span>photo<span>,</span>boyfriend_id<span>)</span>
    <span>VALUES</span><span>(</span><span>13</span><span>,</span><span>'唐艺昕'</span><span>,</span><span>'女'</span><span>,</span><span>'1990-4-23'</span><span>,</span><span>'1898888888'</span><span>,</span><span>NULL</span><span>,</span><span>2</span><span>)</span><span>;</span>

    <span>#方法二：字段和值都省略</span>
    <span>INSERT</span> <span>INTO</span> beauty<span>(</span>id<span>,</span>NAME<span>,</span>sex<span>,</span>phone<span>)</span>
    <span>VALUES</span><span>(</span><span>15</span><span>,</span><span>'娜扎'</span><span>,</span><span>'女'</span><span>,</span><span>'1388888888'</span><span>)</span><span>;</span>

<span>#3.列的顺序是否可以调换（可以）</span>
<span>INSERT</span> <span>INTO</span> beauty<span>(</span>NAME<span>,</span>sex<span>,</span>id<span>,</span>phone<span>)</span>
<span>VALUES</span><span>(</span><span>'蒋欣'</span><span>,</span><span>'女'</span><span>,</span><span>16</span><span>,</span><span>'110'</span><span>)</span><span>;</span>

<span>#4.列数和值的个数必须一致</span>
<span>INSERT</span> <span>INTO</span> beauty<span>(</span>NAME<span>,</span>sex<span>,</span>id<span>,</span>phone<span>)</span>
<span>VALUES</span><span>(</span><span>'关晓彤'</span><span>,</span><span>'女'</span><span>,</span><span>17</span><span>,</span><span>'110'</span><span>)</span><span>;</span>

<span>#5.可以省略列名，默认所有列，而且列的顺序和表中列的顺序一致</span>
<span>INSERT</span> <span>INTO</span> beauty
<span>VALUES</span><span>(</span><span>18</span><span>,</span><span>'张飞'</span><span>,</span><span>'男'</span><span>,</span><span>NULL</span><span>,</span><span>'119'</span><span>,</span><span>NULL</span><span>,</span><span>NULL</span><span>)</span><span>;</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><h3 id="二-方式二"> （二）方式二</h3>
<p><mark>结合SET插入单条记录</mark></p>
<ul>
<li>语法：insert into 表名 set 列名=值,列名=值,…</li>
</ul>
<div><pre><code><span>INSERT</span> <span>INTO</span> beauty <span>SET</span> id<span>=</span><span>19</span><span>,</span>NAME<span>=</span>‘刘涛’<span>,</span>phone<span>=</span>‘<span>999</span>’<span>;</span>
</code></pre>
<div><span>1</span><br></div></div><h3 id="三-两种方式的区别"> （三）两种方式的区别</h3>
<div><pre><code><span>1.</span>方式一支持一次插入单行或多行，语法如下：
<span>insert</span> <span>into</span> 表名【<span>(</span>字段名<span>,</span><span>.</span><span>.</span><span>)</span>】 <span>values</span><span>(</span>值，<span>.</span><span>.</span><span>)</span><span>,</span><span>(</span>值，<span>.</span><span>.</span><span>.</span><span>)</span><span>,</span><span>.</span><span>.</span><span>.</span><span>;</span>
<span>2.</span>方式一支持子查询，语法如下：
    <span>insert</span> <span>into</span> 表名 查询语句<span>;</span>
    
<span>#1、方式一支持插入多行,方式二不支持</span>
<span>INSERT</span> <span>INTO</span> beauty
<span>VALUES</span><span>(</span><span>23</span><span>,</span><span>'唐艺昕1'</span><span>,</span><span>'女'</span><span>,</span><span>'1990-4-23'</span><span>,</span><span>'1898888888'</span><span>,</span><span>NULL</span><span>,</span><span>2</span><span>)</span>
<span>,</span><span>(</span><span>24</span><span>,</span><span>'唐艺昕2'</span><span>,</span><span>'女'</span><span>,</span><span>'1990-4-23'</span><span>,</span><span>'1898888888'</span><span>,</span><span>NULL</span><span>,</span><span>2</span><span>)</span>
<span>,</span><span>(</span><span>25</span><span>,</span><span>'唐艺昕3'</span><span>,</span><span>'女'</span><span>,</span><span>'1990-4-23'</span><span>,</span><span>'1898888888'</span><span>,</span><span>NULL</span><span>,</span><span>2</span><span>)</span><span>;</span>

<span>#2、方式一支持子查询，方式二不支持</span>
<span>INSERT</span> <span>INTO</span> beauty<span>(</span>id<span>,</span>NAME<span>,</span>phone<span>)</span> <span>SELECT</span> <span>26</span><span>,</span><span>'宋茜'</span><span>,</span><span>'11809866'</span><span>;</span>

<span>INSERT</span> <span>INTO</span> beauty<span>(</span>id<span>,</span>NAME<span>,</span>phone<span>)</span> 
<span>SELECT</span> id<span>,</span>boyname<span>,</span><span>'1234567'</span> <span>FROM</span> boys <span>WHERE</span> id<span>&lt;</span><span>3</span><span>;</span>       
 
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><h2 id="二、修改语句"> 二、修改语句</h2>
<ul>
<li>
<p>修改单表的记录★</p>
</li>
<li>
<p>语法：update 表名 set 列=新值,列=新值,… where 筛选条件;</p>
</li>
<li>
<p>案例</p>
<div><pre><code><span>#1.修改单表的记录</span>
<span>#案例1：修改beauty表中姓唐的女神的电话为13899888899</span>
<span>UPDATE</span> beauty <span>SET</span> phone <span>=</span> <span>'13899888899'</span>
<span>WHERE</span> NAME <span>LIKE</span> <span>'唐%'</span><span>;</span>

<span>#案例2：修改boys表中id好为2的名称为张飞，魅力值 10</span>
<span>UPDATE</span> boys <span>SET</span> boyname<span>=</span><span>'张飞'</span><span>,</span>usercp<span>=</span><span>10</span>
<span>WHERE</span> id<span>=</span><span>2</span><span>;</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div></li>
<li>
<p>修改多表的记录【补充】</p>
</li>
<li>
<p>sql92语法：update 表1 别名,表2 别名 set 列=值,… where 连接条件 and 筛选条件;</p>
</li>
<li>
<p>sql99语法：update 表1 别名 inner|left|right join 表2 别名 on 连接条件 set 列=值,… where 筛选条件;</p>
</li>
<li>
<p>案例</p>
<div><pre><code><span>#2.修改多表的记录</span>
<span>#案例 1：修改张无忌的女朋友的手机号为114</span>
<span>UPDATE</span> boys bo
<span>INNER</span> <span>JOIN</span> beauty b <span>ON</span> bo<span>.</span><span>`</span>id<span>`</span><span>=</span>b<span>.</span><span>`</span>boyfriend_id<span>`</span>
<span>SET</span> b<span>.</span><span>`</span>phone<span>`</span><span>=</span><span>'119'</span><span>,</span>bo<span>.</span><span>`</span>userCP<span>`</span><span>=</span><span>1000</span>
<span>WHERE</span> bo<span>.</span><span>`</span>boyName<span>`</span><span>=</span><span>'张无忌'</span><span>;</span>

<span>#案例2：修改没有男朋友的女神的男朋友编号都为2号</span>
<span>UPDATE</span> boys bo
<span>RIGHT</span> <span>JOIN</span> beauty b <span>ON</span> bo<span>.</span><span>`</span>id<span>`</span><span>=</span>b<span>.</span><span>`</span>boyfriend_id<span>`</span>
<span>SET</span> b<span>.</span><span>`</span>boyfriend_id<span>`</span><span>=</span><span>2</span> <span>WHERE</span> bo<span>.</span><span>`</span>id<span>`</span> <span>IS</span> <span>NULL</span><span>;</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div></li>
</ul>
<h2 id="三、删除语句"> 三、删除语句</h2>
<h3 id="一-方式一-delete"> （一）方式一（delete）</h3>
<ul>
<li>语法</li>
</ul>
<div><pre><code><span>1</span>、单表的删除【★】
<span>delete</span> <span>from</span> 表名 <span>where</span> 筛选条件

<span>2</span>、多表的删除【补充】
sql92语法：
<span>delete</span> 表<span>1</span>的别名<span>,</span>表<span>2</span>的别名
<span>from</span> 表<span>1</span> 别名<span>,</span>表<span>2</span> 别名
<span>where</span> 连接条件
<span>and</span> 筛选条件<span>;</span>

sql99语法：
<span>delete</span> 表<span>1</span>的别名<span>,</span>表<span>2</span>的别名
<span>from</span> 表<span>1</span> 别名
<span>inner</span><span>|</span><span>left</span><span>|</span><span>right</span> <span>join</span> 表<span>2</span> 别名 <span>on</span> 连接条件
<span>where</span> 筛选条件<span>;</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><ul>
<li>案例</li>
</ul>
<div><pre><code><span>#1.单表的删除</span>
<span>#案例：删除手机号以9结尾的女神信息</span>
<span>DELETE</span> <span>FROM</span> beauty <span>WHERE</span> phone <span>LIKE</span> <span>'%9'</span><span>;</span>
<span>SELECT</span> <span>*</span> <span>FROM</span> beauty<span>;</span>

<span>#2.多表的删除</span>
<span>#案例：删除张无忌的女朋友的信息</span>
<span>DELETE</span> b
<span>FROM</span> beauty b
<span>INNER</span> <span>JOIN</span> boys bo <span>ON</span> b<span>.</span><span>`</span>boyfriend_id<span>`</span> <span>=</span> bo<span>.</span><span>`</span>id<span>`</span>
<span>WHERE</span> bo<span>.</span><span>`</span>boyName<span>`</span><span>=</span><span>'张无忌'</span><span>;</span>

<span>#案例：删除黄晓明的信息以及他女朋友的信息</span>
<span>DELETE</span> b<span>,</span>bo
<span>FROM</span> beauty b
<span>INNER</span> <span>JOIN</span> boys bo <span>ON</span> b<span>.</span><span>`</span>boyfriend_id<span>`</span><span>=</span>bo<span>.</span><span>`</span>id<span>`</span>
<span>WHERE</span> bo<span>.</span><span>`</span>boyName<span>`</span><span>=</span><span>'黄晓明'</span><span>;</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><h3 id="二-方式二-truncate"> （二）方式二（truncate）</h3>
<div><pre><code>语法：<span>truncate</span> <span>table</span> 表名<span>;</span>
<span>TRUNCATE</span> <span>TABLE</span> boys <span>;</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id="三-两种方式的区别【面试题】★"> （三）两种方式的区别【面试题】★</h3>
<div><pre><code><span>1.</span><span>delete</span> 可以加<span>where</span> 条件，<span>truncate</span>不能加
<span>2.</span><span>truncate</span>删除，效率高一点
<span>3.</span>假如要删除的表中有自增长列，
  如果用<span>delete</span>删除后，再插入数据，自增长列的值从断点开始，而<span>truncate</span>删除后，再插入数据，自增长列的值从<span>1</span>开始。
<span>4.</span><span>truncate</span>删除没有返回值，<span>delete</span>删除有返回值
<span>5.</span><span>truncate</span>删除不能回滚，<span>delete</span>删除可以回滚<span>.</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div>]]></content>
    <author>
      <name>南辞</name>
    </author>
    <category term="数据库"/>
    <contributor>
      <name>南辞</name>
    </contributor>
    <published>2021-03-31T05:51:25.000Z</published>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">MySQL-DQL</title>
    <id>http://qiqi.dreamagain.top/software/database/SQL/MySQL/MySQL-DQL/</id>
    <link href="http://qiqi.dreamagain.top/software/database/SQL/MySQL/MySQL-DQL/"/>
    <updated>2021-03-31T05:51:25.000Z</updated>
    <summary type="html"><![CDATA[<blockquote>
<p><img src="https://img.shields.io/badge/DQL-Data_Query_Language-blue.svg" alt=""></p>
</blockquote>
]]></summary>
    <content type="html"><![CDATA[<blockquote>
<p><img src="https://img.shields.io/badge/DQL-Data_Query_Language-blue.svg" alt=""></p>
</blockquote>

<h2 style="color:#ab4642" align="center">DQL语言</h2>
<h2 id="一、基础查询"> 一、基础查询</h2>
<ul>
<li>
<p><strong>语法</strong>：select 查询列表 from 表名;</p>
<p>类似于System.out.println(打印东西);</p>
</li>
<li>
<p><strong>特点</strong>：</p>
<p>（1）查询列表可以是：表中的字段、常量值、表达式、函数。（可以是多个）</p>
<p>（2）查询的结果是一个虚拟表格</p>
</li>
<li>
<p><strong>案例</strong></p>
<div><pre><code><span>USE</span> myemployees<span>;</span>

<span>#1.查询表中的单个字段</span>
<span>SELECT</span> last_name <span>FROM</span> employees<span>;</span>

<span>#2.查询表中多个字段</span>
<span>SELECT</span> last_name<span>,</span>salary<span>,</span>email <span>FROM</span> employees<span>;</span>

<span>#3.查询表中的所有字段</span>
<span>SELECT</span> <span>*</span> <span>FROM</span> employees<span>;</span> <span>// InnoDB引擎尽量避免使用select *，效率不高</span>

<span>#4.查询常量</span>
<span># select 常量值;</span>
<span># 注意：字符型和日期型的常量值必须用单引号引起来，数值型不需要</span>
<span>SELECT</span> <span>100</span><span>;</span>
<span>SELECT</span> <span>'join'</span><span>;</span>

<span>#5.查询函数</span>
<span>#select 函数名(实参列表);</span>
<span>SELECT</span> VERSION<span>(</span><span>)</span><span>;</span>

<span>#6.查询表达式 </span>
<span>SELECT</span> <span>100</span><span>%</span><span>98</span><span>;</span>

<span>#7.起别名</span>
<span>/*
1.便于理解
2.如果要查询的字段有重名的情况,使用别名区分
*/</span>
<span>#方式一:使用AS</span>
<span>SELECT</span> <span>100</span><span>%</span><span>98</span> <span>AS</span> 结果<span>;</span>
<span>SELECT</span> last_name <span>AS</span> 姓<span>,</span>first_name <span>AS</span> 名 <span>FROM</span> employees<span>;</span>

<span>#方式二:使用空格</span>
<span>SELECT</span> last_name 姓<span>,</span>first_name 名 <span>FROM</span> employees<span>;</span>

<span>#案例:查询salary,结果显示 out put</span>
<span>SELECT</span> salary <span>AS</span> <span>"out put"</span> <span>FROM</span> employees<span>;</span>

<span>#8.去重</span>
<span># select distinct 字段名 from 表名;</span>
<span>#案例:查询员工表中涉及的所有部门编号</span>
<span>SELECT</span> <span>DISTINCT</span> department_id <span>FROM</span> employees<span>;</span>

<span>#9.+号的作用</span>
<span>#案例:查询员工的名和姓,并显示为姓名</span>
<span>/*
java中的+号:
1.运算符:两个操作数都为数据型
2.连接符:只要有一个操作数为字符串


mysql中的+号:
只能作为运算符

select 100+90; 两个操作数都为数值型,做加法运算
select '123+90';其中一方为字符型,试图将字符型数值转换为数值型
		如果转换成功,则继续做加法运算
select 'john'+90; 如果转换失败,则将字符型数值转换成0

select null+0; 只要其中一方为null,则结果肯定为null.
*/</span>
<span>select</span> <span>100</span><span>+</span><span>90</span><span>;</span> <span>// 190</span>
<span>select</span> <span>'123+90'</span><span>;</span> <span>// 123+90</span>
<span>select</span> <span>'john'</span><span>+</span><span>90</span><span>;</span> <span>// 90</span>

<span>select</span> <span>null</span><span>+</span><span>0</span><span>;</span> <span>// null</span>
<span>SELECT</span> last_name<span>+</span>first_name <span>AS</span> 姓名 <span>FROM</span> employees<span>;</span> <span>// 0</span>

<span>#10.【补充】concat函数 </span>
<span>/*
功能：拼接字符
select concat(字符1，字符2，字符3,...);
*/</span>
<span>SELECT</span> CONCAT<span>(</span><span>'a'</span><span>,</span><span>'b'</span><span>,</span><span>'c'</span><span>)</span> <span>AS</span> 结果<span>;</span> <span>// abc</span>

<span>SELECT</span> CONCAT<span>(</span>last_name<span>,</span>first_name<span>)</span> <span>AS</span> 姓名 <span>FROM</span> employees<span>;</span>

<span>#11.【补充】ifnull函数</span>
<span>#功能：判断某字段或表达式是否为null，如果为null 返回指定的值，否则返回原本的值</span>
<span>SELECT</span> commission_pct<span>,</span>IFNULL<span>(</span>commission_pct<span>,</span><span>0</span><span>)</span> 替换<span>NULL</span> <span>FROM</span> employees<span>;</span>

<span>#12.【补充】isnull函数</span>
<span>#功能：判断某字段或表达式是否为null，如果是，则返回1，否则返回0</span>
<span>SELECT</span> commission_pct<span>,</span>ISNULL<span>(</span>commission_pct<span>)</span> 替换结果 <span>FROM</span> employees<span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br></div></div></li>
</ul>
<h2 id="二、条件查询"> 二、条件查询</h2>
<ul>
<li>
<p><strong>语法</strong>：select 查询列表 from 表名 where 筛选条件;</p>
</li>
<li>
<p><strong>分类</strong></p>
<div><pre><code>
  一、按条件表达式筛选
  	条件运算符:<span>></span> <span>&lt;</span> <span>=</span> <span>!=</span> <span>&lt;></span> <span>>=</span> <span>&lt;=</span> <span>&lt;=></span>完全等于
  	<span>!=</span> 和 <span>&lt;></span>等价
  二、按逻辑表达式筛选
  	逻辑运算符:<span>&amp;&amp;</span> <span>||</span> <span>!</span>
  	<span>and</span> <span>or</span> <span>not</span>

  	<span>&amp;&amp;</span> 和 <span>and</span>:两个条件都为<span>true</span>，结果为<span>true</span>，反之为<span>false</span>
  	<span>||</span> 和 <span>or</span>:只要有一个条件为<span>true</span>，结果为<span>true</span>，反之为<span>false</span>
  	<span>!</span> 或 <span>not</span>:如果连接的条件本身为<span>false</span>，结果为<span>true</span>，反之为<span>false</span>	

  三、模糊查询
  	<span>like</span>:一般搭配通配符使用，可以判断字符型或数值型
  	通配符：<span>%</span>任意多个字符，_任意单个字符
  	<span>like</span>、<span>between</span> <span>and</span>、<span>in</span>、<span>is</span> <span>null</span>
  
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div></li>
<li>
<p><strong>案例</strong></p>
<h3 id="一-按条件表达式筛选"> （一）按条件表达式筛选</h3>
<div><pre><code><span>#案例1:查询工资>12000的员工信息</span>
<span>SELECT</span> <span>*</span> <span>FROM</span> employees <span>WHERE</span> salary<span>></span><span>12000</span><span>;</span>

<span>#案例2:查询部门编号不等于90号的员工名和部门编号</span>
<span>SELECT</span> last_name<span>,</span>department_id <span>FROM</span> employees <span>WHERE</span> department_id <span>&lt;></span> <span>90</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h3 id="二-按逻辑表达式筛选"> （二）按逻辑表达式筛选</h3>
<div><pre><code><span>#案例1:查询工资z在10000到20000之间的员工名、工资及奖金</span>
<span>SELECT</span> last_name<span>,</span>salary<span>,</span>commission_pct <span>FROM</span> employees <span>WHERE</span> salary<span>>=</span><span>10000</span> <span>AND</span> salary<span>&lt;=</span><span>20000</span><span>;</span>

<span>#案例2:查询部门编号不是在90-110之间,或者工资高于15000的员工信息</span>
<span>SELECT</span> <span>*</span> <span>FROM</span> employees <span>WHERE</span> department_id <span>&lt;</span><span>90</span> <span>OR</span> department_id<span>></span><span>110</span> <span>OR</span> salary<span>></span><span>15000</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h3 id="三-模糊查询"> （三）模糊查询</h3>
<p><strong>1、like</strong></p>
<div><pre><code><span>#案例1:查询员工名中包含字符a的员工信息</span>
<span>SELECT</span> <span>*</span> <span>FROM</span> employees <span>WHERE</span> last_name <span>LIKE</span> <span>'%a%'</span><span>;</span>

<span>#案例2:查询员工名中第三个字符为b，第五个字符为a的员工名和工资</span>
<span>SELECT</span> last_name<span>,</span>salary <span>FROM</span> employees <span>WHERE</span> last_name <span>LIKE</span> <span>'__b_a%'</span><span>;</span>

<span>#案例3:查询员工名种第二个字符为_的员工名</span>
<span>SELECT</span> last_name <span>FROM</span> employees <span>WHERE</span> last_name <span>LIKE</span> <span>'_\_%'</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p><strong>2、between and</strong></p>
<div><pre><code><span>#案例1:查询员工编号在100到120之间的员工信息</span>
<span>SELECT</span> <span>*</span> <span>FROM</span> employees <span>WHERE</span> employee_id<span>>=</span><span>100</span> <span>AND</span> employee_id<span>&lt;=</span><span>120</span><span>;</span>

<span>SELECT</span> <span>*</span> <span>FROM</span> employees <span>WHERE</span> employee_id <span>BETWEEN</span> <span>100</span> <span>AND</span> <span>120</span><span>;</span>

<span>/*注意事项：
1.提高语句简洁度
2.包含临界值
3.两个临界值不能调换顺序
*/</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p><strong>3、in</strong></p>
<div><pre><code><span>/*
含义:判断某字段的值是否属于in列表中的某一项
特点:
 1.使用in提高语句简洁度
 2.in列表的值类型必须一致或兼容
*/</span>
<span>#案例1:查询员工的工种编号是IT_PROG、AD_VP、AD_PRES中的一个员工名和工种编号</span>

<span>SELECT</span> last_name<span>,</span>job_id <span>FROM</span> employees <span>WHERE</span> job_id<span>=</span><span>'IT_PROG'</span> <span>OR</span> job_id<span>=</span><span>'AD_PRES'</span> <span>OR</span> job_id<span>=</span><span>'AD_VP'</span><span>;</span>

<span>SELECT</span> last_name<span>,</span>job_id <span>FROM</span> employees <span>WHERE</span> job_id <span>IN</span><span>(</span><span>'IT_PROG'</span><span>,</span><span>'AD_PRES'</span><span>,</span><span>'AD_VP'</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p><strong>4、is null 和  is not null</strong></p>
<div><pre><code><span>/*
=或&lt;>不能用于判断null值
is null 或 is not null 可以判断null值
*/</span>
<span>#案例1:查询没有奖金的员工名和奖金率</span>

<span>SELECT</span> last_name<span>,</span>commission_pct <span>FROM</span> employees <span>WHERE</span> commission_pct <span>IS</span> <span>NULL</span><span>;</span>

<span>SELECT</span> last_name<span>,</span>commission_pct <span>FROM</span> employees <span>WHERE</span> commission_pct <span>IS</span> <span>NOT</span> <span>NULL</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p><strong>5、完全等于&lt;=&gt;</strong></p>
<div><pre><code><span>#案例1:查询没有奖金的员工名和奖金率</span>

<span>SELECT</span> last_name<span>,</span>commission_pct <span>FROM</span> employees <span>WHERE</span> commission_pct <span>&lt;=></span> <span>NULL</span><span>;</span>

<span>#案例2:查询工资为12000的员工信息</span>
<span>SELECT</span> last_name<span>,</span>commission_pct <span>FROM</span> employees <span>WHERE</span> salary <span>&lt;=></span> <span>12000</span><span>;</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p><strong>6、is null PK &lt;=&gt;</strong></p>
<div><pre><code><span>#is null PK &lt;=></span>
<span>#	      普通类型的数值	null值		可读性</span>
<span># is null	  ×		       √		   √</span>
<span># &lt;=>		  √		       √		   ×</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div></li>
</ul>
<h2 id="三、排序查询"> 三、排序查询</h2>
<ul>
<li>
<p><strong>引入</strong>：select * from employees;</p>
</li>
<li>
<p><strong>语法</strong>：select 查询列表 from 表 【where 筛选条件】 order by</p>
</li>
<li>
<p><strong>特点</strong>：</p>
<p>（1）asc代表的是升序，desc代表降序，不写默认为升序</p>
<p>（2）order by子句中可以支持单个字段、多个字段、表达式、函数、别名</p>
<p>（3）order by子句一般是放在查询语句的最后面,limit子句除外</p>
</li>
<li>
<p><strong>案例</strong></p>
<div><pre><code>#案例1:查询员工信息,要求工资从高到低排序
SELECT * FROM employees ORDER BY salary DESC;
SELECT * FROM employees ORDER BY salary;

#案例2:查询部门编号是&gt;=90，按入职时间的先后进行排序
SELECT * FROM employees WHERE department_id&gt;=90 ORDER BY hiredate ASC;

#案例3:按年薪的高低显示员工的信息和年薪【按表达式排序】
SELECT *,salary*12*(1+IFNULL(commission_pct,0)) 年薪 FROM employees 
ORDER BY salary*12*(1+IFNULL(commission_pct,0)) DESC; 

#案例4:按年薪的高低显示员工的信息和年薪【按别名排序】
SELECT *,salary*12*(1+IFNULL(commission_pct,0)) 年薪 FROM employees 
ORDER BY 年薪 DESC; 

#案例5:按姓名的长度显示员工的姓名和工资【按函数排序】
SELECT LENGTH(last_name) 字节长度,last_name,salary
FROM employees
ORDER BY LENGTH(last_name) DESC;

#案例6:查询员工共信息,要求按工资排序，再按员工编号排序【按多个字段排序】
SELECT * FROM employees
ORDER BY salary ASC,employee_id DESC;

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div></li>
</ul>
<h2 id="四、常见函数"> 四、常见函数</h2>
<ul>
<li>
<p><strong>概念</strong>：类似于Java的方法，将一组逻辑语句封装在方法体中，对外暴露方法名</p>
</li>
<li>
<p><strong>优点</strong>：</p>
<p>（1）隐藏了实现细节</p>
<p>（2）提高了代码的重用性</p>
</li>
<li>
<p><strong>语法</strong>：select 函数名(实参列表) 【from 表】;</p>
</li>
<li>
<p><strong>特点</strong>：</p>
<p>（1）叫什么(函数名)</p>
<p>（2）干什么(函数功能)</p>
</li>
<li>
<p><strong>分类</strong>:</p>
<p>（1）单行函数，如concat、length、ifnull等</p>
<p>（2）分组函数，做统计使用</p>
</li>
</ul>
<h3 id="一-单行函数"> （一）单行函数</h3>
<p>单行函数分类：字符函数、数学函数、日期函数、其他函数、流程控制函数</p>
<p><mark>1、字符函数</mark></p>
<p>concat：连接</p>
<p>substr：截取子串</p>
<p>upper：变大写</p>
<p>lower：变小写</p>
<p>replace：替换</p>
<p>length：获取字节长度</p>
<p>trim：去前后空格</p>
<p>lpad：左填充</p>
<p>rpad：右填充</p>
<p>instr：获取子串第一次出现的索引</p>
<div><pre><code><span>#一.字符函数</span>
<span>#1.length 获取参数值的字节值</span>
<span>SELECT</span> LENGTH<span>(</span><span>'subei'</span><span>)</span><span>;</span>
<span>SELECT</span> LENGTH<span>(</span><span>'鬼谷子qwe'</span><span>)</span><span>;</span>

<span>SHOW</span> VARIABLES <span>LIKE</span> <span>'%char%'</span><span>;</span>

<span>#2.concat 拼接字符串</span>
<span>SELECT</span> CONCAT<span>(</span>last_name<span>,</span><span>'_'</span><span>,</span>first_name<span>)</span> 姓名 <span>FROM</span> employees<span>;</span>

<span>#3.upper:变大写、lower：变小写</span>

<span>SELECT</span> UPPER<span>(</span><span>'ton'</span><span>)</span><span>;</span>
<span>SELECT</span> LOWER<span>(</span><span>'ton'</span><span>)</span><span>;</span>

<span>#示例：将姓变大写，名变小写，然后拼接</span>
<span>SELECT</span> CONCAT<span>(</span>UPPER<span>(</span>last_name<span>)</span><span>,</span><span>' '</span><span>,</span> LOWER<span>(</span>first_name<span>)</span><span>)</span> 姓名 <span>FROM</span> employees<span>;</span>


<span>#4.substr、substring</span>
<span>#注意:索引从1开始</span>

<span>#截取从指定所有处后面的所以字符</span>
<span>SELECT</span> SUBSTR<span>(</span><span>'吴刚伐桂在天上'</span><span>,</span><span>4</span><span>)</span> out_put<span>;</span>

<span>#截取从指定索引处指定字符长度的字符</span>
<span>SELECT</span> SUBSTR<span>(</span><span>'吴刚伐桂在天上'</span><span>,</span><span>1</span><span>,</span><span>2</span><span>)</span> out_put<span>;</span>

<span>#案例:姓名中首字符大写,其他字符小写，然后用_拼接,显示出来</span>
<span>SELECT</span> CONCAT<span>(</span>UPPER<span>(</span>SUBSTR<span>(</span>last_name<span>,</span><span>1</span><span>,</span><span>1</span><span>)</span><span>)</span><span>,</span><span>'_'</span><span>,</span>LOWER<span>(</span>SUBSTR<span>(</span>last_name<span>,</span><span>2</span><span>)</span><span>)</span><span>)</span> out_put <span>FROM</span> employees<span>;</span>

<span>#5.instr:获取子串第一次出现的索引,找不到返回0</span>
<span>SELECT</span> INSTR<span>(</span><span>'MySQL技术进阶'</span><span>,</span><span>'技术'</span><span>)</span> <span>AS</span> out_put<span>;</span>

<span>#6.trim:去前后空格</span>

<span>SELECT</span> LENGTH<span>(</span>TRIM<span>(</span><span>'	霍山	'</span><span>)</span><span>)</span> <span>AS</span> out_put<span>;</span>

<span>SELECT</span> TRIM<span>(</span><span>'+'</span> <span>FROM</span> <span>'++++李刚+++刘邦+++'</span><span>)</span> <span>AS</span> out_put<span>;</span>

<span>#7.lpad:用指定的字符实现左填充指定长度</span>
<span>SELECT</span> LPAD<span>(</span><span>'梅林'</span><span>,</span><span>8</span><span>,</span><span>'+'</span><span>)</span> <span>AS</span> out_put<span>;</span>

<span>#8.rpad:用指定的字符实现右填充指定长度</span>
<span>SELECT</span> RPAD<span>(</span><span>'梅林'</span><span>,</span><span>5</span><span>,</span><span>'&amp;'</span><span>)</span> <span>AS</span> out_put<span>;</span>

<span>#9.replace:替换</span>
<span>SELECT</span> <span>REPLACE</span><span>(</span><span>'莉莉伊万斯的青梅竹马是詹姆'</span><span>,</span><span>'詹姆'</span><span>,</span><span>'斯内普'</span><span>)</span> <span>AS</span> out_put<span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br></div></div><p><mark>2、数学函数</mark></p>
<div><pre><code><span>#1.round:四舍五入</span>
<span>SELECT</span> <span>ROUND</span><span>(</span><span>1.45</span><span>)</span><span>;</span>
<span>SELECT</span> <span>ROUND</span><span>(</span><span>1.567</span><span>,</span><span>2</span><span>)</span><span>;</span>

<span>#2.ceil:向上取整,返回>=该参数的最小整数</span>
<span>SELECT</span> CEIL<span>(</span><span>1.005</span><span>)</span><span>;</span>
<span>SELECT</span> CEIL<span>(</span><span>-</span><span>1.002</span><span>)</span><span>;</span>

<span>#3.floor:向下取整,返回&lt;=该参数的最大整数</span>
<span>SELECT</span> FLOOR<span>(</span><span>-</span><span>9.99</span><span>)</span><span>;</span>

<span>#4.truncate:截断，第二个参数指定截取的小数位数</span>
<span>SELECT</span> <span>TRUNCATE</span><span>(</span><span>1.65</span><span>,</span><span>1</span><span>)</span><span>;</span>

<span>#5.mod:取余</span>
<span>SELECT</span> <span>MOD</span><span>(</span><span>10</span><span>,</span><span>3</span><span>)</span><span>;</span>

<span>#6.rand:获取随机数，返回0-1之间的小数</span>
<span>SELECT</span> RAND<span>(</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><p><mark>3、日期函数</mark></p>
<div><pre><code><span>#1.now:返回当前系统时间+日期</span>
<span>SELECT</span> <span>NOW</span><span>(</span><span>)</span><span>;</span>

<span>#2.year:返回年</span>
<span>SELECT</span> <span>YEAR</span><span>(</span><span>NOW</span><span>(</span><span>)</span><span>)</span><span>;</span>
<span>SELECT</span> <span>YEAR</span><span>(</span>hiredate<span>)</span> 年 <span>FROM</span> employees<span>;</span>

<span>#3.month:返回月</span>
<span>#MONTHNAME:以英文形式返回月</span>
<span>SELECT</span> <span>MONTH</span><span>(</span><span>NOW</span><span>(</span><span>)</span><span>)</span><span>;</span>
<span>SELECT</span> MONTHNAME<span>(</span><span>NOW</span><span>(</span><span>)</span><span>)</span><span>;</span>

<span>#4.day:返回日</span>
<span>#DATEDIFF:返回两个日期相差的天数</span>
<span>SELECT</span> <span>DAY</span><span>(</span><span>NOW</span><span>(</span><span>)</span><span>)</span><span>;</span>
<span>SELECT</span> DATEDIFF<span>(</span><span>'2020/06/30'</span><span>,</span><span>'2020/06/21'</span><span>)</span><span>;</span>

<span>#5.str_to_date:将字符通过指定格式转换成日期</span>
<span>SELECT</span> STR_TO_DATE<span>(</span><span>'2020-5-13'</span><span>,</span><span>'%Y-%c-%d'</span><span>)</span> <span>AS</span> out_put<span>;</span>

<span>#6.date_format:将日期转换成字符</span>
<span>SELECT</span> DATE_FORMAT<span>(</span><span>'2020/6/6'</span><span>,</span><span>'%Y年%m月%d日'</span><span>)</span> <span>AS</span> out_put<span>;</span>
<span>SELECT</span> DATE_FORMAT<span>(</span><span>NOW</span><span>(</span><span>)</span><span>,</span><span>'%Y年%m月%d日'</span><span>)</span> <span>AS</span> out_put<span>;</span>

<span>#7.curdate:返回当前日期</span>
<span>SELECT</span> CURDATE<span>(</span><span>)</span><span>;</span>

<span>#8.curtime:返回当前时间</span>
<span>SELECT</span> CURTIME<span>(</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br></div></div><p><mark>4、其他函数</mark></p>
<div><pre><code><span>#version 当前数据库服务器的版本</span>
<span>SELECT</span> VERSION<span>(</span><span>)</span><span>;</span>

<span>#database 当前打开的数据库</span>
<span>SELECT</span> <span>DATABASE</span><span>(</span><span>)</span><span>;</span>

<span>#user当前用户</span>
<span>SELECT</span> <span>USER</span><span>(</span><span>)</span><span>;</span>

<span>#password('字符')：返回该字符的密码形式</span>
<span>SELECT</span> PASSWORD<span>(</span><span>'a'</span><span>)</span><span>;</span>

<span>#md5('字符'):返回该字符的md5加密形式</span>
<span>SELECT</span> MD5<span>(</span><span>'a'</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p><mark>5、流程控制函数</mark></p>
<div><pre><code><span>#1.if函数: if else效果</span>

<span>SELECT</span> <span>IF</span><span>(</span><span>10</span><span>&lt;</span><span>5</span><span>,</span><span>'大'</span><span>,</span><span>'小'</span><span>)</span><span>;</span>

<span>SELECT</span> last_name<span>,</span>commission_pct<span>,</span><span>IF</span><span>(</span>commission_pct <span>IS</span> <span>NULL</span><span>,</span><span>'没奖金！！！'</span><span>,</span><span>'有奖金!!!'</span><span>)</span> 备注 <span>FROM</span> employees<span>;</span>

<span>#2.case函数</span>
<span>#使用一:switch case 的效果</span>
<span>/*
java中
switch(变量或表达式){
	case 常量1:语句1;break;
	...
	default:语句n;break;
}

mysql中

case 要判断的变量或表达式
when 常量1 then 要显示的值1或语句1
when 常量2 then 要显示的值2或语句2
...
else 要显示的值n或语句n
end

#案例:查询员工的工资,要求:

部门号=30,显示的工资为1.1倍
部门号=40,显示的工资为1.2倍
部门号=50,显示的工资为1.3倍
其他部门,显示的工资为原工资

*/</span>

<span>SELECT</span> salary 原始工资<span>,</span>department_id<span>,</span>
<span>CASE</span> department_id
<span>WHEN</span> <span>30</span> <span>THEN</span> salary<span>*</span><span>1.1</span>
<span>WHEN</span> <span>40</span> <span>THEN</span> salary<span>*</span><span>1.2</span>
<span>WHEN</span> <span>50</span> <span>THEN</span> salary<span>*</span><span>1.3</span>
<span>ELSE</span> salary
<span>END</span> <span>AS</span> 新工资
<span>FROM</span> employees<span>;</span>

<span>#3.case函数的使用二:类似于多重if</span>
<span>/*
java中:
if(条件1){
	语句1;
}else if(条件2){
	语句2;
}
...
else{
	语句n;
}	

mysql中:
case 
when 条件1 then 要显示的值1或语句1
when 条件2 then 要显示的值2或语句2
...
else 要显示的值n或语句n
end

*/</span>

<span>#案例:查询员工的工资的情况</span>
<span>/*
如果工资>20000，显示A级别
如果工资>15000，显示B级别
如果工资>10000，显示c级别
否则，显示D级别
*/</span>

<span>SELECT</span> salary<span>,</span>
<span>CASE</span>
<span>WHEN</span> salary<span>></span><span>20000</span> <span>THEN</span> <span>'A'</span>
<span>WHEN</span> salary<span>></span><span>15000</span> <span>THEN</span> <span>'B'</span>
<span>WHEN</span> salary<span>></span><span>10000</span> <span>THEN</span> <span>'C'</span>
<span>ELSE</span> <span>'D'</span>
<span>END</span> <span>AS</span> 工资等级
<span>FROM</span> employees<span>;</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br></div></div><h3 id="二-分组函数"> （二）分组函数</h3>
<ul>
<li>
<p><strong>功能</strong>：用作统计使用，又称为聚合函数或统计函数或组函数</p>
</li>
<li>
<p><strong>分类</strong>：sum 求和、avg 平均值、max 最大值、min最小值count 计算个数</p>
</li>
<li>
<p><strong>特点</strong>：</p>
<p>（1）sum和avg一般用于处理数值型max、min、count可以处理任何数据类型</p>
<p>（2）以上分组函数都忽略null</p>
<p>（3）都可以搭配distinct使用，实现去重的统计select sum(distinct 字段) from 表;</p>
<p>（4）count函数
count(字段)：统计该字段非空值的个数
count(*):统计结果集的行数</p>
<p>（5）和分组函数一同查询的字段，要求是group by后出现的字段</p>
</li>
</ul>
<div><pre><code><span>#1.简单使用</span>
<span>SELECT</span> <span>SUM</span><span>(</span>salary<span>)</span> <span>FROM</span> employees<span>;</span>
<span>SELECT</span> <span>AVG</span><span>(</span>salary<span>)</span> <span>FROM</span> employees<span>;</span>
<span>SELECT</span> <span>MAX</span><span>(</span>salary<span>)</span> <span>FROM</span> employees<span>;</span>
<span>SELECT</span> <span>MIN</span><span>(</span>salary<span>)</span> <span>FROM</span> employees<span>;</span>
<span>SELECT</span> <span>COUNT</span><span>(</span>salary<span>)</span> <span>FROM</span> employees<span>;</span>

<span>SELECT</span> <span>SUM</span><span>(</span>salary<span>)</span> 和<span>,</span><span>ROUND</span><span>(</span><span>AVG</span><span>(</span>salary<span>)</span><span>,</span><span>2</span><span>)</span> 平均<span>,</span><span>MAX</span><span>(</span>salary<span>)</span> 最高<span>,</span><span>MIN</span><span>(</span>salary<span>)</span> 最低<span>,</span><span>COUNT</span><span>(</span>salary<span>)</span> 个数
<span>FROM</span> employees<span>;</span>

<span>#2.参数支持哪些数据类型</span>

<span>SELECT</span> <span>SUM</span><span>(</span>last_name<span>)</span><span>,</span><span>AVG</span><span>(</span>last_name<span>)</span> <span>FROM</span> employees<span>;</span>
<span>SELECT</span> <span>SUM</span><span>(</span>hiredate<span>)</span><span>,</span><span>AVG</span><span>(</span>hiredate<span>)</span> <span>FROM</span> employees<span>;</span>

<span>SELECT</span> <span>MAX</span><span>(</span>last_name<span>)</span><span>,</span><span>MIN</span><span>(</span>last_name<span>)</span> <span>FROM</span> employees<span>;</span>
<span>SELECT</span> <span>MAX</span><span>(</span>hiredate<span>)</span><span>,</span><span>MIN</span><span>(</span>hiredate<span>)</span> <span>FROM</span> employees<span>;</span>

<span>SELECT</span> <span>COUNT</span><span>(</span>commission_pct<span>)</span> <span>FROM</span> employees<span>;</span>
<span>SELECT</span> <span>COUNT</span><span>(</span>last_name<span>)</span> <span>FROM</span> employees<span>;</span>

<span>#3.是否忽略null</span>
<span>--sum、avg、max、min忽略null</span>
<span>SELECT</span> <span>SUM</span><span>(</span>commission_pct<span>)</span><span>,</span><span>AVG</span><span>(</span>commission_pct<span>)</span> <span>FROM</span> employees<span>;</span>

<span>SELECT</span> commission_pct <span>FROM</span> employees<span>;</span>

<span>SELECT</span> <span>SUM</span><span>(</span>commission_pct<span>)</span><span>,</span><span>AVG</span><span>(</span>commission_pct<span>)</span><span>,</span><span>SUM</span><span>(</span>commission_pct<span>)</span><span>/</span><span>35</span><span>,</span><span>AVG</span><span>(</span>commission_pct<span>)</span><span>/</span><span>107</span> <span>FROM</span> employees<span>;</span>

<span>SELECT</span> <span>MAX</span><span>(</span>commission_pct<span>)</span><span>,</span><span>MIN</span><span>(</span>commission_pct<span>)</span> <span>FROM</span> employees<span>;</span> 

<span>-- count(*)统计所有记录</span>
<span>-- count(column)统计非null值的记录</span>
<span>SELECT</span> <span>COUNT</span><span>(</span><span>*</span><span>)</span> <span>FROM</span> employees<span>;</span> 
<span>SELECT</span> <span>COUNT</span><span>(</span>commission_pct<span>)</span> <span>FROM</span> employees<span>;</span> 
<span>SELECT</span> <span>COUNT</span><span>(</span><span>*</span><span>)</span> <span>FROM</span> employees <span>WHERE</span> commission_pct <span>IS</span> <span>NOT</span> <span>NULL</span><span>;</span> 

<span>#4.和distinct搭配</span>

<span>SELECT</span> <span>SUM</span><span>(</span><span>DISTINCT</span> salary<span>)</span><span>,</span><span>SUM</span><span>(</span>salary<span>)</span> <span>FROM</span> employees<span>;</span>

<span>SELECT</span> <span>COUNT</span><span>(</span><span>DISTINCT</span> salary<span>)</span><span>,</span><span>COUNT</span><span>(</span>salary<span>)</span> <span>FROM</span> employees<span>;</span>

<span>#5.count函数详解</span>

<span>SELECT</span> <span>COUNT</span><span>(</span>salary<span>)</span> <span>FROM</span> employees<span>;</span>
<span>SELECT</span> <span>COUNT</span><span>(</span><span>*</span><span>)</span> <span>FROM</span> employees<span>;</span>
<span>SELECT</span> <span>COUNT</span><span>(</span><span>1</span><span>)</span> <span>FROM</span> employees<span>;</span>
<span>/*
效率上：
MyISAM存储引擎，count(*)最高
InnoDB存储引擎，count(*)和count(1)效率>count(字段)
*/</span>

<span>#6.和分组函数一同查询的字段有限制</span>

<span>SELECT</span> <span>AVG</span><span>(</span>salary<span>)</span><span>,</span>employee_id <span>FROM</span> employees<span>;</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br></div></div><p>大部分运算会忽略NULL行，个别有例外（如聚合、排序）。</p>
<p>具体见下表：</p>
<p>函数	NULL值处理</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>count</td>
<td>count(*)统计所有符合条件的行<br /> count(column)忽略列值为NULL的行<br /> count(NULL)为0</td>
</tr>
<tr>
<td>max</td>
<td>忽略列值为NULL的行</td>
</tr>
<tr>
<td>min</td>
<td>忽略列值为NULL的行</td>
</tr>
<tr>
<td>sum</td>
<td>忽略列值为NULL的行</td>
</tr>
<tr>
<td>avg</td>
<td>忽略列值为NULL的行</td>
</tr>
<tr>
<td>group by</td>
<td>NULL作为一项，放在首行</td>
</tr>
<tr>
<td>order by</td>
<td>所有NULL值相等，作为最小项</td>
</tr>
<tr>
<td>distinct</td>
<td>所有NULL值相等</td>
</tr>
<tr>
<td>+</td>
<td>+直接运算，任意一项值为NULL，则结果为NULL</td>
</tr>
<tr>
<td>&lt;、&gt;<br/>=、&lt;&gt;</td>
<td>论值为什么，结果为<code>NULL</code>；若要与<code>NULL</code>比较是否相等，需使用<code>is null</code>或<code>is not null</code></td>
</tr>
</tbody>
</table>
<div><p>提示</p>
<p>如果就是要统计NULL行，可以利用<code>if</code>求和解决：<code>sum(if(column is null, 1, 0))</code></p>
<p>效率上：</p>
<ul>
<li>MyISAM存储引擎，<code>count(*)</code>最高</li>
<li>InnoDB存储引擎，<code>count(*)</code>和<code>count(1)</code>效率&gt;count(字段)</li>
</ul>
</div>
<h2 id="五、分组查询"> 五、分组查询</h2>
<ul>
<li>
<p><strong>语法</strong></p>
<div><pre><code><span>select</span> 分组函数<span>,</span>分组后的字段
<span>from</span> 表
【<span>where</span> 筛选条件】
<span>group</span> <span>by</span> 分组的字段
【<span>having</span> 分组后的筛选】
【<span>order</span> <span>by</span> 排序列表】
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><div><p>注意</p>
<p>查询列表必须特殊,要求是分组函数和group by后出现的字段</p>
</div>
</li>
<li>
<p><strong>特点</strong></p>
<p>（1）分组查询中的筛选条件分为两类</p>
<div><pre><code>			使用关键字	筛选的表	位置
分组前筛选	<span>where</span>		原始表		<span>group</span> <span>by</span>的前面
分组后筛选	<span>having</span>		分组后的结果	<span>group</span> <span>by</span>的后面
<span>1.</span>分组函数做条件肯定是放在<span>having</span>子句中
<span>2.</span>能用分组前筛选的，就优先考虑使用分组前筛选

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>（2）group by子句支持单个字段分组，多个字段分组(多个字段之间用逗号隔开没有顺序要求),表达式或函数(使用较少)</p>
<p>（3）也可以添加排序(排序放在整个分组查询的最后)</p>
</li>
<li>
<p><strong>案例</strong></p>
<div><pre><code><span>#引入:查询每个部门的平均工资</span>
<span>SELECT</span> e<span>.</span>department_id<span>,</span><span>AVG</span><span>(</span>e<span>.</span>salary<span>)</span> 平均薪资 <span>FROM</span> employees e <span>GROUP</span> <span>BY</span> e<span>.</span>department_id <span>ORDER</span> <span>BY</span> 平均薪资<span>;</span>
<span>-- 复杂一点使用内连接，根据部门ID显示部门名称</span>
<span>SELECT</span> d<span>.</span>department_name 部门<span>,</span><span>AVG</span><span>(</span>e<span>.</span>salary<span>)</span> 平均薪资 <span>FROM</span> employees e <span>INNER</span> <span>JOIN</span> departments d <span>ON</span> e<span>.</span>department_id<span>=</span>d<span>.</span>department_id <span>GROUP</span> <span>BY</span> d<span>.</span>department_name <span>ORDER</span> <span>BY</span> 平均薪资<span>;</span>

<span>#案例1:查询每个工种的最高工资</span>
<span>SELECT</span> <span>MAX</span><span>(</span>salary<span>)</span><span>,</span>job_id <span>FROM</span> employees 
<span>GROUP</span> <span>BY</span> job_id<span>;</span>


<span>#案例2:查询每个位置上的部门个数</span>
<span>SELECT</span> <span>COUNT</span><span>(</span><span>*</span><span>)</span><span>,</span>location_id
<span>FROM</span> departments
<span>GROUP</span> <span>BY</span> location_id<span>;</span>

<span>#添加筛选条件</span>
<span>#案例1:查询邮箱中包含a字符的，每个部门的平均工资</span>
<span>SELECT</span> <span>AVG</span><span>(</span>salary<span>)</span><span>,</span>department_id <span>FROM</span> employees
<span>WHERE</span> email <span>LIKE</span> <span>'%a%'</span> <span>GROUP</span> <span>BY</span> department_id<span>;</span>

<span>#案例2:查询有奖金的每个领导手下员工的最高工资</span>
<span>SELECT</span> <span>MAX</span><span>(</span>salary<span>)</span><span>,</span>manager_id <span>FROM</span> employees
<span>WHERE</span> commission_pct <span>IS</span> <span>NOT</span> <span>NULL</span>
<span>GROUP</span> <span>BY</span> manager_id<span>;</span>

<span>#添加复杂的筛选条件</span>
<span>#案例1:查询哪个部门的员工个数>2</span>
<span>#1.查询每个部门的员工个数</span>
<span>SELECT</span> <span>COUNT</span><span>(</span><span>*</span><span>)</span><span>,</span>department_id <span>FROM</span> employees
<span>GROUP</span> <span>BY</span> department_id<span>;</span>

<span>#2.根据1的结果进行筛选，查询哪个部门的员工个数大于2</span>
<span>SELECT</span> <span>COUNT</span><span>(</span><span>*</span><span>)</span><span>,</span>department_id <span>FROM</span> employees
<span>GROUP</span> <span>BY</span> department_id <span>HAVING</span> <span>COUNT</span><span>(</span><span>*</span><span>)</span><span>></span><span>2</span><span>;</span>


<span>#案例2:查询每个工种有奖金的员工的最高工资>12000的工种编号和最高工资 </span>
<span>#1.查询每个工种有奖金的员工的最高工资 </span>
<span>SELECT</span> <span>MAX</span><span>(</span>salary<span>)</span><span>,</span>job_id <span>FROM</span> employees 
<span>WHERE</span> commission_pct <span>IS</span> <span>NOT</span> <span>NULL</span> <span>GROUP</span> <span>BY</span> job_id<span>;</span> 

<span>#2.根据结果继续筛选，最高工资>12000 </span>

<span>SELECT</span> <span>MAX</span><span>(</span>salary<span>)</span><span>,</span> job_id <span>FROM</span> employees 
<span>WHERE</span> commission_pct <span>IS</span> <span>NOT</span> <span>NULL</span> <span>GROUP</span> <span>BY</span> job_id 
<span>HAVING</span> <span>MAX</span><span>(</span>salary<span>)</span><span>></span><span>12000</span><span>;</span> 

<span>#按表达式或函数分组</span>

<span>#案例:按员工姓名的长度分组,查询每一组的员工个数,筛选员工个数>5</span>

<span>#1.查询每个长度的员工个数 </span>
<span>SELECT</span> <span>COUNT</span><span>(</span><span>*</span><span>)</span><span>,</span>LENGTH<span>(</span>last_name<span>)</span> len_name 
<span>FROM</span> employees <span>GROUP</span> <span>BY</span> LENGTH<span>(</span>last_name<span>)</span><span>;</span> 

<span>#2.添加筛选条件</span>
<span>SELECT</span> <span>COUNT</span><span>(</span><span>*</span><span>)</span> c<span>,</span>LENGTH<span>(</span>last_name<span>)</span> len_name 
<span>FROM</span> employees <span>GROUP</span> <span>BY</span> len_name <span>HAVING</span> c<span>></span><span>5</span><span>;</span>

<span>#按多个字段查询</span>
<span>#案例:查询每个部门每个工种的员工的平均工资</span>

<span>SELECT</span> <span>AVG</span><span>(</span>salary<span>)</span><span>,</span>department_id<span>,</span>job_id
<span>FROM</span> employees <span>GROUP</span> <span>BY</span> department_id<span>,</span>job_id<span>;</span>

<span>#添加排序</span>
<span>#案例:查询每个部门每个工种的员工的平均工资,按平均工资的高低查询</span>

<span>SELECT</span> <span>AVG</span><span>(</span>salary<span>)</span><span>,</span>department_id<span>,</span>job_id
<span>FROM</span> employees <span>GROUP</span> <span>BY</span> department_id<span>,</span>job_id
<span>ORDER</span> <span>BY</span> <span>AVG</span><span>(</span>salary<span>)</span> <span>DESC</span><span>;</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br></div></div></li>
</ul>
<h2 id="六、连接查询"> 六、连接查询</h2>
<ul>
<li>
<p><strong>含义</strong>：又称多表查询,当查询的数据来自多个表时,就会用到连接查询</p>
</li>
<li>
<p><strong>笛卡尔乘积现象</strong>：表1 有m行，表2有n行，结果=m*n行</p>
</li>
<li>
<p><strong>发生原因</strong>：没有有效的连接条件</p>
</li>
<li>
<p><strong>如何避免</strong>：添加有效的连接条件</p>
</li>
<li>
<p><strong>分类</strong></p>
<div><pre><code>按年代分类：
	sql92标准:仅仅支持内连接
	sql99标准【推荐】：支持内连接+外连接（左外和右外）+交叉连接
	
按功能分类：
	内连接：
		等值连接
		非等值连接
		自连接
	外连接：
		左外连接
		右外连接
		全外连接
	交叉连接
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div></li>
</ul>
<h3 id="一-sql92标准案例"> （一）sql92标准案例</h3>
<p><strong>1、等值连接</strong></p>
<div><pre><code><span>#1、等值连接</span>

<span>/*
1.多表等值连接的结果为多表的交集部分
2.n表连接，至少需要n-1个连接条件
3.多表的顺序没有要求
4.一般需要为表起别名
5.可以搭配前面介绍的所有子句使用，比如排序、分组、筛选
*/</span>

<span>#案例1：查询女神名和对应的男神名</span>
<span>SELECT</span> NAME<span>,</span>boyName <span>FROM</span> boys<span>,</span>beauty
<span>WHERE</span> beauty<span>.</span>boyfriend_id<span>=</span> boys<span>.</span>id<span>;</span>

<span>#案例2：查询员工名和对应的部门名</span>

<span>SELECT</span> last_name<span>,</span>department_name 
<span>FROM</span> employees<span>,</span>departments
<span>WHERE</span> employees<span>.</span><span>`</span>department_id<span>`</span><span>=</span>departments<span>.</span><span>`</span>department_id<span>`</span><span>;</span>

<span>#2、为表起别名</span>
<span>/*
1.提高语句的简洁度
2.区分多个重名的字段

注意：如果为表起了别名，则查询的字段就不能使用原来的表名去限定
*/</span>
<span>#查询员工名、工种号、工种名</span>
<span>SELECT</span> e<span>.</span>last_name<span>,</span>e<span>.</span>job_id<span>,</span>j<span>.</span>job_title
<span>FROM</span> employees  e<span>,</span>jobs j
<span>WHERE</span> e<span>.</span><span>`</span>job_id<span>`</span><span>=</span>j<span>.</span><span>`</span>job_id<span>`</span><span>;</span>

<span>#3、两个表的顺序是否可以调换</span>
<span>#查询员工名、工种号、工种名</span>

<span>SELECT</span> e<span>.</span>last_name<span>,</span>e<span>.</span>job_id<span>,</span>j<span>.</span>job_title
<span>FROM</span> jobs j<span>,</span>employees e
<span>WHERE</span> e<span>.</span><span>`</span>job_id<span>`</span><span>=</span>j<span>.</span><span>`</span>job_id<span>`</span><span>;</span>
<span>-- 可以调换</span>

<span>#4、可以加筛选</span>
<span>#案例：查询有奖金的员工名、部门名</span>

<span>SELECT</span> last_name<span>,</span>department_name<span>,</span>commission_pct
<span>FROM</span> employees e<span>,</span>departments d
<span>WHERE</span> e<span>.</span><span>`</span>department_id<span>`</span><span>=</span>d<span>.</span><span>`</span>department_id<span>`</span>
<span>AND</span> e<span>.</span><span>`</span>commission_pct<span>`</span> <span>IS</span> <span>NOT</span> <span>NULL</span><span>;</span>

<span>#案例2：查询城市名中第二个字符为o的部门名和城市名</span>

<span>SELECT</span> department_name<span>,</span>city
<span>FROM</span> departments d<span>,</span>locations l
<span>WHERE</span> d<span>.</span><span>`</span>location_id<span>`</span> <span>=</span> l<span>.</span><span>`</span>location_id<span>`</span>
<span>AND</span> city <span>LIKE</span> <span>'_o%'</span><span>;</span>

<span>#5、可以加分组</span>
<span>#案例1：查询每个城市的部门个数</span>

<span>SELECT</span> <span>COUNT</span><span>(</span><span>*</span><span>)</span> 个数<span>,</span>city
<span>FROM</span> departments d<span>,</span>locations l
<span>WHERE</span> d<span>.</span><span>`</span>location_id<span>`</span><span>=</span>l<span>.</span><span>`</span>location_id<span>`</span>
<span>GROUP</span> <span>BY</span> city<span>;</span>

<span>#案例2：查询有奖金的每个部门的部门名和部门的领导编号和该部门的最低工资</span>
<span>SELECT</span> department_name<span>,</span>d<span>.</span><span>`</span>manager_id<span>`</span><span>,</span><span>MIN</span><span>(</span>salary<span>)</span>
<span>FROM</span> departments d<span>,</span>employees e
<span>WHERE</span> d<span>.</span><span>`</span>department_id<span>`</span><span>=</span>e<span>.</span><span>`</span>department_id<span>`</span>
<span>AND</span> commission_pct <span>IS</span> <span>NOT</span> <span>NULL</span>
<span>GROUP</span> <span>BY</span> department_name<span>;</span>

<span>#6、可以加排序</span>
<span>#案例：查询每个工种的工种名和员工的个数，并且按员工个数降序</span>

<span>SELECT</span> job_title<span>,</span><span>COUNT</span><span>(</span><span>*</span><span>)</span>
<span>FROM</span> employees e<span>,</span>jobs j
<span>WHERE</span> e<span>.</span><span>`</span>job_id<span>`</span><span>=</span>j<span>.</span><span>`</span>job_id<span>`</span>
<span>GROUP</span> <span>BY</span> job_title
<span>ORDER</span> <span>BY</span> <span>COUNT</span><span>(</span><span>*</span><span>)</span> <span>DESC</span><span>;</span>

<span>#7、可以实现三表连接？</span>
<span>#案例：查询员工名、部门名和所在的城市</span>

<span>SELECT</span> last_name<span>,</span>department_name<span>,</span>city
<span>FROM</span> employees e<span>,</span>departments d<span>,</span>locations l
<span>WHERE</span> e<span>.</span><span>`</span>department_id<span>`</span><span>=</span>d<span>.</span><span>`</span>department_id<span>`</span>
<span>AND</span> d<span>.</span><span>`</span>location_id<span>`</span><span>=</span>l<span>.</span><span>`</span>location_id<span>`</span>
<span>AND</span> city <span>LIKE</span> <span>'s%'</span>
<span>ORDER</span> <span>BY</span> department_name <span>DESC</span><span>;</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br></div></div><p><strong>2、非等值连接</strong></p>
<div><pre><code><span>#2、非等值连接</span>
<span>#案例1：查询员工的工资和工资级别</span>

<span>SELECT</span> salary<span>,</span>grade_level
<span>FROM</span> employees e<span>,</span>job_grades g
<span>WHERE</span> salary <span>BETWEEN</span> g<span>.</span><span>`</span>lowest_sal<span>`</span> <span>AND</span> g<span>.</span><span>`</span>highest_sal<span>`</span>
<span>AND</span> g<span>.</span><span>`</span>grade_level<span>`</span><span>=</span><span>'A'</span><span>;</span>

<span>/*
select salary,employee_id from employees;
select * from job_grades;
CREATE TABLE job_grades
(grade_level VARCHAR(3),
 lowest_sal  int,
 highest_sal int);

INSERT INTO job_grades
VALUES ('A', 1000, 2999);

INSERT INTO job_grades
VALUES ('B', 3000, 5999);

INSERT INTO job_grades
VALUES('C', 6000, 9999);

INSERT INTO job_grades
VALUES('D', 10000, 14999);

INSERT INTO job_grades
VALUES('E', 15000, 24999);

INSERT INTO job_grades
VALUES('F', 25000, 40000);

*/</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br></div></div><p><strong>3、自连接</strong></p>
<div><pre><code><span>#3、自连接</span>
<span>#案例：查询 员工名和上级的名称</span>
<span>SELECT</span> e<span>.</span>employee_id<span>,</span>e<span>.</span>last_name<span>,</span>m<span>.</span>employee_id<span>,</span>m<span>.</span>last_name
<span>FROM</span> employees e<span>,</span>employees m
<span>WHERE</span> e<span>.</span><span>`</span>manager_id<span>`</span><span>=</span>m<span>.</span><span>`</span>employee_id<span>`</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h3 id="二-sql99标准案例"> （二）sql99标准案例</h3>
<ul>
<li>
<p><strong>语法</strong></p>
<div><pre><code><span>select</span> 查询列表
<span>from</span> 表<span>1</span> 别名 【连接类型】
<span>join</span> 表<span>2</span> 别名 
<span>on</span> 连接条件
【<span>where</span> 筛选条件】
【<span>group</span> <span>by</span> 分组】
【<span>having</span> 筛选条件】
【<span>order</span> <span>by</span> 排序列表】
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div></li>
<li>
<p><strong>分类</strong></p>
<div><pre><code>内连接（★）：<span>inner</span>
外连接
	左外<span>(</span>★<span>)</span>:<span>left</span> 【<span>outer</span>】
	右外<span>(</span>★<span>)</span>：<span>right</span> 【<span>outer</span>】
	全外：<span>full</span>【<span>outer</span>】
交叉连接：<span>cross</span> 
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div></li>
<li>
<p><strong>案例</strong></p>
<div><pre><code><span>#一、内连接</span>
<span>/*
语法：

select 查询列表
from 表1 别名
inner join 表2 别名
on 连接条件;

分类：
等值
非等值
自连接

特点：
①添加排序、分组、筛选
②inner可以省略
③ 筛选条件放在where后面，连接条件放在on后面，提高分离性，便于阅读
④inner join连接和sql92语法中的等值连接效果是一样的，都是查询多表的交集

*/</span>

<span>#1、等值连接</span>
<span>#案例1.查询员工名、部门名</span>

<span>SELECT</span> last_name<span>,</span>department_name <span>FROM</span> departments d
<span>INNER</span> <span>JOIN</span>  employees e
<span>ON</span> e<span>.</span><span>`</span>department_id<span>`</span> <span>=</span> d<span>.</span><span>`</span>department_id<span>`</span><span>;</span>

<span>#案例2.查询名字中包含e的员工名和工种名（添加筛选）</span>
<span>SELECT</span> last_name<span>,</span>job_title <span>FROM</span> employees e
<span>INNER</span> <span>JOIN</span> jobs j <span>ON</span> e<span>.</span><span>`</span>job_id<span>`</span><span>=</span>  j<span>.</span><span>`</span>job_id<span>`</span>
<span>WHERE</span> e<span>.</span><span>`</span>last_name<span>`</span> <span>LIKE</span> <span>'%e%'</span><span>;</span>

<span>#案例3.查询部门个数>3的城市名和部门个数，（添加分组+筛选）</span>

<span>#1.查询每个城市的部门个数</span>
<span>#2.在1结果上筛选满足条件的</span>
<span>SELECT</span> city<span>,</span><span>COUNT</span><span>(</span><span>*</span><span>)</span> 部门个数
<span>FROM</span> departments d
<span>INNER</span> <span>JOIN</span> locations l
<span>ON</span> d<span>.</span><span>`</span>location_id<span>`</span><span>=</span>l<span>.</span><span>`</span>location_id<span>`</span>
<span>GROUP</span> <span>BY</span> city
<span>HAVING</span> <span>COUNT</span><span>(</span><span>*</span><span>)</span><span>></span><span>3</span><span>;</span>

<span>#案例4.查询哪个部门的员工个数>3的部门名和员工个数，并按个数降序（添加排序）</span>

<span>#1.查询每个部门的员工个数</span>
<span>SELECT</span> <span>COUNT</span><span>(</span><span>*</span><span>)</span><span>,</span>department_name
<span>FROM</span> employees e
<span>INNER</span> <span>JOIN</span> departments d
<span>ON</span> e<span>.</span><span>`</span>department_id<span>`</span><span>=</span>d<span>.</span><span>`</span>department_id<span>`</span>
<span>GROUP</span> <span>BY</span> department_name<span>;</span>

<span>#2.在1结果上筛选员工个数>3的记录，并排序</span>

<span>SELECT</span> <span>COUNT</span><span>(</span><span>*</span><span>)</span> 个数<span>,</span>department_name
<span>FROM</span> employees e
<span>INNER</span> <span>JOIN</span> departments d
<span>ON</span> e<span>.</span><span>`</span>department_id<span>`</span><span>=</span>d<span>.</span><span>`</span>department_id<span>`</span>
<span>GROUP</span> <span>BY</span> department_name
<span>HAVING</span> <span>COUNT</span><span>(</span><span>*</span><span>)</span><span>></span><span>3</span>
<span>ORDER</span> <span>BY</span> <span>COUNT</span><span>(</span><span>*</span><span>)</span> <span>DESC</span><span>;</span>

<span>#案例5.查询员工名、部门名、工种名，并按部门名降序（添加三表连接）</span>

<span>SELECT</span> last_name<span>,</span>department_name<span>,</span>job_title
<span>FROM</span> employees e
<span>INNER</span> <span>JOIN</span> departments d <span>ON</span> e<span>.</span><span>`</span>department_id<span>`</span><span>=</span>d<span>.</span><span>`</span>department_id<span>`</span>
<span>INNER</span> <span>JOIN</span> jobs j <span>ON</span> e<span>.</span><span>`</span>job_id<span>`</span> <span>=</span> j<span>.</span><span>`</span>job_id<span>`</span>
<span>ORDER</span> <span>BY</span> department_name <span>DESC</span><span>;</span>

<span>#二、非等值连接</span>

<span>#查询员工的工资级别</span>

<span>SELECT</span> salary<span>,</span>grade_level
<span>FROM</span> employees e
<span>JOIN</span> job_grades g
<span>ON</span> e<span>.</span><span>`</span>salary<span>`</span> <span>BETWEEN</span> g<span>.</span><span>`</span>lowest_sal<span>`</span> <span>AND</span> g<span>.</span><span>`</span>highest_sal<span>`</span><span>;</span>
 
<span>#查询工资级别的个数>20的个数，并且按工资级别降序</span>
<span>SELECT</span> <span>COUNT</span><span>(</span><span>*</span><span>)</span><span>,</span>grade_level
<span>FROM</span> employees e
<span>JOIN</span> job_grades g
<span>ON</span> e<span>.</span><span>`</span>salary<span>`</span> <span>BETWEEN</span> g<span>.</span><span>`</span>lowest_sal<span>`</span> <span>AND</span> g<span>.</span><span>`</span>highest_sal<span>`</span>
<span>GROUP</span> <span>BY</span> grade_level
<span>HAVING</span> <span>COUNT</span><span>(</span><span>*</span><span>)</span><span>></span><span>20</span>
<span>ORDER</span> <span>BY</span> grade_level <span>DESC</span><span>;</span>

<span>#三、自连接</span>
 
<span>#查询员工的名字、上级的名字</span>
<span>SELECT</span> e<span>.</span>last_name<span>,</span>m<span>.</span>last_name
<span>FROM</span> employees e
<span>JOIN</span> employees m
<span>ON</span> e<span>.</span><span>`</span>manager_id<span>`</span><span>=</span> m<span>.</span><span>`</span>employee_id<span>`</span><span>;</span>
 
<span>#查询姓名中包含字符k的员工的名字、上级的名字</span>
<span>SELECT</span> e<span>.</span>last_name<span>,</span>m<span>.</span>last_name
<span>FROM</span> employees e
<span>JOIN</span> employees m
<span>ON</span> e<span>.</span><span>`</span>manager_id<span>`</span><span>=</span> m<span>.</span><span>`</span>employee_id<span>`</span>
<span>WHERE</span> e<span>.</span><span>`</span>last_name<span>`</span> <span>LIKE</span> <span>'%k%'</span><span>;</span>

<span>#二、外连接</span>
 
<span>/*
应用场景：用于查询一个表中有，另一个表没有的记录
 
特点：
1、外连接的查询结果为主表中的所有记录
	如果从表中有和它匹配的，则显示匹配的值
	如果从表中没有和它匹配的，则显示null
	外连接查询结果=内连接结果+主表中有而从表没有的记录
2、左外连接，left join左边的是主表
   右外连接，right join右边的是主表
3、左外和右外交换两个表的顺序，可以实现同样的效果 
4、全外连接=内连接的结果+表1中有但表2没有的+表2中有但表1没有的
*/</span>
<span>#引入：查询男朋友 不在男神表的的女神名</span>

<span>SELECT</span> <span>*</span> <span>FROM</span> beauty<span>;</span>
<span>SELECT</span> <span>*</span> <span>FROM</span> boys<span>;</span>
 
<span>#左外连接</span>
<span>SELECT</span> b<span>.</span><span>*</span><span>,</span>bo<span>.</span><span>*</span> <span>FROM</span> boys bo
<span>LEFT</span> <span>OUTER</span> <span>JOIN</span> beauty b
<span>ON</span> b<span>.</span><span>`</span>boyfriend_id<span>`</span> <span>=</span> bo<span>.</span><span>`</span>id<span>`</span>
<span>WHERE</span> b<span>.</span><span>`</span>id<span>`</span> <span>IS</span> <span>NULL</span><span>;</span>
 
<span>#案例1：查询哪个部门没有员工</span>
<span>#左外</span>
<span>SELECT</span> d<span>.</span><span>*</span><span>,</span>e<span>.</span>employee_id
<span>FROM</span> departments d
<span>LEFT</span> <span>OUTER</span> <span>JOIN</span> employees e
<span>ON</span> d<span>.</span><span>`</span>department_id<span>`</span> <span>=</span> e<span>.</span><span>`</span>department_id<span>`</span>
<span>WHERE</span> e<span>.</span><span>`</span>employee_id<span>`</span> <span>IS</span> <span>NULL</span><span>;</span>

<span>#右外</span>
 
<span>SELECT</span> d<span>.</span><span>*</span><span>,</span>e<span>.</span>employee_id
<span>FROM</span> employees e
<span>RIGHT</span> <span>OUTER</span> <span>JOIN</span> departments d
<span>ON</span> d<span>.</span><span>`</span>department_id<span>`</span> <span>=</span> e<span>.</span><span>`</span>department_id<span>`</span>
<span>WHERE</span> e<span>.</span><span>`</span>employee_id<span>`</span> <span>IS</span> <span>NULL</span><span>;</span>

<span>#全外</span>

<span>USE</span> girls<span>;</span>
<span>SELECT</span> b<span>.</span><span>*</span><span>,</span>bo<span>.</span><span>*</span> <span>FROM</span> beauty b
<span>FULL</span> <span>OUTER</span> <span>JOIN</span> boys bo
<span>ON</span> b<span>.</span><span>`</span>boyfriend_id<span>`</span> <span>=</span> bo<span>.</span>id<span>;</span>

<span>#交叉连接</span>
<span>-- 两个表各10条记录，交叉连接就是返回10*10条记录</span>
<span>-- 可以想象，当表中的数据较多时，得到的运行结果会非常长，而且得到的运行结果也没太大的意义。</span>
<span>-- 所以，通过交叉连接的方式进行多表查询的这种方法并不常用，我们应该尽量避免这种查询。</span>
<span>SELECT</span> <span>*</span> <span>FROM</span> beauty b
<span>CROSS</span> <span>JOIN</span> boys bo<span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br><span>96</span><br><span>97</span><br><span>98</span><br><span>99</span><br><span>100</span><br><span>101</span><br><span>102</span><br><span>103</span><br><span>104</span><br><span>105</span><br><span>106</span><br><span>107</span><br><span>108</span><br><span>109</span><br><span>110</span><br><span>111</span><br><span>112</span><br><span>113</span><br><span>114</span><br><span>115</span><br><span>116</span><br><span>117</span><br><span>118</span><br><span>119</span><br><span>120</span><br><span>121</span><br><span>122</span><br><span>123</span><br><span>124</span><br><span>125</span><br><span>126</span><br><span>127</span><br><span>128</span><br><span>129</span><br><span>130</span><br><span>131</span><br><span>132</span><br><span>133</span><br><span>134</span><br><span>135</span><br><span>136</span><br><span>137</span><br><span>138</span><br><span>139</span><br><span>140</span><br><span>141</span><br><span>142</span><br><span>143</span><br><span>144</span><br><span>145</span><br><span>146</span><br><span>147</span><br><span>148</span><br><span>149</span><br><span>150</span><br><span>151</span><br><span>152</span><br><span>153</span><br><span>154</span><br><span>155</span><br><span>156</span><br><span>157</span><br><span>158</span><br><span>159</span><br><span>160</span><br></div></div></li>
</ul>
<h3 id="三-sql92和sql99对比"> （三）sql92和sql99对比</h3>
<ul>
<li><strong>功能</strong>：sql99支持的较多</li>
<li><strong>可读性</strong>：sql99实现连接条件和筛选条件的分离，可读性较高</li>
</ul>
<h2 id="七、子查询"> 七、子查询</h2>
<ul>
<li>
<p><strong>含义</strong>：出现在其他语句中的select语句,称为子查询或内查询外部的查询语句，称为主查询或外查询。</p>
</li>
<li>
<p><strong>分类</strong></p>
</li>
<li>
<p><strong>案例</strong></p>
<div><pre><code><span>#一、where或having后面</span>
<span>/*
1、标量子查询（单行子查询）
2、列子查询（多行子查询）
3、行子查询（多列多行）

特点：
①子查询放在小括号内
②子查询一般放在条件的右侧
③标量子查询，一般搭配着单行操作符使用
> &lt; >= &lt;= = &lt;>

列子查询，一般搭配着多行操作符使用
in、any/some、all

④子查询的执行优先于主查询执行，主查询的条件用到了子查询的结果
*/</span>

<span>#1.标量子查询★</span>

<span>#案例1：谁的工资比 Abel 高?</span>

<span>#①查询Abel的工资</span>
<span>SELECT</span> salary
<span>FROM</span> employees
<span>WHERE</span> last_name <span>=</span> <span>'Abel'</span><span>;</span>

<span>#②查询员工的信息，满足 salary>①结果</span>
<span>SELECT</span> <span>*</span>
<span>FROM</span> employees
<span>WHERE</span> salary<span>></span><span>(</span>
	<span>SELECT</span> salary
	<span>FROM</span> employees
	<span>WHERE</span> last_name <span>=</span> <span>'Abel'</span>
	
<span>)</span><span>;</span>

<span>#案例2：返回job_id与141号员工相同，salary比143号员工多的员工 姓名，job_id 和工资</span>

<span>#①查询141号员工的job_id</span>
<span>SELECT</span> job_id <span>FROM</span> employees
<span>WHERE</span> employee_id <span>=</span> <span>141</span><span>;</span>

<span>#②查询143号员工的salary</span>
<span>SELECT</span> salary <span>FROM</span> employees
<span>WHERE</span> employee_id <span>=</span> <span>143</span><span>;</span>

<span>#③查询员工的姓名，job_id 和工资，要求job_id=①并且salary>②</span>

<span>SELECT</span> last_name<span>,</span>job_id<span>,</span>salary
<span>FROM</span> employees
<span>WHERE</span> job_id <span>=</span> <span>(</span>
	<span>SELECT</span> job_id
	<span>FROM</span> employees
	<span>WHERE</span> employee_id <span>=</span> <span>141</span>
<span>)</span> <span>AND</span> salary<span>></span><span>(</span>
	<span>SELECT</span> salary
	<span>FROM</span> employees
	<span>WHERE</span> employee_id <span>=</span> <span>143</span>

<span>)</span><span>;</span>

<span>#案例3：返回公司工资最少的员工的last_name,job_id和salary</span>

<span>#①查询公司的最低工资</span>
<span>SELECT</span> <span>MIN</span><span>(</span>salary<span>)</span> <span>FROM</span> employees<span>;</span>

<span>#②查询last_name,job_id和salary，要求salary=①</span>
<span>SELECT</span> last_name<span>,</span>job_id<span>,</span>salary
<span>FROM</span> employees
<span>WHERE</span> salary<span>=</span><span>(</span>
	<span>SELECT</span> <span>MIN</span><span>(</span>salary<span>)</span>
	<span>FROM</span> employees
<span>)</span><span>;</span>

<span>#案例4：查询最低工资大于50号部门最低工资的部门id和其最低工资</span>

<span>#①查询50号部门的最低工资</span>
<span>SELECT</span>  <span>MIN</span><span>(</span>salary<span>)</span>
<span>FROM</span> employees
<span>WHERE</span> department_id <span>=</span> <span>50</span><span>;</span>

<span>#②查询每个部门的最低工资</span>

<span>SELECT</span> <span>MIN</span><span>(</span>salary<span>)</span><span>,</span>department_id
<span>FROM</span> employees
<span>GROUP</span> <span>BY</span> department_id<span>;</span>

<span>#③ 在②基础上筛选，满足min(salary)>①</span>
<span>SELECT</span> <span>MIN</span><span>(</span>salary<span>)</span><span>,</span>department_id
<span>FROM</span> employees
<span>GROUP</span> <span>BY</span> department_id
<span>HAVING</span> <span>MIN</span><span>(</span>salary<span>)</span><span>></span><span>(</span>
	<span>SELECT</span>  <span>MIN</span><span>(</span>salary<span>)</span>
	<span>FROM</span> employees
	<span>WHERE</span> department_id <span>=</span> <span>50</span>
<span>)</span><span>;</span>

<span>#非法使用标量子查询</span>

<span>SELECT</span> <span>MIN</span><span>(</span>salary<span>)</span><span>,</span>department_id
<span>FROM</span> employees
<span>GROUP</span> <span>BY</span> department_id
<span>HAVING</span> <span>MIN</span><span>(</span>salary<span>)</span><span>></span><span>(</span>
	<span>SELECT</span>  salary
	<span>FROM</span> employees
	<span>WHERE</span> department_id <span>=</span> <span>250</span>
<span>)</span><span>;</span>

<span>#2.列子查询（多行子查询）★</span>
<span>#案例1：返回location_id是1400或1700的部门中的所有员工姓名</span>

<span>#①查询location_id是1400或1700的部门编号</span>
<span>SELECT</span> <span>DISTINCT</span> department_id
<span>FROM</span> departments
<span>WHERE</span> location_id <span>IN</span><span>(</span><span>1400</span><span>,</span><span>1700</span><span>)</span><span>;</span>

<span>#②查询员工姓名，要求部门号是①列表中的某一个</span>

<span>SELECT</span> last_name
<span>FROM</span> employees
<span>WHERE</span> department_id  <span>&lt;></span><span>ALL</span><span>(</span>
	<span>SELECT</span> <span>DISTINCT</span> department_id
	<span>FROM</span> departments
	<span>WHERE</span> location_id <span>IN</span><span>(</span><span>1400</span><span>,</span><span>1700</span><span>)</span>
<span>)</span><span>;</span>


<span>#案例2：返回其它工种中比job_id为‘IT_PROG’工种任一工资低的员工的员工号、姓名、job_id 以及salary</span>

<span>#①查询job_id为‘IT_PROG’部门任一工资</span>

<span>SELECT</span> <span>DISTINCT</span> salary <span>FROM</span> employees
<span>WHERE</span> job_id <span>=</span> <span>'IT_PROG'</span><span>;</span>

<span>#②查询员工号、姓名、job_id 以及salary，salary&lt;(①)的任意一个</span>
<span>SELECT</span> last_name<span>,</span>employee_id<span>,</span>job_id<span>,</span>salary
<span>FROM</span> employees
<span>WHERE</span> salary<span>&lt;</span><span>ANY</span><span>(</span>
	<span>SELECT</span> <span>DISTINCT</span> salary
	<span>FROM</span> employees
	<span>WHERE</span> job_id <span>=</span> <span>'IT_PROG'</span>

<span>)</span> <span>AND</span> job_id<span>&lt;></span><span>'IT_PROG'</span><span>;</span>

<span>#或</span>
<span>SELECT</span> last_name<span>,</span>employee_id<span>,</span>job_id<span>,</span>salary
<span>FROM</span> employees
<span>WHERE</span> salary<span>&lt;</span><span>(</span>
	<span>SELECT</span> <span>MAX</span><span>(</span>salary<span>)</span>
	<span>FROM</span> employees
	<span>WHERE</span> job_id <span>=</span> <span>'IT_PROG'</span>

<span>)</span> <span>AND</span> job_id<span>&lt;></span><span>'IT_PROG'</span><span>;</span>


<span>#案例3：返回其它部门中比job_id为‘IT_PROG’部门所有工资都低的员工   的员工号、姓名、job_id 以及salary</span>

<span>SELECT</span> last_name<span>,</span>employee_id<span>,</span>job_id<span>,</span>salary
<span>FROM</span> employees
<span>WHERE</span> salary<span>&lt;</span><span>ALL</span><span>(</span>
	<span>SELECT</span> <span>DISTINCT</span> salary
	<span>FROM</span> employees
	<span>WHERE</span> job_id <span>=</span> <span>'IT_PROG'</span>

<span>)</span> <span>AND</span> job_id<span>&lt;></span><span>'IT_PROG'</span><span>;</span>

<span>#或</span>

<span>SELECT</span> last_name<span>,</span>employee_id<span>,</span>job_id<span>,</span>salary
<span>FROM</span> employees
<span>WHERE</span> salary<span>&lt;</span><span>(</span>
	<span>SELECT</span> <span>MIN</span><span>(</span> salary<span>)</span>
	<span>FROM</span> employees
	<span>WHERE</span> job_id <span>=</span> <span>'IT_PROG'</span>

<span>)</span> <span>AND</span> job_id<span>&lt;></span><span>'IT_PROG'</span><span>;</span>

<span>#3、行子查询（结果集一行多列或多行多列）</span>

<span>#案例：查询员工编号最小并且工资最高的员工信息</span>

<span>SELECT</span> <span>*</span> <span>FROM</span> employees
<span>WHERE</span> <span>(</span>employee_id<span>,</span>salary<span>)</span><span>=</span><span>(</span>
	<span>SELECT</span> <span>MIN</span><span>(</span>employee_id<span>)</span><span>,</span><span>MAX</span><span>(</span>salary<span>)</span>
	<span>FROM</span> employees
<span>)</span><span>;</span>

<span>#①查询最小的员工编号</span>
<span>SELECT</span> <span>MIN</span><span>(</span>employee_id<span>)</span> <span>FROM</span> employees<span>;</span>

<span>#②查询最高工资</span>
<span>SELECT</span> <span>MAX</span><span>(</span>salary<span>)</span> <span>FROM</span> employees<span>;</span>

<span>#③查询员工信息</span>
<span>SELECT</span> <span>*</span> <span>FROM</span> employees
<span>WHERE</span> employee_id<span>=</span><span>(</span>
	<span>SELECT</span> <span>MIN</span><span>(</span>employee_id<span>)</span>
	<span>FROM</span> employees
<span>)</span><span>AND</span> salary<span>=</span><span>(</span>
	<span>SELECT</span> <span>MAX</span><span>(</span>salary<span>)</span>
	<span>FROM</span> employees
<span>)</span><span>;</span>


<span>#二、select后面</span>
<span>/*
仅仅支持标量子查询
*/</span>

<span>#案例：查询每个部门的员工个数</span>

<span>SELECT</span> d<span>.</span><span>*</span><span>,</span><span>(</span>
	<span>SELECT</span> <span>COUNT</span><span>(</span><span>*</span><span>)</span>
	<span>FROM</span> employees e
	<span>WHERE</span> e<span>.</span>department_id <span>=</span> d<span>.</span><span>`</span>department_id<span>`</span>
 <span>)</span> 个数
 <span>FROM</span> departments d<span>;</span>
 
 
<span>#案例2：查询员工号=102的部门名</span>
 
<span>SELECT</span> <span>(</span>
	<span>SELECT</span> department_name<span>,</span>e<span>.</span>department_id
	<span>FROM</span> departments d
	<span>INNER</span> <span>JOIN</span> employees e
	<span>ON</span> d<span>.</span>department_id<span>=</span>e<span>.</span>department_id
	<span>WHERE</span> e<span>.</span>employee_id<span>=</span><span>102</span>
	
<span>)</span> 部门名<span>;</span>

<span>#三、from后面</span>
<span>/*
将子查询结果充当一张表，要求必须起别名
*/</span>

<span>#案例：查询每个部门的平均工资的工资等级</span>
<span>#①查询每个部门的平均工资</span>
<span>SELECT</span> <span>AVG</span><span>(</span>salary<span>)</span><span>,</span>department_id
<span>FROM</span> employees <span>GROUP</span> <span>BY</span> department_id<span>;</span>

<span>SELECT</span> <span>*</span> <span>FROM</span> job_grades<span>;</span>

<span>#②连接①的结果集和job_grades表，筛选条件平均工资 between lowest_sal and highest_sal</span>

<span>SELECT</span>  ag_dep<span>.</span><span>*</span><span>,</span>g<span>.</span><span>`</span>grade_level<span>`</span>
<span>FROM</span> <span>(</span>
	<span>SELECT</span> <span>AVG</span><span>(</span>salary<span>)</span> ag<span>,</span>department_id
	<span>FROM</span> employees
	<span>GROUP</span> <span>BY</span> department_id
<span>)</span> ag_dep
<span>INNER</span> <span>JOIN</span> job_grades g
<span>ON</span> ag_dep<span>.</span>ag <span>BETWEEN</span> lowest_sal <span>AND</span> highest_sal<span>;</span>

<span>#四、exists后面（相关子查询）</span>
<span>/*
语法：
exists(完整的查询语句)
结果：
1或0
*/</span>
<span>SELECT</span> <span>EXISTS</span><span>(</span><span>SELECT</span> employee_id <span>FROM</span> employees <span>WHERE</span> salary<span>=</span><span>300000</span><span>)</span><span>;</span>

<span>#案例1：查询有员工的部门名</span>

<span>#in</span>
<span>SELECT</span> department_name
<span>FROM</span> departments d
<span>WHERE</span> d<span>.</span><span>`</span>department_id<span>`</span> <span>IN</span><span>(</span>
	<span>SELECT</span> department_id
	<span>FROM</span> employees
<span>)</span><span>;</span>

<span>#exists</span>
<span>SELECT</span> department_name
<span>FROM</span> departments d
<span>WHERE</span> <span>EXISTS</span><span>(</span>
	<span>SELECT</span> <span>*</span>
	<span>FROM</span> employees e
	<span>WHERE</span> d<span>.</span><span>`</span>department_id<span>`</span><span>=</span>e<span>.</span><span>`</span>department_id<span>`</span>
<span>)</span><span>;</span>

<span>#案例2：查询没有女朋友的男神信息</span>

<span>#in</span>
<span>SELECT</span> bo<span>.</span><span>*</span>
<span>FROM</span> boys bo
<span>WHERE</span> bo<span>.</span>id <span>NOT</span> <span>IN</span><span>(</span>
	<span>SELECT</span> boyfriend_id
	<span>FROM</span> beauty
<span>)</span><span>;</span>

<span>#exists</span>
<span>SELECT</span> bo<span>.</span><span>*</span>
<span>FROM</span> boys bo
<span>WHERE</span> <span>NOT</span> <span>EXISTS</span><span>(</span>
	<span>SELECT</span> boyfriend_id
	<span>FROM</span> beauty b
	<span>WHERE</span> bo<span>.</span><span>`</span>id<span>`</span><span>=</span>b<span>.</span><span>`</span>boyfriend_id<span>`</span>
<span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br><span>96</span><br><span>97</span><br><span>98</span><br><span>99</span><br><span>100</span><br><span>101</span><br><span>102</span><br><span>103</span><br><span>104</span><br><span>105</span><br><span>106</span><br><span>107</span><br><span>108</span><br><span>109</span><br><span>110</span><br><span>111</span><br><span>112</span><br><span>113</span><br><span>114</span><br><span>115</span><br><span>116</span><br><span>117</span><br><span>118</span><br><span>119</span><br><span>120</span><br><span>121</span><br><span>122</span><br><span>123</span><br><span>124</span><br><span>125</span><br><span>126</span><br><span>127</span><br><span>128</span><br><span>129</span><br><span>130</span><br><span>131</span><br><span>132</span><br><span>133</span><br><span>134</span><br><span>135</span><br><span>136</span><br><span>137</span><br><span>138</span><br><span>139</span><br><span>140</span><br><span>141</span><br><span>142</span><br><span>143</span><br><span>144</span><br><span>145</span><br><span>146</span><br><span>147</span><br><span>148</span><br><span>149</span><br><span>150</span><br><span>151</span><br><span>152</span><br><span>153</span><br><span>154</span><br><span>155</span><br><span>156</span><br><span>157</span><br><span>158</span><br><span>159</span><br><span>160</span><br><span>161</span><br><span>162</span><br><span>163</span><br><span>164</span><br><span>165</span><br><span>166</span><br><span>167</span><br><span>168</span><br><span>169</span><br><span>170</span><br><span>171</span><br><span>172</span><br><span>173</span><br><span>174</span><br><span>175</span><br><span>176</span><br><span>177</span><br><span>178</span><br><span>179</span><br><span>180</span><br><span>181</span><br><span>182</span><br><span>183</span><br><span>184</span><br><span>185</span><br><span>186</span><br><span>187</span><br><span>188</span><br><span>189</span><br><span>190</span><br><span>191</span><br><span>192</span><br><span>193</span><br><span>194</span><br><span>195</span><br><span>196</span><br><span>197</span><br><span>198</span><br><span>199</span><br><span>200</span><br><span>201</span><br><span>202</span><br><span>203</span><br><span>204</span><br><span>205</span><br><span>206</span><br><span>207</span><br><span>208</span><br><span>209</span><br><span>210</span><br><span>211</span><br><span>212</span><br><span>213</span><br><span>214</span><br><span>215</span><br><span>216</span><br><span>217</span><br><span>218</span><br><span>219</span><br><span>220</span><br><span>221</span><br><span>222</span><br><span>223</span><br><span>224</span><br><span>225</span><br><span>226</span><br><span>227</span><br><span>228</span><br><span>229</span><br><span>230</span><br><span>231</span><br><span>232</span><br><span>233</span><br><span>234</span><br><span>235</span><br><span>236</span><br><span>237</span><br><span>238</span><br><span>239</span><br><span>240</span><br><span>241</span><br><span>242</span><br><span>243</span><br><span>244</span><br><span>245</span><br><span>246</span><br><span>247</span><br><span>248</span><br><span>249</span><br><span>250</span><br><span>251</span><br><span>252</span><br><span>253</span><br><span>254</span><br><span>255</span><br><span>256</span><br><span>257</span><br><span>258</span><br><span>259</span><br><span>260</span><br><span>261</span><br><span>262</span><br><span>263</span><br><span>264</span><br><span>265</span><br><span>266</span><br><span>267</span><br><span>268</span><br><span>269</span><br><span>270</span><br><span>271</span><br><span>272</span><br><span>273</span><br><span>274</span><br><span>275</span><br><span>276</span><br><span>277</span><br><span>278</span><br><span>279</span><br><span>280</span><br><span>281</span><br><span>282</span><br><span>283</span><br><span>284</span><br><span>285</span><br><span>286</span><br><span>287</span><br><span>288</span><br><span>289</span><br><span>290</span><br><span>291</span><br><span>292</span><br><span>293</span><br><span>294</span><br><span>295</span><br><span>296</span><br><span>297</span><br><span>298</span><br><span>299</span><br><span>300</span><br></div></div></li>
</ul>
<h2 id="八、分页查询"> 八、分页查询</h2>
<ul>
<li>
<p><strong>应用场景</strong>：当要显示的数据，一页显示不全，需要分页提交sql请求。</p>
</li>
<li>
<p><strong>语法</strong></p>
<div><pre><code><span>select</span> 查询列表
<span>from</span> 表<span>1</span>
【<span>join</span> <span>type</span>】 <span>join</span> 表<span>2</span>
<span>on</span> 连接条件
<span>where</span> 筛选条件
<span>group</span> <span>by</span> 分组字段
<span>having</span> 分组后的筛选
<span>order</span> <span>by</span> 排序的字段】
<span>limit</span> 【<span>offset</span><span>,</span>】size<span>;</span>

<span>--注意：</span>
	<span>offset</span>要显示条目的起始索引（起始索引从<span>0</span>开始）
	size 要显示的条目个数
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div></li>
<li>
<p><strong>特点</strong></p>
<div><pre><code>①<span>limit</span>语句放在查询语句的最后
②公式
	要显示的页数 page，每页的条目数size
	
<span>select</span> 查询列表 <span>from</span> 表
<span>limit</span> <span>(</span>page<span>-</span><span>1</span><span>)</span><span>*</span>size<span>,</span>size<span>;</span>
	
size<span>=</span><span>10</span>
page  
<span>1</span>	<span>0</span>
<span>2</span>  	<span>10</span>
<span>3</span>	<span>20</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div></li>
<li>
<p><strong>案例</strong></p>
<div><pre><code><span>#案例1：查询前五条员工信息</span>
<span>SELECT</span> <span>*</span> <span>FROM</span>  employees <span>LIMIT</span> <span>0</span><span>,</span><span>5</span><span>;</span>
<span>SELECT</span> <span>*</span> <span>FROM</span>  employees <span>LIMIT</span> <span>5</span><span>;</span>

<span>#案例2：查询第11条——第25条</span>
<span>SELECT</span> <span>*</span> <span>FROM</span> employees <span>LIMIT</span> <span>10</span><span>,</span><span>15</span><span>;</span>

<span>#案例3：有奖金的员工信息，并且工资较高的前10名显示出来</span>
<span>SELECT</span> <span>*</span> <span>FROM</span> employees 
<span>WHERE</span> commission_pct <span>IS</span> <span>NOT</span> <span>NULL</span> 
<span>ORDER</span> <span>BY</span> salary <span>DESC</span> <span>LIMIT</span> <span>10</span> <span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div></li>
</ul>
<h2 id="九、联合查询"> 九、联合查询</h2>
<ul>
<li>
<p><strong>含义</strong>：union (联合、合并)：将多条查询语句的结果合并成一个结果。</p>
</li>
<li>
<p><strong>语法</strong></p>
<div><pre><code>查询语句<span>1</span>
<span>union</span> 【<span>all</span>】
查询语句<span>2</span>
<span>union</span> 【<span>all</span>】
<span>.</span><span>.</span><span>.</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div></li>
<li>
<p><strong>意义</strong></p>
<p>（1）将一条比较复杂的查询语句拆分成多条语句</p>
<p>（2）适用于查询多个表的时候，查询的列基本是一致。</p>
</li>
<li>
<p><strong>特点</strong></p>
<p>（1）要求多条查询语句的查询列数是一致的！</p>
<p>（2）要求多条查询语句的查询的每一列的类型和顺序最好一致</p>
<p>（3）union关键字默认去重，如果使用union all 可以包含重复项</p>
</li>
<li>
<p><strong>案例</strong></p>
<div><pre><code><span>#引入的案例：查询部门编号>90或邮箱包含a的员工信息</span>

<span>SELECT</span> <span>*</span> <span>FROM</span> employees <span>WHERE</span> email <span>LIKE</span> <span>'%a%'</span> <span>OR</span> department_id<span>></span><span>90</span><span>;</span>

<span>SELECT</span> <span>*</span> <span>FROM</span> employees  <span>WHERE</span> email <span>LIKE</span> <span>'%a%'</span>
<span>UNION</span>
<span>SELECT</span> <span>*</span> <span>FROM</span> employees  <span>WHERE</span> department_id<span>></span><span>90</span><span>;</span>


<span>#案例：查询中国用户中男性的信息以及外国用户中年男性的用户信息</span>

<span>SELECT</span> id<span>,</span>cname<span>,</span>csex <span>FROM</span> t_ca <span>WHERE</span> csex<span>=</span><span>'男'</span>
<span>UNION</span>
<span>SELECT</span> t_id<span>,</span>tName<span>,</span>tGender <span>FROM</span> t_ua <span>WHERE</span> tGender<span>=</span><span>'male'</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div></li>
<li>
<p><strong>此处需要的数据库源文件</strong></p>
<div><pre><code><span>/*
 Navicat MySQL Data Transfer

 Source Server         : localhost
 Source Server Type    : MySQL
 Source Server Version : 50145
 Source Host           : localhost:3306
 Source Schema         : test

 Target Server Type    : MySQL
 Target Server Version : 50145
 File Encoding         : 65001

 Date: 03/07/2020 11:08:32
*/</span>

<span>SET</span> NAMES utf8mb4<span>;</span>
<span>SET</span> FOREIGN_KEY_CHECKS <span>=</span> <span>0</span><span>;</span>

<span>-- ----------------------------</span>
<span>-- Table structure for t_ca</span>
<span>-- ----------------------------</span>
<span>DROP</span> <span>TABLE</span> <span>IF</span> <span>EXISTS</span> <span>`</span>t_ca<span>`</span><span>;</span>
<span>CREATE</span> <span>TABLE</span> <span>`</span>t_ca<span>`</span>  <span>(</span>
  <span>`</span>id<span>`</span> <span>int</span><span>(</span><span>20</span><span>)</span> <span>NOT</span> <span>NULL</span><span>,</span>
  <span>`</span>cname<span>`</span> <span>varchar</span><span>(</span><span>255</span><span>)</span> <span>CHARACTER</span> <span>SET</span> utf8 <span>COLLATE</span> utf8_general_ci <span>NULL</span> <span>DEFAULT</span> <span>NULL</span><span>,</span>
  <span>`</span>csex<span>`</span> <span>varchar</span><span>(</span><span>255</span><span>)</span> <span>CHARACTER</span> <span>SET</span> utf8 <span>COLLATE</span> utf8_general_ci <span>NULL</span> <span>DEFAULT</span> <span>NULL</span><span>,</span>
  <span>PRIMARY</span> <span>KEY</span> <span>(</span><span>`</span>id<span>`</span><span>)</span> <span>USING</span> <span>BTREE</span>
<span>)</span> <span>ENGINE</span> <span>=</span> <span>InnoDB</span> <span>CHARACTER</span> <span>SET</span> <span>=</span> utf8 <span>COLLATE</span> <span>=</span> utf8_general_ci ROW_FORMAT <span>=</span> Compact<span>;</span>

<span>-- ----------------------------</span>
<span>-- Records of t_ca</span>
<span>-- ----------------------------</span>
<span>INSERT</span> <span>INTO</span> <span>`</span>t_ca<span>`</span> <span>VALUES</span> <span>(</span><span>1</span><span>,</span> <span>'韩梅梅'</span><span>,</span> <span>'女'</span><span>)</span><span>;</span>
<span>INSERT</span> <span>INTO</span> <span>`</span>t_ca<span>`</span> <span>VALUES</span> <span>(</span><span>2</span><span>,</span> <span>'李雷'</span><span>,</span> <span>'男'</span><span>)</span><span>;</span>
<span>INSERT</span> <span>INTO</span> <span>`</span>t_ca<span>`</span> <span>VALUES</span> <span>(</span><span>3</span><span>,</span> <span>'李明'</span><span>,</span> <span>'男'</span><span>)</span><span>;</span>

<span>SET</span> FOREIGN_KEY_CHECKS <span>=</span> <span>1</span><span>;</span>


<span>/*
 Navicat MySQL Data Transfer

 Source Server         : localhost
 Source Server Type    : MySQL
 Source Server Version : 50145
 Source Host           : localhost:3306
 Source Schema         : test

 Target Server Type    : MySQL
 Target Server Version : 50145
 File Encoding         : 65001

 Date: 03/07/2020 11:09:05
*/</span>

<span>SET</span> NAMES utf8mb4<span>;</span>
<span>SET</span> FOREIGN_KEY_CHECKS <span>=</span> <span>0</span><span>;</span>

<span>-- ----------------------------</span>
<span>-- Table structure for t_ua</span>
<span>-- ----------------------------</span>
<span>DROP</span> <span>TABLE</span> <span>IF</span> <span>EXISTS</span> <span>`</span>t_ua<span>`</span><span>;</span>
<span>CREATE</span> <span>TABLE</span> <span>`</span>t_ua<span>`</span>  <span>(</span>
  <span>`</span>t_id<span>`</span> <span>int</span><span>(</span><span>11</span><span>)</span> <span>NOT</span> <span>NULL</span><span>,</span>
  <span>`</span>tName<span>`</span> <span>varchar</span><span>(</span><span>255</span><span>)</span> <span>CHARACTER</span> <span>SET</span> utf8 <span>COLLATE</span> utf8_general_ci <span>NULL</span> <span>DEFAULT</span> <span>NULL</span><span>,</span>
  <span>`</span>tGender<span>`</span> <span>varchar</span><span>(</span><span>255</span><span>)</span> <span>CHARACTER</span> <span>SET</span> utf8 <span>COLLATE</span> utf8_general_ci <span>NULL</span> <span>DEFAULT</span> <span>NULL</span><span>,</span>
  <span>PRIMARY</span> <span>KEY</span> <span>(</span><span>`</span>t_id<span>`</span><span>)</span> <span>USING</span> <span>BTREE</span>
<span>)</span> <span>ENGINE</span> <span>=</span> <span>InnoDB</span> <span>CHARACTER</span> <span>SET</span> <span>=</span> utf8 <span>COLLATE</span> <span>=</span> utf8_general_ci ROW_FORMAT <span>=</span> Compact<span>;</span>

<span>-- ----------------------------</span>
<span>-- Records of t_ua</span>
<span>-- ----------------------------</span>
<span>INSERT</span> <span>INTO</span> <span>`</span>t_ua<span>`</span> <span>VALUES</span> <span>(</span><span>1</span><span>,</span> <span>'john'</span><span>,</span> <span>'male'</span><span>)</span><span>;</span>
<span>INSERT</span> <span>INTO</span> <span>`</span>t_ua<span>`</span> <span>VALUES</span> <span>(</span><span>2</span><span>,</span> <span>'lucy'</span><span>,</span> <span>'female'</span><span>)</span><span>;</span>
<span>INSERT</span> <span>INTO</span> <span>`</span>t_ua<span>`</span> <span>VALUES</span> <span>(</span><span>3</span><span>,</span> <span>'lily'</span><span>,</span> <span>'female'</span><span>)</span><span>;</span>
<span>INSERT</span> <span>INTO</span> <span>`</span>t_ua<span>`</span> <span>VALUES</span> <span>(</span><span>4</span><span>,</span> <span>'jack'</span><span>,</span> <span>'male'</span><span>)</span><span>;</span>
<span>INSERT</span> <span>INTO</span> <span>`</span>t_ua<span>`</span> <span>VALUES</span> <span>(</span><span>5</span><span>,</span> <span>'rose'</span><span>,</span> <span>'female'</span><span>)</span><span>;</span>

<span>SET</span> FOREIGN_KEY_CHECKS <span>=</span> <span>1</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br></div></div></li>
</ul>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <category term="数据库"/>
    <contributor>
      <name>南辞</name>
    </contributor>
    <published>2021-03-31T05:51:25.000Z</published>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">MySQL-TCL</title>
    <id>http://qiqi.dreamagain.top/software/database/SQL/MySQL/MySQL-TCL/</id>
    <link href="http://qiqi.dreamagain.top/software/database/SQL/MySQL/MySQL-TCL/"/>
    <updated>2021-03-31T05:51:25.000Z</updated>
    <summary type="html"><![CDATA[<blockquote>
<p><img src="https://img.shields.io/badge/TCL-Transaction_Control_Language-blue.svg" alt=""></p>
</blockquote>
]]></summary>
    <content type="html"><![CDATA[<blockquote>
<p><img src="https://img.shields.io/badge/TCL-Transaction_Control_Language-blue.svg" alt=""></p>
</blockquote>

<h2 style="color:#ab4642" align="center">TCL语言</h2>
<h2 id="一、什么是事务"> 一、什么是事务</h2>
<p>一个或一组sql语句组成一个执行单元，这个执行单元要么全部执行，要么全部不执行。</p>
<div><pre><code>案例：转账

张三丰  <span>1000</span>
郭襄	<span>1000</span>

<span>update</span> 表 <span>set</span> 张三丰的余额<span>=</span><span>500</span> <span>where</span> name<span>=</span><span>'张三丰'</span>
意外
<span>update</span> 表 <span>set</span> 郭襄的余额<span>=</span><span>1500</span> <span>where</span> name<span>=</span><span>'郭襄'</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h2 id="二、事务的特性-acid"> 二、事务的特性(ACID)</h2>
<ul>
<li>原子性：一个事务不可再分割，要么都执行要么都不执行</li>
<li>一致性：一个事务执行会使数据从一个一致状态切换到另外一个一致状态</li>
<li>隔离性：一个事务的执行不受其他事务的干扰</li>
<li>持久性：一个事务一旦提交，则会永久的改变数据库的数据.</li>
</ul>
<h2 id="三、事务的使用步骤-★"> 三、事务的使用步骤 ★</h2>
<ul>
<li>
<p>了解</p>
<p>（1）隐式（自动）事务：没有明显的开启和结束，本身就是一条事务可以自动提交，比如insert、update、delete</p>
<p>（2）显式事务：事务具有明显的开启和结束的标记；前提：必须先设置自动提交功能为禁用</p>
<p>​          具体步骤</p>
<div><pre><code>①开启事务
<span>set</span> autocommit<span>=</span><span>0</span><span>;</span>
<span>start</span> <span>transaction</span><span>;</span><span>#可以省略</span>

②编写一组逻辑<span>sql</span>语句
注意：<span>sql</span>语句支持的是<span>insert</span>、<span>update</span>、<span>delete</span>

设置回滚点：
<span>savepoint</span> 回滚点名<span>;</span>

③结束事务
提交：<span>commit</span><span>;</span>
回滚：<span>rollback</span><span>;</span>
回滚到指定的地方：<span>rollback</span> <span>to</span> 回滚点名<span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div></li>
<li>
<p>案例</p>
<div><pre><code>SHOW VARIABLES LIKE &#39;autocommit&#39;;
SHOW ENGINES;

#1.演示事务的使用步骤
DROP TABLE IF EXISTS account;
CREATE TABLE account(
	id INT PRIMARY KEY AUTO_INCREMENT,
	username VARCHAR(20),
	balance DOUBLE
);
INSERT INTO account(username,balance)
VALUES(&#39;张无忌&#39;,1000),(&#39;赵敏&#39;,1000);

#开启事务
SET autocommit=0;
START TRANSACTION;
#编写一组事务的语句
UPDATE account SET balance = 1000 WHERE username=&#39;张无忌&#39;;
UPDATE account SET balance = 1000 WHERE username=&#39;赵敏&#39;;

#结束事务
ROLLBACK;
#commit;

SELECT * FROM account;
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div></li>
</ul>
<h2 id="四、并发事务"> 四、并发事务</h2>
<p>1、<strong>事务的并发问题是如何发生的？</strong></p>
<ul>
<li>多个事务同时操作 同一个数据库的相同数据时</li>
</ul>
<p>2、<strong>并发问题都有哪些？</strong></p>
<ul>
<li>
<p>对于同时运行的多个事务, 当这些事务访问数据库中相同的数据时, 如果没有采取必要的隔离机制, 就会导致各种并发问题：</p>
</li>
<li>
<p>脏读：一个事务读取了其他事务还没有提交的数据，读到的是其他事务“更新”的数据；</p>
</li>
<li>
<p>不可重复读：一个事务多次读取，结果不一样；</p>
</li>
<li>
<p>幻读：一个事务读取了其他事务还没有提交的数据，只是读到的是 其他事务“插入”的数据。</p>
</li>
<li>
<p>数据库事务的隔离性: 数据库系统必须具有隔离并发运行各个事务的能力, 使它们不会相互影响, 避免各种并发问题.</p>
</li>
<li>
<p>一个事务与其他事务隔离的程度称为隔离级别. 数据库规定了多种事务隔离级别, 不同隔离级别对应不同的干扰程度, 隔离级别越高, 数据一致性就越好, 但并发性越弱</p>
</li>
<li>
<p>3、如何解决并发问题？</p>
<ul>
<li>通过设置隔离级别来解决并发问题</li>
</ul>
</li>
<li>
<p>4、隔离级别</p>
<div><pre><code>							脏读			不可重复读		  幻读
read uncommitted:读未提交     ×                ×              ×        
read committed：读已提交      √                ×              ×
repeatable read：可重复读     √                √              ×
serializable：串行化          √                √              √
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div></li>
<li>
<p>Oracle 支持的2 种事务隔离级别：READ COMMITED, SERIALIZABLE。Oracle 默认的事务隔离级别为: READ COMMITED</p>
</li>
<li>
<p>Mysql 支持4 种事务隔离级别. Mysql 默认的事务隔离级别为: REPEATABLE READ</p>
<div><pre><code>查看隔离级别
select @@tx_isolation;
设置隔离级别
set session|global transaction isolation level 隔离级别;

#2.演示事务对于delete和truncate的处理的区别
SET autocommit=0;
START TRANSACTION;

DELETE FROM account;
ROLLBACK;
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div></li>
</ul>
<h2 id="五、回滚点的演示"> 五、回滚点的演示</h2>
<ul>
<li>
<p>savepoint 节点名;设置保存点</p>
<div><pre><code>#3.演示savepoint 的使用
SET autocommit=0;

START TRANSACTION;
DELETE FROM account WHERE id=25;
SAVEPOINT a;#设置保存点
DELETE FROM account WHERE id=28;
ROLLBACK TO a;#回滚到保存点

SELECT * FROM account;
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div></li>
</ul>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <category term="数据库"/>
    <contributor>
      <name>南辞</name>
    </contributor>
    <published>2021-03-31T05:51:25.000Z</published>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">MySQL-Index</title>
    <id>http://qiqi.dreamagain.top/software/database/SQL/MySQL/MySQL-index/</id>
    <link href="http://qiqi.dreamagain.top/software/database/SQL/MySQL/MySQL-index/"/>
    <updated>2021-03-31T05:51:25.000Z</updated>
    <summary type="html"><![CDATA[<blockquote>
<p><img src="https://img.shields.io/badge/MySQL-%E7%B4%A2%E5%BC%95-blue.svg" alt=""></p>
</blockquote>
]]></summary>
    <content type="html"><![CDATA[<blockquote>
<p><img src="https://img.shields.io/badge/MySQL-%E7%B4%A2%E5%BC%95-blue.svg" alt=""></p>
</blockquote>

<h2 id="一、mysql索引实现"> 一、MySQL索引实现</h2>
<p>在学习索引之前先了解<a href="">B+树的实现原理</a>。</p>
<p>我们知道，MySQL内部索引是由不同的引擎实现的，主要包含InnoDB和MyISAM这两种，并且这两种引擎中的索引都是使用b+树的结构来存储的。</p>
<h3 id="一-innodb引擎中的索引"> （一）InnoDB引擎中的索引</h3>
<p>InnoDB中有2种索引：主键索引（也叫聚集索引）、辅助索引（也叫非聚集索引）。</p>
<p><strong>1、主键索引</strong>：每个表只有一个主键索引，b+树结构，叶子节点存储主键的值以及对应整条记录的数据，非叶子节点不存储记录的数据，只存储主键的值。</p>
<p>当表中未指定主键时，MySQL内部会自动给每条记录添加一个隐藏的rowid字段（默认4个字节）作为主键，用rowid构建聚集索引。聚集索引在MySQL中即主键索引。</p>
<p><strong>2、辅助索引</strong>：每个表可以有多个辅助索引，b+树结构，非聚集索引叶子节点存储字段（索引字段）的值以及对应记录主键的值，其他非叶子节点只存储字段的值（索引字段），这就是与聚集索引不同的地方。每个表可以有多个非聚集索引。</p>
<p>MySQL中非聚集索引进一步区分：</p>
<table>
<thead>
<tr>
<th>非聚集索引类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>单列索引</td>
<td>一个索引只包含一个列</td>
</tr>
<tr>
<td>多列索引（复合索引）</td>
<td>一个索引包含多个列</td>
</tr>
<tr>
<td>唯一索引</td>
<td>索引列的值必须唯一，允许有一个空值</td>
</tr>
</tbody>
</table>
<h3 id="二-myisam引擎中的索引"> （二）MyISAM引擎中的索引</h3>
<p>也是B+树结构，MyISM使用的是非聚簇索引，如下图，非聚簇索引的两棵B+树看上去没什么不同，节点的结构完全一致只是存储的内容不同而已：</p>
<ul>
<li>主键索引B+树的节点存储了主键，</li>
<li>辅助键索引B+树存储了辅助键。</li>
</ul>
<p>表数据存储在独立的地方，这两颗B+树的叶子节点都使用一个地址指向真正的表数据，对于表数据来说，这两个键没有任何差别。</p>
<p>由于索引树是独立的，通过辅助键检索无需访问主键的索引树。</p>
<p>下图更形象说明这两种索引的区别，这边假设了一个存储4行数据的表。Id为主键索引，Name作为辅助索引，图中清晰的体现了聚簇索引和非聚簇索引的差异。</p>
<p><img src="assets/6f5c3f7b8d8eddd178d89842ceff1f7b.jpg" alt="6f5c3f7b8d8eddd178d89842ceff1f7b"></p>
<p>我们来分析一下图中数据检索过程：</p>
<h3 id="三-innodb数据检索过程"> （三）InnoDB数据检索过程</h3>
<p>上面的表中有2个索引：id作为主键索引，name作为辅助索引。</p>
<p>如果需要查询id=14的数据，只需要在左边的主键索引中检索就可以了。</p>
<p>如果需要搜索name='Ellison'的数据，需要2步：</p>
<p>1、先在辅助索引中检索到name='Ellison'的数据，获取id为14</p>
<p>2、再到主键索引中检索id为14的记录</p>
<p>辅助索引这个查询过程在mysql中叫做==回表==，相对于主键索引多了第二步操作。</p>
<h3 id="四-myisam数据检索过程"> （四）MyISAM数据检索过程</h3>
<p>1、在索引中找到对应的关键字，获取关键字对应的记录的地址</p>
<p>2、通过记录的地址查找到对应的数据记录</p>
<p>对比发现：InnoDB中最好是采用主键查询，这样只需要一次索引，如果使用辅助索引检索，涉及多一步的回表操作，比主键查询要耗时一些。</p>
<h3 id="五-innodb中辅助索引区别于myisam的是"> （五）InnoDB中辅助索引区别于MyISAM的是 ⭐️</h3>
<p>表中的数据发生变更的时候，会影响其他记录地址的变化，如果辅助索引中记录数据的地址，此时会受影响，而主键的值一般是很少更新的，当页中的记录发生地址变更的时候，对辅助索引是没有影响的。</p>
<h2 id="二、索引管理和使用"> 二、索引管理和使用</h2>
<h3 id="一-数据准备"> （一）数据准备</h3>
<p>请参考第21篇（MySQL全面瓦解21（番外）：一次深夜优化亿级数据分页的奇妙经历）中模拟的千万数据，我们以这个数据为测试数据。</p>
<h3 id="二-创建索引"> （二）创建索引</h3>
<p><strong>create 方式：</strong></p>
<div><pre><code><span># 单值索引</span>
<span>create</span> <span>[</span><span>unique</span><span>]</span> <span>index</span> index_name <span>on</span> t_name<span>(</span>c_name<span>[</span><span>(</span>length<span>)</span><span>]</span><span>)</span><span>;</span> 
<span># 复合索引</span>
<span>create</span> <span>index</span> index_name <span>on</span> t_name<span>(</span>c_name1<span>[</span><span>(</span>length<span>)</span><span>]</span><span>,</span>c_name2<span>[</span><span>(</span>length<span>)</span><span>]</span><span>,</span><span>.</span><span>.</span><span>.</span><span>)</span><span>;</span> 
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p><strong>alter表 方式：</strong></p>
<div><pre><code><span># 单值索引</span>
<span>alter</span> <span>table</span> t_name <span>add</span> <span>[</span><span>unique</span><span>]</span> <span>index</span> index_name<span>(</span>c_name<span>[</span><span>(</span>length<span>)</span><span>]</span><span>)</span><span>;</span> 
<span># 复合索引</span>
<span>alter</span> <span>table</span> t_name <span>add</span> <span>index</span> index_name<span>(</span>c_name1<span>[</span><span>(</span>length<span>)</span><span>]</span><span>,</span>c_name2<span>[</span><span>(</span>length<span>)</span><span>]</span><span>,</span><span>.</span><span>.</span><span>.</span><span>)</span><span>;</span> 
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>这边需注意的是：</p>
<p>index_name 代表索引名称、t_name代表 表名称、c_name代表字段名称。</p>
<p>[] 中括号的内容是可以省略的，也就是说 unique 和 length 可以不写。如果加上了unique，表示创建唯一索引。</p>
<p>如果字段是char、varchar类型，length可以小于字段实际长度，如果是blog、text等长文本类型，必须指定length。</p>
<p>如果t_name后面只写一个字段，就是单列索引，如果需要写多个字段，可以使用逗号隔开，这种叫做复合索引。</p>
<h3 id="三-删除索引"> （三）删除索引</h3>
<div><pre><code><span>drop</span> <span>index</span> index_name <span>on</span> t_name<span>;</span>
</code></pre>
<div><span>1</span><br></div></div><h3 id="四-查看索引"> （四）查看索引</h3>
<div><pre><code><span>show</span> <span>index</span> <span>from</span> t_name<span>;</span> 
</code></pre>
<div><span>1</span><br></div></div><h3 id="五-索引修改"> （五）索引修改</h3>
<p>即先删除索引，再重建索引：drop +create。</p>
<h3 id="六-示例"> （六）示例</h3>
<p>emp表中有500W数据 我们用emp来做测试</p>
<div><pre><code> mysql<span>></span> <span>select</span> <span>count</span><span>(</span><span>*</span><span>)</span> <span>from</span> emp<span>;</span>
 <span>+</span><span>----------+</span>
 <span>|</span> <span>count</span><span>(</span><span>*</span><span>)</span> <span>|</span>
 <span>+</span><span>----------+</span>
 <span>|</span>  <span>5000000</span> <span>|</span>
 <span>+</span><span>----------+</span>
 <span>1</span> <span>row</span> <span>in</span> <span>set</span> 
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>查看和创建索引</p>
<p>记得我们之前在emp表上做过索引，所以先看一下这个表目前所有的索引</p>
<p>可以看到，目前主键字段id和depno字段上都有建立索引</p>
<div><pre><code> mysql<span>></span> <span>desc</span> emp<span>;</span>
 <span>+</span><span>----------+-----------------------+------+-----+---------+----------------+</span>
 <span>|</span> Field    <span>|</span> <span>Type</span>                  <span>|</span> <span>Null</span> <span>|</span> <span>Key</span> <span>|</span> <span>Default</span> <span>|</span> Extra          <span>|</span>
 <span>+</span><span>----------+-----------------------+------+-----+---------+----------------+</span>
 <span>|</span> id       <span>|</span> <span>int</span><span>(</span><span>10</span><span>)</span> <span>unsigned</span>      <span>|</span> <span>NO</span>   <span>|</span> PRI <span>|</span> <span>NULL</span>    <span>|</span> <span>auto_increment</span> <span>|</span>
 <span>|</span> empno    <span>|</span> <span>mediumint</span><span>(</span><span>8</span><span>)</span> <span>unsigned</span> <span>|</span> <span>NO</span>   <span>|</span>     <span>|</span> <span>0</span>       <span>|</span>                <span>|</span>
 <span>|</span> empname  <span>|</span> <span>varchar</span><span>(</span><span>20</span><span>)</span>           <span>|</span> <span>NO</span>   <span>|</span>     <span>|</span>         <span>|</span>                <span>|</span>
 <span>|</span> job      <span>|</span> <span>varchar</span><span>(</span><span>9</span><span>)</span>            <span>|</span> <span>NO</span>   <span>|</span>     <span>|</span>         <span>|</span>                <span>|</span>
 <span>|</span> mgr      <span>|</span> <span>mediumint</span><span>(</span><span>8</span><span>)</span> <span>unsigned</span> <span>|</span> <span>NO</span>   <span>|</span>     <span>|</span> <span>0</span>       <span>|</span>                <span>|</span>
 <span>|</span> hiredate <span>|</span> <span>datetime</span>              <span>|</span> <span>NO</span>   <span>|</span>     <span>|</span> <span>NULL</span>    <span>|</span>                <span>|</span>
 <span>|</span> sal      <span>|</span> <span>decimal</span><span>(</span><span>7</span><span>,</span><span>2</span><span>)</span>          <span>|</span> <span>NO</span>   <span>|</span>     <span>|</span> <span>NULL</span>    <span>|</span>                <span>|</span>
 <span>|</span> comn     <span>|</span> <span>decimal</span><span>(</span><span>7</span><span>,</span><span>2</span><span>)</span>          <span>|</span> <span>NO</span>   <span>|</span>     <span>|</span> <span>NULL</span>    <span>|</span>                <span>|</span>
 <span>|</span> depno    <span>|</span> <span>mediumint</span><span>(</span><span>8</span><span>)</span> <span>unsigned</span> <span>|</span> <span>NO</span>   <span>|</span> MUL <span>|</span> <span>0</span>       <span>|</span>                <span>|</span>
 <span>+</span><span>----------+-----------------------+------+-----+---------+----------------+</span>
 <span>9</span> <span>rows</span> <span>in</span> <span>set</span>
 
 mysql<span>></span> <span>show</span> <span>index</span> <span>from</span> emp<span>;</span>
 <span>+</span><span>-------+------------+---------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+</span>
 <span>|</span> <span>Table</span> <span>|</span> Non_unique <span>|</span> Key_name      <span>|</span> Seq_in_index <span>|</span> Column_name <span>|</span> Collation <span>|</span> Cardinality <span>|</span> Sub_part <span>|</span> Packed <span>|</span> <span>Null</span> <span>|</span> Index_type <span>|</span> <span>Comment</span> <span>|</span> Index_comment <span>|</span>
 <span>+</span><span>-------+------------+---------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+</span>
 <span>|</span> emp   <span>|</span>          <span>0</span> <span>|</span> <span>PRIMARY</span>       <span>|</span>            <span>1</span> <span>|</span> id          <span>|</span> A         <span>|</span>     <span>4952492</span> <span>|</span> <span>NULL</span>     <span>|</span> <span>NULL</span>   <span>|</span>      <span>|</span> <span>BTREE</span>      <span>|</span>         <span>|</span>               <span>|</span>
 <span>|</span> emp   <span>|</span>          <span>1</span> <span>|</span> idx_emp_id    <span>|</span>            <span>1</span> <span>|</span> id          <span>|</span> A         <span>|</span>     <span>4952492</span> <span>|</span> <span>NULL</span>     <span>|</span> <span>NULL</span>   <span>|</span>      <span>|</span> <span>BTREE</span>      <span>|</span>         <span>|</span>               <span>|</span>
 <span>|</span> emp   <span>|</span>          <span>1</span> <span>|</span> idx_emp_depno <span>|</span>            <span>1</span> <span>|</span> depno       <span>|</span> A         <span>|</span>          <span>18</span> <span>|</span> <span>NULL</span>     <span>|</span> <span>NULL</span>   <span>|</span>      <span>|</span> <span>BTREE</span>      <span>|</span>         <span>|</span>               <span>|</span>
 <span>+</span><span>-------+------------+---------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+</span>
 <span>3</span> <span>rows</span> <span>in</span> <span>set</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div><p>我们在没有做索引的字段上做一下查询看看，在500W数据中查询一个名叫LsHfFJA的员工，消耗 2.239S</p>
<p><img src="assets/3557625c81d7d637a3cd26b85751f6db.png" alt="MySQL全面剖析：MySQL索引实现和使用"></p>
<p>再看看他的执行过程，扫描了4952492 条数据才找到该行数据：</p>
<div><pre><code>mysql<span>></span> <span>explain</span> <span>select</span> <span>*</span> <span>from</span> emp <span>where</span> empname<span>=</span><span>'LsHfFJA'</span><span>;</span>
<span>+</span><span>----+-------------+-------+------+---------------+------+---------+------+---------+-------------+</span>
<span>|</span> id <span>|</span> select_type <span>|</span> <span>table</span> <span>|</span> <span>type</span> <span>|</span> possible_keys <span>|</span> <span>key</span>  <span>|</span> key_len <span>|</span> ref  <span>|</span> <span>rows</span>    <span>|</span> Extra       <span>|</span>
<span>+</span><span>----+-------------+-------+------+---------------+------+---------+------+---------+-------------+</span>
<span>|</span>  <span>1</span> <span>|</span> <span>SIMPLE</span>      <span>|</span> emp   <span>|</span> <span>ALL</span>  <span>|</span> <span>NULL</span>          <span>|</span> <span>NULL</span> <span>|</span> <span>NULL</span>    <span>|</span> <span>NULL</span> <span>|</span> <span>4952492</span> <span>|</span> <span>Using</span> <span>where</span> <span>|</span>
<span>+</span><span>----+-------------+-------+------+---------------+------+---------+------+---------+-------------+</span>
<span>1</span> <span>row</span> <span>in</span> <span>set</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>我们在empname这个字段上建立索引</p>
<div><pre><code>mysql<span>></span> <span>create</span> <span>index</span> idx_emp_empname <span>on</span> emp<span>(</span>empname<span>)</span><span>;</span> 
Query OK<span>,</span> <span>0</span> <span>rows</span> affected
Records: <span>0</span>  Duplicates: <span>0</span>  <span>Warnings</span>: <span>0</span>

mysql<span>></span> <span>show</span> <span>index</span> <span>from</span> emp<span>;</span>
<span>+</span><span>-------+------------+-----------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+</span>
<span>|</span> <span>Table</span> <span>|</span> Non_unique <span>|</span> Key_name        <span>|</span> Seq_in_index <span>|</span> Column_name <span>|</span> Collation <span>|</span> Cardinality <span>|</span> Sub_part <span>|</span> Packed <span>|</span> <span>Null</span> <span>|</span> Index_type <span>|</span> <span>Comment</span> <span>|</span> Index_comment <span>|</span>
<span>+</span><span>-------+------------+-----------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+</span>
<span>|</span> emp   <span>|</span>          <span>0</span> <span>|</span> <span>PRIMARY</span>         <span>|</span>            <span>1</span> <span>|</span> id          <span>|</span> A         <span>|</span>     <span>4952492</span> <span>|</span> <span>NULL</span>     <span>|</span> <span>NULL</span>   <span>|</span>      <span>|</span> <span>BTREE</span>      <span>|</span>         <span>|</span>               <span>|</span>
<span>|</span> emp   <span>|</span>          <span>1</span> <span>|</span> idx_emp_id      <span>|</span>            <span>1</span> <span>|</span> id          <span>|</span> A         <span>|</span>     <span>4952492</span> <span>|</span> <span>NULL</span>     <span>|</span> <span>NULL</span>   <span>|</span>      <span>|</span> <span>BTREE</span>      <span>|</span>         <span>|</span>               <span>|</span>
<span>|</span> emp   <span>|</span>          <span>1</span> <span>|</span> idx_emp_depno   <span>|</span>            <span>1</span> <span>|</span> depno       <span>|</span> A         <span>|</span>          <span>18</span> <span>|</span> <span>NULL</span>     <span>|</span> <span>NULL</span>   <span>|</span>      <span>|</span> <span>BTREE</span>      <span>|</span>         <span>|</span>               <span>|</span>
<span>|</span> emp   <span>|</span>          <span>1</span> <span>|</span> idx_emp_empname <span>|</span>            <span>1</span> <span>|</span> empname     <span>|</span> A         <span>|</span>     <span>1650830</span> <span>|</span> <span>NULL</span>     <span>|</span> <span>NULL</span>   <span>|</span>      <span>|</span> <span>BTREE</span>      <span>|</span>         <span>|</span>               <span>|</span>
<span>+</span><span>-------+------------+-----------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+</span>
<span>4</span> <span>rows</span> <span>in</span> <span>set</span> 
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>再看一下这个执行效率，就会发现有质的飞跃：0.001S，就是这么神奇，学过之前那篇的B+ Tree就知道，它不用从头开始扫表核对，而是很少次数的io读取</p>
<p><img src="assets/78a1065b5f021542fcf1e0f5191e4dcd.png" alt="MySQL全面剖析：MySQL索引实现和使用"></p>
<p>再看看他的执行过程，一次定位到该条数据：</p>
<div><pre><code>mysql<span>></span> <span>explain</span> <span>select</span> <span>*</span> <span>from</span> emp <span>where</span> empname<span>=</span><span>'LsHfFJA'</span><span>;</span>
<span>+</span><span>----+-------------+-------+------+-----------------+-----------------+---------+-------+------+-----------------------+</span>
<span>|</span> id <span>|</span> select_type <span>|</span> <span>table</span> <span>|</span> <span>type</span> <span>|</span> possible_keys   <span>|</span> <span>key</span>             <span>|</span> key_len <span>|</span> ref   <span>|</span> <span>rows</span> <span>|</span> Extra                 <span>|</span>
<span>+</span><span>----+-------------+-------+------+-----------------+-----------------+---------+-------+------+-----------------------+</span>
<span>|</span>  <span>1</span> <span>|</span> <span>SIMPLE</span>      <span>|</span> emp   <span>|</span> ref  <span>|</span> idx_emp_empname <span>|</span> idx_emp_empname <span>|</span> <span>22</span>      <span>|</span> const <span>|</span>    <span>1</span> <span>|</span> <span>Using</span> <span>index</span> condition <span>|</span>
<span>+</span><span>----+-------------+-------+------+-----------------+-----------------+---------+-------+------+-----------------------+</span>
<span>1</span> <span>row</span> <span>in</span> <span>set</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h3 id="七-设置合适的索引长度"> （七）设置合适的索引长度</h3>
<p>根据我们之前的了解，每个磁盘块（disk）存储的内容是有限的，如果一个页中可以存储的索引记录越多，那么查询效率就会提高，所以我们可以指定索引的字段长度。</p>
<p>但并不是越短越好，要保证字符类型字段查询有足够高的区分度，如果只设置了一个长度，反而导致查询的相似匹配度不高。</p>
<p>长度的原则是要恰到好处，太长索引文件就会变大，因此要在区分度和长度上做一个平衡。</p>
<p>如果在我们搜索的内容中，最后的内容是一致的或者高度一致的，那我们就可以省略，比如在用户的email字段上做索引，几乎前10个字符是不一样的，结尾限定在 <code>@****</code>，那么通过前面10个字符就可以定位一个email地址了。</p>
<p>我们在该字段创建索引的时候就可以指定长度为10，这样相对于整个email字段更短些，查询效果确却基本一样，这样一个页中也可以存储更多的索引记录。</p>
<p>像我们上面的那个 empname 字段，基本都是6位数的，只是小部分是超过6位数，而且后缀基本一致，所以6位数之后的区分度差不多。</p>
<p>有一个判断 高区分度以及合适长度索引 的通用算法，如下：</p>
<div><pre><code><span>1</span> <span>select</span> <span>count</span><span>(</span><span>distinct</span> <span>left</span><span>(</span><span>`</span>c_name<span>`</span><span>,</span>calcul_len<span>)</span><span>)</span><span>/</span><span>count</span><span>(</span><span>*</span><span>)</span> <span>from</span> t_name<span>;</span>
</code></pre>
<div><span>1</span><br></div></div><p>下面是对 empname 做的分析，匹配度越高搜索效率越高：</p>
<div><pre><code>mysql<span>></span> <span>select</span> <span>count</span><span>(</span><span>distinct</span> <span>left</span><span>(</span><span>`</span>empname<span>`</span><span>,</span><span>3</span><span>)</span><span>)</span><span>/</span><span>count</span><span>(</span><span>*</span><span>)</span> <span>from</span> emp<span>;</span>
<span>+</span><span>--------------------------------------------+</span>
<span>|</span> <span>count</span><span>(</span><span>distinct</span> <span>left</span><span>(</span><span>`</span>empname<span>`</span><span>,</span><span>3</span><span>)</span><span>)</span><span>/</span><span>count</span><span>(</span><span>*</span><span>)</span> <span>|</span>
<span>+</span><span>--------------------------------------------+</span>
<span>|</span> <span>0.0012</span>                                     <span>|</span>
<span>+</span><span>--------------------------------------------+</span>
<span>1</span> <span>row</span> <span>in</span> <span>set</span>

mysql<span>></span> <span>select</span> <span>count</span><span>(</span><span>distinct</span> <span>left</span><span>(</span><span>`</span>empname<span>`</span><span>,</span><span>4</span><span>)</span><span>)</span><span>/</span><span>count</span><span>(</span><span>*</span><span>)</span> <span>from</span> emp<span>;</span>
<span>+</span><span>--------------------------------------------+</span>
<span>|</span> <span>count</span><span>(</span><span>distinct</span> <span>left</span><span>(</span><span>`</span>empname<span>`</span><span>,</span><span>4</span><span>)</span><span>)</span><span>/</span><span>count</span><span>(</span><span>*</span><span>)</span> <span>|</span>
<span>+</span><span>--------------------------------------------+</span>
<span>|</span> <span>0.0076</span>                                     <span>|</span>
<span>+</span><span>--------------------------------------------+</span>
<span>1</span> <span>row</span> <span>in</span> <span>set</span>

mysql<span>></span> <span>select</span> <span>count</span><span>(</span><span>distinct</span> <span>left</span><span>(</span><span>`</span>empname<span>`</span><span>,</span><span>6</span><span>)</span><span>)</span><span>/</span><span>count</span><span>(</span><span>*</span><span>)</span> <span>from</span> emp<span>;</span>
<span>+</span><span>--------------------------------------------+</span>
<span>|</span> <span>count</span><span>(</span><span>distinct</span> <span>left</span><span>(</span><span>`</span>empname<span>`</span><span>,</span><span>6</span><span>)</span><span>)</span><span>/</span><span>count</span><span>(</span><span>*</span><span>)</span> <span>|</span>
<span>+</span><span>--------------------------------------------+</span>
<span>|</span> <span>0.1713</span>                                     <span>|</span>
<span>+</span><span>--------------------------------------------+</span>
<span>1</span> <span>row</span> <span>in</span> <span>set</span>

mysql<span>></span> <span>select</span> <span>count</span><span>(</span><span>distinct</span> <span>left</span><span>(</span><span>`</span>empname<span>`</span><span>,</span><span>7</span><span>)</span><span>)</span><span>/</span><span>count</span><span>(</span><span>*</span><span>)</span> <span>from</span> emp<span>;</span>
<span>+</span><span>--------------------------------------------+</span>
<span>|</span> <span>count</span><span>(</span><span>distinct</span> <span>left</span><span>(</span><span>`</span>empname<span>`</span><span>,</span><span>7</span><span>)</span><span>)</span><span>/</span><span>count</span><span>(</span><span>*</span><span>)</span> <span>|</span>
<span>+</span><span>--------------------------------------------+</span>
<span>|</span> <span>0.1713</span>                                     <span>|</span>
<span>+</span><span>--------------------------------------------+</span>
<span>1</span> <span>row</span> <span>in</span> <span>set</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br></div></div>]]></content>
    <author>
      <name>南辞</name>
    </author>
    <category term="数据库"/>
    <contributor>
      <name>南辞</name>
    </contributor>
    <published>2021-03-31T05:51:25.000Z</published>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">MySQL-intro</title>
    <id>http://qiqi.dreamagain.top/software/database/SQL/MySQL/MySQL-intro/</id>
    <link href="http://qiqi.dreamagain.top/software/database/SQL/MySQL/MySQL-intro/"/>
    <updated>2021-03-31T05:51:25.000Z</updated>
    <summary type="html"><![CDATA[<blockquote>
<p>​	<img src="https://img.shields.io/badge/MySQL-%E7%AE%80%E4%BB%8B-blue.svg" alt=""></p>
</blockquote>
]]></summary>
    <content type="html"><![CDATA[<blockquote>
<p>​	<img src="https://img.shields.io/badge/MySQL-%E7%AE%80%E4%BB%8B-blue.svg" alt=""></p>
</blockquote>

<h2 id="一、概述"> 一、概述</h2>
<h3 id="一-为什么学习数据库"> （一）为什么学习数据库？</h3>
<ul>
<li>实现数据持久化</li>
<li>使用完整的管理系统统一管理，易于查询</li>
</ul>
<h3 id="二-数据库的相关概念"> （二）数据库的相关概念</h3>
<ul>
<li>DB：数据库（database）：存储数据的“仓库”。它保存了一系列有组织的数据。</li>
<li>DBMS
<ul>
<li>数据库管理系统（Database Management System）。数据库是通过DBMS创建和操作的容器</li>
<li>常见的数据库管理系统：MySQL、Oracle、DB2、SqlServer等。</li>
</ul>
</li>
<li>SQL
<ul>
<li>结构化查询语言（Structure Query Language）：专门用来与数据库通信的语言。</li>
<li>SQL的优点：①简单易学；②不是某个特定数据库供应商专有的语言，几乎所有DBMS都支持SQL；③虽然简单，但实际上是一种强有力的语言，灵活使用其语言元素，可以进行非常复杂和高级的数据库操作。</li>
</ul>
</li>
<li>DBA、DBS、DBMS、SQL、DB之间的关系</li>
</ul>
<p><img src="https://gitee.com/small-universe/blog_data/raw/images/%20database/MySQL/%E5%85%B3%E7%B3%BB.jpg" alt="关系"></p>
<h3 id="三-数据库存储数据的特点"> （三）数据库存储数据的特点</h3>
<ul>
<li>1、将数据放到表中，表再放到库中</li>
<li>2、一个数据库中可以有多个表，每个表都有一个的名字，用来标识自己。表名具有唯一性。</li>
<li>3、表具有一些特性，这些特性定义了数据在表中如何存储，类似java中 “类”的设计。</li>
<li>4、表由列组成，我们也称为字段。所有表都是由一个或多个列组成的，每一列类似java 中的”属性”。</li>
<li>5、表中的数据是按行存储的，每一行类似于java中的“对象”。</li>
</ul>
<h3 id="四-mysql软件"> （四）MySQL软件</h3>
<ul>
<li>
<p><strong>介绍</strong></p>
<ul>
<li>
<p>MySQL数据库原属于MySQLAB公司，总部位于瑞典，后被Oracle收购。</p>
</li>
<li>
<p>优点：</p>
<p>①成本低：开放源代码，免费，可定制；</p>
<p>②简单：很容易安装和使用；</p>
<p>③性能高：轻巧、执行sql很快。</p>
</li>
</ul>
</li>
<li>
<p><strong>安装</strong></p>
<ul>
<li>
<p>DBMS分为两类：</p>
<p>①基于共享文件系统的DBMS （Access）；</p>
<p>②基于客户机——服务器的DBMS（MySQL、Oracle、SqlServer）。</p>
</li>
<li>
<p>版本可分为：社区版（免费），企业版（收费）。</p>
</li>
<li>
<p>Windows平台下下载社区版：http://dev.mysql.com/downloads/mysql</p>
</li>
<li>
<p>下载后解压缩文件到指定文件夹并配置环境变量即可</p>
<p>eg:  变量名<code>MySQL_HOME</code> 路径<code>D:\dev_softs\mysql-8.0.20-winx64</code></p>
</li>
</ul>
</li>
<li>
<p><strong>启动和停止MySQL服务</strong></p>
<ul>
<li>
<p>方式一：右击此电脑—管理—服务—启动或停止MySQL服务</p>
</li>
<li>
<p>方式二：DOS窗口中使用如下命令</p>
<div><pre><code>启动：net start 服务名
停止：net stop 服务名
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div></li>
</ul>
</li>
<li>
<p><strong>MySQL服务端的登录和退出</strong></p>
<div><pre><code>登录
mysql 【–h 主机名 <span>-</span>P 端口号】 –u 用户名 –p密码
例：mysql <span>-</span>h localhost <span>-</span>u root <span>-</span>proot

退出
<span>exit</span>或ctrl<span>+</span>C
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div></li>
<li>
<p><strong>MySQL常见命令介绍</strong></p>
<div><pre><code>进入mysql<span>,</span> 在命令行中输入
mysql–uroot–p<span>####  (其中：####表示密码）</span>
例：mysql <span>-</span>uroot <span>-</span>proot

查看mysql中有哪些个数据库
<span>show</span> <span>databases</span><span>;</span>

新建一个数据库
<span>create</span> <span>database</span> 数据库名<span>;</span>
例：<span>create</span> <span>database</span> book<span>;</span>

选择一个数据库
<span>use</span> 数据库名称<span>;</span>
例：<span>use</span> test<span>;</span>

查询数据表
<span>show</span> <span>tables</span><span>;</span>

查看指定的数据库中有哪些数据表
<span>show</span> <span>tables</span> <span>from</span> 数据库名<span>;</span>
例：<span>show</span> <span>tables</span> <span>from</span> mysql<span>;</span>

查询当前所在数据库
<span>select</span> <span>database</span><span>(</span><span>)</span><span>;</span>

新建一个数据表
<span>create</span> <span>table</span> math<span>(</span>
    id <span>int</span><span>,</span>
    name <span>varchar</span><span>(</span><span>20</span><span>)</span>
<span>)</span><span>;</span>

查看表的结构
<span>desc</span> 表名<span>;</span>
例：<span>desc</span> math<span>;</span>

查看表中的所有记录
<span>select</span> <span>*</span> <span>from</span> 表名<span>;</span>
例： <span>select</span> <span>*</span> <span>from</span> math<span>;</span>

向表中插入记录
<span>insert</span> <span>into</span> 表名<span>(</span>列名列表<span>)</span> <span>values</span><span>(</span>列对应的值的列表<span>)</span><span>;</span>
注意：插入<span>varchar</span>或<span>date</span> 型的数据要用单引号或双引号引起来
例：<span>insert</span> <span>into</span> math <span>(</span>id<span>,</span>name<span>)</span> <span>values</span><span>(</span><span>1</span><span>,</span><span>'ton'</span><span>)</span><span>;</span>

修改记录
<span>update</span> 表名<span>set</span> 列<span>1</span> <span>=</span> 列<span>1</span>的值<span>,</span> 列<span>2</span> <span>=</span> 列<span>2</span>的值<span>where</span> <span>.</span><span>.</span>
例：<span>update</span> math <span>set</span> name<span>=</span><span>"wugang"</span> <span>where</span> id<span>=</span><span>1</span><span>;</span>

删除记录
<span>delete</span> <span>from</span> 表名 <span>where</span> <span>.</span><span>.</span><span>.</span>
例：<span>delete</span> <span>from</span> math <span>where</span> id<span>=</span><span>1</span><span>;</span>

删除数据表
<span>drop</span> <span>table</span> 表名<span>;</span>
例：<span>drop</span> <span>table</span> math<span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br></div></div></li>
<li>
<p><strong>查看MySQL服务端版本</strong></p>
<div><pre><code>登录到mysql服务端
<span>SELECT</span> VERSION<span>(</span><span>)</span> <span>AS</span> <span>'MySQL版本'</span><span>;</span>

没有登录到mysql服务端
在cmd命令界面输入：mysql <span>--version</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div></li>
<li>
<p><strong>MySQL的语法规范</strong></p>
<ul>
<li>不区分大小写,但建议关键字大写，表名、列名小写</li>
<li>每句话用;或\g、\G结尾，最好用分号结尾</li>
<li>每条命令根据需要，可以进行缩进或换行</li>
<li>注释：①单行注释：#注释文字；②单行注释：-- 注释文字；③多行注释：/* 注释文字 */</li>
</ul>
</li>
<li>
<p><strong>图形化用户界面客户端</strong></p>
<ul>
<li>
<p>介绍：主要分为两种——SQLyog 12、Navicat 12 for mysql</p>
</li>
<li>
<p>安装：傻瓜式安装</p>
</li>
<li>
<p>卸载：方法一：控制面板选中SQLyog直接卸载；方法二：卸载时担心注册表清除不干净,百度geek下载工具，下载免费版即可。下载后，放到桌面，双击后可直接选中要卸载的软件进行卸载,最后可根据选择是否清除注册表。</p>
</li>
<li>
<p>注意：<code>SQLyog连接数据库报错</code>plugin caching_sha2_password could not be loaded，解决方法如下</p>
<div><pre><code>打开cmd：mysql -uroot -p 
进入mysql依次执行下面语句
ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;password&#39; PASSWORD EXPIRE NEVER; #修改加密规则 
ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED WITH mysql_native_password BY &#39;password&#39;; #更新一下用户的密码 

FLUSH PRIVILEGES; #刷新权限
alter user &#39;root&#39;@&#39;localhost&#39; identified by &#39;xzx123456&#39;;#重置密码，xzx123456就是变更后的密码，自己的密码自己更改下哦
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div></li>
</ul>
<div><p>提示</p>
<p>MySQL8.0+的驱动需要设置时区，如:</p>
<div><pre><code>jdbc<span>:</span>mysql<span>:</span>//localhost<span>:</span>3306/myemployees<span>?</span>serverTimezone=Asia/Shanghai<span>&amp;useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=true</span>
</code></pre>
<div><span>1</span><br></div></div></div>
</li>
</ul>
<h2 id="二、sql语言的分类"> 二、SQL语言的分类</h2>
<div><p>相关信息</p>
<p>对于这个，网上有三种、四种、五种、六种很多，但综合来说，是5种！！</p>
<p>因为大部分用到的是DQL和DML，偶尔会用到DDL，一般的开发人员很少会用到DCL</p>
</div>
<ul>
<li>DQL（Data Query Language）：数据查询语言，用于检索数据库中的数据，主要是SELECT语句；</li>
<li>DML（Data Manipulation Language)：数据操纵语言，用于改变数据库中的数据，主要包括INSERT、UPDATE和DELETE语句；</li>
<li>DDL（Data Definition Language)：数据定义语言，用于库和表的创建、修改、删除。主要包括CREATE、DROP、ALTER语句；</li>
<li>DCL（Data Control Language)：数据控制语言，用于定义用户的访问权限和安全级别。主要包括GRANT和REVOKE语句；</li>
<li>TCL（Transaction Control Language)：事务控制语言，用于维护数据的一致性，包括COMMIT、ROLLBACK和SAVEPOINT语句。</li>
</ul>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <category term="数据库"/>
    <contributor>
      <name>南辞</name>
    </contributor>
    <published>2021-03-31T05:51:25.000Z</published>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">MySQL-other</title>
    <id>http://qiqi.dreamagain.top/software/database/SQL/MySQL/MySQL-other/</id>
    <link href="http://qiqi.dreamagain.top/software/database/SQL/MySQL/MySQL-other/"/>
    <updated>2021-03-31T05:51:25.000Z</updated>
    <summary type="html"><![CDATA[<blockquote>
<p><img src="https://img.shields.io/badge/MySQL%E5%9F%BA%E7%A1%80-%E5%85%B6%E4%BB%96-blue.svg" alt=""></p>
</blockquote>
]]></summary>
    <content type="html"><![CDATA[<blockquote>
<p><img src="https://img.shields.io/badge/MySQL%E5%9F%BA%E7%A1%80-%E5%85%B6%E4%BB%96-blue.svg" alt=""></p>
</blockquote>

<h2 style="color:#ab4642" align="center">MySQL基础-其他</h2>
<ol>
<li>视图</li>
<li>变量</li>
<li>存储过程和函数</li>
</ol>
<h2 id="一、视图"> 一、视图</h2>
<h3 id="一-什么是视图"> （一）什么是视图</h3>
<ul>
<li>
<p><strong>视图</strong>：虚拟表,和普通表一样使用。mysql5.1版本出现的新特性，是通过表动态生成的数据。</p>
<p>​			创建视图可以类比Java中创建一个方法</p>
</li>
<li>
<p><strong>应用场景</strong></p>
<p>（1）多个地方用到同样的查询结果</p>
<p>（2）该查询结果使用的sql语句较复杂</p>
</li>
<li>
<p><strong>案例</strong></p>
<div><pre><code><span>SELECT</span> stuname<span>,</span>majorname <span>FROM</span> stuinfo s
<span>INNER</span> <span>JOIN</span> major m <span>ON</span> s<span>.</span><span>`</span>majorid<span>`</span><span>=</span> m<span>.</span><span>`</span>id<span>`</span>
<span>WHERE</span> s<span>.</span><span>`</span>stuname<span>`</span> <span>LIKE</span> <span>'张%'</span><span>;</span>

<span>CREATE</span> <span>VIEW</span> v1 <span>AS</span>
<span>SELECT</span> stuname<span>,</span>majorname
<span>FROM</span> stuinfo s
<span>INNER</span> <span>JOIN</span> major m <span>ON</span> s<span>.</span><span>`</span>majorid<span>`</span><span>=</span> m<span>.</span><span>`</span>id<span>`</span><span>;</span>

<span>SELECT</span> <span>*</span> <span>FROM</span> v1 <span>WHERE</span> stuname <span>LIKE</span> <span>'张%'</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div></li>
</ul>
<h3 id="二-视图的创建"> （二）视图的创建</h3>
<ul>
<li>
<p><strong>语法</strong>：create view 视图名 as 查询语句;</p>
</li>
<li>
<p><strong>案例</strong></p>
<div><pre><code><span>USE</span> myemployees<span>;</span>

<span>#1.查询姓名中包含a字符的员工名、部门名和工种信息</span>
    <span>#①创建</span>
    <span>CREATE</span> <span>VIEW</span> myv1 <span>AS</span>
    <span>SELECT</span> last_name<span>,</span>department_name<span>,</span>job_title
    <span>FROM</span> employees e
    <span>JOIN</span> departments d <span>ON</span> e<span>.</span>department_id  <span>=</span> d<span>.</span>department_id
    <span>JOIN</span> jobs j <span>ON</span> j<span>.</span>job_id  <span>=</span> e<span>.</span>job_id<span>;</span>

    <span>#②使用</span>
    <span>SELECT</span> <span>*</span> <span>FROM</span> myv1 <span>WHERE</span> last_name <span>LIKE</span> <span>'%a%'</span><span>;</span>

<span>#2.查询各部门的平均工资级别</span>
    <span>#①创建视图查看每个部门的平均工资</span>
    <span>CREATE</span> <span>VIEW</span> myv2 <span>AS</span>
    <span>SELECT</span> <span>AVG</span><span>(</span>salary<span>)</span> ag<span>,</span>department_id
    <span>FROM</span> employees <span>GROUP</span> <span>BY</span> department_id<span>;</span>

    <span>#②使用</span>
    <span>SELECT</span> myv2<span>.</span><span>`</span>ag<span>`</span><span>,</span>g<span>.</span>grade_level <span>FROM</span> myv2
    <span>JOIN</span> job_grades g
    <span>ON</span> myv2<span>.</span><span>`</span>ag<span>`</span> <span>BETWEEN</span> g<span>.</span><span>`</span>lowest_sal<span>`</span> <span>AND</span> g<span>.</span><span>`</span>highest_sal<span>`</span><span>;</span>

<span>#3.查询平均工资最低的部门信息</span>
<span>SELECT</span> <span>*</span> <span>FROM</span> myv2 <span>ORDER</span> <span>BY</span> ag <span>LIMIT</span> <span>1</span><span>;</span>

<span>#4.查询平均工资最低的部门名和工资</span>
    <span>CREATE</span> <span>VIEW</span> myv3 <span>AS</span>
    <span>SELECT</span> <span>*</span> <span>FROM</span> myv2 <span>ORDER</span> <span>BY</span> ag <span>LIMIT</span> <span>1</span><span>;</span>

    <span>SELECT</span> d<span>.</span><span>*</span><span>,</span>m<span>.</span>ag <span>FROM</span> myv3 m
    <span>JOIN</span> departments d
    <span>ON</span> m<span>.</span><span>`</span>department_id<span>`</span><span>=</span>d<span>.</span><span>`</span>department_id<span>`</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br></div></div></li>
<li>
<p><strong>视图的好处</strong></p>
<p>（1）重用sql语句</p>
<p>（2）简化复杂的sql操作，不必知道它的查询细节</p>
<p>（3）保护数据，提高安全性</p>
</li>
</ul>
<h3 id="三-视图的修改"> （三）视图的修改</h3>
<ul>
<li>
<p>语法</p>
<div><pre><code>方式一：
<span>create</span> <span>or</span> <span>replace</span> <span>view</span> 视图名 <span>as</span> 查询语句<span>;</span>
方式二：
<span>alter</span> <span>view</span> 视图名 <span>as</span> 查询语句<span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div></li>
<li>
<p>案例</p>
<div><pre><code><span>#方式一：</span>
<span>/*
create or replace view  视图名 as 查询语句;
*/</span>
<span>SELECT</span> <span>*</span> <span>FROM</span> myv3 

<span>CREATE</span> <span>OR</span> <span>REPLACE</span> <span>VIEW</span> myv3 <span>AS</span>
<span>SELECT</span> <span>AVG</span><span>(</span>salary<span>)</span><span>,</span>job_id
<span>FROM</span> employees <span>GROUP</span> <span>BY</span> job_id<span>;</span>

<span>#方式二：</span>
<span>/*
语法：
alter view 视图名 as 查询语句;
*/</span>
<span>ALTER</span> <span>VIEW</span> myv3 <span>AS</span> <span>SELECT</span> <span>*</span> <span>FROM</span> employees<span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div></li>
</ul>
<h3 id="四-视图的删除"> （四）视图的删除</h3>
<p>用户可以一次删除一个或者多个视图，前提是必须有该视图的drop权限。</p>
<ul>
<li>
<p><strong>语法</strong>：drop view 视图1，视图2,…;</p>
</li>
<li>
<p><strong>案例</strong></p>
<div><pre><code><span>/*
语法：drop view 视图名,视图名,...;
*/</span>
<span>DROP</span> <span>VIEW</span> emp_v1<span>,</span>emp_v2<span>,</span>myv3<span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div></li>
</ul>
<h3 id="五-视图的查看"> （五）视图的查看</h3>
<ul>
<li>
<p><strong>语法</strong></p>
<div><pre><code><span>desc</span> 视图名<span>;</span>
<span>show</span> <span>create</span> <span>view</span> 视图名<span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div></li>
<li>
<p><strong>案例</strong></p>
<div><pre><code><span>DESC</span> myv3<span>;</span>
<span>SHOW</span> <span>CREATE</span> <span>VIEW</span> myv3<span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div></li>
</ul>
<h3 id="六-视图的更新"> （六）视图的更新</h3>
<ul>
<li>
<p><strong>插入</strong>：insert</p>
</li>
<li>
<p><strong>修改</strong>：update</p>
</li>
<li>
<p><strong>删除</strong>：delete</p>
</li>
<li>
<p><strong>查看</strong>：select</p>
<div><pre><code><span>CREATE</span> <span>OR</span> <span>REPLACE</span> <span>VIEW</span> myv1
<span>AS</span>
<span>SELECT</span> last_name<span>,</span>email<span>,</span>salary<span>*</span><span>12</span><span>*</span><span>(</span><span>1</span><span>+</span>IFNULL<span>(</span>commission_pct<span>,</span><span>0</span><span>)</span><span>)</span> <span>"annual salary"</span>
<span>FROM</span> employees<span>;</span>

<span>CREATE</span> <span>OR</span> <span>REPLACE</span> <span>VIEW</span> myv1
<span>AS</span>
<span>SELECT</span> last_name<span>,</span>email
<span>FROM</span> employees<span>;</span>

<span>SELECT</span> <span>*</span> <span>FROM</span> myv1<span>;</span>
<span>SELECT</span> <span>*</span> <span>FROM</span> employees<span>;</span>
<span>#1.插入</span>

<span>INSERT</span> <span>INTO</span> myv1 <span>VALUES</span><span>(</span><span>'张飞'</span><span>,</span><span>'zf@qq.com'</span><span>)</span><span>;</span>

<span>#2.修改</span>
<span>UPDATE</span> myv1 <span>SET</span> last_name <span>=</span> <span>'张无忌'</span> <span>WHERE</span> last_name<span>=</span><span>'张飞'</span><span>;</span>

<span>#3.删除</span>
<span>DELETE</span> <span>FROM</span> myv1 <span>WHERE</span> last_name <span>=</span> <span>'张无忌'</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div></li>
<li>
<p><strong>注意</strong>：视图一般用于查询的，而不是更新的，所以具备以下特点的视图都不允许更新</p>
<p>（1）包含以下关键字的sql语句：分组函数、distinct、group by、having、union或者union all</p>
<p>（2）常量视图</p>
<p>（3）select中包含子查询</p>
<p>（4）join</p>
<p>（5）from一个不能更新的视图</p>
<p>（6）where子句的子查询引用了from子句中的表</p>
<div><pre><code><span>#具备以下特点的视图不允许更新</span>
<span>#①包含以下关键字的sql语句：分组函数、distinct、group  by、having、union或者union all</span>
<span>CREATE</span> <span>OR</span> <span>REPLACE</span> <span>VIEW</span> myv1
<span>AS</span>
<span>SELECT</span> <span>MAX</span><span>(</span>salary<span>)</span> m<span>,</span>department_id
<span>FROM</span> employees
<span>GROUP</span> <span>BY</span> department_id<span>;</span>

<span>SELECT</span> <span>*</span> <span>FROM</span> myv1<span>;</span>

<span>#更新</span>
<span>UPDATE</span> myv1 <span>SET</span> m<span>=</span><span>9000</span> <span>WHERE</span> department_id<span>=</span><span>10</span><span>;</span>

<span>#②常量视图</span>
<span>CREATE</span> <span>OR</span> <span>REPLACE</span> <span>VIEW</span> myv2
<span>AS</span>
<span>SELECT</span> <span>'john'</span> NAME<span>;</span>

<span>SELECT</span> <span>*</span> <span>FROM</span> myv2<span>;</span>

<span>#更新</span>
<span>UPDATE</span> myv2 <span>SET</span> NAME<span>=</span><span>'lucy'</span><span>;</span>

<span>#③Select中包含子查询</span>

<span>CREATE</span> <span>OR</span> <span>REPLACE</span> <span>VIEW</span> myv3
<span>AS</span>
<span>SELECT</span> department_id<span>,</span><span>(</span><span>SELECT</span> <span>MAX</span><span>(</span>salary<span>)</span> <span>FROM</span> employees<span>)</span> 最高工资
<span>FROM</span> departments<span>;</span>

<span>#更新</span>
<span>SELECT</span> <span>*</span> <span>FROM</span> myv3<span>;</span>
<span>UPDATE</span> myv3 <span>SET</span> 最高工资<span>=</span><span>100000</span><span>;</span>

<span>#④join</span>
<span>CREATE</span> <span>OR</span> <span>REPLACE</span> <span>VIEW</span> myv4
<span>AS</span>
<span>SELECT</span> last_name<span>,</span>department_name
<span>FROM</span> employees e
<span>JOIN</span> departments d
<span>ON</span> e<span>.</span>department_id  <span>=</span> d<span>.</span>department_id<span>;</span>

<span>#更新</span>
<span>SELECT</span> <span>*</span> <span>FROM</span> myv4<span>;</span>
<span>UPDATE</span> myv4 <span>SET</span> last_name  <span>=</span> <span>'张飞'</span> <span>WHERE</span> last_name<span>=</span><span>'Whalen'</span><span>;</span>
<span>INSERT</span> <span>INTO</span> myv4 <span>VALUES</span><span>(</span><span>'陈真'</span><span>,</span><span>'xxxx'</span><span>)</span><span>;</span>

<span>#⑤from一个不能更新的视图</span>
<span>CREATE</span> <span>OR</span> <span>REPLACE</span> <span>VIEW</span> myv5
<span>AS</span> <span>SELECT</span> <span>*</span> <span>FROM</span> myv3<span>;</span>

<span>#更新</span>
<span>SELECT</span> <span>*</span> <span>FROM</span> myv5<span>;</span>
<span>UPDATE</span> myv5 <span>SET</span> 最高工资<span>=</span><span>10000</span> <span>WHERE</span> department_id<span>=</span><span>60</span><span>;</span>

<span>#⑥where子句的子查询引用了from子句中的表</span>

<span>CREATE</span> <span>OR</span> <span>REPLACE</span> <span>VIEW</span> myv6
<span>AS</span>
<span>SELECT</span> last_name<span>,</span>email<span>,</span>salary
<span>FROM</span> employees
<span>WHERE</span> employee_id <span>IN</span><span>(</span>
	<span>SELECT</span>  manager_id
	<span>FROM</span> employees
	<span>WHERE</span> manager_id <span>IS</span> <span>NOT</span> <span>NULL</span>
<span>)</span><span>;</span>

<span>#更新</span>
<span>SELECT</span> <span>*</span> <span>FROM</span> myv6<span>;</span>
<span>UPDATE</span> myv6 <span>SET</span> salary<span>=</span><span>10000</span> <span>WHERE</span> last_name <span>=</span> <span>'k_ing'</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br></div></div></li>
</ul>
<h3 id="七-视图和表的对比"> （七）视图和表的对比</h3>
<div><pre><code>	    关键字		  是否占用物理空间			 使用
视图	  view	    占用较小，只保存sql逻辑	 一般用于查询
表	   table		保存实际的数据			  增删改查
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id="二、变量"> 二、变量</h2>
<h3 id="一-变量的介绍"> （一）变量的介绍</h3>
<ul>
<li>
<p>系统变量：</p>
<p>（1）全局变量</p>
<p>（2）会话变量</p>
</li>
<li>
<p>自定义变量：</p>
<p>（3）用户变量</p>
<p>（4）局部变量</p>
</li>
</ul>
<h3 id="二-系统变量的介绍和语法"> （二）系统变量的介绍和语法</h3>
<ul>
<li>
<p><strong>说明</strong>：变量由系统定义，不是用户定义，属于服务器层面</p>
</li>
<li>
<p><strong>注意</strong>：全局变量需要添加global关键字，会话变量需要添加session关键字，如果不写，默认会话级别</p>
</li>
<li>
<p><strong>使用步骤</strong>：</p>
<p>（1）查看所有系统变量</p>
<div><pre><code><span>show</span> <span>global</span><span>|</span>【<span>session</span>】variables<span>;</span>
</code></pre>
<div><span>1</span><br></div></div><p>（2）查看满足条件的部分系统变量</p>
<div><pre><code><span>show</span> <span>global</span><span>|</span>【<span>session</span>】 variables <span>like</span> <span>'%char%'</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div><p>（3）查看指定的系统变量的值</p>
<div><pre><code><span>select</span> @<span>@global</span><span>|</span>【<span>session</span>】系统变量名<span>;</span>
</code></pre>
<div><span>1</span><br></div></div><p>（4）为某个系统变量赋值</p>
<div><pre><code>方式一：
<span>set</span> <span>global</span><span>|</span>【<span>session</span>】系统变量名<span>=</span>值<span>;</span>
方式二：
<span>set</span> @<span>@global</span><span>|</span>【<span>session</span>】系统变量名<span>=</span>值<span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div></li>
</ul>
<h3 id="三-全局变量的演示"> （三）全局变量的演示</h3>
<div><pre><code><span>#1》全局变量</span>
<span>/*
作用域：针对于所有会话（连接）有效，但不能跨重启
*/</span>
<span>#①查看所有全局变量</span>
<span>SHOW</span> <span>GLOBAL</span> VARIABLES<span>;</span>
<span>#②查看满足条件的部分系统变量</span>
<span>SHOW</span> <span>GLOBAL</span> VARIABLES <span>LIKE</span> <span>'%char%'</span><span>;</span>
<span>#③查看指定的系统变量的值</span>
<span>SELECT</span> @<span>@global.autocommit</span><span>;</span>
<span>#④为某个系统变量赋值</span>
<span>SET</span> @<span>@global.autocommit</span><span>=</span><span>0</span><span>;</span>
<span>SET</span> <span>GLOBAL</span> autocommit<span>=</span><span>0</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h3 id="四-会话变量的演示"> （四）会话变量的演示</h3>
<div><pre><code><span>#2》会话变量</span>
<span>/*
作用域：针对于当前会话（连接）有效
*/</span>
<span>#①查看所有会话变量</span>
<span>SHOW</span> <span>SESSION</span> VARIABLES<span>;</span>
<span>#②查看满足条件的部分会话变量</span>
<span>SHOW</span> <span>SESSION</span> VARIABLES <span>LIKE</span> <span>'%char%'</span><span>;</span>
<span>#③查看指定的会话变量的值</span>
<span>SELECT</span> @<span>@autocommit</span><span>;</span>
<span>SELECT</span> @<span>@session.tx_isolation</span><span>;</span>
<span>#④为某个会话变量赋值</span>
<span>SET</span> @<span>@session.tx_isolation</span><span>=</span><span>'read-uncommitted'</span><span>;</span>
<span>SET</span> <span>SESSION</span> tx_isolation<span>=</span><span>'read-committed'</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><h3 id="五-自定义变量-用户变量"> （五）自定义变量—用户变量</h3>
<div><pre><code><span>#二、自定义变量</span>
<span>/*
说明：变量由用户自定义，而不是系统提供的
使用步骤：
1、声明
2、赋值
3、使用（查看、比较、运算等）
*/</span>

<span>#1》用户变量</span>
<span>/*
作用域：针对于当前会话（连接）有效，作用域同于会话变量
*/</span>

<span>#赋值操作符：=或:=</span>
<span>#①声明并初始化</span>
<span>SET</span> @变量名<span>=</span>值<span>;</span>
<span>SET</span> @变量名:<span>=</span>值<span>;</span>
<span>SELECT</span> @变量名:<span>=</span>值<span>;</span>

<span>#②赋值（更新变量的值）</span>
<span>#方式一：</span>
	<span>SET</span> @变量名<span>=</span>值<span>;</span>
	<span>SET</span> @变量名:<span>=</span>值<span>;</span>
	<span>SELECT</span> @变量名:<span>=</span>值<span>;</span>
<span>#方式二：</span>
	<span>SELECT</span> 字段 <span>INTO</span> @变量名
	<span>FROM</span> 表<span>;</span>
<span>#③使用（查看变量的值）</span>
<span>SELECT</span> @变量名<span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br></div></div><h3 id="六-自定义变量-局部变量"> （六）自定义变量—局部变量</h3>
<div><pre><code><span>#2》局部变量</span>
<span>/*
作用域：仅仅在定义它的begin end块中有效
应用在 begin end中的第一句话
*/</span>

<span>#①声明</span>
<span>DECLARE</span> 变量名 类型<span>;</span>
<span>DECLARE</span> 变量名 类型 【<span>DEFAULT</span> 值】<span>;</span>


<span>#②赋值（更新变量的值）</span>

<span>#方式一：</span>
	<span>SET</span> 局部变量名<span>=</span>值<span>;</span>
	<span>SET</span> 局部变量名:<span>=</span>值<span>;</span>
	<span>SELECT</span> 局部变量名:<span>=</span>值<span>;</span>
<span>#方式二：</span>
	<span>SELECT</span> 字段 <span>INTO</span> 具备变量名
	<span>FROM</span> 表<span>;</span>
<span>#③使用（查看变量的值）</span>
<span>SELECT</span> 局部变量名<span>;</span>


<span>#案例：声明两个变量，求和并打印</span>
<span>#用户变量</span>
<span>SET</span> <span>@m</span><span>=</span><span>1</span><span>;</span>
<span>SET</span> <span>@n</span><span>=</span><span>1</span><span>;</span>
<span>SET</span> <span>@sum</span><span>=</span><span>@m</span><span>+</span><span>@n</span><span>;</span>
<span>SELECT</span> <span>@sum</span><span>;</span>

<span>#局部变量</span>
<span>DECLARE</span> m <span>INT</span> <span>DEFAULT</span> <span>1</span><span>;</span>
<span>DECLARE</span> n <span>INT</span> <span>DEFAULT</span> <span>1</span><span>;</span>
<span>DECLARE</span> SUM <span>INT</span><span>;</span>
<span>SET</span> SUM<span>=</span>m<span>+</span>n<span>;</span>
<span>SELECT</span> SUM<span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br></div></div><h3 id="七-用户变量和局部变量的对比"> （七）用户变量和局部变量的对比</h3>
<div><pre><code>		   作用域			           定义位置		            语法
用户变量	当前会话		          会话的任何地方		加@符号，不用指定类型
局部变量	定义它的<span>BEGIN</span> <span>END</span>中  	<span>BEGIN</span> <span>END</span>的第一句话	一般不用加@<span>,</span>需要指定类型
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id="三、存储过程和函数"> 三、存储过程和函数</h2>
<ul>
<li>
<p><strong>说明</strong>：都类似于java中的方法，将一组完成特定功能的逻辑语句包装起来，对外暴露名字</p>
</li>
<li>
<p><strong>好处</strong></p>
<p>（1）提高代码的重用性</p>
<p>（2）简化操作</p>
<p>（3）减少了编译次数并且减少了和数据库服务器的连接次数，提高了效率</p>
</li>
</ul>
<h3 id="一-存储过程"> （一）存储过程</h3>
<ul>
<li>
<p><strong>含义</strong>：一组预先编译好的SQL语句的集合，理解成批处理语句</p>
</li>
<li>
<p><strong>创建语法</strong></p>
<div><pre><code><span>CREATE</span> <span>PROCEDURE</span> 存储过程名<span>(</span>参数列表<span>)</span>
<span>BEGIN</span>
	存储过程体（一组合法的<span>SQL</span>语句）
<span>END</span>

注意：
<span>1</span>、参数列表包含三部分
参数模式  参数名  参数类型
举例：
<span>in</span> stuname <span>varchar</span><span>(</span><span>20</span><span>)</span>

参数模式：
<span>in</span>：该参数可以作为输入，也就是该参数需要调用方传入值
<span>out</span>：该参数可以作为输出，也就是该参数可以作为返回值
<span>inout</span>：该参数既可以作为输入又可以作为输出，也就是该参数既需要传入值，又可以返回值

<span>2</span>、如果存储过程体仅仅只有一句话，<span>begin</span> <span>end</span>可以省略
存储过程体中的每条<span>sql</span>语句的结尾要求必须加分号。
存储过程的结尾可以使用 <span>delimiter</span> 重新设置
语法：
<span>delimiter</span> 结束标记
案例：
<span>delimiter</span> $
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div></li>
<li>
<p><strong>调用语法</strong></p>
<div><pre><code><span>CALL</span> 存储过程名<span>(</span>实参列表<span>)</span><span>;</span>

举例：
调用<span>in</span>模式的参数：<span>call</span> sp1（‘值’）<span>;</span>
调用<span>out</span>模式的参数：<span>set</span> <span>@name</span><span>;</span> <span>call</span> sp1<span>(</span><span>@name</span><span>)</span><span>;</span><span>select</span> <span>@name</span><span>;</span>
调用<span>inout</span>模式的参数：<span>set</span> <span>@name</span><span>=</span>值<span>;</span> <span>call</span> sp1<span>(</span><span>@name</span><span>)</span><span>;</span> <span>select</span> <span>@name</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div></li>
<li>
<p>案例</p>
<div><pre><code><span>#1.空参列表</span>
<span>#案例：插入到admin表中五条记录</span>
<span>SELECT</span> <span>*</span> <span>FROM</span> admin<span>;</span>

<span>DELIMITER</span> $
<span>CREATE</span> <span>PROCEDURE</span> myp1<span>(</span><span>)</span>
<span>BEGIN</span>
	<span>INSERT</span> <span>INTO</span> admin<span>(</span>username<span>,</span><span>`</span>password<span>`</span><span>)</span> 
	<span>VALUES</span><span>(</span><span>'john1'</span><span>,</span><span>'0000'</span><span>)</span><span>,</span><span>(</span><span>'lily'</span><span>,</span><span>'0000'</span><span>)</span><span>,</span><span>(</span><span>'rose'</span><span>,</span><span>'0000'</span><span>)</span><span>,</span><span>(</span><span>'jack'</span><span>,</span><span>'0000'</span><span>)</span><span>,</span><span>(</span><span>'tom'</span><span>,</span><span>'0000'</span><span>)</span><span>;</span>
<span>END</span> $

<span>#调用</span>
<span>CALL</span> myp1<span>(</span><span>)</span>$

<span>#2.创建带in模式参数的存储过程</span>

<span>#案例1：创建存储过程实现 根据女神名，查询对应的男神信息</span>

<span>CREATE</span> <span>PROCEDURE</span> myp2<span>(</span><span>IN</span> beautyName <span>VARCHAR</span><span>(</span><span>20</span><span>)</span><span>)</span>
<span>BEGIN</span>
	<span>SELECT</span> bo<span>.</span><span>*</span>
	<span>FROM</span> boys bo
	<span>RIGHT</span> <span>JOIN</span> beauty b <span>ON</span> bo<span>.</span>id <span>=</span> b<span>.</span>boyfriend_id
	<span>WHERE</span> b<span>.</span>name<span>=</span>beautyName<span>;</span>
<span>END</span> $

<span>#调用</span>
<span>CALL</span> myp2<span>(</span><span>'柳岩'</span><span>)</span>$

<span>#案例2 ：创建存储过程实现，用户是否登录成功</span>
<span>CREATE</span> <span>PROCEDURE</span> myp3<span>(</span><span>IN</span> username <span>VARCHAR</span><span>(</span><span>20</span><span>)</span><span>,</span><span>IN</span> PASSWORD <span>VARCHAR</span><span>(</span><span>20</span><span>)</span><span>)</span>
<span>BEGIN</span>
	<span>DECLARE</span> result <span>VARBINARY</span><span>(</span><span>20</span><span>)</span> <span>DEFAULT</span> <span>''</span><span>;</span><span>#声明并初始化</span>
	
	<span>SELECT</span> <span>COUNT</span><span>(</span><span>*</span><span>)</span> <span>INTO</span> result<span>#赋值</span>
	<span>FROM</span> admin
	<span>WHERE</span> admin<span>.</span>username <span>=</span> username
	<span>AND</span> admin<span>.</span>password <span>=</span> PASSWORD<span>;</span>
	
	<span>SELECT</span> result<span>;</span><span>#使用</span>
<span>END</span> $

<span>CALL</span> myp3<span>(</span><span>'张飞'</span><span>,</span><span>'8888'</span><span>)</span>$

<span>CREATE</span> <span>PROCEDURE</span> myp4<span>(</span><span>IN</span> username <span>VARCHAR</span><span>(</span><span>20</span><span>)</span><span>,</span><span>IN</span> PASSWORD <span>VARCHAR</span><span>(</span><span>20</span><span>)</span><span>)</span>
<span>BEGIN</span>
	<span>DECLARE</span> result <span>INT</span> <span>DEFAULT</span> <span>0</span><span>;</span><span>#声明并初始化</span>
	
	<span>SELECT</span> <span>COUNT</span><span>(</span><span>*</span><span>)</span> <span>INTO</span> result<span>#赋值</span>
	<span>FROM</span> admin
	<span>WHERE</span> admin<span>.</span>username <span>=</span> username
	<span>AND</span> admin<span>.</span>password <span>=</span> PASSWORD<span>;</span>
	
	<span>SELECT</span> <span>IF</span><span>(</span>result<span>></span><span>0</span><span>,</span><span>'成功'</span><span>,</span><span>'失败'</span><span>)</span><span>;</span><span>#使用</span>
<span>END</span> $

<span>#调用</span>
<span>CALL</span> myp4<span>(</span><span>'张飞'</span><span>,</span><span>'8888'</span><span>)</span>$


<span>#3.创建out 模式参数的存储过程</span>
<span>#案例1：根据输入的女神名，返回对应的男神名</span>
<span>CREATE</span> <span>PROCEDURE</span> myp6<span>(</span><span>IN</span> beautyName <span>VARCHAR</span><span>(</span><span>20</span><span>)</span><span>,</span><span>OUT</span> boyName <span>VARCHAR</span><span>(</span><span>20</span><span>)</span><span>)</span>
<span>BEGIN</span>
	<span>SELECT</span> bo<span>.</span>boyname <span>INTO</span> boyname
	<span>FROM</span> boys bo
	<span>RIGHT</span> <span>JOIN</span>
	beauty b <span>ON</span> b<span>.</span>boyfriend_id <span>=</span> bo<span>.</span>id
	<span>WHERE</span> b<span>.</span>name<span>=</span>beautyName <span>;</span>
	
<span>END</span> $

<span>#案例2：根据输入的女神名，返回对应的男神名和魅力值</span>
<span>CREATE</span> <span>PROCEDURE</span> myp7<span>(</span><span>IN</span> beautyName <span>VARCHAR</span><span>(</span><span>20</span><span>)</span><span>,</span><span>OUT</span> boyName <span>VARCHAR</span><span>(</span><span>20</span><span>)</span><span>,</span><span>OUT</span> usercp <span>INT</span><span>)</span> 
<span>BEGIN</span>
	<span>SELECT</span> boys<span>.</span>boyname <span>,</span>boys<span>.</span>usercp <span>INTO</span> boyname<span>,</span>usercp
	<span>FROM</span> boys 
	<span>RIGHT</span> <span>JOIN</span>
	beauty b <span>ON</span> b<span>.</span>boyfriend_id <span>=</span> boys<span>.</span>id
	<span>WHERE</span> b<span>.</span>name<span>=</span>beautyName <span>;</span>
	
<span>END</span> $

<span>#调用</span>
<span>CALL</span> myp7<span>(</span><span>'小昭'</span><span>,</span><span>@name</span><span>,</span><span>@cp</span><span>)</span>$
<span>SELECT</span> <span>@name</span><span>,</span><span>@cp$</span>

<span>#4.创建带inout模式参数的存储过程</span>
<span>#案例1：传入a和b两个值，最终a和b都翻倍并返回</span>

<span>CREATE</span> <span>PROCEDURE</span> myp8<span>(</span><span>INOUT</span> a <span>INT</span> <span>,</span><span>INOUT</span> b <span>INT</span><span>)</span>
<span>BEGIN</span>
	<span>SET</span> a<span>=</span>a<span>*</span><span>2</span><span>;</span>
	<span>SET</span> b<span>=</span>b<span>*</span><span>2</span><span>;</span>
<span>END</span> $

<span>#调用</span>
<span>SET</span> <span>@m</span><span>=</span><span>10</span>$
<span>SET</span> <span>@n</span><span>=</span><span>20</span>$
<span>CALL</span> myp8<span>(</span><span>@m</span><span>,</span><span>@n</span><span>)</span>$
<span>SELECT</span> <span>@m</span><span>,</span><span>@n$</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br><span>96</span><br><span>97</span><br><span>98</span><br><span>99</span><br><span>100</span><br><span>101</span><br></div></div></li>
<li>
<p><strong>查看语法</strong></p>
<div><pre><code><span>show</span> <span>create</span> <span>procedure</span> 存储过程名<span>;</span>

案例
<span>DESC</span> myp2<span>;</span>×
<span>SHOW</span> <span>CREATE</span> <span>PROCEDURE</span>  myp2<span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div></li>
<li>
<p><strong>删除语法</strong></p>
<div><pre><code><span>drop</span> <span>procedure</span> 存储过程名<span>;</span>

案例:
<span>DROP</span> <span>PROCEDURE</span> p1<span>;</span>
<span>DROP</span> <span>PROCEDURE</span> p2<span>,</span>p3<span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div></li>
</ul>
<h3 id="二-函数"> （二）函数</h3>
<ul>
<li>
<p><strong>含义</strong>：一组预先编译好的SQL语句的集合，理解成批处理语句</p>
</li>
<li>
<p><strong>区别</strong>：</p>
<p>（1）存储过程：可以有0个返回，也可以有多个返回，适合做批量插入、批量更新；</p>
<p>（2）函数：有且仅有1 个返回，适合做处理数据后返回一个结果。</p>
</li>
<li>
<p><strong>创建语法</strong></p>
<div><pre><code><span>CREATE</span> <span>FUNCTION</span> 函数名<span>(</span>参数列表<span>)</span> <span>RETURNS</span> 返回类型
<span>BEGIN</span>
	函数体
<span>END</span>

<span>/*
注意：
1.参数列表 包含两部分：
参数名 参数类型
2.函数体：肯定会有return语句，如果没有会报错
如果return语句没有放在函数体的最后也不报错，但不建议

return 值;
3.函数体中仅有一句话，则可以省略begin end
4.使用 delimiter语句设置结束标记
*/</span>

<span>DELIMITER</span> $
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div></li>
<li>
<p><strong>调用语法</strong></p>
<p>SELECT 函数名(参数列表);</p>
<p>案例</p>
<div><pre><code><span>use</span> employees $
<span>#1.无参有返回</span>
<span>#案例：返回公司的员工个数</span>
<span>CREATE</span> <span>FUNCTION</span> myf1<span>(</span><span>)</span> <span>RETURNS</span> <span>INT</span>
<span>BEGIN</span>	
	<span>DECLARE</span> c <span>INT</span> <span>DEFAULT</span> <span>0</span><span>;</span>
	<span>SELECT</span> <span>COUNT</span><span>(</span><span>*</span><span>)</span> <span>INTO</span> c
	<span>FROM</span> employees<span>;</span>
	<span>RETURN</span> c<span>;</span>
<span>END</span> $

<span>SELECT</span> myf1<span>(</span><span>)</span>$


<span>#2.有参有返回</span>
<span>#案例1：根据员工名，返回它的工资</span>
<span>CREATE</span> <span>FUNCTION</span> myf2<span>(</span>empName <span>VARCHAR</span><span>(</span><span>20</span><span>)</span><span>)</span> <span>RETURNS</span> <span>DOUBLE</span>
<span>BEGIN</span>
	<span>SET</span> <span>@sal</span><span>=</span><span>0</span><span>;</span><span>#定义用户变量 </span>
	<span>SELECT</span> salary <span>INTO</span> <span>@sal</span>   <span>#赋值</span>
	<span>FROM</span> employees
	<span>WHERE</span> last_name <span>=</span> empName<span>;</span>
	
	<span>RETURN</span> <span>@sal</span><span>;</span>
<span>END</span> $

<span>SELECT</span> myf2<span>(</span><span>'kochhor'</span><span>)</span> $

<span>#案例2：根据部门名，返回该部门的平均工资</span>
<span>CREATE</span> <span>FUNCTION</span> myf3<span>(</span>deptName <span>VARCHAR</span><span>(</span><span>20</span><span>)</span><span>)</span> <span>RETURNS</span> <span>DOUBLE</span>
<span>BEGIN</span>
	<span>DECLARE</span> sal <span>DOUBLE</span> <span>;</span>
	<span>SELECT</span> <span>AVG</span><span>(</span>salary<span>)</span> <span>INTO</span> sal
	<span>FROM</span> employees e
	<span>JOIN</span> departments d <span>ON</span> e<span>.</span>department_id <span>=</span> d<span>.</span>department_id
	<span>WHERE</span> d<span>.</span>department_name<span>=</span>deptName<span>;</span>
	<span>RETURN</span> sal<span>;</span>
<span>END</span> $

<span>SELECT</span> myf3<span>(</span><span>'IT'</span><span>)</span>$
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br></div></div></li>
<li>
<p><strong>查看函数</strong></p>
<div><pre><code><span>show</span> <span>create</span> <span>function</span> 函数名<span>;</span>

<span>SHOW</span> <span>CREATE</span> <span>FUNCTION</span> myf3 $
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div></li>
<li>
<p><strong>删除函数</strong></p>
<div><pre><code><span>drop</span> <span>function</span> 函数名<span>;</span>

<span>DROP</span> <span>FUNCTION</span> myf3 $
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div></li>
</ul>
<h3 id="三-流程控制结构"> （三）流程控制结构</h3>
<ul>
<li>顺序结构：程序从上往下依次执行</li>
<li>分支结构：程序按条件进行选择执行，从两条或多条路径中选择一条执行</li>
<li>循环结构：程序满足一定条件下，重复执行一组语句</li>
</ul>
<p><strong>1、分支结构</strong></p>
<ul>
<li>
<p>if函数</p>
<p>语法：if(条件,值1，值2)；</p>
<p>功能：实现双分支；</p>
<p>应用：可以作为表达式放在任何位置</p>
</li>
<li>
<p>case结构</p>
<p>语法：</p>
<div><pre><code>情况<span>1</span>：类似于switch，一般用于实现等值判断。
语法：
<span>case</span> 变量或表达式
<span>when</span> 值<span>1</span> <span>then</span> 语句<span>1</span><span>;</span>
<span>when</span> 值<span>2</span> <span>then</span> 语句<span>2</span><span>;</span>
<span>.</span><span>.</span><span>.</span>
<span>else</span> 语句n<span>;</span>
<span>end</span> 

情况<span>2</span>：类似于多重<span>if</span>语句，一般用于实现区间判断。
语法：
<span>case</span> 
<span>when</span> 条件<span>1</span> <span>then</span> 语句<span>1</span><span>;</span>
<span>when</span> 条件<span>2</span> <span>then</span> 语句<span>2</span><span>;</span>
<span>.</span><span>.</span><span>.</span>
<span>else</span> 语句n<span>;</span>
<span>end</span> 
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p><strong>特点</strong></p>
<p>（1）可以作为表达式，嵌套在其他语句中使用。</p>
<p>（2）可以放在任何地方，BEGIN END 中或BEGIN END 的外面可以作为独立的语句去使用，只能放在BEGIN END中如果wHEN中的值满足或条件成立，则执行对应的THzN后面的语句，并且结束CASE如果都不满足，则执行E1SE中的语句或值。</p>
<p>（3）ELSE可以省略，如果ELSE省略了，并且所有WHEN条件都不满足，则返回NULL。</p>
<p><strong>位置</strong></p>
<p>（1）可以放在任何位置，</p>
<p>（2）如果放在begin end 外面，作为表达式结合着其他语句使用</p>
<p>（3）如果放在begin end 里面，一般作为独立的语句使用</p>
<p><strong>案例</strong></p>
<div><pre><code><span>#案例 </span>
<span>#创建存储过程，根据传入的成绩，来显示等级，比如传入的成绩：90-100, 显示A，80-90，显示B，60-80，显示c，否则，显示D</span>

<span>CREATE</span> <span>PROCEDURE</span> test_case <span>(</span><span>IN</span> score <span>INT</span><span>)</span> 
<span>BEGIN</span> 
	<span>CASE</span> 
	<span>WHEN</span> score<span>>=</span><span>90</span> <span>AND</span> score<span>&lt;=</span><span>100</span> <span>THEN</span> <span>SELECT</span> <span>'A'</span><span>;</span> 
	<span>WHEN</span> score<span>>=</span><span>80</span> <span>THEN</span> <span>SELECT</span> <span>'B'</span><span>;</span>
	<span>WHEN</span> score<span>>=</span><span>60</span> <span>THEN</span> <span>SELECT</span> <span>'C'</span><span>;</span> 
	<span>ELSE</span> <span>SELECT</span> <span>'D'</span><span>;</span>
	<span>END</span> <span>CASE</span><span>;</span> 
<span>END</span> $
<span>CALL</span> test_case<span>(</span><span>95</span><span>)</span>$
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div></li>
<li>
<p>if结构</p>
<p>语法：</p>
<div><pre><code><span>if</span> 条件<span>1</span> <span>then</span> 语句<span>1</span><span>;</span>
<span>elseif</span> 条件<span>2</span> <span>then</span> 语句<span>2</span><span>;</span>
<span>.</span><span>.</span><span>.</span><span>.</span>
<span>else</span> 语句n<span>;</span>
<span>end</span> <span>if</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>功能：类似于多重if；只能应用在begin end 中</p>
<div><pre><code><span>#案例1：创建函数，实现传入成绩，如果成绩>90,返回A，如果成绩>80,返回B，如果成绩>60,返回C，否则返回D</span>
<span>CREATE</span> <span>FUNCTION</span> test_case<span>(</span>score <span>FLOAT</span><span>)</span> <span>RETURNS</span> <span>CHAR</span>
<span>BEGIN</span> 
	<span>DECLARE</span> ch <span>CHAR</span> <span>DEFAULT</span> <span>'A'</span><span>;</span>
	
	<span>CASE</span> 
	<span>WHEN</span> score<span>></span><span>90</span> <span>THEN</span> <span>SET</span> ch<span>=</span><span>'A'</span><span>;</span>
	<span>WHEN</span> score<span>></span><span>80</span> <span>THEN</span> <span>SET</span> ch<span>=</span><span>'B'</span><span>;</span>
	<span>WHEN</span> score<span>></span><span>60</span> <span>THEN</span> <span>SET</span> ch<span>=</span><span>'C'</span><span>;</span>
	<span>ELSE</span> <span>SET</span> ch<span>=</span><span>'D'</span><span>;</span>
	<span>END</span> <span>CASE</span><span>;</span>
	
	<span>RETURN</span> ch<span>;</span>
<span>END</span> $

<span>SELECT</span> test_case<span>(</span><span>56</span><span>)</span>$
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div></li>
</ul>
<p><strong>2、循环结构</strong></p>
<ul>
<li>
<p><strong>位置</strong>：只能放在begin end中</p>
</li>
<li>
<p><strong>特点</strong>：都能实现循环结构</p>
</li>
<li>
<p><strong>语法</strong></p>
<div><pre><code><span>1</span>、<span>while</span>
语法：
【名称:】<span>while</span> 循环条件 <span>do</span>
		循环体
<span>end</span> <span>while</span> 【名称】<span>;</span>
<span>2</span>、<span>loop</span>
语法：
【名称：】<span>loop</span>
		循环体
<span>end</span> <span>loop</span> 【名称】<span>;</span>

<span>3</span>、<span>repeat</span>
语法：
【名称:】<span>repeat</span>
		循环体
until 结束条件 
<span>end</span> <span>repeat</span> 【名称】<span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div></li>
<li>
<p><strong>对比</strong></p>
<div><pre><code>①这三种循环都可以省略名称，但如果循环中添加了循环控制语句（<span>leave</span>或<span>iterate</span>）则必须添加名称
②
<span>loop</span> 一般用于实现简单的死循环
<span>while</span> 先判断后执行
<span>repeat</span> 先执行后判断，无条件至少执行一次
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div></li>
<li>
<p><strong>循环控制语句</strong></p>
<p><mark>leave</mark>：类似于break，用于跳出所在的循环</p>
<p><mark>iterate</mark>：类似于continue，用于结束本次循环，继续下一次</p>
<div><p>注意</p>
<p>循环中添加了循环控制语句（leave或iterate）则必须添加名称</p>
</div>
</li>
<li>
<p><strong>案例</strong></p>
<div><pre><code><span>#1.没有添加循环控制语句</span>
<span>#案例：批量插入，根据次数插入到admin表中多条记录</span>
<span>USE</span> girls$
<span>DROP</span> <span>PROCEDURE</span> pro_while1$
<span>CREATE</span> <span>PROCEDURE</span> pro_while1<span>(</span><span>IN</span> insertCount <span>INT</span><span>)</span>
<span>BEGIN</span>
	<span>DECLARE</span> i <span>INT</span> <span>DEFAULT</span> <span>1</span><span>;</span>
	<span>WHILE</span> i<span>&lt;=</span>insertCount <span>DO</span>
		<span>INSERT</span> <span>INTO</span> admin<span>(</span>username<span>,</span><span>`</span>password<span>`</span><span>)</span> <span>VALUES</span><span>(</span>CONCAT<span>(</span><span>'Rose'</span><span>,</span>i<span>)</span><span>,</span><span>'666'</span><span>)</span><span>;</span>
		<span>SET</span> i<span>=</span>i<span>+</span><span>1</span><span>;</span>
	<span>END</span> <span>WHILE</span><span>;</span>
<span>END</span> $

<span>CALL</span> pro_while1<span>(</span><span>158</span><span>)</span>$

<span>select</span> <span>*</span> <span>from</span> admin $
<span>/*
int i=1;
while(i&lt;=insertcount){
	//插入
	i++;

}
*/</span>

<span>#2.添加leave语句</span>
<span>#案例：批量插入，根据次数插入到admin表中多条记录，如果次数>20则停止</span>
<span>TRUNCATE</span> <span>TABLE</span> admin$
<span>DROP</span> <span>PROCEDURE</span> test_while1$
<span>CREATE</span> <span>PROCEDURE</span> test_while1<span>(</span><span>IN</span> insertCount <span>INT</span><span>)</span>
<span>BEGIN</span>
	<span>DECLARE</span> i <span>INT</span> <span>DEFAULT</span> <span>1</span><span>;</span>
	a:<span>WHILE</span> i<span>&lt;=</span>insertCount <span>DO</span>
		<span>INSERT</span> <span>INTO</span> admin<span>(</span>username<span>,</span><span>`</span>password<span>`</span><span>)</span> <span>VALUES</span><span>(</span>CONCAT<span>(</span><span>'xiaohua'</span><span>,</span>i<span>)</span><span>,</span><span>'0000'</span><span>)</span><span>;</span>
		<span>IF</span> i<span>>=</span><span>20</span> <span>THEN</span> <span>LEAVE</span> a<span>;</span>
		<span>END</span> <span>IF</span><span>;</span>
		<span>SET</span> i<span>=</span>i<span>+</span><span>1</span><span>;</span>
	<span>END</span> <span>WHILE</span> a<span>;</span>
<span>END</span> $

<span>CALL</span> test_while1<span>(</span><span>100</span><span>)</span>$

<span>select</span> <span>*</span> <span>from</span> admin $

<span>#3.添加iterate语句</span>
<span>#案例：批量插入，根据次数插入到admin表中多条记录，只插入偶数次</span>
<span>TRUNCATE</span> <span>TABLE</span> admin$
<span>DROP</span> <span>PROCEDURE</span> test_while1$
<span>CREATE</span> <span>PROCEDURE</span> test_while1<span>(</span><span>IN</span> insertCount <span>INT</span><span>)</span>
<span>BEGIN</span>
	<span>DECLARE</span> i <span>INT</span> <span>DEFAULT</span> <span>0</span><span>;</span>
	a:<span>WHILE</span> i<span>&lt;=</span>insertCount <span>DO</span>
		<span>SET</span> i<span>=</span>i<span>+</span><span>1</span><span>;</span>
		<span>IF</span> <span>MOD</span><span>(</span>i<span>,</span><span>2</span><span>)</span><span>!=</span><span>0</span> <span>THEN</span> <span>ITERATE</span> a<span>;</span>
		<span>END</span> <span>IF</span><span>;</span>
		
		<span>INSERT</span> <span>INTO</span> admin<span>(</span>username<span>,</span><span>`</span>password<span>`</span><span>)</span> <span>VALUES</span><span>(</span>CONCAT<span>(</span><span>'xiaohua'</span><span>,</span>i<span>)</span><span>,</span><span>'0000'</span><span>)</span><span>;</span>
		
	<span>END</span> <span>WHILE</span> a<span>;</span>
<span>END</span> $

<span>CALL</span> test_while1<span>(</span><span>100</span><span>)</span>$

<span>/*
int i=0;
while(i&lt;=insertCount){
	i++;
	if(i%2==0){
		continue;
	}
	插入
}
*/</span>

<span>select</span> <span>*</span> <span>from</span> admin $
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br></div></div></li>
</ul>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <category term="数据库"/>
    <contributor>
      <name>南辞</name>
    </contributor>
    <published>2021-03-31T05:51:25.000Z</published>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">常用关系型数据库</title>
    <id>http://qiqi.dreamagain.top/software/database/SQL/</id>
    <link href="http://qiqi.dreamagain.top/software/database/SQL/"/>
    <updated>2021-02-18T01:11:00.000Z</updated>
    <content type="html"><![CDATA[<h1 id="常用关系型数据库"> 常用关系型数据库</h1>
<h2 id="一、mysql"> 一、MySQL</h2>
<h2 id="二、oracle"> 二、Oracle</h2>
<h2 id="三、sql-server"> 三、SQL Server</h2>
<h2 id="四、postgresql"> 四、PostgreSQL</h2>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <contributor>
      <name>南辞</name>
    </contributor>
    <published>2021-02-18T01:11:00.000Z</published>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">数据库</title>
    <id>http://qiqi.dreamagain.top/software/database/</id>
    <link href="http://qiqi.dreamagain.top/software/database/"/>
    <updated>2021-03-31T05:51:25.000Z</updated>
    <content type="html"><![CDATA[<h1 id="数据库"> 数据库</h1>
<h2 id="一、关系型数据库与非关系型数据库的区别"> 一、关系型数据库与非关系型数据库的区别</h2>
<h2 id="二、关系型数据库"> 二、关系型数据库</h2>
<h2 id="三、非关系型数据库"> 三、非关系型数据库</h2>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <contributor>
      <name>南辞</name>
    </contributor>
    <published>2021-02-18T01:11:00.000Z</published>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">windows下安装多版本Node</title>
    <id>http://qiqi.dreamagain.top/software/nvm/</id>
    <link href="http://qiqi.dreamagain.top/software/nvm/"/>
    <updated>2021-03-31T05:51:25.000Z</updated>
    <summary type="html"><![CDATA[<p><img src="https://img.shields.io/badge/nvm-blue.svg" alt="">  <img src="https://img.shields.io/badge/Node.js-blue.svg" alt=""> ![](https://img.shields.io/badge/npm -blue.svg)  <img src="https://img.shields.io/badge/yarn-blue.svg" alt=""></p>
]]></summary>
    <content type="html"><![CDATA[<p><img src="https://img.shields.io/badge/nvm-blue.svg" alt="">  <img src="https://img.shields.io/badge/Node.js-blue.svg" alt=""> ![](https://img.shields.io/badge/npm -blue.svg)  <img src="https://img.shields.io/badge/yarn-blue.svg" alt=""></p>

<p>对于Node.js的爱好者来说，必然希望能够在同一台机器上安装多个版本的Node.js(至少两个：稳定版和最新版)。稳定版用来在实际生产项目中使用，最新版本用来研究Node.js的新特性、踩坑。</p>
<p>以下将介绍在windows系统中如何通过nvm进行node多版本管理以及一些常用命令</p>
<h2 id="一、概念介绍"> 一、概念介绍</h2>
<p><code>nvm</code>：Node.js Version Manager，用来管理 node 的版本。</p>
<p><code>node</code>：Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。 Node.js使用了一个事件驱动、非阻塞式I/O的模型（ Node.js的特性），使其轻量级又高效。 Node.js 的包管理器 nmp 是全球最大的开源库生态系统。</p>
<p><code>npm</code>：Node Package Manager，npm 不需要单独安装。默认在安装 node 的时候，会连带一起安装 npm</p>
<p><code>cnpm</code>：淘宝镜像，自定义命令。介绍详见https://github.com/cnpm/cnpm</p>
<p><code>yarn</code>：Yarn 是 Facebook, Google, Exponent 和 Tilde 开发的一款新的 JavaScript 包管理工具。它的目的是解决这些团队使用 npm 面临的少数问题，即：</p>
<p>1、安装的时候无法保证速度、一致性；</p>
<p>2、安全问题，因为 npm 安装时允许运行代码；</p>
<p>3、more...</p>
<h2 id="二、安装及使用"> 二、安装及使用</h2>
<div><p>nvm-windows的地址</p>
<p>nvm-windows的github地址:https://github.com/coreybutler/nvm-windows</p>
<p>安装包下载地址：<a href="https://github.com/coreybutler/nvm-windows/releases" target="_blank" rel="noopener noreferrer">https://github.com/coreybutler/nvm-windows/releases</a></p>
</div>
<h3 id="一-安装包下载"> （一）安装包下载</h3>
<p>可以看到nvm已经很久没有更新了，目前最新版本也是2018年发布的，这也是长期支持的版本，可以选择安装版<code>nvm-setup.zip</code>和免安装版<code>nvm-noinstall.zip</code>，这里我选择的是<code>nvm-setup.zip</code></p>
<p><img src="./assets/nvm01.png" alt=""></p>
<h3 id="二-安装环境"> （二）安装环境</h3>
<p>Win10系统，64位</p>
<h3 id="三-安装"> （三）安装</h3>
<p>安装nvm-windows的时候会指定安装目录和当前所使用的Node.js的目录，这两个路径中不要带有特殊的字符以及空格，否则会在nvm use xxx的时候出错，无法正确解析指定的Node.js的版本的地址</p>
<p>在安装的时候，自动会把nvm和Node.js的目录添加到系统环境变量中，所以安装后可以直接测试安装是否成功。</p>
<blockquote>
<img src="./assets/nvm02.png" style="zoom:100%;" />
<img src="./assets/nvm03.png" style="zoom:90%;" />
</blockquote>
<h3 id="四-nvm命令"> （四）nvm命令</h3>
<img src="./assets/nvm04.png" alt="image-20210211112509359" style="zoom:70%;" />
<p>1、nvm list 是查找本电脑上所有的node版本</p>
<ul>
<li>
<p>nvm list 查看已经安装的版本</p>
</li>
<li>
<p>nvm list installed 查看已经安装的版本</p>
</li>
<li>
<p>nvm list available 查看网络可以安装的版本</p>
</li>
</ul>
<p>2、nvm install 安装最新版本nvm</p>
<ul>
<li>nvm install xxx 安装指定node版本，可模糊安装，nvm install v8.12.0 或 nvm install 8.12.0 或 nvm install 8.12</li>
</ul>
<p>3、nvm use <code>&lt;version&gt;</code> 切换使用指定的版本node</p>
<p>4、nvm ls 列出所有版本</p>
<p>5、nvm current显示当前版本</p>
<p>6、nvm alias<code>&lt;name&gt; &lt;version&gt;</code> 给不同的版本号添加别名</p>
<p>7、nvm unalias <code>&lt;name&gt;</code> 删除已定义的别名</p>
<p>8、nvm reinstall-packages <code>&lt;version&gt;</code> #在当前版本node环境下，重新全局安装指定版本号的npm包</p>
<p>9、nvm on 打开Node.js控制</p>
<p>10、nvm off 关闭Node.js控制</p>
<p>11、nvm proxy 查看设置与代理</p>
<p>12、nvm node_mirror [url] 设置或者查看setting.txt中的node_mirror，如果不设置的默认是 https://Node.js.org/dist/
　　       nvm npm_mirror [url] 设置或者查看setting.txt中的npm_mirror,如果不设置的话默认的是： https://github.com/npm/npm/archive/.</p>
<p>13、nvm uninstall <code>&lt;version&gt;</code> 卸载制定的版本</p>
<p>14、nvm use [version] [arch] 切换制定的node版本和位数</p>
<p>15、nvm root [path] 设置和查看root路径</p>
<p>16、nvm version 查看当前的版本</p>
<h3 id="五-安装-node-js"> （五）安装 Node.js</h3>
<p><strong>1、获取所有可安装的 Node.js 版本</strong></p>
<div><pre><code>nvm list available
</code></pre>
<div><span>1</span><br></div></div><p>以下也只是给我们列出部分较新的版本，根据环境需要找合适的版本安装。</p>
<p>比较贴心的告诉我们，要查看完整的系列版本访问 ：https://Node.js.org/download/release</p>
<p><code>LTS</code> 指最新稳定版本，<code>CURRENT</code> 指最新版本，一般安装 <code>LTS</code></p>
<p><img src="./assets/nvm05.png" alt=""></p>
<p><strong>2、安装指定版本的 Node.js</strong></p>
<div><pre><code>nvm <span>install</span> <span>10.16</span>.3
</code></pre>
<div><span>1</span><br></div></div><p><strong>3、列出所有已经安装的版本</strong></p>
<div><pre><code>nvm list
</code></pre>
<div><span>1</span><br></div></div><img src="./assets/nvm06.png" style="zoom:110%;" />
<p><strong>4、指定当前要使用的 Node.js 版本,只用指定使用的 Node.js 版本后，Node.js 的才真正安装了。</strong></p>
<div><pre><code>nvm use <span>10.16</span>.3
</code></pre>
<div><span>1</span><br></div></div><p>版本查看：</p>
<img src="./assets/nvm07.png" style="zoom:120%;" />
<div><p>提示</p>
<p>通过以上步骤安装的Node.js和单独安装Node.js没有太大的区别，所以可以和单独安装的Node.js一样放心的使用npm进行cordova、ionic、vue等等的安装</p>
<p>npm是Node.js自带的包管理工具，类似于Java开发中经常使用的maven</p>
</div>
<p><strong>5、卸载某个 Node.js 版本</strong></p>
<div><pre><code>nvm uninstall <span>12.20</span>.0
</code></pre>
<div><span>1</span><br></div></div><h2 id="三、node-js-包管理器"> 三、Node.js 包管理器</h2>
<p>Node.js 包管理器一览表</p>
<ul>
<li>npm</li>
<li>cnpm</li>
<li>yarn</li>
</ul>
<p>npm 是 Node.js 自带的包管理器，但是默认下载依赖包的地址是国外服务器，下载速度较慢。使用 npm ,下载包两小时，敲代码 5 分钟。所以使用的时候指定安装源为国内的镜像源。</p>
<p>阿里巴巴是 Node.js 前端非常重视 Node.js 的使用，于是，淘宝开发了 cnpm,使用与 npm 一致，默认下载是国内地址，下载速度快得飞起。下载地址<a href="https://npm.taobao.org/" target="_blank" rel="noopener noreferrer">https://npm.taobao.org</a></p>
<p><a href="https://yarnpkg.com/zh-Hans/" target="_blank" rel="noopener noreferrer">yarn</a> 是 facebook 开发的新一代包管理器，主要是解决依赖包的安装问题。支持离线安装依赖包，同时依赖包的安装顺序不会出错。</p>
<h3 id="一-国内npm镜像源设置"> （一）国内npm镜像源设置</h3>
<p><strong>1、国内npm镜像源</strong></p>
<ul>
<li>
<p>淘宝npm镜像</p>
<p>搜索地址：http://npm.taobao.org/</p>
<p>registry地址：http://registry.npm.taobao.org/</p>
</li>
<li>
<p>cnpmjs镜像</p>
<p>搜索地址：http://cnpmjs.org/</p>
<p>registry地址：http://r.cnpmjs.org/</p>
</li>
<li>
<p>使用方法：</p>
<p>临时使用<code>npm --registry https://registry.npm.taobao.org install express</code></p>
<p>持久使用<code>npm config set registry https://registry.npm.taobao.org</code></p>
</li>
</ul>
<p><strong>以配置淘宝镜像为例：</strong></p>
<p>1、修改下载仓库为淘宝镜像</p>
<div><pre><code><span>npm</span> config <span>set</span> registry http://registry.npm.taobao.org/
或 
<span>yarn</span> config <span>set</span> registry https://registry.npm.taobao.org
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>如果需要安装node-sass，最好设置变量 sass_binary_site，指向淘宝镜像地址，很多时候环境安装不成功就是sass安装失败</p>
<div><pre><code><span>npm</span> config <span>set</span> sass_binary_site https://npm.taobao.org/mirrors/node-sass/
或
<span>yarn</span> config <span>set</span> sass_binary_site http://cdn.npm.taobao.org/dist/node-sass -g
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>2、 如果需要修改回来</p>
<div><pre><code><span>npm</span> config <span>set</span> registry https://registry.npmjs.org/
或 
<span>yarn</span> config <span>set</span> registry https://registry.yarnpkg.com
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>3、或直接采用他们的cnpm</p>
<div><pre><code><span>npm</span> <span>install</span> -g cnpm --registry<span>=</span>https://registry.npm.taobao.org
</code></pre>
<div><span>1</span><br></div></div><p><strong>2、配置完成后可通过下面方式来验证是否成功</strong></p>
<div><pre><code><span>npm</span> config get registry
或npm info express
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h3 id="二-安装yarn"> （二）安装Yarn</h3>
<p><strong>通过npm安装</strong></p>
<div><pre><code><span># -g 全局安装</span>
<span># -d 局部安装</span>
<span>npm</span> <span>install</span> -g <span>yarn</span>
或者
<span>npm</span> i <span>yarn</span> -g
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p><strong>查看版本</strong></p>
<img src="./assets/nvm08.png" style="zoom:150%;" />
<p><strong>Yarn 淘宝源配置</strong></p>
<div><pre><code><span>yarn</span> config <span>set</span> registry https://registry.npm.taobao.org -g

<span>yarn</span> config <span>set</span> sass_binary_site http://cdn.npm.taobao.org/dist/node-sass -g
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id="二-npm-yarn-命令对照表"> （二）npm yarn 命令对照表</h3>
<table>
<thead>
<tr>
<th>npm</th>
<th>Yarn</th>
</tr>
</thead>
<tbody>
<tr>
<td>npm install</td>
<td>yarn install</td>
</tr>
<tr>
<td>(N/A)</td>
<td>yarn install --flat</td>
</tr>
<tr>
<td>(N/A)</td>
<td>yarn install --har</td>
</tr>
<tr>
<td>(N/A)</td>
<td>yarn install --no-lockfile</td>
</tr>
<tr>
<td>(N/A)</td>
<td>yarn install --pure-lockfile</td>
</tr>
<tr>
<td>npm install [package]</td>
<td>(N/A)</td>
</tr>
<tr>
<td>npm install --save [package]</td>
<td>yarn add [package]</td>
</tr>
<tr>
<td>npm install --save-dev [package]</td>
<td>yarn add [package] [--dev/-D]</td>
</tr>
<tr>
<td>(N/A)</td>
<td>yarn add [package] [--peer/-P]</td>
</tr>
<tr>
<td>npm install --save-optional [package]</td>
<td>yarn add [package] [--optional/-O]</td>
</tr>
<tr>
<td>npm install --save-exact [package]</td>
<td>yarn add [package] [--exact/-E]</td>
</tr>
<tr>
<td>(N/A)</td>
<td>yarn add [package] [--tilde/-T]</td>
</tr>
<tr>
<td>npm install --global [package]</td>
<td>yarn global add [package]</td>
</tr>
<tr>
<td>npm rebuild</td>
<td>yarn install --force</td>
</tr>
<tr>
<td>npm uninstall [package]</td>
<td>(N/A)</td>
</tr>
<tr>
<td>npm uninstall --save [package]</td>
<td>yarn remove [package]</td>
</tr>
<tr>
<td>npm uninstall --save-dev [package]</td>
<td>yarn remove [package]</td>
</tr>
<tr>
<td>npm uninstall --save-optional [package]</td>
<td>yarn remove [package]</td>
</tr>
<tr>
<td>npm cache clean</td>
<td>yarn cache clean</td>
</tr>
<tr>
<td>rm -rf node_modules &amp;&amp; npm install</td>
<td>yarn upgrade</td>
</tr>
</tbody>
</table>
<h2 id="四、常用指令"> 四、常用指令</h2>
<p>上面列出很多命令，仅供查阅使用，下面是经常用到的命令，也不用记，只是刚接触的时候要多看几眼，先熟练用这几个命令</p>
<p>nvm -v ： 查看已安装的nvm版本</p>
<p>nvm install xxx ： 安装指定node版本，可模糊安装</p>
<p>nvm ls ： 查看已安装的所有node版本</p>
<p>node -v ：查看已安装的node版本</p>
<p>npm -v ：查看已安装的npm 版本</p>
<p>yarn -v ：查看已安装的yarn 版本</p>
<p>npm config get registry：查看当前设置的npm镜像源</p>
<p>yarn config get registry ：查看当前设置的yarn镜像源</p>
<p>npm config set registry https://registry.npm.taobao.org</p>
<p>yarn config set registry https://registry.npm.taobao.org</p>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <category term="软件使用"/>
    <contributor>
      <name>南辞</name>
    </contributor>
    <published>2021-02-18T01:11:00.000Z</published>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">常用工具</title>
    <id>http://qiqi.dreamagain.top/software/tool/online/common/</id>
    <link href="http://qiqi.dreamagain.top/software/tool/online/common/"/>
    <updated>2021-03-31T05:51:25.000Z</updated>
    <content type="html"><![CDATA[<h2 id="一、搜索类在线工具"> 一、搜索类在线工具</h2>
<ol>
<li><a href="https://searchcode.com/" target="_blank" rel="noopener noreferrer">SearchCode</a> 是一个源码搜索引擎，目前支持从 Github、Bitbucket、Google Code、CodePlex、SourceForge 和 Fedora Project 平台搜索公开的源码。</li>
<li><a href="http://mvnrepository.com/" target="_blank" rel="noopener noreferrer">mvnrepository</a> 这个不用详细解释了，就是查询maven的gav等信息。</li>
<li><a href="https://www.iconfont.cn/" target="_blank" rel="noopener noreferrer">Iconfont</a> 国内功能很强大且图标内容很丰富的矢量图标库，提供矢量图标下载、在线存储、格式转换等功能。阿里巴巴体验团队倾力打造，设计和前端开发的便捷工具。</li>
<li><a href="https://openjdk.binarydoc.org/net.java/openjdk/" target="_blank" rel="noopener noreferrer">BinaryDoc for OpenJDK</a> 直接从OpenJDK二进制文件生成文档，二进制代码是最好的文档。</li>
<li><a href="https://unsplash.com/" target="_blank" rel="noopener noreferrer">Unsplas</a> 是一个免费的图片分享网站，可以在上面搜索无版权图片</li>
<li><a href="https://www.jiumodiary.com/" target="_blank" rel="noopener noreferrer">鸠摩搜书</a> 国内一款强大的电子书搜索引擎，整合了大部分电子书平台的资源，最重要的是他无需注册登录，可以直接下载。并且网站页面清新、且资源免费。</li>
<li><a href="https://myslide.cn/" target="_blank" rel="noopener noreferrer">MySlide</a> 是一个提供PPT分享服务的平台，在这里你可以找到你想要的PPT。</li>
<li><a href="https://www.itdks.com/" target="_blank" rel="noopener noreferrer">IT大咖说</a> 是IT垂直领域的大咖知识分享平台，分享行业TOP大咖干货，技术大会在线直播录播，在线直播知识分享平台。</li>
</ol>
<h2 id="二、生成类在线工具"> 二、生成类在线工具</h2>
<ol>
<li><a href="http://www.bejson.com/json2javapojo" target="_blank" rel="noopener noreferrer">BeJSON</a> 是一个比较好用将Json转成Java对象的工具。json是目前JavaWeb中数据传输的主要格式，很多时候会有把json转成Java对象的需求。有时候合作方会提供一个json的样例，需要我们自己定义Java类，这时候这个工具就派上用场了。</li>
<li><a href="https://cron.qqe2.com/" target="_blank" rel="noopener noreferrer">在线corn生成工具</a>，Cron 一般用于配置定时任务的执行。但是要想一次性的把一个corn表达式配置好确实很难的，需要程序员记住他的语法。有一些在线工具可以提供图形化的界面，只要输入想要定时执行的周期等，就可以自动生成corn表达式。</li>
<li><a href="http://tool.chinaz.com/tools/regexgenerate" target="_blank" rel="noopener noreferrer">正则表达式的生成工具</a> 正则表达式，又称规则表达式。（英语：Regular Expression，在代码中常简写为regex、regexp或RE），计算机科学的一个概念。正则表达式通常被用来检索、替换那些符合某个模式(规则)的文本。在使用正则表达式进行字符转过滤的时候，需要用事先定义好的一些特定字符、及这些特定字符的组合，组成一个“规则字符串”，这个“规则字符串”用来表达对字符串的一种过滤逻辑。通常，这个规则字符串的定义是比较麻烦和复杂的。也需要经过大量的测试和验证才能被采用。</li>
<li><a href="http://patorjk.com/software/taag/" target="_blank" rel="noopener noreferrer">ASCII艺术生成工具</a> 可以将输入的字符快速转换成ASCII艺术文字的形式。</li>
<li><a href="https://www.processon.com/" target="_blank" rel="noopener noreferrer">ProcessOn</a> 是一个在线协作绘图平台，为用户提供最强大、易用的作图工具!支持在线创作流程图、BPMN、UML图、UI界面原型设计、iOS界面原型设计。</li>
<li>MarkDown编辑器，Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，深受广大程序员们的喜爱，推荐几款在线md编辑器：<a href="https://mahua.jser.me/" target="_blank" rel="noopener noreferrer">MaHua</a> 、<a href="https://maxiang.io/" target="_blank" rel="noopener noreferrer">马克飞象</a>、<a href="https://www.zybuluo.com/mdeditor" target="_blank" rel="noopener noreferrer">Cmd</a></li>
</ol>
<h2 id="三、转换类在线工具"> 三、转换类在线工具</h2>
<ol>
<li>
<p>站长工具的<a href="http://tool.chinaz.com/tools/unicode.aspx" target="_blank" rel="noopener noreferrer">编码转换</a>比较全面，提供了Unicode编码、UFT8编码、URL编码/解码等功能。编码问题一直困扰着开发人员，尤其在Java 中更加明显，因为Java 是跨平台语言，不同平台之间编码之间的切换较多。计算中提拱了多种编码方式，常见的有 ASCII、ISO-8859-1、GB2312、GBK、UTF-8、UTF-16 等。有些时候开发人员需要通过编码转换的方式来查看不同编码下面的文件内容。</p>
</li>
<li>
<p><a href="http://tool.chinaz.com/Tools/unixtime.aspx" target="_blank" rel="noopener noreferrer">时间戳转换工具</a>，时间戳(英语：Timestamp）是指在一连串的资料中加入辨识文字，如时间或日期，用以保障本地端（local）资料更新顺序与远端（remote）一致。</p>
</li>
<li>
<p><a href="http://www.timebie.com/cn/easternbeijing.php" target="_blank" rel="noopener noreferrer">Timebie</a> 提供了世界时间相互转换的功能。世界各地时间转换在做国际业务的时候会经常用到，比如北京时间转纽约时间，北京时间转洛杉矶时间。</p>
</li>
<li>
<p>加密解密也是JavaWeb可能会经常遇到的，有的时候我们需要验证加密算法是否正确，或者要解密等场景，就需要一个<a href="http://tool.chinaz.com/tools/textencrypt.aspx" target="_blank" rel="noopener noreferrer">在线加密解密工具</a>来快速验证。</p>
</li>
<li>
<p><a href="https://www.convertworld.com/zh-hans/" target="_blank" rel="noopener noreferrer">convertworld</a> 是一个比较全的单位换算的网站。我经常用它进行时间单位和货币单位的换算。</p>
</li>
<li>
<p><a href="https://convertio.co/zh/flv-mp4/" target="_blank" rel="noopener noreferrer">Convertio</a> 是一个在线视频格式转换工具，支持多种常见视频格式，如 FLV、MOV 和 AVI 等。上传的视频文件不能超过 100 MB。</p>
</li>
<li>
<p><a href="https://docsmall.com/image-compress" target="_blank" rel="noopener noreferrer">Docsmall</a> 是一个在线图片压缩工具，可以批量压缩图片、Gif 图，一次最多上传 30 张图片，每张图片最大为 25 MB。</p>
</li>
</ol>
<h2 id="四、检查类在线工具"> 四、检查类在线工具</h2>
<ol>
<li><a href="https://www.json.cn/" target="_blank" rel="noopener noreferrer">JSON格式化工具</a> 是我尝试过很多同类工具之后最经常使用的一个，不仅支持json格式的验证及格式化，还可以将json格式压缩成普通文本等好用功能。有时候我们不确定这个文本是否完全符合JSON格式，有时候我们也想可以更清晰的查看这个JSON文本的格式关系。就可以使用这个工具来进行JSON格式的验证和格式化。</li>
<li><a href="http://tool.chinaz.com/regex" target="_blank" rel="noopener noreferrer">正则验证</a>，Java开发对正则表达式肯定不陌生。站长工具提供的这个正则验真工具还不错。</li>
<li><a href="http://tool.chinaz.com/regex" target="_blank" rel="noopener noreferrer">Diffchecker</a>）是一个使用很不错代码差异对比工具。使过svn或者git的人对diffcheck肯定不陌生，但有时候我们修改的文本内容并没有被版本控制，那么就可以使用在线的网站查看文件的修改情况。</li>
</ol>
<h2 id="五、对照类工具"> 五、对照类工具</h2>
<ol>
<li><a href="http://tool.oschina.net/commons?type=4" target="_blank" rel="noopener noreferrer">ASCII对照表</a></li>
<li><a href="http://tool.oschina.net/commons?type=5" target="_blank" rel="noopener noreferrer">HTTP状态码</a></li>
<li><a href="http://tool.oschina.net/commons" target="_blank" rel="noopener noreferrer">HTTP Content-type</a></li>
<li><a href="http://tool.oschina.net/commons?type=7" target="_blank" rel="noopener noreferrer">TCP/UDP常见端口参考</a></li>
<li><a href="http://tool.oschina.net/commons?type=2" target="_blank" rel="noopener noreferrer">HTML转义字符</a></li>
<li><a href="http://tool.oschina.net/commons?type=2" target="_blank" rel="noopener noreferrer">RGB颜色参考</a></li>
<li><a href="http://tool.oschina.net/commons?type=8" target="_blank" rel="noopener noreferrer">网页字体参考</a></li>
</ol>
<h2 id="六、在线代码运行"> 六、在线代码运行</h2>
<ul>
<li>在线工具的<a href="https://tool.lu/coderunner/" target="_blank" rel="noopener noreferrer">CodeRunner</a>可以在线运行php、c、c++、go、python、java、groovy等代码。</li>
<li><a href="https://c.runoob.com/" target="_blank" rel="noopener noreferrer">菜鸟工具</a>  提供的编译工具支持的语言比CodeRunner多</li>
</ul>
<h2 id="七、一个实用小插件"> 七、一个实用小插件</h2>
<p>最后，再给大家推荐一个chrome插件<code>FeHelper</code> ，这个插件中囊括了很多上面介绍的在线工具的功能，如JSON格式化、时间戳转换、Markdown工具、编码解码、加密解密、正则验证等。</p>
<div><p>转载</p>
<p><a href="https://www.hollischuang.com/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7" target="_blank" rel="noopener noreferrer">Holis</a></p>
</div>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <category term="在线工具"/>
    <contributor>
      <name>南辞</name>
    </contributor>
    <published>2021-02-18T01:11:00.000Z</published>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">在线工具网站整理</title>
    <id>http://qiqi.dreamagain.top/software/tool/online/website/</id>
    <link href="http://qiqi.dreamagain.top/software/tool/online/website/"/>
    <updated>2021-02-18T01:11:00.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p><img src="https://img.shields.io/badge/%E5%9C%A8%E7%BA%BF%E5%B7%A5%E5%85%B7-blue.svg" alt=""> <img src="https://img.shields.io/badge/%E6%95%B4%E7%90%86%E7%AF%87-blue.svg" alt=""></p>
</blockquote>

<p>在学习一些技术的时候不免要安装一些必要的软件，值得高兴的是有很多网站提供了在线工具，有一些工具还是比较实用的，比如在线编译工具。我们可以打开浏览器直接在网页上运行代码，查看效果。</p>
<p>尤其在学习机器学习、神经网络的过程中搭建环境是一项费时伤神的体力活，利用网上一些搭建好基础环境的在线工具可以帮我们快速搭建好学习环境，避免在搭建学习环境的复杂流程上浪费太多时间，可以把更多精力投入到知识体系的学习中来。</p>
<p>类似的网站还是很多的，以下是觉得还不错的一些在线工具网站</p>
<h2 id="一、基础编程"> 一、基础编程</h2>
<ul>
<li>
<p><a href="https://c.runoob.com/" target="_blank" rel="noopener noreferrer">菜鸟工具</a></p>
</li>
<li>
<p><a href="https://tool.lu/" target="_blank" rel="noopener noreferrer">在线工具</a></p>
</li>
</ul>
<h2 id="二、人工智能"> 二、人工智能</h2>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <category term="在线工具"/>
    <contributor>
      <name>南辞</name>
    </contributor>
    <published>2021-02-18T01:11:00.000Z</published>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">VPN</title>
    <id>http://qiqi.dreamagain.top/software/tool/vpn/</id>
    <link href="http://qiqi.dreamagain.top/software/tool/vpn/"/>
    <updated>2021-03-31T05:51:25.000Z</updated>
    <summary type="html"><![CDATA[<blockquote>
<p><img src="https://img.shields.io/badge/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%A2%AF%E5%AD%90-blue.svg" alt=""></p>
</blockquote>
]]></summary>
    <content type="html"><![CDATA[<blockquote>
<p><img src="https://img.shields.io/badge/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%A2%AF%E5%AD%90-blue.svg" alt=""></p>
</blockquote>

<table>
<thead>
<tr>
<th>VPN</th>
<th>特点</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://www.panhdpe.xyz/r/22216799" target="_blank" rel="noopener noreferrer">PandaVPN</a></td>
<td>海外华人开发，有免费试用</td>
</tr>
<tr>
<td><a href="https://go.nordlocker.net/aff_c?offer_id=15&amp;aff_id=38201&amp;url_id=6063&amp;aff_sub=github&amp;aff_click_id=supertz" target="_blank" rel="noopener noreferrer">NordVPN</a></td>
<td>顶级VPN品牌之一</td>
</tr>
<tr>
<td><a href="https://www.xvbelink.com/?a_fid=tizi_vpn&amp;chan=github&amp;data1=supertz" target="_blank" rel="noopener noreferrer">ExpressVPN</a></td>
<td>顶级品牌（需翻墙后购买）</td>
</tr>
<tr>
<td><a href="https://get.surfshark.net/aff_c?offer_id=6&amp;aff_id=3401" target="_blank" rel="noopener noreferrer">SurfShark</a></td>
<td>不限设备数（需翻墙后购买）</td>
</tr>
<tr>
<td><a href="https://www.ivacykodi.com/easter-deal-2020/?aff=91814&amp;data1=github&amp;data2=supertz" target="_blank" rel="noopener noreferrer">IvacyVPN</a></td>
<td>网速一流的VPN</td>
</tr>
</tbody>
</table>
<h2 id="一、pandavpn-熊猫"> 一、PandaVPN（熊猫）</h2>
<p><a href="https://www.panhdpe.xyz/r/22216799" target="_blank" rel="noopener noreferrer">熊猫VPN官网（中国区镜像），可直接打开</a></p>
<ul>
<li>
<p><strong>海外华人开发的VPN，在国内很好用</strong></p>
</li>
<li>
<p>熊猫VPN总部在美国，由海外华人团队开发，所以中文支持很好。</p>
</li>
<li>
<p>它的运营的时间并不长，是中国VPN市场的后期之秀，支持Windows，Mac，iOS，Android、Linux、Android TV几种主流设备。</p>
</li>
<li>
<p>熊猫VPN有国内可直接访问的镜像网站，购买后也可直接从那里下载客户端，无需访问应用商店。</p>
</li>
<li>
<p>在手机上测试了一个小时，非常好用，随机测了香港、美国的几个节点，连接非常快。试了试Youtube，视频的速度也很满意。</p>
</li>
<li>
<p>根据我的使用体验，PandaVPN在敏感时期的穿墙能力比较强，可能是它比较新的缘故，还没被墙特别“关照”。</p>
</li>
<li>
<p>PandaVPN建立连接的速度非常快，而且客户端里提供全局代理、分应用代理，很智能。</p>
</li>
<li>
<p>熊猫VPN支持银联、Paypal、信用卡等支付方式（以前支持支付宝，微信，可能支付被封了），付款7天内可退款。</p>
</li>
<li>
<p>目前有买一年送一年的优惠，到年底圣诞节可能有更大优惠，可以关注。</p>
</li>
</ul>
<p><strong>万一不能用，如何退款？</strong></p>
<p>Panda有7天退款政策，但申请退款需要说明理由。如果你发现它在你的设备和网络环境下不能用，可以用下列方式联系客服，客服会协助你解决问题，如果确实为软件问题造成无法使用，会给你退款：</p>
<ol>
<li>打开镜像站，点击右下角的在线客服，就可以联系到客服，要在美国工作时间联系他们。</li>
<li>写邮件给 panda7x24@gmail.com，会工作日尽快回复你。</li>
<li>PandaVPN客服支持中文，所以你可以直接用中文沟通，非常方便。</li>
</ol>
<h2 id="二、expressvpn"> 二、ExpressVPN</h2>
<p><a href="https://www.xvbelink.com/?a_fid=tizi_vpn&amp;chan=github&amp;data1=supertz" target="_blank" rel="noopener noreferrer">ExpressVPN官网镜像，需翻墙后打开</a>，可以用<a href="https://www.panhdpe.xyz/r/22216799" target="_blank" rel="noopener noreferrer">PandaVPN免费试用</a>打开再购买</p>
<ul>
<li><strong>市场上最强跨设备通用翻墙软件</strong></li>
<li>最近一个重磅新闻，2020年9月起，ExpressVPN不再提供大陆用户可直接访问的镜像，但不影响客户端本身在国内使用，ExpressVPN官方的说法是“受最近的政策原因影响”，不管厂商是什么想法，服务的退步都是我们的损失。但是，ExpressVPN仍然是穿墙能力最强的翻墙软件之一。如果想购买，可以先用<a href="https://www.panhdpe.xyz/r/22216799" target="_blank" rel="noopener noreferrer">PandaVPN免费试用</a>，获得国外IP后，到<a href="https://www.xvbelink.com/?a_fid=tizi_vpn&amp;chan=github&amp;data1=supertz" target="_blank" rel="noopener noreferrer">ExpressVPN官网</a>购买。</li>
<li>虽然ExpressVPN在特殊时期也会有点问题，但一年中97%的时间里使用都很流畅。每年不能用的时间大致在2-3个星期，会有几天时间出现连不上，ExpressVPN已经为中国网民服务了11年，是可以毫不犹豫购买的VPN，连通率应该是最高的，速度相比其他VPN软件也不慢，隐私保护技术最好，还有最重要的，客户端最好用，设备支持它最全。</li>
<li>客户端好用的VPN不少，但提供无需Google Play Store和苹果美国商店即可安装客户端的VPN厂商，恐怕ExpressVPN是仅有的几家之一，ExpressVPN还支持P2P下载，不限流量。</li>
<li>ExpressVPN真正实现全终端覆盖，包括：电脑Windows，MacOS，Linux，手机iPhone，iPad、Android，路由器Router，游戏主机PS2、XBox等。</li>
<li>ExpressVPN已通过普华永道隐私保护机制审计，ExpressVPN的无日志政策是实打实的无日志。</li>
<li>无硬盘服务器：技术上，这种服务器无法保留任何上网痕迹，重启或断掉所以信息都会被抹得一干二净。</li>
<li>智能连接：自动检测最快的服务器，自动匹配最佳节点。断线自动重连，防止流量无意间泄露，防止被监控。</li>
<li>DNS泄露保护：ExpressVPN在每台服务器上运行自己的私有加密DNS服务器，所有DNS请求都会通过这些私有的DNS服务器，严格保护隐私。</li>
<li>ExpresssVPN的缺点是它比较贵，但它是外国人在国内使用最多的软件，可见其稳定性和受信赖的程度，就好像iPhone，知道它贵，但仍然想买它。</li>
<li>ExpressVPN支持的付款方式很多，包括支付宝、银联。买一年送3个月，30天无理由退款，支持支付宝付款。</li>
<li>ExpressVPN同时支持5台设备，可配置Split Tunneling ，推荐香港、日本、新加坡、美国节点。</li>
</ul>
<p><strong>ExpressVPN提供30天内无理由退款</strong>，如果你发现它在你的设备和网络环境下用不了，你可以有两种方式联系退款：</p>
<ol>
<li>打开官网，看到右下方的“在线客服”入口，点进去就能联系客服，他们7天24小时都客服在线。</li>
<li>写邮件给 support@expressvpn.com，他们一般会在一个工作日内回复。</li>
</ol>
<p>客服不支持中文，你可以用简单一两句话来进行交流，例如：</p>
<p><code>Hi，I would like to have a refund, because your service does not work for me. My account is xxx@xxx. Thank you.</code></p>
<h2 id="三、nordvpn"> 三、NordVPN</h2>
<p><a href="https://go.nordlocker.net/aff_c?offer_id=15&amp;aff_id=38201&amp;url_id=6063&amp;aff_sub=github&amp;aff_click_id=supertz" target="_blank" rel="noopener noreferrer">NordVPN官网镜像，可直接打开</a></p>
<ul>
<li>NordVPN也是老牌的VPN，世界顶级的VPN厂商，之前有段时间在国内使用不稳定，不过经过一段时间的优化，NordVPN现在又非常好用了。</li>
<li>这个VPN有广泛的设备支持：Windows，Mac，Linux，Android，iOS … 没有ExpressVPN那么面面俱到，但能满足绝大多数用户的需要了。价格方面，比ExpressVPN要便宜不少。</li>
<li>在中国使用NordVPN不再需要特别操作，只需要点击快速连接（Quick Connect）按钮，客户端会自动连上最快连接。</li>
<li>NordVPN经常性的有促销活动，有些活动是官方说明“以后不会再有”，所以遇到活动就别犹豫了。</li>
<li>NordVPN官方还有所谓的优惠券，实际上赠送时长，一般是1个月，但与套餐绑定，必须买2年套餐才有用</li>
</ul>
<p><strong>NordVPN支持30天无理由退款</strong>，如果你发现它在你的设备和网络环境下用不了，你可以写邮件 support@nordvpn.com 要求退款：</p>
<p><code>Hi，I would like to have a refund, because your service does not work for me. My account is xxx@xxx. Thank you.</code></p>
<h2 id="四、surfshark"> 四、SurfShark</h2>
<p><a href="https://get.surfshark.net/aff_c?offer_id=6&amp;aff_id=3401" target="_blank" rel="noopener noreferrer">SurfShark官网地址，翻墙后打开</a>，可以用<a href="https://www.panhdpe.xyz/r/22216799" target="_blank" rel="noopener noreferrer">PandaVPN免费试用</a>打开再购买</p>
<ul>
<li>
<p><strong>市场上少有的不限设备数量的VPN</strong></p>
</li>
<li>
<p>不限设备数量：这可能是SurfShark最大的优点，SurfShark允许用户在任意台设备上同时使用（可以分享给很多朋友了）。</p>
</li>
<li>
<p>支持设备： SurfShark支持Windows，MacOS，Linux，iOS，Android，FireTV等设备，也提供Chrome、Firefox浏览器插件。</p>
</li>
<li>
<p>智能连接： 允许按应用区分配置流量，例如迅雷正常下载，而Chrome浏览器看海外视频，很实用。</p>
</li>
<li>
<p>安全与隐私保护： SurfShark保证严格的务日志政策，提供连接时自动断网保护，能有效防止DNS泄露。</p>
</li>
<li>
<p>SurfShark目前只能通过官网购买，要先翻墙，可以用PandaVPN的免费试用，先获取国外IP，再进行购买。</p>
</li>
</ul>
<p><strong>SurfShark提供30天退款保证</strong>，并提供7天24小时客服，如果购买后你的设备或网络环境下无法使用，可以联系客服退款：</p>
<ol>
<li>打开官网，在右下角找到“Chat”按钮，与客服沟通</li>
<li>写邮件给 support@surfshark.com</li>
</ol>
<hr>
<div><p>转载</p>
<p><a href="https://github.com/shenqianzou" target="_blank" rel="noopener noreferrer">shenqianzou</a>/<strong><a href="https://github.com/shenqianzou/tizi" target="_blank" rel="noopener noreferrer">tizi</a></strong></p>
</div>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <category term="软件使用"/>
    <contributor>
      <name>南辞</name>
    </contributor>
    <published>2021-03-31T05:51:25.000Z</published>
    <rights>Copyright by 南辞</rights>
  </entry>
</feed>