<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="zh-CN">
  <id>http://qiqi.dreamagain.top/</id>
  <title>七七部落</title>
  <subtitle>Actions speak louder than words.</subtitle>
  <author>
    <name>南辞</name>
  </author>
  <updated>2021-02-16T08:01:14.172Z</updated>
  <generator>@mr-hope/vuepress-plugin-feed</generator>
  <link rel="self" href="http://qiqi.dreamagain.top/atom.xml"/>
  <link rel="alternate" href="http://qiqi.dreamagain.top/"/>
  <rights>License MIT|Copyright © 2021 Mr.Yang</rights>
  <category term="目录"/>
  <category term="使用指南"/>
  <category term="面试"/>
  <category term="后端框架"/>
  <category term="框架"/>
  <category term="Java"/>
  <category term="编程语言"/>
  <category term="JavaScript"/>
  <category term="前端"/>
  <category term="编程开发"/>
  <category term="服务器"/>
  <category term="软件"/>
  <category term="数据库"/>
  <category term="编辑器"/>
  <category term="Git"/>
  <category term="Github"/>
  <category term="Linux"/>
  <category term="基础"/>
  <category term="软件使用"/>
  <category term="在线工具"/>
  <category term="VS Code"/>
  <contributor>
    <name>南辞</name>
  </contributor>
  <contributor>
    <name>廖雪峰</name>
  </contributor>
  <contributor>
    <name>Mr.Hope &amp; 廖雪峰</name>
  </contributor>
  <contributor>
    <name>阮一峰</name>
  </contributor>
  <contributor>
    <name>沈启民</name>
  </contributor>
  <entry>
    <title type="html">关于我</title>
    <id>http://qiqi.dreamagain.top/about/intro/</id>
    <link href="http://qiqi.dreamagain.top/about/intro/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<h2 id="自我介绍"> 自我介绍</h2>
<ul>
<li>笔名: 南辞</li>
<li>性别: 男</li>
<li>年龄: 22</li>
<li>爱好: 编程</li>
</ul>
<h2 id="联系方式"> 联系方式</h2>
<p>qq：1715261428</p>
<p>邮箱：18846770224@163.com</p>
<p>希望能在圈子里认识更多朋友。欢迎大家留言交流。</p>
<h2 id="友情链接"> 友情链接</h2>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <contributor>
      <name>南辞</name>
    </contributor>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">关于本站</title>
    <id>http://qiqi.dreamagain.top/about/site/</id>
    <link href="http://qiqi.dreamagain.top/about/site/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<h2 id="网站介绍"> 网站介绍</h2>
<p>网站使用 <a href="https://v1.vuepress.vuejs.org/zh/guide/" target="_blank" rel="noopener noreferrer">VuePress</a> 建站工具构建，主题使用 <a href="https://github.com/Mister-Hope/vuepress-theme-hope/" target="_blank" rel="noopener noreferrer">vuepress-theme-hope</a></p>
<h2 id="仓库链接"> 仓库链接</h2>
<ul>
<li><a href="https://github.com/small-universe/QiQi-Blog" target="_blank" rel="noopener noreferrer"><strong>QiQi-Blog</strong></a></li>
</ul>
<h2 id="免责声明"> 免责声明</h2>
<ul>
<li>本站内容均用于个人学习，有转载或参考的博客文章都已在每篇博客中声明，若有侵权请联系删除！</li>
</ul>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <contributor>
      <name>南辞</name>
    </contributor>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">Home</title>
    <id>http://qiqi.dreamagain.top/blog/</id>
    <link href="http://qiqi.dreamagain.top/blog/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <author>
      <name>南辞</name>
    </author>
    <contributor>
      <name>南辞</name>
    </contributor>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">目录导航</title>
    <id>http://qiqi.dreamagain.top/content/</id>
    <link href="http://qiqi.dreamagain.top/content/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <summary type="html"><![CDATA[<blockquote>
<p><img src="https://img.shields.io/badge/%E4%B8%83%E4%B8%83%E5%8D%9A%E5%AE%A2-%E7%9B%AE%E5%BD%95%E5%AF%BC%E8%88%AA-blue.svg" alt="img"></p>
</blockquote>
]]></summary>
    <content type="html"><![CDATA[<blockquote>
<p><img src="https://img.shields.io/badge/%E4%B8%83%E4%B8%83%E5%8D%9A%E5%AE%A2-%E7%9B%AE%E5%BD%95%E5%AF%BC%E8%88%AA-blue.svg" alt="img"></p>
</blockquote>

<h2 id="项目结构"> 项目结构</h2>
<blockquote>
<div><pre><code>.
├──.github
|   └── workflows
|       └── deploy-github.yml(github action 用于持续部署)
|
├── src
│   ├── .vuepress 
│   │   ├── config 
|   |   |   ├── sideBar (侧边栏)
|   |   |   |   ├── backend
|   |   |   |   ├── frontend
|   |   |   |   ├── interview
|   |   |   |   ├── software
|   |   |   |   └── index.js
|   |   |   |
|   |   |   ├── navBar.js (导航栏)
|   |   |   └── private.js (私人设置，可在.gitignore中设置不加入版本管理)
│   │   |
│   │   ├── public (引用图片资源目录约定使用&quot;/&quot;为public目录)
|   |   |   └── assets
|   |   |       ├── icon
|   |   |       └── img
|   |   |
│   │   ├── styles (自定义主题的一些样式)
│   │   │   ├── base.styl
│   │   │   ├── index.styl
│   │   │   └── palette.styl
|   |   |
│   │   └── config.js (项目的配置)
│   │ 
│   ├── about
|   |   ├── intro.md
|   |   └── site.md
|   |  
│   ├── guide
|   |   ├── markdown.md
│   │   └── template.md
|   |
│   ├── interview
|   |   ├── Java208
│   │   └── readme.md
|   |
│   ├── program
|   |   ├── backend
│   │   └── readme.md
|   |
│   ├── blog.md (博客首页)
│   ├── content.md (目录导航)
│   └── readme.md (部落主页)
|   
├── .gitignore
├── deploy.sh (手动部署脚本)
├── package.json
└── package-lock.json
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br></div></div></blockquote>
<h2 id="快速导航"> 快速导航</h2>
<p>侧边栏显示即为一级目录，点击查看相关内容</p>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <category term="目录"/>
    <contributor>
      <name>南辞</name>
    </contributor>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">element-ui插件文档</title>
    <id>http://qiqi.dreamagain.top/guide/element-ui-plugin/</id>
    <link href="http://qiqi.dreamagain.top/guide/element-ui-plugin/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <summary type="html"><![CDATA[<p><a href="https://www.npmjs.com/package/vuepress-plugin-element-ui" target="_blank" rel="noopener noreferrer"><img src="https://img.shields.io/npm/v/vuepress-plugin-element-ui.svg" alt="Version"></a> <a href="https://www.npmjs.com/package/vuepress-plugin-element-ui" target="_blank" rel="noopener noreferrer"><img src="https://img.shields.io/npm/l/vuepress-plugin-element-ui.svg" alt="License"></a> <img src="https://img.shields.io/badge/thanks-element-brightgreen.svg" alt="img"></p>
<p>Vuepress plugin - extend <a href="https://github.com/ElemeFE/element" target="_blank" rel="noopener noreferrer">Element UI</a> base on markdown-it-container</p>
]]></summary>
    <content type="html"><![CDATA[<p><a href="https://www.npmjs.com/package/vuepress-plugin-element-ui" target="_blank" rel="noopener noreferrer"><img src="https://img.shields.io/npm/v/vuepress-plugin-element-ui.svg" alt="Version"></a> <a href="https://www.npmjs.com/package/vuepress-plugin-element-ui" target="_blank" rel="noopener noreferrer"><img src="https://img.shields.io/npm/l/vuepress-plugin-element-ui.svg" alt="License"></a> <img src="https://img.shields.io/badge/thanks-element-brightgreen.svg" alt="img"></p>
<p>Vuepress plugin - extend <a href="https://github.com/ElemeFE/element" target="_blank" rel="noopener noreferrer">Element UI</a> base on markdown-it-container</p>

<h2 id="一、安装"> 一、安装</h2>
<blockquote>
<p>This plugin requires VuePress &gt;= 1.0.0, for now you can try it via yarn add vuepress@next -D</p>
</blockquote>
<div><pre><code><span>yarn</span> <span>add</span> vuepress-plugin-element-ui -D
// .vuepress/config.js
module.exports <span>=</span> <span>{</span>
  plugins: <span>[</span>
    <span>'element-ui'</span>
  <span>]</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h2 id="二、预览"> 二、预览</h2>
<h3 id="_1、el-tabs"> 1、el-tabs</h3>
<div><pre><code>:::: el-tabs
::: el-tab-pane label=markdown
<span>*</span> vue
  <span>*</span> vue-cli
  <span>*</span> nuxt
  <span>*</span> vuepress
<span>*</span> react
  <span>*</span> create-react-app
  <span>*</span> nest
:::
::: el-tab-pane label=javascript
<span><span>```</span><span> javascript</span>
<span><span>&lt;</span>span <span>class</span><span>=</span><span>"token punctuation"</span><span>></span><span>(</span><span>&lt;</span><span>/</span>span<span>></span><span>&lt;</span>span <span>class</span><span>=</span><span>"token punctuation"</span><span>></span><span>)</span><span>&lt;</span><span>/</span>span<span>></span> <span>&lt;</span>span <span>class</span><span>=</span><span>"token operator"</span><span>>=</span><span>></span><span>&lt;</span><span>/</span>span<span>></span> <span>&lt;</span>span <span>class</span><span>=</span><span>"token punctuation"</span><span>></span><span>{</span><span>&lt;</span><span>/</span>span<span>></span>
  console<span>&lt;</span>span <span>class</span><span>=</span><span>"token punctuation"</span><span>></span><span>.</span><span>&lt;</span><span>/</span>span<span>></span><span>&lt;</span>span <span>class</span><span>=</span><span>"token function"</span><span>></span>log<span>&lt;</span><span>/</span>span<span>></span><span>&lt;</span>span <span>class</span><span>=</span><span>"token punctuation"</span><span>></span><span>(</span><span>&lt;</span><span>/</span>span<span>></span><span>&lt;</span>span <span>class</span><span>=</span><span>"token string"</span><span>></span><span>'Javascript code example'</span><span>&lt;</span><span>/</span>span<span>></span><span>&lt;</span>span <span>class</span><span>=</span><span>"token punctuation"</span><span>></span><span>)</span><span>&lt;</span><span>/</span>span<span>></span>
<span>&lt;</span>span <span>class</span><span>=</span><span>"token punctuation"</span><span>></span><span>}</span><span>&lt;</span><span>/</span>span<span>></span></span>
<span>```</span></span>
:::
::::
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><el-tabs >
<el-tab-pane label=markdown>
<ul>
<li>vue
<ul>
<li>vue-cli</li>
<li>nuxt</li>
<li>vuepress</li>
</ul>
</li>
<li>react
<ul>
<li>create-react-app</li>
<li>nest</li>
</ul>
</li>
</ul>
</el-tab-pane>
<el-tab-pane label=javascript>
<div><pre><code><span>(</span><span>)</span> <span>=></span> <span>{</span>
  console<span>.</span><span>log</span><span>(</span><span>'Javascript code example'</span><span>)</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div></el-tab-pane>
</el-tabs>
<h3 id="_2、el-collapses"> 2、el-collapses</h3>
<div><pre><code>:::: el-collapse
::: el-collapse-item title="一致性 Consistency"
与现实生活一致：与现实生活的流程、逻辑保持一致，遵循用户习惯的语言和概念；
在界面中一致：所有的元素和结构需保持一致，比如：设计样式、图标和文本、元素的位置等。
:::
::: el-collapse-item title="反馈 Feedback"
控制反馈：通过界面样式和交互动效让用户可以清晰的感知自己的操作；
页面反馈：操作后，通过页面元素的变化清晰地展现当前状态。
:::
::: el-collapse-item title="效率 Efficiency"
简化流程：设计简洁直观的操作流程；
清晰明确：语言表达清晰且表意明确，让用户快速理解进而作出决策；
帮助用户识别：界面简单直白，让用户快速识别而非回忆，减少用户记忆负担。
:::
::: el-collapse-item title="可控 Controllability"
用户决策：根据场景可给予用户操作建议或安全提示，但不能代替用户进行决策；
结果可控：用户可以自由的进行操作，包括撤销、回退和终止当前操作等。
:::
::::
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><el-collapse >
<el-collapse-item title="一致性 Consistency">
<p>与现实生活一致：与现实生活的流程、逻辑保持一致，遵循用户习惯的语言和概念；</p>
<p>在界面中一致：所有的元素和结构需保持一致，比如：设计样式、图标和文本、元素的位置等。</p>
</el-collapse-item>
<el-collapse-item title="反馈 Feedback">
<p>控制反馈：通过界面样式和交互动效让用户可以清晰的感知自己的操作；</p>
<p>页面反馈：操作后，通过页面元素的变化清晰地展现当前状态。</p>
</el-collapse-item>
<el-collapse-item title="效率 Efficiency">
<p>简化流程：设计简洁直观的操作流程；</p>
<p>清晰明确：语言表达清晰且表意明确，让用户快速理解进而作出决策；</p>
<p>帮助用户识别：界面简单直白，让用户快速识别而非回忆，减少用户记忆负担。</p>
</el-collapse-item>
<el-collapse-item title="可控 Controllability">
<p>用户决策：根据场景可给予用户操作建议或安全提示，但不能代替用户进行决策；</p>
<p>结果可控：用户可以自由的进行操作，包括撤销、回退和终止当前操作等。</p>
</el-collapse-item>
</el-collapse>
<h3 id="_3、el-steps"> 3、el-steps</h3>
<div><pre><code>:::: el-steps
::: el-step title=&quot;步骤 11&quot; icon=&quot;el-icon-edit&quot;
:::
::: el-step title=&quot;步骤 2&quot; icon=&quot;el-icon-upload&quot;
:::
::: el-step title=&quot;步骤 3&quot; icon=&quot;el-icon-picture&quot;
:::
::::
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><el-steps >
<el-step title="步骤 11" icon="el-icon-edit">
</el-step>
<el-step title="步骤 2" icon="el-icon-upload">
</el-step>
<el-step title="步骤 3" icon="el-icon-picture">
</el-step>
</el-steps>
<h3 id="_4、all-componenets"> 4、All Componenets</h3>
<p>you can use all of element-ui components in below:</p>
<div><pre><code>  &#39;el-collapse-transition&#39;, &#39;el-pagination&#39;,      &#39;el-dialog&#39;,
  &#39;el-autocomplete&#39;,        &#39;el-dropdown&#39;,        &#39;el-dropdown-menu&#39;,
  &#39;el-dropdown-item&#39;,       &#39;el-menu&#39;,            &#39;el-submenu&#39;,
  &#39;el-menu-item&#39;,           &#39;el-menu-item-group&#39;, &#39;el-input&#39;,
  &#39;el-input-number&#39;,        &#39;el-radio&#39;,           &#39;el-radio-group&#39;,
  &#39;el-radio-button&#39;,        &#39;el-checkbox&#39;,        &#39;el-checkbox-button&#39;,
  &#39;el-checkbox-group&#39;,      &#39;el-switch&#39;,          &#39;el-select&#39;,
  &#39;el-option&#39;,              &#39;el-option-group&#39;,    &#39;el-button&#39;,
  &#39;el-button-group&#39;,        &#39;el-table&#39;,           &#39;el-table-column&#39;,
  &#39;el-date-picker&#39;,         &#39;el-time-select&#39;,     &#39;el-time-picker&#39;,
  &#39;el-popover&#39;,             &#39;el-tooltip&#39;,         &#39;el-breadcrumb&#39;,
  &#39;el-breadcrumb-item&#39;,     &#39;el-form&#39;,            &#39;el-form-item&#39;,
  &#39;el-tabs&#39;,                &#39;el-tab-pane&#39;,        &#39;el-tag&#39;,
  &#39;el-tree&#39;,                &#39;el-alert&#39;,           &#39;el-slider&#39;,
  &#39;el-icon&#39;,                &#39;el-row&#39;,             &#39;el-col&#39;,
  &#39;el-upload&#39;,              &#39;el-progress&#39;,        &#39;el-spinner&#39;,
  &#39;el-badge&#39;,               &#39;el-card&#39;,            &#39;el-rate&#39;,
  &#39;el-steps&#39;,               &#39;el-step&#39;,            &#39;el-carousel&#39;,
  &#39;el-scrollbar&#39;,           &#39;el-carousel-item&#39;,   &#39;el-collapse&#39;,
  &#39;el-collapse-item&#39;,       &#39;el-cascader&#39;,        &#39;el-color-picker&#39;,
  &#39;el-transfer&#39;,            &#39;el-container&#39;,       &#39;el-header&#39;,
  &#39;el-aside&#39;,               &#39;el-main&#39;,            &#39;el-footer&#39;,
  &#39;el-timeline&#39;,            &#39;el-timeline-item&#39;,   &#39;el-link&#39;,
  &#39;el-divider&#39;,             &#39;el-image&#39;,           &#39;el-calendar&#39;,
  &#39;el-backtop&#39;,             &#39;el-page-header&#39;,     &#39;el-cascader-panel&#39;,
  &#39;el-avatar&#39;,              &#39;el-drawer&#39;,          &#39;el-popconfirm&#39;
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><p>当然，你可以直接在Markdown中使用element标签，因为 vuepress是使用vue-loader来编译markdown的</p>
<div><pre><code>&lt;el-tag&gt;标签一&lt;/el-tag&gt;
&lt;el-tag type=&quot;success&quot;&gt;标签二&lt;/el-tag&gt;
&lt;el-tag type=&quot;info&quot;&gt;标签三&lt;/el-tag&gt;
&lt;el-tag type=&quot;warning&quot;&gt;标签四&lt;/el-tag&gt;
&lt;el-tag type=&quot;danger&quot;&gt;标签五&lt;/el-tag&gt;
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><el-tag>标签一</el-tag>
<el-tag type="success">标签二</el-tag>
<el-tag type="info">标签三</el-tag>
<el-tag type="warning">标签四</el-tag>
<el-tag type="danger">标签五</el-tag>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <category term="使用指南"/>
    <contributor>
      <name>南辞</name>
    </contributor>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">Markdown指南</title>
    <id>http://qiqi.dreamagain.top/guide/markdown/</id>
    <link href="http://qiqi.dreamagain.top/guide/markdown/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <summary type="html"><![CDATA[<blockquote>
<p><code>vuepress-theme-hope</code> 通过内置 <a href="https://vuepress-md-enhance.mrhope.site" target="_blank" rel="noopener noreferrer">md-enhance</a>，在 Markdown 中启用了更多的语法与新功能。</p>
</blockquote>
]]></summary>
    <content type="html"><![CDATA[<blockquote>
<p><code>vuepress-theme-hope</code> 通过内置 <a href="https://vuepress-md-enhance.mrhope.site" target="_blank" rel="noopener noreferrer">md-enhance</a>，在 Markdown 中启用了更多的语法与新功能。</p>
</blockquote>

<h2 id="一键启用"> 一键启用</h2>
<p>你可以设置 <code>themeconfig.mdEnhance.enableAll</code> 启用 <a href="https://vuepress-md-enhance.mrhope.site" target="_blank" rel="noopener noreferrer">md-enhance</a> 插件的所有功能。</p>
<div><div><br><br><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><br><br><br></div><pre><code>module<span>.</span>exports <span>=</span> <span>{</span>
    themeConfig<span>:</span> <span>{</span>
        mdEnhance<span>:</span> <span>{</span>
            enableAll<span>:</span> <span>true</span><span>,</span>
        <span>}</span><span>,</span>
    <span>}</span><span>,</span>
<span>}</span><span>;</span>
</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h2 id="新增的更多语法"> 新增的更多语法</h2>
<h3 id="上下角标"> 上下角标</h3>
<p>19<sup>th</sup> H<sub>2</sub>O</p>
<details><summary>代码</summary>
<div><pre><code>19^th^ H<span><span>~</span><span>2</span><span>~</span></span>O
</code></pre>
<div><span>1</span><br></div></div></details>
<ul>
<li><a href="https://vuepress-theme.mrhope.site/zh/guide/feature/markdown/sup-sub/" target="_blank" rel="noopener noreferrer">点击查看</a></li>
</ul>
<h3 id="自定义对齐"> 自定义对齐</h3>
<div>
<p>我是居中的</p>
</div>
<div>
<p>我在右对齐</p>
</div>
<details><summary>代码</summary>
<div><pre><code>::: center
我是居中的
:::

::: right
我在右对齐
:::
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div></details>
<ul>
<li><a href="https://vuepress-theme.mrhope.site/zh/guide/feature/markdown/align/" target="_blank" rel="noopener noreferrer">点击查看</a></li>
</ul>
<h3 id="脚注"> 脚注</h3>
<p>此文字有脚注<sup></sup>.</p>
<details><summary>代码</summary>
<div><pre><code>此文字有脚注[^first].

<span><span>[</span><span>^first</span><span>]</span><span>:</span> 这是脚注内容</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div></details>
<ul>
<li><a href="https://vuepress-theme.mrhope.site/zh/guide/feature/markdown/footnote/" target="_blank" rel="noopener noreferrer">点击查看</a></li>
</ul>
<h3 id="标记"> 标记</h3>
<p>你可以标记 <mark>重要的内容</mark> 。</p>
<details><summary>代码</summary>
<div><pre><code>你可以标记 ==重要的内容== 。
</code></pre>
<div><span>1</span><br></div></div></details>
<ul>
<li><a href="https://vuepress-theme.mrhope.site/zh/guide/feature/markdown/mark/" target="_blank" rel="noopener noreferrer">点击查看</a></li>
</ul>
<h3 id="流程图"> 流程图</h3>
<i>Not supported content</i><details><summary>代码</summary>
<div><pre><code>@flowstart
cond=>condition: Process?
process=>operation: Process
e=>end: End

cond(yes)->process->e
cond(no)->e
@flowend
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div></details>
<ul>
<li><a href="https://vuepress-theme.mrhope.site/zh/guide/feature/markdown/flowchart/" target="_blank" rel="noopener noreferrer">点击查看</a></li>
</ul>
<h3 id="tex-语法"> Tex 语法</h3>
<p class='katex-block'><span><span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:2.40003em;vertical-align:-0.95003em;"></span><span><span></span><span><span><span><span style="height:1.37144em;"><span style="top:-2.314em;"><span style="height:3em;"></span><span><span style="margin-right:0.05556em;">∂</span><span><span style="margin-right:0.03588em;">ω</span><span><span><span><span style="height:0.590392em;"><span style="top:-2.9890000000000003em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span style="margin-right:0.02778em;">r</span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span style="height:3em;"></span><span style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span style="height:3em;"></span><span><span><span style="margin-right:0.05556em;">∂</span><span><span><span><span style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span style="margin-right:0.02778em;">r</span></span></span></span></span></span></span></span></span></span></span><span>​</span></span><span><span style="height:0.686em;"><span></span></span></span></span></span><span></span></span><span style="margin-right:0.16666666666666666em;"></span><span><span style="top:0em;"><span>(</span></span><span><span></span><span><span><span><span style="height:1.341392em;"><span style="top:-2.314em;"><span style="height:3em;"></span><span><span style="margin-right:0.03588em;">ω</span></span></span><span style="top:-3.23em;"><span style="height:3em;"></span><span style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span style="height:3em;"></span><span><span><span style="margin-right:0.03588em;">y</span><span><span><span><span style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span><span style="margin-right:0.03588em;">ω</span></span></span></span></span></span></span></span></span></span></span></span><span>​</span></span><span><span style="height:0.686em;"><span></span></span></span></span></span><span></span></span><span style="top:0em;"><span>)</span></span></span><span style="margin-right:0.2777777777777778em;"></span><span>=</span><span style="margin-right:0.2777777777777778em;"></span></span><span><span style="height:3.027669em;vertical-align:-1.277669em;"></span><span><span style="top:0em;"><span>(</span></span><span><span></span><span><span><span><span style="height:1.341392em;"><span style="top:-2.314em;"><span style="height:3em;"></span><span><span style="margin-right:0.03588em;">ω</span></span></span><span style="top:-3.23em;"><span style="height:3em;"></span><span style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span style="height:3em;"></span><span><span><span style="margin-right:0.03588em;">y</span><span><span><span><span style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span><span style="margin-right:0.03588em;">ω</span></span></span></span></span></span></span></span></span></span></span></span><span>​</span></span><span><span style="height:0.686em;"><span></span></span></span></span></span><span></span></span><span style="top:0em;"><span>)</span></span></span><span style="margin-right:0.16666666666666666em;"></span><span><span style="top:0em;"><span>{</span></span><span>(</span><span>lo<span style="margin-right:0.01389em;">g</span></span><span style="margin-right:0.16666666666666666em;"></span><span style="margin-right:0.03588em;">y</span><span><span>)</span><span><span><span><span style="height:0.7143919999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span style="margin-right:0.02778em;">r</span></span></span></span></span></span></span></span><span style="margin-right:0.2222222222222222em;"></span><span>+</span><span style="margin-right:0.2222222222222222em;"></span><span><span><span><span style="height:1.6513970000000002em;"><span style="top:-1.872331em;margin-left:0em;"><span style="height:3.05em;"></span><span><span><span>i</span><span>=</span><span>1</span></span></span></span><span style="top:-3.050005em;"><span style="height:3.05em;"></span><span><span>∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span style="height:3.05em;"></span><span><span style="margin-right:0.02778em;">r</span></span></span></span><span>​</span></span><span><span style="height:1.277669em;"><span></span></span></span></span></span><span style="margin-right:0.16666666666666666em;"></span><span><span></span><span><span><span><span style="height:1.5016639999999999em;"><span style="top:-2.314em;"><span style="height:3em;"></span><span><span><span style="margin-right:0.03588em;">ω</span><span><span><span><span style="height:0.750664em;"><span style="top:-2.9890000000000003em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>i</span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span style="height:3em;"></span><span style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span style="height:3em;"></span><span><span>(</span><span>−</span><span>1</span><span><span>)</span><span><span><span><span style="height:0.824664em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>i</span></span></span></span></span></span></span></span><span style="margin-right:0.02778em;">r</span><span style="margin-right:0.16666666666666666em;"></span><span>⋯</span><span style="margin-right:0.16666666666666666em;"></span><span>(</span><span style="margin-right:0.02778em;">r</span><span style="margin-right:0.2222222222222222em;"></span><span>−</span><span style="margin-right:0.2222222222222222em;"></span><span>i</span><span style="margin-right:0.2222222222222222em;"></span><span>+</span><span style="margin-right:0.2222222222222222em;"></span><span>1</span><span>)</span><span>(</span><span>lo<span style="margin-right:0.01389em;">g</span></span><span style="margin-right:0.16666666666666666em;"></span><span style="margin-right:0.03588em;">y</span><span><span>)</span><span><span><span><span style="height:0.824664em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span><span style="margin-right:0.02778em;">r</span><span>−</span><span>i</span></span></span></span></span></span></span></span></span></span></span></span><span>​</span></span><span><span style="height:0.686em;"><span></span></span></span></span></span><span></span></span><span style="top:0em;"><span>}</span></span></span></span></span></span></span></p>
<details><summary>代码</summary>
<div><pre><code>$$
\frac {\partial^r} {\partial \omega^r} \left(\frac {y^{\omega}} {\omega}\right)
= \left(\frac {y^{\omega}} {\omega}\right) \left\{(\log y)^r + \sum_{i=1}^r \frac {(-1)^i r \cdots (r-i+1) (\log y)^{r-i}} {\omega^i} \right\}
$$
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div></details>
<ul>
<li><a href="https://vuepress-theme.mrhope.site/zh/guide/feature/markdown/tex/" target="_blank" rel="noopener noreferrer">点击查看</a></li>
</ul>
<h3 id="代码案例"> 代码案例</h3>

          <div
            id="code-demo-40b08364"
           
  
 data-title="%E4%B8%80%E4%B8%AA%E6%99%AE%E9%80%9A%20Demo"

            data-code="%7B%22html%22%3A%22%3Ch1%3EMr.Hope%3C%2Fh1%3E%5Cn%3Cp%3E%3Cspan%20id%3D%5C%22very%5C%22%3E%E5%8D%81%E5%88%86%3C%2Fspan%3E%20%E5%B8%85%3C%2Fp%3E%5Cn%22%2C%22js%22%3A%22document.querySelector(%5C%22%23very%5C%22).addEventListener(%5C%22click%5C%22%2C%20()%20%3D%3E%20%7B%5Cn%20%20%20%20alert(%5C%22%E5%8D%81%E5%88%86%E5%B8%85%5C%22)%3B%5Cn%7D)%3B%5Cn%22%2C%22css%22%3A%22span%20%7B%5Cn%20%20%20%20color%3A%20red%3B%5Cn%7D%5Cn%22%7D"
          >
              <div>
                
              </div>
              <div>
                <div>
<div><pre><code><span><span><span>&lt;</span>h1</span><span>></span></span>Mr.Hope<span><span><span>&lt;/</span>h1</span><span>></span></span>
<span><span><span>&lt;</span>p</span><span>></span></span><span><span><span>&lt;</span>span</span> <span>id</span><span><span>=</span><span>"</span>very<span>"</span></span><span>></span></span>十分<span><span><span>&lt;/</span>span</span><span>></span></span> 帅<span><span><span>&lt;/</span>p</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><div><pre><code>document<span>.</span><span>querySelector</span><span>(</span><span>"#very"</span><span>)</span><span>.</span><span>addEventListener</span><span>(</span><span>"click"</span><span>,</span> <span>(</span><span>)</span> <span>=></span> <span>{</span>
    <span>alert</span><span>(</span><span>"十分帅"</span><span>)</span><span>;</span>
<span>}</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><div><pre><code><span>span</span> <span>{</span>
    <span>color</span><span>:</span> red<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div>
            </div>
          </div>
          
        </div>
<details><summary>代码</summary>
<div><pre><code>::: demo 一个普通 Demo

​```html
<span><span><span>&lt;</span>h1</span><span>></span></span>Mr.Hope<span><span><span>&lt;/</span>h1</span><span>></span></span>
<span><span><span>&lt;</span>p</span><span>></span></span><span><span><span>&lt;</span>span</span> <span>id</span><span><span>=</span><span>"</span>very<span>"</span></span><span>></span></span>十分<span><span><span>&lt;/</span>span</span><span>></span></span> 帅<span><span><span>&lt;/</span>p</span><span>></span></span>
<span><span>```</span>
<span>
```js
document.querySelector("#very").addEventListener("click", () => {
  alert("十分帅");
});</span>
<span>```</span></span>

<span><span>```</span><span>css</span>
<span><span>&lt;span>span&lt;/span> &lt;span></span><span>{</span>&lt;/span>
  &lt;span class=<span>"token property"</span>>color&lt;/span>&lt;span class=<span>"token punctuation"</span>><span>:</span>&lt;/span> red&lt;span class=<span>"token punctuation"</span>><span>;</span>&lt;/span>
&lt;span class=<span>"token punctuation"</span>><span>}</span>&lt;/span></span>
<span>```</span></span>

:::



:::: details 代码

<span><span>```</span><span>`md</span>
<span>::: demo [react] 一个 React Demo

​```js
export default class App extends React.Component {
  constructor(props) {
    super(props);
    this.state = { message: "十分帅" };
  }
  render() {
    return (
      <span><span><span>&lt;</span>span</span> <span>class</span><span><span>=</span><span>"</span>token tag<span>"</span></span><span>></span></span><span><span><span>&lt;</span>span</span> <span>class</span><span><span>=</span><span>"</span>token tag<span>"</span></span><span>></span></span><span><span><span>&lt;</span>span</span> <span>class</span><span><span>=</span><span>"</span>token punctuation<span>"</span></span><span>></span></span>&lt;<span><span><span>&lt;/</span>span</span><span>></span></span>div<span><span><span>&lt;/</span>span</span><span>></span></span> <span><span><span>&lt;</span>span</span> <span>class</span><span><span>=</span><span>"</span>token attr-name<span>"</span></span><span>></span></span>className<span><span><span>&lt;/</span>span</span><span>></span></span><span><span><span>&lt;</span>span</span> <span>class</span><span><span>=</span><span>"</span>token attr-value<span>"</span></span><span>></span></span><span><span><span>&lt;</span>span</span> <span>class</span><span><span>=</span><span>"</span>token punctuation attr-equals<span>"</span></span><span>></span></span>=<span><span><span>&lt;/</span>span</span><span>></span></span><span><span><span>&lt;</span>span</span> <span>class</span><span><span>=</span><span>"</span>token punctuation<span>"</span></span><span>></span></span>"<span><span><span>&lt;/</span>span</span><span>></span></span>box-react<span><span><span>&lt;</span>span</span> <span>class</span><span><span>=</span><span>"</span>token punctuation<span>"</span></span><span>></span></span>"<span><span><span>&lt;/</span>span</span><span>></span></span><span><span><span>&lt;/</span>span</span><span>></span></span><span><span><span>&lt;</span>span</span> <span>class</span><span><span>=</span><span>"</span>token punctuation<span>"</span></span><span>></span></span>><span><span><span>&lt;/</span>span</span><span>></span></span><span><span><span>&lt;/</span>span</span><span>></span></span>
        Mr.Hope <span><span><span>&lt;</span>span</span> <span>class</span><span><span>=</span><span>"</span>token tag<span>"</span></span><span>></span></span><span><span><span>&lt;</span>span</span> <span>class</span><span><span>=</span><span>"</span>token tag<span>"</span></span><span>></span></span><span><span><span>&lt;</span>span</span> <span>class</span><span><span>=</span><span>"</span>token punctuation<span>"</span></span><span>></span></span>&lt;<span><span><span>&lt;/</span>span</span><span>></span></span>span<span><span><span>&lt;/</span>span</span><span>></span></span><span><span><span>&lt;</span>span</span> <span>class</span><span><span>=</span><span>"</span>token punctuation<span>"</span></span><span>></span></span>><span><span><span>&lt;/</span>span</span><span>></span></span><span><span><span>&lt;/</span>span</span><span>></span></span>{this.state.message}<span><span><span>&lt;</span>span</span> <span>class</span><span><span>=</span><span>"</span>token tag<span>"</span></span><span>></span></span><span><span><span>&lt;</span>span</span> <span>class</span><span><span>=</span><span>"</span>token tag<span>"</span></span><span>></span></span><span><span><span>&lt;</span>span</span> <span>class</span><span><span>=</span><span>"</span>token punctuation<span>"</span></span><span>></span></span>&lt;/<span><span><span>&lt;/</span>span</span><span>></span></span>span<span><span><span>&lt;/</span>span</span><span>></span></span><span><span><span>&lt;</span>span</span> <span>class</span><span><span>=</span><span>"</span>token punctuation<span>"</span></span><span>></span></span>><span><span><span>&lt;/</span>span</span><span>></span></span><span><span><span>&lt;/</span>span</span><span>></span></span>
      <span><span><span>&lt;</span>span</span> <span>class</span><span><span>=</span><span>"</span>token tag<span>"</span></span><span>></span></span><span><span><span>&lt;</span>span</span> <span>class</span><span><span>=</span><span>"</span>token tag<span>"</span></span><span>></span></span><span><span><span>&lt;</span>span</span> <span>class</span><span><span>=</span><span>"</span>token punctuation<span>"</span></span><span>></span></span>&lt;/<span><span><span>&lt;/</span>span</span><span>></span></span>div<span><span><span>&lt;/</span>span</span><span>></span></span><span><span><span>&lt;</span>span</span> <span>class</span><span><span>=</span><span>"</span>token punctuation<span>"</span></span><span>></span></span>><span><span><span>&lt;/</span>span</span><span>></span></span><span><span><span>&lt;/</span>span</span><span>></span></span>
    );
  }
}</span>
<span>```</span></span>

<span><span>```</span><span>css</span>
<span><span>&lt;span>.box-react span&lt;/span> &lt;span></span><span>{</span>&lt;/span>
  &lt;span class=<span>"token property"</span>>color&lt;/span>&lt;span class=<span>"token punctuation"</span>><span>:</span>&lt;/span> red&lt;span class=<span>"token punctuation"</span>><span>;</span>&lt;/span>
&lt;span class=<span>"token punctuation"</span>><span>}</span>&lt;/span></span>
<span>```</span></span>

:::



</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br></div></div></details>

          <div
            id="code-demo-a8b6364c"
           
  data-type="vue"
 data-title="%E4%B8%80%E4%B8%AA%20Vue%20Demo"

            data-code="%7B%22%22%3A%22%5Cn%22%7D"
          >
              <div>
                
              </div>
              <div>
                <div>
<p>​```vue
<template>
<div>
Mr.Hope <span>{{ message }}</span>
</div>
</template>
<script>
export default {
data: () =&gt; ({ message: &quot;十分帅&quot; }),
};
</script>
<style>
.box-vue span {
color: red;
}
</style></p>
<div><pre><code>
</code></pre>
<div><span>1</span><br></div></div>
            </div>
          </div>
          
        </div>
<details><summary>代码</summary>
<div><pre><code>::: demo [vue] 一个 Vue Demo

​```vue
<span><span><span>&lt;</span>template</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>box-vue<span>"</span></span><span>></span></span>
    Mr.Hope <span><span><span>&lt;</span>span</span><span>></span></span>{{ message }}<span><span><span>&lt;/</span>span</span><span>></span></span>
  <span><span><span>&lt;/</span>div</span><span>></span></span>
<span><span><span>&lt;/</span>template</span><span>></span></span>
<span><span><span>&lt;</span>script</span><span>></span></span><span><span>
<span>export</span> <span>default</span> <span>{</span>
  <span>data</span><span>:</span> <span>(</span><span>)</span> <span>=></span> <span>(</span><span>{</span> message<span>:</span> <span>"十分帅"</span> <span>}</span><span>)</span><span>,</span>
<span>}</span><span>;</span>
</span></span><span><span><span>&lt;/</span>script</span><span>></span></span>
<span><span><span>&lt;</span>style</span><span>></span></span><span><span>
<span>.box-vue span</span> <span>{</span>
  <span>color</span><span>:</span> red<span>;</span>
<span>}</span>
</span></span><span><span><span>&lt;/</span>style</span><span>></span></span>
```

:::

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div></details>

          <div
            id="code-demo-4ad68778"
           
  
 data-title="%E4%B8%80%E4%B8%AA%E6%99%AE%E9%80%9A%20Demo"

            data-code="%7B%22%22%3A%22%5Cn%60%60%60ts%5Cnconst%20message%3A%20string%20%3D%20%5C%22Mr.Hope%5C%22%3B%5Cn%5Cndocument.querySelector(%5C%22h1%5C%22).innerHTML%20%3D%20message%3B%5Cn%22%2C%22scss%22%3A%22h1%20%7B%5Cn%20%20font-style%3A%20italic%3B%5Cn%5Cn%20%20%2B%20p%20%7B%5Cn%20%20%20%20color%3A%20red%3B%5Cn%20%20%7D%5Cn%7D%5Cn%22%7D"
          >
              <div>
                
              </div>
              <div>
                <div>
<p>​```md</p>
<h1 id="标题"> 标题</h1>
<p>十分帅</p>
<div><pre><code>
```ts
const message: string = &quot;Mr.Hope&quot;;

document.querySelector(&quot;h1&quot;).innerHTML = message;
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><div><pre><code><span>h1 </span><span>{</span>
  <span>font-style</span><span>:</span> italic<span>;</span>

  <span>+ p </span><span>{</span>
    <span>color</span><span>:</span> red<span>;</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div>
            </div>
          </div>
          
        </div>
<details><summary>代码</summary>
<div><pre><code>::: demo 一个普通 Demo

​```md
<span><span>#</span> 标题</span>

十分帅
<span><span>```</span>
<span>
```ts
const message: string = "Mr.Hope";

document.querySelector("h1").innerHTML = message;</span>
<span>```</span></span>

<span><span>```</span><span>scss</span>
<span><span>&lt;span>h1 &lt;/span>&lt;span></span><span>{</span>&lt;/span>
  &lt;span class=<span>"token property"</span>>font-style&lt;/span>&lt;span class=<span>"token punctuation"</span>><span>:</span>&lt;/span> italic&lt;span class=<span>"token punctuation"</span>><span>;</span><span>&lt;/span>

  &lt;span>+ p &lt;/span>&lt;span></span><span>{</span>&lt;/span>
    &lt;span class=<span>"token property"</span>>color&lt;/span>&lt;span class=<span>"token punctuation"</span>><span>:</span>&lt;/span> red&lt;span class=<span>"token punctuation"</span>><span>;</span>&lt;/span>
  &lt;span class=<span>"token punctuation"</span>><span>}</span>&lt;/span>
&lt;span class=<span>"token punctuation"</span>><span>}</span>&lt;/span></span>
<span>```</span></span>

:::

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div></details>
<ul>
<li><a href="https://vuepress-theme.mrhope.site/zh/guide/feature/markdown/demo/" target="_blank" rel="noopener noreferrer">点击查看</a></li>
</ul>
<h3 id="幻灯片"> 幻灯片</h3>
<i>Not supported content</i><details><summary>代码</summary>
<div><pre><code>@slidestart

<span><span>##</span> 幻灯片 1</span>

一个有文字和 <span>[<span>链接</span>](<span>https://mrhope.site</span>)</span> 的段落

<span>---</span>

<span><span>##</span> 幻灯片 2</span>

<span>-</span> 列表 1
<span>-</span> 列表 2

<span>---</span>

<span><span>##</span> 幻灯片 3.1</span>

​```js
const a = 1;
```

--

<span><span>##</span> 幻灯片 3.2</span>

$$
J(\theta_0,\theta_1) = \sum_{i=0}
$$

@slideend

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br></div></div></details>
<ul>
<li><a href="https://vuepress-theme.mrhope.site/zh/guide/feature/markdown/presentation/" target="_blank" rel="noopener noreferrer">点击查看</a></li>
</ul>
<h2 id="其他语法"> 其他语法</h2>
<div><p>自定义标题</p>
<p>信息容器</p>
</div>
<div><p>自定义标题</p>
<p>提示容器</p>
</div>
<div><p>自定义标题</p>
<p>警告容器</p>
</div>
<div><p>自定义标题</p>
<p>危险容器</p>
</div>
<details><summary>自定义标题</summary>
<p>详情容器</p>
</details>
<details><summary>代码</summary>
<p>​```md</p>
<div><p>自定义标题</p>
<p>信息容器</p>
</div>
<div><p>自定义标题</p>
<p>提示容器</p>
</div>
<div><p>自定义标题</p>
<p>警告容器</p>
</div>
<div><p>自定义标题</p>
<p>危险容器</p>
</div>
<details><summary>自定义标题</summary>
<p>详情容器</p>
</details>
<div><pre><code>
</code></pre>
<div><span>1</span><br></div></div></details>
<hr>
<section>
<ol>
<li id="fn1"><p>这是脚注内容 </p>
</li>
</ol>
</section>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <category term="使用指南"/>
    <contributor>
      <name>南辞</name>
    </contributor>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">指南</title>
    <id>http://qiqi.dreamagain.top/guide/</id>
    <link href="http://qiqi.dreamagain.top/guide/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<h2 id="目录"> 目录</h2>
<ul>
<li><a href="./markdown.html">Markdown指南</a></li>
<li><a href="./template.html">页面模板</a></li>
</ul>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <category term="使用指南"/>
    <contributor>
      <name>南辞</name>
    </contributor>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">页面配置模板</title>
    <id>http://qiqi.dreamagain.top/guide/template/</id>
    <link href="http://qiqi.dreamagain.top/guide/template/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <summary type="html"><![CDATA[模板]]></summary>
    <content type="html"><![CDATA[<blockquote>
<div><pre><code><span><span>---</span>
<span><span>########## 页面信息配置 ############</span>
<span># 这是页面的图标</span>
<span>icon</span><span>:</span> page
<span># 这是文章的标题</span>
<span>title</span><span>:</span> 博文参考模板
<span># 设置当前页面内容描述</span>
<span>description</span><span>:</span> 模板
<span># 设置作者</span>
<span>author</span><span>:</span> 南辞
<span># 是否原创</span>
<span>original</span><span>:</span> <span>true</span>
<span># 设置写作时间</span>
<span>time</span><span>:</span> <span>2021-01-01</span>
<span># 一个页面只能有一个分类</span>
<span>category</span><span>:</span> 使用指南
<span># 一个页面可以有多个标签</span>
<span>tag</span><span>:</span>
    <span>-</span> 页面配置
<span># 设置当前文章是否在列表中置顶。当填入数字时，数字越大，排名越靠前</span>
<span>sticky</span><span>:</span> <span>1</span>
<span># 是否将该文章添加至文章列表中</span>
<span>article</span><span>:</span> <span>true</span>
<span># 是否将该文章添加至文章列表中</span>
<span>timeline</span><span>:</span> <span>false</span>
<span># 设置当前文章的密码</span>
<span>password</span><span>:</span> <span>123</span>
<span># 设置当前页面的预览图(分享图)</span>
<span>images</span><span>:</span> <span>"/images/1.jpg"</span>


<span>########## 页面显示配置 ###########</span>
<span># 默认显示信息</span>
pageInfo<span>:</span><span>[</span><span>'author'</span><span>,</span> <span>'visitor'</span><span>,</span> <span>'time'</span><span>,</span> <span>'category'</span><span>,</span> <span>'tag'</span><span>,</span> <span>'readtime'</span><span>]</span>
<span># 当前页面是否显示浏览量</span>
<span>visitor</span><span>:</span> <span>true</span>
<span># 当前页面是否开启路径导航</span>
<span>breadcrumb</span><span>:</span> <span>true</span>
<span># 当前页面是否开启路径导航图标</span>
<span>breadcrumbIcon</span><span>:</span> <span>true</span>
<span># 是否禁用导航栏,false会禁用</span>
<span>navbar</span><span>:</span> <span>true</span>
<span># 页面的侧边栏配置选项，支持 false 或 auto</span>
<span>sidebar</span><span>:</span> <span>'auto'</span>
<span># 该页面的侧边栏渲染深度</span>
<span>sidebarDepth</span><span>:</span> <span>4</span>
<span># 当前页面是否开启评论功能</span>
<span>comment</span><span>:</span> <span>true</span>
<span># 页脚,想要移除默认的页脚内容，设置为 '';如果你想使用默认页脚，设置为 true</span>
<span>footer</span><span>:</span> <span>true</span>
<span># 页面的自定义布局名称</span>
<span>layout</span><span>:</span> <span>""</span></span>
<span>---</span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br></div></div></blockquote>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <category term="使用指南"/>
    <contributor>
      <name>南辞</name>
    </contributor>
    <published>2020-12-27T00:00:00.000Z</published>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">vuepress使用vl-layer插件</title>
    <id>http://qiqi.dreamagain.top/guide/vl-layer/</id>
    <link href="http://qiqi.dreamagain.top/guide/vl-layer/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <summary type="html"><![CDATA[<blockquote>
<p><strong><a href="https://github.com/gjTool/vl-layer" target="_blank" rel="noopener noreferrer">vl-layer</a>vue弹窗组件，layui-layer弹窗风格</strong></p>
</blockquote>
]]></summary>
    <content type="html"><![CDATA[<blockquote>
<p><strong><a href="https://github.com/gjTool/vl-layer" target="_blank" rel="noopener noreferrer">vl-layer</a>vue弹窗组件，layui-layer弹窗风格</strong></p>
</blockquote>

<h2 id="一、安装"> 一、安装</h2>
<div><pre><code>yarn add vl-layer
</code></pre>
<div><span>1</span><br></div></div><h2 id="_2、引入"> 2、引入</h2>
<p>在enhanceApp.js文件中进行全局注册（高亮部分）</p>
<div><div><br><br><br><div>&nbsp;</div><div>&nbsp;</div><br><br><br><br><br><br><br><br><br><br><br><br><div>&nbsp;</div><br><br><br></div><pre><code><span>import</span> Vue <span>from</span> <span>"vue"</span>
<span>import</span> ElementUI <span>from</span> <span>'element-ui'</span>
<span>import</span> <span>'element-ui/lib/theme-chalk/index.css'</span>
<span>import</span> layer <span>from</span> <span>'vl-layer'</span>
<span>import</span> <span>'vl-layer/vl-layer.css'</span><span>;</span>

<span>// 使用异步函数也是可以的</span>
<span>export</span> <span>default</span> <span>(</span><span>{</span>
                    Vue<span>,</span> <span>// VuePress 正在使用的 Vue 构造函数</span>
                    <span>// options, // 附加到根实例的一些选项</span>
                    <span>// router, // 当前应用的路由实例</span>
                    <span>// siteData, // 站点元数据</span>
                    <span>// isServer, // 当前应用配置是处于 服务端渲染 或 客户端</span>
                <span>}</span><span>)</span> <span>=></span> <span>{</span>
    <span>// ...做一些其他的应用级别的优化</span>
    <span>// 全局注入组件</span>
    Vue<span>.</span><span>use</span><span>(</span>ElementUI<span>)</span><span>;</span>
    <span>Vue</span><span>.</span>prototype<span>.</span>$layer <span>=</span> <span>layer</span><span>(</span>Vue<span>)</span><span>;</span>

<span>}</span><span>;</span>
</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><h2 id="_3、测试"> 3、测试</h2>
<p>先使用作者给的例子进行测试</p>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <category term="使用指南"/>
    <contributor>
      <name>南辞</name>
    </contributor>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">vuepress从入坑到放弃</title>
    <id>http://qiqi.dreamagain.top/guide/vuepress/</id>
    <link href="http://qiqi.dreamagain.top/guide/vuepress/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <summary type="html"><![CDATA[<blockquote>
<p><img src="https://img.shields.io/badge/vuepress-blue.svg" alt=""> <img src="https://img.shields.io/badge/vuepress--theme--reco-blue.svg" alt=""></p>
<p>没有出现问题和解决问题的教程都不是好教程</p>
</blockquote>
]]></summary>
    <content type="html"><![CDATA[<blockquote>
<p><img src="https://img.shields.io/badge/vuepress-blue.svg" alt=""> <img src="https://img.shields.io/badge/vuepress--theme--reco-blue.svg" alt=""></p>
<p>没有出现问题和解决问题的教程都不是好教程</p>
</blockquote>

<p>在利用vuepress搭建个人博客的过程中参考过很多教程，最权威的教程是<a href="https://v1.vuepress.vuejs.org/zh/" target="_blank" rel="noopener noreferrer">vuepress官网</a>，其他不懂的细节再通过百度基本能解决，不过不得不说如果要自定义主题、编写自己的组件或者开发一下插件的时候，这方面的教程很少，即使是仅有的教程也没有达到我所期望的质效果。</p>
<h2 id="一、vuepress简介"> 一、vuepress简介</h2>
<p>官方介绍：https://v1.vuepress.vuejs.org/zh/guide/</p>
<p>简单整理一下</p>
<h3 id="_1、什么是vuepress"> 1、什么是vuepress</h3>
<ul>
<li>vue全家桶成员之一，尤雨溪大神于2018年4月12日推出</li>
<li><strong>vuepress = <a href="https://github.com/vuejs/vuepress/tree/master/packages/%40vuepress/core" target="_blank" rel="noopener noreferrer">极简静态网站生成器</a> + <a href="https://v1.vuepress.vuejs.org/zh/theme/default-theme-config.html" target="_blank" rel="noopener noreferrer">默认主题</a></strong></li>
</ul>
<h3 id="_2、vuepress是干什么的"> 2、vuepress是干什么的</h3>
<p>官方说明：它的诞生初衷是为了支持 Vue 及其子项目的文档需求</p>
<p>所以它最初就是用来写项目文档的，现在还支持了博客，而且有很多优秀的社区主题供我们选择</p>
<p>考虑到像github、gitee都能免费提供静态网页服务，所以利用<code>vuepress+gitee/github</code>就可以搭建起自己的博客网站，唯一需要花费的可能就是购买一个域名，不过域名也不是必须的，所以算是全程白嫖。</p>
<h3 id="_3、vuepress工作原理"> 3、vuepress工作原理</h3>
<p>还是看官方说明：事实上，一个 VuePress 网站是一个由 <a href="http://vuejs.org/" target="_blank" rel="noopener noreferrer">Vue </a>、<a href="https://github.com/vuejs/vue-router" target="_blank" rel="noopener noreferrer">Vue Router</a>和 <a href="http://webpack.js.org/" target="_blank" rel="noopener noreferrer">webpack </a>驱动的单页应用</p>
<p>所以，<strong>vuepress网站=应用</strong>。</p>
<p>我们在没有服务器的前提下就可以构建出一个应用，所以vuepress就是这么牛，吹一波尤大神。</p>
<h3 id="_4、使用体验"> 4、使用体验</h3>
<p>对于非开发人员来说，我们的目的是用vuepress来写博客和写文档，当然不希望配置流程很复杂、使用也不方便。</p>
<p>从个人体验来看，基础配置不多，很容易就可以把博客搭建起来；但是在使用的时候，因为我们要在markdown文件中写一些标签之类的东西，体验就没有像在csdn、简书等这样的系统上写博客那么好，但对于像我这样的颜控还是忍不住喜欢vuepress写出来的文档风格，其次就是可以白嫖😂，服务器续费太贵了。</p>
<p>当然用什么写博客都是看个人喜好，如果没有商业性质，个人博客只不过是自己记一些东西，方便查阅，没有几个人会看到。那些商业化的博客文章也只会是选择曝光度较好的一些博客系统。</p>
<p>接下来就从一步步看看如何搭建、使用以及做一些个人定制。</p>
<h2 id="二、开始搭建"> 二、开始搭建</h2>
<h3 id="一-创建项目目录"> （一）创建项目目录</h3>
<p>在任意位置新建一个目录<code>qiqi-algorithm</code></p>
<h3 id="二-初始化"> （二）初始化</h3>
<p>进入qiqi-blog目录中，执行下面的命令</p>
<div><pre><code><span>yarn</span> init 
或
<span>npm</span> init
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>可以一直回车，不用填任何信息</p>
<p><img src="./assets/vuepress01.png" alt=""></p>
<p>执行结束后项目下会生成<code>package.json</code>文件</p>
<div><pre><code><span>{</span>
  <span>"name"</span><span>:</span> <span>"`qiqi-algorithm`"</span><span>,</span>
  <span>"version"</span><span>:</span> <span>"1.0.0"</span><span>,</span>
  <span>"main"</span><span>:</span> <span>"index.js"</span><span>,</span>
  <span>"license"</span><span>:</span> <span>"MIT"</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><div><p>提示</p>
<p>npm 和 yarn都是包管理工具，在使用之前需要安装node.js</p>
<p>如果你还没有安装过node.js、npm、yarn这些基础环境可以参考<a href="/software/nvm/">windows下安装多版本Node.js</a></p>
</div>
<h3 id="三-安装-vuepress"> （三）安装 VuePress</h3>
<p><mark>官方推荐局部安装</mark>，听官方的准没错，给自己省点麻烦</p>
<div><pre><code><span>yarn</span> <span>add</span> -D vuepress 
或
<span>npm</span> <span>install</span> -D vuepress
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><div><p>官方提示</p>
<p>注意</p>
<p>如果你的现有项目依赖了 webpack 3.x，我们推荐使用 <a href="https://classic.yarnpkg.com/zh-Hans/" target="_blank" rel="noopener noreferrer">Yarn (opens new window)</a>而不是 npm 来安装 VuePress。因为在这种情形下，npm 会生成错误的依赖树。</p>
<p>yarn能够解决npm存在的一些问题，所以推荐还是使用yarn</p>
</div>
<h3 id="四-创建目录src"> （四）创建目录src</h3>
<p>在<code>qiqi-algorithm</code>下创建目录<code>src</code>，这个目录可以任意命名，只是后面要提交的脚本要相应改一下就行。官方是<code>docs</code></p>
<h3 id="五-package-json"> （五）<code>package.json</code></h3>
<p>在 <code>package.json</code> 中添加以下内容</p>
<div><pre><code><span>{</span>
  <span>"scripts"</span><span>:</span> <span>{</span>
    <span>"dev"</span><span>:</span> <span>"vuepress dev src"</span><span>,</span>
    <span>"build"</span><span>:</span> <span>"vuepress build src"</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>添加该内容后将把 <code>src</code>目录作为 <code>targetDir</code></p>
<p>如果按照官方创建的是docs目录，添加的内容是：</p>
<div><pre><code><span>{</span>
  <span>"scripts"</span><span>:</span> <span>{</span>
    <span>"docs:dev"</span><span>:</span> <span>"vuepress dev docs"</span><span>,</span>
    <span>"docs:build"</span><span>:</span> <span>"vuepress build docs"</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>dev、build是vuepress中的相关命令，更多命令参考：<a href="https://www.vuepress.cn/api/cli.html" target="_blank" rel="noopener noreferrer">命令行接口</a>，还可以使用 <a href="https://www.vuepress.cn/plugin/option-api.html#extendcli" target="_blank" rel="noopener noreferrer">extendCli</a> 来创建自定义命令。</p>
<p>所以可以据个人需要设置一下在此处添加更多命令</p>
<p>这里我改一下script内容为：</p>
<div><pre><code><span>{</span>
<span>"scripts"</span><span>:</span> <span>{</span>
    <span>"dev"</span><span>:</span> <span>"vuepress dev src --open --host localhost"</span><span>,</span>
    <span>"build"</span><span>:</span> <span>"vuepress build src --dest dist"</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h3 id="六-编写首页"> （六）编写首页</h3>
<p>在src目录下创建readme.md文件并在开头插入<a href="https://vuepress.vuejs.org/zh/guide/frontmatter.html" target="_blank" rel="noopener noreferrer">Front Matter</a>内容</p>
<div><pre><code><span><span>---</span>
<span><span>home</span><span>:</span> <span>true</span>
<span>heroImage</span><span>:</span> /logo.png
<span>heroText</span><span>:</span> 七七算法
<span>tagline</span><span>:</span> welcome
<span>actionText</span><span>:</span> 了解更多 →
<span>actionLink</span><span>:</span> /
<span>features</span><span>:</span>
<span>-</span> <span>title</span><span>:</span> 简洁至上
  <span>details</span><span>:</span> 以 Markdown 为中心的项目结构，以最少的配置帮助你专注于写作。
<span>-</span> <span>title</span><span>:</span> Vue驱动
  <span>details</span><span>:</span> 享受 Vue + webpack 的开发体验，在 Markdown 中使用 Vue 组件，同时可以使用 Vue 来开发自定义主题。
<span>-</span> <span>title</span><span>:</span> 高性能
  <span>details</span><span>:</span> VuePress 为每个页面预渲染生成静态的 HTML，同时在页面被加载的时候，将作为 SPA 运行。
<span>footer</span><span>:</span> Copyright © 2021 Mr·Yang</span>
<span>---</span></span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><h3 id="七-在本地启动服务器"> （七）在本地启动服务器</h3>
<p>根据第五步执行相关命令</p>
<p>按照官网来启动命令是：</p>
<div><pre><code><span>yarn</span> docs:dev 
或
<span>npm</span> run docs:dev
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>按照我自己配置的就应该是：</p>
<div><pre><code><span>yarn</span> dev 
或
<span>npm</span> run dev
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>此时<code>package.json</code>完整内容应该是这样</p>
<div><pre><code><span>{</span>
  <span>"name"</span><span>:</span> <span>"qiqi-algorithm"</span><span>,</span>
  <span>"version"</span><span>:</span> <span>"1.0.0"</span><span>,</span>
  <span>"main"</span><span>:</span> <span>"index.js"</span><span>,</span>
  <span>"scripts"</span><span>:</span> <span>{</span>
    <span>"dev"</span><span>:</span> <span>"vuepress dev src --open --host localhost"</span><span>,</span>
    <span>"build"</span><span>:</span> <span>"vuepress build src --dest dist"</span>
  <span>}</span><span>,</span>
  <span>"license"</span><span>:</span> <span>"MIT"</span><span>,</span>
  <span>"devDependencies"</span><span>:</span> <span>{</span>
    <span>"vuepress"</span><span>:</span> <span>"^1.8.1"</span>
  <span>}</span>
<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><div><p>提示</p>
<p>不按照官网主要是为了更直观看到那些地方可以自定义</p>
</div>
<p>运行结果：</p>
<p><img src="./assets/vuepress02.png" alt=""></p>
<p>能运行出来说明配置没有出错，仔细看还有圈出来的基础地方没有显示，说明我们还要接着做一些配置</p>
<p>官网里也详细指出我们接下来的工作了：</p>
<img src="./assets/vuepress03.png"/>
<h3 id="八-创建基本项目结构"> （八）创建基本项目结构</h3>
<p>官方只有<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.vuepress.cn%2Fguide%2Fdirectory-structure.html" target="_blank" rel="noopener noreferrer">推荐目录结构</a>，并没有现成的cli，所以需要通过命令行或手动创建如下结构：</p>
<div><pre><code>qiqi<span>-</span>algorithm
├─package<span>.</span>json
├─docs
<span>|</span>  ├─readme<span>.</span>md
<span>|</span>  ├─<span>.</span>vuepress
<span>|</span>  <span>|</span>     ├─config<span>.</span>js
<span>|</span>  <span>|</span>     ├─<span>public</span>
<span>|</span>  <span>|</span>     <span>|</span>   └logo<span>.</span>png
<span>|</span>  <span>|</span>     <span>|</span>   └favicon<span>.</span>ico
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>其中有后缀的是文件，没后缀的是文件夹</p>
<h3 id="九-配置config-js"> （九）配置config.js</h3>
<p>该文件为项目最重要的配置文件，几乎所有配置项都是在此进行。</p>
<p>我们先来一个最简单的配置看看效果：</p>
<div><pre><code>module<span>.</span>exports <span>=</span> <span>{</span>
    title<span>:</span> <span>'七七算法'</span><span>,</span>
    head<span>:</span> <span>[</span> <span>// 注入到当前页面的 HTML &lt;head> 中的标签</span>
      <span>[</span><span>'link'</span><span>,</span> <span>{</span> rel<span>:</span> <span>'icon'</span><span>,</span> href<span>:</span> <span>'/favicon.ico'</span> <span>}</span><span>]</span><span>,</span> <span>// 增加一个自定义的 favicon(网页标签的图标)</span>
    <span>]</span><span>,</span>
    themeConfig<span>:</span> <span>{</span>
      logo<span>:</span> <span>'/logo.png'</span><span>,</span>  <span>// 左上角logo</span>
      nav<span>:</span><span>[</span> <span>// 导航栏配置</span>
        <span>{</span>text<span>:</span> <span>'首页'</span><span>,</span> link<span>:</span> <span>'/'</span> <span>}</span><span>,</span>
        <span>{</span>text<span>:</span> <span>'侧边栏测试'</span><span>,</span> link<span>:</span> <span>'/sidebar'</span> <span>}</span><span>,</span>
        <span>{</span>text<span>:</span> <span>'七七部落'</span><span>,</span> link<span>:</span> <span>'http://qiqi.dreamagain.top'</span> <span>}</span><span>,</span> 
      <span>]</span><span>,</span>
      sidebar<span>:</span> <span>'auto'</span><span>,</span> <span>// 配置为自动生成侧边栏</span>
    <span>}</span>
  <span>}</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>详细配置可直接查询<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.vuepress.cn%2Fconfig%2F%23%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE" target="_blank" rel="noopener noreferrer">官网-config配置</a>
<strong>注意：路由根路径为src文件夹，静态资源（图片）根路径为public文件夹</strong>，这是vuepress约定的</p>
<p>在src下新建：sidebar.md</p>
<div><pre><code><span><span>---</span>
<span><span>title</span><span>:</span> 侧边栏测试</span>
<span>---</span></span>
<span><span>##</span> 二级标题01</span>

<span><span>###</span> 三级标题01-1</span>

<span><span>##</span> 二级标题02</span>

<span><span>###</span> 三级标题02-1 </span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h3 id="十-再次启动项目"> （十）再次启动项目</h3>
<p><code>yarn run dev</code></p>
<p>效果如下：</p>
<img src="./assets/vuepress04.png" style="zoom: 80%;" />
<img src="./assets/vuepress05.png" style="zoom: 80%;" />
<p>我们配置的title、nav、sidebar、logo全都生效了！</p>
<p>到这里一个极简的框架已经搭建起来了</p>
<p>这里默认使用的是<strong>官方默认主题</strong>：</p>
<ul>
<li>左上角的logo与title</li>
<li>右上角的全局搜索框与nav导航栏</li>
<li>左侧的sidebar导航栏（自动将md一级标题设置为导航文案）</li>
<li>右侧的markdown内容</li>
</ul>
<p><strong>注意：项目自带热更新; 但config.js有时可能会热更新失败，需要重启项目</strong></p>
<h2 id="三、详细配置"> 三、详细配置</h2>
<p>接下来参照官网<a href="https://www.vuepress.cn/guide/basic-config.html" target="_blank" rel="noopener noreferrer">基本配置</a>进行一些更细节的配置</p>
<h3 id="一-更换主题"> （一）更换主题</h3>
<div><p>主题</p>
<p><strong>主题分类：</strong></p>
<ul>
<li>默认主题</li>
<li>自定义主题</li>
</ul>
<p>默认主题样式比较简洁，如果要使用丰富样式的主题就使用官方或社区提供的一些自定义主题，如果实力允许你也可以开发一个自定义主题。不想那么麻烦，但默认主题又不满足需求？那就在默认主题基础上做一些修改，以满足需求。</p>
</div>
<p>可以在<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.npmjs.com%2F" target="_blank" rel="noopener noreferrer">npm官网</a>中输入<code>vuepress-theme</code>寻找自己喜欢的主题，其中以 @vuepress/theme- 开头的主题是官方维护的主</p>
<p>这里使用  <a href="https://github.com/vuepress-reco/vuepress-theme-reco" target="_blank" rel="noopener noreferrer">vuepress-theme-reco</a>，<a href="https://vuepress-reco-doc.now.sh/views/1.x/" target="_blank" rel="noopener noreferrer">官方文档</a></p>
<p>该主题提供了快速构建的脚手架，这里选择yarn安装</p>
<p><strong>使用脚手架安装</strong></p>
<div><pre><code>// 安装脚手架
<span>yarn</span> <span>add</span> global @vuepress-reco/theme-cli

// 初始化
theme-cli init reco-demo

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>执行<code>theme-cli init reco-demo</code>命令后根据提示填写相关信息</p>
<div><pre><code>PS F:<span>\</span>program<span>\</span>我的博客<span>\</span>qiqi-algorithm<span>></span> theme-cli init reco-demo
? What<span>'s the name of new directory? reco-demo
? What'</span>s the title of your project? reco-demo
? What<span>'s the description of your project? Create a blog template with vuepress-theme-reco.
? What'</span>s the author<span>'s name? nanci
? What style do you want your home page to be?(Select afternoon-grocery, if you want to download reco_luan'</span>s <span>'午后南杂'</span><span>)</span>? What style <span>do</span> you want your home page to be?<span>(</span>Select afternoon-grocery, <span>if</span> you want to download reco_luan<span>'s '</span>午后南杂<span>')? What style do you want your home page to be?(Select afternoon-grocery, if you want to download reco_luan'</span>s <span>'午后南杂'</span><span>)</span>? What style <span>do</span> you want your home page to be?<span>(</span>Select afternoon-grocery, <span>if</span> you want to download reco_luan<span>'s '</span>午后南杂'<span>)</span> 
<span>></span> blog
  doc
  afternoon-grocery

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><blockquote>
<p>&gt;blog</p>
<p>doc</p>
<p>afternoon-grocery</p>
</blockquote>
<p>通过上下键来选择，这里选择blog，回车</p>
<p>继续执行以下命令</p>
<div><pre><code><span>yarn</span> <span>install</span>

<span># run</span>
<span>yarn</span> dev

<span># build</span>
<span>yarn</span> build
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>运行效果：</p>
<p><img src="./assets/vuepress06.png" alt=""></p>
<p>查看项目的目录结构和package.json文件</p>
<p><img src="./assets/vuepress28.png" alt=""></p>
<p>说明是把项目根目录作为 <code>targetDir</code>，如果要按照官方推荐的目录就手动改一下，不过改不改这都无伤大雅。</p>
<div><p>官方说明</p>
<p>vuepress官网也提供了 <a href="https://www.vuepress.cn/theme/using-a-theme.html" target="_blank" rel="noopener noreferrer">使用主题</a> 的方法</p>
<p><strong>使用社区主题</strong></p>
<div><pre><code><span>// .vuepress/config.js</span>
module<span>.</span>exports <span>=</span> <span>{</span>
  theme<span>:</span> <span>'vuepress-theme-xx'</span>
<span>}</span>

<span>// 主题名以 vuepress-theme- 开头，可以使用缩写来省略这个前缀：</span>
module<span>.</span>exports <span>=</span> <span>{</span>
  theme<span>:</span> <span>'xxx'</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p><strong>使用官方主题</strong></p>
<div><pre><code><span>// .vuepress/config.js</span>
module<span>.</span>exports <span>=</span> <span>{</span>
  theme<span>:</span> <span>'@org/vuepress-theme-xxx'</span><span>,</span> <span>//一个官方主题: '@vuepress/theme-xxx'</span>
<span>}</span>
<span>// 缩写</span>
module<span>.</span>exports <span>=</span> <span>{</span>
  theme<span>:</span> <span>'@org/xxx'</span><span>,</span> <span>// 或者一个官方主题: '@vuepress/xxx'</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>所以如果你不想使用开始搭建，而是在旧项目中使用，可以像官方介绍的这样来安装</p>
<p>1、安装</p>
<div><pre><code><span>yarn</span> <span>add</span> vuepress-theme-reco
</code></pre>
<div><span>1</span><br></div></div><p>2、引用</p>
<div><pre><code>// .vuepress/config.js

module.exports <span>=</span> <span>{</span>
  theme: <span>'reco'</span>
<span>}</span>  
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div></div>
<p><strong>查看<code>package.json</code></strong></p>
<div><pre><code><span>{</span>
  <span>"name"</span><span>:</span> <span>"reco-demo"</span><span>,</span>
  <span>"version"</span><span>:</span> <span>"1.0.0"</span><span>,</span>
  <span>"author"</span><span>:</span> <span>"nanci"</span><span>,</span>
  <span>"scripts"</span><span>:</span> <span>{</span>
    <span>"dev"</span><span>:</span> <span>"vuepress dev . --open --host \"localhost\""</span><span>,</span>
    <span>"build"</span><span>:</span> <span>"vuepress build ."</span>
  <span>}</span><span>,</span>
  <span>"devDependencies"</span><span>:</span> <span>{</span>
    <span>"vuepress"</span><span>:</span> <span>"1.7.1"</span><span>,</span>
    <span>"vuepress-theme-reco"</span><span>:</span> <span>"1.6.1"</span>
  <span>}</span><span>,</span>
  <span>"description"</span><span>:</span> <span>"Create a blog template with vuepress-theme-reco."</span>
<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p><strong>更新依赖</strong>（3种方式）</p>
<ol>
<li>下载npm-check-updates</li>
<li>yarn upgrade-interactive --latest</li>
<li>yarn upgrade package@version</li>
</ol>
<p><strong>1、第一种</strong></p>
<div><pre><code>// 先下载
<span>yarn</span> global <span>add</span> npm-check-updates

// 更新包（yarn.lock和package.json同步更新）
ncu --upgrade --upgradeAll <span>&amp;&amp;</span> <span>yarn</span> upgrade
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p><strong>2、第二种</strong></p>
<div><pre><code><span>yarn</span> upgrade-interactive --latest
// 需要手动选择升级的依赖包，按空格键选择，a 键切换所有，i 键反选选择
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><strong>3、第三种</strong></p>
<div><pre><code><span>yarn</span> upgrade package@version
// yarn.lock和package.json都会更新，但是会进行版本锁定 <span>"echarts"</span><span>:</span> <span>"4.2.0-rc.2"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><div><p>参考</p>
<p><a href="https://blog.csdn.net/qq_37939251/article/details/107832805" target="_blank" rel="noopener noreferrer">多纤果冻</a></p>
</div>
<div><p>提示</p>
<ul>
<li>yarn upgrade  依赖包小版本升级</li>
<li>yarn upgrade-interactive --latest  大版本升级。忽略package.json指定的版本范围，并使用latest注册表中标记的版本。
大版本升级会让你手动选择要升级的工具包，尽量选择范围调整到最小，以防止项目出现问题</li>
<li>小版本升级一般不会影响现在的工具使用，大版本升级要慎用，由于最新的ES语法babel不能识别，特地将babel进行了大版本升级。</li>
</ul>
<p><mark>推荐使用第二种<code>yarn upgrade-interactive --latest</code>不需要安装过多的依赖就可以达到目的</mark></p>
</div>
<p>大胆尝试更新，运行报错无法解决我们再退回到以前版本即可。</p>
<p>执行命令后依赖版本如下:</p>
<div><pre><code><span>{</span>
  <span>"name"</span><span>:</span> <span>"reco-demo"</span><span>,</span>
  <span>"version"</span><span>:</span> <span>"1.0.0"</span><span>,</span>
  <span>"author"</span><span>:</span> <span>"nanci"</span><span>,</span>
  <span>"scripts"</span><span>:</span> <span>{</span>
    <span>"dev"</span><span>:</span> <span>"vuepress dev . --open --host \"localhost\""</span><span>,</span>
    <span>"build"</span><span>:</span> <span>"vuepress build ."</span>
  <span>}</span><span>,</span>
  <span>"devDependencies"</span><span>:</span> <span>{</span>
    <span>"vuepress"</span><span>:</span> <span>"1.8.1"</span><span>,</span>
    <span>"vuepress-theme-reco"</span><span>:</span> <span>"1.6.4"</span>
  <span>}</span><span>,</span>
  <span>"description"</span><span>:</span> <span>"Create a blog template with vuepress-theme-reco."</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><blockquote>
<p>测试运行</p>
</blockquote>
<p>发现页面空白，后台也没有任何报错信息</p>
<p>去到github官网查看<a href="https://github.com/vuepress-reco/vuepress-theme-reco/releases" target="_blank" rel="noopener noreferrer"><code>vuepress-theme-reco</code>的发布版本</a>，当前已发布版本如下：</p>
<p><img src="./assets/vuepress07.png" alt=""></p>
<p>发现1.6.2、1.6.3、1.6.4 才是最近发布的，可能存在不少bug，我们还是使用之前的1.6.1版本。</p>
<p>测试发现只要改用<code>&quot;vuepress-theme-reco&quot;: &quot;1.6.1&quot;</code>就能正常显示，所以在更新依赖的时候不更新<code>vuepress-theme-reco</code>就可以了</p>
<blockquote>
<p>修改配置文件config.js</p>
</blockquote>
<p>修改的同时我们也可以安装一些实用的插件</p>
<div><pre><code>// 阅读进度条
<span>yarn</span> <span>add</span> vuepress-plugin-reading-progress 
// 代码一键复制
<span>yarn</span> <span>add</span> @mr-hope/vuepress-plugin-copy-code 
或
<span>yarn</span> <span>add</span> @xiaopanda/vuepress-plugin-code-copy
// RSS
<span>yarn</span> <span>add</span> @vuepress-reco/vuepress-plugin-rss 
// 加载进度条
<span>yarn</span> <span>add</span> @vuepress/plugin-nprogress 
// 音乐
<span>yarn</span> <span>add</span> vuepress-plugin-meting 
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p><strong>config.js</strong>完整内容如下：</p>
<div><pre><code>module<span>.</span>exports <span>=</span> <span>{</span>
  host<span>:</span> <span>"127.0.0.1"</span><span>,</span> <span>// 生成网页地址（本地调试使用）</span>
  port<span>:</span> <span>"65535"</span><span>,</span> <span>// 生成网页端口（本地调试使用）</span>
  title<span>:</span> <span>"reco-demo"</span><span>,</span> <span>// 显示在左上角的网页名称以及首页在浏览器标签显示的title名称</span>
  description<span>:</span> <span>"A blog template with vuepress-theme-reco."</span><span>,</span> <span>// meta 中的描述文字，用于SEO</span>
  head<span>:</span> <span>[</span>
    <span>[</span><span>"link"</span><span>,</span> <span>{</span> rel<span>:</span> <span>"icon"</span><span>,</span> href<span>:</span> <span>"/favicon.svg"</span> <span>}</span><span>]</span><span>,</span> <span>//浏览器的标签栏的网页图标,基地址/.vuepress/public</span>
    <span>[</span>
      <span>"meta"</span><span>,</span>
      <span>{</span>
        name<span>:</span> <span>"viewport"</span><span>,</span>
        content<span>:</span> <span>"width=device-width,initial-scale=1,user-scalable=no"</span><span>,</span>
      <span>}</span><span>,</span>
    <span>]</span><span>,</span> <span>//在移动端，搜索框在获得焦点时会放大</span>
  <span>]</span><span>,</span>
  theme<span>:</span> <span>"reco"</span><span>,</span> <span>//选择主题‘reco’</span>
  themeConfig<span>:</span> <span>{</span>
    type<span>:</span> <span>"blog"</span><span>,</span> <span>//选择类型博客</span>
    fullscreen<span>:</span> <span>true</span><span>,</span>
    blogConfig<span>:</span> <span>{</span>
      category<span>:</span> <span>{</span>
        location<span>:</span> <span>2</span><span>,</span> <span>// 在导航栏菜单中所占的位置，默认2</span>
        text<span>:</span> <span>"分类"</span><span>,</span> <span>// 默认 “分类”</span>
      <span>}</span><span>,</span>
      tag<span>:</span> <span>{</span>
        location<span>:</span> <span>3</span><span>,</span> <span>// 在导航栏菜单中所占的位置，默认3</span>
        text<span>:</span> <span>"标签"</span><span>,</span> <span>// 默认 “标签”</span>
      <span>}</span><span>,</span>
      socialLinks<span>:</span> <span>[</span>
        <span>{</span> icon<span>:</span> <span>"reco-github"</span><span>,</span> link<span>:</span> <span>"https://github.com/small-universe"</span> <span>}</span><span>,</span>
        <span>{</span> icon<span>:</span> <span>"reco-qq"</span><span>,</span> link<span>:</span> <span>"tencent://AddContact/?fromId=50&amp;fromSubId=1&amp;subcmd=all&amp;uin=1715261428"</span> <span>}</span><span>,</span>
        <span>{</span> icon<span>:</span> <span>"reco-mail"</span><span>,</span> link<span>:</span> <span>"mailto:18846770224@163.com"</span> <span>}</span><span>,</span>
        <span>{</span> icon<span>:</span> <span>"reco-gitee"</span><span>,</span> link<span>:</span> <span>"https://gitee.com/small-universe"</span> <span>}</span><span>,</span>
        <span>{</span> icon<span>:</span> <span>"reco-csdn"</span><span>,</span> link<span>:</span> <span>"https://blog.csdn.net/qq_39839033/"</span>  <span>}</span><span>,</span>
      <span>]</span><span>,</span>
    <span>}</span><span>,</span>
    nav<span>:</span> <span>[</span>
      <span>//导航栏设置</span>
      <span>{</span>text<span>:</span> <span>'首页'</span><span>,</span> link<span>:</span> <span>'/'</span><span>,</span> icon<span>:</span> <span>'reco-home'</span><span>}</span><span>,</span>
    <span>{</span> text<span>:</span> <span>"时间线"</span><span>,</span> link<span>:</span> <span>"/timeline/"</span><span>,</span> icon<span>:</span> <span>"reco-date"</span> <span>}</span><span>,</span>
    <span>{</span>
        text<span>:</span> <span>"联系"</span><span>,</span>
        icon<span>:</span> <span>"reco-message"</span><span>,</span>
        items<span>:</span> <span>[</span>
            <span>{</span>text<span>:</span> <span>'七七部落'</span><span>,</span> link<span>:</span> <span>'http://qiqi.dreamagain.top/'</span><span>,</span> icon<span>:</span> <span>'reco-logo'</span><span>}</span><span>,</span>
            <span>{</span>text<span>:</span> <span>'GitHub'</span><span>,</span> link<span>:</span> <span>'https://github.com/small-universe/qiqi-algorithm'</span><span>,</span> icon<span>:</span> <span>'reco-github'</span><span>}</span><span>,</span>
            <span>{</span>text<span>:</span> <span>"CSDN"</span><span>,</span> link<span>:</span> <span>"https://blog.csdn.net/qq_27961843/"</span><span>,</span> icon<span>:</span> <span>"reco-csdn"</span><span>}</span><span>,</span>
            <span>{</span>text<span>:</span> <span>"QQ"</span><span>,</span> link<span>:</span> <span>"tencent://message/?uin=1715261428"</span><span>,</span> icon<span>:</span> <span>"reco-qq"</span><span>}</span><span>,</span>
            <span>{</span>text<span>:</span> <span>"Gmail"</span><span>,</span> link<span>:</span> <span>"mailto:18846770224@163.com"</span><span>,</span> icon<span>:</span> <span>"reco-mail"</span><span>}</span><span>,</span>
        <span>]</span><span>,</span>
    <span>}</span><span>,</span>
    <span>]</span><span>,</span>

    <span>// displayAllHeaders: true, // 默认值：false</span>
    subSidebar<span>:</span> <span>"auto"</span><span>,</span>

    record<span>:</span> <span>"滇ICP备20004889号-1"</span><span>,</span>
    recordLink<span>:</span> <span>"https://icp.chinaz.com/home/info?host=dreamagain.top"</span><span>,</span>
    <span>// cyberSecurityRecord: "全国互联网安全管理服务平台",</span>
    <span>// cyberSecurityLink:</span>
    <span>//   "http://www.beian.gov.cn/portal/registerSystemInfo",</span>
    startYear<span>:</span> <span>"2021"</span><span>,</span> <span>// 项目开始时间，只填写年份</span>
    lastUpdated<span>:</span> <span>"最后更新时间"</span><span>,</span> <span>// string | boolean</span>
    author<span>:</span> <span>"nanci"</span><span>,</span>
    authorAvatar<span>:</span> <span>"/avatar.jpg"</span><span>,</span> <span>//作者头像</span>
    mode<span>:</span> <span>"light"</span><span>,</span> <span>//默认显示白天模式</span>
    codeTheme<span>:</span> <span>"okaidia"</span><span>,</span> <span>// default 'tomorrow'</span>
    smooth<span>:</span> <span>"true"</span><span>,</span> <span>//平滑滚动</span>
    <span>// 评论设置,结合github actions使用，避免暴露个人重要信息</span>
    valineConfig<span>:</span> <span>{</span>
      appId<span>:</span> process<span>.</span>env<span>.</span><span>LEANCLOUD_APP_ID</span><span>,</span>
      appKey<span>:</span> process<span>.</span>env<span>.</span><span>LEANCLOUD_APP_KEY</span><span>,</span>
    <span>}</span><span>,</span>
  <span>}</span><span>,</span>
  markdown<span>:</span> <span>{</span>
    lineNumbers<span>:</span> <span>true</span><span>,</span> <span>//代码显示行号</span>
  <span>}</span><span>,</span> <span>// 搜索设置</span>
  search<span>:</span> <span>true</span><span>,</span>
  searchMaxSuggestions<span>:</span> <span>10</span><span>,</span> <span>// 插件</span>
  plugins<span>:</span> <span>[</span>
    <span>// 音乐</span>
    <span>[</span>
      <span>"meting"</span><span>,</span>
      <span>{</span>
        <span>// metingApi: "https://meting.sigure.xyz/api/music",</span>
        meting<span>:</span> <span>{</span>
          server<span>:</span> <span>"netease"</span><span>,</span>
          type<span>:</span> <span>"playlist"</span><span>,</span>
          <span>// 歌单id</span>
          mid<span>:</span> <span>"3047591896"</span><span>,</span>
        <span>}</span><span>,</span>
        aplayer<span>:</span> <span>{</span>
          lrcType<span>:</span> <span>3</span><span>,</span>
          theme<span>:</span> <span>"#3489fd"</span><span>,</span>
        <span>}</span><span>,</span>
      <span>}</span><span>,</span>
    <span>]</span><span>,</span>
    <span>// ],</span>
    <span>[</span>
      <span>"@vuepress-reco/vuepress-plugin-rss"</span><span>,</span> <span>//RSS插件</span>
      <span>{</span>
        site_url<span>:</span> <span>"http://algorithm.dreamagain.top"</span><span>,</span> <span>//网站地址</span>
        copyright<span>:</span> <span>"nanci"</span><span>,</span> <span>//版权署名</span>
      <span>}</span><span>,</span>
    <span>]</span><span>,</span>
    <span>[</span><span>"@vuepress/nprogress"</span><span>]</span><span>,</span> <span>// 加载进度条</span>
    <span>[</span><span>"reading-progress"</span><span>]</span><span>,</span> <span>// 阅读进度条</span>
    <span>[</span><span>"vuepress-plugin-code-copy"</span><span>]</span><span>,</span> <span>//一键复制代码插件</span>
  <span>]</span><span>,</span>
<span>}</span><span>;</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br><span>96</span><br><span>97</span><br><span>98</span><br><span>99</span><br><span>100</span><br><span>101</span><br><span>102</span><br><span>103</span><br><span>104</span><br><span>105</span><br><span>106</span><br><span>107</span><br><span>108</span><br><span>109</span><br><span>110</span><br><span>111</span><br></div></div><h3 id="二-修改主题"> （二）修改主题</h3>
<blockquote>
<p><strong>添加图标</strong></p>
</blockquote>
<p>主题有默认图标，如果还不满足需求，怎么办？引入阿里妈妈提供的矢量图标库</p>
<p><strong>第一步：</strong></p>
<p>首先你需要登录并创建自己的一下项目，如下示例：</p>
<img src="./assets/vuepress08.png" style="zoom: 80%;" />
<p>为了统一图标前缀，新建一个项目<code>reco-demo</code>并添加一个gitee的图标，如下图所示：</p>
<p><mark>新建项目reco-demo</mark> :</p>
<img src="./assets/vuepress09.png" style="zoom:80%;" />
<p><mark>添加图标gitee</mark> ：</p>
<img src="./assets/vuepress10.png" style="zoom: 50%;" />
<p><strong>第二步：</strong></p>
<p>在.vuepress/styles/下创建一个index.styl文件，将上图所示的代码添加进去</p>
<div><pre><code>//.vuepress/styles/index.styl

@import <span>'//at.alicdn.com/t/font_2372941_unkgma3bras.css'</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>这也是上面配置<code>config.js</code>留下的一个小坑，个人信息栏没有显示<strong>gitee</strong>，也就是默认图标库中没有<code>reco-gitee</code>这个图标</p>
<p><img src="./assets/vuepress11.png" alt=""></p>
<p><strong>第三步：</strong></p>
<p>运行测试，图标可以正常显示。在其他地方扩展图标也是按照这样的步骤来就可以</p>
<p><img src="./assets/vuepress12.png" alt=""></p>
<h3 id="三-修改默认主题"> （三）修改默认主题</h3>
<p>在使用默认主题的情况下可将默认主题的各功能组件释放出来，只需执行命令：</p>
<div><pre><code> vuepress <span>eject</span> docs
</code></pre>
<div><span>1</span><br></div></div><p>你会发现，在根目录下，多了一个theme文件夹，如下：</p>
<p><img src="./assets/vuepress13.png" alt=""></p>
<p>上图列出了主要的布局组件，只需在其中做适量修改以满足业务需求即可。</p>
<p>不过我们用的<code>vuepress-theme-reco</code>主题已经很强大了，没有必要花费太多精力在搭建博客上面，而是花更多的时间在内容创作上。</p>
<div><p>提示</p>
<ul>
<li>学习的话可以花些时间捣鼓捣鼓</li>
<li>使用的话可以直接略过</li>
</ul>
</div>
<h3 id="四-客户端增强"> （四）客户端增强</h3>
<p>如果你想对自己的应用做一些优化，比如使用router做登录拦截、给vue实例挂载全局变量或注册其他组件等，可以在.vuepress下新建文件<code>enhanceApp.js</code>：</p>
<div><pre><code><span>export</span> <span>default</span> <span>(</span><span>{</span>
  Vue<span>,</span> <span>// VuePress 正在使用的 Vue 构造函数</span>
  options<span>,</span> <span>// 附加到根实例的一些选项</span>
  router<span>,</span> <span>// 当前应用的路由实例</span>
  siteData <span>// 站点元数据</span>
<span>}</span><span>)</span> <span>=</span><span>></span> <span>{</span>
  <span>// ...做一些其他的应用级别的优化</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>这个文件类似于<code>vue-cli</code>脚手架中的main.js文件</p>
<p>这个功能还是比较实用的，可以引入你想要的vue组件库并在md文件中使用。或者利用组件库来封装一个自定义组件。</p>
<blockquote>
<p><strong>1、尝试集成Element-UI组件</strong></p>
</blockquote>
<p>参照<a href="https://element.eleme.cn/#/zh-CN/component/installation" target="_blank" rel="noopener noreferrer">Element-UI官方文档</a></p>
<p>1、安装组件</p>
<div><pre><code><span>yarn</span> <span>add</span> element-ui
</code></pre>
<div><span>1</span><br></div></div><p>2、引入组件</p>
<div><pre><code><span>//.vuepress/enhanceApp.js</span>

<span>/**
 * 扩展 VuePress 应用
 */</span>
<span>import</span> Element <span>from</span> <span>'element-ui'</span>
<span>import</span> <span>'element-ui/lib/theme-chalk/index.css'</span>

<span>export</span> <span>default</span> <span>(</span><span><span>{</span>
  Vue<span>,</span> 
<span>}</span></span><span>)</span> <span>=></span> <span>{</span>
  <span>// ...做一些其他的应用级别的优化</span>
  Vue<span>.</span><span>use</span><span>(</span>Element<span>)</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>在扩展之后，就可以在自定义的组件或者md文件中使用element的组件了。</p>
<p>3、测试在md中使用</p>
<p>创建<code>blogs/components/element-ui.md</code>，内容如下</p>
<div><pre><code><span><span>---</span>
<span><span>title</span><span>:</span> Element<span>-</span>UI Test
<span>date</span><span>:</span> 2021<span>-</span>1<span>-</span><span>15</span>
<span>tags</span><span>:</span>
  <span>-</span> element<span>-</span>ui
<span>categories</span><span>:</span>
  <span>-</span> Vue Components</span>
<span>---</span></span>
<span><span><span>&lt;</span>template</span><span>></span></span>
<span><span><span>&lt;</span>el-row</span><span>></span></span>
  <span><span><span>&lt;</span>el-button</span><span>></span></span>默认按钮<span><span><span>&lt;/</span>el-button</span><span>></span></span>
  <span><span><span>&lt;</span>el-button</span> <span>type</span><span><span>=</span><span>"</span>primary<span>"</span></span><span>></span></span>主要按钮<span><span><span>&lt;/</span>el-button</span><span>></span></span>
  <span><span><span>&lt;</span>el-button</span> <span>type</span><span><span>=</span><span>"</span>success<span>"</span></span><span>></span></span>成功按钮<span><span><span>&lt;/</span>el-button</span><span>></span></span>
  <span><span><span>&lt;</span>el-button</span> <span>type</span><span><span>=</span><span>"</span>info<span>"</span></span><span>></span></span>信息按钮<span><span><span>&lt;/</span>el-button</span><span>></span></span>
  <span><span><span>&lt;</span>el-button</span> <span>type</span><span><span>=</span><span>"</span>warning<span>"</span></span><span>></span></span>警告按钮<span><span><span>&lt;/</span>el-button</span><span>></span></span>
  <span><span><span>&lt;</span>el-button</span> <span>type</span><span><span>=</span><span>"</span>danger<span>"</span></span><span>></span></span>危险按钮<span><span><span>&lt;/</span>el-button</span><span>></span></span>
<span><span><span>&lt;/</span>el-row</span><span>></span></span>

<span><span><span>&lt;</span>el-row</span><span>></span></span>
  <span><span><span>&lt;</span>el-button</span> <span>plain</span><span>></span></span>朴素按钮<span><span><span>&lt;/</span>el-button</span><span>></span></span>
  <span><span><span>&lt;</span>el-button</span> <span>type</span><span><span>=</span><span>"</span>primary<span>"</span></span> <span>plain</span><span>></span></span>主要按钮<span><span><span>&lt;/</span>el-button</span><span>></span></span>
  <span><span><span>&lt;</span>el-button</span> <span>type</span><span><span>=</span><span>"</span>success<span>"</span></span> <span>plain</span><span>></span></span>成功按钮<span><span><span>&lt;/</span>el-button</span><span>></span></span>
  <span><span><span>&lt;</span>el-button</span> <span>type</span><span><span>=</span><span>"</span>info<span>"</span></span> <span>plain</span><span>></span></span>信息按钮<span><span><span>&lt;/</span>el-button</span><span>></span></span>
  <span><span><span>&lt;</span>el-button</span> <span>type</span><span><span>=</span><span>"</span>warning<span>"</span></span> <span>plain</span><span>></span></span>警告按钮<span><span><span>&lt;/</span>el-button</span><span>></span></span>
  <span><span><span>&lt;</span>el-button</span> <span>type</span><span><span>=</span><span>"</span>danger<span>"</span></span> <span>plain</span><span>></span></span>危险按钮<span><span><span>&lt;/</span>el-button</span><span>></span></span>
<span><span><span>&lt;/</span>el-row</span><span>></span></span>

<span><span><span>&lt;</span>el-row</span><span>></span></span>
  <span><span><span>&lt;</span>el-button</span> <span>round</span><span>></span></span>圆角按钮<span><span><span>&lt;/</span>el-button</span><span>></span></span>
  <span><span><span>&lt;</span>el-button</span> <span>type</span><span><span>=</span><span>"</span>primary<span>"</span></span> <span>round</span><span>></span></span>主要按钮<span><span><span>&lt;/</span>el-button</span><span>></span></span>
  <span><span><span>&lt;</span>el-button</span> <span>type</span><span><span>=</span><span>"</span>success<span>"</span></span> <span>round</span><span>></span></span>成功按钮<span><span><span>&lt;/</span>el-button</span><span>></span></span>
  <span><span><span>&lt;</span>el-button</span> <span>type</span><span><span>=</span><span>"</span>info<span>"</span></span> <span>round</span><span>></span></span>信息按钮<span><span><span>&lt;/</span>el-button</span><span>></span></span>
  <span><span><span>&lt;</span>el-button</span> <span>type</span><span><span>=</span><span>"</span>warning<span>"</span></span> <span>round</span><span>></span></span>警告按钮<span><span><span>&lt;/</span>el-button</span><span>></span></span>
  <span><span><span>&lt;</span>el-button</span> <span>type</span><span><span>=</span><span>"</span>danger<span>"</span></span> <span>round</span><span>></span></span>危险按钮<span><span><span>&lt;/</span>el-button</span><span>></span></span>
<span><span><span>&lt;/</span>el-row</span><span>></span></span>

<span><span><span>&lt;</span>el-row</span><span>></span></span>
  <span><span><span>&lt;</span>el-button</span> <span>icon</span><span><span>=</span><span>"</span>el-icon-search<span>"</span></span> <span>circle</span><span>></span></span><span><span><span>&lt;/</span>el-button</span><span>></span></span>
  <span><span><span>&lt;</span>el-button</span> <span>type</span><span><span>=</span><span>"</span>primary<span>"</span></span> <span>icon</span><span><span>=</span><span>"</span>el-icon-edit<span>"</span></span> <span>circle</span><span>></span></span><span><span><span>&lt;/</span>el-button</span><span>></span></span>
  <span><span><span>&lt;</span>el-button</span> <span>type</span><span><span>=</span><span>"</span>success<span>"</span></span> <span>icon</span><span><span>=</span><span>"</span>el-icon-check<span>"</span></span> <span>circle</span><span>></span></span><span><span><span>&lt;/</span>el-button</span><span>></span></span>
  <span><span><span>&lt;</span>el-button</span> <span>type</span><span><span>=</span><span>"</span>info<span>"</span></span> <span>icon</span><span><span>=</span><span>"</span>el-icon-message<span>"</span></span> <span>circle</span><span>></span></span><span><span><span>&lt;/</span>el-button</span><span>></span></span>
  <span><span><span>&lt;</span>el-button</span> <span>type</span><span><span>=</span><span>"</span>warning<span>"</span></span> <span>icon</span><span><span>=</span><span>"</span>el-icon-star-off<span>"</span></span> <span>circle</span><span>></span></span><span><span><span>&lt;/</span>el-button</span><span>></span></span>
  <span><span><span>&lt;</span>el-button</span> <span>type</span><span><span>=</span><span>"</span>danger<span>"</span></span> <span>icon</span><span><span>=</span><span>"</span>el-icon-delete<span>"</span></span> <span>circle</span><span>></span></span><span><span><span>&lt;/</span>el-button</span><span>></span></span>
<span><span><span>&lt;/</span>el-row</span><span>></span></span>
<span><span><span>&lt;/</span>template</span><span>></span></span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br></div></div><p>4、运行测试</p>
<p>页面空白，打开控制台查看报错信息</p>
<p><img src="./assets/vuepress14.png" alt=""></p>
<div><p>问题解决</p>
<p>使用命令安装依赖</p>
<div><pre><code><span>yarn</span> <span>add</span> async-validator@1.11.5 
或
<span>npm</span> <span>install</span> async-validator@1.11.5
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>另外，使用命令：</p>
<div><pre><code>npx vuepress info
</code></pre>
<div><span>1</span><br></div></div><p>查看vue包的版本，有助于查看版本是否对应</p>
<div><p>感谢</p>
<p><a href="https://blog.csdn.net/qq_32855007/article/details/108726430" target="_blank" rel="noopener noreferrer">无休止的bug</a> 提供的解决方法</p>
</div>
</div>
<p>再次运行，页面可以正常显示</p>
<p>点击文章Element-UI Test，显示的效果如下</p>
<p><img src="./assets/vuepress15.png" alt=""></p>
<p>在npm官网中也可以找到相关的插件，我们可以免去自己集成的麻烦。经测试，插件<a href="https://superbiger.github.io/vuepress-plugin-tabs/" target="_blank" rel="noopener noreferrer">vuepress-plugin-element-ui</a>可以正常使用。使用yarn安装网站能正常使用，但如果使用npm安装就不行，页面显示是空白的，好在对应github仓库的issue中已经给出解决方法，就是版本对应的问题。</p>
<p>不过如果你要用这个插件就使用yarn来安装，减少不必要的麻烦。</p>
<p><img src="./assets/vuepress51.png" alt=""></p>
<blockquote>
<p><strong>2、尝试集成View UI组件</strong></p>
</blockquote>
<div><p>提示</p>
<p>View UI原来叫做iview，<a href="">官方文档</a></p>
</div>
<p>1、安装iview</p>
<div><pre><code><span>yarn</span> <span>add</span> view-design
</code></pre>
<div><span>1</span><br></div></div><p>2、引入组件</p>
<div><pre><code><span>/**
 * 扩展 VuePress 应用
 */</span>
<span>// import Element from 'element-ui'</span>
<span>// import 'element-ui/lib/theme-chalk/index.css'</span>

<span>import</span> ViewUI <span>from</span> <span>'view-design'</span><span>;</span>
<span>import</span> <span>'view-design/dist/styles/iview.css'</span><span>;</span>


<span>export</span> <span>default</span> <span>(</span><span><span>{</span>
                    Vue<span>,</span>
                <span>}</span></span><span>)</span> <span>=></span> <span>{</span>
    <span>// ...做一些其他的应用级别的优化</span>
    <span>// Vue.use(Element);</span>
    Vue<span>.</span><span>use</span><span>(</span>ViewUI<span>)</span><span>;</span>

<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><p>3、在md中测试</p>
<p>创建<code>blogs/components/view-ui.md</code>，内容如下</p>
<div><pre><code><span><span>---</span>
<span><span>title</span><span>:</span> View UI Test
<span>date</span><span>:</span> <span>2021-01-15</span>
<span>tags</span><span>:</span>
  <span>-</span> iview
  <span>-</span> view ui
<span>categories</span><span>:</span>
  <span>-</span> Vue Components</span>
<span>---</span></span>
<span><span><span>&lt;</span>template</span><span>></span></span>
    <span><span><span>&lt;</span>Row</span><span>></span></span>
        <span><span><span>&lt;</span>Col</span> <span>span</span><span><span>=</span><span>"</span>8<span>"</span></span><span>></span></span>
            <span><span><span>&lt;</span>Menu</span> <span>:theme</span><span><span>=</span><span>"</span>theme2<span>"</span></span><span>></span></span>
                <span><span><span>&lt;</span>Submenu</span> <span>name</span><span><span>=</span><span>"</span>1<span>"</span></span><span>></span></span>
                    <span><span><span>&lt;</span>template</span> <span>slot</span><span><span>=</span><span>"</span>title<span>"</span></span><span>></span></span>
                        <span><span><span>&lt;</span>Icon</span> <span>type</span><span><span>=</span><span>"</span>ios-paper<span>"</span></span> <span>/></span></span>
                        内容管理
                    <span><span><span>&lt;/</span>template</span><span>></span></span>
                    <span><span><span>&lt;</span>MenuItem</span> <span>name</span><span><span>=</span><span>"</span>1-1<span>"</span></span><span>></span></span>文章管理<span><span><span>&lt;/</span>MenuItem</span><span>></span></span>
                    <span><span><span>&lt;</span>MenuItem</span> <span>name</span><span><span>=</span><span>"</span>1-2<span>"</span></span><span>></span></span>评论管理<span><span><span>&lt;/</span>MenuItem</span><span>></span></span>
                    <span><span><span>&lt;</span>MenuItem</span> <span>name</span><span><span>=</span><span>"</span>1-3<span>"</span></span><span>></span></span>举报管理<span><span><span>&lt;/</span>MenuItem</span><span>></span></span>
                <span><span><span>&lt;/</span>Submenu</span><span>></span></span>
                <span><span><span>&lt;</span>Submenu</span> <span>name</span><span><span>=</span><span>"</span>2<span>"</span></span><span>></span></span>
                    <span><span><span>&lt;</span>template</span> <span>slot</span><span><span>=</span><span>"</span>title<span>"</span></span><span>></span></span>
                        <span><span><span>&lt;</span>Icon</span> <span>type</span><span><span>=</span><span>"</span>ios-people<span>"</span></span> <span>/></span></span>
                        用户管理
                    <span><span><span>&lt;/</span>template</span><span>></span></span>
                    <span><span><span>&lt;</span>MenuItem</span> <span>name</span><span><span>=</span><span>"</span>2-1<span>"</span></span><span>></span></span>新增用户<span><span><span>&lt;/</span>MenuItem</span><span>></span></span>
                    <span><span><span>&lt;</span>MenuItem</span> <span>name</span><span><span>=</span><span>"</span>2-2<span>"</span></span><span>></span></span>活跃用户<span><span><span>&lt;/</span>MenuItem</span><span>></span></span>
                <span><span><span>&lt;/</span>Submenu</span><span>></span></span>
                <span><span><span>&lt;</span>Submenu</span> <span>name</span><span><span>=</span><span>"</span>3<span>"</span></span><span>></span></span>
                    <span><span><span>&lt;</span>template</span> <span>slot</span><span><span>=</span><span>"</span>title<span>"</span></span><span>></span></span>
                        <span><span><span>&lt;</span>Icon</span> <span>type</span><span><span>=</span><span>"</span>ios-stats<span>"</span></span> <span>/></span></span>
                        统计分析
                    <span><span><span>&lt;/</span>template</span><span>></span></span>
                    <span><span><span>&lt;</span>MenuGroup</span> <span>title</span><span><span>=</span><span>"</span>使用<span>"</span></span><span>></span></span>
                        <span><span><span>&lt;</span>MenuItem</span> <span>name</span><span><span>=</span><span>"</span>3-1<span>"</span></span><span>></span></span>新增和启动<span><span><span>&lt;/</span>MenuItem</span><span>></span></span>
                        <span><span><span>&lt;</span>MenuItem</span> <span>name</span><span><span>=</span><span>"</span>3-2<span>"</span></span><span>></span></span>活跃分析<span><span><span>&lt;/</span>MenuItem</span><span>></span></span>
                        <span><span><span>&lt;</span>MenuItem</span> <span>name</span><span><span>=</span><span>"</span>3-3<span>"</span></span><span>></span></span>时段分析<span><span><span>&lt;/</span>MenuItem</span><span>></span></span>
                    <span><span><span>&lt;/</span>MenuGroup</span><span>></span></span>
                    <span><span><span>&lt;</span>MenuGroup</span> <span>title</span><span><span>=</span><span>"</span>留存<span>"</span></span><span>></span></span>
                        <span><span><span>&lt;</span>MenuItem</span> <span>name</span><span><span>=</span><span>"</span>3-4<span>"</span></span><span>></span></span>用户留存<span><span><span>&lt;/</span>MenuItem</span><span>></span></span>
                        <span><span><span>&lt;</span>MenuItem</span> <span>name</span><span><span>=</span><span>"</span>3-5<span>"</span></span><span>></span></span>流失用户<span><span><span>&lt;/</span>MenuItem</span><span>></span></span>
                    <span><span><span>&lt;/</span>MenuGroup</span><span>></span></span>
                <span><span><span>&lt;/</span>Submenu</span><span>></span></span>
            <span><span><span>&lt;/</span>Menu</span><span>></span></span>
        <span><span><span>&lt;/</span>Col</span><span>></span></span>
        <span><span><span>&lt;</span>Col</span> <span>span</span><span><span>=</span><span>"</span>8<span>"</span></span><span>></span></span>
            <span><span><span>&lt;</span>Menu</span> <span>:theme</span><span><span>=</span><span>"</span>theme2<span>"</span></span> <span>active-name</span><span><span>=</span><span>"</span>1-2<span>"</span></span> <span>:open-names</span><span><span>=</span><span>"</span>[<span>'</span>1<span>'</span>]<span>"</span></span><span>></span></span>
                <span><span><span>&lt;</span>Submenu</span> <span>name</span><span><span>=</span><span>"</span>1<span>"</span></span><span>></span></span>
                    <span><span><span>&lt;</span>template</span> <span>slot</span><span><span>=</span><span>"</span>title<span>"</span></span><span>></span></span>
                        <span><span><span>&lt;</span>Icon</span> <span>type</span><span><span>=</span><span>"</span>ios-paper<span>"</span></span> <span>/></span></span>
                        内容管理
                    <span><span><span>&lt;/</span>template</span><span>></span></span>
                    <span><span><span>&lt;</span>MenuItem</span> <span>name</span><span><span>=</span><span>"</span>1-1<span>"</span></span><span>></span></span>文章管理<span><span><span>&lt;/</span>MenuItem</span><span>></span></span>
                    <span><span><span>&lt;</span>MenuItem</span> <span>name</span><span><span>=</span><span>"</span>1-2<span>"</span></span><span>></span></span>评论管理<span><span><span>&lt;/</span>MenuItem</span><span>></span></span>
                    <span><span><span>&lt;</span>MenuItem</span> <span>name</span><span><span>=</span><span>"</span>1-3<span>"</span></span><span>></span></span>举报管理<span><span><span>&lt;/</span>MenuItem</span><span>></span></span>
                <span><span><span>&lt;/</span>Submenu</span><span>></span></span>
                <span><span><span>&lt;</span>Submenu</span> <span>name</span><span><span>=</span><span>"</span>2<span>"</span></span><span>></span></span>
                    <span><span><span>&lt;</span>template</span> <span>slot</span><span><span>=</span><span>"</span>title<span>"</span></span><span>></span></span>
                        <span><span><span>&lt;</span>Icon</span> <span>type</span><span><span>=</span><span>"</span>ios-people<span>"</span></span> <span>/></span></span>
                        用户管理
                    <span><span><span>&lt;/</span>template</span><span>></span></span>
                    <span><span><span>&lt;</span>MenuItem</span> <span>name</span><span><span>=</span><span>"</span>2-1<span>"</span></span><span>></span></span>新增用户<span><span><span>&lt;/</span>MenuItem</span><span>></span></span>
                    <span><span><span>&lt;</span>MenuItem</span> <span>name</span><span><span>=</span><span>"</span>2-2<span>"</span></span><span>></span></span>活跃用户<span><span><span>&lt;/</span>MenuItem</span><span>></span></span>
                <span><span><span>&lt;/</span>Submenu</span><span>></span></span>
                <span><span><span>&lt;</span>Submenu</span> <span>name</span><span><span>=</span><span>"</span>3<span>"</span></span><span>></span></span>
                    <span><span><span>&lt;</span>template</span> <span>slot</span><span><span>=</span><span>"</span>title<span>"</span></span><span>></span></span>
                        <span><span><span>&lt;</span>Icon</span> <span>type</span><span><span>=</span><span>"</span>ios-stats<span>"</span></span> <span>/></span></span>
                        统计分析
                    <span><span><span>&lt;/</span>template</span><span>></span></span>
                    <span><span><span>&lt;</span>MenuGroup</span> <span>title</span><span><span>=</span><span>"</span>使用<span>"</span></span><span>></span></span>
                        <span><span><span>&lt;</span>MenuItem</span> <span>name</span><span><span>=</span><span>"</span>3-1<span>"</span></span><span>></span></span>新增和启动<span><span><span>&lt;/</span>MenuItem</span><span>></span></span>
                        <span><span><span>&lt;</span>MenuItem</span> <span>name</span><span><span>=</span><span>"</span>3-2<span>"</span></span><span>></span></span>活跃分析<span><span><span>&lt;/</span>MenuItem</span><span>></span></span>
                        <span><span><span>&lt;</span>MenuItem</span> <span>name</span><span><span>=</span><span>"</span>3-3<span>"</span></span><span>></span></span>时段分析<span><span><span>&lt;/</span>MenuItem</span><span>></span></span>
                    <span><span><span>&lt;/</span>MenuGroup</span><span>></span></span>
                    <span><span><span>&lt;</span>MenuGroup</span> <span>title</span><span><span>=</span><span>"</span>留存<span>"</span></span><span>></span></span>
                        <span><span><span>&lt;</span>MenuItem</span> <span>name</span><span><span>=</span><span>"</span>3-4<span>"</span></span><span>></span></span>用户留存<span><span><span>&lt;/</span>MenuItem</span><span>></span></span>
                        <span><span><span>&lt;</span>MenuItem</span> <span>name</span><span><span>=</span><span>"</span>3-5<span>"</span></span><span>></span></span>流失用户<span><span><span>&lt;/</span>MenuItem</span><span>></span></span>
                    <span><span><span>&lt;/</span>MenuGroup</span><span>></span></span>
                <span><span><span>&lt;/</span>Submenu</span><span>></span></span>
            <span><span><span>&lt;/</span>Menu</span><span>></span></span>
        <span><span><span>&lt;/</span>Col</span><span>></span></span>
        <span><span><span>&lt;</span>Col</span> <span>span</span><span><span>=</span><span>"</span>8<span>"</span></span><span>></span></span>
            <span><span><span>&lt;</span>Menu</span> <span>:theme</span><span><span>=</span><span>"</span>theme2<span>"</span></span> <span>:open-names</span><span><span>=</span><span>"</span>[<span>'</span>1<span>'</span>]<span>"</span></span> <span>accordion</span><span>></span></span>
                <span><span><span>&lt;</span>Submenu</span> <span>name</span><span><span>=</span><span>"</span>1<span>"</span></span><span>></span></span>
                    <span><span><span>&lt;</span>template</span> <span>slot</span><span><span>=</span><span>"</span>title<span>"</span></span><span>></span></span>
                        <span><span><span>&lt;</span>Icon</span> <span>type</span><span><span>=</span><span>"</span>ios-paper<span>"</span></span> <span>/></span></span>
                        内容管理
                    <span><span><span>&lt;/</span>template</span><span>></span></span>
                    <span><span><span>&lt;</span>MenuItem</span> <span>name</span><span><span>=</span><span>"</span>1-1<span>"</span></span><span>></span></span>文章管理<span><span><span>&lt;/</span>MenuItem</span><span>></span></span>
                    <span><span><span>&lt;</span>MenuItem</span> <span>name</span><span><span>=</span><span>"</span>1-2<span>"</span></span><span>></span></span>评论管理<span><span><span>&lt;/</span>MenuItem</span><span>></span></span>
                    <span><span><span>&lt;</span>MenuItem</span> <span>name</span><span><span>=</span><span>"</span>1-3<span>"</span></span><span>></span></span>举报管理<span><span><span>&lt;/</span>MenuItem</span><span>></span></span>
                <span><span><span>&lt;/</span>Submenu</span><span>></span></span>
                <span><span><span>&lt;</span>Submenu</span> <span>name</span><span><span>=</span><span>"</span>2<span>"</span></span><span>></span></span>
                    <span><span><span>&lt;</span>template</span> <span>slot</span><span><span>=</span><span>"</span>title<span>"</span></span><span>></span></span>
                        <span><span><span>&lt;</span>Icon</span> <span>type</span><span><span>=</span><span>"</span>ios-people<span>"</span></span> <span>/></span></span>
                        用户管理
                    <span><span><span>&lt;/</span>template</span><span>></span></span>
                    <span><span><span>&lt;</span>MenuItem</span> <span>name</span><span><span>=</span><span>"</span>2-1<span>"</span></span><span>></span></span>新增用户<span><span><span>&lt;/</span>MenuItem</span><span>></span></span>
                    <span><span><span>&lt;</span>MenuItem</span> <span>name</span><span><span>=</span><span>"</span>2-2<span>"</span></span><span>></span></span>活跃用户<span><span><span>&lt;/</span>MenuItem</span><span>></span></span>
                <span><span><span>&lt;/</span>Submenu</span><span>></span></span>
                <span><span><span>&lt;</span>Submenu</span> <span>name</span><span><span>=</span><span>"</span>3<span>"</span></span><span>></span></span>
                    <span><span><span>&lt;</span>template</span> <span>slot</span><span><span>=</span><span>"</span>title<span>"</span></span><span>></span></span>
                        <span><span><span>&lt;</span>Icon</span> <span>type</span><span><span>=</span><span>"</span>ios-stats<span>"</span></span> <span>/></span></span>
                        统计分析
                    <span><span><span>&lt;/</span>template</span><span>></span></span>
                    <span><span><span>&lt;</span>MenuGroup</span> <span>title</span><span><span>=</span><span>"</span>使用<span>"</span></span><span>></span></span>
                        <span><span><span>&lt;</span>MenuItem</span> <span>name</span><span><span>=</span><span>"</span>3-1<span>"</span></span><span>></span></span>新增和启动<span><span><span>&lt;/</span>MenuItem</span><span>></span></span>
                        <span><span><span>&lt;</span>MenuItem</span> <span>name</span><span><span>=</span><span>"</span>3-2<span>"</span></span><span>></span></span>活跃分析<span><span><span>&lt;/</span>MenuItem</span><span>></span></span>
                        <span><span><span>&lt;</span>MenuItem</span> <span>name</span><span><span>=</span><span>"</span>3-3<span>"</span></span><span>></span></span>时段分析<span><span><span>&lt;/</span>MenuItem</span><span>></span></span>
                    <span><span><span>&lt;/</span>MenuGroup</span><span>></span></span>
                    <span><span><span>&lt;</span>MenuGroup</span> <span>title</span><span><span>=</span><span>"</span>留存<span>"</span></span><span>></span></span>
                        <span><span><span>&lt;</span>MenuItem</span> <span>name</span><span><span>=</span><span>"</span>3-4<span>"</span></span><span>></span></span>用户留存<span><span><span>&lt;/</span>MenuItem</span><span>></span></span>
                        <span><span><span>&lt;</span>MenuItem</span> <span>name</span><span><span>=</span><span>"</span>3-5<span>"</span></span><span>></span></span>流失用户<span><span><span>&lt;/</span>MenuItem</span><span>></span></span>
                    <span><span><span>&lt;/</span>MenuGroup</span><span>></span></span>
                <span><span><span>&lt;/</span>Submenu</span><span>></span></span>
            <span><span><span>&lt;/</span>Menu</span><span>></span></span>
        <span><span><span>&lt;/</span>Col</span><span>></span></span>
    <span><span><span>&lt;/</span>Row</span><span>></span></span>
    <span><span><span>&lt;</span>br</span><span>></span></span>
    <span><span><span>&lt;</span>p</span><span>></span></span>Change theme<span><span><span>&lt;/</span>p</span><span>></span></span>
    <span><span><span>&lt;</span>RadioGroup</span> <span>v-model</span><span><span>=</span><span>"</span>theme2<span>"</span></span><span>></span></span>
        <span><span><span>&lt;</span>Radio</span> <span>label</span><span><span>=</span><span>"</span>light<span>"</span></span><span>></span></span><span><span><span>&lt;/</span>Radio</span><span>></span></span>
        <span><span><span>&lt;</span>Radio</span> <span>label</span><span><span>=</span><span>"</span>dark<span>"</span></span><span>></span></span><span><span><span>&lt;/</span>Radio</span><span>></span></span>
    <span><span><span>&lt;/</span>RadioGroup</span><span>></span></span>
<span><span><span>&lt;/</span>template</span><span>></span></span>
<span><span><span>&lt;</span>script</span><span>></span></span><span><span>
    <span>export</span> <span>default</span> <span>{</span>
        <span>data</span> <span>(</span><span>)</span> <span>{</span>
            <span>return</span> <span>{</span>
                theme2<span>:</span> <span>'light'</span>
            <span>}</span>
        <span>}</span>
    <span>}</span>
</span></span><span><span><span>&lt;/</span>script</span><span>></span></span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br><span>96</span><br><span>97</span><br><span>98</span><br><span>99</span><br><span>100</span><br><span>101</span><br><span>102</span><br><span>103</span><br><span>104</span><br><span>105</span><br><span>106</span><br><span>107</span><br><span>108</span><br><span>109</span><br><span>110</span><br><span>111</span><br><span>112</span><br><span>113</span><br><span>114</span><br><span>115</span><br><span>116</span><br><span>117</span><br><span>118</span><br><span>119</span><br><span>120</span><br><span>121</span><br><span>122</span><br><span>123</span><br><span>124</span><br><span>125</span><br><span>126</span><br><span>127</span><br><span>128</span><br><span>129</span><br><span>130</span><br><span>131</span><br><span>132</span><br><span>133</span><br><span>134</span><br><span>135</span><br><span>136</span><br><span>137</span><br></div></div><p>4、运行测试</p>
<p>发现页面空白，控制台信息如下，所以不知道是哪里有问题</p>
<p><img src="./assets/vuepress16.png" alt=""></p>
<p>索性把enhanceApp.js内容全部注释，页面恢复正常。为什么会这样，原因未知，有待继续深入学习。</p>
<p>参照view ui文档中的main.js</p>
<p><img src="./assets/vuepress17.png" alt=""></p>
<p>修改enhanceApp.js的内容如下：</p>
<div><pre><code><span>// import Element from 'element-ui'</span>
<span>// import 'element-ui/lib/theme-chalk/index.css'</span>
<span>import</span> Vue <span>from</span> <span>'vue'</span><span>;</span>
<span>import</span> ViewUI <span>from</span> <span>'view-design'</span><span>;</span>
<span>import</span> <span>'view-design/dist/styles/iview.css'</span><span>;</span>
Vue<span>.</span><span>use</span><span>(</span>ViewUI<span>)</span><span>;</span>

<span>export</span> <span>default</span> <span>(</span><span><span>{</span>
                    Vue<span>,</span>
                <span>}</span></span><span>)</span> <span>=></span> <span>{</span>
    <span>// ...做一些其他的应用级别的优化</span>
    <span>// Vue.use(Element);</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>查看首页面已经能够正常显示，点开View UI Test文章查看，效果也正常显示</p>
<p><img src="./assets/vuepress18.png" alt=""></p>
<p>以上测试了两个前端常用的组件库Element-UI和View UI，其他的组件库的使用也是类似，如果出现页面空白而后台没有报错的情况，先查看浏览器控制台报错信息再百度查找解决方法，或者尝试修改enhanceApp.js内容。</p>
<div><p>提示</p>
<p><strong>修改enhanceApp.js内容后项目不用重启，直接看浏览器中是否正常显示</strong>。</p>
</div>
<h3 id="五-个性化组件开发"> （五）个性化组件开发</h3>
<p>上一小节演示的是直接在md文件中使用vue，实际写博客时这样操作就失去了写博客的初衷了，所以我们一般都是利用第三方的组件库来便携编写一个我们自己的组件，方便我们在md文件中使用</p>
<p>如果我们需要开发自己的组件，那么在<code>.vuepress</code>下新建<code>components</code>文件夹，可以在里面编写vue文件，与vue-cli开发无异，而且，组件是全局注册的，组件之间互相调用，不用手动引入，<strong>在md文件中，在theme中都可以使用</strong>。</p>
<p>下图是对应的官方说明</p>
<img src="./assets/vuepress19.png" style="zoom:80%;" />
<h3 id="六-博客的自动路由"> （六）博客的自动路由</h3>
<p>vuepress是一个单页面应用，所谓路由，是VueRouter模拟出来的假象，通过官方对<a href="https://vuepress.vuejs.org/zh/theme/writing-a-theme.html#%E7%BD%91%E7%AB%99%E5%92%8C%E9%A1%B5%E9%9D%A2%E7%9A%84%E5%85%83%E6%95%B0%E6%8D%AE" target="_blank" rel="noopener noreferrer">元数据</a> 的描述，我们可以了解到<code>vuepress</code></p>
<p>能够提供博客以及博客中的分类、标签、时间线等功能支持主要就是使用元数据 <strong>$page</strong> 来实现，看一下官方文档中比较关键的说明：</p>
<div><p>元数据</p>
<p><code>pages</code> 是一个包含了每个页面元数据对象的数据，包括它的路径、页面标题（明确地通过 <a href="https://vuepress.vuejs.org/zh/guide/markdown.html#front-matter" target="_blank" rel="noopener noreferrer">YAML front matter</a> 指定，或者通过该页面的第一个标题取到），以及所有源文件中的 <code>YAML front matter</code> 的数据。</p>
<p>如果用户在 <code>.vuepress/config.js</code> 配置了 <code>themeConfig</code>，你将可以通过 <code>$site.themeConfig</code> 访问到它。如此一来，你可以通过它来对用户开放一些自定义主题的配置 —— 比如指定目录或者页面的顺序，你也可以结合 <code>$site.pages</code> 来动态地构建导航链接。</p>
<p>最后，别忘了，作为 Vue Router API 的一部分，<code>this.$route</code> 和 <code>this.$router</code> 同样可以使用。</p>
</div>
<p>没错,<strong>$pages</strong>它记录了所有md文件的元数据，我可以通过在元数据中添加分类、标签，以及时间来实现路由。</p>
<p>每一次新写的文章，无需在config.js中设置路由，只需要在md中按照元数据的格式，设置好type(分类),tags(标签)。</p>
<p>最后编译，push到github，就可以在相应的菜单中看到它。</p>
<p><mark>如果你有兴趣去做一些相关开发，元数据是你得好好深入学习一下</mark></p>
<h3 id="七-导航栏与侧边栏"> （七）导航栏与侧边栏</h3>
<p>我们不必把导航栏和侧边栏的配置都放到config.js中，我们可以单独配置然后在config.js中引用</p>
<p>1、.vuepress下创建以下的文件结构</p>
<div><pre><code><span>.</span>vuepress
├─ config
	├─ navbar
    <span>|</span>  └── index<span>.</span>js
	└─ sidebar
       └── index<span>.</span>js

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>navbar/index.js内容</p>
<div><pre><code>module<span>.</span>exports<span>=</span><span>[</span>

    <span>{</span>text<span>:</span> <span>'首页'</span><span>,</span> link<span>:</span> <span>'/'</span><span>,</span> icon<span>:</span> <span>'reco-home'</span><span>}</span><span>,</span>
    <span>{</span> text<span>:</span> <span>"时间线"</span><span>,</span> link<span>:</span> <span>"/timeline/"</span><span>,</span> icon<span>:</span> <span>"reco-date"</span> <span>}</span><span>,</span>
    <span>{</span>
        text<span>:</span> <span>"联系"</span><span>,</span>
        icon<span>:</span> <span>"reco-message"</span><span>,</span>
        items<span>:</span> <span>[</span>
            <span>{</span>text<span>:</span> <span>'七七部落'</span><span>,</span> link<span>:</span> <span>'http://qiqi.dreamagain.top/'</span><span>,</span> icon<span>:</span> <span>'reco-logo'</span><span>}</span><span>,</span>
            <span>{</span>text<span>:</span> <span>'GitHub'</span><span>,</span> link<span>:</span> <span>'https://github.com/small-universe/qiqi-algorithm'</span><span>,</span> icon<span>:</span> <span>'reco-github'</span><span>}</span><span>,</span>
            <span>{</span>text<span>:</span> <span>"CSDN"</span><span>,</span> link<span>:</span> <span>"https://blog.csdn.net/qq_27961843/"</span><span>,</span> icon<span>:</span> <span>"reco-csdn"</span><span>}</span><span>,</span>
            <span>{</span>text<span>:</span> <span>"QQ"</span><span>,</span> link<span>:</span> <span>"tencent://message/?uin=1715261428"</span><span>,</span> icon<span>:</span> <span>"reco-qq"</span><span>}</span><span>,</span>
            <span>{</span>text<span>:</span> <span>"Gmail"</span><span>,</span> link<span>:</span> <span>"mailto:18846770224@163.com"</span><span>,</span> icon<span>:</span> <span>"reco-mail"</span><span>}</span><span>,</span>
        <span>]</span><span>,</span>
    <span>}</span><span>,</span>
<span>]</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p>sidebar/index.js内容</p>
<div><pre><code>//侧边栏
module.exports = {
    &#39;/blogs/&#39;: [
        {
            title: &#39;分类一&#39;,
            collapsable: false,
            children: [
                &#39;./category1/2018/121501&#39;,
                &#39;./category1/2019/092101&#39;,
            ]
        },
        {
            title: &#39;分类二&#39;,
            collapsable: false,
            children: [
                &#39;./category2/2016/121501&#39;,
                &#39;./category2/2017/092101&#39;,
            ]
        },
        {
            title: &#39;组件&#39;,
            // collapsable: false,
            children: [
                &#39;./components/element-ui&#39;,
                &#39;./components/view-ui&#39;,
            ]
        },
    ],

}


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br></div></div><p>2、config.js中导入</p>
<div><div><div>&nbsp;</div><div>&nbsp;</div><br><br><br><br><div>&nbsp;</div><div>&nbsp;</div><br><br><br><br></div><pre><code><span>const</span> sidebar <span>=</span> <span>require</span><span>(</span><span>'./config/sidebar'</span><span>)</span>
<span>const</span> nav <span>=</span> <span>require</span><span>(</span><span>'./config/navbar'</span><span>)</span>
<span>...</span><span>...</span>
  themeConfig<span>:</span> <span>{</span>
    type<span>:</span> <span>"blog"</span><span>,</span> <span>//选择类型博客</span>
    fullscreen<span>:</span> <span>true</span><span>,</span>
    nav<span>,</span> <span>//导航栏设置</span>
    sidebar<span>,</span> <span>//侧边栏</span>
    subSidebar<span>:</span> <span>'auto'</span><span>,</span><span>//在所有页面中启用自动生成子侧边栏，原 sidebar 仍然兼容</span>
  <span>}</span>
<span>...</span><span>...</span>
</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>3、测试</p>
<p><img src="./assets/vuepress20.png" alt=""></p>
<p>::: 待解决bug</p>
<ol>
<li>
<p><s>切换主题颜色的按钮样式改变，如下图所示</s> ：<mark>引入第三方组件库导致</mark></p>
</li>
<li>
<p><s>点击标签，页面跳转后显示空白</s>：<mark>引入第三方组件库导致</mark></p>
<p><img src="./assets/vuepress50.png" alt=""></p>
</li>
<li>
<p><s>去除组件库后，按钮样式正常，标签和分类功能出现返回时页面404</s>： <mark>标签和分类不能是中文，不能有空格</mark></p>
</li>
</ol>
<p>当前版本还是存在一些不足之处，坐等主题稳定新版本。</p>
<p>:::</p>
<h2 id="四、部署"> 四、部署</h2>
<h3 id="一-通过deploy-sh脚本部署"> （一）通过deploy.sh脚本部署</h3>
<p>在项目的根路径下创建脚本deploy.sh，内容如下：</p>
<div><pre><code># 确保脚本抛出遇到的错误
set -e

# 生成静态文件
npm run build

# 进入生成的文件夹
cd .vuepress/dist

# 如果是发布到自定义域名
#　echo &#39;reco-demo.dreamagain.top&#39; &gt; CNAME

git init
git add -A
git commit -m &#39;deploy&#39;

# 如果发布到 https://&lt;USERNAME&gt;.github.io
# git push -f git@github.com:&lt;USERNAME&gt;/&lt;USERNAME&gt;.github.io.git master

# 如果发布到 https://&lt;USERNAME&gt;.github.io/&lt;REPO&gt;
# git push -f git@github.com:&lt;USERNAME&gt;/&lt;REPO&gt;.git master:gh-pages

git push -f git@github.com:small-universe/reco-demo.git master:gh-pages

cd -

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><p>在package.json的script中添加如下内容</p>
<div><div><br><div>&nbsp;</div><br><br></div><pre><code><span>"scripts"</span><span>:</span> <span>{</span>
    <span>"deploy"</span><span>:</span> <span>"deploy.sh"</span>
  <span>}</span><span>,</span>
</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>执行命令</p>
<div><pre><code><span>yarn</span> run deploy
</code></pre>
<div><span>1</span><br></div></div><p>项目构建的静态文件已经被发布到对应的github仓库的gh-pages分支</p>
<p><img src="./assets/vuepress21.png" alt=""></p>
<p>点开仓库的设置往下找到GitHub Pages</p>
<p><img src="./assets/vuepress22.png" alt=""></p>
<p><img src="./assets/vuepress23.png" alt=""></p>
<p>访问https://small-universe.github.io/reco-demo/，结果surprise，我们的页面样式丢失了。</p>
<p><img src="./assets/vuepress24.png" alt=""></p>
<p><mark>更多的报错信息说是无法加载静态资源：</mark></p>
<img src="./assets/vuepress25.png" style="zoom:80%;" />
<p>​		仔细查看访问静态资源使用的都是'/'开头，说明默认是从根路径开始查找，但是实际上我们应该使用相对路径，接下来怎么办？</p>
<p>​        回头再仔细看看官方文档有没有什么被我们忽略的说明。</p>
<hr>
<p>果然在<a href="https://vuepress.vuejs.org/zh/config/#base" target="_blank" rel="noopener noreferrer">基本配置</a>里有这样的说明：</p>
<p><img src="./assets/vuepress26.png" alt=""></p>
<p>那就在config.js中配置一下<code>base: &quot;/reco-demo/&quot;,</code></p>
<div><pre><code>module<span>.</span>exports <span>=</span> <span>{</span>
  host<span>:</span> <span>"127.0.0.1"</span><span>,</span> <span>// 生成网页地址（本地调试使用）</span>
  port<span>:</span> <span>"65535"</span><span>,</span> <span>// 生成网页端口（本地调试使用）</span>
  title<span>:</span> <span>"reco-demo"</span><span>,</span> <span>// 显示在左上角的网页名称以及首页在浏览器标签显示的title名称</span>
  description<span>:</span> <span>"A blog template with vuepress-theme-reco."</span><span>,</span> <span>// meta 中的描述文字，用于SEO</span>
  base<span>:</span> <span>"/reco-demo/"</span><span>,</span>
  <span>...</span><span>...</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>再执行一下命令<code>yarn run deploy</code>，这次正常显示了</p>
<p><img src="./assets/vuepress27.png" alt=""></p>
<div><p>提示</p>
<p>配置到此，基本的使用是没有问题了，可以开开心心写博客了。</p>
<p>但还有下面几个步骤，推荐配置一下Github Actions自动部署，这样使用起来会更舒心一些，每次只需要push文件到远程仓库即可，使用deploy.sh部署的这种方式就可以不用了。</p>
</div>
<h3 id="二-github-actions自动部署-推荐"> （二）Github Actions自动部署（推荐）</h3>
<p>在 Github 网页上添加 Github Actions 配置文件，参考<a href="https://docs.github.com/cn/actions/quickstart" target="_blank" rel="noopener noreferrer">官方的文档</a>，可自行取舍相应内容，其中需要保密的部分需要添加 Github Secrets 环境变量【仓库的 Settings --&gt; Secrets --&gt; Add a new secret】</p>
<p>在看官方文档之前建议看一下简单的入门教程，推荐<a href="http://www.ruanyifeng.com/blog/2019/09/getting-started-with-github-actions.html" target="_blank" rel="noopener noreferrer">阮一峰 GitHub Actions 入门教程</a>，对<code>Guthub Actions</code>有基本了解后就可以参照官方文档进行详细的配置</p>
<p><strong>配置步骤：</strong></p>
<p>**第一步:**创建<code>.github/workflows</code>目录并在该目录下创建<code>deploy.yml</code>文件，内容如下：</p>
<div><pre><code><span>name</span><span>:</span> Deploy

<span>on</span><span>:</span>
  <span>push</span><span>:</span>
    <span>branches</span><span>:</span>
      <span>-</span> master

<span>jobs</span><span>:</span>
  <span>deploy-gh-pages</span><span>:</span>
    <span>runs-on</span><span>:</span> ubuntu<span>-</span>latest
    <span>steps</span><span>:</span>
      <span># 获取源码</span>
      <span>-</span> <span>name</span><span>:</span> Checkout
        <span>uses</span><span>:</span> actions/checkout@v2
        <span>with</span><span>:</span>
          <span>persist-credentials</span><span>:</span> <span>false</span>
          <span>ssh-key</span><span>:</span> $<span>{</span><span>{</span> secrets.SSH_PRIVATE_KEY <span>}</span><span>}</span>
          <span>submodules</span><span>:</span> <span>true</span>
          <span>fetch-depth</span><span>:</span> <span>0</span>
	  <span># 缓存依赖项配置</span>
      <span>-</span> <span>uses</span><span>:</span> actions/cache@v2
        <span>id</span><span>:</span> node<span>-</span>modules
        <span>with</span><span>:</span>
          <span>path</span><span>:</span> node_modules/
          <span>key</span><span>:</span> $<span>{</span><span>{</span> runner.os <span>}</span><span>}</span><span>-</span>node<span>-</span>modules<span>-</span>$<span>{</span><span>{</span> hashFiles('yarn.lock') <span>}</span><span>}</span>
          <span>restore-keys</span><span>:</span> <span>|</span><span>
            ${{ runner.os }}-node-modules-</span>
	  <span># 安装依赖</span>
      <span>-</span> <span>name</span><span>:</span> Install Deps
        <span>if</span><span>:</span> steps.node<span>-</span>modules.outputs.cache<span>-</span>hit <span>!=</span> 'true'
        <span>run</span><span>:</span> yarn install <span>-</span><span>-</span>frozen<span>-</span>lockfile

	  <span># 构建</span>
      <span>-</span> <span>name</span><span>:</span> Build reco<span>-</span>demo
        <span>run</span><span>:</span> yarn run build

	  <span># 部署</span>
      <span>-</span> <span>name</span><span>:</span> Deploy To gh<span>-</span>pages
        <span>uses</span><span>:</span> JamesIves/github<span>-</span>pages<span>-</span>deploy<span>-</span>action@releases/v3
        <span>with</span><span>:</span>
          <span>ACCESS_TOKEN</span><span>:</span> $<span>{</span><span>{</span> secrets.ACCESS_TOKEN <span>}</span><span>}</span>
          <span>BRANCH</span><span>:</span> gh<span>-</span>pages
          <span>FOLDER</span><span>:</span> .vuepress/dist
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br></div></div><p><strong>第二步</strong>：配置<code>ACCESS_TOKEN</code></p>
<p>1、生成Personal access tokens（ <mark>仅第一次显示</mark> ）</p>
<p><img src="./assets/vuepress29.png" alt=""></p>
<p>2、复制 <code>ACCESS_TOKEN</code>内容到仓库的Settings --&gt; Secrets--&gt;<code>ACCESS_TOKEN</code></p>
<p><img src="./assets/vuepress32.png" alt=""></p>
<p><strong>第三步</strong>：配置<code>SSH_PRIVATE_KEY</code></p>
<p>1、生成sshkey: 输入命令ssh-keygen -t rsa -C &quot;邮箱地址&quot; 【邮箱地址：注册github时填写的邮箱地址】</p>
<div><pre><code>ssh-keygen -t rsa -C <span>"1715261428@qq.com"</span>
</code></pre>
<div><span>1</span><br></div></div><p>2、进入.ssh目录</p>
<p><img src="./assets/vuepress30.png" alt=""></p>
<p>3、复制 id_rsa内容到仓库的 Settings --&gt; Secrets--&gt;SSH_PRIVATE_KEY</p>
<p><img src="./assets/vuepress31.png" alt=""></p>
<p><strong>第四步</strong>：测试</p>
<p>报错如下</p>
<p><img src="./assets/vuepress33.png" alt=""></p>
<p>我们config.js的配置这样：</p>
<div><pre><code><span>const</span> sidebar <span>=</span> <span>require</span><span>(</span><span>'./config/sidebar'</span><span>)</span>
<span>const</span> nav <span>=</span> <span>require</span><span>(</span><span>'./config/navbar'</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>本地测试正常，线上就出问题，那我们就配置完整路径</p>
<div><pre><code><span>const</span> sidebar <span>=</span> <span>require</span><span>(</span><span>'./config/sidebar/index.js'</span><span>)</span>
</code></pre>
<div><span>1</span><br></div></div><p>再次提交，测试，部署成功。</p>
<p><img src="./assets/vuepress34.png" alt=""></p>
<p><strong>第五步</strong>：配置域名</p>
<div><p>补充：设置域名dns指向</p>
<p>方法有<strong>3种</strong>：</p>
<ul>
<li><strong>第一种：</strong>
A记录：域名直接映射IP，但是这个IP换成了192.30.252.153或192.30.252.154。</li>
<li><strong>第二种：</strong>
如果域名提供商支持ALIAS或ANAME，将域名指向username.github.io，这样可以在域名解析的时候得到一个动态的IP，这个IP是一台离你最近的镜像主机。</li>
<li><strong>第三种：</strong>
CNMAE：如果你希望使用二级域名访问，将一个二级域名配置成CNAME，指向username.github.io，这样可以在域名解析的时候得到一个动态的IP，这个IP是一台离你最近的镜像主机</li>
</ul>
<p>我使用的是第三种方法CNAME。</p>
</div>
<p>在域名供应商处新增一个CNAME类型的域名域名解析,记录类型固定的是 ：<strong>CNAME</strong>，记录值就是你的<strong>GitHub</strong>地址</p>
<p>这里还白嫖了百度云CDN加速</p>
<p><img src="./assets/vuepress35.png" alt=""></p>
<p>Github Pages添加自定义域名，点击<code>save</code>等它解析一会</p>
<p><img src="./assets/vuepress36.png" alt=""></p>
<p>如下图所示，你可以通过域名http://reco-demo.dreamagain.top访问了</p>
<p><img src="./assets/vuepress37.png" alt=""></p>
<p>访问测试，又是一个surprise！！！,就是惊喜加意外。</p>
<p><img src="./assets/vuepress38.png" alt=""></p>
<p>如上图中资源的访问路径应该是没有问题，那我们通过deploy.sh直接设置自定义域名试一下</p>
<div><pre><code><span># 如果是发布到自定义域名</span>
<span>echo</span> <span>'reco-demo.dreamagain.top'</span> <span>></span> CNAME
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>执行命令<code>yarn run deploy</code>，运行结束后再次访问<code>reco-demo.dreamagain.top</code>，样式依旧还是没有出来</p>
<p>两种方式下自定义域名都出现样式丢失，想到之前样式丢失的时候我们加了<code>base:&quot;/reco-demo/&quot;</code>，我们注释掉base配置尝试一下。</p>
<p>结果发现注释之后能通过自定义域名正常访问了。</p>
<p><img src="./assets/vuepress39.png" alt=""></p>
<p>对比一下没有配置自定义域名的情况下如何访问到静态资源的</p>
<p><img src="./assets/vuepress40.png" alt=""></p>
<p>这就是说明了自定义域名<code>http://reco-demo.dreamagain.top/</code>--&gt;<code>https://small-universe.github.io/reco-demo/</code></p>
<p>在vuepress中没有看到这样的说明，那我们就去github中看看自定义域名的相关文档，</p>
<p><img src="./assets/vuepress41.png" alt=""></p>
<p>与测试时得出的结论有点出入，但大体是一个意思。仓库下配置类自定义域名<code>reco-demo.dreamagain.top</code>虽然只是替换的<code>&lt;user&gt;.github.io</code>，但此时Gihub Pages服务已经默认通过域名直接访问仓库中资源，所以这时候不用在config.js中添加<code>base:&quot;/reco-demo/&quot;</code>了</p>
<p>::: 小结</p>
<p>仓库名为<code>&lt;username&gt;.github.io</code>或者是使用自定义域名，不用在config.js中配置base字段</p>
<p>不使用自定义域名且仓库名不是<code>&lt;username&gt;.github.io</code>,那么<code>base</code> 应该被设置成 <code>&quot;/&lt;仓库名&gt;/&quot;</code></p>
<p>:::</p>
<p><strong>完善评论功能</strong></p>
<p>第一步：<a href="https://console.leancloud.cn/login" target="_blank" rel="noopener noreferrer">LeanCloud</a>注册并登录</p>
<p><img src="./assets/vuepress42.png" alt=""></p>
<p>第二步：创建应用</p>
<p><img src="./assets/vuepress43.png" alt=""></p>
<p>第三步：获取AppKey和AppID</p>
<p><img src="./assets/vuepress44.png" alt=""></p>
<p><img src="./assets/vuepress45.png" alt=""></p>
<p>第四步：在仓库中添加刚刚获得的Key和ID</p>
<p><img src="./assets/vuepress46.png" alt=""></p>
<p>第五步：在deploy.yml中添加如下内容</p>
<div><div><br><br><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><br><br></div><pre><code><span>-</span> <span>name</span><span>:</span> Build reco<span>-</span>demo
  <span>run</span><span>:</span> yarn run build
  <span>env</span><span>:</span>
     <span>LEANCLOUD_APP_ID</span><span>:</span> $<span>{</span><span>{</span> secrets.LEANCLOUD_APP_ID <span>}</span><span>}</span> <span># 评论系统的ID</span>
     <span>LEANCLOUD_APP_KEY</span><span>:</span> $<span>{</span><span>{</span> secrets.LEANCLOUD_APP_KEY <span>}</span><span>}</span> <span># 评论系统的KEY</span>

</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>第六步：测试</p>
<p><img src="./assets/vuepress47.png" alt=""></p>
<h3 id="三-部署到阿里云服务器-可选"> （三）部署到阿里云服务器（可选）</h3>
<p>实现步骤：</p>
<ol>
<li><code>zip -r dist.zip .vuepress/dist</code> 将构建的静态文件压缩</li>
<li><code>appleboy/scp-action@master</code> 拷贝文件到服务器</li>
<li><code>appleboy/ssh-action@master</code> SSH远程登录服务器将原文件备份并解压<code>dist.zip</code></li>
<li>安装配置nginx、测试访问</li>
</ol>
<blockquote>
<p>4、配置yml文件</p>
</blockquote>
<p>需要在Secrets中添加：</p>
<ul>
<li>ALIYUN_SERVER_IP ：服务器的IP地址</li>
<li>ALIYUN_SERVER_USERNAME：服务器用户名</li>
<li>ALIYUN_SERVER_PASSWORD：服务器登录密码</li>
<li>ALIYUN_SERVER_PORT：SSH端口</li>
</ul>
<p>在deploy.yml中添加以下 <mark>高亮部分</mark> 的代码内容</p>
<div><div><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><br><br><br><br><br><br><br><br><br><br><br><br><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><br><br><br></div><pre><code><span>name</span><span>:</span> Deploy

<span>on</span><span>:</span>
  <span>push</span><span>:</span>
    <span>branches</span><span>:</span>
      <span>-</span> master

<span>jobs</span><span>:</span>
  <span>deploy-gh-pages</span><span>:</span>
    <span>runs-on</span><span>:</span> ubuntu<span>-</span>latest
    <span>steps</span><span>:</span>
      <span># 获取源码</span>
      <span>-</span> <span>name</span><span>:</span> Checkout
        <span>uses</span><span>:</span> actions/checkout@v2
        <span>with</span><span>:</span>
          <span>persist-credentials</span><span>:</span> <span>false</span>
          <span>ssh-key</span><span>:</span> $<span>{</span><span>{</span> secrets.SSH_PRIVATE_KEY <span>}</span><span>}</span>
          <span>submodules</span><span>:</span> <span>true</span>
          <span>fetch-depth</span><span>:</span> <span>0</span>
      <span># 缓存依赖项配置</span>
      <span>-</span> <span>uses</span><span>:</span> actions/cache@v2
        <span>id</span><span>:</span> node<span>-</span>modules
        <span>with</span><span>:</span>
          <span>path</span><span>:</span> node_modules/
          <span>key</span><span>:</span> $<span>{</span><span>{</span> runner.os <span>}</span><span>}</span><span>-</span>node<span>-</span>modules<span>-</span>$<span>{</span><span>{</span> hashFiles('yarn.lock') <span>}</span><span>}</span>
          <span>restore-keys</span><span>:</span> <span>|</span><span>
            ${{ runner.os }}-node-modules-</span>
      <span># 安装依赖</span>
      <span>-</span> <span>name</span><span>:</span> Install Deps
        <span>if</span><span>:</span> steps.node<span>-</span>modules.outputs.cache<span>-</span>hit <span>!=</span> 'true'
        <span>run</span><span>:</span> yarn install <span>-</span><span>-</span>frozen<span>-</span>lockfile

      <span># 构建项目并压缩为dist.zip</span>
      <span>-</span> <span>name</span><span>:</span> Build and zip
        <span>run</span><span>:</span> <span>|</span><span>
          yarn run build
          cd .vuepress
          zip -r dist.zip ./dist</span>
        <span>env</span><span>:</span>
          <span>LEANCLOUD_APP_ID</span><span>:</span> $<span>{</span><span>{</span> secrets.LEANCLOUD_APP_ID <span>}</span><span>}</span> <span># 评论系统的ID</span>
          <span>LEANCLOUD_APP_KEY</span><span>:</span> $<span>{</span><span>{</span> secrets.LEANCLOUD_APP_KEY <span>}</span><span>}</span> <span># 评论系统的KEY</span>

      <span># 部署到gh-pages分支</span>
      <span>-</span> <span>name</span><span>:</span> Deploy To gh<span>-</span>pages
        <span>uses</span><span>:</span> JamesIves/github<span>-</span>pages<span>-</span>deploy<span>-</span>action@releases/v3
        <span>with</span><span>:</span>
          <span>ACCESS_TOKEN</span><span>:</span> $<span>{</span><span>{</span> secrets.ACCESS_TOKEN <span>}</span><span>}</span>
          <span>BRANCH</span><span>:</span> gh<span>-</span>pages
          <span>FOLDER</span><span>:</span> .vuepress/dist

      <span># Scp脚本拷贝dist.zip到服务器</span>
      <span>-</span> <span>name</span><span>:</span> Scp file to aliyun
        <span>uses</span><span>:</span> appleboy/scp<span>-</span>action@master
        <span>with</span><span>:</span>
          <span># IP地址</span>
          <span>host</span><span>:</span> $<span>{</span><span>{</span> secrets.ALIYUN_SERVER_IP <span>}</span><span>}</span>
          <span># 用户，如：root等</span>
          <span>username</span><span>:</span> $<span>{</span><span>{</span> secrets.ALIYUN_SERVER_USERNAME <span>}</span><span>}</span>
          <span># 密码</span>
          <span>password</span><span>:</span> $<span>{</span><span>{</span> secrets.ALIYUN_SERVER_PASSWORD <span>}</span><span>}</span>
          <span># ssh端口，如：22</span>
          <span>port</span><span>:</span> $<span>{</span><span>{</span> secrets.ALIYUN_SERVER_PORT <span>}</span><span>}</span>
          <span>source</span><span>:</span> <span>".vuepress/dist.zip"</span>
          <span># 将文件拷贝到服务器</span>
          <span>target</span><span>:</span> <span>"/home/tmp"</span>

      <span># 备份、解压、删除</span>
      <span>-</span> <span>name</span><span>:</span> Backup and unzip
        <span>uses</span><span>:</span> appleboy/ssh<span>-</span>action@master
        <span>with</span><span>:</span>
          <span># IP地址</span>
          <span>host</span><span>:</span> $<span>{</span><span>{</span> secrets.ALIYUN_SERVER_IP <span>}</span><span>}</span>
          <span># 用户，如:root等</span>
          <span>username</span><span>:</span> $<span>{</span><span>{</span> secrets.ALIYUN_SERVER_USERNAME <span>}</span><span>}</span>
          <span># 密码</span>
          <span>password</span><span>:</span> $<span>{</span><span>{</span> secrets.ALIYUN_SERVER_PASSWORD <span>}</span><span>}</span>
          <span># ssh端口，如：22</span>
          <span>port</span><span>:</span> $<span>{</span><span>{</span> secrets.ALIYUN_SERVER_PORT <span>}</span><span>}</span>
          <span># 先备份再解压</span>
          <span>script</span><span>:</span> <span>|</span><span>
            echo "################# files remove #################"
            if [ -f "/home/web/reco-demo-bak" ];then
              rm -rf /home/web/reco-demo-bak
              echo "reco-demo-bak exists and is deleted"
            fi
            echo "################# files backup #################"
            if [ -f "/home/web/reco-demo" ];then
              mv /home/web/reco-demo /home/web/reco-demo-bak
              echo "reco-demo exists and is backuped"
            else
              mkdir /home/web/reco-demo
            fi
            echo "################# unzip dist.zip #################"
            unzip -od  /home/web/reco-demo /home/tmp/dist.zip</span>


</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br><span>96</span><br></div></div><blockquote>
<p>5、配置nginx</p>
</blockquote>
<div><p>提示</p>
<p><a href="">Linux安装Nginx</a></p>
<p>默认的<code>nginx.conf</code>文件会帮你将<code>.*\.(js|css)?$</code>文件和 <code>.*\.(gif|jpg|jpeg|png|bmp|swf|ico)$</code>这些文件进行缓存</p>
</div>
<p>修改<code>nginx.conf</code>内容如下：</p>
<div><div><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><br><br><br><br><br><br><br><br><br><br></div><pre><code>
#user  nobody;
worker_processes  <span>1</span>;

#error_log  logs/error.log;
#error_log  logs/error.log  notice;
#error_log  logs/error.log  info;

#pid        logs/nginx.pid;


events <span>{</span>
    worker_connections  <span>1024</span>;
<span>}</span>


http <span>{</span>
    include       mime.types;
    default_type  application/octet-stream;

    sendfile        on;
    keepalive_timeout  <span>65</span>;

    server <span>{</span>
    	#监听的是<span>80</span>端口，不建议换成其他端口，因为换成其他端口后，你访问时，域名也得加上加上端口，
        #比如端口号改成<span>8080</span>，访问时则是： reco-demo.dreamagain.top<span>:</span><span>8080</span>
        listen       <span>80</span>;
        server_name  demo.dreamagain.top;

        #如果访问的是ip，则直接返回<span>404</span>，此处只允许通过域名访问
		if ($host ~ <span>"\d+\.\d+\.\d+\.\d"</span>) <span>{</span>
    			return <span>404</span>;
		<span>}</span>

        location / <span>{</span>
            root   /home/web/reco-demo/dist;
            index  index.html index.htm;
        <span>}</span>
        error_page   <span>500</span> <span>502</span> <span>503</span> <span>504</span>  /50x.html;
        location = /50x.html <span>{</span>
            root   html;
        <span>}</span>

    <span>}</span>

<span>}</span>

</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br></div></div><div><p>nginx常用命令</p>
<p>./nginx   启动nginx</p>
<p>./nginx -s stop 关闭nginx</p>
<p>./nginx -s quit  退出nginx</p>
<p>./nginx -s reload 重启nginx（重启用户基本感觉不到）</p>
</div>
<p>访问<code>demo.dreamagain.top</code>，页面正常显示，测试成功</p>
<p><img src="./assets/vuepress49.png" alt=""></p>
<h2 id="五、写在最后的话"> 五、写在最后的话</h2>
<p>如此折腾，做一个属于自己的博客，其实也不会有几个人能看到，毕竟沧海一粟，如此平凡。</p>
<p>这篇博客正好是自己第一次入坑vuepress的心路历程，特此复现记录在此，限于主要从事Java开发的前端渣渣，很多前端相关问题也是点到即止，有什么建议可以评论区留言，这篇博客内容将会不断的更新完善，努力做到简洁、通俗易懂。</p>
<p>如果你有幸看到此篇博客，并且内容正好能解决你当前遇到的问题，欢迎留言支持 (/≧▽≦/) 。</p>
<div><p>感谢</p>
<p>【<a href="https://vuepress.vuejs.org/zh/" target="_blank" rel="noopener noreferrer">VuePress</a> 】</p>
<p>【  <a href="https://vuepress-reco-doc.now.sh/" target="_blank" rel="noopener noreferrer">vuepress-theme-reco</a>】</p>
<p>【<a href="https://www.jianshu.com/p/37509da5a020" target="_blank" rel="noopener noreferrer">南宫__</a>】</p>
<p>【 <a href="https://www.jianshu.com/p/2220dbacfde1" target="_blank" rel="noopener noreferrer">kobuta</a>】</p>
<p>【<a href="https://tsanfer.xyz/" target="_blank" rel="noopener noreferrer">Tsanfer's Blog</a>】</p>
</div>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <category term="使用指南"/>
    <contributor>
      <name>南辞</name>
    </contributor>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">Java必备208道面试题</title>
    <id>http://qiqi.dreamagain.top/interview/Java208/</id>
    <link href="http://qiqi.dreamagain.top/interview/Java208/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <summary type="html"><![CDATA[<div><p>声明</p>
<p>此份面试题来自知乎<a href="https://www.zhihu.com/question/27858692/answer/787505434" target="_blank" rel="noopener noreferrer">java经验总结</a> ，原文参考答案比较浅显且部分有误，目前已对部分参考答案进行订正、补充。</p>
<p>提示：此份面试题在学完相关基础后食用效果最佳，可以快速查缺补漏，加深对知识的理解。切忌死记硬背，编程重在理解思想和代码编写</p>
</div>
]]></summary>
    <content type="html"><![CDATA[<div><p>声明</p>
<p>此份面试题来自知乎<a href="https://www.zhihu.com/question/27858692/answer/787505434" target="_blank" rel="noopener noreferrer">java经验总结</a> ，原文参考答案比较浅显且部分有误，目前已对部分参考答案进行订正、补充。</p>
<p>提示：此份面试题在学完相关基础后食用效果最佳，可以快速查缺补漏，加深对知识的理解。切忌死记硬背，编程重在理解思想和代码编写</p>
</div>

<h2 id="一-面试题模块介绍"> 一. 面试题模块介绍</h2>
<p>这份面试题，包含的内容了十九了模块：Java 基础、容器、多线程、反射、对象拷贝、Java Web 模块、异常、网络、设计模式、Spring/Spring MVC、Spring Boot/Spring Cloud、Hibernate、Mybatis、RabbitMQ、Kafka、Zookeeper、MySql、Redis、JVM 。如下图所示：</p>
<img src="./assets/java-00.png"  />
<p>可能对于初学者不需要看后面的框架和 JVM 模块的知识，读者朋友们可根据自己的情况，选择对应的模块进行阅读。</p>
<h2 id="二-适宜阅读人群"> 二. 适宜阅读人群</h2>
<ul>
<li>需要面试的初/中/高级 java 程序员</li>
<li>想要查漏补缺的人</li>
<li>想要不断完善和扩充自己 java 技术栈的人</li>
<li>java 面试官</li>
</ul>
<h2 id="三-具体面试题"> 三. 具体面试题</h2>
<div><p>(一)、Java基础</p>
<br/>
</div>
<p>1.JDK和JRE有什么区别?</p>
<p>2.==和equals的区别是什么?</p>
<p>3.两个对象的 hashCode()相同，则equals()也一定为true，对吗?</p>
<p>4.final在java中有什么作用?</p>
<p>5.java中的 Math.round(-1.5)等于多少?</p>
<p>6.String 属于基础的数据类型吗?</p>
<p>7.java 中操作字符串都有哪些类?它们之间有什么区别?</p>
<p>8.String str=&quot;i&quot;与String str=new String(&quot;i&quot;)一样吗?</p>
<p>9.如何将字符串反转?</p>
<p>10.String类的常用方法都有那些?</p>
<p>11.抽象类必须要有抽象方法吗?</p>
<p>12.普通类和抽象类有哪些区别?</p>
<p>13.抽象类能使用final 修饰吗?</p>
<p>14.接口和抽象类有什么区别?</p>
<p>15.java中IO流分为几种?</p>
<p>16.BIO、NIO、AIO有什么区别</p>
<p>17.Files的常用方法有哪些？</p>
<div>
<p><a href="./模块01—Java基础.html">参考答案</a></p>
</div>
<hr>
<div><p>（二）、容器</p>
<br/>
</div>
<p>18.java容器都有哪些?</p>
<p>19.Collection和Collections有什么区别?</p>
<p>20.List、Set、Map 之间的区别是什么?</p>
<p>21.HashMap和Hashtable有什么区别?</p>
<p>22.如何决定使用HashMap还是TreeMap?</p>
<p>23.说一下HashMap 的实现原理?</p>
<p>24.说一下 HashSet 的实现原理?</p>
<p>25.ArrayList和LinkedList的区别是什么?</p>
<p>26.如何实现数组和List 之间的转换?</p>
<p>27.ArrayList和Vector 的区别是什么?</p>
<p>28.Array和ArrayList有何区别?</p>
<p>29.在 Queue 中 poll()和remove()有什么区别?</p>
<p>30.哪些集合类是线程安全的?</p>
<p>31.迭代器lterator 是什么?</p>
<p>32.lterator怎么使用?有什么特点?</p>
<p>33.lterator和Listlterator有什么区别?</p>
<p>34.怎么确保一个集合不能被修改？</p>
<div>
<p><a href="./模块02—Java集合.html">参考答案</a></p>
</div>
<hr>
<div><p>（三）、多线程</p>
<br/>
</div>
<p>35.并行和并发有什么区别?</p>
<p>36.线程和进程的区别?</p>
<p>37.守护线程是什么?</p>
<p>38.创建线程有哪几种方式?</p>
<p>39.说一下runnable和callable有什么区别?</p>
<p>40.线程有哪些状态?</p>
<p>41.sleep()和wait()有什么区别?</p>
<p>42.notify()和 notifyAll)有什么区别?</p>
<p>43.线程的run()和start()有什么区别?</p>
<p>44.创建线程池有哪几种方式?</p>
<p>45.线程池都有哪些状态?</p>
<p>46.线程池中 submit()和execute()方法有什么区别?</p>
<p>47.在java程序中怎么保证多线程的运行安全?</p>
<p>48.多线程锁的升级原理是什么?</p>
<p>49.什么是死锁?</p>
<p>50.怎么防止死锁?</p>
<p>51.ThreadLocal是什么?有哪些使用场景?</p>
<p>52.说一下synchronized底层实现原理?</p>
<p>53.synchronized和volatile 的区别是什么?</p>
<p>54.synchronized和Lock有什么区别?</p>
<p>55.synchronized和ReentrantLock区别是什么?</p>
<p>56.说一下atomic 的原理?</p>
<hr>
<div><p>（四）、反射</p>
<br/>
</div>
<p>57.什么是反射?</p>
<p>58.什么是java序列化?什么情况下需要序列化?</p>
<p>59.动态代理是什么?有哪些应用?</p>
<p>60.怎么实现动态代理?</p>
<hr>
<div><p>（五）、对象拷贝</p>
<br/>
</div>
<p>61.为什么要使用克隆?</p>
<p>62.如何实现对象克隆?</p>
<p>63.深拷贝和浅拷贝区别是什么?</p>
<hr>
<div><p>（六）、Java Web</p>
<br/>
</div>
<p>64.jsp和servlet有什么区别?</p>
<p>65.jsp有哪些内置对象?作用分别是什么?</p>
<p>66.说一下jsp的4种作用域?</p>
<p>67.session和cookie有什么区别?</p>
<p>68.说一下 session的工作原理?</p>
<p>69.如果客户端禁止 cookie 能实现session 还能用吗?</p>
<p>70.spring mvc和struts 的区别是什么?</p>
<p>71.如何避免 sql注入?</p>
<p>72.什么是XSS攻击,如何避免?</p>
<p>73.什么是CSRF攻击，如何避免?</p>
<hr>
<div><p>（七）、异常</p>
<br/>
</div>
<p>74.throw和throws 的区别?</p>
<p>75.final、finally、finalize有什么区别?</p>
<p>76.try-catch-finally 中哪个部分可以省略?</p>
<p>77.try-catch-finally中，如果catch 中 return 了, finally还会执行吗?78.常见的异常类有哪些?</p>
<hr>
<div><p>（八）、网络</p>
<br/>
</div>
<p>79.http响应码301和302代表的是什么?有什么区别?</p>
<p>80.forward和redirect的区别?</p>
<p>81.简述tcp和udp的区别?</p>
<p>82.tcp为什么要三次握手，两次不行吗?为什么?</p>
<p>83.说一下 tcp粘包是怎么产生的?</p>
<p>84.OSl的七层模型都有哪些?</p>
<p>85.get和post请求有哪些区别?</p>
<p>86.如何实现跨域?</p>
<p>87.说一下JSONP 实现原理?</p>
<hr>
<div><p>（九）、设计模式</p>
<br/>
</div>
<p>88.说一下你熟悉的设计模式?</p>
<p>89.简单工厂和抽象工厂有什么区别?</p>
<hr>
<div><p>（十）.Spring/Spring MVC</p>
<br/>
</div>
<p>90.为什么要使用spring?</p>
<p>91.解释一下什么是aop?</p>
<p>9⒉.解释一下什么是ioc?</p>
<p>93.spring有哪些主要模块?</p>
<p>94.spring 常用的注入方式有哪些?</p>
<p>95.spring 中的 bean是线程安全的吗?</p>
<p>96.spring支持几种bean的作用域?</p>
<p>97.spring自动装配bean有哪些方式?</p>
<p>98.spring事务实现方式有哪些?</p>
<p>99.说一下spring 的事务隔离?</p>
<p>100.说一下spring mvc运行流程?</p>
<p>101.spring mvc有哪些组件?</p>
<p>102.@RequestMapping 的作用是什么?</p>
<p>103.@Autowired的作用是什么?</p>
<hr>
<div><p>（十一）、Spring Boot/Spring Cloud</p>
<br/>
</div>
<p>104.什么是spring boot?</p>
<p>105.为什么要用spring boot?</p>
<p>106.spring boot核心配置文件是什么?</p>
<p>107.spring boot配置文件有哪几种类型?它们有什么区别?</p>
<p>108.spring boot有哪些方式可以实现热部署?</p>
<p>109.jpa和hibernate有什么区别?</p>
<p>110.什么是 spring cloud?</p>
<p>111.spring cloud 断路器的作用是什么?</p>
<p>112.spring cloud的核心组件有哪些?</p>
<hr>
<div><p>（十二）、Hibernate</p>
<br/>
</div>
<p>113.为什么要使用hibernate?</p>
<p>114.什么是 ORM框架?</p>
<p>115.hibernate 中如何在控制台查看打印的sql语句?</p>
<p>116.hibernate有几种查询方式?</p>
<p>117.hibernate 实体类可以被定义为final 吗?</p>
<p>118.在hibernate中使用Integer和int做映射有什么区别?</p>
<p>119.hibernate是如何工作的?</p>
<p>120.get()和load()的区别?</p>
<p>121.说一下 hibernate 的缓存机制?</p>
<p>122.hibernate对象有哪些状态?</p>
<p>123.在 hibernate 中 getCurrentSession和openSession的区别是什么?</p>
<p>124.hibernate 实体类必须要有无参构造函数吗?为什么?</p>
<hr>
<div><p>（十三）、Mybatis</p>
<br/>
</div>
<p>125.mybatis 中#{和$0的区别是什么?</p>
<p>126.mybatis有几种分页方式?</p>
<p>127.RowBounds是一次性查询全部结果吗?为什么?</p>
<p>128.mybatis逻辑分页和物理分页的区别是什么?</p>
<p>129.mybatis 是否支持延迟加载?延迟加载的原理是什么?</p>
<p>130.说一下mybatis的一级缓存和二级缓存?</p>
<p>131.mybatis 和 hibernate的区别有哪些?</p>
<p>132.mybatis有哪些执行器(Executor) ?</p>
<p>133.mybatis分页插件的实现原理是什么?</p>
<p>134.mybatis 如何编写一个自定义插件?</p>
<hr>
<div><p>（十四）、RabbitMQ</p>
<br/>
</div>
<p>135.rabbitmq的使用场景有哪些?</p>
<p>136.rabbitmq有哪些重要的角色?</p>
<p>137.rabbitmq有哪些重要的组件?</p>
<p>138.rabbitmq中 vhost的作用是什么?</p>
<p>139.rabbitmq的消息是怎么发送的?</p>
<p>140.rabbitmq怎么保证消息的稳定性?</p>
<p>141.rabbitmq怎么避免消息丢失?</p>
<p>142.要保证消息持久化成功的条件有哪些?</p>
<p>143.rabbitmq持久化有什么缺点?</p>
<p>144.rabbitmq有几种广播类型?</p>
<p>145.rabbitmq怎么实现延迟消息队列?</p>
<p>146.rabbitmq集群有什么用?</p>
<p>147.rabbitmq节点的类型有哪些?</p>
<p>148.rabbitmq集群搭建需要注意哪些问题?</p>
<p>149.rabbitmq每个节点是其他节点的完整拷贝吗?为什么?</p>
<p>150.rabbitmq集群中唯—一个磁盘节点崩溃了会发生什么情况?</p>
<hr>
<div><p>（十五）、Kafka</p>
<br/>
</div>
<p>152.kafka可以脱离zookeeper单独使用吗?为什么?</p>
<p>153.kafka有几种数据保留的策略?</p>
<p>154.kafka同时设置了7天和10G清除数据，到第五天的时候消息达到了10G，这个时候 kafka将如何处理?</p>
<p>155.什么情况会导致kafka运行变慢?</p>
<p>156.使用kafka集群需要注意什么?</p>
<hr>
<div><p>（十六）、Zookeeper</p>
<br/>
</div>
<p>157.zookeeper是什么?</p>
<p>158.zookeeper都有哪些功能?</p>
<p>159.zookeeper有几种部署模式?</p>
<p>160.zookeeper怎么保证主从节点的状态同步?</p>
<p>161.集群中为什么要有主节点?</p>
<p>162.集群中有3台服务器，其中一个节点宕机，这个时候zookeeper还可以使用吗?</p>
<p>163.说一下zookeeper的通知机制?</p>
<hr>
<div><p>（十七）.MySQL</p>
<br/>
</div>
<p>164.数据库的三范式是什么?</p>
<p>165.一张自增表里面总共有7条数据，删除了最后⒉条数据，重启 mysql数据库，又插入了一条数据，此时id是几?</p>
<p>166.如何获取当前数据库版本?</p>
<p>167.说一下ACID是什么?</p>
<p>168.char和varchar 的区别是什么?</p>
<p>169.float和double的区别是什么?</p>
<p>170.mysql 的内连接、左连接、右连接有什么区别?</p>
<p>171.mysql索引是怎么实现的?</p>
<p>172.怎么验证 mysql的索引是否满足需求?</p>
<p>173.说一下数据库的事务隔离?</p>
<p>174.说一下mysql常用的引擎?</p>
<p>175.说一下mysql的行锁和表锁?</p>
<p>176.说一下乐观锁和悲观锁?</p>
<p>177.mysql问题排查都有哪些手段?</p>
<p>178.如何做mysql的性能优化?</p>
<hr>
<div><p>（十八）、Redis</p>
<br/>
</div>
<p>179.redis是什么?都有哪些使用场景?</p>
<p>180.redis有哪些功能?</p>
<p>181.redis和 memecache有什么区别?</p>
<p>182.redis为什么是单线程的?</p>
<p>183.什么是缓存穿透?怎么解决?</p>
<p>184.redis支持的数据类型有哪些?</p>
<p>185.redis支持的java客户端都有哪些?</p>
<p>186.jedis和redisson有哪些区别?</p>
<p>187.怎么保证缓存和数据库数据的一致性?</p>
<p>188.redis持久化有几种方式?</p>
<p>189.redis 怎么实现分布式锁?</p>
<p>190.redis分布式锁有什么缺陷?</p>
<p>191.redis如何做内存优化?</p>
<p>192.redis淘汰策略有哪些?</p>
<p>193.redis 常见的性能问题有哪些?该如何解决?</p>
<hr>
<div><p>（十九）、JVM</p>
<br/>
</div>
<p>194.说一下 jvm的主要组成部分?及其作用?</p>
<p>195.说一下 jvm运行时数据区?</p>
<p>196.说一下堆栈的区别?</p>
<p>197.队列和栈是什么?有什么区别?</p>
<p>198.什么是双亲委派模型?</p>
<p>199.说一下类加载的执行过程?</p>
<p>200.怎么判断对象是否可以被回收?</p>
<p>201.java中都有哪些引用类型?</p>
<p>202.说一下 jvm有哪些垃圾回收算法?</p>
<p>203.说一下 jvm有哪些垃圾回收器?</p>
<p>204.详细介绍一下 CMS垃圾回收器?</p>
<p>205.新生代垃圾回收器和老生代垃圾回收器都有哪些?有什么区别?</p>
<p>206.简述分代垃圾回收器是怎么工作的?</p>
<p>207.说一下jvm调优的工具?</p>
<p>208.常用的jvm调优的参数都有哪些?</p>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <contributor>
      <name>南辞</name>
    </contributor>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">模块01-Java基础</title>
    <id>http://qiqi.dreamagain.top/interview/Java208/%E6%A8%A1%E5%9D%9701%E2%80%94Java%E5%9F%BA%E7%A1%80/</id>
    <link href="http://qiqi.dreamagain.top/interview/Java208/%E6%A8%A1%E5%9D%9701%E2%80%94Java%E5%9F%BA%E7%A1%80/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<h2 id="问题"> 问题：</h2>
<p>1.JDK和JRE有什么区别?</p>
<p>2.==和equals的区别是什么?</p>
<p>3.两个对象的 hashCode()相同，则equals()也一定为true，对吗?</p>
<p>4.final在java中有什么作用?</p>
<p>5.java中的 Math.round(-1.5)等于多少?</p>
<p>6.String 属于基础的数据类型吗?</p>
<p>7.java 中操作字符串都有哪些类?它们之间有什么区别?</p>
<p>8.String str=&quot;i&quot;与String str=new String(&quot;i&quot;)一样吗?</p>
<p>9.如何将字符串反转?</p>
<p>10.String类的常用方法都有那些?</p>
<p>11.抽象类必须要有抽象方法吗?</p>
<p>12.普通类和抽象类有哪些区别?</p>
<p>13.抽象类能使用final 修饰吗?</p>
<p>14.接口和抽象类有什么区别?</p>
<ol start="15">
<li>java中IO流分为几种?</li>
</ol>
<p>16.BIO、NIO、AIO有什么区别</p>
<p>17.Files的常用方法有哪些？</p>
<h2 id="答案"> 答案：</h2>
<blockquote>
<h3 id="_1-jdk和jre有什么区别"> 1.JDK和JRE有什么区别?</h3>
</blockquote>
<ul>
<li>JDK：Java Development Kit 的简称，java 开发工具包，提供了 java 的开发环境和运行环境。</li>
<li>JRE：Java Runtime Environment 的简称，java 运行环境，为 java 的运行提供了所需环境。</li>
</ul>
<p>具体来说 JDK 其实包含了 JRE，同时还包含了编译 java 源码的编译器 javac，还包含了很多 java 程序调试和分析的工具。</p>
<p>简单来说：如果你需要运行 java 程序，只需安装 JRE 就可以了，如果你需要编写 java 程序，需要安装 JDK。</p>
<blockquote>
<h3 id="_2-和equals的区别是什么"> 2.==和equals的区别是什么?</h3>
</blockquote>
<p><strong>① == 解读</strong></p>
<p>对于基本类型和引用类型 == 的作用效果是不同的，如下所示：</p>
<ul>
<li>基本类型：比较的是值是否相同；</li>
<li>引用类型：比较的是引用是否相同；</li>
</ul>
<p>代码示例：</p>
<div><pre><code><span>String</span> x <span>=</span> <span>"string"</span><span>;</span>
<span>String</span> y <span>=</span> <span>"string"</span><span>;</span>
<span>String</span> z <span>=</span> <span>new</span> <span>String</span><span>(</span><span>"string"</span><span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>x<span>==</span>y<span>)</span><span>;</span> <span>// true</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>x<span>==</span>z<span>)</span><span>;</span> <span>// false</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>x<span>.</span><span>equals</span><span>(</span>y<span>)</span><span>)</span><span>;</span> <span>// true</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>x<span>.</span><span>equals</span><span>(</span>z<span>)</span><span>)</span><span>;</span> <span>// true</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>代码解读：因为 x 和 y 指向的是同一个引用，所以 == 也是 true，而 new String()方法则重新<strong>在堆区</strong>中开辟了内存空间，所以 == 结果为 false，而 equals 比较的一直是值，所以结果都为 true。</p>
<p><strong>② equals 解读</strong></p>
<p>equals 本质上就是 ==，只不过 String 和 Integer 等重写了 equals 方法，把它变成了值比较。看下面的代码就明白了。</p>
<p>首先来看默认情况下 equals 比较一个有相同值的对象，代码如下：</p>
<div><pre><code><span>class</span> <span>Cat</span> <span>{</span>
    <span>public</span> <span>Cat</span><span>(</span><span>String</span> name<span>)</span> <span>{</span>
        <span>this</span><span>.</span>name <span>=</span> name<span>;</span>
    <span>}</span>

    <span>private</span> <span>String</span> name<span>;</span>

    <span>public</span> <span>String</span> <span>getName</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> name<span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>setName</span><span>(</span><span>String</span> name<span>)</span> <span>{</span>
        <span>this</span><span>.</span>name <span>=</span> name<span>;</span>
    <span>}</span>
<span>}</span>

<span>Cat</span> c1 <span>=</span> <span>new</span> <span>Cat</span><span>(</span><span>"王磊"</span><span>)</span><span>;</span>
<span>Cat</span> c2 <span>=</span> <span>new</span> <span>Cat</span><span>(</span><span>"王磊"</span><span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>c1<span>.</span><span>equals</span><span>(</span>c2<span>)</span><span>)</span><span>;</span> <span>// false</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><p>输出结果出乎我们的意料，竟然是 false？这是怎么回事，看了 equals 源码就知道了，源码如下：</p>
<div><pre><code><span>public</span> <span>boolean</span> <span>equals</span><span>(</span><span>Object</span> obj<span>)</span> <span>{</span>
    <span>return</span> <span>(</span><span>this</span> <span>==</span> obj<span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>原来 equals 本质上就是 ==。</p>
<p>那问题来了，<strong>两个相同值的 String 对象，为什么返回的是 true</strong>？代码如下：</p>
<div><pre><code><span>String</span> s1 <span>=</span> <span>new</span> <span>String</span><span>(</span><span>"老王"</span><span>)</span><span>;</span>
<span>String</span> s2 <span>=</span> <span>new</span> <span>String</span><span>(</span><span>"老王"</span><span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>s1<span>.</span><span>equals</span><span>(</span>s2<span>)</span><span>)</span><span>;</span> <span>// true</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>同样的，当我们进入 String 的 equals 方法，找到了答案，代码如下：</p>
<div><pre><code><span>public</span> <span>boolean</span> <span>equals</span><span>(</span><span>Object</span> anObject<span>)</span> <span>{</span>
    <span>//判断是否是同一个对象</span>
    <span>if</span> <span>(</span><span>this</span> <span>==</span> anObject<span>)</span> <span>{</span>
        <span>return</span> <span>true</span><span>;</span>
    <span>}</span>
    <span>//不是同一个对象才进行值比较</span>
    <span>//判断是不是String类型</span>
    <span>if</span> <span>(</span>anObject <span>instanceof</span> <span>String</span><span>)</span> <span>{</span>
        <span>String</span> anotherString <span>=</span> <span>(</span><span>String</span><span>)</span>anObject<span>;</span>
        <span>int</span> n <span>=</span> value<span>.</span>length<span>;</span>
        <span>//字符串长度比较</span>
        <span>if</span> <span>(</span>n <span>==</span> anotherString<span>.</span>value<span>.</span>length<span>)</span> <span>{</span>
            <span>char</span> v1<span>[</span><span>]</span> <span>=</span> value<span>;</span>
            <span>char</span> v2<span>[</span><span>]</span> <span>=</span> anotherString<span>.</span>value<span>;</span>
            <span>int</span> i <span>=</span> <span>0</span><span>;</span>
            <span>//两个字符数组一一进行字符比较</span>
            <span>while</span> <span>(</span>n<span>--</span> <span>!=</span> <span>0</span><span>)</span> <span>{</span>
                <span>if</span> <span>(</span>v1<span>[</span>i<span>]</span> <span>!=</span> v2<span>[</span>i<span>]</span><span>)</span>
                    <span>return</span> <span>false</span><span>;</span>
                i<span>++</span><span>;</span>
            <span>}</span>
            <span>return</span> <span>true</span><span>;</span>
        <span>}</span>
    <span>}</span>
    <span>//不是String类型的比较直接返回false</span>
    <span>return</span> <span>false</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div><p>原来是 <strong>String 重写了 Object 的 equals 方法</strong>，把<strong>引用比较改成了值比较</strong>。</p>
<p><strong>总结</strong> ：</p>
<ul>
<li>
<p>== 对于基本类型来说是值比较，对于引用类型来说是比较的是引用；</p>
</li>
<li>
<p>而 equals 默认情况下是引用比较，只是很多类重新了 equals 方法，比如 String、Integer 等把它变成了值比较，所以一般情况下 equals 比较的是值是否相等。</p>
</li>
</ul>
<blockquote>
<h3 id="_3-两个对象的-hashcode-相同-则equals-也一定为true-对吗"> 3.两个对象的 hashCode()相同，则equals()也一定为true，对吗?</h3>
</blockquote>
<p>不对，两个对象的 hashCode()相同，equals()不一定 true。</p>
<p>代码示例：</p>
<div><pre><code>String str1 = &quot;通话&quot;;
String str2 = &quot;重地&quot;;
System.out.println(String.format(&quot;str1：%d | str2：%d&quot;, str1.hashCode(),str2.hashCode()));
System.out.println(str1.equals(str2));
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>执行的结果：</p>
<p>str1：1179395 | str2：1179395</p>
<p>false</p>
<p>代码解读：很显然“通话”和“重地”的 hashCode() 相同，然而 equals() 则为 false，因为在散列表中，hashCode()相等即两个键值对的哈</p>
<p>希值相等，然而哈希值相等，并不一定能得出键值对相等。</p>
<blockquote>
<h3 id="_4-final在java中有什么作用"> 4.final在java中有什么作用?</h3>
</blockquote>
<ul>
<li>
<p>final 修饰的类叫最终类，该类不能被继承。</p>
</li>
<li>
<p>final 修饰的方法不能被重写。</p>
</li>
<li>
<p>final 修饰的变量叫常量，常量必须初始化，初始化之后值就不能被修改。</p>
</li>
</ul>
<blockquote>
<h3 id="_5-java中的-math-round-1-5-等于多少"> 5.java中的 Math.round(-1.5)等于多少?</h3>
</blockquote>
<p>等于 -1，因为在数轴上取值时，中间值（0.5）向右取整，所以正 0.5 是往上取整，负 0.5 是直接舍弃。</p>
<blockquote>
<h3 id="_6-string-属于基础的数据类型吗"> 6.String 属于基础的数据类型吗?</h3>
</blockquote>
<p>String 不属于基础类型，基础类型有 8 种：byte、short、int、long、float、double、boolean、char，而 String 属于对象。</p>
<p>这8种基本数据类型对应的存储字节数：1  2  4  8  4  8  1  2</p>
<blockquote>
<h3 id="_7-java-中操作字符串都有哪些类-它们之间有什么区别"> 7.java 中操作字符串都有哪些类?它们之间有什么区别?</h3>
</blockquote>
<p>操作字符串的类有：String、StringBuffer、StringBuilder。</p>
<p><strong>String 和 StringBuffer、StringBuilder 的区别:</strong></p>
<ul>
<li>
<p>String 声明的是不可变的对象，每次操作都会生成新的 String 对象，然后将指针指向新的 String 对象，</p>
</li>
<li>
<p>而 StringBuffer、StringBuilder 可以在原有对象的基础上进行操作，所以在经常改变字符串内容的情况下最好不要使用 String。</p>
</li>
</ul>
<p><strong>StringBuffer 和 StringBuilder 最大的区别：</strong></p>
<ul>
<li>
<p>StringBuffer 是线程安全的，而 StringBuilder 是非线程安全的，</p>
</li>
<li>
<p>但 StringBuilder 的性能却高于 StringBuffer，所以在单线程环境下推荐使用 StringBuilder，多线程环境下推荐使用 StringBuffer。</p>
</li>
</ul>
<blockquote>
<h3 id="_8-string-str-i-与string-str-new-string-i-一样吗"> 8.String str=&quot;i&quot;与String str=new String(&quot;i&quot;)一样吗?</h3>
</blockquote>
<p>不一样，因为内存的分配方式不一样。</p>
<ul>
<li>
<p>String str=&quot;i&quot;的方式，java 虚拟机会将其分配到常量池中；</p>
</li>
<li>
<p>而 String str=new String(&quot;i&quot;) 则会被分到堆内存中。</p>
</li>
</ul>
<blockquote>
<h3 id="_9-如何将字符串反转"> 9.如何将字符串反转?</h3>
</blockquote>
<p>使用 StringBuilder 或者 stringBuffer 的 reverse() 方法。当然也可以使用字符数组进行逆置</p>
<p>示例代码：</p>
<div><pre><code><span>// StringBuffer reverse</span>
<span>StringBuffer</span> stringBuffer <span>=</span> <span>new</span> <span>StringBuffer</span><span>(</span><span>)</span><span>;</span>
stringBuffer<span>.</span><span>append</span><span>(</span><span>"abcdefg"</span><span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>stringBuffer<span>.</span><span>reverse</span><span>(</span><span>)</span><span>)</span><span>;</span> <span>// gfedcba</span>
<span>// StringBuilder reverse</span>
<span>StringBuilder</span> stringBuilder <span>=</span> <span>new</span> <span>StringBuilder</span><span>(</span><span>)</span><span>;</span>
stringBuilder<span>.</span><span>append</span><span>(</span><span>"abcdefg"</span><span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>stringBuilder<span>.</span><span>reverse</span><span>(</span><span>)</span><span>)</span><span>;</span> <span>// gfedcba</span>
<span>// 字符数组</span>
<span>public</span> <span>static</span> <span>String</span> <span>reverse</span><span>(</span><span>String</span> str<span>)</span><span>{</span>
        <span>if</span> <span>(</span>str<span>==</span><span>null</span><span>||</span>str<span>.</span><span>length</span><span>(</span><span>)</span><span>==</span><span>0</span><span>||</span>str<span>.</span><span>length</span><span>(</span><span>)</span><span>==</span><span>1</span><span>)</span><span>{</span>
            <span>return</span> str<span>;</span>
        <span>}</span>
        <span>char</span><span>[</span><span>]</span> chars <span>=</span> str<span>.</span><span>toCharArray</span><span>(</span><span>)</span><span>;</span>
        <span>int</span> i <span>=</span> str<span>.</span><span>length</span><span>(</span><span>)</span><span>;</span>
        <span>int</span> j <span>=</span> <span>0</span><span>;</span>
        <span>while</span> <span>(</span>j<span>&lt;</span>i<span>)</span><span>{</span>
            <span>char</span> tmp <span>=</span> chars<span>[</span>i<span>-</span><span>1</span><span>]</span><span>;</span>
            chars<span>[</span>i<span>-</span><span>1</span><span>]</span> <span>=</span> chars<span>[</span>j<span>]</span><span>;</span>
            chars<span>[</span>j<span>]</span> <span>=</span> tmp<span>;</span>

            j<span>++</span><span>;</span>
            i<span>--</span><span>;</span>
        <span>}</span>
        str <span>=</span> <span>new</span> <span>String</span><span>(</span>chars<span>)</span><span>;</span>
         <span>return</span> str<span>;</span>
    <span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div><blockquote>
<h3 id="_10-string类的常用方法都有那些"> 10.String类的常用方法都有那些?</h3>
</blockquote>
<ul>
<li>
<p>indexOf()：返回指定字符的索引。</p>
</li>
<li>
<p>charAt()：返回指定索引处的字符。</p>
</li>
<li>
<p>replace()：字符串替换。</p>
</li>
<li>
<p>trim()：去除字符串两端空白。</p>
</li>
<li>
<p>split()：分割字符串，返回一个分割后的字符串数组。</p>
</li>
<li>
<p>getBytes()：返回字符串的 byte 类型数组。</p>
</li>
<li>
<p>length()：返回字符串长度。</p>
</li>
<li>
<p>toLowerCase()：将字符串转成小写字母。</p>
</li>
<li>
<p>toUpperCase()：将字符串转成大写字符。</p>
</li>
<li>
<p>toCharArray()：转为字符数组</p>
</li>
<li>
<p>substring()：截取字符串。</p>
</li>
<li>
<p>equals()：字符串比较。</p>
</li>
</ul>
<blockquote>
<h3 id="_11-抽象类必须要有抽象方法吗"> 11.抽象类必须要有抽象方法吗?</h3>
</blockquote>
<p>不需要，抽象类不一定非要有抽象方法。</p>
<p>示例代码：</p>
<div><pre><code><span>abstract</span> <span>class</span> <span>Cat</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>sayHi</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"hi~"</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>上面代码，抽象类并没有抽象方法但完全可以正常运行。</p>
<blockquote>
<h3 id="_12-普通类和抽象类有哪些区别"> 12.普通类和抽象类有哪些区别?</h3>
</blockquote>
<ul>
<li>普通类不能包含抽象方法，抽象类可以包含抽象方法。</li>
<li>抽象类不能直接实例化，普通类可以直接实例化。</li>
</ul>
<blockquote>
<h3 id="_13-抽象类能使用final-修饰吗"> 13.抽象类能使用final 修饰吗?</h3>
</blockquote>
<p>不能，定义抽象类就是让其他类继承的，如果定义为 final 该类就不能被继承，这样彼此就会产生矛盾，所以 final 不能修饰抽象类，</p>
<p>如果在抽象类上加final关键字，编辑器也会提示错误信息：</p>
<blockquote>
<h3 id="_14-接口和抽象类有什么区别"> 14.接口和抽象类有什么区别?</h3>
</blockquote>
<ul>
<li>实现：抽象类的子类使用 extends 来继承；接口必须使用 implements 来实现接口。</li>
<li>构造函数：抽象类可以有构造函数；接口不能有。</li>
<li>main 方法：抽象类可以有 main 方法，并且我们能运行它；接口不能有 main 方法。</li>
<li>实现数量：类可以实现很多个接口；但是只能继承一个抽象类。</li>
<li>访问修饰符：接口中的方法默认使用 public 修饰；抽象类中的方法可以是任意访问修饰符。</li>
</ul>
<blockquote>
<h3 id="_15-java中io流分为几种"> 15.java中IO流分为几种?</h3>
</blockquote>
<p>按功能来分：输入流（input）、输出流（output）。</p>
<p>按类型来分：字节流和字符流。</p>
<p>字节流和字符流的区别是：字节流按 8 位传输以字节为单位输入输出数据，字符流按 16 位传输以字符为单位输入输出数据。</p>
<blockquote>
<h3 id="_16-bio、nio、aio有什么区别"> 16.BIO、NIO、AIO有什么区别</h3>
</blockquote>
<ul>
<li>BIO：Block IO 同步阻塞式 IO，就是我们平常使用的传统 IO，它的特点是模式简单使用方便，并发处理能力低。</li>
<li>NIO：New IO 同步非阻塞 IO，是传统 IO 的升级，客户端和服务器端通过 Channel（通道）通讯，实现了多路复用。</li>
<li>AIO：Asynchronous IO 是 NIO 的升级，也叫 NIO2，实现了异步非堵塞 IO ，异步 IO 的操作基于<strong>事件和回调机制</strong>。</li>
</ul>
<blockquote>
<h3 id="_17-files的常用方法有哪些"> 17.Files的常用方法有哪些？</h3>
</blockquote>
<ul>
<li>Files.exists()：检测文件路径是否存在。</li>
<li>Files.createFile()：创建文件。</li>
<li>Files.createDirectory()：创建文件夹。</li>
<li>Files.delete()：删除一个文件或目录。</li>
<li>Files.copy()：复制文件。</li>
<li>Files.move()：移动文件。</li>
<li>Files.size()：查看文件个数。</li>
<li>Files.read()：读取文件。</li>
<li>Files.write()：写入文件。</li>
</ul>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <contributor>
      <name>南辞</name>
    </contributor>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">模块02-Java集合（容器）</title>
    <id>http://qiqi.dreamagain.top/interview/Java208/%E6%A8%A1%E5%9D%9702%E2%80%94Java%E9%9B%86%E5%90%88/</id>
    <link href="http://qiqi.dreamagain.top/interview/Java208/%E6%A8%A1%E5%9D%9702%E2%80%94Java%E9%9B%86%E5%90%88/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<h2 id="问题"> 问题：</h2>
<p>18.java容器都有哪些?</p>
<p>19.Collection和Collections有什么区别?</p>
<p>20.List、Set、Map 之间的区别是什么?</p>
<p>21.HashMap和Hashtable有什么区别?</p>
<p>22.如何决定使用HashMap还是TreeMap?</p>
<p>23.说一下HashMap 的实现原理?</p>
<p>24.说一下 HashSet 的实现原理?</p>
<p>25.ArrayList和LinkedList的区别是什么?</p>
<p>26.如何实现数组和List 之间的转换?</p>
<p>27.ArrayList和Vector 的区别是什么?</p>
<p>28.Array和ArrayList有何区别?</p>
<p>29.在 Queue 中 poll()和remove()有什么区别?</p>
<p>30.哪些集合类是线程安全的?</p>
<p>31.迭代器lterator 是什么?</p>
<p>32.lterator怎么使用?有什么特点?</p>
<p>33.lterator和Listlterator有什么区别?</p>
<p>34.怎么确保一个集合不能被修改？</p>
<h2 id="答案"> 答案：</h2>
<h3 id="_18-java容器都有哪些"> 18.java容器都有哪些?</h3>
<p><img src="./assets/java-03.png" alt=""></p>
<h3 id="_19-collection和collections有什么区别"> 19.Collection和Collections有什么区别?</h3>
<ul>
<li>java.util.Collection 是一个集合接口（集合类的一个顶级接口）。它提供了对集合对象进行基本操作的通用接口方法。Collection接口在Java 类库中有很多具体的实现。Collection接口的意义是为各种具体的集合提供了最大化的统一操作方式，其直接继承接口有List与Set。</li>
<li>Collections则是集合类的一个工具类/帮助类，其中提供了一系列静态方法，用于对集合中元素进行排序、搜索以及线程安全等各种操作。</li>
</ul>
<h3 id="_20-list、set、map-之间的区别是什么"> 20.List、Set、Map 之间的区别是什么?</h3>
<img src="./assets/java-04.png" style="zoom:80%;" />
<h3 id="_21-hashmap和hashtable有什么区别"> 21.HashMap和Hashtable有什么区别?</h3>
<ul>
<li>hashMap去掉了Hashtable 的contains方法，但是加上了containsValue（）和containsKey（）方法。</li>
<li>Hashtable同步的，而HashMap是非同步的，效率上比Hashtable要高。</li>
<li>hashMap允许空键值，而Hashtable不允许。</li>
</ul>
<h3 id="_22-如何决定使用hashmap还是treemap"> 22.如何决定使用HashMap还是TreeMap?</h3>
<p>对于在Map中插入、删除和定位元素这类操作，HashMap是最好的选择。</p>
<p>然而，假如你需要对一个有序的key集合进行遍历，TreeMap是更好的选择。基于你的collection的大小，也许向HashMap中添加元素</p>
<p>会更快，将map换为TreeMap进行有序key的遍历。</p>
<h3 id="_23-说一下hashmap-的实现原理"> 23.说一下HashMap 的实现原理?</h3>
<p><strong>HashMap概述：</strong> HashMap是基于哈希表的Map接口的非同步实现。此实现提供所有可选的映射操作，并允许使用null值和null键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。</p>
<p><strong>HashMap的数据结构：</strong> 在java编程语言中，最基本的结构就是两种，一个是数组，另外一个是模拟指针（引用），所有的数据结构都可以用这两个基本结构来构造的，HashMap也不例外。HashMap实际上是一个“链表散列”的数据结构，即数组和链表的结合体。</p>
<p>当我们往HashMap中put元素时,首先根据key的hashcode重新计算hash值,根据hash值得到这个元素在数组中的位置(下标),如果该数组在该位置上已经存放了其他元素,那么在这个位置上的元素将以链表的形式存放,新加入的放在链头,最先加入的放入链尾.如果数组中该位置没有元素,就直接将该元素放到数组的该位置上。</p>
<p>需要注意Jdk 1.8中对HashMap的实现做了优化,当链表中的节点数据超过<strong>八个</strong>之后,该链表会转为<strong>红黑树</strong>来提高查询效率,从原来的O(n)到O(logn)</p>
<h3 id="_24-说一下-hashset-的实现原理"> 24.说一下 HashSet 的实现原理?</h3>
<ul>
<li>
<p>HashSet底层由HashMap实现</p>
</li>
<li>
<p>HashSet的值存放于HashMap的key上</p>
</li>
<li>
<p>HashMap的value统一为PRESENT</p>
</li>
</ul>
<h3 id="_25-arraylist和linkedlist的区别是什么"> 25.ArrayList和LinkedList的区别是什么?</h3>
<p>最明显的区别是 ArrrayList底层的数据结构是数组，支持随机访问，而 LinkedList 的底层数据结构是双向循环链表，不支持随机访问。</p>
<p>使用下标访问一个元素，ArrayList 的时间复杂度是 O(1)，而 LinkedList 是 O(n)。</p>
<h3 id="_26-如何实现数组和list-之间的转换"> 26.如何实现数组和List 之间的转换?</h3>
<ul>
<li>
<p>List转换成为数组：调用ArrayList的toArray方法。</p>
</li>
<li>
<p>数组转换成为List：调用Arrays的asList方法。</p>
</li>
</ul>
<h3 id="_27-arraylist和vector-的区别是什么"> 27.ArrayList和Vector 的区别是什么?</h3>
<ul>
<li>
<p>Vector是同步的，而ArrayList不是。然而，如果你寻求在迭代的时候对列表进行改变，你应该使用CopyOnWriteArrayList。</p>
</li>
<li>
<p>ArrayList比Vector快，Vecto它因为有同步，不会过载。 ArrayList在多线程情况下可能会出现ConcurrentModificationException。</p>
</li>
<li>
<p>ArrayList更加通用，因为我们可以使用Collections工具类轻易地获取同步列表和只读列表。</p>
</li>
</ul>
<h3 id="_28-array和arraylist有何区别"> 28.Array和ArrayList有何区别?</h3>
<ul>
<li>
<p>Array可以容纳基本类型和对象，而ArrayList只能容纳对象。</p>
</li>
<li>
<p>Array是指定大小的，而ArrayList大小是固定的。</p>
</li>
<li>
<p>Array没有提供ArrayList那么多功能，比如addAll、removeAll和iterator等。</p>
</li>
</ul>
<h3 id="_29-在-queue-中-poll-和remove-有什么区别"> 29.在 Queue 中 poll()和remove()有什么区别?</h3>
<p>poll() 和 remove() 都是从队列中取出一个元素，但是 poll() 在获取元素失败的时候会返回空，但是 remove() 失败的时候会抛出异常。</p>
<h3 id="_30-哪些集合类是线程安全的"> 30.哪些集合类是线程安全的?</h3>
<ul>
<li>
<p>Vector：就比ArrayList多了个同步化机制（线程安全），因为效率较低，现在已经不太建议使用。在web应用中，特别是前台页面，往往效率（页面响应速度）是优先考虑的。</p>
</li>
<li>
<p>statck：堆栈类，先进后出。</p>
</li>
<li>
<p>Hashtable：就比HashMap多了个线程安全。</p>
</li>
<li>
<p>Enumeration：枚举，相当于迭代器。</p>
</li>
</ul>
<h3 id="_31-迭代器lterator-是什么"> 31.迭代器lterator 是什么?</h3>
<p>迭代器是一种设计模式，它是一个对象，它可以遍历并选择序列中的对象，而开发人员不需要了解该序列的底层结构。迭代器通常被称</p>
<p>为“轻量级”对象，因为创建它的代价小。</p>
<h3 id="_32-lterator怎么使用-有什么特点"> 32.lterator怎么使用?有什么特点?</h3>
<p>Java中的Iterator功能比较简单，并且只能单向移动：</p>
<p>(1) 使用方法iterator()要求容器返回一个Iterator。第一次调用Iterator的next()方法时，它返回序列的第一个元素。注意：iterator()方法是java.lang.Iterable接口,被Collection继承。</p>
<p>(2) 使用next()获得序列中的下一个元素。</p>
<p>(3) 使用hasNext()检查序列中是否还有元素。</p>
<p>(4) 使用remove()将迭代器新返回的元素删除。</p>
<p>Iterator是Java迭代器最简单的实现，为List设计的ListIterator具有更多的功能，它可以从两个方向遍历List，也可以从List中插入和删除元素。</p>
<h3 id="_33-lterator和listlterator有什么区别"> 33.lterator和Listlterator有什么区别?</h3>
<ul>
<li>Iterator可用来遍历Set和List集合，但是ListIterator只能用来遍历List。</li>
<li>Iterator对集合只能是前向遍历，ListIterator既可以前向也可以后向。</li>
<li>ListIterator实现了Iterator接口，并包含其他的功能，比如：增加元素，替换元素，获取前一个和后一个元素的索引，等等。</li>
</ul>
<h3 id="_34-怎么确保一个集合不能被修改"> 34.怎么确保一个集合不能被修改？</h3>
<p>可以使用 Collections. unmodifiableCollection(Collection c) 方法来创建一个只读集合，这样改变集合的任何操作都会抛出 Java. lang.</p>
<p>UnsupportedOperationException 异常。</p>
<p>示例代码如下：</p>
<div><pre><code><span>List</span><span><span>&lt;</span><span>String</span><span>></span></span> list <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
list<span>.</span> <span>add</span><span>(</span><span>"A"</span><span>)</span><span>;</span>
<span>Collection</span><span><span>&lt;</span><span>String</span><span>></span></span> unmlist <span>=</span> <span>Collections</span><span>.</span> <span>unmodifiableCollection</span><span>(</span>list<span>)</span><span>;</span>
unmlist<span>.</span> <span>add</span><span>(</span><span>"B"</span><span>)</span><span>;</span> <span>// 运行时此行报错</span>
<span>System</span><span>.</span> out<span>.</span> <span>println</span><span>(</span>list<span>.</span><span>size</span><span>(</span><span>)</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div>]]></content>
    <author>
      <name>南辞</name>
    </author>
    <contributor>
      <name>南辞</name>
    </contributor>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">模块03-Java多线程</title>
    <id>http://qiqi.dreamagain.top/interview/Java208/%E6%A8%A1%E5%9D%9703%E2%80%94%E5%A4%9A%E7%BA%BF%E7%A8%8B/</id>
    <link href="http://qiqi.dreamagain.top/interview/Java208/%E6%A8%A1%E5%9D%9703%E2%80%94%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<h2 id="问题"> 问题：</h2>
<p>35.并行和并发有什么区别?</p>
<p>36.线程和进程的区别?</p>
<p>37.守护线程是什么?</p>
<p>38.创建线程有哪几种方式?</p>
<p>39.说一下runnable和callable有什么区别?</p>
<p>40.线程有哪些状态?</p>
<p>41.sleep()和wait()有什么区别?</p>
<p>42.notify()和 notifyAll)有什么区别?</p>
<p>43.线程的run()和start()有什么区别?</p>
<p>44.创建线程池有哪几种方式?</p>
<p>45.线程池都有哪些状态?</p>
<p>46.线程池中 submit()和execute()方法有什么区别?</p>
<p>47.在java程序中怎么保证多线程的运行安全?</p>
<p>48.多线程锁的升级原理是什么?</p>
<p>49.什么是死锁?</p>
<p>50.怎么防止死锁?</p>
<p>51.ThreadLocal是什么?有哪些使用场景?</p>
<p>52.说一下synchronized底层实现原理?</p>
<p>53.synchronized和volatile 的区别是什么?</p>
<p>54.synchronized和Lock有什么区别?</p>
<p>55.synchronized和ReentrantLock区别是什么?</p>
<p>56.说一下atomic 的原理?</p>
<h3 id="答案"> 答案：</h3>
<h3 id="_35-并行和并发有什么区别"> 35.并行和并发有什么区别?</h3>
<ul>
<li>并行是指两个或者多个事件在同一时刻发生；而并发是指两个或多个事件在同一时间间隔发生。</li>
<li>并行是在不同实体上的多个事件，并发是在同一实体上的多个事件。</li>
<li>在一台处理器上“同时”处理多个任务；在多台处理器上同时处理多个任务。如hadoop分布式集群。</li>
</ul>
<p>所以并发编程的目标是充分的利用处理器的每一个核，以达到最高的处理性能。</p>
<h3 id="_36-线程和进程的区别"> 36.线程和进程的区别?</h3>
<p>简而言之，进程是程序运行和资源分配的基本单位，一个程序至少有一个进程，一个进程至少有一个线程。</p>
<p>进程在执行过程中拥有独立的内存单元，而多个线程共享内存资源，减少切换次数，从而效率更高。</p>
<p>线程是进程的一个实体，是cpu调度和分派的基本单位，是比程序更小的能独立运行的基本单位。</p>
<p>同一进程中的多个线程之间可以并发执行。</p>
<h3 id="_37-守护线程是什么"> 37.守护线程是什么?</h3>
<p>守护线程（即daemon thread），是个服务线程，准确地来说就是服务其他的线程。</p>
<h3 id="_38-创建线程有哪几种方式"> 38.创建线程有哪几种方式?</h3>
<p>①. 继承Thread类创建线程类</p>
<ul>
<li>定义Thread类的子类，并重写该类的run方法，该run方法的方法体就代表了线程要完成的任务。因此把run()方法称为执行体。</li>
<li>创建Thread子类的实例，即创建了线程对象。</li>
<li>调用线程对象的start()方法来启动该线程。</li>
</ul>
<p>②. 通过Runnable接口创建线程类</p>
<ul>
<li>定义runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体同样是该线程的线程执行体。</li>
<li>创建 Runnable实现类的实例，并依此实例作为Thread的target来创建Thread对象，该Thread对象才是真正的线程对象。</li>
<li>调用线程对象的start()方法来启动该线程。</li>
</ul>
<p>③. 通过Callable和Future创建线程</p>
<ul>
<li>创建Callable接口的实现类，并实现call()方法，该call()方法将作为线程执行体，并且有返回值。</li>
<li>创建Callable实现类的实例，使用FutureTask类来包装Callable对象，该FutureTask对象封装了该Callable对象的call()方法的返回值。</li>
<li>使用FutureTask对象作为Thread对象的target创建并启动新线程。</li>
<li>调用FutureTask对象的get()方法来获得子线程执行结束后的返回值。</li>
</ul>
<h3 id="_39-说一下runnable和callable有什么区别"> 39.说一下runnable和callable有什么区别?</h3>
<p>有点深的问题了，也看出一个Java程序员学习知识的广度。</p>
<ul>
<li>Runnable接口中的run()方法的返回值是void，它做的事情只是纯粹地去执行run()方法中的代码而已；</li>
<li>Callable接口中的call()方法是有返回值的，是一个泛型，和Future、FutureTask配合可以用来<strong>获取异步执行的结果</strong>。</li>
</ul>
<h3 id="_40-线程有哪些状态"> 40.线程有哪些状态?</h3>
<p>线程通常都有五种状态，创建、就绪、运行、阻塞和死亡。</p>
<ul>
<li>创建状态。在生成线程对象，并没有调用该对象的start方法，这是线程处于创建状态。</li>
<li>就绪状态。当调用了线程对象的start方法之后，该线程就进入了就绪状态，但是此时线程调度程序还没有把该线程设置为当前线程，此时处于就绪状态。在线程运行之后，从等待或者睡眠中回来之后，也会处于就绪状态。</li>
<li>运行状态。线程调度程序将处于就绪状态的线程设置为当前线程，此时线程就进入了运行状态，开始运行run函数当中的代码。</li>
<li>阻塞状态。线程正在运行的时候，被暂停，通常是为了等待某个时间的发生(比如说某项资源就绪)之后再继续运行。sleep,suspend，wait等方法都可以导致线程阻塞。</li>
<li>死亡状态。如果一个线程的run方法执行结束或者调用stop方法后，该线程就会死亡。对于已经死亡的线程，无法再使用start方法令其进入就绪</li>
</ul>
<h3 id="_41-sleep-和wait-有什么区别"> 41.sleep()和wait()有什么区别?</h3>
<ul>
<li>
<p>sleep()：方法是线程类（Thread）的静态方法，让调用线程进入睡眠状态，让出执行机会给其他线程，等到休眠时间结束后，线程进入就绪状态和其他线程一起竞争cpu的执行时间。</p>
</li>
<li>
<p>因为sleep() 是static静态的方法，他不能改变对象的机锁，当一个synchronized块中调用了sleep() 方法，线程虽然进入休眠，但是对象的机锁没有被释放，其他线程依然无法访问这个对象。</p>
</li>
<li>
<p>wait()：wait()是Object类的方法，当一个线程执行到wait方法时，它就进入到一个和该对象相关的等待池，同时释放对象的机锁，使得其他线程能够访问，可以通过notify，notifyAll方法来唤醒等待的线程</p>
</li>
</ul>
<h3 id="_42-notify-和-notifyall-有什么区别"> 42.notify()和 notifyAll)有什么区别?</h3>
<ul>
<li>如果线程调用了对象的 wait()方法，那么线程便会处于该对象的等待池中，等待池中的线程不会去竞争该对象的锁。</li>
<li>当有线程调用了对象的 notifyAll()方法（唤醒所有 wait 线程）或 notify()方法（只随机唤醒一个 wait 线程），被唤醒的的线程便会进入该对象的锁池中，锁池中的线程会去竞争该对象锁。也就是说，调用了notify后只要一个线程会由等待池进入锁池，而notifyAll会将该对象等待池内的所有线程移动到锁池中，等待锁竞争。</li>
<li>优先级高的线程竞争到对象锁的概率大，假若某线程没有竞争到该对象锁，它还会留在锁池中，唯有线程再次调用 wait()方法，它才会重新回到等待池中。而竞争到对象锁的线程则继续往下执行，直到执行完了 synchronized 代码块，它会释放掉该对象锁，这时锁池中的线程会继续竞争该对象锁。</li>
</ul>
<h3 id="_43-线程的run-和start-有什么区别"> 43.线程的run()和start()有什么区别?</h3>
<ul>
<li>
<p>每个线程都是通过某个特定Thread对象所对应的方法run()来完成其操作的，方法run()称为线程体。通过调用Thread类的start()方法来启动一个线程。</p>
</li>
<li>
<p>start()方法来启动一个线程，真正实现了多线程运行。这时无需等待run方法体代码执行完毕，可以直接继续执行下面的代码； 这时此线程是处于就绪状态， 并没有运行。 然后通过此Thread类调用方法run()来完成其运行状态， 这里方法run()称为线程体，它包含了要执行的这个线程的内容， run方法运行结束， 此线程终止。然后CPU再调度其它线程。</p>
</li>
<li>
<p>run()方法是在本线程里的，只是线程里的一个函数,而不是多线程的。 如果直接调用run(),其实就相当于是调用了一个普通函数而已，直接待用run()方法必须等待run()方法执行完毕才能执行下面的代码，所以执行路径还是只有一条，根本就没有线程的特征，所以在多线程执行时要使用start()方法而不是run()方法。</p>
</li>
</ul>
<h3 id="_44-创建线程池有哪几种方式"> 44.创建线程池有哪几种方式?</h3>
<p><strong>①. newFixedThreadPool(int nThreads)</strong></p>
<p>创建一个固定长度的线程池，每当提交一个任务就创建一个线程，直到达到线程池的最大数量，这时线程规模将不再变化，当线程发生未预期的错误而结束时，线程池会补充一个新的线程。</p>
<p><strong>②. newCachedThreadPool()</strong></p>
<p>创建一个可缓存的线程池，如果线程池的规模超过了处理需求，将自动回收空闲线程，而当需求增加时，则可以自动添加新线程，线程池的规模不存在任何限制。</p>
<p><strong>③. newSingleThreadExecutor()</strong></p>
<p>这是一个单线程的Executor，它创建单个工作线程来执行任务，如果这个线程异常结束，会创建一个新的来替代它；它的特点是能确保依照任务在队列中的顺序来串行执行。</p>
<p><strong>④. newScheduledThreadPool(int corePoolSize)</strong></p>
<p>创建了一个固定长度的线程池，而且以延迟或定时的方式来执行任务，类似于Timer。</p>
<h3 id="_45-线程池都有哪些状态"> 45.线程池都有哪些状态?</h3>
<p>线程池有5种状态：Running、ShutDown、Stop、Tidying、Terminated。</p>
<p>线程池各个状态切换框架图：</p>
<p><img src="./assets/java-01.png" alt=""></p>
<h3 id="_46-线程池中-submit-和execute-方法有什么区别"> 46.线程池中 submit()和execute()方法有什么区别?</h3>
<ul>
<li>接收的参数不一样</li>
<li>submit有返回值，而execute没有</li>
<li>submit方便Exception处理</li>
</ul>
<h3 id="_47-在java程序中怎么保证多线程的运行安全"> 47.在java程序中怎么保证多线程的运行安全?</h3>
<p>线程安全在三个方面体现：</p>
<ul>
<li>原子性：提供互斥访问，同一时刻只能有一个线程对数据进行操作，（atomic,synchronized）；</li>
<li>可见性：一个线程对主内存的修改可以及时地被其他线程看到，（synchronized,volatile）；</li>
<li>有序性：一个线程观察其他线程中的指令执行顺序，由于指令重排序，该观察结果一般杂乱无序，（happens-before原则）。</li>
</ul>
<h3 id="_48-多线程锁的升级原理是什么"> 48.多线程锁的升级原理是什么?</h3>
<p>在Java中，锁共有4种状态，级别从低到高依次为：无状态锁，偏向锁，轻量级锁和重量级锁状态，这几个状态会随着竞争情况逐渐升</p>
<p>级。锁可以升级但不能降级。</p>
<p>锁升级的图示过程：</p>
<p><img src="./assets/java-02.png" alt=""></p>
<h3 id="_49-什么是死锁"> 49.什么是死锁?</h3>
<p>死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无</p>
<p>法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。是操作系统层面的一个错误，是</p>
<p>进程死锁的简称，最早在 1965 年由 Dijkstra 在研究银行家算法时提出的，它是计算机操作系统乃至整个并发程序设计领域最难处理的</p>
<p>问题之一。</p>
<h3 id="_50-怎么防止死锁"> 50.怎么防止死锁?</h3>
<p>死锁的四个必要条件：</p>
<ul>
<li>**互斥条件：**进程对所分配到的资源不允许其他进程进行访问，若其他进程访问该资源，只能等待，直至占有该资源的进程使用完成后释放该资源</li>
<li>**请求和保持条件：**进程获得一定的资源之后，又对其他资源发出请求，但是该资源可能被其他进程占有，此事请求阻塞，但又对自己获得的资源保持不放</li>
<li>**不可剥夺条件：**是指进程已获得的资源，在未完成使用之前，不可被剥夺，只能在使用完后自己释放</li>
<li>**环路等待条件：**是指进程发生死锁后，若干进程之间形成一种头尾相接的循环等待资源关系</li>
</ul>
<p>这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之 一不满足，就不会发生死锁。</p>
<p>理解了死锁的原因，尤其是产生死锁的四个必要条件，就可以最大可能地避免、预防和 解除死锁。</p>
<p>所以，在系统设计、进程调度等方面注意如何不让这四个必要条件成立，如何确 定资源的合理分配算法，避免进程永久占据系统资源。</p>
<p>此外，也要防止进程在处于等待状态的情况下占用资源。因此，对资源的分配要给予合理的规划。</p>
<h3 id="_51-threadlocal是什么-有哪些使用场景"> 51.ThreadLocal是什么?有哪些使用场景?</h3>
<p>线程局部变量是局限于线程内部的变量，属于线程自身所有，不在多个线程间共享。Java提供ThreadLocal类来支持线程局部变量，是</p>
<p>一种实现线程安全的方式。但是在管理环境下（如 web 服务器）使用线程局部变量的时候要特别小心，在这种情况下，工作线程的生</p>
<p>命周期比任何应用变量的生命周期都要长。任何线程局部变量一旦在工作完成后没有释放，Java 应用就存在内存泄露的风险。</p>
<h3 id="_52-说一下synchronized底层实现原理"> 52.说一下synchronized底层实现原理?</h3>
<p>synchronized可以保证方法或者代码块在运行时，同一时刻只有一个方法可以进入到临界区，同时它还可以保证共享变量的内存可见性。</p>
<p>Java中每一个对象都可以作为锁，这是synchronized实现同步的基础：</p>
<ul>
<li>普通同步方法，锁是当前实例对象</li>
<li>静态同步方法，锁是当前类的class对象</li>
<li>同步方法块，锁是括号里面的对象</li>
</ul>
<h3 id="_53-synchronized和volatile-的区别是什么"> 53.synchronized和volatile 的区别是什么?</h3>
<ul>
<li>volatile本质是在告诉jvm当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取； synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。</li>
<li>volatile仅能使用在变量级别；synchronized则可以使用在变量、方法、和类级别的。</li>
<li>volatile仅能实现变量的修改可见性，不能保证原子性；而synchronized则可以保证变量的修改可见性和原子性。</li>
<li>volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞。</li>
<li>volatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化。</li>
</ul>
<h3 id="_54-synchronized和lock有什么区别"> 54.synchronized和Lock有什么区别?</h3>
<ul>
<li>首先synchronized是java内置关键字，在jvm层面，Lock是个java类；</li>
<li>synchronized无法判断是否获取锁的状态，Lock可以判断是否获取到锁；</li>
<li>synchronized会自动释放锁(a 线程执行完同步代码会释放锁 ；b 线程执行过程中发生异常会释放锁)，Lock需在finally中手工释放锁（unlock()方法释放锁），否则容易造成线程死锁；</li>
<li>用synchronized关键字的两个线程1和线程2，如果当前线程1获得锁，线程2线程等待。如果线程1阻塞，线程2则会一直等待下去，而Lock锁就不一定会等待下去，如果尝试获取不到锁，线程可以不用一直等待就结束了；</li>
<li>synchronized的锁可重入、不可中断、非公平，而Lock锁可重入、可判断、可公平（两者皆可）；</li>
<li>Lock锁适合大量同步的代码的同步问题，synchronized锁适合代码少量的同步问题。</li>
</ul>
<h3 id="_55-synchronized和reentrantlock区别是什么"> 55.synchronized和ReentrantLock区别是什么?</h3>
<p>synchronized是和if、else、for、while一样的关键字，ReentrantLock是类，这是二者的本质区别。既然ReentrantLock是类，那么它</p>
<p>就提供了比synchronized更多更灵活的特性，可以被继承、可以有方法、可以有各种各样的类变量，ReentrantLock比synchronized的</p>
<p>扩展性体现在几点上：</p>
<ul>
<li>ReentrantLock可以对获取锁的等待时间进行设置，这样就避免了死锁</li>
<li>ReentrantLock可以获取各种锁的信息</li>
<li>ReentrantLock可以灵活地实现多路通知</li>
</ul>
<p>另外，二者的锁机制其实也是不一样的:ReentrantLock底层调用的是Unsafe的park方法加锁，synchronized操作的应该是对象头中mark word。</p>
<h3 id="_56-说一下atomic-的原理"> 56.说一下atomic 的原理?</h3>
<p>Atomic包中的类基本的特性就是在多线程环境下，当有多个线程同时对单个（包括基本类型及引用类型）变量进行操作时，具有排他</p>
<p>性，即当多个线程同时对该变量的值进行更新时，仅有一个线程能成功，而未成功的线程可以像自旋锁一样，继续尝试，一直等到执行</p>
<p>成功。</p>
<p>Atomic系列的类中的核心方法都会调用unsafe类中的几个本地方法。我们需要先知道一个东西就是Unsafe类，全名为：</p>
<p>sun.misc.Unsafe，这个类包含了大量的对C代码的操作，包括很多直接内存分配以及原子操作的调用，而它之所以标记为非安全的，是</p>
<p>告诉你这个里面大量的方法调用都会存在安全隐患，需要小心使用，否则会导致严重的后果，例如在通过unsafe分配内存的时候，如果</p>
<p>自己指定某些区域可能会导致一些类似C++一样的指针越界到其他进程的问题。</p>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <contributor>
      <name>南辞</name>
    </contributor>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">模块04-Java反射</title>
    <id>http://qiqi.dreamagain.top/interview/Java208/%E6%A8%A1%E5%9D%9704%E2%80%94%E5%8F%8D%E5%B0%84/</id>
    <link href="http://qiqi.dreamagain.top/interview/Java208/%E6%A8%A1%E5%9D%9704%E2%80%94%E5%8F%8D%E5%B0%84/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<h2 id="问题"> 问题：</h2>
<p>57.什么是反射?</p>
<p>58.什么是java序列化?什么情况下需要序列化?</p>
<p>59.动态代理是什么?有哪些应用?</p>
<p>60.怎么实现动态代理?</p>
<h2 id="答案"> 答案：</h2>
<h3 id="_57-什么是反射"> 57.什么是反射?</h3>
<p>反射主要是指程序可以访问、检测和修改它本身状态或行为的一种能力</p>
<p><strong>Java反射：</strong></p>
<p>在Java运行时环境中，对于任意一个类，能否知道这个类有哪些属性和方法？对于任意一个对象，能否调用它的任意一个方法</p>
<p>Java反射机制主要提供了以下功能：</p>
<ul>
<li>在运行时判断任意一个对象所属的类。</li>
<li>在运行时构造任意一个类的对象。</li>
<li>在运行时判断任意一个类所具有的成员变量和方法。</li>
<li>在运行时调用任意一个对象的方法。</li>
</ul>
<h3 id="_58-什么是java序列化-什么情况下需要序列化"> 58.什么是java序列化?什么情况下需要序列化?</h3>
<p>简单说就是为了保存在内存中的各种对象的状态（也就是实例变量，不是方法），并且可以把保存的对象状态再读出来。虽然你可以用</p>
<p>你自己的各种各样的方法来保存object states，但是Java给你提供一种应该比你自己好的保存对象状态的机制，那就是序列化。</p>
<p><strong>什么情况下需要序列化：</strong></p>
<ol>
<li>当你想把的内存中的对象状态保存到一个文件中或者数据库中时候；</li>
<li>当你想用<strong>套接字</strong>在网络上传送对象的时候；</li>
<li>当你想通过<strong>RMI</strong>传输对象的时候；</li>
</ol>
<h3 id="_59-动态代理是什么-有哪些应用"> 59.动态代理是什么?有哪些应用?</h3>
<p>动态代理：</p>
<p>当想要给实现了某个接口的类中的方法，加一些额外的处理。比如说加日志，加事务等。可以给这个类创建一个代理，故名思议就是创建一个新的类，这个类不仅包含原来类方法的功能，而且还在原来的基础上添加了额外处理的新类。这个代理类并不是定义好的，是动态生成的。具有解耦意义，灵活，扩展性强。</p>
<p>动态代理的应用：</p>
<ul>
<li>Spring的AOP</li>
<li>加事务</li>
<li>加权限</li>
<li>加日志</li>
</ul>
<h3 id="_60-怎么实现动态代理"> 60.怎么实现动态代理?</h3>
<ul>
<li>
<p>首先必须定义一个接口，还要有一个InvocationHandler(将实现接口的类的对象传递给它)处理类。</p>
</li>
<li>
<p>再有一个工具类Proxy(习惯性将其称为代理类，因为调用他的newInstance()可以产生代理对象,其实他只是一个产生代理对象的工具类）。</p>
</li>
<li>
<p>利用到InvocationHandler，拼接代理类源码，将其编译生成代理类的二进制码，利用加载器加载，并将其实例化产生代理对象，最后返回。</p>
</li>
</ul>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <contributor>
      <name>南辞</name>
    </contributor>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">模块05-Java对象拷贝</title>
    <id>http://qiqi.dreamagain.top/interview/Java208/%E6%A8%A1%E5%9D%9705%E2%80%94%E5%AF%B9%E8%B1%A1%E6%8B%B7%E8%B4%9D/</id>
    <link href="http://qiqi.dreamagain.top/interview/Java208/%E6%A8%A1%E5%9D%9705%E2%80%94%E5%AF%B9%E8%B1%A1%E6%8B%B7%E8%B4%9D/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<h2 id="问题"> 问题：</h2>
<p>61.为什么要使用克隆?</p>
<p>62.如何实现对象克隆?</p>
<p>63.深拷贝和浅拷贝区别是什么?</p>
<h2 id="答案"> 答案：</h2>
<h3 id="_61-为什么要使用克隆"> 61.为什么要使用克隆?</h3>
<p>想对一个对象进行处理，又想保留原有的数据进行接下来的操作，就需要克隆了，Java语言中克隆针对的是类的实例。</p>
<h3 id="_62-如何实现对象克隆"> 62.如何实现对象克隆?</h3>
<p>有两种方式：</p>
<p>1). 实现Cloneable接口并重写Object类中的clone()方法；</p>
<p>2). 实现Serializable接口，通过对象的序列化和反序列化实现克隆，可以实现真正的深度克隆，代码如下：</p>
<div><pre><code>
<span>import</span> <span>java<span>.</span>io<span>.</span></span><span>ByteArrayInputStream</span><span>;</span>
<span>import</span> <span>java<span>.</span>io<span>.</span></span><span>ByteArrayOutputStream</span><span>;</span>
<span>import</span> <span>java<span>.</span>io<span>.</span></span><span>ObjectInputStream</span><span>;</span>
<span>import</span> <span>java<span>.</span>io<span>.</span></span><span>ObjectOutputStream</span><span>;</span>
<span>import</span> <span>java<span>.</span>io<span>.</span></span><span>Serializable</span><span>;</span>

<span>public</span> <span>class</span> <span>MyUtil</span> <span>{</span>

    <span>private</span> <span>MyUtil</span><span>(</span><span>)</span> <span>{</span>
        <span>throw</span> <span>new</span> <span>AssertionError</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>

    <span>@SuppressWarnings</span><span>(</span><span>"unchecked"</span><span>)</span>
    <span>public</span> <span>static</span> <span><span>&lt;</span><span>T</span> <span>extends</span> <span>Serializable</span><span>></span></span> <span>T</span> <span>clone</span><span>(</span><span>T</span> obj<span>)</span> 
                                  <span>throws</span> <span>Exception</span> <span>{</span>
        <span>ByteArrayOutputStream</span> bout <span>=</span> <span>new</span> <span>ByteArrayOutputStream</span><span>(</span><span>)</span><span>;</span>
        <span>ObjectOutputStream</span> oos <span>=</span> <span>new</span> <span>ObjectOutputStream</span><span>(</span>bout<span>)</span><span>;</span>
        oos<span>.</span><span>writeObject</span><span>(</span>obj<span>)</span><span>;</span>

        <span>ByteArrayInputStream</span> bin <span>=</span> 
                    <span>new</span> <span>ByteArrayInputStream</span><span>(</span>bout<span>.</span><span>toByteArray</span><span>(</span><span>)</span><span>)</span><span>;</span>
        <span>ObjectInputStream</span> ois <span>=</span> <span>new</span> <span>ObjectInputStream</span><span>(</span>bin<span>)</span><span>;</span>
        <span>return</span> <span>(</span><span>T</span><span>)</span> ois<span>.</span><span>readObject</span><span>(</span><span>)</span><span>;</span>

        <span>// 说明：调用ByteArrayInputStream</span>
        <span>//或ByteArrayOutputStream对象的close方法没有任何意义</span>
        <span>// 这两个基于内存的流只要垃圾回收器清理对象就能够释放资源，</span>
        <span>//这一点不同于对外部资源（如文件流）的释放</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br></div></div><p>下面是测试代码：</p>
<div><pre><code>
<span>import</span> <span>java<span>.</span>io<span>.</span></span><span>Serializable</span><span>;</span>

<span>/**
 * 人类
 * @author nnngu
 *
 */</span>
<span>class</span> <span>Person</span> <span>implements</span> <span>Serializable</span> <span>{</span>
    <span>private</span> <span>static</span> <span>final</span> <span>long</span> serialVersionUID 
                              <span>=</span> <span>-</span><span>9102017020286042305L</span><span>;</span>

    <span>private</span> <span>String</span> name<span>;</span>    <span>// 姓名</span>
    <span>private</span> <span>int</span> age<span>;</span>        <span>// 年龄</span>
    <span>private</span> <span>Car</span> car<span>;</span>        <span>// 座驾</span>

    <span>public</span> <span>Person</span><span>(</span><span>String</span> name<span>,</span> <span>int</span> age<span>,</span> <span>Car</span> car<span>)</span> <span>{</span>
        <span>this</span><span>.</span>name <span>=</span> name<span>;</span>
        <span>this</span><span>.</span>age <span>=</span> age<span>;</span>
        <span>this</span><span>.</span>car <span>=</span> car<span>;</span>
    <span>}</span>

    <span>public</span> <span>String</span> <span>getName</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> name<span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>setName</span><span>(</span><span>String</span> name<span>)</span> <span>{</span>
        <span>this</span><span>.</span>name <span>=</span> name<span>;</span>
    <span>}</span>

    <span>public</span> <span>int</span> <span>getAge</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> age<span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>setAge</span><span>(</span><span>int</span> age<span>)</span> <span>{</span>
        <span>this</span><span>.</span>age <span>=</span> age<span>;</span>
    <span>}</span>

    <span>public</span> <span>Car</span> <span>getCar</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> car<span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>setCar</span><span>(</span><span>Car</span> car<span>)</span> <span>{</span>
        <span>this</span><span>.</span>car <span>=</span> car<span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>String</span> <span>toString</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> <span>"Person [name="</span> <span>+</span> name <span>+</span> "<span>,</span>
                       age<span>=</span><span>" + age + "</span><span>,</span> car<span>=</span><span>" + car + "</span><span>]</span>"<span>;</span>
    <span>}</span>

<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br></div></div><div><pre><code>
<span>/**
 * 小汽车类
 * @author nnngu
 *
 */</span>
<span>class</span> <span>Car</span> <span>implements</span> <span>Serializable</span> <span>{</span>
    <span>private</span> <span>static</span> <span>final</span> <span>long</span> serialVersionUID 
                                <span>=</span> <span>-</span><span>5713945027627603702L</span><span>;</span>

    <span>private</span> <span>String</span> brand<span>;</span>       <span>// 品牌</span>
    <span>private</span> <span>int</span> maxSpeed<span>;</span>       <span>// 最高时速</span>

    <span>public</span> <span>Car</span><span>(</span><span>String</span> brand<span>,</span> <span>int</span> maxSpeed<span>)</span> <span>{</span>
        <span>this</span><span>.</span>brand <span>=</span> brand<span>;</span>
        <span>this</span><span>.</span>maxSpeed <span>=</span> maxSpeed<span>;</span>
    <span>}</span>

    <span>public</span> <span>String</span> <span>getBrand</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> brand<span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>setBrand</span><span>(</span><span>String</span> brand<span>)</span> <span>{</span>
        <span>this</span><span>.</span>brand <span>=</span> brand<span>;</span>
    <span>}</span>

    <span>public</span> <span>int</span> <span>getMaxSpeed</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> maxSpeed<span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>setMaxSpeed</span><span>(</span><span>int</span> maxSpeed<span>)</span> <span>{</span>
        <span>this</span><span>.</span>maxSpeed <span>=</span> maxSpeed<span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>String</span> <span>toString</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> <span>"Car [brand="</span> <span>+</span> brand <span>+</span> "<span>,</span> 
                      maxSpeed<span>=</span><span>" + maxSpeed + "</span><span>]</span>"<span>;</span>
    <span>}</span>

<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br></div></div><div><pre><code>
<span>class</span> <span>CloneTest</span> <span>{</span>

    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>try</span> <span>{</span>
            <span>Person</span> p1 <span>=</span> <span>new</span> <span>Person</span><span>(</span><span>"郭靖"</span><span>,</span> <span>33</span><span>,</span> 
                              <span>new</span> <span>Car</span><span>(</span><span>"Benz"</span><span>,</span> <span>300</span><span>)</span><span>)</span><span>;</span>
            <span>Person</span> p2 <span>=</span> <span>MyUtil</span><span>.</span><span>clone</span><span>(</span>p1<span>)</span><span>;</span>   <span>// 深度克隆</span>
            p2<span>.</span><span>getCar</span><span>(</span><span>)</span><span>.</span><span>setBrand</span><span>(</span><span>"BYD"</span><span>)</span><span>;</span>
            <span>// 修改克隆的Person对象p2关联的汽车对象的品牌属性</span>
            <span>// 原来的Person对象p1关联的汽车不会受到任何影响</span>
            <span>// 因为在克隆Person对象时其关联的汽车对象也被克隆了</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>p1<span>)</span><span>;</span>
        <span>}</span> <span>catch</span> <span>(</span><span>Exception</span> e<span>)</span> <span>{</span>
            e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><p>注意：基于序列化和反序列化实现的克隆不仅仅是深度克隆，更重要的是通过泛型限定，可以检查出要克隆的对象是否支持序列化，这</p>
<p>项检查是编译器完成的，不是在运行时抛出异常，这种是方案明显优于使用Object类的clone方法克隆对象。让问题在编译的时候暴露</p>
<p>出来总是好过把问题留到运行时。</p>
<h3 id="_63-深拷贝和浅拷贝区别是什么"> 63.深拷贝和浅拷贝区别是什么?</h3>
<ul>
<li>浅拷贝只是复制了对象的引用地址，两个对象指向同一个内存地址，所以修改其中任意的值，另一个值都会随之变化，这就是浅拷贝（例：assign()）</li>
<li>深拷贝是将对象及值复制过来，两个对象修改其中任意的值另一个值不会改变，这就是深拷贝（例：JSON.parse()和JSON.stringify()，但是此方法无法复制函数类型）</li>
</ul>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <contributor>
      <name>南辞</name>
    </contributor>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">模块06—Java Web</title>
    <id>http://qiqi.dreamagain.top/interview/Java208/%E6%A8%A1%E5%9D%9706%E2%80%94Java%20Web/</id>
    <link href="http://qiqi.dreamagain.top/interview/Java208/%E6%A8%A1%E5%9D%9706%E2%80%94Java%20Web/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<h2 id="问题"> 问题：</h2>
<p>64.jsp和servlet有什么区别?</p>
<p>65.jsp有哪些内置对象?作用分别是什么?</p>
<p>66.说一下jsp的4种作用域?</p>
<p>67.session和cookie有什么区别?</p>
<p>68.说一下 session的工作原理?</p>
<p>69.如果客户端禁止 cookie 能实现session 还能用吗?</p>
<p>70.spring mvc和struts 的区别是什么?</p>
<p>71.如何避免 sql注入?</p>
<p>72.什么是XSS攻击,如何避免?</p>
<p>73.什么是CSRF攻击，如何避免?</p>
<h2 id="答案"> 答案：</h2>
<h3 id="_64-jsp和servlet有什么区别"> 64.jsp和servlet有什么区别?</h3>
<ol>
<li>jsp经编译后就变成了Servlet.（JSP的本质就是Servlet，JVM只能识别java的类，不能识别JSP的代码，Web容器将JSP的代码编译成JVM能够识别的java类）</li>
<li>jsp更擅长表现于页面显示，servlet更擅长于逻辑控制。</li>
<li>Servlet中没有内置对象，Jsp中的内置对象都是必须通过HttpServletRequest对象，HttpServletResponse对象以及HttpServlet对象得到。</li>
<li>Jsp是Servlet的一种简化，使用Jsp只需要完成程序员需要输出到客户端的内容，Jsp中的Java脚本如何镶嵌到一个类中，由Jsp容器完成。而Servlet则是个完整的Java类，这个类的Service方法用于生成对客户端的响应。</li>
</ol>
<h3 id="_65-jsp有哪些内置对象-作用分别是什么"> 65.jsp有哪些内置对象?作用分别是什么?</h3>
<p>JSP有9个内置对象：</p>
<ul>
<li>request：封装客户端的请求，其中包含来自GET或POST请求的参数；</li>
<li>response：封装服务器对客户端的响应；</li>
<li>pageContext：通过该对象可以获取其他对象；</li>
<li>session：封装用户会话的对象；</li>
<li>application：封装服务器运行环境的对象；</li>
<li>out：输出服务器响应的输出流对象；</li>
<li>config：Web应用的配置对象；</li>
<li>page：JSP页面本身（相当于Java程序中的this）；</li>
<li>exception：封装页面抛出异常的对象。</li>
</ul>
<h3 id="_66-说一下jsp的4种作用域"> 66.说一下jsp的4种作用域?</h3>
<p>JSP中的四种作用域包括page、request、session和application，具体来说：</p>
<ul>
<li><strong>page</strong>代表与一个页面相关的对象和属性。</li>
<li><strong>request</strong>代表与Web客户机发出的一个请求相关的对象和属性。一个请求可能跨越多个页面，涉及多个Web组件；需要在页面显示的临时数据可以置于此作用域。</li>
<li><strong>session</strong>代表与某个用户与服务器建立的一次会话相关的对象和属性。跟某个用户相关的数据应该放在用户自己的session中。</li>
<li><strong>application</strong>代表与整个Web应用程序相关的对象和属性，它实质上是跨越整个Web应用程序，包括多个页面、请求和会话的一个全局作用域。</li>
</ul>
<h3 id="_67-session和cookie有什么区别"> 67.session和cookie有什么区别?</h3>
<ul>
<li>
<p>由于HTTP协议是无状态的协议，所以服务端需要记录用户的状态时，就需要用某种机制来识具体的用户，这个机制就是Session.典型的场景比如购物车，当你点击下单按钮时，由于HTTP协议无状态，所以并不知道是哪个用户操作的，所以服务端要为特定的用户创建了特定的Session，用于标识这个用户，并且跟踪用户，这样才知道购物车里面有几本书。这个Session是保存在服务端的，有一个唯一标识。在服务端保存Session的方法很多，内存、数据库、文件都有。集群的时候也要考虑Session的转移，在大型的网站，一般会有专门的Session服务器集群，用来保存用户会话，这个时候 Session 信息都是放在内存的，使用一些缓存服务比如Memcached之类的来放 Session。</p>
</li>
<li>
<p>思考一下服务端如何识别特定的客户？这个时候Cookie就登场了。每次HTTP请求的时候，客户端都会发送相应的Cookie信息到服务端。实际上大多数的应用都是用 Cookie 来实现Session跟踪的，第一次创建Session的时候，服务端会在HTTP协议中告诉客户端，需要在 Cookie 里面记录一个Session ID，以后每次请求把这个会话ID发送到服务器，我就知道你是谁了。有人问，如果客户端的浏览器禁用了 Cookie 怎么办？一般这种情况下，会使用一种叫做<strong>URL重写</strong>的技术来进行会话跟踪，即每次HTTP交互，URL后面都会被附加上一个诸如 <strong>sid=xxxxx 这样的参数</strong>，服务端据此来识别用户。</p>
</li>
<li>
<p>Cookie其实还可以用在一些方便用户的场景下，设想你某次登陆过一个网站，下次登录的时候不想再次输入账号了，怎么办？这个信息可以写到Cookie里面，访问网站的时候，网站页面的脚本可以读取这个信息，就自动帮你把用户名给填了，能够方便一下用户。这也是Cookie名称的由来，给用户的一点甜头。所以，总结一下：Session是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中；Cookie是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现Session的一种方式。</p>
</li>
</ul>
<h3 id="_68-说一下-session的工作原理"> 68.说一下 session的工作原理?</h3>
<p>其实session是一个存在服务器上的类似于一个散列表格的文件。里面存有我们需要的信息，在我们需要用的时候可以从里面取出来。</p>
<p>类似于一个大号的map吧，里面的键存储的是用户的sessionid，用户向服务器发送请求的时候会带上这个sessionid。这时就可以从中</p>
<p>取出对应的值了。</p>
<h3 id="_69-如果客户端禁止-cookie-能实现session-还能用吗"> 69.如果客户端禁止 cookie 能实现session 还能用吗?</h3>
<p>Cookie与 Session，一般认为是两个独立的东西，Session采用的是在服务器端保持状态的方案，而Cookie采用的是在客户端保持状态</p>
<p>的方案。但为什么禁用Cookie就不能得到Session呢？因为Session是用Session ID来确定当前对话所对应的服务器Session，而Session</p>
<p>ID是通过Cookie来传递的，禁用Cookie相当于失去了Session ID，也就得不到Session了。</p>
<p>假定用户关闭Cookie的情况下使用Session，其实现途径有以下几种：</p>
<ol>
<li>设置php.ini配置文件中的“session.use_trans_sid = 1”，或者编译时打开“--enable-trans-sid”选项，让PHP自动跨页传递Session ID。</li>
<li>手动通过URL传值、隐藏表单传递Session ID。</li>
<li>用文件、数据库等形式保存Session ID，在跨页过程中手动调用。</li>
</ol>
<h3 id="_70-springmvc和struts-的区别是什么"> 70.SpringMVC和struts 的区别是什么?</h3>
<ul>
<li><strong>拦截机制的不同</strong></li>
</ul>
<p>Struts2是类级别的拦截，每次请求就会创建一个Action，和Spring整合时Struts2的ActionBean注入作用域是原型模式prototype，然后通过setter，getter把request数据注入到属性。Struts2中，一个Action对应一个request，response上下文，在接收参数时，可以通过属性接收，这说明属性参数是让多个方法共享的。Struts2中Action的一个方法可以对应一个url，而其类属性却被所有方法共享，这也就无法用注解或其他方式标识其所属方法了，只能设计为多例。</p>
<p>SpringMVC是方法级别的拦截，一个方法对应一个Request上下文，所以方法直接基本上是独立的，独享request，response数据。而每个方法同时又和一个url对应，参数的传递是直接注入到方法中的，是方法所独有的。处理结果通过ModeMap返回给框架。在Spring整合时，SpringMVC的Controller Bean默认单例模式Singleton，所以默认对所有的请求，只会创建一个Controller，又因为没有共享的属性，所以是线程安全的，如果要改变默认的作用域，需要添加@Scope注解修改。</p>
<p>Struts2有自己的拦截Interceptor机制，SpringMVC这是用的是独立的AOP方式，这样导致Struts2的配置文件量还是比SpringMVC大。</p>
<ul>
<li><strong>底层框架的不同</strong></li>
</ul>
<p>Struts2采用Filter（StrutsPrepareAndExecuteFilter）实现，SpringMVC（DispatcherServlet）则采用Servlet实现。Filter在容器启动之后即初始化；服务停止以后销毁，晚于Servlet。Servlet在是在调用时初始化，先于Filter调用，服务停止后销毁。</p>
<ul>
<li>
<h3 id="性能方面"> <strong>性能方面</strong></h3>
</li>
</ul>
<p>Struts2是类级别的拦截，每次请求对应实例一个新的Action，需要加载所有的属性值注入，SpringMVC实现了零配置，由于SpringMVC基于方法的拦截，有加载一次单例模式bean注入。所以，SpringMVC开发效率和性能高于Struts2。</p>
<ul>
<li>
<h3 id="配置方面"> <strong>配置方面</strong></h3>
</li>
</ul>
<p>Spring MVC和Spring是无缝的。从这个项目的管理和安全上也比Struts2高。</p>
<h3 id="_71-如何避免-sql注入"> 71.如何避免 sql注入?</h3>
<ol>
<li>PreparedStatement（简单又有效的方法）</li>
<li>使用正则表达式过滤传入的参数</li>
<li>字符串过滤</li>
<li>JSP中调用该函数检查是否包函非法字符</li>
<li>JSP页面判断代码</li>
</ol>
<h3 id="_72-什么是xss攻击-如何避免"> 72.什么是XSS攻击,如何避免?</h3>
<p>XSS攻击又称CSS,全称Cross Site Script （跨站脚本攻击），其原理是攻击者向有XSS漏洞的网站中输入恶意的 HTML 代码，当用户浏览</p>
<p>该网站时，这段 HTML 代码会自动执行，从而达到攻击的目的。XSS 攻击类似于 SQL 注入攻击，SQL注入攻击中以SQL语句作为用户输</p>
<p>入，从而达到查询/修改/删除数据的目的，而在xss攻击中，通过插入恶意脚本，实现对用户游览器的控制，获取用户的一些信息。 XSS</p>
<p>是 Web 程序中常见的漏洞，XSS 属于被动式且用于客户端的攻击方式。</p>
<p>XSS防范的总体思路是：<strong>对输入(和URL参数)进行过滤，对输出进行编码</strong>。</p>
<h3 id="_73-什么是csrf攻击-如何避免"> 73.什么是CSRF攻击，如何避免?</h3>
<p>CSRF（Cross-site request forgery）也被称为 one-click attack或者 session riding，中文全称是叫<strong>跨站请求伪造</strong>。一般来说，攻击者通过伪造用户的浏览器的请求，向访问一个用户自己曾经认证访问过的网站发送出去，使目标网站接收并误以为是用户的真实操作而去执行命令。常用于盗取账号、转账、发送虚假消息等。攻击者利用网站对请求的验证漏洞而实现这样的攻击行为，网站能够确认请求来源于用户的浏览器，却不能验证请求是否源于用户的真实意愿下的操作行为。</p>
<p><strong>如何避免：</strong></p>
<ol>
<li>
<p>验证 HTTP Referer 字段</p>
<p>HTTP头中的Referer字段记录了该 HTTP 请求的来源地址。在通常情况下，访问一个安全受限页面的请求来自于同一个网站，而如果黑客要对其实施 CSRF攻击，他一般只能在他自己的网站构造请求。因此，可以通过验证Referer值来防御CSRF 攻击。</p>
</li>
<li>
<p>使用验证码</p>
<p>关键操作页面加上验证码，后台收到请求后通过判断验证码可以防御CSRF。但这种方法对用户不太友好。</p>
</li>
<li>
<p>在请求地址中添加token并验证</p>
<p>CSRF 攻击之所以能够成功，是因为黑客可以完全<strong>伪造用户的请求</strong>，该请求中所有的用户验证信息都是存在于cookie中，因此黑客可以在不知道这些验证信息的情况下直接利用用户自己的cookie 来通过安全验证。要抵御 CSRF，关键在于在请求中放入黑客所不能伪造的信息，并且该信息不存在于 cookie 之中。</p>
<p>可以在 HTTP 请求<strong>中以参数的形式加入一个随机产生的 token</strong>，并在服务器端建立一个拦截器来验证这个 token，如果请求中没有token或者 token 内容不正确，则认为可能是 CSRF 攻击而拒绝该请求。这种方法要比检查 Referer 要安全一些，token 可以在用户登陆后产生并放于session之中，然后在每次请求时把token 从 session 中拿出，与请求中的 token 进行比对，但这种方法的难点在于如何把 token 以参数的形式加入请求。
对于 GET 请求，token 将附在请求地址之后，这样 URL 就变成 http://url?csrftoken=tokenvalue。
而对于 POST 请求来说，要在 form 的最后加上 <input type="hidden" name="csrftoken" value="tokenvalue"/>，这样就把token以参数的形式加入请求了。</p>
</li>
<li>
<p>在HTTP 头中自定义属性并验证</p>
<p>这种方法也是使用 token 并进行验证，和上一种方法不同的是，这里并不是把 token 以参数的形式置于 HTTP 请求之中，而是把它放到 HTTP 头中自定义的属性里。</p>
<p>通过 XMLHttpRequest 这个类，可以一次性给所有该类请求加上 csrftoken 这个 HTTP 头属性，并把 token 值放入其中。这样解决了上种方法在请求中加入 token 的不便，同时，通过 XMLHttpRequest 请求的地址不会被记录到浏览器的地址栏，也不用担心 token 会透过 Referer 泄露到其他网站中去。</p>
</li>
</ol>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <contributor>
      <name>南辞</name>
    </contributor>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">模块07—Java异常</title>
    <id>http://qiqi.dreamagain.top/interview/Java208/%E6%A8%A1%E5%9D%9707%E2%80%94%E5%BC%82%E5%B8%B8/</id>
    <link href="http://qiqi.dreamagain.top/interview/Java208/%E6%A8%A1%E5%9D%9707%E2%80%94%E5%BC%82%E5%B8%B8/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<h2 id="问题"> 问题：</h2>
<p>74.throw和throws 的区别?</p>
<p>75.final、finally、finalize有什么区别?</p>
<p>76.try-catch-finally 中哪个部分可以省略?</p>
<p>77.try-catch-finally中，如果catch 中 return 了, finally还会执行吗?</p>
<p>78.常见的异常类有哪些?</p>
<h2 id="答案"> 答案:</h2>
<h3 id="_74-throw和throws-的区别"> 74.throw和throws 的区别?</h3>
<p>throws是用来声明一个方法可能抛出的所有异常信息，throws是将异常声明但是不处理，而是将异常往上传，谁调用我就交给谁处</p>
<p>理。而throw则是指抛出的一个具体的异常类型。</p>
<h3 id="_75-final、finally、finalize有什么区别"> 75.final、finally、finalize有什么区别?</h3>
<ul>
<li>final可以修饰类、变量、方法，修饰类表示该类不能被继承、修饰方法表示该方法不能被重写、修饰变量表示该变量是一个常量不能被重新赋值。</li>
<li>finally一般作用在try-catch代码块中，在处理异常的时候，通常我们将一定要执行的代码方法finally代码块中，表示不管是否出现异常，该代码块都会执行，一般用来存放一些关闭资源的代码。</li>
<li>finalize是一个方法，属于Object类的一个方法，而Object类是所有类的父类，该方法一般由垃圾回收器来调用，当我们调用System的gc()方法的时候，由垃圾回收器调用finalize(),回收垃圾。</li>
</ul>
<h3 id="_76-try-catch-finally-中哪个部分可以省略"> 76.try-catch-finally 中哪个部分可以省略?</h3>
<p>catch 可以省略</p>
<p><strong>原因：</strong></p>
<p>更为严格的说法其实是：try只适合处理运行时异常，try+catch适合处理运行时异常+普通异常。也就是说，如果你只用try去处理普通异常却不加以catch处理，编译是通不过的，因为编译器硬性规定，普通异常如果选择捕获，则必须用catch显示声明以便进一步处理。而运行时异常在编译时没有如此规定，所以catch可以省略，你加上catch编译器也觉得无可厚非。</p>
<p>理论上，编译器看任何代码都不顺眼，都觉得可能有潜在的问题，所以你即使对所有代码加上try，代码在运行期时也只不过是在正常运行的基础上加一层皮。但是你一旦对一段代码加上try，就等于显示地承诺编译器，对这段代码可能抛出的异常进行捕获而非向上抛出处理。如果是普通异常，编译器要求必须用catch捕获以便进一步处理；如果运行时异常，捕获然后丢弃并且+finally扫尾处理，或者加上catch捕获以便进一步处理。</p>
<p>至于加上finally，则是在不管有没捕获异常，都要进行的“扫尾”处理。</p>
<h3 id="_77-try-catch-finally中-如果catch-中-return-了-finally还会执行吗"> 77.try-catch-finally中，如果catch 中 return 了, finally还会执行吗?</h3>
<p>会执行，在 return 前执行。</p>
<div><pre><code><span>/*
 * java面试题--如果catch里面有return语句，finally里面的代码还会执行吗？
 */</span>
<span>public</span> <span>class</span> <span>FinallyDemo2</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>getInt</span><span>(</span><span>)</span><span>)</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>static</span> <span>int</span> <span>getInt</span><span>(</span><span>)</span> <span>{</span>
        <span>int</span> a <span>=</span> <span>10</span><span>;</span>
        <span>try</span> <span>{</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>a <span>/</span> <span>0</span><span>)</span><span>;</span>
            a <span>=</span> <span>20</span><span>;</span>
        <span>}</span> <span>catch</span> <span>(</span><span>ArithmeticException</span> e<span>)</span> <span>{</span>
            a <span>=</span> <span>30</span><span>;</span>
            <span>return</span> a<span>;</span>
            <span>/*
             * return a 在程序执行到这一步的时候，这里不是return a 而是 return 30；这个返回路径就形成了
             * 但是呢，它发现后面还有finally，所以继续执行finally的内容，a=40
             * 再次回到以前的路径,继续走return 30，形成返回路径之后，这里的a就不是a变量了，而是常量30
             */</span>
        <span>}</span> <span>finally</span> <span>{</span>
            a <span>=</span> <span>40</span><span>;</span>
        <span>}</span>

<span>//      return a;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br></div></div><p>执行结果：30</p>
<p><strong>代码示例2：</strong></p>
<div><pre><code>
<span>package</span> <span>com<span>.</span>java_02</span><span>;</span>

<span>/*
 * java面试题--如果catch里面有return语句，finally里面的代码还会执行吗？
 */</span>
<span>public</span> <span>class</span> <span>FinallyDemo2</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>getInt</span><span>(</span><span>)</span><span>)</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>static</span> <span>int</span> <span>getInt</span><span>(</span><span>)</span> <span>{</span>
        <span>int</span> a <span>=</span> <span>10</span><span>;</span>
        <span>try</span> <span>{</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>a <span>/</span> <span>0</span><span>)</span><span>;</span>
            a <span>=</span> <span>20</span><span>;</span>
        <span>}</span> <span>catch</span> <span>(</span><span>ArithmeticException</span> e<span>)</span> <span>{</span>
            a <span>=</span> <span>30</span><span>;</span>
            <span>return</span> a<span>;</span>
            <span>/*
             * return a 在程序执行到这一步的时候，这里不是return a 而是 return 30；这个返回路径就形成了
             * 但是呢，它发现后面还有finally，所以继续执行finally的内容，a=40
             * 再次回到以前的路径,继续走return 30，形成返回路径之后，这里的a就不是a变量了，而是常量30
             */</span>
        <span>}</span> <span>finally</span> <span>{</span>
            a <span>=</span> <span>40</span><span>;</span>
            <span>return</span> a<span>;</span> <span>//如果这样，就又重新形成了一条返回路径，由于只能通过1个return返回，所以这里直接返回40</span>
        <span>}</span>

<span>//      return a;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br></div></div><p>执行结果：40</p>
<h3 id="_78-常见的异常类有哪些"> 78.常见的异常类有哪些?</h3>
<ul>
<li>NullPointerException：当应用程序试图访问空对象时，则抛出该异常。</li>
<li>SQLException：提供关于数据库访问错误或其他错误信息的异常。</li>
<li>IndexOutOfBoundsException：指示某排序索引（例如对数组、字符串或向量的排序）超出范围时抛出。</li>
<li>NumberFormatException：当应用程序试图将字符串转换成一种数值类型，但该字符串不能转换为适当格式时，抛出该异常。</li>
<li>FileNotFoundException：当试图打开指定路径名表示的文件失败时，抛出此异常。</li>
<li>IOException：当发生某种I/O异常时，抛出此异常。此类是失败或中断的I/O操作生成的异常的通用类。</li>
<li>ClassCastException：当试图将对象强制转换为不是实例的子类时，抛出该异常。</li>
<li>ArrayStoreException：试图将错误类型的对象存储到一个对象数组时抛出的异常。</li>
<li>IllegalArgumentException：抛出的异常表明向方法传递了一个不合法或不正确的参数。</li>
<li>ArithmeticException：当出现异常的运算条件时，抛出此异常。例如，一个整数“除以零”时，抛出此类的一个实例。</li>
<li>NegativeArraySizeException：如果应用程序试图创建大小为负的数组，则抛出该异常。</li>
<li>NoSuchMethodException：无法找到某一特定方法时，抛出该异常。</li>
<li>SecurityException：由安全管理器抛出的异常，指示存在安全侵犯。</li>
<li>UnsupportedOperationException：当不支持请求的操作时，抛出该异常。</li>
<li>RuntimeExceptionRuntimeException：是那些可能在Java虚拟机正常运行期间抛出的异常的超类。</li>
</ul>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <contributor>
      <name>南辞</name>
    </contributor>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">模块08—网络</title>
    <id>http://qiqi.dreamagain.top/interview/Java208/%E6%A8%A1%E5%9D%9708%E2%80%94%E7%BD%91%E7%BB%9C/</id>
    <link href="http://qiqi.dreamagain.top/interview/Java208/%E6%A8%A1%E5%9D%9708%E2%80%94%E7%BD%91%E7%BB%9C/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<h2 id="问题"> 问题：</h2>
<p>79.http响应码301和302代表的是什么?有什么区别?</p>
<p>80.forward和redirect的区别?</p>
<p>81.简述tcp和udp的区别?</p>
<p>82.tcp为什么要三次握手，两次不行吗?为什么?</p>
<p>83.说一下 tcp粘包是怎么产生的?</p>
<p>84.OSl的七层模型都有哪些?</p>
<p>85.get和post请求有哪些区别?</p>
<p>86.如何实现跨域?</p>
<p>87.说一下JSONP 实现原理?</p>
<h2 id="答案"> 答案：</h2>
<h3 id="_79-http响应码301和302代表的是什么-有什么区别"> 79.http响应码301和302代表的是什么?有什么区别?</h3>
<p>301，302 都是HTTP状态的编码，都代表着某个URL发生了转移。</p>
<p><strong>区别：</strong></p>
<ul>
<li>
<p>301 redirect: 301 代表永久性转移(Permanently Moved)。</p>
</li>
<li>
<p>302 redirect: 302 代表暂时性转移(Temporarily Moved )。</p>
</li>
</ul>
<h3 id="_80-forward和redirect的区别"> 80.forward和redirect的区别?</h3>
<p>Forward和Redirect代表了两种请求转发方式：直接转发和间接转发。</p>
<p><strong>直接转发方式（Forward）</strong>，客户端和浏览器只发出一次请求，Servlet、HTML、JSP或其它信息资源，由第二个信息资源响应该请求，在请求对象request中，保存的对象对于每个信息资源是共享的。</p>
<p>**间接转发方式（Redirect）**实际是两次HTTP请求，服务器端在响应第一次请求的时候，让浏览器再向另外一个URL发出请求，从而达到转发的目的。</p>
<p><strong>举个通俗的例子：</strong></p>
<p>直接转发就相当于：“A找B借钱，B说没有，B去找C借，借到借不到都会把消息传递给A”；</p>
<p>间接转发就相当于：&quot;A找B借钱，B说没有，让A去找C借&quot;。</p>
<h3 id="_81-简述tcp和udp的区别"> 81.简述TCP和UDP的区别?</h3>
<ul>
<li>TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接。</li>
<li>TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付。</li>
<li>TCP通过校验和，重传控制，序号标识，滑动窗口、确认应答实现可靠传输。如丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。</li>
<li>UDP具有较好的实时性，工作效率比TCP高，适用于对高速传输和实时性有较高的通信或广播通信。</li>
<li>每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信。</li>
<li>TCP对系统资源要求较多，UDP对系统资源要求较少。</li>
</ul>
<h3 id="_82-tcp为什么要三次握手-两次不行吗-为什么"> 82.TCP为什么要三次握手，两次不行吗?为什么?</h3>
<p>为了实现可靠数据传输， TCP 协议的通信双方， 都必须维护一个序列号， 以标识发送出去的数据包中， 哪些是已经被对方收到的。</p>
<p>三次握手的过程即是通信双方相互告知序列号起始值， 并确认对方已经收到了序列号起始值的必经步骤。</p>
<p>如果只是两次握手， 至多只有连接发起方的起始序列号能被确认， 另一方选择的序列号则得不到确认。</p>
<h3 id="_83-说一下-tcp粘包是怎么产生的"> 83.说一下 TCP粘包是怎么产生的?</h3>
<p><strong>①. 发送方产生粘包</strong></p>
<p>采用TCP协议传输数据的客户端与服务器经常是保持一个长连接的状态（一次连接发一次数据不存在粘包），双方在连接不断开的情况下，可以一直传输数据；但当发送的数据包过于小的时候，那么TCP协议默认的会启用Nagle算法，将这些较小的数据包进行合并发送（缓冲区数据发送是一个堆压的过程）；这个合并过程就是在发送缓冲区中进行的，也就是说数据发送出来它已经是粘包的状态了。</p>
<blockquote>
<p><img src="./assets/image-20210110112812920.png" alt=""></p>
</blockquote>
<p><strong>②. 接收方产生粘包</strong></p>
<p>接收方采用TCP协议接收数据时的过程是这样的：数据到底接收方，从网络模型的下方传递至传输层，传输层的TCP协议处理是将其放置接收缓冲区，然后由应用层来主动获取（C语言用recv、read等函数）；这时会出现一个问题，就是我们在程序中调用的读取数据函数不能及时的把缓冲区中的数据拿出来，而下一个数据又到来并有一部分放入的缓冲区末尾，等我们读取数据时就是一个粘包。（放数据的速度 &gt; 应用层拿数据速度）</p>
<blockquote>
<p><img src="./assets/image-20210110113226253.png" alt=""></p>
</blockquote>
<h3 id="_84-osl的七层模型都有哪些"> 84.OSl的七层模型都有哪些?</h3>
<p><strong>物联网淑慧示用</strong></p>
<ol>
<li>应用层：网络服务与最终用户的一个接口。</li>
<li>表示层：数据的表示、安全、压缩。</li>
<li>会话层：建立、管理、终止会话。</li>
<li>传输层：定义传输数据的协议端口号，以及流控和差错校验。</li>
<li>网络层：进行逻辑地址寻址，实现不同网络之间的路径选择。</li>
<li>数据链路层：建立逻辑连接、进行硬件地址寻址、差错校验等功能。</li>
<li>物理层：建立、维护、断开物理连接。</li>
</ol>
<h3 id="_85-get和post请求有哪些区别"> 85.get和post请求有哪些区别?</h3>
<ul>
<li>GET在浏览器回退时是无害的，而POST会再次提交请求。</li>
<li>GET产生的URL地址可以被Bookmark，而POST不可以。</li>
<li>GET请求会被浏览器主动cache，而POST不会，除非手动设置。</li>
<li>GET请求只能进行url编码，而POST支持多种编码方式。</li>
<li>GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。</li>
<li>GET请求在URL中传送的参数是有长度限制的，而POST么有。</li>
<li>对参数的数据类型，GET只接受ASCII字符，而POST没有限制。</li>
<li>GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。</li>
<li>GET参数通过URL传递，POST放在Request body中。</li>
</ul>
<h3 id="_86-如何实现跨域"> 86.如何实现跨域?</h3>
<h4 id="方式一-图片ping或script标签跨域"> 方式一：图片ping或script标签跨域</h4>
<p><strong>图片ping</strong>常用于跟踪用户点击页面或动态广告曝光次数。 <strong>script标签</strong>可以得到从其他来源数据，这也是JSONP依赖的根据。</p>
<h4 id="方式二-jsonp跨域"> 方式二：JSONP跨域</h4>
<p>JSONP（JSON with Padding）是数据格式JSON的一种“使用模式”，可以让网页从别的网域要数据。根据 XmlHttpRequest 对象受到同源策略的影响，而利用 <code>&lt;script&gt;</code>元素的这个开放策略，网页可以得到从其他来源动态产生的JSON数据，而这种使用模式就是所谓的 JSONP。用JSONP抓到的数据并不是JSON，而是任意的JavaScript，用 JavaScript解释器运行而不是用JSON解析器解析。所有通过Chrome查看所有JSONP发送的Get请求都是js类型，而非XHR。</p>
<h4 id="方式三-cors"> 方式三：CORS</h4>
<p>Cross-Origin Resource Sharing（CORS）跨域资源共享是一份浏览器技术的规范，提供了 Web 服务从不同域传来沙盒脚本的方法，以避开浏览器的同源策略，确保安全的跨域数据传输。现代浏览器使用CORS在API容器如XMLHttpRequest来减少HTTP请求的风险来源。与 JSONP 不同，CORS 除了 GET 要求方法以外也支持其他的 HTTP 要求。服务器一般需要增加如下响应头的一种或几种：</p>
<div><pre><code>Access-Control-Allow-Origin: *
Access-Control-Allow-Methods: POST, GET, OPTIONS
Access-Control-Allow-Headers: X-PINGOTHER, Content-Type
Access-Control-Max-Age: 86400
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>跨域请求默认不会携带Cookie信息，如果需要携带，请配置下述参数：</p>
<div><pre><code>"Access-Control-Allow-Credentials": true
// Ajax设置
"withCredentials": true
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h4 id="方式四-window-name-iframe"> 方式四：window.name+iframe</h4>
<p><code>window.name</code>通过在iframe（一般动态创建）中加载跨域HTML文件来起作用。然后，HTML文件将传递给请求者的字符串内容赋值<code>window.name</code>。然后，请求者可以检索<code>window.name</code>值作为响应。</p>
<ul>
<li>iframe标签的跨域能力；</li>
<li><code>window.name</code>属性值在文档刷新后依旧存在的能力（且最大允许2M左右）。</li>
</ul>
<p>每个iframe都有包裹它的window，而这个window是top window的子窗口。contentWindow属性返回<code>&lt;iframe&gt;</code>元素的Window对象。你可以使用这个Window对象来访问iframe的文档及其内部DOM。</p>
<div><pre><code><span>&lt;!-- 
 下述用端口 
 10000表示：domainA
 10001表示：domainB
--></span>

<span>&lt;!-- localhost:10000 --></span>
<span><span><span>&lt;</span>script</span><span>></span></span><span><span>
  <span>var</span> iframe <span>=</span> document<span>.</span><span>createElement</span><span>(</span><span>'iframe'</span><span>)</span><span>;</span>
  iframe<span>.</span>style<span>.</span>display <span>=</span> <span>'none'</span><span>;</span> <span>// 隐藏</span>

  <span>var</span> state <span>=</span> <span>0</span><span>;</span> <span>// 防止页面无限刷新</span>
  iframe<span>.</span><span>onload</span> <span>=</span> <span>function</span><span>(</span><span>)</span> <span>{</span>
      <span>if</span><span>(</span>state <span>===</span> <span>1</span><span>)</span> <span>{</span>
          console<span>.</span><span>log</span><span>(</span><span>JSON</span><span>.</span><span>parse</span><span>(</span>iframe<span>.</span>contentWindow<span>.</span>name<span>)</span><span>)</span><span>;</span>
          <span>// 清除创建的iframe</span>
          iframe<span>.</span>contentWindow<span>.</span>document<span>.</span><span>write</span><span>(</span><span>''</span><span>)</span><span>;</span>
          iframe<span>.</span>contentWindow<span>.</span><span>close</span><span>(</span><span>)</span><span>;</span>
          document<span>.</span>body<span>.</span><span>removeChild</span><span>(</span>iframe<span>)</span><span>;</span>
      <span>}</span> <span>else</span> <span>if</span><span>(</span>state <span>===</span> <span>0</span><span>)</span> <span>{</span>
          state <span>=</span> <span>1</span><span>;</span>
          <span>// 加载完成，指向当前域，防止错误(proxy.html为空白页面)</span>
          <span>// Blocked a frame with origin "http://localhost:10000" from accessing a cross-origin frame.</span>
          iframe<span>.</span>contentWindow<span>.</span>location <span>=</span> <span>'http://localhost:10000/proxy.html'</span><span>;</span>
      <span>}</span>
  <span>}</span><span>;</span>

  iframe<span>.</span>src <span>=</span> <span>'http://localhost:10001'</span><span>;</span>
  document<span>.</span>body<span>.</span><span>appendChild</span><span>(</span>iframe<span>)</span><span>;</span>
</span></span><span><span><span>&lt;/</span>script</span><span>></span></span>

<span>&lt;!-- localhost:10001 --></span>
<span><span>&lt;!</span><span>DOCTYPE</span> <span>html</span><span>></span></span>
...
<span><span><span>&lt;</span>script</span><span>></span></span><span><span>
  window<span>.</span>name <span>=</span> <span>JSON</span><span>.</span><span>stringify</span><span>(</span><span>{</span>a<span>:</span> <span>1</span><span>,</span> b<span>:</span> <span>2</span><span>}</span><span>)</span><span>;</span>
</span></span><span><span><span>&lt;/</span>script</span><span>></span></span>
<span><span><span>&lt;/</span>html</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br></div></div><h4 id="方式五-window-postmessage"> 方式五：window.postMessage()</h4>
<p>HTML5新特性，可以用来向其他所有的 window 对象发送消息。需要注意的是我们必须要保证所有的脚本执行完才发送 MessageEvent，如果在函数执行的过程中调用了它，就会让后面的函数超时无法执行。</p>
<p>下述代码实现了跨域存储localStorage</p>
<div><pre><code><span>&lt;!-- 
 下述用端口 
 10000表示：domainA
 10001表示：domainB
--></span>

<span>&lt;!-- localhost:10000 --></span>
<span><span><span>&lt;</span>iframe</span> <span>src</span><span><span>=</span><span>"</span>http://localhost:10001/msg.html<span>"</span></span> <span>name</span><span><span>=</span><span>"</span>myPostMessage<span>"</span></span> <span><span>style</span><span><span>=</span><span>"</span><span><span>display</span><span>:</span>none<span>;</span></span><span>"</span></span></span><span>></span></span>
<span><span><span>&lt;/</span>iframe</span><span>></span></span>

<span><span><span>&lt;</span>script</span><span>></span></span><span><span>
  <span>function</span> <span>main</span><span>(</span><span>)</span> <span>{</span>
      <span>LSsetItem</span><span>(</span><span>'test'</span><span>,</span> <span>'Test: '</span> <span>+</span> <span>new</span> <span>Date</span><span>(</span><span>)</span><span>)</span><span>;</span>
      <span>LSgetItem</span><span>(</span><span>'test'</span><span>,</span> <span>function</span><span>(</span><span>value</span><span>)</span> <span>{</span>
          console<span>.</span><span>log</span><span>(</span><span>'value: '</span> <span>+</span> value<span>)</span><span>;</span>
      <span>}</span><span>)</span><span>;</span>
      <span>LSremoveItem</span><span>(</span><span>'test'</span><span>)</span><span>;</span>
  <span>}</span>

  <span>var</span> callbacks <span>=</span> <span>{</span><span>}</span><span>;</span>
  window<span>.</span><span>addEventListener</span><span>(</span><span>'message'</span><span>,</span> <span>function</span><span>(</span><span>event</span><span>)</span> <span>{</span>
      <span>if</span> <span>(</span>event<span>.</span>source <span>===</span> frames<span>[</span><span>'myPostMessage'</span><span>]</span><span>)</span> <span>{</span>
          console<span>.</span><span>log</span><span>(</span>event<span>)</span>
          <span>var</span> data <span>=</span> <span><span>/</span><span>^#localStorage#(\d+)(null)?#([\S\s]*)</span><span>/</span></span><span>.</span><span>exec</span><span>(</span>event<span>.</span>data<span>)</span><span>;</span>
          <span>if</span> <span>(</span>data<span>)</span> <span>{</span>
              <span>if</span> <span>(</span>callbacks<span>[</span>data<span>[</span><span>1</span><span>]</span><span>]</span><span>)</span> <span>{</span>
                  callbacks<span>[</span>data<span>[</span><span>1</span><span>]</span><span>]</span><span>(</span>data<span>[</span><span>2</span><span>]</span> <span>===</span> <span>'null'</span> <span>?</span> <span>null</span> <span>:</span> data<span>[</span><span>3</span><span>]</span><span>)</span><span>;</span>
              <span>}</span>
              <span>delete</span> callbacks<span>[</span>data<span>[</span><span>1</span><span>]</span><span>]</span><span>;</span>
          <span>}</span>
      <span>}</span>
  <span>}</span><span>,</span> <span>false</span><span>)</span><span>;</span>

  <span>var</span> domain <span>=</span> <span>'*'</span><span>;</span>
  <span>// 增加</span>
  <span>function</span> <span>LSsetItem</span><span>(</span><span>key<span>,</span> value</span><span>)</span> <span>{</span>
      <span>var</span> obj <span>=</span> <span>{</span>
          setItem<span>:</span> key<span>,</span>
          value<span>:</span> value
      <span>}</span><span>;</span>
      frames<span>[</span><span>'myPostMessage'</span><span>]</span><span>.</span><span>postMessage</span><span>(</span><span>JSON</span><span>.</span><span>stringify</span><span>(</span>obj<span>)</span><span>,</span> domain<span>)</span><span>;</span>
  <span>}</span>
  <span>// 获取</span>
  <span>function</span> <span>LSgetItem</span><span>(</span><span>key<span>,</span> callback</span><span>)</span> <span>{</span>
      <span>var</span> identifier <span>=</span> <span>new</span> <span>Date</span><span>(</span><span>)</span><span>.</span><span>getTime</span><span>(</span><span>)</span><span>;</span>
      <span>var</span> obj <span>=</span> <span>{</span>
          identifier<span>:</span> identifier<span>,</span>
          getItem<span>:</span> key
      <span>}</span><span>;</span>
      callbacks<span>[</span>identifier<span>]</span> <span>=</span> callback<span>;</span>
      frames<span>[</span><span>'myPostMessage'</span><span>]</span><span>.</span><span>postMessage</span><span>(</span><span>JSON</span><span>.</span><span>stringify</span><span>(</span>obj<span>)</span><span>,</span> domain<span>)</span><span>;</span>
  <span>}</span>
  <span>// 删除</span>
  <span>function</span> <span>LSremoveItem</span><span>(</span><span>key</span><span>)</span> <span>{</span>
      <span>var</span> obj <span>=</span> <span>{</span>
          removeItem<span>:</span> key
      <span>}</span><span>;</span>
      frames<span>[</span><span>'myPostMessage'</span><span>]</span><span>.</span><span>postMessage</span><span>(</span><span>JSON</span><span>.</span><span>stringify</span><span>(</span>obj<span>)</span><span>,</span> domain<span>)</span><span>;</span>
  <span>}</span>
</span></span><span><span><span>&lt;/</span>script</span><span>></span></span>

<span>&lt;!-- localhost:10001 --></span>
<span><span><span>&lt;</span>script</span><span>></span></span><span><span>
  window<span>.</span><span>addEventListener</span><span>(</span><span>'message'</span><span>,</span> <span>function</span><span>(</span><span>event</span><span>)</span> <span>{</span>
    console<span>.</span><span>log</span><span>(</span><span>'Receiver debugging'</span><span>,</span> event<span>)</span><span>;</span>
    <span>if</span> <span>(</span>event<span>.</span>origin <span>==</span> <span>'http://localhost:10000'</span><span>)</span> <span>{</span>
      <span>var</span> data <span>=</span> <span>JSON</span><span>.</span><span>parse</span><span>(</span>event<span>.</span>data<span>)</span><span>;</span>
      <span>if</span> <span>(</span><span>'setItem'</span> <span>in</span> data<span>)</span> <span>{</span>
        localStorage<span>.</span><span>setItem</span><span>(</span>data<span>.</span>setItem<span>,</span> data<span>.</span>value<span>)</span><span>;</span>
      <span>}</span> <span>else</span> <span>if</span> <span>(</span><span>'getItem'</span> <span>in</span> data<span>)</span> <span>{</span>
        <span>var</span> gotItem <span>=</span> localStorage<span>.</span><span>getItem</span><span>(</span>data<span>.</span>getItem<span>)</span><span>;</span>
        event<span>.</span>source<span>.</span><span>postMessage</span><span>(</span>
          <span>'#localStorage#'</span> <span>+</span> data<span>.</span>identifier <span>+</span>
          <span>(</span>gotItem <span>===</span> <span>null</span> <span>?</span> <span>'null#'</span> <span>:</span> <span>'#'</span> <span>+</span> gotItem<span>)</span><span>,</span>
          event<span>.</span>origin
        <span>)</span><span>;</span>
      <span>}</span> <span>else</span> <span>if</span> <span>(</span><span>'removeItem'</span> <span>in</span> data<span>)</span> <span>{</span>
        localStorage<span>.</span><span>removeItem</span><span>(</span>data<span>.</span>removeItem<span>)</span><span>;</span>
      <span>}</span>
    <span>}</span>
  <span>}</span><span>,</span> <span>false</span><span>)</span><span>;</span>
</span></span><span><span><span>&lt;/</span>script</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br></div></div><p>注意Safari一下，会报错：</p>
<p><strong>Blocked a frame with origin “http://localhost:10001” from accessing a frame with origin “http://localhost:10000“. Protocols, domains, and ports must match.</strong></p>
<p>避免该错误，可以在Safari浏览器中勾选开发菜单==&gt;停用跨域限制。或者只能使用服务器端转存的方式实现，因为Safari浏览器默认只支持CORS跨域请求。</p>
<h4 id="方式六-修改document-domain跨子域"> 方式六：修改document.domain跨子域</h4>
<p>前提条件：这两个域名必须属于同一个基础域名!而且所用的协议，端口都要一致，否则无法利用document.domain进行跨域，所以只能跨子域</p>
<p>在根域范围内，允许把domain属性的值设置为它的上一级域。例如，在”aaa.xxx.com”域内，可以把domain设置为 “xxx.com” 但不能设置为 “xxx.org” 或者”com”。</p>
<p>现在存在两个域名aaa.xxx.com和bbb.xxx.com。在aaa下嵌入bbb的页面，由于其document.name不一致，无法在aaa下操作bbb的js。可以在aaa和bbb下通过js将document.name = 'xxx.com';设置一致，来达到互相访问的作用。</p>
<h4 id="方式七-websocket"> 方式七：WebSocket</h4>
<p>WebSocket protocol 是HTML5一种新的协议。它实现了浏览器与服务器全双工通信，同时允许跨域通讯，是server push技术的一种很棒的实现。相关文章，请查看：WebSocket、WebSocket-SockJS</p>
<p>需要注意：WebSocket对象不支持DOM 2级事件侦听器，必须使用DOM 0级语法分别定义各个事件。</p>
<h4 id="方式八-代理"> 方式八：代理</h4>
<p>同源策略是针对浏览器端进行的限制，可以通过服务器端来解决该问题</p>
<p>DomainA客户端（浏览器） ==&gt; DomainA服务器 ==&gt; DomainB服务器 ==&gt; DomainA客户端（浏览器）</p>
<h3 id="_87-说一下jsonp-实现原理"> 87.说一下JSONP 实现原理?</h3>
<p>jsonp 即 json+padding，动态创建script标签，利用script标签的src属性可以获取任何域下的js脚本，通过这个特性(也可以说漏洞)，服务器端不在返回json格式，而是返回一段调用某个函数的js代码，在src中进行了调用，这样实现了跨域。</p>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <contributor>
      <name>南辞</name>
    </contributor>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">模块09—设计模式</title>
    <id>http://qiqi.dreamagain.top/interview/Java208/%E6%A8%A1%E5%9D%9709%E2%80%94%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <link href="http://qiqi.dreamagain.top/interview/Java208/%E6%A8%A1%E5%9D%9709%E2%80%94%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<h2 id="问题"> 问题：</h2>
<p>88.说一下你熟悉的设计模式?</p>
<p>89.简单工厂和抽象工厂有什么区别?</p>
<h2 id="答案"> 答案：</h2>
<h3 id="_88-说一下你熟悉的设计模式"> 88.说一下你熟悉的设计模式?</h3>
<h4 id="_1、单例模式"> 1、单例模式</h4>
<p>简单点说，就是一个应用程序中，某个类的实例对象只有一个，你没有办法去new，因为构造器是被private修饰的，一般通过getInstance()的方法来获取它们的实例。</p>
<p>getInstance()的返回值是一个对象的引用，并不是一个新的实例，所以不要错误的理解成多个对象。单例模式实现起来也很容易，直接看demo吧</p>
<p><strong>① 懒汉式法（线程不安全）</strong></p>
<div><pre><code><span>public</span> <span>class</span> <span>Singleton</span> <span>{</span>

<span>private</span> <span>static</span> <span>Singleton</span> singleton<span>;</span>

<span>private</span> <span>Singleton</span><span>(</span><span>)</span> <span>{</span>
<span>}</span>

<span>public</span> <span>static</span> <span>Singleton</span> <span>getInstance</span><span>(</span><span>)</span> <span>{</span>
 <span>if</span> <span>(</span>singleton <span>==</span> <span>null</span><span>)</span> <span>{</span>
  singleton <span>=</span> <span>new</span> <span>Singleton</span><span>(</span><span>)</span><span>;</span>
 <span>}</span>
 <span>return</span> singleton<span>;</span>
<span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p><strong>② 懒汉式写法（线程安全）</strong></p>
<div><pre><code><span>public</span> <span>class</span> <span>Singleton</span> <span>{</span>  
   <span>private</span> <span>static</span> <span>Singleton</span> instance<span>;</span>  
   <span>private</span> <span>Singleton</span> <span>(</span><span>)</span><span>{</span><span>}</span>  
   <span>public</span> <span>static</span> <span>synchronized</span> <span>Singleton</span> <span>getInstance</span><span>(</span><span>)</span> <span>{</span>  
   <span>if</span> <span>(</span>instance <span>==</span> <span>null</span><span>)</span> <span>{</span>  
       instance <span>=</span> <span>new</span> <span>Singleton</span><span>(</span><span>)</span><span>;</span>  
   <span>}</span>  
   <span>return</span> instance<span>;</span>  
   <span>}</span>  
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p><strong>③ 饿汉式写法</strong></p>
<div><pre><code><span>public</span> <span>class</span> <span>Singleton</span> <span>{</span>  
 
    <span>private</span> <span>static</span> <span>Singleton</span> instance <span>=</span> <span>new</span> <span>Singleton</span><span>(</span><span>)</span><span>;</span>  
 
    <span>private</span> <span>Singleton</span> <span>(</span><span>)</span><span>{</span><span>}</span>  
  
    <span>public</span> <span>static</span> <span>Singleton</span> <span>getInstance</span><span>(</span><span>)</span> <span>{</span>  
  			<span>return</span> instance<span>;</span>  
   <span>}</span>  
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p><strong>④ 静态内部类</strong></p>
<div><pre><code><span>public</span> <span>class</span> <span>Singleton</span> <span>{</span>  
    <span>private</span> <span>Singleton</span> <span>(</span><span>)</span><span>{</span><span>}</span>  
  
    <span>private</span> <span>static</span> <span>class</span> <span>SingletonHolder</span> <span>{</span>  
   		<span>private</span> <span>static</span> <span>final</span> <span>Singleton</span> INSTANCE <span>=</span> <span>new</span> <span>Singleton</span><span>(</span><span>)</span><span>;</span>  
   <span>}</span>  
   
    <span>public</span> <span>static</span> <span>final</span> <span>Singleton</span> <span>getInstance</span><span>(</span><span>)</span> <span>{</span>  
        <span>return</span> <span>SingletonHolder</span><span>.</span>INSTANCE<span>;</span>  
   <span>}</span>  
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p><strong>⑤ 枚举</strong></p>
<div><pre><code><span>public</span> <span>enum</span> <span>Singleton</span> <span>{</span>  
   INSTANCE<span>;</span>  
   <span>public</span> <span>void</span> <span>whateverMethod</span><span>(</span><span>)</span> <span>{</span>  
   <span>}</span>  
<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>这种方式是Effective Java作者Josh Bloch 提倡的方式，它不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象，可谓是很坚强的壁垒啊，不过，个人认为由于1.5中才加入enum特性，用这种方式写不免让人感觉生疏。</p>
<p><strong>⑥ 双重校验锁</strong></p>
<div><pre><code><span>public</span> <span>class</span> <span>Singleton</span> <span>{</span>  
   <span>private</span> <span>volatile</span> <span>static</span> <span>Singleton</span> singleton<span>;</span>  
   <span>private</span> <span>Singleton</span> <span>(</span><span>)</span><span>{</span><span>}</span>  
   <span>public</span> <span>static</span> <span>Singleton</span> <span>getSingleton</span><span>(</span><span>)</span> <span>{</span>  
   <span>if</span> <span>(</span>singleton <span>==</span> <span>null</span><span>)</span> <span>{</span>  
       <span>synchronized</span> <span>(</span><span>Singleton</span><span>.</span><span>class</span><span>)</span> <span>{</span>  
       <span>if</span> <span>(</span>singleton <span>==</span> <span>null</span><span>)</span> <span>{</span>  
           singleton <span>=</span> <span>new</span> <span>Singleton</span><span>(</span><span>)</span><span>;</span>  
       <span>}</span>  
       <span>}</span>  
   <span>}</span>  
   <span>return</span> singleton<span>;</span>  
   <span>}</span>  
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p><strong>总结</strong>：我个人比较喜欢静态内部类写法和饿汉式写法，其实这两种写法能够应付绝大多数情况了。其他写法也可以选择，主要还是看业务需求吧。</p>
<h4 id="_2、观察者模式"> 2、观察者模式</h4>
<p>对象间一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。</p>
<p><img src="./assets/image-20210110121411458.png" alt="image-20210110121411458"></p>
<p>看不懂图的人端着小板凳到这里来，给你举个栗子：假设有三个人，小美（女，22），小王和小李。小美很漂亮，小王和小李是两个程</p>
<p>序猿，时刻关注着小美的一举一动。有一天，小美说了一句：“谁来陪我打游戏啊。”这句话被小王和小李听到了，结果乐坏了，蹭蹭</p>
<p>蹭，没一会儿，小王就冲到小美家门口了，在这里，小美是被观察者，小王和小李是观察者，被观察者发出一条信息，然后观察者们进</p>
<p>行相应的处理，看代码：</p>
<div><pre><code><span>public</span> <span>interface</span> <span>Person</span> <span>{</span>
   <span>//小王和小李通过这个接口可以接收到小美发过来的消息</span>
   <span>void</span> <span>getMessage</span><span>(</span><span>String</span> s<span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>这个接口相当于小王和小李的电话号码，小美发送通知的时候就会拨打getMessage这个电话，拨打电话就是调用接口，看不懂没关</p>
<p>系，先往下看</p>
<div><pre><code><span>public</span> <span>class</span> <span>LaoWang</span> <span>implements</span> <span>Person</span> <span>{</span>

   <span>private</span> <span>String</span> name <span>=</span> <span>"小王"</span><span>;</span>

   <span>public</span> <span>LaoWang</span><span>(</span><span>)</span> <span>{</span>
   <span>}</span>

   <span>@Override</span>
   <span>public</span> <span>void</span> <span>getMessage</span><span>(</span><span>String</span> s<span>)</span> <span>{</span>
       <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>name <span>+</span> <span>"接到了小美打过来的电话，电话内容是："</span> <span>+</span> s<span>)</span><span>;</span>
   <span>}</span>

<span>}</span>

<span>public</span> <span>class</span> <span>LaoLi</span> <span>implements</span> <span>Person</span> <span>{</span>

   <span>private</span> <span>String</span> name <span>=</span> <span>"小李"</span><span>;</span>

   <span>public</span> <span>LaoLi</span><span>(</span><span>)</span> <span>{</span>
   <span>}</span>

   <span>@Override</span>
   <span>public</span> <span>void</span> <span>getMessage</span><span>(</span><span>String</span> s<span>)</span> <span>{</span>
       <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>name <span>+</span> <span>"接到了小美打过来的电话，电话内容是：->"</span> <span>+</span> s<span>)</span><span>;</span>
   <span>}</span>

<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div><p>代码很简单，我们再看看小美的代码：</p>
<div><pre><code><span>public</span> <span>class</span> <span>XiaoMei</span> <span>{</span>
   <span>List</span><span><span>&lt;</span><span>Person</span><span>></span></span> list <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>Person</span><span>></span></span><span>(</span><span>)</span><span>;</span>
    <span>public</span> <span>XiaoMei</span><span>(</span><span>)</span><span>{</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>addPerson</span><span>(</span><span>Person</span> person<span>)</span><span>{</span>
        list<span>.</span><span>add</span><span>(</span>person<span>)</span><span>;</span>
    <span>}</span>

    <span>//遍历list，把自己的通知发送给所有暗恋自己的人</span>
    <span>public</span> <span>void</span> <span>notifyPerson</span><span>(</span><span>)</span> <span>{</span>
        <span>for</span><span>(</span><span>Person</span> person<span>:</span>list<span>)</span><span>{</span>
            person<span>.</span><span>getMessage</span><span>(</span><span>"你们过来吧，谁先过来谁就能陪我一起玩儿游戏!"</span><span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>我们写一个测试类来看一下结果对不对</p>
<div><pre><code><span>public</span> <span>class</span> <span>Test</span> <span>{</span>
   <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>

       <span>XiaoMei</span> xiao_mei <span>=</span> <span>new</span> <span>XiaoMei</span><span>(</span><span>)</span><span>;</span>
       <span>LaoWang</span> lao_wang <span>=</span> <span>new</span> <span>LaoWang</span><span>(</span><span>)</span><span>;</span>
       <span>LaoLi</span> lao_li <span>=</span> <span>new</span> <span>LaoLi</span><span>(</span><span>)</span><span>;</span>

       <span>//小王和小李在小美那里都注册了一下</span>
       xiao_mei<span>.</span><span>addPerson</span><span>(</span>lao_wang<span>)</span><span>;</span>
       xiao_mei<span>.</span><span>addPerson</span><span>(</span>lao_li<span>)</span><span>;</span>

       <span>//小美向小王和小李发送通知</span>
       xiao_mei<span>.</span><span>notifyPerson</span><span>(</span><span>)</span><span>;</span>
   <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><h4 id="_3、装饰者模式"> 3、装饰者模式</h4>
<p>对已有的业务逻辑进一步的封装，使其增加额外的功能，如Java中的IO流就使用了装饰者模式，用户在使用的时候，可以任意组装，达</p>
<p>到自己想要的效果。 举个栗子，我想吃三明治，首先我需要一根大大的香肠，我喜欢吃奶油，在香肠上面加一点奶油，再放一点蔬菜，</p>
<p>最后再用两片面包夹一下，很丰盛的一顿午饭，营养又健康。那我们应该怎么来写代码呢？ 首先，我们需要写一个Food类，让其他所</p>
<p>有食物都来继承这个类，看代码：</p>
<div><pre><code><span>public</span> <span>class</span> <span>Food</span> <span>{</span>

   <span>private</span> <span>String</span> food_name<span>;</span>

   <span>public</span> <span>Food</span><span>(</span><span>)</span> <span>{</span>
   <span>}</span>

   <span>public</span> <span>Food</span><span>(</span><span>String</span> food_name<span>)</span> <span>{</span>
       <span>this</span><span>.</span>food_name <span>=</span> food_name<span>;</span>
   <span>}</span>

   <span>public</span> <span>String</span> <span>make</span><span>(</span><span>)</span> <span>{</span>
       <span>return</span> food_name<span>;</span>
   <span>}</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>代码很简单，然后我们写几个子类继承它：</p>
<div><pre><code><span>//面包类</span>
<span>public</span> <span>class</span> <span>Bread</span> <span>extends</span> <span>Food</span> <span>{</span>

   <span>private</span> <span>Food</span> basic_food<span>;</span>

   <span>public</span> <span>Bread</span><span>(</span><span>Food</span> basic_food<span>)</span> <span>{</span>
       <span>this</span><span>.</span>basic_food <span>=</span> basic_food<span>;</span>
   <span>}</span>

   <span>public</span> <span>String</span> <span>make</span><span>(</span><span>)</span> <span>{</span>
       <span>return</span> basic_food<span>.</span><span>make</span><span>(</span><span>)</span><span>+</span><span>"+面包"</span><span>;</span>
   <span>}</span>
<span>}</span>

<span>//奶油类</span>
<span>public</span> <span>class</span> <span>Cream</span> <span>extends</span> <span>Food</span> <span>{</span>

   <span>private</span> <span>Food</span> basic_food<span>;</span>

   <span>public</span> <span>Cream</span><span>(</span><span>Food</span> basic_food<span>)</span> <span>{</span>
       <span>this</span><span>.</span>basic_food <span>=</span> basic_food<span>;</span>
   <span>}</span>

   <span>public</span> <span>String</span> <span>make</span><span>(</span><span>)</span> <span>{</span>
       <span>return</span> basic_food<span>.</span><span>make</span><span>(</span><span>)</span><span>+</span><span>"+奶油"</span><span>;</span>
   <span>}</span>
<span>}</span>

<span>//蔬菜类</span>
<span>public</span> <span>class</span> <span>Vegetable</span> <span>extends</span> <span>Food</span> <span>{</span>

   <span>private</span> <span>Food</span> basic_food<span>;</span>

   <span>public</span> <span>Vegetable</span><span>(</span><span>Food</span> basic_food<span>)</span> <span>{</span>
       <span>this</span><span>.</span>basic_food <span>=</span> basic_food<span>;</span>
   <span>}</span>

   <span>public</span> <span>String</span> <span>make</span><span>(</span><span>)</span> <span>{</span>
       <span>return</span> basic_food<span>.</span><span>make</span><span>(</span><span>)</span><span>+</span><span>"+蔬菜"</span><span>;</span>
   <span>}</span>

<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br></div></div><p>这几个类都是差不多的，构造方法传入一个Food类型的参数，然后在make方法中加入一些自己的逻辑，如果你还是看不懂为什么这么</p>
<p>写，不急，你看看我的Test类是怎么写的，一看你就明白了</p>
<div><pre><code><span>public</span> <span>class</span> <span>Test</span> <span>{</span>
   <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
       <span>Food</span> food <span>=</span> <span>new</span> <span>Bread</span><span>(</span><span>new</span> <span>Vegetable</span><span>(</span><span>new</span> <span>Cream</span><span>(</span><span>new</span> <span>Food</span><span>(</span><span>"香肠"</span><span>)</span><span>)</span><span>)</span><span>)</span><span>;</span>
       <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>food<span>.</span><span>make</span><span>(</span><span>)</span><span>)</span><span>;</span>
   <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>看到没有，一层一层封装，我们从里往外看：最里面我new了一个香肠，在香肠的外面我包裹了一层奶油，在奶油的外面我又加了一层</p>
<p>蔬菜，最外面我放的是面包，是不是很形象，哈哈~ 这个设计模式简直跟现实生活中一摸一样，看懂了吗？ 我们看看运行结果吧</p>
<p><img src="./assets/image-20210110122635076.png" alt="image-20210110122635076"></p>
<p>一个三明治就做好了～</p>
<h4 id="_4、适配器模式"> 4、适配器模式</h4>
<p>将两种完全不同的事物联系到一起，就像现实生活中的变压器。假设一个手机充电器需要的电压是20V，但是正常的电压是220V，这时</p>
<p>候就需要一个变压器，将220V的电压转换成20V的电压，这样，变压器就将20V的电压和手机联系起来了。</p>
<div><pre><code><span>public</span> <span>class</span> <span>Test</span> <span>{</span>
   <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
       <span>Phone</span> phone <span>=</span> <span>new</span> <span>Phone</span><span>(</span><span>)</span><span>;</span>
       <span>VoltageAdapter</span> adapter <span>=</span> <span>new</span> <span>VoltageAdapter</span><span>(</span><span>)</span><span>;</span>
       phone<span>.</span><span>setAdapter</span><span>(</span>adapter<span>)</span><span>;</span>
       phone<span>.</span><span>charge</span><span>(</span><span>)</span><span>;</span>
   <span>}</span>
<span>}</span>

<span>// 手机类</span>
<span>class</span> <span>Phone</span> <span>{</span>

   <span>public</span> <span>static</span> <span>final</span> <span>int</span> <span>V</span> <span>=</span> <span>220</span><span>;</span><span>// 正常电压220v，是一个常量</span>

   <span>private</span> <span>VoltageAdapter</span> adapter<span>;</span>

   <span>// 充电</span>
   <span>public</span> <span>void</span> <span>charge</span><span>(</span><span>)</span> <span>{</span>
       adapter<span>.</span><span>changeVoltage</span><span>(</span><span>)</span><span>;</span>
   <span>}</span>

   <span>public</span> <span>void</span> <span>setAdapter</span><span>(</span><span>VoltageAdapter</span> adapter<span>)</span> <span>{</span>
       <span>this</span><span>.</span>adapter <span>=</span> adapter<span>;</span>
   <span>}</span>
<span>}</span>

<span>// 变压器</span>
<span>class</span> <span>VoltageAdapter</span> <span>{</span>
   <span>// 改变电压的功能</span>
   <span>public</span> <span>void</span> <span>changeVoltage</span><span>(</span><span>)</span> <span>{</span>
       <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"正在充电..."</span><span>)</span><span>;</span>
       <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"原始电压："</span> <span>+</span> <span>Phone<span>.</span>V</span> <span>+</span> <span>"V"</span><span>)</span><span>;</span>
       <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"经过变压器转换之后的电压:"</span> <span>+</span> <span>(</span><span>Phone<span>.</span>V</span> <span>-</span> <span>200</span><span>)</span> <span>+</span> <span>"V"</span><span>)</span><span>;</span>
   <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br></div></div><p><img src="./assets/image-20210110123230431.png" alt="image-20210110123230431"></p>
<h4 id="_5、工厂模式"> 5、工厂模式</h4>
<p>**① 简单工厂模式：**一个抽象的接口，多个抽象接口的实现类，一个工厂类，用来实例化抽象的接口</p>
<div><pre><code><span>// 抽象产品类</span>
<span>abstract</span> <span>class</span> <span>Car</span> <span>{</span>
   <span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span><span>;</span>

   <span>public</span> <span>void</span> <span>stop</span><span>(</span><span>)</span><span>;</span>
<span>}</span>

<span>// 具体实现类</span>
<span>class</span> <span>Benz</span> <span>implements</span> <span>Car</span> <span>{</span>
   <span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span> <span>{</span>
       <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"Benz开始启动了。。。。。"</span><span>)</span><span>;</span>
   <span>}</span>

   <span>public</span> <span>void</span> <span>stop</span><span>(</span><span>)</span> <span>{</span>
       <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"Benz停车了。。。。。"</span><span>)</span><span>;</span>
   <span>}</span>
<span>}</span>

<span>class</span> <span>Ford</span> <span>implements</span> <span>Car</span> <span>{</span>
   <span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span> <span>{</span>
       <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"Ford开始启动了。。。"</span><span>)</span><span>;</span>
   <span>}</span>

   <span>public</span> <span>void</span> <span>stop</span><span>(</span><span>)</span> <span>{</span>
       <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"Ford停车了。。。。"</span><span>)</span><span>;</span>
   <span>}</span>
<span>}</span>

<span>// 工厂类</span>
<span>class</span> <span>Factory</span> <span>{</span>
   <span>public</span> <span>static</span> <span>Car</span> <span>getCarInstance</span><span>(</span><span>String</span> type<span>)</span> <span>{</span>
       <span>Car</span> c <span>=</span> <span>null</span><span>;</span>
       <span>if</span> <span>(</span><span>"Benz"</span><span>.</span><span>equals</span><span>(</span>type<span>)</span><span>)</span> <span>{</span>
           c <span>=</span> <span>new</span> <span>Benz</span><span>(</span><span>)</span><span>;</span>
       <span>}</span>
       <span>if</span> <span>(</span><span>"Ford"</span><span>.</span><span>equals</span><span>(</span>type<span>)</span><span>)</span> <span>{</span>
           c <span>=</span> <span>new</span> <span>Ford</span><span>(</span><span>)</span><span>;</span>
       <span>}</span>
       <span>return</span> c<span>;</span>
   <span>}</span>
<span>}</span>

<span>public</span> <span>class</span> <span>Test</span> <span>{</span>

   <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
       <span>Car</span> c <span>=</span> <span>Factory</span><span>.</span><span>getCarInstance</span><span>(</span><span>"Benz"</span><span>)</span><span>;</span>
       <span>if</span> <span>(</span>c <span>!=</span> <span>null</span><span>)</span> <span>{</span>
           c<span>.</span><span>run</span><span>(</span><span>)</span><span>;</span>
           c<span>.</span><span>stop</span><span>(</span><span>)</span><span>;</span>
       <span>}</span> <span>else</span> <span>{</span>
           <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"造不了这种汽车。。。"</span><span>)</span><span>;</span>
       <span>}</span>

   <span>}</span>

<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br></div></div><p>**② 工厂方法模式：**有四个角色，抽象工厂模式，具体工厂模式，抽象产品模式，具体产品模式。不再是由一个工厂类去实例化</p>
<p>具体的产品，而是由抽象工厂的子类去实例化产品</p>
<div><pre><code><span>// 抽象产品角色</span>
<span>public</span> <span>interface</span> <span>Moveable</span> <span>{</span>
   <span>void</span> <span>run</span><span>(</span><span>)</span><span>;</span>
<span>}</span>

<span>// 具体产品角色</span>
<span>public</span> <span>class</span> <span>Plane</span> <span>implements</span> <span>Moveable</span> <span>{</span>
   <span>@Override</span>
   <span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span> <span>{</span>
       <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"plane...."</span><span>)</span><span>;</span>
   <span>}</span>
<span>}</span>

<span>public</span> <span>class</span> <span>Broom</span> <span>implements</span> <span>Moveable</span> <span>{</span>
   <span>@Override</span>
   <span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span> <span>{</span>
       <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"broom....."</span><span>)</span><span>;</span>
   <span>}</span>
<span>}</span>

<span>// 抽象工厂</span>
<span>public</span> <span>abstract</span> <span>class</span> <span>VehicleFactory</span> <span>{</span>
   <span>abstract</span> <span>Moveable</span> <span>create</span><span>(</span><span>)</span><span>;</span>
<span>}</span>

<span>// 具体工厂</span>
<span>public</span> <span>class</span> <span>PlaneFactory</span> <span>extends</span> <span>VehicleFactory</span> <span>{</span>
   <span>public</span> <span>Moveable</span> <span>create</span><span>(</span><span>)</span> <span>{</span>
       <span>return</span> <span>new</span> <span>Plane</span><span>(</span><span>)</span><span>;</span>
   <span>}</span>
<span>}</span>

<span>public</span> <span>class</span> <span>BroomFactory</span> <span>extends</span> <span>VehicleFactory</span> <span>{</span>
   <span>public</span> <span>Moveable</span> <span>create</span><span>(</span><span>)</span> <span>{</span>
       <span>return</span> <span>new</span> <span>Broom</span><span>(</span><span>)</span><span>;</span>
   <span>}</span>
<span>}</span>

<span>// 测试类</span>
<span>public</span> <span>class</span> <span>Test</span> <span>{</span>
   <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
       <span>VehicleFactory</span> factory <span>=</span> <span>new</span> <span>BroomFactory</span><span>(</span><span>)</span><span>;</span>
       <span>Moveable</span> m <span>=</span> factory<span>.</span><span>create</span><span>(</span><span>)</span><span>;</span>
       m<span>.</span><span>run</span><span>(</span><span>)</span><span>;</span>
   <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br></div></div><p>**③ 抽象工厂模式：**与工厂方法模式不同的是，工厂方法模式中的工厂只生产单一的产品，而抽象工厂模式中的工厂生产多个产</p>
<p>品</p>
<div><pre><code><span>//抽象工厂类</span>
<span>public</span> <span>abstract</span> <span>class</span> <span>AbstractFactory</span> <span>{</span>
   <span>public</span> <span>abstract</span> <span>Vehicle</span> <span>createVehicle</span><span>(</span><span>)</span><span>;</span>
   <span>public</span> <span>abstract</span> <span>Weapon</span> <span>createWeapon</span><span>(</span><span>)</span><span>;</span>
   <span>public</span> <span>abstract</span> <span>Food</span> <span>createFood</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
<span>//具体工厂类，其中Food,Vehicle，Weapon是抽象类，</span>
<span>public</span> <span>class</span> <span>DefaultFactory</span> <span>extends</span> <span>AbstractFactory</span><span>{</span>
   <span>@Override</span>
   <span>public</span> <span>Food</span> <span>createFood</span><span>(</span><span>)</span> <span>{</span>
       <span>return</span> <span>new</span> <span>Apple</span><span>(</span><span>)</span><span>;</span>
   <span>}</span>
   <span>@Override</span>
   <span>public</span> <span>Vehicle</span> <span>createVehicle</span><span>(</span><span>)</span> <span>{</span>
       <span>return</span> <span>new</span> <span>Car</span><span>(</span><span>)</span><span>;</span>
   <span>}</span>
   <span>@Override</span>
   <span>public</span> <span>Weapon</span> <span>createWeapon</span><span>(</span><span>)</span> <span>{</span>
       <span>return</span> <span>new</span> <span>AK47</span><span>(</span><span>)</span><span>;</span>
   <span>}</span>
<span>}</span>
<span>//测试类</span>
<span>public</span> <span>class</span> <span>Test</span> <span>{</span>
   <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
       <span>AbstractFactory</span> f <span>=</span> <span>new</span> <span>DefaultFactory</span><span>(</span><span>)</span><span>;</span>
       <span>Vehicle</span> v <span>=</span> f<span>.</span><span>createVehicle</span><span>(</span><span>)</span><span>;</span>
       v<span>.</span><span>run</span><span>(</span><span>)</span><span>;</span>
       <span>Weapon</span> w <span>=</span> f<span>.</span><span>createWeapon</span><span>(</span><span>)</span><span>;</span>
       w<span>.</span><span>shoot</span><span>(</span><span>)</span><span>;</span>
       <span>Food</span> a <span>=</span> f<span>.</span><span>createFood</span><span>(</span><span>)</span><span>;</span>
       a<span>.</span><span>printName</span><span>(</span><span>)</span><span>;</span>
   <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br></div></div><h4 id="_6、代理模式-proxy"> 6、代理模式（proxy）</h4>
<p>代理模式有两种，静态代理和动态代理。</p>
<p><strong>静态代理：</strong></p>
<p>到了一定的年龄，我们就要结婚，结婚是一件很麻烦的事情，（包括那些被父母催婚的）。有钱的家庭可能会找司仪来主持婚礼，显得</p>
<p>热闹，洋气～好了，现在婚庆公司的生意来了，我们只需要给钱，婚庆公司就会帮我们安排一整套结婚的流程。整个流程大概是这样</p>
<p>的：家里人催婚-&gt;男女双方家庭商定结婚的黄道即日-&gt;找一家靠谱的婚庆公司-&gt;在约定的时间举行结婚仪式-&gt;结婚完毕</p>
<p>婚庆公司打算怎么安排婚礼的节目，在婚礼完毕以后婚庆公司会做什么，我们一概不知。。。别担心，不是黑中介，我们只要把钱给人</p>
<p>家，人家会把事情给我们做好。所以，这里的婚庆公司相当于代理角色，现在明白什么是代理角色了吧。</p>
<p>代理接口代码：</p>
<div><pre><code><span>//代理接口</span>
<span>public</span> <span>interface</span> <span>ProxyInterface</span> <span>{</span>
<span>//需要代理的是结婚这件事，如果还有其他事情需要代理，比如吃饭睡觉上厕所，也可以写</span>
<span>void</span> <span>marry</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>婚庆公司的代码:</p>
<div><pre><code><span>public</span> <span>class</span> <span>WeddingCompany</span> <span>implements</span> <span>ProxyInterface</span> <span>{</span>

<span>private</span> <span>ProxyInterface</span> proxyInterface<span>;</span>

<span>public</span> <span>WeddingCompany</span><span>(</span><span>ProxyInterface</span> proxyInterface<span>)</span> <span>{</span>
 <span>this</span><span>.</span>proxyInterface <span>=</span> proxyInterface<span>;</span>
<span>}</span>

<span>@Override</span>
<span>public</span> <span>void</span> <span>marry</span><span>(</span><span>)</span> <span>{</span>
 <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"我们是婚庆公司的"</span><span>)</span><span>;</span>
 <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"我们在做结婚前的准备工作"</span><span>)</span><span>;</span>
 <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"节目彩排..."</span><span>)</span><span>;</span>
 <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"礼物购买..."</span><span>)</span><span>;</span>
 <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"工作人员分工..."</span><span>)</span><span>;</span>
 <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"可以开始结婚了"</span><span>)</span><span>;</span>
 proxyInterface<span>.</span><span>marry</span><span>(</span><span>)</span><span>;</span>
 <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"结婚完毕，我们需要做后续处理，你们可以回家了，其余的事情我们公司来做"</span><span>)</span><span>;</span>
<span>}</span>

<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><p>看到没有，婚庆公司需要做的事情很多，我们再看看结婚家庭的代码:</p>
<div><pre><code><span>public</span> <span>class</span> <span>NormalHome</span> <span>implements</span> <span>ProxyInterface</span><span>{</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>marry</span><span>(</span><span>)</span> <span>{</span>
     	<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"我们结婚啦～"</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>这个已经很明显了，结婚家庭只需要结婚，而婚庆公司要包揽一切，前前后后的事情都是婚庆公司来做，听说现在婚庆公司很赚钱的，</p>
<p>这就是原因，干的活多，能不赚钱吗？</p>
<p>来看看测试类代码：</p>
<div><pre><code><span>public</span> <span>class</span> <span>Test</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
         <span>ProxyInterface</span> proxyInterface <span>=</span> <span>new</span> <span>WeddingCompany</span><span>(</span><span>new</span> <span>NormalHome</span><span>(</span><span>)</span><span>)</span><span>;</span>
         proxyInterface<span>.</span><span>marry</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p><img src="./assets/image-20210110124934337.png" alt="image-20210110124934337"></p>
<blockquote>
<h3 id="_89-简单工厂和抽象工厂有什么区别"> 89.简单工厂和抽象工厂有什么区别?</h3>
</blockquote>
<p><strong>简单工厂模式</strong>：</p>
<p>这个模式本身很简单而且使用在业务较简单的情况下。一般用于小项目或者具体产品很少扩展的情况（这样工厂类才不用经常更改）。</p>
<p>它由三种角色组成：</p>
<ul>
<li>工厂类角色：这是本模式的核心，含有一定的商业逻辑和判断逻辑，根据逻辑不同，产生具体的工厂产品。如例子中的Driver类。</li>
<li>抽象产品角色：它一般是具体产品继承的父类或者实现的接口。由接口或者抽象类来实现。如例中的Car接口。</li>
<li>具体产品角色：工厂类所创建的对象就是此角色的实例。在java中由一个具体类实现，如例子中的Benz、Bmw类。</li>
</ul>
<p>用类图来清晰的表示下的它们之间的关系：</p>
<p><img src="./assets/image-20210110125152216.png" alt="image-20210110125152216"></p>
<p><strong>抽象工厂模式：</strong></p>
<p>先来认识下什么是产品族： 位于不同产品等级结构中，功能相关联的产品组成的家族。</p>
<p><img src="./assets/image-20210110125238563.png" alt="image-20210110125238563"></p>
<p>图中的BmwCar和BenzCar就是两个产品树（产品层次结构）；而如图所示的BenzSportsCar和BmwSportsCar就是一个产品族。他们都可以放到跑车家族中，因此功能有所关联。同理BmwBussinessCar和BenzBusinessCar也是一个产品族。</p>
<p><strong>可以这么说，它和工厂方法模式的区别就在于需要创建对象的复杂程度上。而且抽象工厂模式是三个里面最为抽象、最具一般性的。抽象工厂模式的用意为：给客户端提供一个接口，可以创建多个产品族中的产品对象。</strong></p>
<p>而且使用抽象工厂模式还要满足一下条件：</p>
<ol>
<li>系统中有多个产品族，而系统一次只可能消费其中一族产品</li>
<li>同属于同一个产品族的产品以其使用。</li>
</ol>
<p>来看看抽象工厂模式的各个角色（和工厂方法的如出一辙）：</p>
<ul>
<li>抽象工厂角色： 这是工厂方法模式的核心，它与应用程序无关。是具体工厂角色必须实现的接口或者必须继承的父类。在java中它由抽象类或者接口来实现。</li>
<li>具体工厂角色：它含有和具体业务逻辑有关的代码。由应用程序调用以创建对应的具体产品的对象。在java中它由具体的类来实现。</li>
<li>抽象产品角色：它是具体产品继承的父类或者是实现的接口。在java中一般有抽象类或者接口来实现。</li>
<li>具体产品角色：具体工厂角色所创建的对象就是此角色的实例。在java中由具体的类来实现。</li>
</ul>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <contributor>
      <name>南辞</name>
    </contributor>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">模块10—Spring/Spring MVC</title>
    <id>http://qiqi.dreamagain.top/interview/Java208/%E6%A8%A1%E5%9D%9710%E2%80%94SpringSpring%20MVC/</id>
    <link href="http://qiqi.dreamagain.top/interview/Java208/%E6%A8%A1%E5%9D%9710%E2%80%94SpringSpring%20MVC/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<h2 id="问题"> 问题：</h2>
<p>90.为什么要使用Spring?</p>
<p>91.解释一下什么是AOP?</p>
<p>92.解释一下什么是IoC?</p>
<p>93.Spring有哪些主要模块?</p>
<p>94.Spring 常用的注入方式有哪些?</p>
<p>95.Spring 中的 bean是线程安全的吗?</p>
<p>96.Spring支持几种bean的作用域?</p>
<p>97.Spring自动装配bean有哪些方式?</p>
<p>98.Spring事务实现方式有哪些?</p>
<p>99.说一下Spring 的事务隔离?</p>
<p>100.说一下Spring MVC运行流程?</p>
<p>101.Spring MVC有哪些组件?</p>
<p>102.@RequestMapping 的作用是什么?</p>
<p>103.@Autowired的作用是什么?</p>
<h2 id="答案"> 答案：</h2>
<h3 id="_90-为什么要使用spring"> 90.为什么要使用Spring?</h3>
<p><strong>1.简介</strong></p>
<ul>
<li>目的：解决企业应用开发的复杂性</li>
<li>功能：使用基本的JavaBean代替EJB，并提供了更多的企业应用功能</li>
<li>范围：任何Java应用</li>
</ul>
<p>简单来说，Spring是一个轻量级的控制反转(IoC)和面向切面(AOP)的容器框架。</p>
<p><strong>2.轻量</strong></p>
<p>从大小与开销两方面而言Spring都是轻量的。完整的Spring框架可以在一个大小只有1MB多的 jar文件里发布。并且Spring所需的处理</p>
<p>开销也是微不足道的。此外，Spring是非侵入式的：典型地，Spring应用中的对象不依赖于Spring的特定类。</p>
<p><strong>3.控制反转</strong></p>
<p>Spring通过一种称作控制反转（IoC）的技术促进了松耦合。当应用了IoC，一个对象依赖的其它对象会通过被动的方式传递进来，而不</p>
<p>是这个对象自己创建或者查找依赖对象。你可以认为IoC与JNDI相反——不是对象从容器中查找依赖，而是容器在对象初始化时不等对</p>
<p>象请求就主动将依赖传递给它。</p>
<p><strong>4.面向切面</strong></p>
<p>Spring提供了面向切面编程的丰富支持，允许通过分离应用的业务逻辑与系统级服务（例如审计（auditing）和事务（transaction）管</p>
<p>理）进行内聚性的开发。应用对象只实现它们应该做的——完成业务逻辑——仅此而已。它们并不负责（甚至是意识）其它的系统级关</p>
<p>注点，例如日志或事务支持。</p>
<p><strong>5.容器</strong></p>
<p>Spring包含并管理应用对象的配置和生命周期，在这个意义上它是一种容器，你可以配置你的每个bean如何被创建——基于一个可配置</p>
<p>原型（prototype），你的bean可以创建一个单独的实例或者每次需要时都生成一个新的实例——以及它们是如何相互关联的。然而，</p>
<p>Spring不应该被混同于传统的重量级的EJB容器，它们经常是庞大与笨重的，难以使用。</p>
<p><strong>6.框架</strong></p>
<p>Spring可以将简单的组件配置、组合成为复杂的应用。在Spring中，应用对象被声明式地组合，典型地是在一个XML文件里。Spring也</p>
<p>提供了很多基础功能（事务管理、持久化框架集成等等），将应用逻辑的开发留给了你。所有Spring的这些特征使你能够编写更干净、</p>
<p>更可管理、并且更易于测试的代码。它们也为Spring中的各种模块提供了基础支持。</p>
<h3 id="_91-解释一下什么是aop"> 91.解释一下什么是AOP?</h3>
<p>AOP（Aspect-Oriented Programming，面向方面编程），可以说是OOP（Object-Oriented Programing，面向对象编程）的补充和完善。OOP引入封装、继承和多态性等概念来建立一种对象层次结构，用以模拟公共行为的一个集合。当我们需要为分散的对象引入公共行为的时候，OOP则显得无能为力。也就是说，OOP允许你定义从上到下的关系，但并不适合定义从左到右的关系。例如日志功能。日志代码往往水平地散布在所有对象层次中，而与它所散布到的对象的核心功能毫无关系。对于其他类型的代码，如安全性、异常处理和透明的持续性也是如此。这种散布在各处的无关的代码被称为横切（cross-cutting）代码，在OOP设计中，它导致了大量代码的重复，而不利于各个模块的重用。</p>
<p>而AOP技术则恰恰相反，它利用一种称为“横切”的技术，剖解开封装的对象内部，并将那些影响了多个类的公共行为封装到一个可重用模块，并将其名为“Aspect”，即方面。所谓“方面”，简单地说，就是将那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可操作性和可维护性。AOP代表的是一个横向的关系，如果说“对象”是一个空心的圆柱体，其中封装的是对象的属性和行为；那么面向方面编程的方法，就仿佛一把利刃，将这些空心圆柱体剖开，以获得其内部的消息。而剖开的切面，也就是所谓的“方面”了。然后它又以巧夺天功的妙手将这些剖开的切面复原，不留痕迹。</p>
<p>使用“横切”技术，AOP把软件系统分为两个部分：核心关注点和横切关注点。业务处理的主要流程是核心关注点，与之关系不大的部分是横切关注点。横切关注点的一个特点是，他们经常发生在核心关注点的多处，而各处都基本相似。比如权限认证、日志、事务处理。Aop 的作用在于分离系统中的各种关注点，将核心关注点和横切关注点分离开来。正如Avanade公司的高级方案构架师Adam Magee所说，AOP的核心思想就是“将应用程序中的商业逻辑同对其提供支持的通用服务进行分离。”</p>
<h3 id="_92-解释一下什么是ioc"> 92.解释一下什么是IoC?</h3>
<p>IOC是Inversion of Control的缩写，多数书籍翻译成“控制反转”。</p>
<p>1996年，Michael Mattson在一篇有关探讨面向对象框架的文章中，首先提出了IOC 这个概念。对于面向对象设计及编程的基本思想，前面我们已经讲了很多了，不再赘述，简单来说就是把复杂系统分解成相互合作的对象，这些对象类通过封装以后，内部实现对外部是透明的，从而降低了解决问题的复杂度，而且可以灵活地被重用和扩展。</p>
<p>IOC理论提出的观点大体是这样的：借助于“第三方”实现具有依赖关系的对象之间的解耦。如下图：</p>
<p><img src="./assets/java-05.png" alt=""></p>
<p>大家看到了吧，由于引进了中间位置的“第三方”，也就是IOC容器，使得A、B、C、D这4个对象没有了耦合关系，齿轮之间的传动全部依靠“第三方”了，全部对象的控制权全部上缴给“第三方”IOC容器，所以，IOC容器成了整个系统的关键核心，它起到了一种类似“粘合剂”的作用，把系统中的所有对象粘合在一起发挥作用，如果没有这个“粘合剂”，对象与对象之间会彼此失去联系，这就是有人把IOC容器比喻成“粘合剂”的由来。</p>
<p>我们再来做个试验：把上图中间的IOC容器拿掉，然后再来看看这套系统：</p>
<p><img src="./assets/java-06.png" alt=""></p>
<p>我们现在看到的画面，就是我们要实现整个系统所需要完成的全部内容。这时候，A、B、C、D这4个对象之间已经没有了耦合关系，彼</p>
<p>此毫无联系，这样的话，当你在实现A的时候，根本无须再去考虑B、C和D了，对象之间的依赖关系已经降低到了最低程度。所以，如</p>
<p>果真能实现IOC容器，对于系统开发而言，这将是一件多么美好的事情，参与开发的每一成员只要实现自己的类就可以了，跟别人没有</p>
<p>任何关系！</p>
<p><strong>我们再来看看，控制反转(IOC)到底为什么要起这么个名字？我们来对比一下：</strong></p>
<p>软件系统在没有引入IOC容器之前，如图1所示，对象A依赖于对象B，那么对象A在初始化或者运行到某一点的时候，自己必须主动去创建对象B或者使用已经创建的对象B。无论是创建还是使用对象B，控制权都在自己手上。</p>
<p>软件系统在引入IOC容器之后，这种情形就完全改变了，如图3所示，由于IOC容器的加入，对象A与对象B之间失去了直接联系，所以，当对象A运行到需要对象B的时候，IOC容器会主动创建一个对象B注入到对象A需要的地方。</p>
<p>通过前后的对比，我们不难看出来：对象A获得依赖对象B的过程,由主动行为变为了被动行为，控制权颠倒过来了，这就是“控制反转”这个名称的由来。</p>
<h3 id="_93-spring有哪些主要模块"> 93.Spring有哪些主要模块?</h3>
<p>Spring框架至今已集成了20多个模块。这些模块主要被分如下图所示的核心容器、数据访问/集成,、Web、AOP（面向切面编程）、工</p>
<p>具、消息和测试模块。</p>
<p><img src="./assets/java-07.png" alt=""></p>
<h3 id="_94-spring-常用的注入方式有哪些"> 94.Spring 常用的注入方式有哪些?</h3>
<p>Spring通过DI（依赖注入）实现IOC（控制反转），常用的注入方式主要有三种：</p>
<ol>
<li>构造方法注入</li>
<li>setter注入</li>
<li>基于注解的注入</li>
</ol>
<h3 id="_95-spring-中的-bean是线程安全的吗"> 95.Spring 中的 bean是线程安全的吗?</h3>
<p>Spring容器中的Bean是否线程安全，容器本身并没有提供Bean的线程安全策略，因此可以说spring容器中的Bean本身不具备线程安全</p>
<p>的特性，但是具体还是要结合具体scope的Bean去研究。</p>
<h3 id="_96-spring支持几种bean的作用域"> 96.Spring支持几种bean的作用域?</h3>
<p>当通过spring容器创建一个Bean实例时，不仅可以完成Bean实例的实例化，还可以为Bean指定特定的作用域。Spring支持如下5种作用域：</p>
<ul>
<li>**singleton：**单例模式，在整个Spring IoC容器中，使用singleton定义的Bean将只有一个实例</li>
<li>**prototype：**原型模式，每次通过容器的getBean方法获取prototype定义的Bean时，都将产生一个新的Bean实例</li>
<li>**request：**对于每次HTTP请求，使用request定义的Bean都将产生一个新实例，即每次HTTP请求将会产生不同的Bean实例。只有在Web应用中使用Spring时，该作用域才有效</li>
<li>**session：**对于每次HTTP Session，使用session定义的Bean豆浆产生一个新实例。同样只有在Web应用中使用Spring时，该作用域才有效</li>
<li>**globalsession：**每个全局的HTTP Session，使用session定义的Bean都将产生一个新实例。典型情况下，仅在使用portlet context的时候有效。同样只有在Web应用中使用Spring时，该作用域才有效</li>
</ul>
<p>其中比较常用的是singleton和prototype两种作用域。对于singleton作用域的Bean，每次请求该Bean都将获得相同的实例。容器负责跟踪Bean实例的状态，负责维护Bean实例的生命周期行为；如果一个Bean被设置成prototype作用域，程序每次请求该id的Bean，Spring都会新建一个Bean实例，然后返回给程序。在这种情况下，Spring容器仅仅使用new 关键字创建Bean实例，一旦创建成功，容器不在跟踪实例，也不会维护Bean实例的状态。</p>
<p>如果不指定Bean的作用域，Spring默认使用singleton作用域。Java在创建Java实例时，需要进行内存申请；销毁实例时，需要完成垃圾回收，这些工作都会导致系统开销的增加。因此，prototype作用域Bean的创建、销毁代价比较大。而singleton作用域的Bean实例一旦创建成功，可以重复使用。因此，除非必要，否则尽量避免将Bean被设置成prototype作用域。</p>
<h3 id="_97-spring自动装配bean有哪些方式"> 97.Spring自动装配bean有哪些方式?</h3>
<p>Spring容器负责创建应用程序中的bean同时通过ID来协调这些对象之间的关系。作为开发人员，我们需要告诉Spring要创建哪些bean并且如何将其装配到一起。</p>
<p>spring中bean装配有两种方式：</p>
<ul>
<li>隐式的bean发现机制和自动装配</li>
<li>在java代码或者XML中进行显示配置</li>
</ul>
<p>当然这些方式也可以配合使用。</p>
<h3 id="_98-spring事务实现方式有哪些"> 98.Spring事务实现方式有哪些?</h3>
<ol>
<li>编程式事务管理对基于 POJO 的应用来说是唯一选择。我们需要在代码中调用beginTransaction()、commit()、rollback()等事务管理相关的方法，这就是编程式事务管理。</li>
<li>基于 TransactionProxyFactoryBean 的声明式事务管理</li>
<li>基于 @Transactional 的声明式事务管理</li>
<li>基于 Aspectj AOP 配置事务</li>
</ol>
<h3 id="_99-说一下spring-的事务隔离"> 99.说一下Spring 的事务隔离?</h3>
<p>事务隔离级别指的是一个事务对数据的修改与另一个并行的事务的隔离程度，当多个事务同时访问相同数据时，如果没有采取必要的隔离机制，就可能发生以下问题：</p>
<ul>
<li>脏读：一个事务读到另一个事务未提交的更新数据。</li>
<li>幻读：例如第一个事务对一个表中的数据进行了修改，比如这种修改涉及到表中的“全部数据行”。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入“一行新数据”。那么，以后就会发生操作第一个事务的用户发现表中还存在没有修改的数据行，就好象发生了幻觉一样。</li>
<li>不可重复读：比方说在同一个事务中先后执行两条一模一样的select语句，期间在此次事务中没有执行过任何DDL语句，但先后得到的结果不一致，这就是不可重复读。</li>
</ul>
<h3 id="_100-说一下spring-mvc运行流程"> 100.说一下Spring MVC运行流程?</h3>
<p><strong>Spring MVC运行流程图：</strong></p>
<p><img src="./assets/java-08.png" alt=""></p>
<p><strong>Spring运行流程描述：</strong></p>
<ol>
<li>
<p>用户向服务器发送请求，请求被Spring 前端控制Servelt DispatcherServlet捕获；</p>
</li>
<li>
<p>DispatcherServlet对请求URL进行解析，得到请求资源标识符（URI）。然后根据该URI，调用HandlerMapping获得该Handler配置的所有相关的对象（包括Handler对象以及Handler对象对应的拦截器），最后以HandlerExecutionChain对象的形式返回；</p>
</li>
<li>
<p>DispatcherServlet 根据获得的Handler，选择一个合适的HandlerAdapter；（附注：如果成功获得HandlerAdapter后，此时将开始执行拦截器的preHandler(...)方法）</p>
</li>
<li>
<p>提取Request中的模型数据，填充Handler入参，开始执行Handler（Controller)。 在填充Handler的入参过程中，根据你的配置，Spring将帮你做一些额外的工作：</p>
<ul>
<li>HttpMessageConveter： 将请求消息（如Json、xml等数据）转换成一个对象，将对象转换为指定的响应信息</li>
<li>数据转换：对请求消息进行数据转换。如String转换成Integer、Double等</li>
<li>数据根式化：对请求消息进行数据格式化。 如将字符串转换成格式化数字或格式化日期等</li>
<li>数据验证： 验证数据的有效性（长度、格式等），验证结果存储到BindingResult或Error中</li>
</ul>
</li>
<li>
<p>Handler执行完成后，向DispatcherServlet 返回一个ModelAndView对象；</p>
</li>
<li>
<p>根据返回的ModelAndView，选择一个适合的ViewResolver（必须是已经注册到Spring容器中的ViewResolver)返回给DispatcherServlet ；</p>
</li>
<li>
<p>ViewResolver 结合Model和View，来渲染视图；</p>
</li>
<li>
<p>将渲染结果返回给客户端。</p>
</li>
</ol>
<h3 id="_101-spring-mvc有哪些组件"> 101.Spring MVC有哪些组件?</h3>
<p>Spring MVC的核心组件：</p>
<ol>
<li>DispatcherServlet：中央控制器，把请求给转发到具体的控制类</li>
<li>Controller：具体处理请求的控制器</li>
<li>HandlerMapping：映射处理器，负责映射中央处理器转发给controller时的映射策略</li>
<li>ModelAndView：服务层返回的数据和视图层的封装类</li>
<li>ViewResolver：视图解析器，解析具体的视图</li>
<li>Interceptors ：拦截器，负责拦截我们定义的请求然后做处理工作</li>
</ol>
<h3 id="_102-requestmapping-的作用是什么"> 102.@RequestMapping 的作用是什么?</h3>
<p>RequestMapping是一个用来处理请求地址映射的注解，可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。</p>
<p>RequestMapping注解有六个属性，下面我们把它分成三类进行说明。</p>
<p><strong>value， method：</strong></p>
<ul>
<li>value：指定请求的实际地址，指定的地址可以是URI Template 模式（后面将会说明）；</li>
<li>method：指定请求的method类型， GET、POST、PUT、DELETE等；</li>
</ul>
<p><strong>consumes，produces</strong></p>
<ul>
<li>consumes：指定处理请求的提交内容类型（Content-Type），例如application/json, text/html；</li>
<li>produces：指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回；</li>
</ul>
<p><strong>params，headers</strong></p>
<ul>
<li>params： 指定request中必须包含某些参数值是，才让该方法处理。</li>
<li>headers：指定request中必须包含某些指定的header值，才能让该方法处理请求。</li>
</ul>
<h3 id="_103-autowired的作用是什么"> 103.@Autowired的作用是什么?</h3>
<p>@Autowired 是一个注解，它可以对类成员变量、方法及构造函数进行标注，让 spring 完成 bean 自动装配的工作。</p>
<p>@Autowired 默认是按照类去匹配，配合 @Qualifier 指定按照名称去装配 bean。</p>
<p>常见用法</p>
<div><pre><code><span>import</span> <span>org<span>.</span>springframework<span>.</span>beans<span>.</span>factory<span>.</span>annotation<span>.</span></span><span>Autowired</span><span>;</span>
<span>import</span> <span>org<span>.</span>springframework<span>.</span>stereotype<span>.</span></span><span>Controller</span><span>;</span>
 
<span>import</span> <span>blog<span>.</span>service<span>.</span></span><span>ArticleService</span><span>;</span>
<span>import</span> <span>blog<span>.</span>service<span>.</span></span><span>TagService</span><span>;</span>
<span>import</span> <span>blog<span>.</span>service<span>.</span></span><span>TypeService</span><span>;</span>
 
<span>@Controller</span>
<span>public</span> <span>class</span> <span>TestController</span> <span>{</span>
 
	<span>//成员属性字段使用 @Autowired，无需字段的 set 方法</span>
	<span>@Autowired</span>
	<span>private</span> <span>TypeService</span> typeService<span>;</span>
	
	
	<span>//set 方法使用 @Autowired</span>
	<span>private</span> <span>ArticleService</span> articleService<span>;</span>
	<span>@Autowired</span>
	<span>public</span> <span>void</span> <span>setArticleService</span><span>(</span><span>ArticleService</span> articleService<span>)</span> <span>{</span>
		<span>this</span><span>.</span>articleService <span>=</span> articleService<span>;</span>
	<span>}</span>
 
	<span>//构造方法使用 @Autowired</span>
	<span>private</span> <span>TagService</span> tagService<span>;</span>
	<span>@Autowired</span>
	<span>public</span> <span>TestController</span><span>(</span><span>TagService</span> tagService<span>)</span> <span>{</span>
		<span>this</span><span>.</span>tagService <span>=</span> tagService<span>;</span> 
	<span>}</span>
	
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br></div></div>]]></content>
    <author>
      <name>南辞</name>
    </author>
    <contributor>
      <name>南辞</name>
    </contributor>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">模块11—Spring Boot/Spring Cloud</title>
    <id>http://qiqi.dreamagain.top/interview/Java208/%E6%A8%A1%E5%9D%9711%E2%80%94Spring%20BootSpring%20Cloud/</id>
    <link href="http://qiqi.dreamagain.top/interview/Java208/%E6%A8%A1%E5%9D%9711%E2%80%94Spring%20BootSpring%20Cloud/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<h2 id="问题"> 问题：</h2>
<p>104.什么是Spring Boot?</p>
<p>105.为什么要用Spring Boot?</p>
<p>106.Spring Boot核心配置文件是什么?</p>
<p>107.Spring Boot配置文件有哪几种类型?它们有什么区别?</p>
<p>108.Spring Boot有哪些方式可以实现热部署?</p>
<p>109.jpa和hibernate有什么区别?</p>
<p>110.什么是 Spring Cloud?</p>
<p>111.Spring Cloud 断路器的作用是什么?</p>
<p>112.Spring Cloud的核心组件有哪些?</p>
<h2 id="答案"> 答案：</h2>
<h3 id="_104-什么是spring-boot"> 104.什么是Spring Boot?</h3>
<p>在Spring框架这个大家族中，产生了很多衍生框架，比如 Spring、SpringMvc框架等，Spring的核心内容在于控制反转(IOC)和依赖注入(DI),所谓控制反转并非是一种技术，而是一种思想，在操作方面是指在spring配置文件中创建<bean>，依赖注入即为由spring容器为应用程序的某个对象提供资源，比如 引用对象、常量数据等。</p>
<p>Spring Boot是一个框架，一种全新的编程规范，他的产生简化了框架的使用，所谓简化是指简化了Spring众多框架中所需的大量且繁琐的配置文件，所以 Spring Boot是一个服务于框架的框架，服务范围是简化配置文件。</p>
<h3 id="_105-为什么要用spring-boot"> 105.为什么要用Spring Boot?</h3>
<ul>
<li>Spring Boot使编码变简单</li>
<li>Spring Boot使配置变简单</li>
<li>Spring Boot使部署变简单</li>
<li>Spring Boot使监控变简单</li>
<li>Spring的不足</li>
</ul>
<h3 id="_106-spring-boot核心配置文件是什么"> 106.Spring Boot核心配置文件是什么?</h3>
<p>Spring Boot提供了两种常用的配置文件：</p>
<ul>
<li>properties文件</li>
<li>yml文件</li>
</ul>
<h3 id="_107-spring-boot配置文件有哪几种类型-它们有什么区别"> 107.Spring Boot配置文件有哪几种类型?它们有什么区别?</h3>
<p>Spring Boot提供了两种常用的配置文件，分别是properties文件和yml文件。</p>
<p>相对于properties文件而言，yml文件更年轻，也有很多的坑。可谓成也萧何败萧何，</p>
<p>yml通过空格来确定层级关系，使配置文件结构跟清晰，但也会因为微不足道的空格而破坏了层级关系。</p>
<h3 id="_108-spring-boot有哪些方式可以实现热部署"> 108.Spring Boot有哪些方式可以实现热部署?</h3>
<p>SpringBoot热部署实现有两种方式：</p>
<p><strong>①. 使用spring loaded</strong></p>
<p>在项目的pom.xml中添加如下代码：</p>
<div><pre><code><span><span><span>&lt;</span>build</span><span>></span></span>
    <span><span><span>&lt;</span>plugins</span><span>></span></span>
        <span><span><span>&lt;</span>plugin</span><span>></span></span>
            <span>&lt;!-- Spring Boot编译插件--></span>
            <span><span><span>&lt;</span>groupId</span><span>></span></span>org.springframework.boot<span><span><span>&lt;/</span>groupId</span><span>></span></span>
            <span><span><span>&lt;</span>artifactId</span><span>></span></span>spring-boot-maven-plugin<span><span><span>&lt;/</span>artifactId</span><span>></span></span>
            <span><span><span>&lt;</span>dependencies</span><span>></span></span>
                <span>&lt;!-- Spring热部署 --></span>
                <span>&lt;!-- 该依赖在此处下载不下来，可以放置在build标签外部下载完成后再粘贴进plugin中 --></span>
                <span><span><span>&lt;</span>dependency</span><span>></span></span>
                    <span><span><span>&lt;</span>groupId</span><span>></span></span>org.springframework<span><span><span>&lt;/</span>groupId</span><span>></span></span>
                    <span><span><span>&lt;</span>artifactId</span><span>></span></span>springloaded<span><span><span>&lt;/</span>artifactId</span><span>></span></span>
                    <span><span><span>&lt;</span>version</span><span>></span></span>1.2.6.RELEASE<span><span><span>&lt;/</span>version</span><span>></span></span>
                <span><span><span>&lt;/</span>dependency</span><span>></span></span>
            <span><span><span>&lt;/</span>dependencies</span><span>></span></span>
        <span><span><span>&lt;/</span>plugin</span><span>></span></span>
    <span><span><span>&lt;/</span>plugins</span><span>></span></span>
<span><span><span>&lt;/</span>build</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><p>添加完毕后需要使用mvn指令运行：</p>
<p>首先找到IDEA中的Edit configurations ,然后进行如下操作：（点击左上角的&quot;+&quot;,然后选择maven将出现右侧面板，在红色划线部位输入</p>
<p>如图所示指令，你可以为该指令命名(此处命名为MvnSpringBootRun)）</p>
<img src="./assets/java-09.png" style="zoom:80%;" />
<p>点击保存将会在IDEA项目运行部位出现，点击绿色箭头运行即可</p>
<p><img src="./assets/java-10.png" alt=""></p>
<p><strong>②. 使用spring-boot-devtools</strong></p>
<p>在项目的pom文件中添加依赖：</p>
<div><pre><code><span>&lt;!--热部署jar--></span>
<span><span><span>&lt;</span>dependency</span><span>></span></span>
    <span><span><span>&lt;</span>groupId</span><span>></span></span>org.springframework.boot<span><span><span>&lt;/</span>groupId</span><span>></span></span>
    <span><span><span>&lt;</span>artifactId</span><span>></span></span>spring-boot-devtools<span><span><span>&lt;/</span>artifactId</span><span>></span></span>
<span><span><span>&lt;/</span>dependency</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>然后：使用 shift+ctrl+alt+&quot;/&quot; （IDEA中的快捷键） 选择&quot;Registry&quot; 然后勾选 compiler.automake.allow.when.app.running</p>
<h3 id="_109jpa和hibernate有什么区别"> 109JPA和Hibernate有什么区别?</h3>
<ul>
<li>JPA Java Persistence API，是Java EE 5的标准ORM接口，也是Ejb3规范的一部分。</li>
<li>Hibernate，当今很流行的ORM框架，是JPA的一个实现，但是其功能是JPA的超集。</li>
<li>JPA和Hibernate之间的关系，可以简单的理解为JPA是标准接口，Hibernate是实现。那么Hibernate是如何实现与JPA的这种关系的呢。Hibernate主要是通过三个组件来实现的，及hibernate-annotation、hibernate-entitymanager和hibernate-core。</li>
<li>hibernate-annotation是Hibernate支持annotation方式配置的基础，它包括了标准的JPA annotation以及Hibernate自身特殊功能的annotation。</li>
<li>hibernate-core是Hibernate的核心实现，提供了Hibernate所有的核心功能。</li>
<li>hibernate-entitymanager实现了标准的JPA，可以把它看成hibernate-core和JPA之间的适配器，它并不直接提供ORM的功能，而是对hibernate-core进行封装，使得Hibernate符合JPA的规范。</li>
</ul>
<h3 id="_110-什么是-spring-cloud"> 110.什么是 Spring Cloud?</h3>
<p>从字面理解，Spring Cloud 就是致力于分布式系统、云服务的框架。</p>
<p>Spring Cloud 是整个 Spring 家族中新的成员，是最近云服务火爆的必然产物。</p>
<p>Spring Cloud 为开发人员提供了快速构建分布式系统中一些常见模式的工具，例如：</p>
<ul>
<li>配置管理</li>
<li>服务注册与发现</li>
<li>断路器</li>
<li>智能路由</li>
<li>服务间调用</li>
<li>负载均衡</li>
<li>微代理</li>
<li>控制总线</li>
<li>一次性令牌</li>
<li>全局锁</li>
<li>领导选举</li>
<li>分布式会话</li>
<li>集群状态</li>
<li>分布式消息</li>
<li>……</li>
</ul>
<p>使用 Spring Cloud 开发人员可以开箱即用的实现这些模式的服务和应用程序。这些服务可以任何环境下运行，包括分布式环境，也包括开发人员自己的笔记本电脑以及各种托管平台。</p>
<h3 id="_111-spring-cloud-断路器的作用是什么"> 111.Spring Cloud 断路器的作用是什么?</h3>
<p>在Spring Cloud中使用了Hystrix 来实现断路器的功能，断路器可以防止一个应用程序多次试图执行一个操作，即很可能失败，允许它继续而不等待故障恢复或者浪费 CPU 周期，而它确定该故障是持久的。断路器模式也使应用程序能够检测故障是否已经解决，如果问题似乎已经得到纠正，应用程序可以尝试调用操作。</p>
<p>断路器增加了稳定性和灵活性，以一个系统，提供稳定性，而系统从故障中恢复，并尽量减少此故障的对性能的影响。它可以帮助快速地拒绝对一个操作，即很可能失败，而不是等待操作超时（或者不返回）的请求，以保持系统的响应时间。如果断路器提高每次改变状态的时间的事件，该信息可以被用来监测由断路器保护系统的部件的健康状况，或以提醒管理员当断路器跳闸，以在打开状态。</p>
<h3 id="_112-spring-cloud的核心组件有哪些"> 112.Spring Cloud的核心组件有哪些?</h3>
<p><strong>①. 服务发现——Netflix Eureka</strong></p>
<p>一个RESTful服务，用来定位运行在AWS地区（Region）中的中间层服务。由两个组件组成：Eureka服务器和Eureka客户端。Eureka服务器用作服务注册服务器。Eureka客户端是一个java客户端，用来简化与服务器的交互、作为轮询负载均衡器，并提供服务的故障切换支持。Netflix在其生产环境中使用的是另外的客户端，它提供基于流量、资源利用率以及出错状态的加权负载均衡。</p>
<p><strong>②. 客服端负载均衡——Netflix Ribbon</strong></p>
<p>Ribbon，主要提供客户侧的软件负载均衡算法。Ribbon客户端组件提供一系列完善的配置选项，比如连接超时、重试、重试算法等。Ribbon内置可插拔、可定制的负载均衡组件。</p>
<p><strong>③. 断路器——Netflix Hystrix</strong></p>
<p>断路器可以防止一个应用程序多次试图执行一个操作，即很可能失败，允许它继续而不等待故障恢复或者浪费 CPU 周期，而它确定该故障是持久的。断路器模式也使应用程序能够检测故障是否已经解决。如果问题似乎已经得到纠正，应用程序可以尝试调用操作。</p>
<p><strong>④. 服务网关——Netflix Zuul</strong></p>
<p>类似nginx，反向代理的功能，不过netflix自己增加了一些配合其他组件的特性。</p>
<p><strong>⑤. 分布式配置——Spring Cloud Config</strong></p>
<p>这个还是静态的，得配合Spring Cloud Bus实现动态的配置更新。</p>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <contributor>
      <name>南辞</name>
    </contributor>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">模块12—Hibernate</title>
    <id>http://qiqi.dreamagain.top/interview/Java208/%E6%A8%A1%E5%9D%9712%E2%80%94Hibernate/</id>
    <link href="http://qiqi.dreamagain.top/interview/Java208/%E6%A8%A1%E5%9D%9712%E2%80%94Hibernate/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<h2 id="问题"> 问题：</h2>
<p>113.为什么要使用Hibernate?</p>
<p>114.什么是 ORM框架?</p>
<p>115.Hibernate 中如何在控制台查看打印的sql语句?</p>
<p>116.Hibernate有几种查询方式?</p>
<p>117.Hibernate 实体类可以被定义为final 吗?</p>
<p>118.在Hibernate中使用Integer和int做映射有什么区别?</p>
<p>119.Hibernate是如何工作的?</p>
<p>120.get()和load()的区别?</p>
<p>121.说一下 Hibernate 的缓存机制?</p>
<p>122.Hibernate对象有哪些状态?</p>
<p>123.在 Hibernate 中 getCurrentSession和openSession的区别是什么?</p>
<p>124.Hibernate 实体类必须要有无参构造函数吗?为什么?</p>
<h2 id="答案"> 答案：</h2>
<h3 id="_113-为什么要使用hibernate"> 113.为什么要使用Hibernate?</h3>
<ul>
<li>
<p>对JDBC访问数据库的代码做了封装，大大简化了数据访问层繁琐的重复性代码。</p>
</li>
<li>
<p>Hibernate是一个基于JDBC的主流持久化框架，是一个优秀的ORM实现。他很大程度的简化DAO层的编码工作</p>
</li>
<li>
<p>Hibernate使用Java反射机制，而不是字节码增强程序来实现透明性。</p>
</li>
<li>
<p>Hibernate的性能非常好，因为它是个轻量级框架。映射的灵活性很出色。它支持各种关系数据库，从一对一到多对多的各种复杂关系。</p>
</li>
</ul>
<h3 id="_114-什么是-orm框架"> 114.什么是 ORM框架?</h3>
<p>对象-关系映射（Object-Relational Mapping，简称ORM），面向对象的开发方法是当今企业级应用开发环境中的主流开发方法，关系数据库是企业级应用环境中永久存放数据的主流数据存储系统。</p>
<p>对象和关系数据是业务实体的两种表现形式，业务实体在内存中表现为对象，在数据库中表现为关系数据。内存中的对象之间存在关联和继承关系，而在数据库中，关系数据无法直接表达多对多关联和继承关系。因此，对象-关系映射(ORM)系统一般以中间件的形式存在，主要实现程序对象到关系数据库数据的映射。</p>
<h3 id="_115-hibernate-中如何在控制台查看打印的sql语句"> 115.Hibernate 中如何在控制台查看打印的sql语句?</h3>
<p>参考：blog.csdn.net/Randy_Wang_/article/details/79460306</p>
<h3 id="_116-hibernate有几种查询方式"> 116.Hibernate有几种查询方式?</h3>
<ul>
<li>hql查询</li>
<li>sql查询</li>
<li>条件查询</li>
</ul>
<div><pre><code>
hql查询，sql查询，条件查询

HQL<span>:</span>  <span>Hibernate</span> <span>Query</span> <span>Language</span><span>.</span> 面向对象的写法<span>:</span>
<span>Query</span> query <span>=</span> session<span>.</span><span>createQuery</span><span>(</span><span>"from Customer where name = ?"</span><span>)</span><span>;</span>
query<span>.</span><span>setParameter</span><span>(</span><span>0</span><span>,</span> <span>"苍老师"</span><span>)</span><span>;</span>
<span>Query</span><span>.</span><span>list</span><span>(</span><span>)</span><span>;</span>



QBC<span>:</span>  <span>Query</span> <span>By</span> <span>Criteria</span><span>.</span><span>(</span>条件查询<span>)</span>
<span>Criteria</span> criteria <span>=</span> session<span>.</span><span>createCriteria</span><span>(</span><span>Customer</span><span>.</span><span>class</span><span>)</span><span>;</span>
criteria<span>.</span><span>add</span><span>(</span><span>Restrictions</span><span>.</span><span>eq</span><span>(</span><span>"name"</span><span>,</span> <span>"花姐"</span><span>)</span><span>)</span><span>;</span>
<span>List</span><span><span>&lt;</span><span>Customer</span><span>></span></span> list <span>=</span> criteria<span>.</span><span>list</span><span>(</span><span>)</span><span>;</span>



SQL<span>:</span>
<span>SQLQuery</span> query <span>=</span> session<span>.</span><span>createSQLQuery</span><span>(</span><span>"select * from customer"</span><span>)</span><span>;</span>
<span>List</span><span>&lt;</span><span>Object</span><span>[</span><span>]</span><span>></span> list <span>=</span> query<span>.</span><span>list</span><span>(</span><span>)</span><span>;</span>

<span>SQLQuery</span> query <span>=</span> session<span>.</span><span>createSQLQuery</span><span>(</span><span>"select * from customer"</span><span>)</span><span>;</span>
query<span>.</span><span>addEntity</span><span>(</span><span>Customer</span><span>.</span><span>class</span><span>)</span><span>;</span>
<span>List</span><span><span>&lt;</span><span>Customer</span><span>></span></span> list <span>=</span> query<span>.</span><span>list</span><span>(</span><span>)</span><span>;</span>



<span>Hql</span>： 具体分类
<span>1</span>、 属性查询 <span>2</span>、 参数查询、命名参数查询 <span>3</span>、 关联查询 <span>4</span>、 分页查询 <span>5</span>、 统计函数



HQL和SQL的区别

HQL是面向对象查询操作的，SQL是结构化查询语言 是面向数据库表结构的
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br></div></div><h3 id="_117-hibernate-实体类可以被定义为final-吗"> 117.Hibernate 实体类可以被定义为final 吗?</h3>
<p>可以将Hibernate的实体类定义为final类，但这种做法并不好。因为Hibernate会使用代理模式在延迟关联的情况下提高性能，如果你把</p>
<p>实体类定义成final类之后，因为 Java不允许对final类进行扩展，所以Hibernate就无法再使用代理了，如此一来就限制了使用可以提升</p>
<p>性能的手段。不过，如果你的持久化类实现了一个接口而且在该接口中声明了所有定义于实体类中的所有public的方法轮到话，你就能</p>
<p>够避免出现前面所说的不利后果。</p>
<h3 id="_118-在hibernate中使用integer和int做映射有什么区别"> 118.在Hibernate中使用Integer和int做映射有什么区别?</h3>
<p>在Hibernate中，如果将OID定义为Integer类型，那么Hibernate就可以根据其值是否为null而判断一个对象是否是临时的，如果将OID</p>
<p>定义为了int类型，还需要在hbm映射文件中设置其unsaved-value属性为0。</p>
<h3 id="_119-hibernate是如何工作的"> 119.Hibernate是如何工作的?</h3>
<p>hibernate工作原理：</p>
<ol>
<li>通过Configuration config = new Configuration().configure();//读取并解析hibernate.cfg.xml配置文件</li>
<li>由hibernate.cfg.xml中的<mapping resource="com/xx/User.hbm.xml"/>读取并解析映射信息</li>
<li>通过SessionFactory sf = config.buildSessionFactory();//创建SessionFactory</li>
<li>Session session = sf.openSession();//打开Sesssion</li>
<li>Transaction tx = session.beginTransaction();//创建并启动事务Transation</li>
<li>persistent operate操作数据，持久化操作</li>
<li>tx.commit();//提交事务</li>
<li>关闭Session</li>
<li>关闭SesstionFactory</li>
</ol>
<h3 id="_120-get-和load-的区别"> 120.get()和load()的区别?</h3>
<ul>
<li>load() 没有使用对象的其他属性的时候，没有SQL  延迟加载</li>
<li>get() 没有使用对象的其他属性的时候，也生成了SQL  立即加载</li>
</ul>
<h3 id="_121-说一下-hibernate-的缓存机制"> 121.说一下 Hibernate 的缓存机制?</h3>
<p>Hibernate中的缓存分为一级缓存和二级缓存。</p>
<p>一级缓存就是 Session 级别的缓存，在事务范围内有效是,内置的不能被卸载。二级缓存是 SesionFactory级别的缓存，从应用启动到应用结束有效。是可选的，默认没有二级缓存，需要手动开启。保存数据库后，缓存在内存中保存一份，如果更新了数据库就要同步更新。</p>
<p>什么样的数据适合存放到第二级缓存中？</p>
<ul>
<li>很少被修改的数据  帖子的最后回复时间</li>
<li>经常被查询的数据  电商的地点</li>
<li>不是很重要的数据，允许出现偶尔并发的数据</li>
<li>不会被并发访问的数据</li>
<li>常量数据</li>
</ul>
<p>**扩展：**Hibernate的二级缓存默认是不支持分布式缓存的。使用 memcahe,redis等中央缓存来代替二级缓存。</p>
<h3 id="_122-hibernate对象有哪些状态"> 122.Hibernate对象有哪些状态?</h3>
<p>Hibernate里对象有三种状态：</p>
<ol>
<li>Transient（瞬时）：对象刚new出来，还没设id，设了其他值。</li>
<li>Persistent（持久）：调用了save()、saveOrUpdate()，就变成Persistent，有id。</li>
<li>Detached（脱管）：当session  close()完之后，变成Detached。</li>
</ol>
<p><img src="C:%5CUsers%5CMr%20Yang%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210110165420322.png" alt="image-20210110165420322"></p>
<h3 id="_123-在-hibernate-中-getcurrentsession和opensession的区别是什么"> 123.在 Hibernate 中 getCurrentSession和openSession的区别是什么?</h3>
<p>openSession 从字面上可以看得出来，是打开一个新的session对象，而且每次使用都是打开一个新的session，假如连续使用多次，则获得的session不是同一个对象，并且使用完需要调用close方法关闭session。</p>
<p>getCurrentSession ，从字面上可以看得出来，是获取当前上下文一个session对象，当第一次使用此方法时，会自动产生一个session对象，并且连续使用多次时，得到的session都是同一个对象，这就是与openSession的区别之一，简单而言，getCurrentSession 就是：如果有已经使用的，用旧的，如果没有，建新的。</p>
<p>注意：在实际开发中，往往使用getCurrentSession多，因为一般是处理同一个事务（即是使用一个数据库的情况），所以在一般情况下比较少使用openSession或者说openSession是比较老旧的一套接口了。</p>
<h3 id="_124-hibernate-实体类必须要有无参构造函数吗-为什么"> 124.Hibernate 实体类必须要有无参构造函数吗?为什么?</h3>
<p>必须，因为hibernate框架会调用这个默认构造方法来构造实例对象，即Class类的newInstance方法，这个方法就是通过调用默认构造方法来创建实例对象的。</p>
<p>另外再提醒一点，如果你没有提供任何构造方法，虚拟机会自动提供默认构造方法（无参构造器），但是如果你提供了其他有参数的构造方法的话，虚拟机就不再为你提供默认构造方法，这时必须手动把无参构造器写在代码里，否则new Xxxx()是会报错的，所以默认的构造方法不是必须的，只在有多个构造方法时才是必须的，这里“必须”指的是“必须手动写出来”。</p>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <contributor>
      <name>南辞</name>
    </contributor>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">模块13—MyBatis</title>
    <id>http://qiqi.dreamagain.top/interview/Java208/%E6%A8%A1%E5%9D%9713%E2%80%94MyBatis/</id>
    <link href="http://qiqi.dreamagain.top/interview/Java208/%E6%A8%A1%E5%9D%9713%E2%80%94MyBatis/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<h2 id="问题"> 问题：</h2>
<p>125.MyBatis 中#{和$0的区别是什么?</p>
<p>126.MyBatis有几种分页方式?</p>
<p>127.RowBounds是一次性查询全部结果吗?为什么?</p>
<p>128.MyBatis逻辑分页和物理分页的区别是什么?</p>
<p>129.MyBatis 是否支持延迟加载?延迟加载的原理是什么?</p>
<p>130.说一下MyBatis的一级缓存和二级缓存?</p>
<p>131.MyBatis 和 hibernate的区别有哪些?</p>
<p>132.MyBatis有哪些执行器(Executor) ?</p>
<p>133.MyBatis分页插件的实现原理是什么?</p>
<p>134.MyBatis 如何编写一个自定义插件?</p>
<h2 id="答案"> 答案：</h2>
<h3 id="_125-mybatis-中-和-的区别是什么"> 125.MyBatis 中#{}和${}的区别是什么?</h3>
<ul>
<li>#{}是预编译处理，${}是字符串替换；</li>
<li>MyBatis在处理#{}时，会将sql中的#{}替换为?号，调用PreparedStatement的set方法来赋值；</li>
<li>MyBatis在处理<span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:0.68333em;vertical-align:0em;"></span><span></span><span>时</span><span>，</span><span>就</span><span>是</span><span>把</span></span></span></span>{}替换成变量的值；</li>
<li>使用**#{}可以有效的防止SQL注入**，提高系统安全性。</li>
</ul>
<h3 id="_126-mybatis有几种分页方式"> 126.MyBatis有几种分页方式?</h3>
<ol>
<li>数组分页</li>
<li>sql分页</li>
<li>拦截器分页</li>
<li>RowBounds分页</li>
</ol>
<h3 id="_127-rowbounds是一次性查询全部结果吗-为什么"> 127.RowBounds是一次性查询全部结果吗?为什么?</h3>
<p>RowBounds 表面是在“所有”数据中检索数据，其实并非是一次性查询出所有数据，因为 MyBatis 是对 jdbc 的封装，在 jdbc 驱动中有</p>
<p>一个 Fetch Size 的配置，它规定了每次最多从数据库查询多少条数据，假如你要查询更多数据，它会在你执行 next()的时候，去查询更</p>
<p>多的数据。就好比你去自动取款机取 10000 元，但取款机每次最多能取 2500 元，所以你要取 4 次才能把钱取完。只是对于 jdbc 来</p>
<p>说，当你调用 next()的时候会自动帮你完成查询工作。这样做的好处可以有效的防止内存溢出。</p>
<p>Fetch Size 官方相关文档：http://t. cn/EfSE2g3</p>
<h3 id="_128-mybatis逻辑分页和物理分页的区别是什么"> 128.MyBatis逻辑分页和物理分页的区别是什么?</h3>
<ul>
<li>物理分页速度上并不一定快于逻辑分页，逻辑分页速度上也并不一定快于物理分页。</li>
<li>物理分页总是优于逻辑分页：没有必要将属于数据库端的压力加诸到应用端来，就算速度上存在优势,然而其它性能上的优点足以弥补这个缺点。</li>
</ul>
<h3 id="_129-mybatis-是否支持延迟加载-延迟加载的原理是什么"> 129.MyBatis 是否支持延迟加载?延迟加载的原理是什么?</h3>
<p>MyBatis仅支持association关联对象和collection关联集合对象的延迟加载，association指的就是一对一，collection指的就是一对多查</p>
<p>询。在MyBatis配置文件中，可以配置是否启用延迟加载lazyLoadingEnabled=true|false。</p>
<p>它的<strong>原理是：</strong></p>
<ol>
<li>使用<strong>CGLIB</strong>创建目标对象的<strong>代理对象</strong>，当调用目标方法时，进入拦截器方法，比如调用a.getB().getName()，</li>
<li>拦截器invoke()方法发现a.getB()是null值，那么就会单独发送事先保存好的查询关联B对象的sql，把B查询上来，然后调用a.setB(b)，于是a的对象b属性就有值了，</li>
<li>接着完成a.getB().getName()方法的调用。这就是延迟加载的基本原理。</li>
</ol>
<p>当然了，不光是MyBatis，几乎所有的包括Hibernate，支持延迟加载的原理都是一样的。</p>
<h3 id="_130-说一下mybatis的一级缓存和二级缓存"> 130.说一下MyBatis的一级缓存和二级缓存?</h3>
<p><strong>一级缓存:</strong> 基于 PerpetualCache 的 HashMap 本地缓存，其存储作用域为 Session，当 Session flush 或 close 之后，该 Session 中的所有 Cache 就将清空，默认打开一级缓存。</p>
<p>二级缓存与一级缓存其机制相同，默认也是采用 PerpetualCache，HashMap 存储，不同在于其存储作用域为 Mapper(Namespace)，并且可自定义存储源，如 Ehcache。默认不打开二级缓存，要开启二级缓存，使用二级缓存属性类需要实现Serializable序列化接口(可用来保存对象的状态),可在它的映射文件中配置<cache/> ；</p>
<p>对于缓存数据更新机制，当某一个作用域(一级缓存 Session/二级缓存Namespaces)的进行了C/U/D 操作后，默认该作用域下所有 select 中的缓存将被 clear。</p>
<h3 id="_131-mybatis-和-hibernate的区别有哪些"> 131.MyBatis 和 Hibernate的区别有哪些?</h3>
<p>（1）Mybatis和hibernate不同，它不完全是一个ORM框架，因为MyBatis需要程序员自己编写Sql语句。</p>
<p>（2）Mybatis直接编写原生态sql，可以严格控制sql执行性能，灵活度高，非常适合对关系数据模型要求不高的软件开发，因为这类软</p>
<p>件需求变化频繁，一但需求变化要求迅速输出成果。但是灵活的前提是mybatis无法做到数据库无关性，如果需要实现支持多种数据库</p>
<p>的软件，则需要自定义多套sql映射文件，工作量大。</p>
<p>（3）Hibernate对象/关系映射能力强，数据库无关性好，对于关系模型要求高的软件，如果用Hibernate开发可以节省很多代码，提高</p>
<p>效率。</p>
<h3 id="_132-mybatis有哪些执行器-executor"> 132.MyBatis有哪些执行器(Executor) ?</h3>
<p><strong>Mybatis有三种基本的执行器（Executor）：</strong></p>
<ol>
<li><strong>SimpleExecutor</strong>：每执行一次update或select，就开启一个Statement对象，用完立刻关闭Statement对象。</li>
<li><strong>ReuseExecutor</strong>：执行update或select，以sql作为key查找Statement对象，存在就使用，不存在就创建，用完后，不关闭Statement对象，而是放置于Map内，供下一次使用。简言之，就是重复使用Statement对象。</li>
<li><strong>BatchExecutor</strong>：执行update（没有select，JDBC批处理不支持select），将所有sql都添加到批处理中（addBatch()），等待统一执行（executeBatch()），它缓存了多个Statement对象，每个Statement对象都是addBatch()完毕后，等待逐一执行executeBatch()批处理。与JDBC批处理相同。</li>
</ol>
<h3 id="_133-mybatis分页插件的实现原理是什么"> 133.MyBatis分页插件的实现原理是什么?</h3>
<p>分页插件的基本原理是使用Mybatis提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的sql，然后重写sql，根据</p>
<p>dialect方言，添加对应的物理分页语句和物理分页参数。</p>
<h3 id="_134-mybatis-如何编写一个自定义插件"> 134.MyBatis 如何编写一个自定义插件?</h3>
<p>转自：blog.csdn.net/qq_30051265/article/details/80266434</p>
<p>Mybatis自定义插件针对MyBatis四大对象（Executor、StatementHandler 、ParameterHandler 、ResultSetHandler ）进行拦截，具体拦截方式为：</p>
<ul>
<li>Executor：拦截执行器的方法(log记录)</li>
<li>StatementHandler ：拦截Sql语法构建的处理</li>
<li>ParameterHandler ：拦截参数的处理</li>
<li>ResultSetHandler ：拦截结果集的处理</li>
</ul>
<p>Mybatis自定义插件必须实现Interceptor接口：</p>
<div><pre><code>
<span>public</span> <span>interface</span> <span>Interceptor</span> <span>{</span>
    <span>Object</span> <span>intercept</span><span>(</span><span>Invocation</span> invocation<span>)</span> <span>throws</span> <span>Throwable</span><span>;</span>
    <span>Object</span> <span>plugin</span><span>(</span><span>Object</span> target<span>)</span><span>;</span>
    <span>void</span> <span>setProperties</span><span>(</span><span>Properties</span> properties<span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>intercept方法：拦截器具体处理逻辑方法</p>
<p>plugin方法：根据签名signatureMap生成动态代理对象</p>
<p>setProperties方法：设置Properties属性</p>
<p>自定义插件demo：</p>
<div><pre><code>
<span>// ExamplePlugin.java</span>
<span>@Intercepts</span><span>(</span><span>{</span><span>@Signature</span><span>(</span>
  type<span>=</span> <span>Executor</span><span>.</span><span>class</span><span>,</span>
  method <span>=</span> <span>"update"</span><span>,</span>
  args <span>=</span> <span>{</span><span>MappedStatement</span><span>.</span><span>class</span><span>,</span><span>Object</span><span>.</span><span>class</span><span>}</span><span>)</span><span>}</span><span>)</span>
<span>public</span> <span>class</span> <span>ExamplePlugin</span> <span>implements</span> <span>Interceptor</span> <span>{</span>
  <span>public</span> <span>Object</span> <span>intercept</span><span>(</span><span>Invocation</span> invocation<span>)</span> <span>throws</span> <span>Throwable</span> <span>{</span>
  <span>Object</span> target <span>=</span> invocation<span>.</span><span>getTarget</span><span>(</span><span>)</span><span>;</span> <span>//被代理对象</span>
  <span>Method</span> method <span>=</span> invocation<span>.</span><span>getMethod</span><span>(</span><span>)</span><span>;</span> <span>//代理方法</span>
  <span>Object</span><span>[</span><span>]</span> args <span>=</span> invocation<span>.</span><span>getArgs</span><span>(</span><span>)</span><span>;</span> <span>//方法参数</span>
  <span>// do something ...... 方法拦截前执行代码块</span>
  <span>Object</span> result <span>=</span> invocation<span>.</span><span>proceed</span><span>(</span><span>)</span><span>;</span>
  <span>// do something .......方法拦截后执行代码块</span>
  <span>return</span> result<span>;</span>
  <span>}</span>
  <span>public</span> <span>Object</span> <span>plugin</span><span>(</span><span>Object</span> target<span>)</span> <span>{</span>
    <span>return</span> <span>Plugin</span><span>.</span><span>wrap</span><span>(</span>target<span>,</span> <span>this</span><span>)</span><span>;</span>
  <span>}</span>
  <span>public</span> <span>void</span> <span>setProperties</span><span>(</span><span>Properties</span> properties<span>)</span> <span>{</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><p>一个@Intercepts可以配置多个@Signature，@Signature中的参数定义如下：</p>
<ul>
<li>type：表示拦截的类，这里是Executor的实现类；</li>
<li>method：表示拦截的方法，这里是拦截Executor的update方法；</li>
<li>args：表示方法参数。</li>
</ul>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <contributor>
      <name>南辞</name>
    </contributor>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">模块14—RabbitMQ</title>
    <id>http://qiqi.dreamagain.top/interview/Java208/%E6%A8%A1%E5%9D%9714%E2%80%94RabbitMQ/</id>
    <link href="http://qiqi.dreamagain.top/interview/Java208/%E6%A8%A1%E5%9D%9714%E2%80%94RabbitMQ/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<h2 id="问题"> 问题：</h2>
<p>135.RabbitMQ的使用场景有哪些?</p>
<p>136.RabbitMQ有哪些重要的角色?</p>
<p>137.RabbitMQ有哪些重要的组件?</p>
<p>138.RabbitMQ中 vhost的作用是什么?</p>
<p>139.RabbitMQ的消息是怎么发送的?</p>
<p>140.RabbitMQ怎么保证消息的稳定性?</p>
<p>141.RabbitMQ怎么避免消息丢失?</p>
<p>142.要保证消息持久化成功的条件有哪些?</p>
<p>143.RabbitMQ持久化有什么缺点?</p>
<p>144.RabbitMQ有几种广播类型?</p>
<p>145.RabbitMQ怎么实现延迟消息队列?</p>
<p>146.RabbitMQ集群有什么用?</p>
<p>147.RabbitMQ节点的类型有哪些?</p>
<p>148.RabbitMQ集群搭建需要注意哪些问题?</p>
<p>149.RabbitMQ每个节点是其他节点的完整拷贝吗?为什么?</p>
<p>150.RabbitMQ集群中唯—一个磁盘节点崩溃了会发生什么情况?</p>
<h2 id="答案"> 答案：</h2>
<h3 id="_135-rabbitmq的使用场景有哪些"> 135.RabbitMQ的使用场景有哪些?</h3>
<h3 id="_136-rabbitmq有哪些重要的角色"> 136.RabbitMQ有哪些重要的角色?</h3>
<h3 id="_137-rabbitmq有哪些重要的组件"> 137.RabbitMQ有哪些重要的组件?</h3>
<h3 id="_138-rabbitmq中-vhost的作用是什么"> 138.RabbitMQ中 vhost的作用是什么?</h3>
<h3 id="_139-rabbitmq的消息是怎么发送的"> 139.RabbitMQ的消息是怎么发送的?</h3>
<h3 id="_140-rabbitmq怎么保证消息的稳定性"> 140.RabbitMQ怎么保证消息的稳定性?</h3>
<h3 id="_141-rabbitmq怎么避免消息丢失"> 141.RabbitMQ怎么避免消息丢失?</h3>
<h3 id="_142-要保证消息持久化成功的条件有哪些"> 142.要保证消息持久化成功的条件有哪些?</h3>
<h3 id="_143-rabbitmq持久化有什么缺点"> 143.RabbitMQ持久化有什么缺点?</h3>
<h3 id="_144-rabbitmq有几种广播类型"> 144.RabbitMQ有几种广播类型?</h3>
<h3 id="_145-rabbitmq怎么实现延迟消息队列"> 145.RabbitMQ怎么实现延迟消息队列?</h3>
<h3 id="_146-rabbitmq集群有什么用"> 146.RabbitMQ集群有什么用?</h3>
<h3 id="_147-rabbitmq节点的类型有哪些"> 147.RabbitMQ节点的类型有哪些?</h3>
<h3 id="_148-rabbitmq集群搭建需要注意哪些问题"> 148.RabbitMQ集群搭建需要注意哪些问题?</h3>
<h3 id="_149-rabbitmq每个节点是其他节点的完整拷贝吗-为什么"> 149.RabbitMQ每个节点是其他节点的完整拷贝吗?为什么?</h3>
<h3 id="_150-rabbitmq集群中唯-一个磁盘节点崩溃了会发生什么情况"> 150.RabbitMQ集群中唯—一个磁盘节点崩溃了会发生什么情况?</h3>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <contributor>
      <name>南辞</name>
    </contributor>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">模块15—Kafka</title>
    <id>http://qiqi.dreamagain.top/interview/Java208/%E6%A8%A1%E5%9D%9715%E2%80%94Kafka/</id>
    <link href="http://qiqi.dreamagain.top/interview/Java208/%E6%A8%A1%E5%9D%9715%E2%80%94Kafka/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<h2 id="问题"> 问题：</h2>
<p>152.kafka可以脱离zookeeper单独使用吗?为什么?</p>
<p>153.kafka有几种数据保留的策略?</p>
<p>154.kafka同时设置了7天和10G清除数据，到第五天的时候消息达到了10G，这个时候 kafka将如何处理?</p>
<p>155.什么情况会导致kafka运行变慢?</p>
<p>156.使用kafka集群需要注意什么?</p>
<h2 id="答案"> 答案：</h2>
<h3 id="_152-kafka可以脱离zookeeper单独使用吗-为什么"> 152.kafka可以脱离zookeeper单独使用吗?为什么?</h3>
<h3 id="_153-kafka有几种数据保留的策略"> 153.kafka有几种数据保留的策略?</h3>
<h3 id="_154-kafka同时设置了7天和10g清除数据-到第五天的时候消息达到了10g-这个时候-kafka将如何处理"> 154.kafka同时设置了7天和10G清除数据，到第五天的时候消息达到了10G，这个时候 kafka将如何处理?</h3>
<h3 id="_155-什么情况会导致kafka运行变慢"> 155.什么情况会导致kafka运行变慢?</h3>
<h3 id="_156-使用kafka集群需要注意什么"> 156.使用kafka集群需要注意什么?</h3>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <contributor>
      <name>南辞</name>
    </contributor>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">模块17—MySQL</title>
    <id>http://qiqi.dreamagain.top/interview/Java208/%E6%A8%A1%E5%9D%9717%E2%80%94MySQL/</id>
    <link href="http://qiqi.dreamagain.top/interview/Java208/%E6%A8%A1%E5%9D%9717%E2%80%94MySQL/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<h2 id="问题"> 问题：</h2>
<p>164.数据库的三范式是什么?</p>
<p>165.一张自增表里面总共有17条数据，删除了最后⒉条数据，重启 MySQL数据库，又插入了一条数据，此时id是几?</p>
<p>166.如何获取当前数据库版本?</p>
<p>167.说一下ACID是什么?</p>
<p>168.char和varchar 的区别是什么?</p>
<p>169.float和double的区别是什么?</p>
<p>170.MySQL 的内连接、左连接、右连接有什么区别?</p>
<p>171.MySQL索引是怎么实现的?</p>
<p>172.怎么验证 MySQL的索引是否满足需求?</p>
<p>173.说一下数据库的事务隔离?</p>
<p>174.说一下MySQL常用的引擎?</p>
<p>175.说一下MySQL的行锁和表锁?</p>
<p>176.说一下乐观锁和悲观锁?</p>
<p>177.MySQL问题排查都有哪些手段?</p>
<p>178.如何做MySQL的性能优化?</p>
<h2 id="答案"> 答案:</h2>
<h3 id="_164-数据库的三范式是什么"> 164.数据库的三范式是什么?</h3>
<ul>
<li>第一范式：强调的是列的原子性，即数据库表的每一列都是不可分割的原子数据项。</li>
<li>第二范式：要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性。</li>
<li>第三范式：任何非主属性不依赖于其它非主属性。</li>
</ul>
<h3 id="_165-一张自增表里面总共有17条数据-删除了最后2-条数据-重启-mysql数据库-又插入了一条数据-此时id是几"> 165.一张自增表里面总共有17条数据，删除了最后⒉条数据，重启 MySQL数据库，又插入了一条数据，此时id是几?</h3>
<ul>
<li>表类型如果是 MyISAM ，那 id 就是 18。</li>
<li>表类型如果是 InnoDB，那 id 就是 15。</li>
</ul>
<p>InnoDB 表只会把自增主键的最大 id 记录在内存中，所以重启之后会导致最大 id 丢失。</p>
<h3 id="_166-如何获取当前数据库版本"> 166.如何获取当前数据库版本?</h3>
<p>使用 select version() 获取当前 MySQL 数据库版本。</p>
<h3 id="_167-说一下acid是什么"> 167.说一下ACID是什么?</h3>
<ul>
<li>Atomicity（原子性）：一个事务（transaction）中的所有操作，或者全部完成，或者全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被恢复（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。即，事务不可分割、不可约简。</li>
<li>Consistency（一致性）：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设约束、触发器、级联回滚等。</li>
<li>Isolation（隔离性）：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。</li>
<li>Durability（持久性）：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</li>
</ul>
<h3 id="_168-char和varchar-的区别是什么"> 168.char和varchar 的区别是什么?</h3>
<p>char(n) ：固定长度类型，比如订阅 char(10)，当你输入&quot;abc&quot;三个字符的时候，它们占的空间还是 10 个字节，其他 7 个是空字节。</p>
<p>char 优点：效率高；缺点：占用空间；适用场景：存储密码的 md5 值，固定长度的，使用 char 非常合适。</p>
<p>varchar(n) ：可变长度，存储的值是每个值占用的字节再加上一个用来记录其长度的字节的长度。</p>
<p>所以，从空间上考虑 varchar 比较合适；从效率上考虑 char 比较合适，二者使用需要权衡。</p>
<h3 id="_169-float和double的区别是什么"> 169.float和double的区别是什么?</h3>
<p><strong>1、变量类型不同</strong></p>
<p>float属于单精度型浮点数据。</p>
<p>double属于双精度型浮点数据。</p>
<p><img src="./assets/java-11.png" alt=""></p>
<p>一个浮点数由三部分组成：符号位S、指数部分E（阶码）以及尾数部分M。</p>
<ul>
<li>
<p>单精度浮点数(float)总共用32位来表示浮点数，其中尾数用23位存储，加上小数点前有一位隐藏的1(IEEE754规约数表示法)，2^(23+1) = 16777216。因为 10^7 &lt; 16777216 &lt; 10^8，所以说单精度浮点数的有效位数是7位。考虑到第7位可能的四舍五入问题，所以单精度最少有6位有效数字（最小尺寸）。</p>
</li>
<li>
<p>同样地：双精度浮点数(double)总共用64位来表示浮点数，其中尾数用52位存储，   2^(52+1) = 9007199254740992，10^16 &lt; 9007199254740992 &lt; 10^17，所以双精度的有效位数是16位。同样四舍五入，最少15位。</p>
</li>
</ul>
<p><strong>2、指数范围不同</strong></p>
<p>float的指数范围为-127~128。</p>
<p>double而double的指数范围为-1023~1024</p>
<p><strong>3、表达式指数位不同</strong></p>
<p>float的表达式为1bit（符号位）+8bits（指数位）+23bits（尾数位）</p>
<p>double的表达式为1bit（符号位）+ 11bits（指数位）+ 52bits（尾数位）</p>
<p><strong>4、占用内存空间不同</strong></p>
<p>float占4个字节（32位）内存空间，其数值范围为3.4E-38～3.4E+38。</p>
<p>double占8 个字节（64位）内存空间，其数值范围为1.7E-308～1.7E+308。</p>
<p><strong>5、有效位数不同</strong></p>
<p>单精度浮点数的有效位数是7位。</p>
<p>双精度浮点数的有效位数是16位。</p>
<p>单精度最少有6位有效数字（最小尺寸）。</p>
<p>双精度的有效位数最少15位</p>
<h3 id="_170-mysql-的内连接、左连接、右连接有什么区别"> 170.MySQL 的内连接、左连接、右连接有什么区别?</h3>
<p>内连接关键字：inner join；左连接：left join；右连接：right join。</p>
<p>内连接是把匹配的关联数据显示出来；左连接是左边的表全部显示出来，右边的表显示出符合条件的数据；右连接正好相反。</p>
<h3 id="_171-mysql索引是怎么实现的"> 171.MySQL索引是怎么实现的?</h3>
<p>索引是满足某种特定查找算法的数据结构，而这些数据结构会以某种方式指向数据，从而实现高效查找数据。</p>
<p>具体来说 MySQL 中的索引，不同的数据引擎实现有所不同，但目前主流的数据库引擎的索引都是 B+ 树实现的，B+ 树的搜索效率，可</p>
<p>以到达二分法的性能，找到数据区域之后就找到了完整的数据结构了，所以性能也是更好的。</p>
<h3 id="_172-怎么验证-mysql的索引是否满足需求"> 172.怎么验证 MySQL的索引是否满足需求?</h3>
<p>使用 explain 查看 SQL 是如何执行查询语句的，从而分析你的索引是否满足需求。</p>
<p>explain 语法：explain select * from table where type=1。</p>
<h3 id="_173-说一下数据库的事务隔离"> 173.说一下数据库的事务隔离?</h3>
<p>MySQL 的事务隔离是在 MySQL. ini 配置文件里添加的，在文件的最后添加：transaction-isolation = REPEATABLE-READ</p>
<p>可用的配置值：READ-UNCOMMITTED、READ-COMMITTED、REPEATABLE-READ、SERIALIZABLE。</p>
<ul>
<li>READ-UNCOMMITTED：未提交读，最低隔离级别、事务未提交前，就可被其他事务读取（会出现幻读、脏读、不可重复读）。</li>
<li>READ-COMMITTED：提交读，一个事务提交后才能被其他事务读取到（会造成幻读、不可重复读）。</li>
<li>REPEATABLE-READ：可重复读，默认级别，保证多次读取同一个数据时，其值都和事务开始时候的内容是一致，禁止读取到别的事务未提交的数据（会造成幻读）。</li>
<li>SERIALIZABLE：序列化，代价最高最可靠的隔离级别，该隔离级别能防止脏读、不可重复读、幻读。</li>
</ul>
<p>**脏读 ：**表示一个事务能够读取另一个事务中还未提交的数据。比如，某个事务尝试插入记录 A，此时该事务还未提交，然后另一个事</p>
<p>务尝试读取到了记录 A。</p>
<p>**不可重复读 ：**是指在一个事务内，多次读同一数据。</p>
<p>**幻读 ：**指同一个事务内多次查询返回的结果集不一样。比如同一个事务 A 第一次查询时候有 n 条记录，但是第二次同等条件下查询却</p>
<p>有 n+1 条记录，这就好像产生了幻觉。发生幻读的原因也是另外一个事务新增或者删除或者修改了第一个事务结果集里面的数据，同一</p>
<p>个记录的数据内容被修改了，所有数据行的记录就变多或者变少了。</p>
<h3 id="_174-说一下mysql常用的引擎"> 174.说一下MySQL常用的引擎?</h3>
<p>InnoDB 引擎：InnoDB 引擎提供了对数据库 ACID 事务的支持，并且还提供了行级锁和外键的约束，它的设计的目标就是处理大数据容量的数据库系统。MySQL 运行的时候，InnoDB 会在内存中建立缓冲池，用于缓冲数据和索引。但是该引擎是不支持全文搜索，同时启动也比较的慢，它是不<strong>会保存表的行数</strong>的，所以当进行 select count(*) from table 指令的时候，<strong>需要进行扫描全表</strong>。由于<strong>锁的粒度小，写操作是不会锁定全表的,所以在并发度较高的场景下使用会提升效率的。</strong></p>
<p>MyIASM 引擎：MySQL 的默认引擎，但不提供事务的支持，也不支持行级锁和外键。因此当执行插入和更新语句时，即执行写操作的时候需要锁定这个表，所以会导致效率会降低。不过和 InnoDB 不同的是，MyIASM 引擎是<strong>保存了表的行数</strong>，于是当进行 select count(*) from table 语句时，可以直接的读取已经保存的值而<strong>不需要进行扫描全表</strong>。所以，如果<strong>表的读操作远远多于写操作时，并且不需要事务的支持的，可以将 MyIASM 作为数据库引擎的首选。</strong></p>
<h3 id="_175-说一下mysql的行锁和表锁"> 175.说一下MySQL的行锁和表锁?</h3>
<p>MyISAM 只支持表锁，InnoDB 支持表锁和行锁，默认为行锁。</p>
<ul>
<li>表级锁：开销小，加锁快，不会出现死锁。锁粒度大，发生锁冲突的概率最高，并发量最低。</li>
<li>行级锁：开销大，加锁慢，会出现死锁。锁粒度小，发生锁冲突的概率小，并发度最高。</li>
</ul>
<h3 id="_176-说一下乐观锁和悲观锁"> 176.说一下乐观锁和悲观锁?</h3>
<ul>
<li>乐观锁：每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在提交更新的时候会判断一下在此期间别人有没有去更新这个数据。</li>
<li>悲观锁：每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻止，直到这个锁被释放。</li>
</ul>
<p>数据库的乐观锁需要自己实现，在表里面添加一个 version 字段，每次修改成功值加 1，这样每次修改的时候先对比一下，自己拥有的</p>
<p>version 和数据库现在的 version 是否一致，如果不一致就不修改，这样就实现了乐观锁。</p>
<h3 id="_177-mysql问题排查都有哪些手段"> 177.MySQL问题排查都有哪些手段?</h3>
<ul>
<li>使用 show processlist 命令查看当前所有连接信息。</li>
<li>使用 explain 命令查询 SQL 语句执行计划。</li>
<li>开启慢查询日志，查看慢查询的 SQL。</li>
</ul>
<h3 id="_178-如何做mysql的性能优化"> 178.如何做MySQL的性能优化?</h3>
<ul>
<li>为搜索字段创建索引。</li>
<li>避免使用 select *，列出需要查询的字段。</li>
<li>垂直分割分表。</li>
<li>选择正确的存储引擎。</li>
</ul>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <contributor>
      <name>南辞</name>
    </contributor>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">模块18—Redis</title>
    <id>http://qiqi.dreamagain.top/interview/Java208/%E6%A8%A1%E5%9D%9718%E2%80%94Redis/</id>
    <link href="http://qiqi.dreamagain.top/interview/Java208/%E6%A8%A1%E5%9D%9718%E2%80%94Redis/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<h2 id="问题"> 问题：</h2>
<p>179.redis是什么?都有哪些使用场景?</p>
<p>180.redis有哪些功能?</p>
<p>181.redis和 memecache有什么区别?</p>
<p>182.redis为什么是单线程的?</p>
<p>183.什么是缓存穿透?怎么解决?</p>
<p>184.redis支持的数据类型有哪些?</p>
<p>185.redis支持的java客户端都有哪些?</p>
<p>186.jedis和redisson有哪些区别?</p>
<p>187.怎么保证缓存和数据库数据的一致性?</p>
<p>188.redis持久化有几种方式?</p>
<p>189.redis 怎么实现分布式锁?</p>
<p>190.redis分布式锁有什么缺陷?</p>
<p>191.redis如何做内存优化?</p>
<p>192.redis淘汰策略有哪些?</p>
<p>193.redis 常见的性能问题有哪些?该如何解决?</p>
<h2 id="答案"> 答案：</h2>
<h3 id="_179-redis是什么-都有哪些使用场景"> 179.redis是什么?都有哪些使用场景?</h3>
<p>Redis是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。-----</p>
<p>Redis 使用场景：</p>
<ul>
<li>数据高并发的读写</li>
<li>海量数据的读写</li>
<li>对扩展性要求高的数据</li>
</ul>
<h3 id="_180-redis有哪些功能"> 180.redis有哪些功能?</h3>
<ul>
<li>数据缓存功能</li>
<li>分布式锁的功能</li>
<li>支持数据持久化</li>
<li>支持事务</li>
<li>支持消息队列</li>
</ul>
<h3 id="_181-redis和-memecache有什么区别"> 181.redis和 memecache有什么区别?</h3>
<ul>
<li>memcached所有的值均是简单的字符串，redis作为其替代者，支持更为丰富的数据类型</li>
<li>redis的速度比memcached快很多</li>
<li>redis可以持久化其数据</li>
</ul>
<h3 id="_182-redis为什么是单线程的"> 182.redis为什么是单线程的?</h3>
<p>因为 cpu 不是 Redis 的瓶颈，Redis 的瓶颈最有可能是机器内存或者网络带宽。既然单线程容易实现，而且 cpu 又不会成为瓶颈，那就</p>
<p>顺理成章地采用单线程的方案了。</p>
<p>关于 Redis 的性能，官方网站也有，普通笔记本轻松处理每秒几十万的请求。</p>
<p>而且单线程并不代表就慢 nginx 和 nodejs 也都是高性能单线程的代表。</p>
<h3 id="_183-什么是缓存穿透-怎么解决"> 183.什么是缓存穿透?怎么解决?</h3>
<p>缓存穿透：指查询一个一定不存在的数据，由于缓存是不命中时需要从数据库查询，查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到数据库去查询，造成缓存穿透。</p>
<p>解决方案：最简单粗暴的方法如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），我们就把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。</p>
<h3 id="_184-redis支持的数据类型有哪些"> 184.redis支持的数据类型有哪些?</h3>
<p>string、list、hash、set、zset。</p>
<h3 id="_185-redis支持的java客户端都有哪些"> 185.redis支持的java客户端都有哪些?</h3>
<p>Redisson、Jedis、lettuce等等，官方推荐使用Redisson。</p>
<h3 id="_186-jedis和redisson有哪些区别"> 186.jedis和redisson有哪些区别?</h3>
<ul>
<li>
<p>Jedis是Redis的Java实现的客户端，其API提供了比较全面的Redis命令的支持。</p>
</li>
<li>
<p>Redisson实现了分布式和可扩展的Java数据结构，和Jedis相比，功能较为简单，不支持字符串操作，不支持排序、事务、管道、分区等Redis特性。Redisson的宗旨是促进使用者对Redis的关注分离，从而让使用者能够将精力更集中地放在处理业务逻辑上。</p>
</li>
</ul>
<h3 id="_187-怎么保证缓存和数据库数据的一致性"> 187.怎么保证缓存和数据库数据的一致性?</h3>
<ul>
<li>合理设置缓存的过期时间。</li>
<li>新增、更改、删除数据库操作时同步更新 Redis，可以使用事务机制来保证数据的一致性。</li>
</ul>
<h3 id="_188-redis持久化有几种方式"> 188.redis持久化有几种方式?</h3>
<p>Redis 的持久化有两种方式，或者说有两种策略：</p>
<ul>
<li>RDB（Redis Database）：指定的时间间隔能对你的数据进行快照存储。</li>
<li>AOF（Append Only File）：每一个收到的写命令都通过write函数追加到文件中。</li>
</ul>
<h3 id="_189-redis-怎么实现分布式锁"> 189.redis 怎么实现分布式锁?</h3>
<ul>
<li>
<p>Redis 分布式锁其实就是在系统里面占一个“坑”，其他程序也要占“坑”的时候，</p>
<p>占用成功了就可以继续执行，失败了就只能放弃或稍后重试。</p>
</li>
<li>
<p>占坑一般使用 setnx(set if not exists)指令，只允许被一个程序占有，使用完调用 del 释放锁。</p>
</li>
</ul>
<h3 id="_190-redis分布式锁有什么缺陷"> 190.redis分布式锁有什么缺陷?</h3>
<p>Redis 分布式锁不能解决超时的问题，分布式锁有一个超时时间，程序的执行如果超出了锁的超时时间就会出现问题。</p>
<h3 id="_191-redis如何做内存优化"> 191.redis如何做内存优化?</h3>
<p>尽可能使用散列表（hashes），散列表（是说散列表里面存储的数少）使用的内存非常小，所以你应该尽可能的将你的数据模型抽象到一个散列表里面。</p>
<p>比如你的web系统中有一个用户对象，不要为这个用户的名称，姓氏，邮箱，密码设置单独的key,而是应该把这个用户的所有信息存储到一张散列表里面。</p>
<h3 id="_192-redis淘汰策略有哪些"> 192.redis淘汰策略有哪些?</h3>
<ul>
<li>volatile-lru：从已设置过期时间的数据集（server. db[i]. expires）中挑选最近最少使用的数据淘汰。</li>
<li>volatile-ttl：从已设置过期时间的数据集（server. db[i]. expires）中挑选将要过期的数据淘汰。</li>
<li>volatile-random：从已设置过期时间的数据集（server. db[i]. expires）中任意选择数据淘汰。</li>
<li>allkeys-lru：从数据集（server. db[i]. dict）中挑选最近最少使用的数据淘汰。</li>
<li>allkeys-random：从数据集（server. db[i]. dict）中任意选择数据淘汰。</li>
<li>no-enviction（驱逐）：禁止驱逐数据。</li>
</ul>
<h3 id="_193-redis-常见的性能问题有哪些-该如何解决"> 193.redis 常见的性能问题有哪些?该如何解决?</h3>
<ul>
<li>主服务器写内存快照，会阻塞主线程的工作，当快照比较大时对性能影响是非常大的，会间断性暂停服务，所以主服务器最好不要写内存快照。</li>
<li>Redis 主从复制的性能问题，为了主从复制的速度和连接的稳定性，主从库最好在同一个局域网内。</li>
</ul>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <contributor>
      <name>南辞</name>
    </contributor>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">模块16—Zookeeper</title>
    <id>http://qiqi.dreamagain.top/interview/Java208/%E6%A8%A1%E5%9D%9716%E2%80%94Zookeeper/</id>
    <link href="http://qiqi.dreamagain.top/interview/Java208/%E6%A8%A1%E5%9D%9716%E2%80%94Zookeeper/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<h2 id="问题"> 问题：</h2>
<p>157.zookeeper是什么?</p>
<p>158.zookeeper都有哪些功能?</p>
<p>159.zookeeper有几种部署模式?</p>
<p>160.zookeeper怎么保证主从节点的状态同步?</p>
<p>161.集群中为什么要有主节点?</p>
<p>162.集群中有3台服务器，其中一个节点宕机，这个时候zookeeper还可以使用吗?</p>
<p>163.说一下zookeeper的通知机制?</p>
<h2 id="答案"> 答案：</h2>
<h3 id="_157-zookeeper是什么"> 157.zookeeper是什么?</h3>
<h3 id="_158-zookeeper都有哪些功能"> 158.zookeeper都有哪些功能?</h3>
<h3 id="_159-zookeeper有几种部署模式"> 159.zookeeper有几种部署模式?</h3>
<h3 id="_160-zookeeper怎么保证主从节点的状态同步"> 160.zookeeper怎么保证主从节点的状态同步?</h3>
<h3 id="_161-集群中为什么要有主节点"> 161.集群中为什么要有主节点?</h3>
<h3 id="_162-集群中有3台服务器-其中一个节点宕机-这个时候zookeeper还可以使用吗"> 162.集群中有3台服务器，其中一个节点宕机，这个时候zookeeper还可以使用吗?</h3>
<h3 id="_163-说一下zookeeper的通知机制"> 163.说一下zookeeper的通知机制?</h3>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <contributor>
      <name>南辞</name>
    </contributor>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">模块19—JVM</title>
    <id>http://qiqi.dreamagain.top/interview/Java208/%E6%A8%A1%E5%9D%9719%E2%80%94JVM/</id>
    <link href="http://qiqi.dreamagain.top/interview/Java208/%E6%A8%A1%E5%9D%9719%E2%80%94JVM/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<h2 id="问题"> 问题：</h2>
<p>194.说一下 jvm的主要组成部分?及其作用?</p>
<p>195.说一下 jvm运行时数据区?</p>
<p>196.说一下堆栈的区别?</p>
<p>197.队列和栈是什么?有什么区别?</p>
<p>198.什么是双亲委派模型?</p>
<p>199.说一下类加载的执行过程?</p>
<p>200.怎么判断对象是否可以被回收?</p>
<p>201.java中都有哪些引用类型?</p>
<p>202.说一下 jvm有哪些垃圾回收算法?</p>
<p>203.说一下 jvm有哪些垃圾回收器?</p>
<p>204.详细介绍一下 CMS垃圾回收器?</p>
<p>205.新生代垃圾回收器和老生代垃圾回收器都有哪些?有什么区别?</p>
<p>206.简述分代垃圾回收器是怎么工作的?</p>
<p>207.说一下jvm调优的工具?</p>
<p>208.常用的jvm调优的参数都有哪些?</p>
<h2 id="答案"> 答案：</h2>
<h3 id="_194-说一下-jvm的主要组成部分-及其作用"> 194.说一下 jvm的主要组成部分?及其作用?</h3>
<ul>
<li>类加载器（ClassLoader）</li>
<li>运行时数据区（Runtime Data Area）</li>
<li>执行引擎（Execution Engine）</li>
<li>本地库接口（Native Interface）</li>
</ul>
<p>组件的作用： 首先通过类加载器（ClassLoader）会把 Java 代码转换成字节码，运行时数据区（Runtime Data Area）再把字节码加载</p>
<p>到内存中，而字节码文件只是 JVM 的一套指令集规范，并不能直接交给底层操作系统去执行，因此需要特定的命令解析器执行引擎</p>
<p>（Execution Engine），将字节码翻译成底层系统指令，再交由 CPU 去执行，而这个过程中需要调用其他语言的本地库接口（Native</p>
<p>Interface）来实现整个程序的功能。</p>
<h3 id="_195-说一下-jvm运行时数据区"> 195.说一下 jvm运行时数据区?</h3>
<ul>
<li>程序计数器</li>
<li>虚拟机栈</li>
<li>本地方法栈</li>
<li>堆</li>
<li>方法区</li>
</ul>
<p>有的区域随着虚拟机进程的启动而存在，有的区域则依赖用户进程的启动和结束而创建和销毁。</p>
<p><img src="./assets/java-12.png" alt=""></p>
<h3 id="_196-说一下堆栈的区别"> 196.说一下堆栈的区别?</h3>
<ol>
<li>
<p>栈内存存储的是局部变量而堆内存存储的是实体；</p>
</li>
<li>
<p>栈内存的更新速度要快于堆内存，因为局部变量的生命周期很短；</p>
</li>
<li>
<p>栈内存存放的变量生命周期一旦结束就会被释放，而堆内存存放的实体会被垃圾回收机制不定时的回收。</p>
</li>
</ol>
<h3 id="_197-队列和栈是什么-有什么区别"> 197.队列和栈是什么?有什么区别?</h3>
<ul>
<li>队列和栈都是被用来预存储数据的。</li>
<li>队列允许先进先出检索元素，但也有例外的情况，Deque 接口允许从两端检索元素。</li>
<li>栈和队列很相似，但它运行对元素进行后进先出进行检索。</li>
</ul>
<h3 id="_198-什么是双亲委派模型"> 198.什么是双亲委派模型?</h3>
<p>在介绍双亲委派模型之前先说下类加载器。对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立在 JVM 中的唯一性，每</p>
<p>一个类加载器，都有一个独立的类名称空间。类加载器就是根据指定全限定名称将 class 文件加载到 JVM 内存，然后再转化为 class 对</p>
<p>象。</p>
<p><strong>类加载器分类：</strong></p>
<ul>
<li>启动类加载器（Bootstrap ClassLoader），是虚拟机自身的一部分，用来加载Java_HOME/lib/目录中的，或者被 -Xbootclasspath 参数所指定的路径中并且被虚拟机识别的类库；</li>
<li>扩展类加载器（Extension ClassLoader）：负责加载&lt;java_home style=&quot;box-sizing: border-box; -webkit-tap-highlight-color: transparent; text-size-adjust: none; -webkit-font-smoothing: antialiased; outline: 0px !important;&quot;&gt;\lib\ext目录或Java. ext. dirs系统变量指定的路径中的所有类库；&lt;/java_home&gt;</li>
<li>应用程序类加载器（Application ClassLoader）。负责加载用户类路径（classpath）上的指定类库，我们可以直接使用这个类加载器。一般情况，如果我们没有自定义类加载器默认就是用这个加载器。</li>
<li>其他类加载器：</li>
</ul>
<p>双亲委派模型：如果一个类加载器收到了类加载的请求，它首先不会自己去加载这个类，而是把这个请求委派给父类加载器去完成，每</p>
<p>一层的类加载器都是如此，这样所有的加载请求都会被传送到顶层的启动类加载器中，只有当父加载无法完成加载请求（它的搜索范围</p>
<p>中没找到所需的类）时，子加载器才会尝试去加载类。</p>
<h3 id="_199-说一下类加载的执行过程"> 199.说一下类加载的执行过程?</h3>
<p>类加载分为以下 5 个步骤：</p>
<ol>
<li>加载：根据查找路径找到相应的 class 文件然后导入；</li>
<li>检查：检查加载的 class 文件的正确性；</li>
<li>准备：给类中的静态变量分配内存空间；</li>
<li>解析：虚拟机将常量池中的符号引用替换成直接引用的过程。符号引用就理解为一个标示，而在直接引用直接指向内存中的地址；</li>
<li>初始化：对静态变量和静态代码块执行初始化工作。</li>
</ol>
<h3 id="_200-怎么判断对象是否可以被回收"> 200.怎么判断对象是否可以被回收?</h3>
<p>一般有两种方法来判断：</p>
<ul>
<li>引用计数器：为每个对象创建一个引用计数，有对象引用时计数器 +1，引用被释放时计数 -1，当计数器为 0 时就可以被回收。它有一个缺点不能解决循环引用的问题；</li>
<li>可达性分析：从 GC Roots 开始向下搜索，搜索所走过的路径称为引用链。当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是可以被回收的。</li>
</ul>
<h3 id="_201-java中都有哪些引用类型"> 201.java中都有哪些引用类型?</h3>
<ul>
<li>强引用</li>
<li>软引用</li>
<li>弱引用</li>
<li>虚引用（幽灵引用/幻影引用）</li>
</ul>
<h3 id="_202-说一下-jvm有哪些垃圾回收算法"> 202.说一下 jvm有哪些垃圾回收算法?</h3>
<ul>
<li>标记-清除算法</li>
<li>标记-整理算法</li>
<li>复制算法</li>
<li>分代算法</li>
</ul>
<h3 id="_203-说一下-jvm有哪些垃圾回收器"> 203.说一下 jvm有哪些垃圾回收器?</h3>
<ul>
<li>Serial：最早的单线程串行垃圾回收器。</li>
<li>Serial Old：Serial 垃圾回收器的老年版本，同样也是单线程的，可以作为 CMS 垃圾回收器的备选预案。</li>
<li>ParNew：是 Serial 的多线程版本。</li>
<li>Parallel 和 ParNew 收集器类似是多线程的，但 Parallel 是吞吐量优先的收集器，可以牺牲等待时间换取系统的吞吐量。</li>
<li>Parallel Old 是 Parallel 老生代版本，Parallel 使用的是复制的内存回收算法，Parallel Old 使用的是标记-整理的内存回收算法。</li>
<li>CMS：一种以获得最短停顿时间为目标的收集器，非常适用 B/S 系统。</li>
<li>G1：一种兼顾吞吐量和停顿时间的 GC 实现，是 JDK 9 以后的默认 GC 选项。</li>
</ul>
<h3 id="_204-详细介绍一下-cms垃圾回收器"> 204.详细介绍一下 CMS垃圾回收器?</h3>
<p>CMS 是英文 Concurrent Mark-Sweep 的简称，是以牺牲吞吐量为代价来获得最短回收停顿时间的垃圾回收器。对于要求服务器响应速度的应用上，这种垃圾回收器非常适合。在启动 JVM 的参数加上“-XX:+UseConcMarkSweepGC”来指定使用 CMS 垃圾回收器。</p>
<p>CMS 使用的是标记-清除的算法实现的，所以在 gc 的时候回产生大量的内存碎片，当剩余内存不能满足程序运行要求时，系统将会出现 Concurrent Mode Failure，临时 CMS 会采用 Serial Old 回收器进行垃圾清除，此时的性能将会被降低。</p>
<h3 id="_205-新生代垃圾回收器和老生代垃圾回收器都有哪些-有什么区别"> 205.新生代垃圾回收器和老生代垃圾回收器都有哪些?有什么区别?</h3>
<ul>
<li>新生代回收器：Serial、ParNew、Parallel Scavenge</li>
<li>老年代回收器：Serial Old、Parallel Old、CMS</li>
<li>整堆回收器：G1</li>
</ul>
<p>新生代垃圾回收器一般采用的是复制算法，复制算法的优点是效率高，缺点是内存利用率低；老年代回收器一般采用的是标记-整理的算法进行垃圾回收。</p>
<h3 id="_206-简述分代垃圾回收器是怎么工作的"> 206.简述分代垃圾回收器是怎么工作的?</h3>
<p>分代回收器有两个分区：老生代和新生代，新生代默认的空间占比总空间的 1/3，老生代的默认占比是 2/3。</p>
<p>新生代使用的是复制算法，新生代里有 3 个分区：Eden、To Survivor、From Survivor，它们的默认占比是 8:1:1，它的执行流程如下：</p>
<ul>
<li>把 Eden + From Survivor 存活的对象放入 To Survivor 区；</li>
<li>清空 Eden 和 From Survivor 分区；</li>
<li>From Survivor 和 To Survivor 分区交换，From Survivor 变 To Survivor，To Survivor 变 From Survivor。</li>
</ul>
<p>每次在 From Survivor 到 To Survivor 移动时都存活的对象，年龄就 +1，当年龄到达 15（默认配置是 15）时，升级为老生代。大对象也会直接进入老生代。</p>
<p>老生代当空间占用到达某个值之后就会触发全局垃圾收回，一般使用标记整理的执行算法。以上这些循环往复就构成了整个分代垃圾回收的整体执行流程。</p>
<h3 id="_207-说一下jvm调优的工具"> 207.说一下jvm调优的工具?</h3>
<p>JDK 自带了很多监控工具，都位于 JDK 的 bin 目录下，其中最常用的是 jconsole 和 jvisualvm 这两款视图监控工具。</p>
<ul>
<li>jconsole：用于对 JVM 中的内存、线程和类等进行监控；</li>
<li>jvisualvm：JDK 自带的全能分析工具，可以分析：内存快照、线程快照、程序死锁、监控内存的变化、gc 变化等。</li>
</ul>
<h3 id="_208-常用的jvm调优的参数都有哪些"> 208.常用的jvm调优的参数都有哪些?</h3>
<ul>
<li>-Xms2g：初始化推大小为 2g；</li>
<li>-Xmx2g：堆最大内存为 2g；</li>
<li>-XX:NewRatio=4：设置年轻的和老年代的内存比例为 1:4；</li>
<li>-XX:SurvivorRatio=8：设置新生代 Eden 和 Survivor 比例为 8:2；</li>
<li>–XX:+UseParNewGC：指定使用 ParNew + Serial Old 垃圾回收器组合；</li>
<li>-XX:+UseParallelOldGC：指定使用 ParNew + ParNew Old 垃圾回收器组合；</li>
<li>-XX:+UseConcMarkSweepGC：指定使用 CMS + Serial Old 垃圾回收器组合；</li>
<li>-XX:+PrintGC：开启打印 gc 信息；</li>
<li>-XX:+PrintGCDetails：打印 gc 详细信息。</li>
</ul>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <contributor>
      <name>南辞</name>
    </contributor>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">面试准备</title>
    <id>http://qiqi.dreamagain.top/interview/</id>
    <link href="http://qiqi.dreamagain.top/interview/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <summary type="html"><![CDATA[<blockquote>
<p><img src="https://img.shields.io/badge/%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3-blue.svg" alt="img"></p>
</blockquote>
]]></summary>
    <content type="html"><![CDATA[<blockquote>
<p><img src="https://img.shields.io/badge/%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3-blue.svg" alt="img"></p>
</blockquote>

<h2 id="网上面试题"> 网上面试题</h2>
<p><a href="./Java208/">Java必备208道面试题</a></p>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <category term="面试"/>
    <contributor>
      <name>南辞</name>
    </contributor>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">Spring Security整合</title>
    <id>http://qiqi.dreamagain.top/program/backend/backframe/Spring%20Security/example/</id>
    <link href="http://qiqi.dreamagain.top/program/backend/backframe/Spring%20Security/example/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<h1 id="spring-security"> Spring Security</h1>
<h1 id="spring-security整合"> Spring Security整合</h1>
<h2 id="一、创建spring-security模块"> 一、创建spring_security模块</h2>
<p><img src="Spring%20Security%E6%95%B4%E5%90%88.assets/423034c7-c21a-4555-8380-393ac7ebca4d.png" alt="img"></p>
<h2 id="二、在spring-security中引入相关依赖"> 二、在spring_security中引入相关依赖</h2>
<div><pre><code><span><span><span>&lt;</span>dependencies</span><span>></span></span>
    <span><span><span>&lt;</span>dependency</span><span>></span></span>
        <span><span><span>&lt;</span>groupId</span><span>></span></span>com.atguigu<span><span><span>&lt;/</span>groupId</span><span>></span></span>
        <span><span><span>&lt;</span>artifactId</span><span>></span></span>common_utils<span><span><span>&lt;/</span>artifactId</span><span>></span></span>
        <span><span><span>&lt;</span>version</span><span>></span></span>0.0.1-SNAPSHOT<span><span><span>&lt;/</span>version</span><span>></span></span>
    <span><span><span>&lt;/</span>dependency</span><span>></span></span>
    
    <span>&lt;!-- Spring Security依赖 --></span>
    <span><span><span>&lt;</span>dependency</span><span>></span></span>
        <span><span><span>&lt;</span>groupId</span><span>></span></span>org.springframework.boot<span><span><span>&lt;/</span>groupId</span><span>></span></span>
        <span><span><span>&lt;</span>artifactId</span><span>></span></span>spring-boot-starter-security<span><span><span>&lt;/</span>artifactId</span><span>></span></span>
    <span><span><span>&lt;/</span>dependency</span><span>></span></span>
    <span><span><span>&lt;</span>dependency</span><span>></span></span>
        <span><span><span>&lt;</span>groupId</span><span>></span></span>io.jsonwebtoken<span><span><span>&lt;/</span>groupId</span><span>></span></span>
        <span><span><span>&lt;</span>artifactId</span><span>></span></span>jjwt<span><span><span>&lt;/</span>artifactId</span><span>></span></span>
    <span><span><span>&lt;/</span>dependency</span><span>></span></span>
<span><span><span>&lt;/</span>dependencies</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><h2 id="三、在service-acl引入spring-security依赖"> 三、在service_acl引入spring_security依赖</h2>
<div><pre><code><span><span><span>&lt;</span>dependency</span><span>></span></span>
    <span><span><span>&lt;</span>groupId</span><span>></span></span>com.nanci<span><span><span>&lt;/</span>groupId</span><span>></span></span>
    <span><span><span>&lt;</span>artifactId</span><span>></span></span>spring_security<span><span><span>&lt;/</span>artifactId</span><span>></span></span>
    <span><span><span>&lt;</span>version</span><span>></span></span>0.0.1-SNAPSHOT<span><span><span>&lt;/</span>version</span><span>></span></span>
<span><span><span>&lt;/</span>dependency</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p><strong>1、代码结构说明：</strong></p>
<p>**<img src="Spring%20Security%E6%95%B4%E5%90%88.assets/6aafe337-8a5d-440c-b93d-ff60d4f9cef6.png" alt="img">
**</p>
<p><strong>2、创建spring security核心配置类</strong></p>
<p><em><strong>*<img src="Spring%20Security%E6%95%B4%E5%90%88.assets/553c05a4-ff6d-456c-a5f6-ee9db5e6954a.png" alt="img">*</strong></em></p>
<p>Spring Security的核心配置就是继承WebSecurityConfigurerAdapter并注解@EnableWebSecurity的配置。</p>
<p>这个配置指明了用户名密码的处理方式、请求路径的开合、登录登出控制等和安全相关的配置</p>
<div><pre><code><span>import</span> <span>com<span>.</span>atguigu<span>.</span>serurity<span>.</span>filter<span>.</span></span><span>TokenAuthenticationFilter</span><span>;</span>
<span>import</span> <span>com<span>.</span>atguigu<span>.</span>serurity<span>.</span>filter<span>.</span></span><span>TokenLoginFilter</span><span>;</span>
<span>import</span> <span>com<span>.</span>atguigu<span>.</span>serurity<span>.</span>security<span>.</span></span><span>DefaultPasswordEncoder</span><span>;</span>
<span>import</span> <span>com<span>.</span>atguigu<span>.</span>serurity<span>.</span>security<span>.</span></span><span>TokenLogoutHandler</span><span>;</span>
<span>import</span> <span>com<span>.</span>atguigu<span>.</span>serurity<span>.</span>security<span>.</span></span><span>TokenManager</span><span>;</span>
<span>import</span> <span>com<span>.</span>atguigu<span>.</span>serurity<span>.</span>security<span>.</span></span><span>UnauthorizedEntryPoint</span><span>;</span>
<span>import</span> <span>org<span>.</span>springframework<span>.</span>beans<span>.</span>factory<span>.</span>annotation<span>.</span></span><span>Autowired</span><span>;</span>
<span>import</span> <span>org<span>.</span>springframework<span>.</span>context<span>.</span>annotation<span>.</span></span><span>Configuration</span><span>;</span>
<span>import</span> <span>org<span>.</span>springframework<span>.</span>data<span>.</span>redis<span>.</span>core<span>.</span></span><span>RedisTemplate</span><span>;</span>
<span>import</span> <span>org<span>.</span>springframework<span>.</span>security<span>.</span>config<span>.</span>annotation<span>.</span>authentication<span>.</span>builders<span>.</span></span><span>AuthenticationManagerBuilder</span><span>;</span>
<span>import</span> <span>org<span>.</span>springframework<span>.</span>security<span>.</span>config<span>.</span>annotation<span>.</span>method<span>.</span>configuration<span>.</span></span><span>EnableGlobalMethodSecurity</span><span>;</span>
<span>import</span> <span>org<span>.</span>springframework<span>.</span>security<span>.</span>config<span>.</span>annotation<span>.</span>web<span>.</span>builders<span>.</span></span><span>HttpSecurity</span><span>;</span>
<span>import</span> <span>org<span>.</span>springframework<span>.</span>security<span>.</span>config<span>.</span>annotation<span>.</span>web<span>.</span>builders<span>.</span></span><span>WebSecurity</span><span>;</span>
<span>import</span> <span>org<span>.</span>springframework<span>.</span>security<span>.</span>config<span>.</span>annotation<span>.</span>web<span>.</span>configuration<span>.</span></span><span>EnableWebSecurity</span><span>;</span>
<span>import</span> <span>org<span>.</span>springframework<span>.</span>security<span>.</span>config<span>.</span>annotation<span>.</span>web<span>.</span>configuration<span>.</span></span><span>WebSecurityConfigurerAdapter</span><span>;</span>
<span>import</span> <span>org<span>.</span>springframework<span>.</span>security<span>.</span>core<span>.</span>userdetails<span>.</span></span><span>UserDetailsService</span><span>;</span>
<span>/**
 * &lt;p>
 * Security配置类
 * &lt;/p>
 */</span>
<span>@Configuration</span>
<span>@EnableWebSecurity</span>
<span>@EnableGlobalMethodSecurity</span><span>(</span>prePostEnabled <span>=</span> <span>true</span><span>)</span>
<span>public</span> <span>class</span> <span>TokenWebSecurityConfig</span> <span>extends</span> <span>WebSecurityConfigurerAdapter</span> <span>{</span>
    <span>private</span> <span>UserDetailsService</span> userDetailsService<span>;</span>
    <span>private</span> <span>TokenManager</span> tokenManager<span>;</span>
    <span>private</span> <span>DefaultPasswordEncoder</span> defaultPasswordEncoder<span>;</span>
    <span>private</span> <span>RedisTemplate</span> redisTemplate<span>;</span>
    <span>@Autowired</span>
    <span>public</span> <span>TokenWebSecurityConfig</span><span>(</span><span>UserDetailsService</span> userDetailsService<span>,</span> <span>DefaultPasswordEncoder</span> defaultPasswordEncoder<span>,</span>
                                  <span>TokenManager</span> tokenManager<span>,</span> <span>RedisTemplate</span> redisTemplate<span>)</span> <span>{</span>
        <span>this</span><span>.</span>userDetailsService <span>=</span> userDetailsService<span>;</span>
        <span>this</span><span>.</span>defaultPasswordEncoder <span>=</span> defaultPasswordEncoder<span>;</span>
        <span>this</span><span>.</span>tokenManager <span>=</span> tokenManager<span>;</span>
        <span>this</span><span>.</span>redisTemplate <span>=</span> redisTemplate<span>;</span>
    <span>}</span>
    <span>/**
     * 配置设置
     * @param http
     * @throws Exception
     */</span>
    <span>@Override</span>
    <span>protected</span> <span>void</span> <span>configure</span><span>(</span><span>HttpSecurity</span> http<span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>
        http<span>.</span><span>exceptionHandling</span><span>(</span><span>)</span>
                <span>.</span><span>authenticationEntryPoint</span><span>(</span><span>new</span> <span>UnauthorizedEntryPoint</span><span>(</span><span>)</span><span>)</span>
                <span>.</span><span>and</span><span>(</span><span>)</span><span>.</span><span>csrf</span><span>(</span><span>)</span><span>.</span><span>disable</span><span>(</span><span>)</span>
                <span>.</span><span>authorizeRequests</span><span>(</span><span>)</span>
                <span>.</span><span>anyRequest</span><span>(</span><span>)</span><span>.</span><span>authenticated</span><span>(</span><span>)</span>
                <span>.</span><span>and</span><span>(</span><span>)</span><span>.</span><span>logout</span><span>(</span><span>)</span><span>.</span><span>logoutUrl</span><span>(</span><span>"/admin/acl/index/logout"</span><span>)</span>
                <span>.</span><span>addLogoutHandler</span><span>(</span><span>new</span> <span>TokenLogoutHandler</span><span>(</span>tokenManager<span>,</span>redisTemplate<span>)</span><span>)</span><span>.</span><span>and</span><span>(</span><span>)</span>
                <span>.</span><span>addFilter</span><span>(</span><span>new</span> <span>TokenLoginFilter</span><span>(</span><span>authenticationManager</span><span>(</span><span>)</span><span>,</span> tokenManager<span>,</span> redisTemplate<span>)</span><span>)</span>
                <span>.</span><span>addFilter</span><span>(</span><span>new</span> <span>TokenAuthenticationFilter</span><span>(</span><span>authenticationManager</span><span>(</span><span>)</span><span>,</span> tokenManager<span>,</span> redisTemplate<span>)</span><span>)</span><span>.</span><span>httpBasic</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
    <span>/**
     * 密码处理
     * @param auth
     * @throws Exception
     */</span>
    <span>@Override</span>
    <span>public</span> <span>void</span> <span>configure</span><span>(</span><span>AuthenticationManagerBuilder</span> auth<span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>
        auth<span>.</span><span>userDetailsService</span><span>(</span>userDetailsService<span>)</span><span>.</span><span>passwordEncoder</span><span>(</span>defaultPasswordEncoder<span>)</span><span>;</span>
    <span>}</span>
    <span>/**
     * 配置哪些请求不拦截
     * @param web
     * @throws Exception
     */</span>
    <span>@Override</span>
    <span>public</span> <span>void</span> <span>configure</span><span>(</span><span>WebSecurity</span> web<span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>
        web<span>.</span><span>ignoring</span><span>(</span><span>)</span><span>.</span><span>antMatchers</span><span>(</span><span>"/api/**"</span><span>,</span>
                <span>"/swagger-resources/**"</span><span>,</span> <span>"/webjars/**"</span><span>,</span> <span>"/v2/**"</span><span>,</span> <span>"/swagger-ui.html/**"</span>
               <span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br></div></div><p><strong>5、创建认证授权相关的工具类</strong></p>
<p><img src="Spring%20Security%E6%95%B4%E5%90%88.assets/75ccbeef-10c1-45fd-8f68-b598019832b1.png" alt="img"></p>
<div><pre><code>（1）DefaultPasswordEncoder：密码处理的方法
</code></pre>
<div><span>1</span><br></div></div><div><pre><code>package com.atguigu.serurity.security;
import com.atguigu.commonutils.utils.MD5;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Component;
/**
 * &lt;p&gt;
 * 密码的处理方法类型
 * &lt;/p&gt;
 */
@Component
public class DefaultPasswordEncoder implements PasswordEncoder {
    public DefaultPasswordEncoder() {
        this(-1);
    }
    /**
     * @param strength
     *            the log rounds to use, between 4 and 31
     */
    public DefaultPasswordEncoder(int strength) {
    }
    public String encode(CharSequence rawPassword) {
        return MD5.encrypt(rawPassword.toString());
    }
    public boolean matches(CharSequence rawPassword, String encodedPassword) {
        return encodedPassword.equals(MD5.encrypt(rawPassword.toString()));
    }
}
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div><p><em><em><em>*</em>*（2）********<code>TokenManager：token操作的工具类</code>******</em>*</em>*</p>
<div><pre><code>import io.jsonwebtoken.CompressionCodecs;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.SignatureAlgorithm;
import org.springframework.stereotype.Component;
import java.util.Date;
/**
 * &lt;p&gt;
 * token管理
 * &lt;/p&gt;
 */
@Component
public class TokenManager {
    private long tokenExpiration = 24*60*60*1000;
    private String tokenSignKey = &quot;123456&quot;;
    public String createToken(String username) {
        String token = Jwts.builder().setSubject(username)
                .setExpiration(new Date(System.currentTimeMillis() + tokenExpiration))
                .signWith(SignatureAlgorithm.HS512, tokenSignKey).compressWith(CompressionCodecs.GZIP).compact();
        return token;
    }
    public String getUserFromToken(String token) {
        String user = Jwts.parser().setSigningKey(tokenSignKey).parseClaimsJws(token).getBody().getSubject();
        return user;
    }
    public void removeToken(String token) {
        //jwttoken无需删除，客户端扔掉即可。
    }
}
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br></div></div><p><em><em><em>*</em>*（3）**********<code>TokenLogoutHandler：退出实现</code>**********
**</em>*</em>*</p>
<div><pre><code>import com.atguigu.commonutils.R;
import com.atguigu.commonutils.utils.ResponseUtil;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.security.core.Authentication;
import org.springframework.security.web.authentication.logout.LogoutHandler;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
/**
 * &lt;p&gt;
 * 登出业务逻辑类
 * &lt;/p&gt;
 */
public class TokenLogoutHandler implements LogoutHandler {
    private TokenManager tokenManager;
    private RedisTemplate redisTemplate;
    public TokenLogoutHandler(TokenManager tokenManager, RedisTemplate redisTemplate) {
        this.tokenManager = tokenManager;
        this.redisTemplate = redisTemplate;
    }
    @Override
    public void logout(HttpServletRequest request, HttpServletResponse response, Authentication authentication) {
        String token = request.getHeader(&quot;token&quot;);
        if (token != null) {
            tokenManager.removeToken(token);
            //清空当前用户缓存中的权限数据
            String userName = tokenManager.getUserFromToken(token);
            redisTemplate.delete(userName);
        }
        ResponseUtil.out(response, R.ok());
    }
}
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br></div></div><p><em><strong>*（4）********<code>UnauthorizedEntryPoint：未授权统一处理</code>*********</strong></em></p>
<div><pre><code>import com.atguigu.commonutils.R;
import com.atguigu.commonutils.utils.ResponseUtil;
import org.springframework.security.core.AuthenticationException;
import org.springframework.security.web.AuthenticationEntryPoint;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
/**
 * &lt;p&gt;
 * 未授权的统一处理方式
 * &lt;/p&gt;
 */
public class UnauthorizedEntryPoint implements AuthenticationEntryPoint {
    @Override
    public void commence(HttpServletRequest request, HttpServletResponse response,
                         AuthenticationException authException) throws IOException, ServletException {
        ResponseUtil.out(response, R.error());
    }
}
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><p><strong><em>*</em>*********6、创建认证授权实体类**********
****<img src="Spring%20Security%E6%95%B4%E5%90%88.assets/76236594-2238-4d28-a15e-7cf743bb53e2.png" alt="img">（1）SecutityUser*****</strong>*</p>
<div><pre><code>import lombok.Data;
import lombok.extern.slf4j.Slf4j;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.util.StringUtils;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
/**
 * &lt;p&gt;
 * 安全认证用户详情信息
 * &lt;/p&gt;
 */
@Data
@Slf4j
public class SecurityUser implements UserDetails {
    //当前登录用户
    private transient User currentUserInfo;
    //当前权限
    private List&lt;String&gt; permissionValueList;
    public SecurityUser() {
    }
    public SecurityUser(User user) {
        if (user != null) {
            this.currentUserInfo = user;
        }
    }
    @Override
    public Collection&lt;? extends GrantedAuthority&gt; getAuthorities() {
        Collection&lt;GrantedAuthority&gt; authorities = new ArrayList&lt;&gt;();
        for(String permissionValue : permissionValueList) {
            if(StringUtils.isEmpty(permissionValue)) continue;
            SimpleGrantedAuthority authority = new SimpleGrantedAuthority(permissionValue);
            authorities.add(authority);
        }
        return authorities;
    }
    @Override
    public String getPassword() {
        return currentUserInfo.getPassword();
    }
    @Override
    public String getUsername() {
        return currentUserInfo.getUsername();
    }
    @Override
    public boolean isAccountNonExpired() {
        return true;
    }
    @Override
    public boolean isAccountNonLocked() {
        return true;
    }
    @Override
    public boolean isCredentialsNonExpired() {
        return true;
    }
    @Override
    public boolean isEnabled() {
        return true;
    }
}
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br></div></div><p><em><em><em>*</em>*****（2）User******</em>*</em>*</p>
<div><pre><code>import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import lombok.Data;
import java.io.Serializable;
/**
 * &lt;p&gt;
 * 用户实体类
 * &lt;/p&gt;
 */
@Data
@ApiModel(description = &quot;用户实体类&quot;)
public class User implements Serializable {
    private static final long serialVersionUID = 1L;
    @ApiModelProperty(value = &quot;微信openid&quot;)
    private String username;
    @ApiModelProperty(value = &quot;密码&quot;)
    private String password;
    @ApiModelProperty(value = &quot;昵称&quot;)
    private String nickName;
    @ApiModelProperty(value = &quot;用户头像&quot;)
    private String salt;
    @ApiModelProperty(value = &quot;用户签名&quot;)
    private String token;
}
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><p><strong><em>*</em>*******************7、创建认证和授权的filter**********
**********<img src="Spring%20Security%E6%95%B4%E5%90%88.assets/bee4d171-befe-4b08-a792-5f1d50a8642b.png" alt="img">
****（1）TokenLoginFilter：认证的filter*****</strong>*</p>
<div><pre><code>import com.atguigu.commonutils.R;
import com.atguigu.commonutils.utils.ResponseUtil;
import com.atguigu.serurity.entity.SecurityUser;
import com.atguigu.serurity.entity.User;
import com.atguigu.serurity.security.TokenManager;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.AuthenticationException;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;
import org.springframework.security.web.util.matcher.AntPathRequestMatcher;
import javax.servlet.FilterChain;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.util.ArrayList;
/**
 * &lt;p&gt;
 * 登录过滤器，继承UsernamePasswordAuthenticationFilter，对用户名密码进行登录校验
 * &lt;/p&gt;
 */
public class TokenLoginFilter extends UsernamePasswordAuthenticationFilter {
    private AuthenticationManager authenticationManager;
    private TokenManager tokenManager;
    private RedisTemplate redisTemplate;
    public TokenLoginFilter(AuthenticationManager authenticationManager, TokenManager tokenManager, RedisTemplate redisTemplate) {
        this.authenticationManager = authenticationManager;
        this.tokenManager = tokenManager;
        this.redisTemplate = redisTemplate;
        this.setPostOnly(false);
        this.setRequiresAuthenticationRequestMatcher(new AntPathRequestMatcher(&quot;/admin/acl/login&quot;,&quot;POST&quot;));
    }
    @Override
    public Authentication attemptAuthentication(HttpServletRequest req, HttpServletResponse res)
            throws AuthenticationException {
        try {
            User user = new ObjectMapper().readValue(req.getInputStream(), User.class);
            return authenticationManager.authenticate(new UsernamePasswordAuthenticationToken(user.getUsername(), user.getPassword(), new ArrayList&lt;&gt;()));
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }
    /**
     * 登录成功
     * @param req
     * @param res
     * @param chain
     * @param auth
     * @throws IOException
     * @throws ServletException
     */
    @Override
    protected void successfulAuthentication(HttpServletRequest req, HttpServletResponse res, FilterChain chain,
                                            Authentication auth) throws IOException, ServletException {
        SecurityUser user = (SecurityUser) auth.getPrincipal();
        String token = tokenManager.createToken(user.getCurrentUserInfo().getUsername());
        redisTemplate.opsForValue().set(user.getCurrentUserInfo().getUsername(), user.getPermissionValueList());
        ResponseUtil.out(res, R.ok().data(&quot;token&quot;, token));
    }
    /**
     * 登录失败
     * @param request
     * @param response
     * @param e
     * @throws IOException
     * @throws ServletException
     */
    @Override
    protected void unsuccessfulAuthentication(HttpServletRequest request, HttpServletResponse response,
                                              AuthenticationException e) throws IOException, ServletException {
        ResponseUtil.out(response, R.error());
    }
}
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br></div></div><p><strong><em>*</em>*******************************<code>（2）TokenAuthenticationFilter：</code>*********************************</strong>*</p>
<div><pre><code>授权filter
</code></pre>
<div><span>1</span><br></div></div><div><pre><code>package com.atguigu.serurity.filter;
import com.atguigu.commonutils.R;
import com.atguigu.commonutils.utils.ResponseUtil;
import com.atguigu.serurity.security.TokenManager;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.web.authentication.www.BasicAuthenticationFilter;
import org.springframework.util.StringUtils;
import javax.servlet.FilterChain;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
/**
 * &lt;p&gt;
 * 访问过滤器
 * &lt;/p&gt;
 */
public class TokenAuthenticationFilter extends BasicAuthenticationFilter {
    private TokenManager tokenManager;
    private RedisTemplate redisTemplate;
    public TokenAuthenticationFilter(AuthenticationManager authManager, TokenManager tokenManager,RedisTemplate redisTemplate) {
        super(authManager);
        this.tokenManager = tokenManager;
        this.redisTemplate = redisTemplate;
    }
    @Override
    protected void doFilterInternal(HttpServletRequest req, HttpServletResponse res, FilterChain chain)
            throws IOException, ServletException {
        logger.info(&quot;=================&quot;+req.getRequestURI());
        if(req.getRequestURI().indexOf(&quot;admin&quot;) == -1) {
            chain.doFilter(req, res);
            return;
        }
        UsernamePasswordAuthenticationToken authentication = null;
        try {
            authentication = getAuthentication(req);
        } catch (Exception e) {
            ResponseUtil.out(res, R.error());
        }
        if (authentication != null) {
            SecurityContextHolder.getContext().setAuthentication(authentication);
        } else {
            ResponseUtil.out(res, R.error());
        }
        chain.doFilter(req, res);
    }
    private UsernamePasswordAuthenticationToken getAuthentication(HttpServletRequest request) {
        // token置于header里
        String token = request.getHeader(&quot;token&quot;);
        if (token != null &amp;&amp; !&quot;&quot;.equals(token.trim())) {
            String userName = tokenManager.getUserFromToken(token);
            List&lt;String&gt; permissionValueList = (List&lt;String&gt;) redisTemplate.opsForValue().get(userName);
            Collection&lt;GrantedAuthority&gt; authorities = new ArrayList&lt;&gt;();
            for(String permissionValue : permissionValueList) {
                if(StringUtils.isEmpty(permissionValue)) continue;
                SimpleGrantedAuthority authority = new SimpleGrantedAuthority(permissionValue);
                authorities.add(authority);
            }
            if (!StringUtils.isEmpty(userName)) {
                return new UsernamePasswordAuthenticationToken(userName, token, authorities);
            }
            return null;
        }
        return null;
    }
}
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br></div></div>]]></content>
    <author>
      <name>南辞</name>
    </author>
    <category term="后端框架"/>
    <contributor>
      <name>南辞</name>
    </contributor>
    <published>2021-01-13T00:00:00.000Z</published>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">Spring Security介绍</title>
    <id>http://qiqi.dreamagain.top/program/backend/backframe/Spring%20Security/intro/</id>
    <link href="http://qiqi.dreamagain.top/program/backend/backframe/Spring%20Security/intro/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<h1 id="spring-security"> Spring Security</h1>
<h2 id="一、框架介绍"> 一、框架介绍</h2>
<p>Spring 是一个非常流行和成功的 Java 应用开发框架。Spring Security 基于 Spring 框架，提供了一套 Web 应用安全性的完整解决方案。一般来说，Web 应用的安全性包括**用户认证（Authentication）和用户授权（Authorization）**两个部分。</p>
<p>（1）用户认证指的是：验证某个用户是否为系统中的合法主体，也就是说用户能否访问该系统。用户认证一般要求用户提供用户名和密码。系统通过校验用户名和密码来完成认证过程。</p>
<p>（2）用户授权指的是验证某个用户是否有权限执行某个操作。在一个系统中，不同用户所具有的权限是不同的。比如对一个文件来说，有的用户只能进行读取，而有的用户可以进行修改。一般来说，系统会为不同的用户分配不同的角色，而每个角色则对应一系列的权限。</p>
<p><strong>Spring Security其实就是用filter，对多请求的路径进行过滤。</strong></p>
<p>（1）如果是基于Session，那么Spring Security会对cookie里的sessionid进行解析，找到服务器存储的sesion信息，然后判断当前用户是否符合请求的要求。</p>
<p>（2）如果是token，则是解析出token，然后将当前请求加入到Spring Security管理的权限信息中去</p>
<h2 id="二、认证与授权实现思路"> 二、认证与授权实现思路</h2>
<p>如果系统的模块众多，每个模块都需要进行授权与认证，可以选择基于token的形式进行授权与认证，用户根据用户名密码认证成功，然后获取当前用户角色的一系列权限值，并以用户名为key，权限列表为value的形式存入redis缓存中，根据用户名相关信息生成token返回，浏览器将token记录到cookie中，每次调用api接口都默认将token携带到header请求头中，Spring Security解析header头获取token信息，解析token获取当前用户名，根据用户名就可以从redis中获取权限列表，这样Spring Security就能够判断当前请求是否有权限访问。</p>
<p>流程图：</p>
<p><img src="intro.assets/image-20210202105449950.png" alt="image-20210202105449950"></p>
<p>代码执行过程：</p>
<p><img src="intro.assets/image-20210202105704682.png" alt="image-20210202105704682"></p>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <category term="后端框架"/>
    <contributor>
      <name>南辞</name>
    </contributor>
    <published>2021-01-13T00:00:00.000Z</published>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">ORM相关框架</title>
    <id>http://qiqi.dreamagain.top/program/backend/backframe/orm/</id>
    <link href="http://qiqi.dreamagain.top/program/backend/backframe/orm/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <author>
      <name>南辞</name>
    </author>
    <contributor>
      <name>南辞</name>
    </contributor>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">后端框架</title>
    <id>http://qiqi.dreamagain.top/program/backend/backframe/</id>
    <link href="http://qiqi.dreamagain.top/program/backend/backframe/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <summary type="html"><![CDATA[<blockquote>
<p><img src="https://img.shields.io/badge/%E6%A1%86%E6%9E%B6-Spring-blue.svg" alt="img">  <img src="https://img.shields.io/badge/%E6%A1%86%E6%9E%B6-SpringMVC-blue.svg" alt="img">  <img src="https://img.shields.io/badge/%E6%A1%86%E6%9E%B6-SpringBoot-blue.svg" alt="img">  <img src="https://img.shields.io/badge/%E6%A1%86%E6%9E%B6-SpringCloud-blue.svg" alt="img"> <img src="https://img.shields.io/badge/%E6%A1%86%E6%9E%B6-SpringSecurity-blue.svg" alt="img"></p>
<p><img src="https://img.shields.io/badge/%E6%A1%86%E6%9E%B6-MyBatis-blue.svg" alt="img">  <img src="https://img.shields.io/badge/%E6%A1%86%E6%9E%B6-MyBatis--Plus-blue.svg" alt="img"></p>
</blockquote>
]]></summary>
    <content type="html"><![CDATA[<blockquote>
<p><img src="https://img.shields.io/badge/%E6%A1%86%E6%9E%B6-Spring-blue.svg" alt="img">  <img src="https://img.shields.io/badge/%E6%A1%86%E6%9E%B6-SpringMVC-blue.svg" alt="img">  <img src="https://img.shields.io/badge/%E6%A1%86%E6%9E%B6-SpringBoot-blue.svg" alt="img">  <img src="https://img.shields.io/badge/%E6%A1%86%E6%9E%B6-SpringCloud-blue.svg" alt="img"> <img src="https://img.shields.io/badge/%E6%A1%86%E6%9E%B6-SpringSecurity-blue.svg" alt="img"></p>
<p><img src="https://img.shields.io/badge/%E6%A1%86%E6%9E%B6-MyBatis-blue.svg" alt="img">  <img src="https://img.shields.io/badge/%E6%A1%86%E6%9E%B6-MyBatis--Plus-blue.svg" alt="img"></p>
</blockquote>

]]></content>
    <author>
      <name>南辞</name>
    </author>
    <category term="后端框架"/>
    <contributor>
      <name>南辞</name>
    </contributor>
    <published>2019-09-10T00:00:00.000Z</published>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">Spring家族框架体系</title>
    <id>http://qiqi.dreamagain.top/program/backend/backframe/spring/</id>
    <link href="http://qiqi.dreamagain.top/program/backend/backframe/spring/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <author>
      <name>南辞</name>
    </author>
    <contributor>
      <name>南辞</name>
    </contributor>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">后端框架</title>
    <id>http://qiqi.dreamagain.top/program/backend/framework/</id>
    <link href="http://qiqi.dreamagain.top/program/backend/framework/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<h2 id="一、spring家族"> 一、Spring家族</h2>
<h3 id="一-spring-framework"> <a href="">（一）Spring Framework</a></h3>
<h3 id="二-spring-mvc"> <a href="">（二）Spring MVC</a></h3>
<h3 id="三-spring-boot"> <a href="">（三）Spring Boot</a></h3>
<h3 id="四-spring-security"> <a href="">（四）Spring Security</a></h3>
<h3 id="五-spring-cloud"> <a href="">（五）Spring Cloud</a></h3>
<h2 id="二、orm框架"> 二、ORM框架</h2>
<h3 id="一-mybatis"> <a href="">（一）MyBatis</a></h3>
<h3 id="二-mybatis-plus"> <a href="">（二）MyBatis-Plus</a></h3>
<h3 id="三-hibanate"> <a href="">（三）Hibanate</a></h3>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <category term="框架"/>
    <contributor>
      <name>南辞</name>
    </contributor>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">JavaSE-注解</title>
    <id>http://qiqi.dreamagain.top/program/backend/java/annotation/</id>
    <link href="http://qiqi.dreamagain.top/program/backend/java/annotation/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<h2 id="一、理解注解"> 一、理解注解</h2>
<h3 id="一-为什么要引入注解"> （一）为什么要引入注解</h3>
<p>使用注解之前(甚至在使用之后)，XML被广泛的应用于描述元数据，得到各大框架的青睐，它以松耦合的方式完成了框架中几乎所有的配置，但是随着项目越来越庞大，XML的内容也越来越复杂，一些应用开发人员和架构师发现维护成本变高。他们希望使用一些和代码紧耦合的东西，于是就有人提出来一种标记式高耦合的配置方式注解。方法上可以进行注解，类上也可以注解，字段属性上也可以注解，反正几乎需要配置的地方都可以进行注解。</p>
<p>【注解】 VS 【XML】:</p>
<ul>
<li>注解可以提供更大的便捷性，易于维护修改，但耦合度高</li>
<li>XML相对于注解则是相反的。追求低耦合就要抛弃高效率，追求效率必然会遇到耦合。</li>
</ul>
<div><p>如何选择</p>
<p>假如你想为应用设置很多的常量或参数，这种情况下，【XML】是一个很好的选择，因为它不会同特定的代码耦合。</p>
<p>如果你想把某个方法声明为服务，那么使用【注解】会更好一些，因为这种情况下需要注解和方法紧密耦合起来，开发人员也必须认识到这点。</p>
<p>目前，许多框架将【XML】和【注解】两种方式结合使用，平衡两者之间的利弊。</p>
</div>
<h3 id="二-什么是注解"> （二）什么是注解</h3>
<p>注解也叫<strong>元数据</strong>，即一种描述数据的数据。例如我们常见的@Override和@Deprecated，注解是JDK1.5版本开始引入的一个特性，用于对代码进行说明，可以对包、类、接口、字段、方法参数、局部变量等进行注解</p>
<p>实际上Java注解与普通修饰符(public、static、void等)的使用方式并没有多大区别，<strong>一个注解准确意义上来说，只不过是一种特殊的注释而已</strong>， <mark>如果没有解析它的代码，它可能连注释都不如</mark>   。下面的例子是常见的注解：</p>
<div><pre><code><span>public</span> <span>class</span> <span>MyAnnotation</span> <span>{</span>
    <span>//@Test注解修饰方法A</span>
    <span>@Test</span>
    <span>public</span> <span>static</span> <span>void</span> <span>A</span><span>(</span><span>)</span><span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"Test....."</span><span>)</span><span>;</span>
    <span>}</span>

    <span>//一个方法上可以拥有多个不同的注解</span>
    <span>@Deprecated</span>
    <span>@SuppressWarnings</span><span>(</span><span>"uncheck"</span><span>)</span>
    <span>public</span> <span>static</span> <span>void</span> <span>B</span><span>(</span><span>)</span><span>{</span>

    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>通过在方法上使用@Test注解后，在运行该方法时，测试框架会自动识别该方法并单独调用，@Test实际上是一种标记注解，起标记作用，运行时告诉测试框架该方法为测试方法。而对于<code>@Deprecated</code>和<code>@SuppressWarnings(“uncheck”)</code>，则是Java本身内置的注解，在代码中，可以经常看见它们，但这并不是一件好事，毕竟当方法或是类上面有<code>@Deprecated</code>注解时，说明该方法或是类都已经过期不建议再用，<code>@SuppressWarnings</code> 则表示忽略指定警告，比如<code>@SuppressWarnings(“uncheck”)</code>，这就是注解的最简单的使用方式。</p>
<div><p>提示</p>
<p>解析一个类或者方法的注解往往有两种形式：</p>
<ul>
<li>一种是编译期直接的扫描</li>
<li>一种是运行期反射</li>
</ul>
</div>
<p>反射的事情先不讨论，而编译器的扫描指的是编译器在对 Java 代码编译成字节码的过程中会检测到某个类或者方法被一些注解修饰，这时它就会对于这些注解进行某些处理。</p>
<p>再来看一个例子:</p>
<div><pre><code><span>@Override</span>
<span>public</span> <span>String</span> <span>toString</span><span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span>"Hello Annotation"</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>上面的代码中重写了<code>toString()</code>方法并使用了<code>@Override</code>注解。但是，即使不使用<code>@Override</code>注解标记代码，程序也能够正常执行。</p>
<p>那么，该注解表示什么？这么写有什么好处吗？</p>
<p>事实上，<code>@Override</code>告诉编译器这个方法是一个重写方法(描述方法的元数据)，如果父类中不存在该方法，编译器便会报错，提示该方法没有重写父类中的方法。如果不小心拼写错误，例如将<code>toString()</code>写成了<code>toStrring()</code>，而且也没有使用<code>@Override</code>注解，那程序依然能编译运行。但运行结果会和期望的大不相同。现在我们了解了什么是注解，并且使用注解有助于提高代码的可读性。</p>
<h2 id="二、注解的用途"> 二、注解的用途</h2>
<ol>
<li>生成文档，通过代码里标识的元数据生成javadoc文档。</li>
<li>编译检查，通过代码里标识的元数据让编译器在编译期间进行检查验证。</li>
<li>编译时动态处理，编译时通过代码里标识的元数据动态处理，例如动态生成代码。</li>
<li>运行时动态处理，运行时通过代码里标识的元数据动态处理，例如使用反射注入实例</li>
</ol>
<h2 id="三、注解的分类"> 三、注解的分类</h2>
<p>Java 定义了一套注解，共有 7 个，3 个在 java.lang 中，剩下 4 个在 java.lang.annotation 中。</p>
<p><strong>作用在代码的注解</strong> ( <mark>使用这些注解后编译器就会进行检查</mark> )</p>
<ol>
<li>
<p>@Override ：检查该方法是否是重写方法。如果发现其父类，或者是引用的接口中并没有该方法时，会报编译错误。</p>
</li>
<li>
<p>@Deprecated ：标记过时方法。如果使用该方法，会报编译警告。</p>
</li>
<li>
<p>@SuppressWarnings ：指示编译器去忽略注解中声明的警告。</p>
</li>
</ol>
<p><strong>元注解</strong>（ <mark>用于定义注解的注解</mark> ）</p>
<ol>
<li>@Retention ：标识这个注解怎么保存，是只在代码中，还是编入class文件中，或者是在运行时可以通过反射访问。</li>
<li>@Documented ： 标记这些注解是否包含在用户文档中。</li>
<li>@Target ：标记这个注解应该是哪种 Java 成员。</li>
<li>@Inherited ： 标记这个注解是继承于哪个注解类(默认 注解并没有继承于任何子类)</li>
</ol>
<p><strong>Java7之后额外添加了 3 个注解</strong></p>
<ul>
<li>@SafeVarargs ： Java 7 开始支持，忽略任何使用参数为泛型变量的方法或构造函数调用产生的警告。</li>
<li>@FunctionalInterface ： Java 8 开始支持，标识一个匿名函数或函数式接口。</li>
<li>@Repeatable： Java 8 开始支持，标识某注解可以在同一个声明上使用多次，属于元注解，使用较少。</li>
</ul>
<p><strong>自定义注解</strong></p>
<p>​         可以根据自己的需求定义注解</p>
<h2 id="四、声明注解与元注解"> 四、声明注解与元注解</h2>
<p>要想真正掌握怎么使用注解，还需要先学习一下元注解。元注解(meta annotation)是用于标注其他注解的注解，学习元注解之后我们就可以利用元注解来自定义注解。</p>
<p>元注解有 @Retention、@Target、@Inherited、@Repeatable、@Documented 5 种。</p>
<p>我们先来看看前面的Test注解是如何声明的：</p>
<div><pre><code><span>//声明Test注解</span>
<span>@Target</span><span>(</span><span>ElementType</span><span>.</span>METHOD<span>)</span>
<span>@Retention</span><span>(</span><span>RetentionPolicy</span><span>.</span>RUNTIME<span>)</span>
<span>public</span> <span>@interface</span> <span>Test</span> <span>{</span>

<span>}</span> 
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>我们使用了<code>@interface</code>声明了Test注解，并使用<code>@Target</code>注解传入<code>ElementType.METHOD</code>参数来标明@Test只能用于方法上，<code>@Retention(RetentionPolicy.RUNTIME)</code>则用来表示该注解生存期是运行时，从代码上看注解的定义很像接口的定义，确实如此，毕竟在编译后也会生成Test.class文件。对于<code>@Target</code>和<code>@Retention</code>是由Java提供的元注解，所谓元注解就是标记其他注解的注解，下面分别介绍</p>
<h3 id="target"> @Target</h3>
<p>Target 是目标的意思，@Target 用来约束注解可以应用于源码的哪些位置（如方法、类或字段）</p>
<p>可以这样理解，当一个注解被 @Target 注解时，这个注解就被限定了 <mark>运用场景</mark>。</p>
<p>@Target 参数是ElementType是枚举类型，其定义如下，也代表可能的取值范围</p>
<div><pre><code><span>public</span> <span>enum</span> <span>ElementType</span> <span>{</span>
    <span>/**标明该注解可以用于类、接口（包括注解类型）或enum声明*/</span>
    TYPE<span>,</span>

    <span>/** 标明该注解可以用于字段(域)声明，包括enum实例 */</span>
    FIELD<span>,</span>

    <span>/** 标明该注解可以用于方法声明 */</span>
    METHOD<span>,</span>

    <span>/** 标明该注解可以用于参数声明 */</span>
    PARAMETER<span>,</span>

    <span>/** 标明注解可以用于构造函数声明 */</span>
    CONSTRUCTOR<span>,</span>

    <span>/** 标明注解可以用于局部变量声明 */</span>
    LOCAL_VARIABLE<span>,</span>

    <span>/** 标明注解可以用于注解声明(应用于另一个注解上)*/</span>
    ANNOTATION_TYPE<span>,</span>

    <span>/** 标明注解可以用于包声明 */</span>
    PACKAGE<span>,</span>

    <span>/**
     * 标明注解可以用于类型参数声明（1.8新加入）
     * @since 1.8
     */</span>
    TYPE_PARAMETER<span>,</span>

    <span>/**
     * 类型使用声明（1.8新加入)
     * @since 1.8
     */</span>
    TYPE_USE
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br></div></div><p><code>@Target</code>注解参数可以是数组，当注解未指定Target值时，则此注解可以用于任何元素之上，多个值使用{}包含并用逗号隔开，如：<code>{ ElementType.METHOD, ElementType.FIELD }</code></p>
<div><pre><code><span>// Java语言使用@interface语法来定义注解（Annotation）</span>
<span>// 参数表明此注解可以用在方法或字段上</span>
<span>@Target</span><span>(</span><span>{</span><span>ElementType</span><span>.</span>METHOD<span>,</span><span>ElementType</span><span>.</span>FIELD<span>}</span><span>)</span>
<span>public</span> <span>@interface</span> <span>MyAnnotation</span> <span>{</span>
    <span>.</span><span>.</span><span>.</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h3 id="retention"> @Retention</h3>
<p>Retention 的英文意为保留期的意思。当 @Retention 应用到一个注解上的时候，它解释说明了这个注解的的 <mark>生命周期</mark>。</p>
<p>它的取值如下：</p>
<ul>
<li><code>SOURCE</code>：注解将被编译器丢弃（该类型的注解信息只会保留在源码里，源码经过编译后，注解信息会被丢弃，不会保留在编译好的class文件里）</li>
<li><code>CLASS</code>：注解在class文件中可用，但会被VM丢弃（该类型的注解信息会保留在源码里和class文件里，在执行的时候，不会加载到虚拟机中），请注意，当注解未定义Retention值时，默认值是CLASS，如Java内置注解，@Override、@Deprecated、@SuppressWarnning等</li>
<li><code>RUNTIME</code>：注解信息将在运行期(JVM)也保留，因此可以通过反射机制读取注解的信息（源码、class文件和执行的时候都有注解的信息），如SpringMVC中的@Controller、@Autowired、@RequestMapping等。</li>
</ul>
<div><p>提示</p>
<p>如果<code>@Retention</code>不存在，则该<code>Annotation</code>默认为<code>CLASS</code>。</p>
<p>因为通常我们自定义的<code>Annotation</code>都是<code>RUNTIME</code>，所以，务必要加上<code>@Retention(RetentionPolicy.RUNTIME)</code>这个元注解</p>
</div>
<h3 id="repeatable"> @Repeatable</h3>
<p>Repeatable 自然是可重复的意思。@Repeatable 是 Java 1.8 才加进来的，所以算是一个新的特性。这个注解应用不是特别广泛。</p>
<p>Repeatable使用场景：在需要对同一种注解多次使用时，往往需要借助@Repeatable。</p>
<p>下面举例说明一下，在生活中一个人往往是具有多种身份，如果我把每种身份当成一种注解该如何使用</p>
<p>先声明一个Persons类用来包含所有的身份</p>
<div><pre><code><span>@Target</span><span>(</span><span>ElementType</span><span>.</span>TYPE<span>)</span> 
<span>@Retention</span><span>(</span><span>RetentionPolicy</span><span>.</span>RUNTIME<span>)</span>
<span>public</span> <span>@interface</span> <span>Persons</span> <span>{</span>
	<span>Person</span><span>[</span><span>]</span> <span>value</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>这里@Target是声明Persons注解的作用范围，参数ElementType.Type代表可以给一个类进行注解</p>
<p>@Retention是注解的有效时间，RetentionPolicy.RUNTIME是指程序运行的时候。</p>
<p>Person注解</p>
<div><pre><code><span>@Repeatable</span><span>(</span><span>Persons</span><span>.</span><span>class</span><span>)</span>
<span>public</span> <span>@interface</span> <span>Person</span><span>{</span>
	<span>String</span> <span>role</span><span>(</span><span>)</span> <span>default</span> <span>""</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>@Repeatable括号内的就相当于用来保存该注解内容的容器。</p>
<p>声明一个Man类，给该类加上一些身份。</p>
<div><pre><code><span>@Person</span><span>(</span>role<span>=</span><span>"CEO"</span><span>)</span>
<span>@Person</span><span>(</span>role<span>=</span><span>"husband"</span><span>)</span>
<span>@Person</span><span>(</span>role<span>=</span><span>"father"</span><span>)</span>
<span>public</span>   <span>class</span> <span>Man</span> <span>{</span>
	<span>String</span> name<span>=</span><span>""</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>在主方法中访问该注解。</p>
<div><pre><code><span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
    <span>Annotation</span><span>[</span><span>]</span> annotations <span>=</span> <span>Man</span><span>.</span><span>class</span><span>.</span><span>getAnnotations</span><span>(</span><span>)</span><span>;</span>  
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>annotations<span>.</span>length<span>)</span><span>;</span>
    <span>Persons</span> p<span>=</span><span>(</span><span>Persons</span><span>)</span> annotations<span>[</span><span>0</span><span>]</span><span>;</span>
    <span>for</span><span>(</span><span>Person</span> t<span>:</span>p<span>.</span><span>value</span><span>(</span><span>)</span><span>)</span><span>{</span>
    	<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>t<span>.</span><span>role</span><span>(</span><span>)</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>运行结果</p>
<div><pre><code><span>1</span>
CEO
husband
father
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id="inherited"> @Inherited</h3>
<p>@Inherited 可以让注解被继承，但这并不是真的继承，只是通过使用@Inherited，可以让子类Class对象使用getAnnotations()获取父类被@Inherited修饰的注解。<code>@Inherited</code>仅针对<code>@Target(ElementType.TYPE)</code>类型的<code>annotation</code>有效，并且仅针对<code>class</code>的继承，对<code>interface</code>的继承无效：</p>
<div><pre><code><span>package</span> <span>test</span><span>;</span>

<span>import</span> <span>java<span>.</span>lang<span>.</span>annotation<span>.</span></span><span>*</span><span>;</span>
<span>import</span> <span>java<span>.</span>util<span>.</span></span><span>Arrays</span><span>;</span>

<span>@Inherited</span>
<span>@Documented</span>
<span>@Target</span><span>(</span><span>ElementType</span><span>.</span>TYPE<span>)</span>
<span>@Retention</span><span>(</span><span>RetentionPolicy</span><span>.</span>RUNTIME<span>)</span>
<span>@interface</span> <span>DocumentA</span> <span>{</span>
<span>}</span>

<span>@Target</span><span>(</span><span>ElementType</span><span>.</span>TYPE<span>)</span>
<span>@Retention</span><span>(</span><span>RetentionPolicy</span><span>.</span>RUNTIME<span>)</span>
<span>@interface</span> <span>DocumentB</span> <span>{</span>
<span>}</span>

<span>@DocumentA</span>
<span>class</span> <span>A</span><span>{</span> <span>}</span>

<span>class</span> <span>B</span> <span>extends</span> <span>A</span><span>{</span> <span>}</span>

<span>@DocumentB</span>
<span>class</span> <span>C</span><span>{</span> <span>}</span>

<span>class</span> <span>D</span> <span>extends</span> <span>C</span><span>{</span> <span>}</span>

<span>/**
 * 测试
 */</span>
<span>public</span> <span>class</span> <span>DocumentedTest</span> <span>{</span>

    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>.</span><span>.</span><span>.</span> args<span>)</span><span>{</span>
        <span>B</span> b <span>=</span> <span>new</span> <span>B</span><span>(</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"使用了@Inherited注解:"</span><span>+</span> <span>Arrays</span><span>.</span><span>toString</span><span>(</span>b<span>.</span><span>getClass</span><span>(</span><span>)</span><span>.</span><span>getAnnotations</span><span>(</span><span>)</span><span>)</span><span>)</span><span>;</span>

        <span>D</span> d <span>=</span> <span>new</span> <span>D</span><span>(</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"没有使用@Inherited注解:"</span><span>+</span><span>Arrays</span><span>.</span><span>toString</span><span>(</span>d<span>.</span><span>getClass</span><span>(</span><span>)</span><span>.</span><span>getAnnotations</span><span>(</span><span>)</span><span>)</span><span>)</span><span>;</span>
    <span>}</span>

    <span>/**
     运行结果:
     使用了@Inherited注解:[@test.DocumentA()]
     没有使用@Inherited注解:[]
     */</span>
<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br></div></div><h3 id="documented"> @Documented</h3>
<p>顾名思义，这个元注解肯定是和文档有关。它的作用是能够将注解中的元素包含到 Javadoc 中去。</p>
<p>如果使用@Documented标注了，在生成javadoc的时候就会把@Documented注解给显示出来。</p>
<p>@Documented注解只是用来做标识，没什么实际作用，了解就好。</p>
<p>（一）类上添加注解@DocumentA、@DocumentB</p>
<div><pre><code><span>/**
 * 测试
 */</span>
<span>@DocumentA</span>
<span>@DocumentB</span>
<span>public</span> <span>class</span> <span>DocumentedTest</span> <span>{</span>

    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>.</span><span>.</span><span>.</span> args<span>)</span><span>{</span>
        <span>B</span> b <span>=</span> <span>new</span> <span>B</span><span>(</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"使用了@Inherited注解:"</span><span>+</span> <span>Arrays</span><span>.</span><span>toString</span><span>(</span>b<span>.</span><span>getClass</span><span>(</span><span>)</span><span>.</span><span>getAnnotations</span><span>(</span><span>)</span><span>)</span><span>)</span><span>;</span>

        <span>D</span> d <span>=</span> <span>new</span> <span>D</span><span>(</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"没有使用@Inherited注解:"</span><span>+</span><span>Arrays</span><span>.</span><span>toString</span><span>(</span>d<span>.</span><span>getClass</span><span>(</span><span>)</span><span>.</span><span>getAnnotations</span><span>(</span><span>)</span><span>)</span><span>)</span><span>;</span>
    <span>}</span>

    <span>/**
     运行结果:
     使用了@Inherited注解:[@test.DocumentA()]
     没有使用@Inherited注解:[]
     */</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><p>（二）执行命令 javadoc  DocumentedTest.java</p>
<p>生成的文档：</p>
<p><img src="./assets/java-01.png" alt=""></p>
<h2 id="五、注解属性及其数据类型"> 五、注解属性及其数据类型</h2>
<h3 id="一-注解的属性"> （一）注解的属性</h3>
<p>注解的属性也叫做成员变量。注解只有成员变量，没有方法。注解的成员变量在注解的定义中以“无形参的方法”形式来声明，其方法名定义了该成员变量的名字，其返回值定义了该成员变量的类型。</p>
<p>@Test内部没有定义其他元素，所以@Test也称为标记注解（marker annotation），但在自定义注解中，一般都会包含一些元素以表示某些值，方便处理器使用。</p>
<div><pre><code><span>@Target</span><span>(</span><span>ElementType</span><span>.</span>TYPE<span>)</span><span>//只能应用于类上</span>
<span>@Retention</span><span>(</span><span>RetentionPolicy</span><span>.</span>RUNTIME<span>)</span><span>//保存到运行时</span>
<span>public</span> <span>@interface</span> <span>MyAnnotation</span> <span>{</span>
    <span>int</span> <span>id</span><span>(</span><span>)</span> <span>default</span> <span>0</span><span>;</span>
    <span>String</span> <span>name</span><span>(</span><span>)</span> <span>default</span> <span>""</span><span>;</span> <span>//注解元素 String类型</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>上面代码定义了 @TestAnnotation 这个注解中拥有 id 和 msg 两个属性。在使用的时候，我们应该给它们进行赋值。</p>
<div><pre><code><span>@MyAnnotation</span><span>(</span>id<span>=</span><span>3</span><span>,</span> name<span>=</span><span>"hello annotation"</span><span>)</span>
<span>public</span> <span>class</span> <span>Test</span> <span>{</span>

<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id="二-注解的数据类型"> （二）注解的数据类型</h3>
<p><strong>注解支持的元素数据类型</strong>：</p>
<ul>
<li>所有基本类型（int,float,boolean,byte,double,char,long,short）</li>
<li>String</li>
<li>Class</li>
<li>enum</li>
<li>Annotation</li>
<li>上述类型的数组</li>
</ul>
<p>倘若使用了其他数据类型，编译器将会丢出一个编译错误，注意，声明注解元素时可以使用基本类型但不允许使用任何包装类型，同时还应该注意到注解也可以作为元素的类型，也就是嵌套注解，下面的代码演示了上述类型的使用过程：</p>
<div><pre><code><span>package</span> <span>com<span>.</span>zejian<span>.</span>annotationdemo</span><span>;</span>

<span>import</span> <span>java<span>.</span>lang<span>.</span>annotation<span>.</span></span><span>ElementType</span><span>;</span>
<span>import</span> <span>java<span>.</span>lang<span>.</span>annotation<span>.</span></span><span>Retention</span><span>;</span>
<span>import</span> <span>java<span>.</span>lang<span>.</span>annotation<span>.</span></span><span>RetentionPolicy</span><span>;</span>
<span>import</span> <span>java<span>.</span>lang<span>.</span>annotation<span>.</span></span><span>Target</span><span>;</span>

<span>/**
 * 数据类型使用Demo
 */</span>

<span>@Target</span><span>(</span><span>ElementType</span><span>.</span>TYPE<span>)</span>
<span>@Retention</span><span>(</span><span>RetentionPolicy</span><span>.</span>RUNTIME<span>)</span>
<span>@interface</span> <span>Reference</span><span>{</span>
    <span>boolean</span> <span>next</span><span>(</span><span>)</span> <span>default</span> <span>false</span><span>;</span>
<span>}</span>

<span>public</span> <span>@interface</span> <span>AnnotationElementDemo</span> <span>{</span>
    <span>//枚举类型</span>
    <span>enum</span> <span>Status</span> <span>{</span>FIXED<span>,</span>NORMAL<span>}</span><span>;</span>

    <span>//声明枚举</span>
    <span>Status</span> <span>status</span><span>(</span><span>)</span> <span>default</span> <span>Status</span><span>.</span>FIXED<span>;</span>

    <span>//布尔类型</span>
    <span>boolean</span> <span>showSupport</span><span>(</span><span>)</span> <span>default</span> <span>false</span><span>;</span>

    <span>//String类型</span>
    <span>String</span> <span>name</span><span>(</span><span>)</span><span>default</span> <span>""</span><span>;</span>

    <span>//class类型</span>
    <span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> <span>testCase</span><span>(</span><span>)</span> <span>default</span> <span>Void</span><span>.</span><span>class</span><span>;</span>

    <span>//注解嵌套</span>
    <span>Reference</span> <span>reference</span><span>(</span><span>)</span> <span>default</span> <span>@Reference</span><span>(</span>next<span>=</span><span>true</span><span>)</span><span>;</span>

    <span>//数组类型</span>
    <span>long</span><span>[</span><span>]</span> <span>value</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br></div></div><h2 id="六、编译器对默认值的限制"> 六、编译器对默认值的限制</h2>
<p>编译器对元素的默认值有些过分挑剔。首先，元素不能有不确定的值。也就是说，元素必须要么具有默认值，要么在使用注解时提供元素的值。其次，对于非基本类型的元素，无论是在源代码中声明，还是在注解接口中定义默认值，都不能以null作为值，这就是限制，没有什么利用可言，但造成一个元素的存在或缺失状态，因为每个注解的声明中，所有的元素都存在，并且都具有相应的值，为了绕开这个限制，只能定义一些特殊的值，例如空字符串或负数，表示某个元素不存在。</p>
<h2 id="七、注解不支持继承"> 七、注解不支持继承</h2>
<p>注解是不支持继承的，因此不能使用关键字extends来继承某个@interface，但注解在编译后，编译器会自动继承java.lang.annotation.Annotation接口，这里我们反编译前面定义的MyAnnotation注解</p>
<div><pre><code><span>package</span> <span>com<span>.</span>zejian<span>.</span>annotationdemo</span><span>;</span>

<span>import</span> <span>java<span>.</span>lang<span>.</span>annotation<span>.</span></span><span>Annotation</span><span>;</span>
<span>//反编译后的代码</span>
<span>public</span> <span>interface</span> <span>MyAnnotation</span> <span>extends</span> <span>Annotation</span>
<span>{</span>
    <span>public</span> <span>abstract</span> <span>String</span> <span>name</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>虽然反编译后发现MyAnnotation注解继承了Annotation接口，请记住，即使Java的接口可以实现多继承，但定义注解时依然无法使用extends关键字继承@interface。</p>
<h2 id="八、自定义注解"> 八、自定义注解</h2>
<p>由于@Test内部没有定义其他元素，所以@Test也称为标记注解（marker annotation），但在自定义注解中，一般都会包含一些元素以表示某些值，方便处理器使用，</p>
<h3 id="第一步-用-interface定义注解"> 第一步，用<code>@interface</code>定义注解：</h3>
<div><pre><code><span>public</span> <span>@interface</span> <span>MyAnnotation</span> <span>{</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h3 id="第二步-添加参数、默认值"> 第二步，添加参数、默认值：</h3>
<div><pre><code><span>public</span> <span>@interface</span> <span>MyAnnotation</span> <span>{</span>
    <span>int</span> <span>type</span><span>(</span><span>)</span> <span>default</span> <span>0</span><span>;</span>
    <span>String</span> <span>level</span><span>(</span><span>)</span> <span>default</span> <span>"info"</span><span>;</span>
    <span>String</span> <span>value</span><span>(</span><span>)</span> <span>default</span> <span>""</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>注解的参数类似无参数方法，可以用<code>default</code>设定一个默认值（强烈推荐）。把最常用的参数定义为<code>value()</code>，推荐所有参数都尽量设置默认值。</p>
<h3 id="第三步-用元注解配置注解"> 第三步，用元注解配置注解：</h3>
<div><pre><code><span>@Target</span><span>(</span><span>ElementType</span><span>.</span>TYPE<span>)</span>
<span>@Retention</span><span>(</span><span>RetentionPolicy</span><span>.</span>RUNTIME<span>)</span>
<span>public</span> <span>@interface</span> <span>MyAnnotation</span> <span>{</span>
    <span>int</span> <span>type</span><span>(</span><span>)</span> <span>default</span> <span>0</span><span>;</span>
    <span>String</span> <span>level</span><span>(</span><span>)</span> <span>default</span> <span>"info"</span><span>;</span>
    <span>String</span> <span>value</span><span>(</span><span>)</span> <span>default</span> <span>""</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>其中，必须设置<code>@Target</code>和<code>@Retention</code>，<code>@Retention</code>一般设置为<code>RUNTIME</code>，因为我们自定义的注解通常要求在运行期读取。一般情况下，不必写<code>@Inherited</code>和<code>@Repeatable</code>。</p>
<div><p>小结</p>
<ul>
<li>Java使用<code>@interface</code>定义注解;</li>
<li>可定义多个参数和默认值，核心参数使用<code>value</code>名称；</li>
<li>必须设置<code>@Target</code>来指定<code>Annotation</code>可以应用的范围；</li>
<li>应当设置<code>@Retention(RetentionPolicy.RUNTIME)</code>便于运行期读取该<code>Annotation</code>。</li>
</ul>
</div>
<h2 id="九、快捷方式"> 九、快捷方式</h2>
<p>所谓的快捷方式就是注解中定义了名为value的元素，并且在使用该注解时，如果该元素是唯一需要赋值的一个元素，那么此时无需使用key=value的语法，而只需在括号内给出value元素所需的值即可。这可以应用于任何合法类型的元素，记住，这限制了 <mark>元素名必须为value</mark>，<strong>推荐设置默认值</strong>，简单案例如下</p>
<div><pre><code><span>package</span> <span>com<span>.</span>zejian<span>.</span>annotationdemo</span><span>;</span>

<span>import</span> <span>java<span>.</span>lang<span>.</span>annotation<span>.</span></span><span>ElementType</span><span>;</span>
<span>import</span> <span>java<span>.</span>lang<span>.</span>annotation<span>.</span></span><span>Retention</span><span>;</span>
<span>import</span> <span>java<span>.</span>lang<span>.</span>annotation<span>.</span></span><span>RetentionPolicy</span><span>;</span>
<span>import</span> <span>java<span>.</span>lang<span>.</span>annotation<span>.</span></span><span>Target</span><span>;</span>

<span>//定义注解</span>
<span>@Target</span><span>(</span><span>ElementType</span><span>.</span>FIELD<span>)</span>
<span>@Retention</span><span>(</span><span>RetentionPolicy</span><span>.</span>RUNTIME<span>)</span>
<span>@interface</span> <span>IntegerVaule</span><span>{</span>
    <span>int</span> <span>value</span><span>(</span><span>)</span> <span>default</span> <span>0</span><span>;</span>
    <span>String</span> <span>name</span><span>(</span><span>)</span> <span>default</span> <span>""</span><span>;</span>
<span>}</span>

<span>//使用注解</span>
<span>public</span> <span>class</span> <span>QuicklyWay</span> <span>{</span>

    <span>//当只想给value赋值时,可以使用以下快捷方式</span>
    <span>@IntegerVaule</span><span>(</span><span>20</span><span>)</span>
    <span>public</span> <span>int</span> age<span>;</span>

    <span>//当name也需要赋值时必须采用key=value的方式赋值</span>
    <span>@IntegerVaule</span><span>(</span>value <span>=</span> <span>10000</span><span>,</span>name <span>=</span> <span>"MONEY"</span><span>)</span>
    <span>public</span> <span>int</span> money<span>;</span>

<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div><h2 id="十、使用注解"> 十、使用注解</h2>
<h3 id="一-注解的声明"> （一）注解的声明</h3>
<ol>
<li>定义一个可以注解在Class，interface，enum上的注解</li>
<li>定义一个可以注解在METHOD上的注解</li>
<li>定义一个可以注解在FIELD上的注解</li>
<li>定义一个可以注解在PARAMETER上的注解</li>
</ol>
<div><pre><code><span>@Target</span><span>(</span><span>ElementType</span><span>.</span>TYPE<span>)</span>
<span>@Retention</span><span>(</span><span>RetentionPolicy</span><span>.</span>RUNTIME<span>)</span>
<span>public</span> <span>@interface</span> <span>MyAnTargetType</span> <span>{</span>

    <span>/**
     * 定义注解的一个元素 并给定默认值
     * @return
     */</span>
    <span>String</span> <span>value</span><span>(</span><span>)</span> <span>default</span> <span>"定义在类、接口、枚举类上的注解元素value的默认值"</span><span>;</span>

<span>}</span>
<span>@Target</span><span>(</span><span>{</span><span>ElementType</span><span>.</span>METHOD<span>}</span><span>)</span>
<span>@Retention</span><span>(</span><span>RetentionPolicy</span><span>.</span>RUNTIME<span>)</span>
<span>public</span> <span>@interface</span> <span>MyAnTargetMethod</span> <span>{</span>

    <span>/**
     * 定义注解的一个元素 并给定默认值
     * @return
     */</span>
    <span>String</span> <span>value</span><span>(</span><span>)</span> <span>default</span> <span>"定义在方法上的注解元素value的默认值"</span><span>;</span>

<span>}</span>
<span>@Target</span><span>(</span><span>{</span><span>ElementType</span><span>.</span>FIELD<span>}</span><span>)</span>
<span>@Retention</span><span>(</span><span>RetentionPolicy</span><span>.</span>RUNTIME<span>)</span>
<span>public</span> <span>@interface</span> <span>MyAnTargetField</span> <span>{</span>

    <span>/**
     * 定义注解的一个元素 并给定默认值
     * @return
     */</span>
    <span>String</span> <span>value</span><span>(</span><span>)</span> <span>default</span> <span>"定义在字段上的注解元素value的默认值"</span><span>;</span>

<span>}</span>
<span>@Target</span><span>(</span><span>{</span><span>ElementType</span><span>.</span>PARAMETER<span>}</span><span>)</span>
<span>@Retention</span><span>(</span><span>RetentionPolicy</span><span>.</span>RUNTIME<span>)</span>
<span>public</span> <span>@interface</span> <span>MyAnTargetParameter</span> <span>{</span>

    <span>/**
     * 定义注解的一个元素 并给定默认值
     * @return
     */</span>
    <span>String</span> <span>value</span><span>(</span><span>)</span> <span>default</span> <span>"定义在参数上的注解元素value的默认值"</span><span>;</span>

<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br></div></div><h3 id="二-注解的读取"> （二）注解的读取</h3>
<p>因为注解定义后也是一种<code>class</code>，所有的注解都继承自<code>java.lang.annotation.Annotation</code>，因此，读取注解，需要使用反射API。</p>
<p><strong>Java提供的使用反射API读取<code>Annotation</code>的方法包括</strong>：</p>
<p>（1）判断某个注解是否存在于<code>Class</code>、<code>Field</code>、<code>Method</code>或<code>Constructor</code>：</p>
<ul>
<li><code>Class.isAnnotationPresent(Class)</code></li>
<li><code>Field.isAnnotationPresent(Class)</code></li>
<li><code>Method.isAnnotationPresent(Class)</code></li>
<li><code>Constructor.isAnnotationPresent(Class)</code></li>
</ul>
<p>（2）使用反射API读取Annotation：</p>
<ul>
<li><code>Class.getAnnotation(Class)</code></li>
<li><code>Field.getAnnotation(Class)</code></li>
<li><code>Method.getAnnotation(Class)</code></li>
<li><code>Constructor.getAnnotation(Class)</code></li>
</ul>
<p><strong>使用反射API读取<code>Annotation</code>有两种方法</strong>：</p>
<p>方法一：先判断<code>Annotation</code>是否存在，如果存在，就直接读取：</p>
<div><pre><code><span>Class</span> test <span>=</span> <span>Test</span><span>.</span><span>class</span><span>;</span>
<span>if</span> <span>(</span>cls<span>.</span><span>isAnnotationPresent</span><span>(</span><span>MyAnnotation</span><span>.</span><span>class</span><span>)</span><span>)</span> <span>{</span>
    <span>MyAnnotation</span> <span>MyAnnotation</span> <span>=</span> test<span>.</span><span>getAnnotation</span><span>(</span><span>MyAnnotation</span><span>.</span><span>class</span><span>)</span><span>;</span>
    <span>.</span><span>.</span><span>.</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>方法二：直接读取<code>Annotation</code>，如果<code>Annotation</code>不存在，将返回<code>null</code>：</p>
<div><pre><code><span>Class</span> test <span>=</span> <span>Test</span><span>.</span><span>class</span><span>;</span>
<span>MyAnnotation</span> <span>MyAnnotation</span> <span>=</span> test<span>.</span><span>getAnnotation</span><span>(</span><span>MyAnnotation</span><span>.</span><span>class</span><span>)</span><span>;</span>
<span>if</span> <span>(</span><span>MyAnnotation</span> <span>!=</span> <span>null</span><span>)</span> <span>{</span>
   <span>.</span><span>.</span><span>.</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>知道如何获取注解后可以接下来的测试了</p>
<div><pre><code><span>package</span> <span>test</span><span>;</span>

<span>import</span> <span>java<span>.</span>lang<span>.</span>annotation<span>.</span></span><span>Annotation</span><span>;</span>
<span>import</span> <span>java<span>.</span>lang<span>.</span>reflect<span>.</span></span><span>Method</span><span>;</span>

<span>@MyAnTargetType</span>
<span>public</span> <span>class</span> <span>AnnotationTest</span> <span>{</span>

    <span>@MyAnTargetField</span>
    <span>private</span> <span>String</span> field <span>=</span> <span>"我是字段"</span><span>;</span>

    <span>@MyAnTargetMethod</span><span>(</span><span>"测试方法"</span><span>)</span>
    <span>public</span> <span>void</span> <span>test</span><span>(</span><span>@MyAnTargetParameter</span> <span>String</span> args<span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"参数值 === "</span> <span>+</span> args<span>)</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>// 1、先获取Class实例</span>
        <span>Class</span><span><span>&lt;</span><span>AnnotationTest</span><span>></span></span> testClass <span>=</span> <span>AnnotationTest</span><span>.</span><span>class</span><span>;</span>

        <span>// 2、反射获取类上的注解MyAnTargetType</span>
        <span>MyAnTargetType</span> t <span>=</span> testClass<span>.</span><span>getAnnotation</span><span>(</span><span>MyAnTargetType</span><span>.</span><span>class</span><span>)</span><span>;</span>
        <span>if</span> <span>(</span>t <span>!=</span> <span>null</span><span>)</span><span>{</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"类上的注解值 === "</span> <span>+</span> t<span>.</span><span>value</span><span>(</span><span>)</span><span>)</span><span>;</span>
        <span>}</span>

        <span>MyAnTargetMethod</span> tm <span>=</span> <span>null</span><span>;</span>
        <span>try</span> <span>{</span>
            <span>// 3、反射获取AnnotationTest类上的test方法</span>
            <span>Method</span> method <span>=</span> testClass<span>.</span><span>getDeclaredMethod</span><span>(</span><span>"test"</span><span>,</span> <span>String</span><span>.</span><span>class</span><span>)</span><span>;</span>
            <span>// 获取方法上的注解MyAnTargetMethod</span>
            tm <span>=</span> method<span>.</span><span>getAnnotation</span><span>(</span><span>MyAnTargetMethod</span><span>.</span><span>class</span><span>)</span><span>;</span>
            <span>if</span> <span>(</span>tm <span>!=</span> <span>null</span><span>)</span><span>{</span>
                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"方法上的注解值 === "</span> <span>+</span> tm<span>.</span><span>value</span><span>(</span><span>)</span><span>)</span><span>;</span>
            <span>}</span>

            <span>// 4、获取方法上的所有参数注解  循环所有注解找到MyAnTargetParameter注解</span>
            <span>// 要读取方法参数的Annotation就比较麻烦一点，因为方法参数本身可以看成一个数组，</span>
            <span>// 而每个参数又可以定义多个注解，所以，一次获取方法参数的所有注解就必须用一个二维数组来表示。</span>
            <span>// 获取所有参数的Annotation:</span>
            <span>Annotation</span><span>[</span><span>]</span><span>[</span><span>]</span> annotations <span>=</span> method<span>.</span><span>getParameterAnnotations</span><span>(</span><span>)</span><span>;</span>
            <span>for</span> <span>(</span><span>Annotation</span><span>[</span><span>]</span> tt <span>:</span> annotations<span>)</span> <span>{</span>
                <span>for</span> <span>(</span><span>Annotation</span> t1 <span>:</span> tt<span>)</span> <span>{</span>
                    <span>if</span> <span>(</span>t1 <span>instanceof</span> <span>MyAnTargetParameter</span><span>)</span> <span>{</span>
                        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"参数上的注解值 === "</span> <span>+</span> <span>(</span><span>(</span><span>MyAnTargetParameter</span><span>)</span> t1<span>)</span><span>.</span><span>value</span><span>(</span><span>)</span><span>)</span><span>;</span>
                    <span>}</span>
                <span>}</span>
            <span>}</span>
            method<span>.</span><span>invoke</span><span>(</span><span>new</span> <span>AnnotationTest</span><span>(</span><span>)</span><span>,</span> <span>"改变默认参数"</span><span>)</span><span>;</span>
            <span>// 获取AnnotationTest类上字段field的注解MyAnTargetField</span>
            <span>MyAnTargetField</span> fieldAn <span>=</span> testClass<span>.</span><span>getDeclaredField</span><span>(</span><span>"field"</span><span>)</span><span>.</span><span>getAnnotation</span><span>(</span><span>MyAnTargetField</span><span>.</span><span>class</span><span>)</span><span>;</span>
            <span>if</span> <span>(</span>fieldAn <span>!=</span> <span>null</span><span>)</span><span>{</span>
                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"字段上的注解值 === "</span> <span>+</span> fieldAn<span>.</span><span>value</span><span>(</span><span>)</span><span>)</span><span>;</span>
            <span>}</span>
        <span>}</span> <span>catch</span> <span>(</span><span>Exception</span> e<span>)</span> <span>{</span>
            e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>

<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br></div></div><p>输出结果</p>
<div><pre><code>类上的注解值 === 定义在类接口枚举类上的注解元素value的默认值
方法上的注解值 === 测试方法
参数上的注解值 === 定义在参数上的注解元素value的默认值
参数值 === 改变默认参数
字段上的注解值 === 定义在字段上的注解元素value的默认值
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h3 id="四-注解的使用"> （四）注解的使用</h3>
<p>注解如何使用，完全由程序自己决定。例如，JUnit是一个测试框架，它会自动运行所有标记为<code>@Test</code>的方法。</p>
<p>我们来看一个<code>@Range</code>注解，我们希望用它来定义一个<code>String</code>字段的规则：字段长度满足<code>@Range</code>的参数定义：</p>
<div><pre><code><span>@Retention</span><span>(</span><span>RetentionPolicy</span><span>.</span>RUNTIME<span>)</span>
<span>@Target</span><span>(</span><span>ElementType</span><span>.</span>FIELD<span>)</span>
<span>public</span> <span>@interface</span> <span>Range</span> <span>{</span>
    <span>int</span> <span>min</span><span>(</span><span>)</span> <span>default</span> <span>0</span><span>;</span>
    <span>int</span> <span>max</span><span>(</span><span>)</span> <span>default</span> <span>255</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>在某个JavaBean中，我们可以使用该注解：</p>
<div><pre><code><span>public</span> <span>class</span> <span>Person</span> <span>{</span>
    <span>@Range</span><span>(</span>min<span>=</span><span>1</span><span>,</span> max<span>=</span><span>20</span><span>)</span>
    <span>public</span> <span>String</span> name<span>;</span>

    <span>@Range</span><span>(</span>max<span>=</span><span>10</span><span>)</span>
    <span>public</span> <span>String</span> city<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>但是，定义了注解，本身对程序逻辑没有任何影响。我们必须自己编写代码来使用注解。这里，我们编写一个<code>Person</code>实例的检查方法，它可以检查<code>Person</code>实例的<code>String</code>字段长度是否满足<code>@Range</code>的定义：</p>
<div><pre><code><span>void</span> <span>check</span><span>(</span><span>Person</span> person<span>)</span> <span>throws</span> <span>IllegalArgumentException</span><span>,</span> <span>ReflectiveOperationException</span> <span>{</span>
    <span>// 遍历所有Field:</span>
    <span>for</span> <span>(</span><span>Field</span> field <span>:</span> person<span>.</span><span>getClass</span><span>(</span><span>)</span><span>.</span><span>getFields</span><span>(</span><span>)</span><span>)</span> <span>{</span>
        <span>// 获取Field定义的@Range:</span>
        <span>Range</span> range <span>=</span> field<span>.</span><span>getAnnotation</span><span>(</span><span>Range</span><span>.</span><span>class</span><span>)</span><span>;</span>
        <span>// 如果@Range存在:</span>
        <span>if</span> <span>(</span>range <span>!=</span> <span>null</span><span>)</span> <span>{</span>
            <span>// 获取Field的值:</span>
            <span>Object</span> value <span>=</span> field<span>.</span><span>get</span><span>(</span>person<span>)</span><span>;</span>
            <span>// 如果值是String:</span>
            <span>if</span> <span>(</span>value <span>instanceof</span> <span>String</span><span>)</span> <span>{</span>
                <span>String</span> s <span>=</span> <span>(</span><span>String</span><span>)</span> value<span>;</span>
                <span>// 判断值是否满足@Range的min/max:</span>
                <span>if</span> <span>(</span>s<span>.</span><span>length</span><span>(</span><span>)</span> <span>&lt;</span> range<span>.</span><span>min</span><span>(</span><span>)</span> <span>||</span> s<span>.</span><span>length</span><span>(</span><span>)</span> <span>></span> range<span>.</span><span>max</span><span>(</span><span>)</span><span>)</span> <span>{</span>
                    <span>throw</span> <span>new</span> <span>IllegalArgumentException</span><span>(</span><span>"Invalid field: "</span> <span>+</span> field<span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>
                <span>}</span>
            <span>}</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><p>这样一来，我们通过<code>@Range</code>注解，配合<code>check()</code>方法，就可以完成<code>Person</code>实例的检查。注意检查逻辑完全是我们自己编写的，JVM不会自动给注解添加任何额外的逻辑。</p>
<h2 id="十一、annotation"> 十一、Annotation</h2>
<p>如果一来就看Annotation 架构可能就很懵逼了，但是学习了上面的相关知识再来看就很清晰了</p>
<p>Annotation接口中有下面这句话来描述注解：Annotation 是所有注解继承的公共接口</p>
<div><pre><code><span>The</span> common <span>interface</span> extended by all annotation types<span>.</span>
</code></pre>
<div><span>1</span><br></div></div><p>注解本质是一个继承了Annotation的特殊接口，其具体实现类是Java运行时生成的动态代理类。而我们通过反射获取注解时，返回的是Java运行时生成的动态代理对象$Proxy1。通过代理对象调用自定义注解（接口）的方法，会最终调用AnnotationInvocationHandler的invoke方法。该方法会从memberValues这个Map中索引出对应的值。而memberValues的来源是Java常量池。</p>
<h3 id="一-annotation-架构图"> （一）Annotation 架构图</h3>
<img src="./assets/java-03.png" style="zoom:80%;" />
<p>从图看出：</p>
<p>1、 <mark>所有注解本质上都继承自Annotation</mark></p>
<p>2、1 个 Annotation 和 1 个 RetentionPolicy 关联</p>
<ul>
<li>RetentionPolicy 是 Enum 枚举类型，它用来指定 Annotation 的策略。通俗点说，就是不同 RetentionPolicy 类型的 Annotation 的作用域不同</li>
<li>可以理解为：每1个Annotation对象，都会有唯一的RetentionPolicy属性</li>
</ul>
<p>3、 1 个 Annotation 和 1~n 个 ElementType 关联</p>
<ul>
<li>ElementType 是 Enum 枚举类型，它用来指定 Annotation 的类型</li>
<li>可以理解为：对于每 1 个 Annotation 对象，可以有若干个 ElementType 属性。</li>
</ul>
<h3 id="二-annotation-组成部分"> （二）Annotation 组成部分</h3>
<div><pre><code><span>//Annotation.java</span>

<span>package</span> <span>java<span>.</span>lang<span>.</span>annotation</span><span>;</span>
<span>public</span> <span>interface</span> <span>Annotation</span> <span>{</span>

    <span>boolean</span> <span>equals</span><span>(</span><span>Object</span> obj<span>)</span><span>;</span>

    <span>int</span> <span>hashCode</span><span>(</span><span>)</span><span>;</span>

    <span>String</span> <span>toString</span><span>(</span><span>)</span><span>;</span>

    <span>Class</span><span><span>&lt;</span><span>?</span> <span>extends</span> <span>Annotation</span><span>></span></span> <span>annotationType</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><div><pre><code><span>//ElementType.java</span>

<span>package</span> <span>java<span>.</span>lang<span>.</span>annotation</span><span>;</span>
<span>public</span> <span>enum</span> <span>ElementType</span> <span>{</span>
   <span>/**标明该注解可以用于类、接口（包括注解类型）或enum声明*/</span>
   TYPE<span>,</span>
 
   <span>/** 标明该注解可以用于字段(域)声明，包括enum实例 */</span>
   FIELD<span>,</span>
 
   <span>/** 标明该注解可以用于方法声明 */</span>
   METHOD<span>,</span>
 
   <span>/** 标明该注解可以用于参数声明 */</span>
   PARAMETER<span>,</span>
 
   <span>/** 标明注解可以用于构造函数声明 */</span>
   CONSTRUCTOR<span>,</span>
 
   <span>/** 标明注解可以用于局部变量声明 */</span>
   LOCAL_VARIABLE<span>,</span>
 
   <span>/** 标明注解可以用于注解声明(应用于另一个注解上)*/</span>
   ANNOTATION_TYPE<span>,</span>
 
   <span>/** 标明注解可以用于包声明 */</span>
   PACKAGE<span>,</span>
 
   <span>/**
    * 标明注解可以用于类型参数声明（1.8新加入）
    * @since 1.8
    */</span>
   TYPE_PARAMETER<span>,</span>
 
   <span>/**
    * 类型使用声明（1.8新加入)
    * @since 1.8
    */</span>
   TYPE_USE
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br></div></div><div><pre><code><span>//RetentionPolicy.java</span>

<span>package</span> <span>java<span>.</span>lang<span>.</span>annotation</span><span>;</span>
<span>public</span> <span>enum</span> <span>RetentionPolicy</span> <span>{</span>
   <span>/** Annotation信息仅存在于编译器处理期间，编译器处理完之后就没有该Annotation信息了 */</span>
    SOURCE<span>,</span>            

    <span>/** 编译器将Annotation存储于类对应的.class文件中。默认行为 */</span>
    CLASS<span>,</span>             

    <span>/** 编译器将Annotation存储于class文件中，并且可由JVM读入 */</span>
    RUNTIME           
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h2 id="十二、注解与反射机制"> 十二、注解与反射机制</h2>
<p>前面经过反编译后，我们知道Java所有注解都继承了Annotation接口，也就是说　Java使用Annotation接口代表注解元素，该接口是所有Annotation类型的父接口。同时为了运行时能准确获取到注解的相关信息，Java在java.lang.reflect 反射包下新增了AnnotatedElement接口，它主要用于表示目前正在 VM 中运行的程序中已使用注解的元素，通过该接口提供的方法可以利用反射技术地读取注解的信息，如反射包的Constructor类、Field类、Method类、Package类和Class类都实现了AnnotatedElement接口，它简要含义如下：</p>
<p>Class：类的Class对象定义</p>
<p>Constructor：代表类的构造器定义</p>
<p>Field：代表类的成员变量定义</p>
<p>Method：代表类的方法定义</p>
<p>Package：代表类的包定义</p>
<p>下面是AnnotatedElement中相关的API方法，以上5个类都实现以下的方法</p>
<table>
<thead>
<tr>
<th>返回值</th>
<th>方法名称</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>&lt;A extends Annotation&gt;</code></td>
<td><code>getAnnotation(Class&lt;A&gt; annotationClass)</code></td>
<td>该元素如果存在指定类型的注解，则返回这些注解，否则返回 null。</td>
</tr>
<tr>
<td><code>Annotation[]</code></td>
<td><code>getAnnotations()</code></td>
<td>返回此元素上存在的所有注解，包括从父类继承的</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>isAnnotationPresent(Class&lt;? extends Annotation&gt; annotationClass)</code></td>
<td>如果指定类型的注解存在于此元素上，则返回 true，否则返回 false。</td>
</tr>
<tr>
<td><code>Annotation[]</code></td>
<td><code>getDeclaredAnnotations()</code></td>
<td>返回直接存在于此元素上的所有注解，注意，不包括父类的注解，调用者可以随意修改返回的数组；这不会对其他调用者返回的数组产生任何影响，没有则返回长度为0的数组</td>
</tr>
</tbody>
</table>
<p>简单案例演示如下：</p>
<div><pre><code>
<span>//继承了A类</span>
<span>@DocumentB</span>
<span>public</span> <span>class</span> <span>DocumentDemo</span> <span>extends</span> <span>A</span><span>{</span>

    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>.</span><span>.</span><span>.</span> args<span>)</span><span>{</span>

        <span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> clazz <span>=</span> <span>DocumentDemo</span><span>.</span><span>class</span><span>;</span>
        <span>//根据指定注解类型获取该注解</span>
        <span>DocumentA</span> documentA<span>=</span>clazz<span>.</span><span>getAnnotation</span><span>(</span><span>DocumentA</span><span>.</span><span>class</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"A:"</span><span>+</span>documentA<span>)</span><span>;</span>

        <span>//获取该元素上的所有注解，包含从父类继承</span>
        <span>Annotation</span><span>[</span><span>]</span> an<span>=</span> clazz<span>.</span><span>getAnnotations</span><span>(</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"an:"</span><span>+</span> <span>Arrays</span><span>.</span><span>toString</span><span>(</span>an<span>)</span><span>)</span><span>;</span>
        <span>//获取该元素上的所有注解，但不包含继承！</span>
        <span>Annotation</span><span>[</span><span>]</span> an2<span>=</span>clazz<span>.</span><span>getDeclaredAnnotations</span><span>(</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"an2:"</span><span>+</span> <span>Arrays</span><span>.</span><span>toString</span><span>(</span>an2<span>)</span><span>)</span><span>;</span>

        <span>//判断注解DocumentA是否在该元素上</span>
        <span>boolean</span> b<span>=</span>clazz<span>.</span><span>isAnnotationPresent</span><span>(</span><span>DocumentA</span><span>.</span><span>class</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"b:"</span><span>+</span>b<span>)</span><span>;</span>

        <span>/**
         执行结果:
         A:@test.DocumentA()
         an:[@test.DocumentA(), @test.DocumentB()]
         an2:[@test.DocumentB()]
         b:true
         */</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br></div></div><h2 id="十三、运行时注解处理器"> 十三、运行时注解处理器</h2>
<p>了解完注解与反射的相关API后，现在通过一个实例来演示利用运行时注解来组装数据库SQL的构建语句的过程</p>
<div><pre><code><span>/**
 * 表注解
 */</span>
<span>@Target</span><span>(</span><span>ElementType</span><span>.</span>TYPE<span>)</span><span>//只能应用于类上</span>
<span>@Retention</span><span>(</span><span>RetentionPolicy</span><span>.</span>RUNTIME<span>)</span><span>//保存到运行时</span>
<span>public</span> <span>@interface</span> <span>DBTable</span> <span>{</span>
    <span>String</span> <span>name</span><span>(</span><span>)</span> <span>default</span> <span>""</span><span>;</span>
<span>}</span>


<span>/**
 * 注解Integer类型的字段
 */</span>
<span>@Target</span><span>(</span><span>ElementType</span><span>.</span>FIELD<span>)</span>
<span>@Retention</span><span>(</span><span>RetentionPolicy</span><span>.</span>RUNTIME<span>)</span>
<span>public</span> <span>@interface</span> <span>SQLInteger</span> <span>{</span>
    <span>//该字段对应数据库表列名</span>
    <span>String</span> <span>name</span><span>(</span><span>)</span> <span>default</span> <span>""</span><span>;</span>
    <span>//嵌套注解</span>
    <span>Constraints</span> <span>constraint</span><span>(</span><span>)</span> <span>default</span> <span>@Constraints</span><span>;</span>
<span>}</span>


<span>/**
 * 注解String类型的字段
 */</span>
<span>@Target</span><span>(</span><span>ElementType</span><span>.</span>FIELD<span>)</span>
<span>@Retention</span><span>(</span><span>RetentionPolicy</span><span>.</span>RUNTIME<span>)</span>
<span>public</span> <span>@interface</span> <span>SQLString</span> <span>{</span>

    <span>//对应数据库表的列名</span>
    <span>String</span> <span>name</span><span>(</span><span>)</span> <span>default</span> <span>""</span><span>;</span>

    <span>//列类型分配的长度，如varchar(30)的30</span>
    <span>int</span> <span>value</span><span>(</span><span>)</span> <span>default</span> <span>0</span><span>;</span>

    <span>Constraints</span> <span>constraint</span><span>(</span><span>)</span> <span>default</span> <span>@Constraints</span><span>;</span>
<span>}</span>


<span>/**
 * 约束注解
 */</span>

<span>@Target</span><span>(</span><span>ElementType</span><span>.</span>FIELD<span>)</span><span>//只能应用在字段上</span>
<span>@Retention</span><span>(</span><span>RetentionPolicy</span><span>.</span>RUNTIME<span>)</span>
<span>public</span> <span>@interface</span> <span>Constraints</span> <span>{</span>
    <span>//判断是否作为主键约束</span>
    <span>boolean</span> <span>primaryKey</span><span>(</span><span>)</span> <span>default</span> <span>false</span><span>;</span>
    <span>//判断是否允许为null</span>
    <span>boolean</span> <span>allowNull</span><span>(</span><span>)</span> <span>default</span> <span>false</span><span>;</span>
    <span>//判断是否唯一</span>
    <span>boolean</span> <span>unique</span><span>(</span><span>)</span> <span>default</span> <span>false</span><span>;</span>
<span>}</span>

<span>/**
 * 数据库表Member对应实例类bean
 */</span>
<span>@DBTable</span><span>(</span>name <span>=</span> <span>"MEMBER"</span><span>)</span>
<span>public</span> <span>class</span> <span>Member</span> <span>{</span>
    <span>//主键ID</span>
    <span>@SQLString</span><span>(</span>name <span>=</span> <span>"ID"</span><span>,</span>value <span>=</span> <span>50</span><span>,</span> constraint <span>=</span> <span>@Constraints</span><span>(</span>primaryKey <span>=</span> <span>true</span><span>)</span><span>)</span>
    <span>private</span> <span>String</span> id<span>;</span>

    <span>@SQLString</span><span>(</span>name <span>=</span> <span>"NAME"</span> <span>,</span> value <span>=</span> <span>30</span><span>)</span>
    <span>private</span> <span>String</span> name<span>;</span>

    <span>@SQLInteger</span><span>(</span>name <span>=</span> <span>"AGE"</span><span>)</span>
    <span>private</span> <span>int</span> age<span>;</span>

    <span>@SQLString</span><span>(</span>name <span>=</span> <span>"DESCRIPTION"</span> <span>,</span>value <span>=</span> <span>150</span> <span>,</span> constraint <span>=</span> <span>@Constraints</span><span>(</span>allowNull <span>=</span> <span>true</span><span>)</span><span>)</span>
    <span>private</span> <span>String</span> description<span>;</span><span>//个人描述</span>

   <span>//省略set get.....</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br></div></div><p>上述定义4个注解，分别是@DBTable(用于类上)、@Constraints(用于字段上)、 @SQLString(用于字段上)、@SQLString(用于字段上)并在Member类中使用这些注解，这些注解的作用的是用于帮助注解处理器生成创建数据库表MEMBER的构建语句，在这里有点需要注意的是，我们使用了嵌套注解@Constraints，该注解主要用于判断字段是否为null或者字段是否唯一。必须清楚认识到上述提供的注解生命周期必须为<code>@Retention(RetentionPolicy.RUNTIME)</code>，即运行时，这样才可以使用反射机制获取其信息。有了上述注解和使用，剩余的就是编写上述的注解处理器了，前面我们聊了很多注解，其处理器要么是Java自身已提供、要么是框架已提供的，我们自己都没有涉及到注解处理器的编写，但上述定义处理SQL的注解，其处理器必须由我们自己编写了，如下</p>
<div><pre><code><span>package</span> <span>test</span><span>;</span>
<span>import</span> <span>java<span>.</span>lang<span>.</span>annotation<span>.</span></span><span>Annotation</span><span>;</span>
<span>import</span> <span>java<span>.</span>lang<span>.</span>reflect<span>.</span></span><span>Field</span><span>;</span>
<span>import</span> <span>java<span>.</span>util<span>.</span></span><span>ArrayList</span><span>;</span>
<span>import</span> <span>java<span>.</span>util<span>.</span></span><span>List</span><span>;</span>

<span>/**
 * 运行时注解处理器，构造表创建语句
 */</span>
<span>public</span> <span>class</span> <span>TableCreator</span> <span>{</span>

  <span>public</span> <span>static</span> <span>String</span> <span>createTableSql</span><span>(</span><span>String</span> className<span>)</span> <span>throws</span> <span>ClassNotFoundException</span> <span>{</span>
    <span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> cl <span>=</span> <span>Class</span><span>.</span><span>forName</span><span>(</span>className<span>)</span><span>;</span>
    <span>DBTable</span> dbTable <span>=</span> cl<span>.</span><span>getAnnotation</span><span>(</span><span>DBTable</span><span>.</span><span>class</span><span>)</span><span>;</span>
    <span>//如果没有表注解，直接返回</span>
    <span>if</span><span>(</span>dbTable <span>==</span> <span>null</span><span>)</span> <span>{</span>
      <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>
              <span>"No DBTable annotations in class "</span> <span>+</span> className<span>)</span><span>;</span>
      <span>return</span> <span>null</span><span>;</span>
    <span>}</span>
    <span>String</span> tableName <span>=</span> dbTable<span>.</span><span>name</span><span>(</span><span>)</span><span>;</span>
    <span>// If the name is empty, use the Class name:</span>
    <span>if</span><span>(</span>tableName<span>.</span><span>length</span><span>(</span><span>)</span> <span>&lt;</span> <span>1</span><span>)</span>
      tableName <span>=</span> cl<span>.</span><span>getName</span><span>(</span><span>)</span><span>.</span><span>toUpperCase</span><span>(</span><span>)</span><span>;</span>
    <span>List</span><span><span>&lt;</span><span>String</span><span>></span></span> columnDefs <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>String</span><span>></span></span><span>(</span><span>)</span><span>;</span>
    <span>//通过Class类API获取到所有成员字段</span>
    <span>for</span><span>(</span><span>Field</span> field <span>:</span> cl<span>.</span><span>getDeclaredFields</span><span>(</span><span>)</span><span>)</span> <span>{</span>
      <span>String</span> columnName <span>=</span> <span>null</span><span>;</span>
      <span>//获取字段上的注解</span>
      <span>Annotation</span><span>[</span><span>]</span> anns <span>=</span> field<span>.</span><span>getDeclaredAnnotations</span><span>(</span><span>)</span><span>;</span>
      <span>if</span><span>(</span>anns<span>.</span>length <span>&lt;</span> <span>1</span><span>)</span>
        <span>continue</span><span>;</span> <span>// Not a db table column</span>

      <span>//判断注解类型</span>
      <span>if</span><span>(</span>anns<span>[</span><span>0</span><span>]</span> <span>instanceof</span> <span>SQLInteger</span><span>)</span> <span>{</span>
        <span>SQLInteger</span> sInt <span>=</span> <span>(</span><span>SQLInteger</span><span>)</span> anns<span>[</span><span>0</span><span>]</span><span>;</span>
        <span>//获取字段对应列名称，如果没有就是使用字段名称替代</span>
        <span>if</span><span>(</span>sInt<span>.</span><span>name</span><span>(</span><span>)</span><span>.</span><span>length</span><span>(</span><span>)</span> <span>&lt;</span> <span>1</span><span>)</span>
          columnName <span>=</span> field<span>.</span><span>getName</span><span>(</span><span>)</span><span>.</span><span>toUpperCase</span><span>(</span><span>)</span><span>;</span>
        <span>else</span>
          columnName <span>=</span> sInt<span>.</span><span>name</span><span>(</span><span>)</span><span>;</span>
        <span>//构建语句</span>
        columnDefs<span>.</span><span>add</span><span>(</span>columnName <span>+</span> <span>" INT"</span> <span>+</span>
                <span>getConstraints</span><span>(</span>sInt<span>.</span><span>constraint</span><span>(</span><span>)</span><span>)</span><span>)</span><span>;</span>
      <span>}</span>
      <span>//判断String类型</span>
      <span>if</span><span>(</span>anns<span>[</span><span>0</span><span>]</span> <span>instanceof</span> <span>SQLString</span><span>)</span> <span>{</span>
        <span>SQLString</span> sString <span>=</span> <span>(</span><span>SQLString</span><span>)</span> anns<span>[</span><span>0</span><span>]</span><span>;</span>
        <span>// Use field name if name not specified.</span>
        <span>if</span><span>(</span>sString<span>.</span><span>name</span><span>(</span><span>)</span><span>.</span><span>length</span><span>(</span><span>)</span> <span>&lt;</span> <span>1</span><span>)</span>
          columnName <span>=</span> field<span>.</span><span>getName</span><span>(</span><span>)</span><span>.</span><span>toUpperCase</span><span>(</span><span>)</span><span>;</span>
        <span>else</span>
          columnName <span>=</span> sString<span>.</span><span>name</span><span>(</span><span>)</span><span>;</span>
        columnDefs<span>.</span><span>add</span><span>(</span>columnName <span>+</span> <span>" VARCHAR("</span> <span>+</span>
                sString<span>.</span><span>value</span><span>(</span><span>)</span> <span>+</span> <span>")"</span> <span>+</span>
                <span>getConstraints</span><span>(</span>sString<span>.</span><span>constraint</span><span>(</span><span>)</span><span>)</span><span>)</span><span>;</span>
      <span>}</span>


    <span>}</span>
    <span>//数据库表构建语句</span>
    <span>StringBuilder</span> createCommand <span>=</span> <span>new</span> <span>StringBuilder</span><span>(</span>
            <span>"CREATE TABLE "</span> <span>+</span> tableName <span>+</span> <span>"("</span><span>)</span><span>;</span>
    <span>for</span><span>(</span><span>String</span> columnDef <span>:</span> columnDefs<span>)</span>
      createCommand<span>.</span><span>append</span><span>(</span><span>"\n    "</span> <span>+</span> columnDef <span>+</span> <span>","</span><span>)</span><span>;</span>

    <span>// Remove trailing comma</span>
    <span>String</span> tableCreate <span>=</span> createCommand<span>.</span><span>substring</span><span>(</span>
            <span>0</span><span>,</span> createCommand<span>.</span><span>length</span><span>(</span><span>)</span> <span>-</span> <span>1</span><span>)</span> <span>+</span> <span>");"</span><span>;</span>
    <span>return</span> tableCreate<span>;</span>
  <span>}</span>


    <span>/**
     * 判断该字段是否有其他约束
     * @param con
     * @return
     */</span>
  <span>private</span> <span>static</span> <span>String</span> <span>getConstraints</span><span>(</span><span>Constraints</span> con<span>)</span> <span>{</span>
    <span>String</span> constraints <span>=</span> <span>""</span><span>;</span>
    <span>if</span><span>(</span><span>!</span>con<span>.</span><span>allowNull</span><span>(</span><span>)</span><span>)</span>
      constraints <span>+=</span> <span>" NOT NULL"</span><span>;</span>
    <span>if</span><span>(</span>con<span>.</span><span>primaryKey</span><span>(</span><span>)</span><span>)</span>
      constraints <span>+=</span> <span>" PRIMARY KEY"</span><span>;</span>
    <span>if</span><span>(</span>con<span>.</span><span>unique</span><span>(</span><span>)</span><span>)</span>
      constraints <span>+=</span> <span>" UNIQUE"</span><span>;</span>
    <span>return</span> constraints<span>;</span>
  <span>}</span>

  <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>
    <span>String</span><span>[</span><span>]</span> arg<span>=</span><span>{</span><span>"test.Member"</span><span>}</span><span>;</span>
    <span>for</span><span>(</span><span>String</span> className <span>:</span> arg<span>)</span> <span>{</span>
      <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"Table Creation SQL for "</span> <span>+</span>
              className <span>+</span> <span>" is :\n"</span> <span>+</span> <span>createTableSql</span><span>(</span>className<span>)</span><span>)</span><span>;</span>
    <span>}</span>

    <span>/**
     * 输出结果：
     Table Creation SQL for test.Member is :
     CREATE TABLE MEMBER(
     ID VARCHAR(50) NOT NULL PRIMARY KEY,
     NAME VARCHAR(30) NOT NULL,
     AGE INT NOT NULL,
     DESCRIPTION VARCHAR(150)
     );
     */</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br><span>96</span><br><span>97</span><br><span>98</span><br><span>99</span><br><span>100</span><br><span>101</span><br><span>102</span><br><span>103</span><br><span>104</span><br><span>105</span><br><span>106</span><br><span>107</span><br><span>108</span><br></div></div><p>如果对反射比较熟悉的同学，上述代码就相对简单了，我们通过传递Member的全路径后通过Class.forName()方法获取到Member的class对象，然后利用Class对象中的方法获取所有成员字段Field，最后利用<code>field.getDeclaredAnnotations()</code>遍历每个Field上的注解再通过注解的类型判断来构建建表的SQL语句。这便是利用注解结合反射来构建SQL语句的简单的处理器模型，是否已回想起Hibernate？</p>
<h2 id="十四、java-8中注解增强"> 十四、Java 8中注解增强</h2>
<h3 id="一-元注解-repeatable"> （一）元注解@Repeatable</h3>
<p>元注解@Repeatable是JDK1.8新加入的，它表示在同一个位置重复相同的注解。在没有该注解前，一般是无法在同一个类型上使用相同的注解的</p>
<div><pre><code><span>//Java8前无法这样使用</span>
<span>@FilterPath</span><span>(</span><span>"/web/update"</span><span>)</span>
<span>@FilterPath</span><span>(</span><span>"/web/add"</span><span>)</span>
<span>public</span> <span>class</span> <span>A</span> <span>{</span>
    
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>Java8前如果是想实现类似的功能，我们需要在定义@FilterPath注解时定义一个数组元素接收多个值如下</p>
<div><pre><code><span>@Target</span><span>(</span><span>ElementType</span><span>.</span>TYPE<span>)</span>
<span>@Retention</span><span>(</span><span>RetentionPolicy</span><span>.</span>RUNTIME<span>)</span>
<span>public</span> <span>@interface</span> <span>FilterPath</span> <span>{</span>
    <span>String</span> <span>[</span><span>]</span> <span>value</span><span>(</span><span>)</span><span>;</span>
<span>}</span>

<span>//使用</span>
<span>@FilterPath</span><span>(</span><span>{</span><span>"/update"</span><span>,</span><span>"/add"</span><span>}</span><span>)</span>
<span>public</span> <span>class</span> <span>A</span> <span>{</span> 
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>但在Java8新增了@Repeatable注解后就可以采用如下的方式定义并使用了</p>
<div><pre><code><span>//使用Java8新增@Repeatable原注解</span>
<span>@Target</span><span>(</span><span>{</span><span>ElementType</span><span>.</span>TYPE<span>,</span><span>ElementType</span><span>.</span>FIELD<span>,</span><span>ElementType</span><span>.</span>METHOD<span>}</span><span>)</span>
<span>@Retention</span><span>(</span><span>RetentionPolicy</span><span>.</span>RUNTIME<span>)</span>
<span>@Repeatable</span><span>(</span><span>FilterPaths</span><span>.</span><span>class</span><span>)</span><span>//参数指明接收的注解class</span>
<span>public</span> <span>@interface</span> <span>FilterPath</span> <span>{</span>
    <span>String</span>  <span>value</span><span>(</span><span>)</span><span>;</span>
<span>}</span>

<span>@Target</span><span>(</span><span>ElementType</span><span>.</span>TYPE<span>)</span>
<span>@Retention</span><span>(</span><span>RetentionPolicy</span><span>.</span>RUNTIME<span>)</span>
<span>@interface</span> <span>FilterPaths</span> <span>{</span>
    <span>FilterPath</span><span>[</span><span>]</span> <span>value</span><span>(</span><span>)</span><span>;</span>
<span>}</span>

<span>//使用案例</span>
<span>@FilterPath</span><span>(</span><span>"/web/update"</span><span>)</span>
<span>@FilterPath</span><span>(</span><span>"/web/add"</span><span>)</span>
<span>@FilterPath</span><span>(</span><span>"/web/delete"</span><span>)</span>
<span>class</span> <span>A</span><span>{</span> 
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><p>我们可以简单理解为通过使用@Repeatable后，将使用@FilterPaths注解作为接收同一个类型上重复注解的容器，而每个@FilterPath则负责保存指定的路径串。</p>
<p>为了处理上述的新增注解，Java8还在<code>AnnotatedElement</code>接口新增了<code>getDeclaredAnnotationsByType()</code>和 <code>getAnnotationsByType()</code>两个方法并在接口给出了默认实现，在指定@Repeatable的注解时，可以通过这两个方法获取到注解相关信息。</p>
<p>但请注意:</p>
<ul>
<li>旧版API中的getDeclaredAnnotation()和 getAnnotation()是不对@Repeatable注解的处理的(除非该注解没有在同一个声明上重复出现)。</li>
<li>getDeclaredAnnotationsByType方法获取到的注解不包括父类，其实当 getAnnotationsByType()方法调用时，其内部先执行了getDeclaredAnnotationsByType方法，只有当前类不存在指定注解时，getAnnotationsByType()才会继续从其父类寻找，但请注意如果@FilterPath和@FilterPaths没有使用了@Inherited的话，仍然无法获取。下面通过代码来演示：</li>
</ul>
<div><pre><code>
<span>//使用Java8新增@Repeatable原注解</span>
<span>@Target</span><span>(</span><span>{</span><span>ElementType</span><span>.</span>TYPE<span>,</span><span>ElementType</span><span>.</span>FIELD<span>,</span><span>ElementType</span><span>.</span>METHOD<span>}</span><span>)</span>
<span>@Retention</span><span>(</span><span>RetentionPolicy</span><span>.</span>RUNTIME<span>)</span>
<span>@Repeatable</span><span>(</span><span>FilterPaths</span><span>.</span><span>class</span><span>)</span>
<span>public</span> <span>@interface</span> <span>FilterPath</span> <span>{</span>
    <span>String</span>  <span>value</span><span>(</span><span>)</span><span>;</span>
<span>}</span>


<span>@Target</span><span>(</span><span>ElementType</span><span>.</span>TYPE<span>)</span>
<span>@Retention</span><span>(</span><span>RetentionPolicy</span><span>.</span>RUNTIME<span>)</span>
<span>@interface</span> <span>FilterPaths</span> <span>{</span>
    <span>FilterPath</span><span>[</span><span>]</span> <span>value</span><span>(</span><span>)</span><span>;</span>
<span>}</span>

<span>@FilterPath</span><span>(</span><span>"/web/list"</span><span>)</span>
<span>class</span> <span>C</span> <span>{</span> <span>}</span>

<span>//使用案例</span>
<span>@FilterPath</span><span>(</span><span>"/web/update"</span><span>)</span>
<span>@FilterPath</span><span>(</span><span>"/web/add"</span><span>)</span>
<span>@FilterPath</span><span>(</span><span>"/web/delete"</span><span>)</span>
<span>class</span> <span>A</span> <span>extends</span> <span>C</span><span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>

        <span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> clazz <span>=</span> <span>A</span><span>.</span><span>class</span><span>;</span>
        <span>//通过getAnnotationsByType方法获取所有重复注解</span>
        <span>FilterPath</span><span>[</span><span>]</span> annotationsByType <span>=</span> clazz<span>.</span><span>getAnnotationsByType</span><span>(</span><span>FilterPath</span><span>.</span><span>class</span><span>)</span><span>;</span>
        <span>FilterPath</span><span>[</span><span>]</span> annotationsByType2 <span>=</span> clazz<span>.</span><span>getDeclaredAnnotationsByType</span><span>(</span><span>FilterPath</span><span>.</span><span>class</span><span>)</span><span>;</span>
        <span>if</span> <span>(</span>annotationsByType <span>!=</span> <span>null</span><span>)</span> <span>{</span>
            <span>for</span> <span>(</span><span>FilterPath</span> filter <span>:</span> annotationsByType<span>)</span> <span>{</span>
                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"1:"</span><span>+</span>filter<span>.</span><span>value</span><span>(</span><span>)</span><span>)</span><span>;</span>
            <span>}</span>
        <span>}</span>

        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"-----------------"</span><span>)</span><span>;</span>

        <span>if</span> <span>(</span>annotationsByType2 <span>!=</span> <span>null</span><span>)</span> <span>{</span>
            <span>for</span> <span>(</span><span>FilterPath</span> filter <span>:</span> annotationsByType2<span>)</span> <span>{</span>
                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"2:"</span><span>+</span>filter<span>.</span><span>value</span><span>(</span><span>)</span><span>)</span><span>;</span>
            <span>}</span>
        <span>}</span>


        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"使用getAnnotation的结果:"</span><span>+</span>clazz<span>.</span><span>getAnnotation</span><span>(</span><span>FilterPath</span><span>.</span><span>class</span><span>)</span><span>)</span><span>;</span>


        <span>/**
         * 执行结果(当前类拥有该注解FilterPath,则不会从C父类寻找)
         1:/web/update
         1:/web/add
         1:/web/delete
         -----------------
         2:/web/update
         2:/web/add
         2:/web/delete
         使用getAnnotation的结果:null
         */</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br></div></div><p>从执行结果来看如果当前类拥有该注解@FilterPath,则getAnnotationsByType方法不会从C父类寻找，下面看看另外一种情况，即A类上没有@FilterPath注解</p>
<div><pre><code>
<span>//使用Java8新增@Repeatable原注解</span>
<span>@Target</span><span>(</span><span>{</span><span>ElementType</span><span>.</span>TYPE<span>,</span><span>ElementType</span><span>.</span>FIELD<span>,</span><span>ElementType</span><span>.</span>METHOD<span>}</span><span>)</span>
<span>@Retention</span><span>(</span><span>RetentionPolicy</span><span>.</span>RUNTIME<span>)</span>
<span>@Inherited</span> <span>//添加可继承元注解</span>
<span>@Repeatable</span><span>(</span><span>FilterPaths</span><span>.</span><span>class</span><span>)</span>
<span>public</span> <span>@interface</span> <span>FilterPath</span> <span>{</span>
    <span>String</span>  <span>value</span><span>(</span><span>)</span><span>;</span>
<span>}</span>


<span>@Target</span><span>(</span><span>ElementType</span><span>.</span>TYPE<span>)</span>
<span>@Retention</span><span>(</span><span>RetentionPolicy</span><span>.</span>RUNTIME<span>)</span>
<span>@Inherited</span> <span>//添加可继承元注解</span>
<span>@interface</span> <span>FilterPaths</span> <span>{</span>
    <span>FilterPath</span><span>[</span><span>]</span> <span>value</span><span>(</span><span>)</span><span>;</span>
<span>}</span>

<span>@FilterPath</span><span>(</span><span>"/web/list"</span><span>)</span>
<span>@FilterPath</span><span>(</span><span>"/web/getList"</span><span>)</span>
<span>class</span> <span>C</span> <span>{</span> <span>}</span>

<span>//A上不使用@FilterPath注解,getAnnotationsByType将会从父类查询</span>
<span>class</span> <span>A</span> <span>extends</span> <span>C</span><span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>

        <span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> clazz <span>=</span> <span>A</span><span>.</span><span>class</span><span>;</span>
        <span>//通过getAnnotationsByType方法获取所有重复注解</span>
        <span>FilterPath</span><span>[</span><span>]</span> annotationsByType <span>=</span> clazz<span>.</span><span>getAnnotationsByType</span><span>(</span><span>FilterPath</span><span>.</span><span>class</span><span>)</span><span>;</span>
        <span>FilterPath</span><span>[</span><span>]</span> annotationsByType2 <span>=</span> clazz<span>.</span><span>getDeclaredAnnotationsByType</span><span>(</span><span>FilterPath</span><span>.</span><span>class</span><span>)</span><span>;</span>
        <span>if</span> <span>(</span>annotationsByType <span>!=</span> <span>null</span><span>)</span> <span>{</span>
            <span>for</span> <span>(</span><span>FilterPath</span> filter <span>:</span> annotationsByType<span>)</span> <span>{</span>
                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"1:"</span><span>+</span>filter<span>.</span><span>value</span><span>(</span><span>)</span><span>)</span><span>;</span>
            <span>}</span>
        <span>}</span>

        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"-----------------"</span><span>)</span><span>;</span>

        <span>if</span> <span>(</span>annotationsByType2 <span>!=</span> <span>null</span><span>)</span> <span>{</span>
            <span>for</span> <span>(</span><span>FilterPath</span> filter <span>:</span> annotationsByType2<span>)</span> <span>{</span>
                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"2:"</span><span>+</span>filter<span>.</span><span>value</span><span>(</span><span>)</span><span>)</span><span>;</span>
            <span>}</span>
        <span>}</span>


        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"使用getAnnotation的结果:"</span><span>+</span>clazz<span>.</span><span>getAnnotation</span><span>(</span><span>FilterPath</span><span>.</span><span>class</span><span>)</span><span>)</span><span>;</span>


        <span>/**
         * 执行结果(当前类没有@FilterPath,getAnnotationsByType方法从C父类寻找)
         1:/web/list
         1:/web/getList
         -----------------
         使用getAnnotation的结果:null
         */</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br></div></div><p>注意定义@FilterPath和@FilterPath时必须指明@Inherited，getAnnotationsByType方法否则依旧无法从父类获取@FilterPath注解，这是为什么呢，不妨看看getAnnotationsByType方法的实现源码：</p>
<div><pre><code><span>//接口默认实现方法</span>
<span>default</span> <span><span>&lt;</span><span>T</span> <span>extends</span> <span>Annotation</span><span>></span></span> <span>T</span><span>[</span><span>]</span> <span>getAnnotationsByType</span><span>(</span><span>Class</span><span><span>&lt;</span><span>T</span><span>></span></span> annotationClass<span>)</span> <span>{</span>
<span>//先调用getDeclaredAnnotationsByType方法</span>
<span>T</span><span>[</span><span>]</span> result <span>=</span> <span>getDeclaredAnnotationsByType</span><span>(</span>annotationClass<span>)</span><span>;</span>

<span>//判断当前类获取到的注解数组是否为0</span>
<span>if</span> <span>(</span>result<span>.</span>length <span>==</span> <span>0</span> <span>&amp;&amp;</span> <span>this</span> <span>instanceof</span> <span>Class</span> <span>&amp;&amp;</span> 
<span>//判断定义注解上是否使用了@Inherited元注解 </span>
 <span>AnnotationType</span><span>.</span><span>getInstance</span><span>(</span>annotationClass<span>)</span><span>.</span><span>isInherited</span><span>(</span><span>)</span><span>)</span> <span>{</span> <span>// Inheritable</span>
        <span>//从父类获取</span>
       <span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> superClass <span>=</span> <span>(</span><span>(</span><span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span><span>)</span> <span>this</span><span>)</span><span>.</span><span>getSuperclass</span><span>(</span><span>)</span><span>;</span>
   <span>if</span> <span>(</span>superClass <span>!=</span> <span>null</span><span>)</span> <span>{</span>
      result <span>=</span> superClass<span>.</span><span>getAnnotationsByType</span><span>(</span>annotationClass<span>)</span><span>;</span>
       <span>}</span>
   <span>}</span>

   <span>return</span> result<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><h3 id="二-新增的两种elementtype"> （二）新增的两种ElementType</h3>
<p>在Java8中 ElementType 新增两个枚举成员，TYPE_PARAMETER 和 TYPE_USE ，在Java8前注解只能标注在一个声明(如字段、类、方法)上，Java8后，新增的TYPE_PARAMETER可以用于标注类型参数，而TYPE_USE则可以用于标注任意类型(不包括class)。如下所示</p>
<div><pre><code><span>//TYPE_PARAMETER 标注在类型参数上</span>
<span>class</span> <span>D</span><span>&lt;</span><span>@Parameter</span> <span>T</span><span>></span> <span>{</span> <span>}</span>

<span>//TYPE_USE则可以用于标注任意类型(不包括class)</span>
<span>//用于父类或者接口</span>
<span>class</span> <span>Image</span> <span>implements</span> <span>@Rectangular</span> <span>Shape</span> <span>{</span> <span>}</span>

<span>//用于构造函数</span>
<span>new</span> <span>@Path</span> <span>String</span><span>(</span><span>"/usr/bin"</span><span>)</span>

<span>//用于强制转换和instanceof检查,注意这些注解中用于外部工具，它们不会对类型转换或者instanceof的检查行为带来任何影响。</span>
<span>String</span> path<span>=</span><span>(</span><span>@Path</span> <span>String</span><span>)</span>input<span>;</span>
<span>if</span><span>(</span>input <span>instanceof</span> <span>@Path</span> <span>String</span><span>)</span>

<span>//用于指定异常</span>
<span>public</span> <span>Person</span> <span>read</span><span>(</span><span>)</span> <span>throws</span> <span>@Localized</span> <span>IOException</span><span>.</span>

<span>//用于通配符绑定</span>
<span>List</span><span>&lt;</span><span>@ReadOnly</span> <span>?</span> <span>extends</span> <span>Person</span><span>></span>
<span>List</span><span>&lt;</span><span>?</span> <span>extends</span> <span>@ReadOnly</span> <span>Person</span><span>></span>

<span>@NotNull</span> <span>String</span><span>.</span><span>class</span> <span>//非法，不能标注class</span>
<span>import</span> <span>java<span>.</span>lang<span>.</span></span>@<span>NotNull</span> <span>String</span> <span>//非法，不能标注</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><p>这里主要说明一下TYPE_USE，类型注解用来支持在Java的程序中做强类型检查，配合第三方插件工具（如Checker Framework），可以在编译期检测出runtime error（如UnsupportedOperationException、NullPointerException异常），避免异常延续到运行期才发现，从而提高代码质量，这就是类型注解的主要作用。</p>
<p>总之Java 8 新增加了两个注解的元素类型ElementType.TYPE_USE 和ElementType.TYPE_PARAMETER ，通过它们，我们可以把注解应用到各种新场合中。</p>
<div><p>参考</p>
<p><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1255945389098144" target="_blank" rel="noopener noreferrer">廖雪峰Java教程 - 注解</a></p>
<p><a href="https://www.runoob.com/w3cnote/java-annotation.html" target="_blank" rel="noopener noreferrer">菜鸟教程 - 注解</a></p>
<p><a href="https://blog.csdn.net/javazejian/article/details/71860633?ops_request_misc=%25257B%252522request%25255Fid%252522%25253A%252522161283974716780262542169%252522%25252C%252522scm%252522%25253A%25252220140713.130102334..%252522%25257D&amp;request_id=161283974716780262542169&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-4-71860633.pc_search_result_no_baidu_js&amp;utm_term=java%25E6%25B3%25A8%25E8%25A7%25A3" target="_blank" rel="noopener noreferrer">zejian的博客</a></p>
</div>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <category term="Java"/>
    <contributor>
      <name>南辞</name>
    </contributor>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">JavaSE-集合</title>
    <id>http://qiqi.dreamagain.top/program/backend/java/collection/</id>
    <link href="http://qiqi.dreamagain.top/program/backend/java/collection/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <summary type="html"><![CDATA[<blockquote>
<p><img src="https://img.shields.io/badge/collection-blue.svg" alt=""> <img src="https://img.shields.io/badge/List-blue.svg" alt=""> <img src="https://img.shields.io/badge/Set-blue.svg" alt=""> <img src="https://img.shields.io/badge/Map-blue.svg" alt=""></p>
</blockquote>
]]></summary>
    <content type="html"><![CDATA[<blockquote>
<p><img src="https://img.shields.io/badge/collection-blue.svg" alt=""> <img src="https://img.shields.io/badge/List-blue.svg" alt=""> <img src="https://img.shields.io/badge/Set-blue.svg" alt=""> <img src="https://img.shields.io/badge/Map-blue.svg" alt="">
</p>
</blockquote>
<h2 id="集合概要"> 集合概要</h2>
<p>Java的<code>java.util</code>包主要提供了以下三种类型的集合（也可以叫作容器，用来存储对象）</p>
<ul>
<li><code>List</code>：一种有序列表的集合</li>
<li><code>Set</code>：一种保证没有重复元素的集合</li>
<li><code>Map</code>：一种通过键值（key-value）查找的映射表集合</li>
</ul>
<p>Java集合的设计有几个特点：</p>
<ol>
<li>
<p>一是实现了接口和实现类相分离，例如，有序表的接口是<code>List</code>，具体的实现类有<code>ArrayList</code>，<code>LinkedList</code>等，</p>
</li>
<li>
<p>二是支持泛型，我们可以限制在一个集合中只能放入同一种数据类型的元素，如：</p>
<div><pre><code><span>List</span><span><span>&lt;</span><span>String</span><span>></span></span> list <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span> <span>// 只能放入String类型</span>
</code></pre>
<div><span>1</span><br></div></div></li>
<li>
<p>三是Java访问集合总是通过统一的方式——迭代器（Iterator）来实现，它最明显的好处在于无需知道集合内部元素是按什么方式存储</p>
</li>
</ol>
<div><p>提示</p>
<p>由于Java的集合设计非常久远，中间经历过大规模改进，我们要注意到有一小部分集合类是遗留类，不应该继续使用：</p>
<ul>
<li><code>Hashtable</code>：一种线程安全的<code>Map</code>实现；</li>
<li><code>Vector</code>：一种线程安全的<code>List</code>实现；</li>
<li><code>Stack</code>：基于<code>Vector</code>实现的<code>LIFO</code>的栈。</li>
</ul>
<p>还有一小部分接口是遗留接口，也不应该继续使用：</p>
<ul>
<li><code>Enumeration&lt;E&gt;</code>：已被<code>Iterator&lt;E&gt;</code>取代。</li>
</ul>
</div>
<h2 id="泛型"> 泛型</h2>
<p>泛型是JDK1.5以后增加的，它可以帮助我们建立类型安全的集合。在使用了泛型的集合中，遍历时不必进行强制类型转换。JDK提供了支持泛型的编译器，将运行时的类型检查提前到了编译时执行，提高了代码可读性和安全性。</p>
<p>泛型的本质就是“数据类型的参数化”。 我们可以把“泛型”理解为数据类型的一个占位符(形式参数)，即告诉编译器，在调用泛型时必须传入实际类型。</p>
<p>为了能够更好的学习集合，建议先学习<strong>泛型</strong>。</p>
<ul>
<li><a href="./generics.html">Java泛型学习笔记</a></li>
<li><a href="https://www.w3cschool.cn/java/java-generics.html" target="_blank" rel="noopener noreferrer">w3cschool教程</a></li>
</ul>
<h2 id="collection接口"> Collection接口</h2>
<p>Collection 表示一组对象，它是集中、收集的意思。Collection接口是List、Set接口的父接口，也就是List、Set都包含Collection中的方法，可以在List、Set接口的实现类中进行测试。</p>
<p>Collection的功能:</p>
<p>1、添加功能</p>
<p><code>boolean add (objcet obj)</code>:添加一个元素</p>
<p><code>boolean addAll(Collection c)</code>:添加一个集合的元素</p>
<p>2、删除功能:</p>
<p><code>void clear ()</code>:清除所有的元素</p>
<p><code>boolean remove (object)</code>:移除一个元素</p>
<p><code>boolean removeAll(Collection c)</code>:移除本集合和集合c中都包含的元素</p>
<p>3、判断功能:</p>
<p><code>boolean contains (0bject o)</code>:判断集合是否包含该元素</p>
<p><code>boolean containsAll(Collection c)</code>:判断集合中是否包含指定的集合元素，只有包含所有的元素,才叫包含</p>
<p><code>boolean isEmpty()</code>:判断集合是否为空</p>
<p>4、获取功能:</p>
<p><code>Iterator&lt;E&gt;iterator()</code>:迭代器</p>
<p><code>Object[] toArray()</code>:转化成Object数组</p>
<p>5、长度功能:</p>
<p><code>int size()</code>:元素的个数</p>
<p>6、交集功能:</p>
<p><code>boolean retainAll(Collection c)</code>:取本集合和集合c都包含的元素</p>
<p>Collection 类图（工作中需要掌握一些常用的集合类就行了）</p>
<h2 id="list接口及其实现类"> List接口及其实现类</h2>
<p>List是有序、可重复的容器。</p>
<p><strong>有序</strong>：List中每个元素都有索引标记。可以根据元素的索引标记(在List中的位置)访问元素，从而精确控制这些元素。</p>
<p><strong>可重复</strong>：List允许加入重复的元素。更确切地讲，List通常允许满足 e1.equals(e2) 的元素重复加入容器。</p>
<p>除了Collection接口中的方法，List多了一些跟顺序(索引)有关的方法</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>void add (int index, Object element)</td>
<td>在指定位置插入元素，以前元素全部后移一位</td>
</tr>
<tr>
<td>Object set (int index,Object element)</td>
<td>修改指定位置的元素</td>
</tr>
<tr>
<td>Object get (int index)</td>
<td>返回指定位置的元素</td>
</tr>
<tr>
<td>Object remove (int index)</td>
<td>删除指定位置的元素，后面元素全部前移一位</td>
</tr>
<tr>
<td>int indexOf (Object o)</td>
<td>返回第一个匹配元素的索引，如果没有该元素，返回-1.</td>
</tr>
<tr>
<td>int lastIndexOf (Object o)</td>
<td>返回最后一个匹配元素的索引，如果没有该元素，返回-1</td>
</tr>
</tbody>
</table>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <category term="Java"/>
    <contributor>
      <name>南辞</name>
    </contributor>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">JavaSE-泛型</title>
    <id>http://qiqi.dreamagain.top/program/backend/java/generics/</id>
    <link href="http://qiqi.dreamagain.top/program/backend/java/generics/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<h2 id="一、前言"> 一、前言</h2>
<p>Java 泛型（Generic）的引入加强了参数类型的安全性，减少了类型的转换，但有一点需要注意：Java 的泛型在编译器有效，在运行期被删除，也就是说所有泛型参数类型在编译后都会被清除掉，看下面一个列子，代码如下：</p>
<div><pre><code><span>public</span> <span>class</span> <span>Foo</span> <span>{</span>
    <span>public</span> <span>void</span> <span>listMethod</span><span>(</span><span>List</span><span><span>&lt;</span><span>String</span><span>></span></span> stringList<span>)</span><span>{</span>
    <span>}</span>
    <span>public</span> <span>void</span> <span>listMethod</span><span>(</span><span>List</span><span><span>&lt;</span><span>Integer</span><span>></span></span> intList<span>)</span> <span>{</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>代码很简单，看起来没什么问题，但是编译器却报出如下错误信息：</p>
<div><pre><code><span>Method</span> <span>listMethod</span><span>(</span><span>List</span><span><span>&lt;</span><span>String</span><span>></span></span><span>)</span> has the same erasure <span>listMethod</span><span>(</span><span>List</span><span><span>&lt;</span><span>E</span><span>></span></span><span>)</span> as another method in type <span>Foo</span>
</code></pre>
<div><span>1</span><br></div></div><p>此错误的意思是说<code>listMethod(List&lt;String&gt;)</code>方法在编译时擦除类型后的方法是<code>listMethod(List&lt;E&gt;)</code>，它与另外一个方法重复，也就是方法签名重复。反编译之后的方法代码如下：</p>
<div><pre><code><span>public</span> <span>void</span> <span>listMethod</span><span>(</span><span>List</span> list<span>)</span><span>{</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>从上面代码可以看出 Java 编译后的字节码中已经没有泛型的任何信息，在编译后所有的泛型类型都会做相应的转化，转化如下：</p>
<ul>
<li><code>List&lt;String&gt;</code>、<code>List&lt;T&gt;</code>擦除后的类型为 List。</li>
<li><code>List&lt;String&gt;</code>、<code>List&lt;T&gt;[]</code> 擦除后的类型为 List[]。</li>
<li><code>List&lt;? extends E&gt;、List&lt;? super E&gt;</code> 擦除后的类型为 <code>List&lt;E&gt;</code>。</li>
<li><code>List&lt;T extends Serialzable &amp; Cloneable&gt;</code> 擦除后类型为 <code>List&lt;Serializable&gt;</code>。</li>
</ul>
<p>Java 为什么这么处理呢？有以下两个原因：</p>
<p>避免 JVM 的大换血（如果 JVM 将泛型类型延续到运行期，那么到运行期时 JVM 就需要进行大量的重构工作了），提高了运行期的效率。  版本兼容。 在编译期擦除可以更好地支持原生类型（Raw Type）。</p>
<p>明白了 Java 泛型是类型擦除的，下面的问题就很好理解了：</p>
<h2 id="二、使用泛型注意点"> 二、使用泛型注意点</h2>
<h3 id="一-泛型的-class-对象是相同的"> （一）泛型的 class 对象是相同的</h3>
<p>每个类都有一个 class 属性，泛型化不会改变 class 属性的返回值，例如：</p>
<div><pre><code><span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
	<span>List</span><span><span>&lt;</span><span>String</span><span>></span></span> ls <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>String</span><span>></span></span><span>(</span><span>)</span><span>;</span>
	<span>List</span><span><span>&lt;</span><span>Integer</span><span>></span></span> li <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>Integer</span><span>></span></span><span>(</span><span>)</span><span>;</span>
	<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>ls<span>.</span><span>getClass</span><span>(</span><span>)</span> <span>==</span> li<span>.</span><span>getClass</span><span>(</span><span>)</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>代码返回值为 true，原因很简单，<code>List&lt;String&gt;</code> 和<code>List&lt;Integer&gt;</code> 擦除后的类型都是 List。</p>
<h3 id="二-泛型数组初始化时不能声明泛型类型"> （二）泛型数组初始化时不能声明泛型类型</h3>
<p>如下代码编译时通不过：</p>
<div><pre><code><span>List</span><span><span>&lt;</span><span>String</span><span>></span></span><span>[</span><span>]</span> list <span>=</span> <span>new</span> <span>List</span><span><span>&lt;</span><span>String</span><span>></span></span><span>[</span><span>]</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div><p>在这里可以声明一个带有泛型参数的数组，但是不能初始化该数组，因为执行了类型擦除操作后，<code>List&lt;Object&gt;[]</code>与 <code>List&lt;String&gt;[]</code>就是同一回事了，编译器拒绝如此声明。</p>
<h3 id="三-instanceof-不允许存在泛型参数"> （三）instanceof 不允许存在泛型参数</h3>
<p>以下代码不能通过编译，原因一样，泛型类型被擦除了。</p>
<div><pre><code><span>List</span><span><span>&lt;</span><span>String</span><span>></span></span> list <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>String</span><span>></span></span><span>(</span><span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>list <span>instanceof</span> <span>List</span><span><span>&lt;</span><span>String</span><span>></span></span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>错误信息如下：<br>
<code>Cannot perform instanceof check against parameterized type List&lt;String&gt;. Use the form List&lt;?&gt; instead since further generic type information will be erased at runtime</code></p>
<h2 id="三、类型擦除"> 三、类型擦除</h2>
<p>正确理解泛型概念的首要前提是理解类型擦除（type erasure）。 Java中的泛型基本上都是在编译器这个层次来实现的。在生成的Java字节代码中是不包含泛型中的类型信息的。使用泛型的时候加上的类型参数，会被编译器在编译的时候去掉。这个过程就称为类型擦除。</p>
<p>如在代码中定义的<code>List&lt;Object&gt;</code>和<code>List&lt;String&gt;</code>等类型，在编译之后都会变成List。JVM看到的只是List，而由泛型附加的类型信息对JVM来说是不可见的。Java编译器会在编译时尽可能的发现可能出错的地方，但是仍然无法避免在运行时刻出现类型转换异常的情况。类型擦除也是Java的泛型实现方式与<a href="http://www.cplusplus.com/doc/tutorial/templates/" target="_blank" rel="noopener noreferrer">C++模板机制</a>实现方式之间的重要区别。</p>
<p>很多泛型的奇怪特性都与这个类型擦除的存在有关，包括：</p>
<ul>
<li>泛型类并没有自己独有的Class类对象。比如并不存在<code>List&lt;String&gt;.class</code>或是<code>List&lt;Integer&gt;.class</code>，而只有<code>List.class</code>。</li>
<li>静态变量是被泛型类的所有实例所共享的。对于声明为<code>MyClass&lt;T&gt;</code>的类，访问其中的静态变量的方法仍然是 <code>MyClass.myStaticVar</code>。不管是通过<code>new MyClass&lt;String&gt;</code>还是<code>new MyClass&lt;Integer&gt;</code>创建的对象，都是共享一个静态变量。</li>
<li><mark>泛型的类型参数不能用在Java异常处理的catch语句中。因为异常处理是由JVM在运行时刻来进行的。由于类型信息被擦除，JVM是无法区分两个异常类型<code>MyException&lt;String&gt;</code>和<code>MyException&lt;Integer&gt;</code>的。对于JVM来说，它们都是 MyException类型的。也就无法执行与异常对应的catch语句。</mark></li>
</ul>
<p>类型擦除的基本过程也比较简单，首先是找到用来替换类型参数的具体类。这个具体类一般是Object。如果指定了类型参数的上界的话，则使用这个上界。把代码中的类型参数都替换成具体的类。同时去掉出现的类型声明，即去掉<code>&lt;&gt;</code>的内容。比如<code>T get()</code>方法声明就变成了<code>Object get()</code>；<code>List&lt;String&gt;</code>就变成了List。接下来就可能需要生成一些桥接方法<code>（bridge method）</code>。这是由于擦除了类型之后的类可能缺少某些必须的方法。比如考虑下面的代码：</p>
<div><pre><code><span>class</span> <span>MyString</span> <span>implements</span> <span>Comparable</span><span><span>&lt;</span><span>String</span><span>></span></span> <span>{</span>
    <span>public</span> <span>int</span> <span>compareTo</span><span>(</span><span>String</span> str<span>)</span> <span>{</span>        
        <span>return</span> <span>0</span><span>;</span>    
    <span>}</span>
<span>}</span> 
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>当类型信息被擦除之后，上述类的声明变成了<code>class MyString implements Comparable</code>。但是这样的话，类MyString就会有编译错误，因为没有实现接口Comparable声明的<code>String compareTo(Object)</code>方法。这个时候就由编译器来动态生成这个方法。</p>
<h3 id="一-实例分析"> （一）实例分析</h3>
<p>了解了类型擦除机制之后，就会明白编译器承担了全部的类型检查工作。编译器禁止某些泛型的使用方式，正是为了确保类型的安全性。以上面提到的<code>List&lt;Object&gt;</code>和<code>List&lt;String&gt;</code>为例来具体分析：</p>
<div><pre><code><span>public</span> <span>void</span> <span>inspect</span><span>(</span><span>List</span><span><span>&lt;</span><span>Object</span><span>></span></span> list<span>)</span> <span>{</span>    
    <span>for</span> <span>(</span><span>Object</span> obj <span>:</span> list<span>)</span> <span>{</span>        
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>obj<span>)</span><span>;</span>    
    <span>}</span>    
    list<span>.</span><span>add</span><span>(</span><span>1</span><span>)</span><span>;</span> <span>//这个操作在当前方法的上下文是合法的。 </span>
<span>}</span>
<span>public</span> <span>void</span> <span>test</span><span>(</span><span>)</span> <span>{</span>    
    <span>List</span><span><span>&lt;</span><span>String</span><span>></span></span> strs <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>String</span><span>></span></span><span>(</span><span>)</span><span>;</span>    
    <span>inspect</span><span>(</span>strs<span>)</span><span>;</span> <span>//编译错误 </span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>这段代码中，inspect方法接受<code>List&lt;Object&gt;</code>作为参数，当在test方法中试图传入<code>List&lt;String&gt;</code>的时候，会出现编译错误。假设这样的做法是允许的，那么在inspect方法就可以通过list.add(1)来向集合中添加一个数字。这样在test方法看来，其声明为<code>List&lt;String&gt;</code>的集合中却被添加了一个Integer类型的对象。这显然是违反类型安全的原则的，在某个时候肯定会抛出<a href="http://download.oracle.com/javase/1.5.0/docs/api/java/lang/ClassCastException.html" target="_blank" rel="noopener noreferrer">ClassCastException</a>。因此，编译器禁止这样的行为。编译器会尽可能的检查可能存在的类型安全问题。对于确定是违反相关原则的地方，会给出编译错误。当编译器无法判断类型的使用是否正确的时候，会给出警告信息。</p>
<h3 id="二-通配符与上下界"> （二）通配符与上下界</h3>
<p>在使用泛型类的时候，既可以指定一个具体的类型，如：</p>
<p><code>List&lt;String&gt;</code>就声明了具体的类型是String；也可以用通配符<code>?</code>来表示未知类型，如<code>List&lt;?&gt;</code>就声明了List中包含的元素类型是未知的。 通配符所代表的其实是一组类型，但具体的类型是未知的。<code>List&lt;?&gt;</code>所声明的就是所有类型都是可以的。但是<code>List&lt;?&gt;</code>并不等同于<code>List&lt;Object&gt;</code>。<code>List&lt;Object&gt;</code>实际上确定了List中包含的是Object及其子类，在使用的时候都可以通过Object来进行引用。而<code>List&lt;?&gt;</code>则其中所包含的元素类型是不确定。其中可能包含的是String，也可能是 Integer。如果它包含了String的话，往里面添加Integer类型的元素就是错误的。正因为类型未知，就不能通过<code>new ArrayList&lt;?&gt;()</code>的方法来创建一个新的ArrayList对象。因为编译器无法知道具体的类型是什么。但是对于<code>List&lt;?&gt;</code>中的元素确总是可以用Object来引用的，因为虽然类型未知，但肯定是Object及其子类。考虑下面的代码：</p>
<div><pre><code><span>public</span> <span>void</span> <span>wildcard</span><span>(</span><span>List</span><span><span>&lt;</span><span>?</span><span>></span></span> list<span>)</span> <span>{</span>
    list<span>.</span><span>add</span><span>(</span><span>1</span><span>)</span><span>;</span><span>//编译错误 </span>
<span>}</span> 
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>如上所示，试图对一个带通配符的泛型类进行操作的时候，总是会出现编译错误。其原因在于通配符所表示的类型是未知的。</p>
<p>因为对于<code>List&lt;?&gt;</code>中的元素只能用Object来引用，在有些情况下不是很方便。在这些情况下，<mark>可以使用上下界来限制未知类型的范围。</mark> 如<code>List&lt;? extends Number&gt;</code>说明List中可能包含的元素类型是Number及其子类。而<code>List&lt;? super Number&gt;</code>则说明List中包含的是Number及其父类。当引入了上界之后，在使用类型的时候就可以使用上界类中定义的方法。比如访问 <code>List&lt;? extends Number&gt;</code>的时候，就可以使用Number类的intValue等方法。</p>
<h3 id="三-类型系统"> （三）类型系统</h3>
<p>在Java中，大家比较熟悉的是通过继承机制而产生的类型体系结构。比如String继承自Object。根据<a href="http://en.wikipedia.org/wiki/Liskov_substitution_principle" target="_blank" rel="noopener noreferrer">Liskov替换原则</a>，子类是可以替换父类的。当需要Object类的引用的时候，如果传入一个String对象是没有任何问题的。但是反过来的话，即用父类的引用替换子类引用的时候，就需要进行强制类型转换。编译器并不能保证运行时刻这种转换一定是合法的。这种自动的子类替换父类的类型转换机制，对于数组也是适用的。 String[]可以替换Object[]。但是泛型的引入，对于这个类型系统产生了一定的影响。正如前面提到的<code>List&lt;String&gt;</code>是不能替换掉<code>List&lt;Object&gt;</code>的。</p>
<p>引入泛型之后的类型系统增加了两个维度：一个是类型参数自身的继承体系结构，另外一个是泛型类或接口自身的继承体系结构。第一个指的是对于<code>List&lt;String&gt;</code>和<code>List&lt;Object&gt;</code>这样的情况，类型参数String是继承自Object的。而第二种指的是 List接口继承自Collection接口。对于这个类型系统，有如下的一些规则：</p>
<ul>
<li>相同类型参数的泛型类的关系取决于泛型类自身的继承体系结构。即<code>List&lt;String&gt;</code>是<code>Collection&lt;String&gt;</code> 的子类型，<code>List&lt;String&gt;</code>可以替换<code>Collection&lt;String&gt;</code>。这种情况也适用于带有上下界的类型声明。</li>
<li>当泛型类的类型声明中使用了通配符的时候， 其子类型可以在两个维度上分别展开。如对<code>Collection&lt;? extends Number&gt;</code>来说，其子类型可以在Collection这个维度上展开，即<code>List&lt;? extends Number&gt;</code>和<code>Set&lt;? extends Number&gt;</code>等；也可以在Number这个层次上展开，即<code>Collection&lt;Double&gt;</code>和<code>Collection&lt;Integer&gt;</code>等。如此循环下去，<code>ArrayList&lt;Long&gt;</code>和<code>HashSet&lt;Double&gt;</code>等也都算是<code>Collection&lt;? extends Number&gt;</code>的子类型。</li>
<li>如果泛型类中包含多个类型参数，则对于每个类型参数分别应用上面的规则。</li>
</ul>
<p>理解了上面的规则之后，就可以很容易的修正实例分析中给出的代码了。只需要把<code>List&lt;Object&gt;</code>改成<code>List&lt;?&gt;</code>即可。<code>List&lt;String&gt;</code>是<code>List&lt;?&gt;</code>的子类型，因此传递参数时不会发生错误。</p>
<h3 id="四-泛型传递"> （四）泛型传递</h3>
<p>即泛型可以当作参数在不同的实例化的类中传递，理论上来说可以无限制层次的传递下去。最终会约束每一层的方法或者类型的泛型确定，在《<a href="http://www.raychase.net/2446" target="_blank" rel="noopener noreferrer">泛型传递</a>》这篇文章中对具体的用法进行详尽的描述。</p>
<h3 id="五-最佳实践"> （五）最佳实践</h3>
<p>在使用泛型的时候可以遵循一些基本的原则，从而避免一些常见的问题。</p>
<ul>
<li>在代码中避免泛型类和原始类型的混用。比如<code>List&lt;String&gt;</code>和List不应该共同使用。这样会产生一些编译器警告和潜在的运行时异常。当需要利用JDK 5之前开发的遗留代码，而不得不这么做时，也尽可能的隔离相关的代码。</li>
<li>在使用带通配符的泛型类的时候，需要明确通配符所代表的一组类型的概念。由于具体的类型是未知的，很多操作是不允许的。</li>
<li>泛型类最好不要同数组一块使用。你只能创建<code>new List&lt;?&gt;[10]</code>这样的数组，无法创建<code>new List&lt;String&gt;[10]</code>这样的。这限制了数组的使用能力，而且会带来很多费解的问题。因此，当需要类似数组的功能时候，使用集合类即可。</li>
<li>不要忽视编译器给出的警告信息。</li>
</ul>
<h2 id="四、集合中使用泛型"> 四、集合中使用泛型</h2>
<p>集合相关类都定义了泛型，我们在开发和工作中，在使用集合类时都要使用泛型。这样，在集合的存储数据、读取数据时都避免了大量的类型判断，非常便捷。</p>
<p>泛型类的在集合中的使用</p>
<div><pre><code><span>public</span> <span>class</span> <span>Test</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>// 以下代码中List、Set、Map、Iterator都是与容器相关的接口;</span>
        <span>List</span><span><span>&lt;</span><span>String</span><span>></span></span> list <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>String</span><span>></span></span><span>(</span><span>)</span><span>;</span>
        <span>Set</span><span><span>&lt;</span><span>Man</span><span>></span></span> mans <span>=</span> <span>new</span> <span>HashSet</span><span><span>&lt;</span><span>Man</span><span>></span></span><span>(</span><span>)</span><span>;</span>
        <span>Map</span><span><span>&lt;</span><span>Integer</span><span>,</span> <span>Man</span><span>></span></span> maps <span>=</span> <span>new</span> <span>HashMap</span><span><span>&lt;</span><span>Integer</span><span>,</span> <span>Man</span><span>></span></span><span>(</span><span>)</span><span>;</span>
        <span>Iterator</span><span><span>&lt;</span><span>Man</span><span>></span></span> iterator <span>=</span> mans<span>.</span><span>iterator</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>阅读源码，发现Collection、List、Set、Map、Iterator接口都定义了泛型</p>
<div><pre><code><span>public</span> <span>interface</span> <span>Collection</span><span><span>&lt;</span><span>E</span><span>></span></span> <span>extends</span> <span>Iterable</span><span><span>&lt;</span><span>E</span><span>></span></span>
<span>public</span> <span>interface</span> <span>List</span><span><span>&lt;</span><span>E</span><span>></span></span> <span>extends</span> <span>Collection</span><span><span>&lt;</span><span>E</span><span>></span></span> 
<span>public</span> <span>interface</span> <span>Set</span><span><span>&lt;</span><span>E</span><span>></span></span> <span>extends</span> <span>Collection</span><span><span>&lt;</span><span>E</span><span>></span></span> 
<span>public</span> <span>interface</span> <span>Map</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> 
<span>public</span> <span>interface</span> <span>Iterator</span><span><span>&lt;</span><span>E</span><span>></span></span>    
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><div><p>注意</p>
<p>因此，我们在使用这些接口及其实现类时，都要使用泛型。</p>
</div>
<h2 id="五、自定义泛型"> 五、自定义泛型</h2>
<p>泛型类与一般的Java类基本相同，只是在类和接口定义上多出来了用&lt;&gt;声明的类型参数。</p>
<p>一个类可以有多个类型参数，我们可以在类的声明处增加泛型列表，如：&lt;T,E,V&gt;。此处，字符可以是任何标识符，一般采用这3个字母。 每个类型参数在声明的时候可以指定上界。所声明的类型参数在Java类中可以像一般的类型一样作为方法的参数和返回值，或是作为域和局部变量的类型。</p>
<h3 id="一-泛型类的声明"> （一）泛型类的声明</h3>
<div><pre><code><span>class</span> <span>MyCollection</span><span><span>&lt;</span><span>E</span><span>></span></span> <span>{</span><span>// E:表示泛型;</span>
    <span>Object</span><span>[</span><span>]</span> objs <span>=</span> <span>new</span> <span>Object</span><span>[</span><span>5</span><span>]</span><span>;</span>
 
    <span>public</span> <span>E</span> <span>get</span><span>(</span><span>int</span> index<span>)</span> <span>{</span><span>// E:表示泛型;</span>
        <span>return</span> <span>(</span><span>E</span><span>)</span> objs<span>[</span>index<span>]</span><span>;</span>
    <span>}</span>
    <span>public</span> <span>void</span> <span>set</span><span>(</span><span>E</span> e<span>,</span> <span>int</span> index<span>)</span> <span>{</span><span>// E:表示泛型;</span>
        objs<span>[</span>index<span>]</span> <span>=</span> e<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>泛型E像一个占位符一样表示“未知的某个数据类型”，我们在真正调用的时候传入这个“数据类型”</p>
<p>但是由于类型擦除机制，<mark>类型参数并不能用来创建对象或是作为静态变量的类型</mark>。考虑下面的泛型类中的正确和错误的用法。</p>
<div><pre><code><span>class</span> <span>ClassTest</span><span><span>&lt;</span><span>X</span> <span>extends</span> <span>Number</span><span>,</span> <span>Y</span><span>,</span> <span>Z</span><span>></span></span> <span>{</span>    
    <span>private</span> <span>X</span> x<span>;</span>    
    <span>private</span> <span>static</span> <span>Y</span> y<span>;</span> <span>//编译错误，不能用在静态变量中    </span>
    <span>public</span> <span>X</span> <span>getFirst</span><span>(</span><span>)</span> <span>{</span>
        <span>//正确用法        </span>
        <span>return</span> x<span>;</span>    
    <span>}</span>    
    <span>public</span> <span>void</span> <span>wrong</span><span>(</span><span>)</span> <span>{</span>        
        <span>Z</span> z <span>=</span> <span>new</span> <span>Z</span><span>(</span><span>)</span><span>;</span> <span>//编译错误，不能创建对象    </span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h3 id="二-泛型类的应用"> （二）泛型类的应用</h3>
<div><pre><code><span>public</span> <span>class</span> <span>TestGenerics</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>// 这里的”String”就是实际传入的数据类型；</span>
        <span>MyCollection</span><span><span>&lt;</span><span>String</span><span>></span></span> mc <span>=</span> <span>new</span> <span>MyCollection</span><span><span>&lt;</span><span>String</span><span>></span></span><span>(</span><span>)</span><span>;</span>
        mc<span>.</span><span>set</span><span>(</span><span>"aaa"</span><span>,</span> <span>0</span><span>)</span><span>;</span>
        mc<span>.</span><span>set</span><span>(</span><span>"bbb"</span><span>,</span> <span>1</span><span>)</span><span>;</span>
        <span>String</span> str <span>=</span> mc<span>.</span><span>get</span><span>(</span><span>1</span><span>)</span><span>;</span> <span>//加了泛型，直接返回String类型，不用强制转换;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>str<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div>]]></content>
    <author>
      <name>南辞</name>
    </author>
    <category term="Java"/>
    <contributor>
      <name>南辞</name>
    </contributor>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">Java</title>
    <id>http://qiqi.dreamagain.top/program/backend/java/</id>
    <link href="http://qiqi.dreamagain.top/program/backend/java/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <summary type="html"><![CDATA[<blockquote>
<p><img src="https://img.shields.io/badge/Java%E7%AE%80%E4%BB%8B-blue.svg" alt=""> <img src="https://img.shields.io/badge/%E5%AD%A6%E4%B9%A0%E6%95%99%E7%A8%8B-blue.svg" alt=""> <img src="https://img.shields.io/badge/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-blue.svg" alt=""></p>
</blockquote>
]]></summary>
    <content type="html"><![CDATA[<blockquote>
<p><img src="https://img.shields.io/badge/Java%E7%AE%80%E4%BB%8B-blue.svg" alt=""> <img src="https://img.shields.io/badge/%E5%AD%A6%E4%B9%A0%E6%95%99%E7%A8%8B-blue.svg" alt=""> <img src="https://img.shields.io/badge/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-blue.svg" alt="">
</p>
</blockquote>
<h2 id="java简介"> Java简介</h2>
<h3 id="java语言的诞生"> Java语言的诞生</h3>
<p>Java 是由 Sun Microsystems 公司于 1995 年 5 月推出的 Java 面向对象程序设计语言和 Java 平台的总称。由 James Gosling（Javaz之父）和同事们共同研发，并在 1995 年正式推出。</p>
<p>后来 Sun 公司被 Oracle （甲骨文）公司收购，Java 也随之成为 Oracle 公司的产品。</p>
<h3 id="java的三个体系"> Java的三个体系</h3>
<ul>
<li>
<p>JavaSE（J2SE）（Java2 Platform Standard Edition，java平台标准版）</p>
</li>
<li>
<p>JavaEE(J2EE)(Java 2 Platform,Enterprise Edition，java平台企业版)</p>
</li>
<li>
<p>JavaME(J2ME)(Java 2 Platform Micro Edition，java平台微型版)。</p>
<img src="./assets/java-00.png" style="zoom:120%;" align="left"/>
</li>
</ul>
<p>2005 年 6 月，JavaOne 大会召开，SUN 公司公开 Java SE 6。此时，Java 的各种版本已经更名，以取消其中的数字 &quot;2&quot;：</p>
<ul>
<li>J2EE 更名为 Java EE</li>
<li>J2SE 更名为Java SE，</li>
<li>J2ME 更名为 Java ME。</li>
</ul>
<br/>
<ol>
<li>Java SE就是标准版，包含标准的JVM和标准库</li>
<li>Java EE是企业版，它只是在Java SE的基础上加上了大量的API和库，以便方便开发Web应用、数据库、消息服务等，Java EE的应用使用的虚拟机和Java SE完全相同。</li>
<li>Java ME就和Java SE不同，它是一个针对嵌入式设备的“瘦身版”，Java SE的标准库无法在Java ME上使用，Java ME的虚拟机也是“瘦身版”。业界以Android开发成为了移动平台的标准之一，Java ME的使用相当少，不建议学习</li>
</ol>
<div><p>学习指南</p>
<ol>
<li>首先要学习Java SE，掌握Java语言本身、Java核心开发技术以及Java标准库的使用；</li>
<li>如果继续学习Java EE，那么Spring框架、数据库开发、分布式架构就是需要学习的；</li>
<li>如果要学习大数据开发，那么Hadoop、Spark、Flink这些大数据平台就是需要学习的，他们都基于Java或Scala开发；</li>
<li>如果想要学习移动开发，那么就深入Android平台，掌握Android App开发。</li>
</ol>
<p>Java SE是整个Java平台的核心，要成为真正的Java程序猿需要学习更多Java底层原理，精通Java SE</p>
</div>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <category term="Java"/>
    <contributor>
      <name>南辞</name>
    </contributor>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">JavaSE-反射</title>
    <id>http://qiqi.dreamagain.top/program/backend/java/reflect/</id>
    <link href="http://qiqi.dreamagain.top/program/backend/java/reflect/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<h2 id="一、什么是反射"> 一、什么是反射：</h2>
<p>（1）Java反射机制的核心是在程序运行时动态加载类并获取类的详细信息，从而操作类或对象的属性和方法。本质是JVM得到class对象之后，再通过class对象进行反编译，从而获取对象的各种信息。</p>
<p>（2）Java属于先编译再运行的语言，程序中对象的类型在编译期就确定下来了，而当程序在运行时可能需要动态加载某些类，这些类因为之前用不到，所以没有被加载到JVM。通过反射，可以在运行时动态地创建对象并调用其属性，不需要提前在编译期知道运行的对象是谁。</p>
<p><strong>反射是框架设计的灵魂</strong>：（使用的前提条件：必须先得到代表的字节码的Class，Class类用于表示.class文件（字节码））</p>
<div><p>小结</p>
<p>反射就是把java类中的各种成分映射成一个个的Java对象</p>
<p>例如：一个类有：成员变量、方法、构造方法、包等等信息，利用反射技术可以对一个类进行解剖，把各个组成部分映射成一个个对象。</p>
</div>
<h2 id="二、反射的原理"> 二、反射的原理：</h2>
<p>如图是类的正常加载过程：反射的原理在于class对象。</p>
<p>加载的时候：Class对象的由来是将class文件读入内存，并为之创建一个Class对象。</p>
<p><img src="./assets/java-02.png" alt=""></p>
<p>了解<a href="./calssloader.html">类加载机制与双亲委派模型</a></p>
<h2 id="三、反射的优缺点"> 三、反射的优缺点：</h2>
<p>1、优点：</p>
<p>在运行时获得类的各种内容，进行反编译，对于Java这种先编译再运行的语言，能够让我们很方便的创建灵活的代码</p>
<p>这些代码可以在运行时装配，无需在组件之间进行源代码的链接，更加容易实现面向对象。</p>
<p>2、缺点：</p>
<p>（1）反射会消耗一定的系统资源，因此，如果不需要动态地创建一个对象，那么就不需要用反射；</p>
<p>（2）<mark>反射调用方法时可以忽略权限检查，因此可能会破坏封装性而导致安全问题。</mark></p>
<h2 id="四、反射的用途"> 四、反射的用途：</h2>
<p>1、反编译：.class--&gt;.java</p>
<p>2、通过反射机制访问java对象的属性，方法，构造方法等</p>
<p>3、当我们在使用IDE,比如InteliJ IDEA时，当我们输入一个对象或者类，并想调用他的属性和方法是，一按点号，编译器就会自动列出他的属性或者方法，这里就是用到反射。</p>
<p>4、反射最重要的用途就是开发各种通用框架。比如很多框架（Spring）都是配置化的（比如通过XML文件配置Bean），为了保证框架的通用性，他们可能需要根据配置文件加载不同的类或者对象，调用不同的方法，这个时候就必须使用到反射了，运行时动态加载需要的加载的对象。</p>
<p>5、比如，加载数据库驱动的，用到的也是反射。</p>
<div><pre><code><span>Class</span><span>.</span><span>forName</span><span>(</span><span>"com.mysql.jdbc.Driver"</span><span>)</span><span>;</span> <span>// 动态加载mysql驱动</span>
</code></pre>
<div><span>1</span><br></div></div><h2 id="五、反射机制常用的类"> 五、反射机制常用的类</h2>
<p>Java.lang.Class;</p>
<p>Java.lang.reflect.Constructor;</p>
<p>Java.lang.reflect.Field;</p>
<p>Java.lang.reflect.Method;</p>
<p>Java.lang.reflect.Modifier;</p>
<h2 id="六、反射的基本使用"> 六、反射的基本使用</h2>
<p>假设我们现在有一个<code>Hero类</code></p>
<div><pre><code><span>package</span> <span>reflect</span><span>;</span>
<span>public</span> <span>class</span> <span>Hero</span> <span>{</span>
	<span>public</span> <span>String</span> name<span>;</span> <span>//昵称</span>
    <span>public</span> <span>float</span> hp<span>;</span> <span>//血量</span>
    <span>public</span> <span>float</span> armor<span>;</span> <span>//护甲</span>
    <span>public</span> <span>int</span> moveSpeed<span>;</span> <span>//移动速度</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h3 id="一-获取类对象"> （一）获取类对象</h3>
<p>获取类对象有3种方式</p>
<ol>
<li><code>Class.forName（）</code>（<strong>常用</strong>）</li>
<li><code>Hero.class</code></li>
<li><code>new Hero().getClass()</code></li>
</ol>
<p>在一个JVM中，一种类，只会有一个类对象存在。所以以上三种方式取出来的类对象，都是一样。</p>
<p>（此处准确是在ClassLoader下,只有一个类对象）</p>
<p><strong>示例：</strong></p>
<div><pre><code><span>package</span> <span>reflect</span><span>;</span>
<span>public</span> <span>class</span> <span>ReflectTest</span> <span>{</span>

	<span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>String</span> className <span>=</span> <span>"reflect.Hero"</span><span>;</span>
		<span>try</span> <span>{</span>
        	<span>//获取类对象的第一种方式</span>
            <span>Class</span> hClass1 <span>=</span> <span>Class</span><span>.</span><span>forName</span><span>(</span>className<span>)</span><span>;</span>
            <span>//获取类对象的第二种方式</span>
            <span>Class</span> hClass2 <span>=</span> <span>Hero</span><span>.</span><span>class</span><span>;</span>
            <span>//获取类对象的第三种方式</span>
            <span>Class</span> hClass3 <span>=</span> <span>new</span> <span>Hero</span><span>(</span><span>)</span><span>.</span><span>getClass</span><span>(</span><span>)</span><span>;</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>hClass1<span>==</span>hClass2<span>)</span><span>;</span><span>//输出true</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>hClass1<span>==</span>hClass3<span>)</span><span>;</span><span>//输出true</span>
        <span>}</span> <span>catch</span> <span>(</span><span>ClassNotFoundException</span> e<span>)</span> <span>{</span>
            <span>// TODO Auto-generated catch block</span>
            e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>
        <span>}</span>
 <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><p>三种方式中，常用第一种，第二种需要导入类的包，依赖太强，不导包就抛编译错误。第三种对象都有了还要反射干什么。</p>
<p>一般都第一种，参数可以传入一个字符串，也可写在配置文件中等多种方法。</p>
<hr>
<h3 id="二-反射机制创建对象"> （二）反射机制创建对象</h3>
<p><strong>通过反射来生成对象主要有两种方法：</strong></p>
<p>（1）使用Class对象的newInstance()方法来创建Class对象对应类的实例。</p>
<div><pre><code><span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> clazz <span>=</span> <span>String</span><span>.</span><span>class</span><span>;</span>
<span>Object</span> str <span>=</span> clazz<span>.</span><span>newInstance</span><span>(</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>（2）先通过Class对象获取指定的Constructor对象，再调用Constructor对象的newInstance()方法来创建对象，这种方法可以用指定的构造器构造类的实例。</p>
<div><pre><code><span>//获取String的Class对象</span>
<span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> clazz <span>=</span> <span>String</span><span>.</span><span>class</span><span>;</span>
<span>//通过Class对象获取指定的Constructor构造器对象</span>
<span>//String.class指明构造器的形参是String类型</span>
<span>Constructor</span> constructor<span>=</span>clazz<span>.</span><span>getConstructor</span><span>(</span><span>String</span><span>.</span><span>class</span><span>)</span><span>;</span>
<span>//根据构造器创建实例：</span>
<span>Object</span> obj <span>=</span> constructor<span>.</span><span>newInstance</span><span>(</span>“hello reflection”<span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p><strong>演示通过构造器创建实例</strong></p>
<p>基本步骤</p>
<p>1、获取类对象 <code>Class class = Class.forName(&quot;reflect.Hero&quot;);</code></p>
<p>2、获取构造器对象 <code>Constructor con = clazz.getConstructor(形参.class);</code></p>
<p>3、获取对象 <code>Hero hero =con.newInstance(实参);</code></p>
<p>上面是最简单的获取方法，当Hero的构造方法不是无参构造方法时，获取构造器对象略有不同，见下面测试：</p>
<p><strong>构造方法不同时，获取构造器对象的方法</strong></p>
<p>1、Hero类添加6种构造方法</p>
<div><pre><code><span>//---------------构造方法-------------------</span>
	<span>//（默认的构造方法）</span>
	<span>Hero</span><span>(</span><span>String</span> str<span>)</span><span>{</span>
		<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"(默认)的构造方法 s = "</span> <span>+</span> str<span>)</span><span>;</span>
	<span>}</span>
	
	<span>//无参构造方法</span>
	<span>public</span> <span>Hero</span><span>(</span><span>)</span><span>{</span>
		<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"调用了公有、无参构造方法执行了。。。"</span><span>)</span><span>;</span>
	<span>}</span>
	
	<span>//有一个参数的构造方法</span>
	<span>public</span> <span>Hero</span><span>(</span><span>char</span> name<span>)</span><span>{</span>
		<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"姓名："</span> <span>+</span> name<span>)</span><span>;</span>
	<span>}</span>
	
	<span>//有多个参数的构造方法</span>
	<span>public</span> <span>Hero</span><span>(</span><span>String</span> name <span>,</span><span>float</span> hp<span>)</span><span>{</span>
		<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"姓名："</span><span>+</span>name<span>+</span><span>"血量："</span><span>+</span> hp<span>)</span><span>;</span>
	<span>}</span>
	
	<span>//受保护的构造方法</span>
	<span>protected</span> <span>Hero</span><span>(</span><span>boolean</span> n<span>)</span><span>{</span>
		<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"受保护的构造方法 n = "</span> <span>+</span> n<span>)</span><span>;</span>
	<span>}</span>
	
	<span>//私有构造方法</span>
	<span>private</span> <span>Hero</span><span>(</span><span>float</span> hp<span>)</span><span>{</span>
		<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"私有的构造方法   血量："</span><span>+</span> hp<span>)</span><span>;</span>
	<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br></div></div><p>2、通过反射机制获取对象</p>
<div><pre><code><span>package</span> <span>reflect</span><span>;</span>

<span>import</span> <span>java<span>.</span>lang<span>.</span>reflect<span>.</span></span><span>Constructor</span><span>;</span>

<span>public</span> <span>class</span> <span>ConstructorTest</span> <span>{</span>


	<span>/*
	 * 通过Class对象可以获取某个类中的：构造方法、成员变量、成员方法；并访问成员；
	 *
	 * 1.获取构造方法：
	 * 		1).批量的方法：
	 * 			public Constructor[] getConstructors()：所有"公有的"构造方法
	            public Constructor[] getDeclaredConstructors()：获取所有的构造方法(包括私有、受保护、默认、公有)

	 * 		2).获取单个的方法，并调用：
	 * 			public Constructor getConstructor(Class... parameterTypes):获取单个的"公有的"构造方法：
	 * 			public Constructor getDeclaredConstructor(Class... parameterTypes):获取"某个构造方法"可以是私有的，或受保护、默认、公有；
	 *
	 * 2.创建对象
	 * 		Constructor对象调用newInstance(Object... initargs)
	 */</span>


	<span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>
		<span>//1.获取Class对象</span>
		<span>Class</span> clazz <span>=</span> <span>Class</span><span>.</span><span>forName</span><span>(</span><span>"reflect.Hero"</span><span>)</span><span>;</span>


		<span>//2.获取所有公有构造方法</span>
		<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"**********************所有公有构造方法*********************************"</span><span>)</span><span>;</span>
		<span>Constructor</span><span>[</span><span>]</span> conArray <span>=</span> clazz<span>.</span><span>getConstructors</span><span>(</span><span>)</span><span>;</span>
		<span>for</span><span>(</span><span>Constructor</span> c <span>:</span> conArray<span>)</span><span>{</span>
			<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>c<span>)</span><span>;</span>
		<span>}</span>


		<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"************所有的构造方法(包括：私有、受保护、默认、公有)***************"</span><span>)</span><span>;</span>
		conArray <span>=</span> clazz<span>.</span><span>getDeclaredConstructors</span><span>(</span><span>)</span><span>;</span>
		<span>for</span><span>(</span><span>Constructor</span> c <span>:</span> conArray<span>)</span><span>{</span>
			<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>c<span>)</span><span>;</span>
		<span>}</span>

		<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"*****************获取公有、无参的构造方法*******************************"</span><span>)</span><span>;</span>
		<span>Constructor</span> con <span>=</span> clazz<span>.</span><span>getConstructor</span><span>(</span><span>null</span><span>)</span><span>;</span>
		<span>//1>、因为是无参的构造方法所以类型是一个null,不写也可以：这里需要的是一个参数的类型，切记是类型</span>
		<span>//2>、返回的是描述这个无参构造函数的类对象。</span>
		<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"con = "</span> <span>+</span> con<span>)</span><span>;</span>
		<span>//调用构造方法</span>
		<span>Object</span> obj <span>=</span> con<span>.</span><span>newInstance</span><span>(</span><span>)</span><span>;</span>
		

		<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"******************获取私有构造方法，并调用*******************************"</span><span>)</span><span>;</span>
		con <span>=</span> clazz<span>.</span><span>getDeclaredConstructor</span><span>(</span><span>float</span><span>.</span><span>class</span><span>)</span><span>;</span>
		<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>con<span>)</span><span>;</span>
		<span>//调用构造方法</span>
		con<span>.</span><span>setAccessible</span><span>(</span><span>true</span><span>)</span><span>;</span><span>//暴力访问(忽略掉访问修饰符)</span>
		obj <span>=</span> con<span>.</span><span>newInstance</span><span>(</span><span>100</span><span>)</span><span>;</span>
	<span>}</span>


<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br></div></div><p>输出：</p>
<div><pre><code><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span>所有公有构造方法<span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span>
<span>public</span> <span><span>reflect<span>.</span></span>Hero</span><span>(</span><span><span>java<span>.</span>lang<span>.</span></span>String</span><span>,</span><span>float</span><span>)</span>
<span>public</span> <span><span>reflect<span>.</span></span>Hero</span><span>(</span><span>char</span><span>)</span>
<span>public</span> <span><span>reflect<span>.</span></span>Hero</span><span>(</span><span>)</span>
<span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span>所有的构造方法<span>(</span>包括：私有、受保护、默认、公有<span>)</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span>
<span>private</span> <span><span>reflect<span>.</span></span>Hero</span><span>(</span><span>float</span><span>)</span>
<span>protected</span> <span><span>reflect<span>.</span></span>Hero</span><span>(</span><span>boolean</span><span>)</span>
<span>public</span> <span><span>reflect<span>.</span></span>Hero</span><span>(</span><span><span>java<span>.</span>lang<span>.</span></span>String</span><span>,</span><span>float</span><span>)</span>
<span>public</span> <span><span>reflect<span>.</span></span>Hero</span><span>(</span><span>char</span><span>)</span>
<span>public</span> <span><span>reflect<span>.</span></span>Hero</span><span>(</span><span>)</span>
<span><span>reflect<span>.</span></span>Hero</span><span>(</span><span><span>java<span>.</span>lang<span>.</span></span>String</span><span>)</span>
<span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span>获取公有、无参的构造方法<span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span>
con <span>=</span> <span>public</span> <span><span>reflect<span>.</span></span>Hero</span><span>(</span><span>)</span>
调用了公有、无参构造方法执行了。。。
<span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span>获取私有构造方法，并调用<span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span><span>*</span>
<span>private</span> <span><span>reflect<span>.</span></span>Hero</span><span>(</span><span>float</span><span>)</span>
私有的构造方法   血量：<span>100.0</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><div><p>小结</p>
<p>1.获取构造器对象方法：</p>
<p>1).批量的方法：</p>
<p>​	public Constructor[] getConstructors()：所有&quot;公有的&quot;构造方法
​			public Constructor[] getDeclaredConstructors()：获取所有的构造方法(包括私有、受保护、默认、公有)</p>
<p>2).获取单个的方法:</p>
<p>​	public Constructor getConstructor(Class… parameterTypes): 获取单个的&quot;公有的&quot;构造方法</p>
<p>​	public Constructor getDeclaredConstructor(Class…parameterTypes):获取&quot;某个构造方法&quot;可以是私有的，或受保护、默认、公有；</p>
</div>
<hr>
<h3 id="三-获取成员变量并使用"> （三）获取成员变量并使用</h3>
<p><strong>基本步骤</strong></p>
<p>创建HeroPlus的对象 <code>new/反射</code></p>
<p>获取属性 <code>Field f1 = h.getDeclaredField(&quot;属性名&quot;)</code></p>
<p>修改属性 <code>f1.set(h，实参)</code>，注意这里的h是对象，不是类对象</p>
<p>1、新增HeroPlus类</p>
<div><pre><code><span>package</span> <span>reflect</span><span>;</span>
<span>public</span> <span>class</span> <span>HeroPlus</span> <span>{</span>
	<span>public</span> <span>String</span> name<span>;</span>
    <span>public</span> <span>float</span> hp<span>;</span>
    <span>public</span> <span>int</span> damage<span>;</span>
    <span>public</span> <span>int</span> id<span>;</span>
     
    <span>public</span> <span>String</span> <span>getName</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> name<span>;</span>
    <span>}</span>
    <span>public</span> <span>void</span> <span>setName</span><span>(</span><span>String</span> name<span>)</span> <span>{</span>
        <span>this</span><span>.</span>name <span>=</span> name<span>;</span>
    <span>}</span>
    <span>public</span> <span>HeroPlus</span><span>(</span><span>)</span><span>{</span>
         
    <span>}</span>
    <span>public</span> <span>HeroPlus</span><span>(</span><span>String</span> string<span>)</span> <span>{</span>
        name <span>=</span>string<span>;</span>
    <span>}</span>
 
    <span>@Override</span>
    <span>public</span> <span>String</span> <span>toString</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> <span>"Hero [name="</span> <span>+</span> name <span>+</span> <span>"]"</span><span>;</span>
    <span>}</span>
    <span>public</span> <span>boolean</span> <span>isDead</span><span>(</span><span>)</span> <span>{</span>
        <span>// TODO Auto-generated method stub</span>
        <span>return</span> <span>false</span><span>;</span>
    <span>}</span>
    <span>public</span> <span>void</span> <span>attackHero</span><span>(</span><span>HeroPlus</span> h2<span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>this</span><span>.</span>name<span>+</span> <span>" 正在攻击 "</span> <span>+</span> h2<span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br></div></div><p>2、获取属性并修改</p>
<div><pre><code><span>package</span> <span>reflect</span><span>;</span>

<span>import</span> <span>java<span>.</span>lang<span>.</span>reflect<span>.</span></span><span>Constructor</span><span>;</span>
<span>import</span> <span>java<span>.</span>lang<span>.</span>reflect<span>.</span></span><span>Field</span><span>;</span>

<span>public</span> <span>class</span> <span>ParaTest</span> <span>{</span>
	 <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
         <span>//HeroPlus h =new HeroPlus();</span>
         <span>//使用传统方式修改name的值为garen</span>
         <span>//h.name = "garen";</span>

         <span>try</span> <span>{</span>
             <span>// 获取Class对象</span>
             <span>Class</span> clazz <span>=</span> <span>Class</span><span>.</span><span>forName</span><span>(</span><span>"reflect.HeroPlus"</span><span>)</span><span>;</span>
             <span>// 获取HeroPlus的无参构造函数</span>
             <span>Constructor</span> con <span>=</span> clazz<span>.</span><span>getDeclaredConstructor</span><span>(</span><span>null</span><span>)</span><span>;</span>
             <span>// 创建一个HeroPlus对象</span>
             <span>HeroPlus</span> h <span>=</span> <span>(</span><span>HeroPlus</span><span>)</span> con<span>.</span><span>newInstance</span><span>(</span><span>)</span><span>;</span>
             <span>//使用传统方式修改name的值为garen</span>
             h<span>.</span>name <span>=</span> <span>"garen"</span><span>;</span>
             <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>h<span>)</span><span>;</span>

             <span>//获取类HeroPlus的名字叫做name的字段</span>
             <span>//Field f1= h.getClass().getDeclaredField("name");</span>
             <span>Field</span> f1<span>=</span> clazz<span>.</span><span>getDeclaredField</span><span>(</span><span>"name"</span><span>)</span><span>;</span>
             <span>//修改h对象的name字段</span>
             f1<span>.</span><span>set</span><span>(</span>h<span>,</span> <span>"teemo"</span><span>)</span><span>;</span>
             <span>//打印被修改后的值</span>
             <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>h<span>)</span><span>;</span>

         <span>}</span> <span>catch</span> <span>(</span><span>Exception</span> e<span>)</span> <span>{</span>
             <span>// TODO Auto-generated catch block</span>
             e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>
         <span>}</span>
 <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br></div></div><div><p>补充</p>
<p><strong>getField和getDeclaredField的区别</strong></p>
<p>getField 只能获取public的，包括从父类继承来的字段。</p>
<p>getDeclaredField 可以获取本类所有的字段，包括private的，但是 不能获取继承来的字段。 (注： 这里只能获取到private的字段，但</p>
<p>并不能访问该private字段的值,除非加上setAccessible(true))</p>
</div>
<hr>
<h3 id="四-获取成员方法并使用"> （四）获取成员方法并使用</h3>
<p><strong>基本步骤</strong></p>
<ol>
<li>
<p>创建HeroPlus的对象 <code>h</code></p>
</li>
<li>
<p>获取成员方法</p>
<p>public Method getMethod(String name ，Class&lt;?&gt;… parameterTypes):获取&quot;公有方法&quot;；（包含了父类的方法也包含Object类）</p>
<p>public Method getDeclaredMethods(String name ，Class&lt;?&gt;… parameterTypes) :获取成员方法，包括私有的(不包括继承的)</p>
<p><strong>参数解释</strong>：name : 方法名； Class … : 形参的Class类型对象</p>
</li>
<li>
<p>调用方法</p>
<p>Method --&gt; public Object invoke(Object obj,Object… args):</p>
<p><strong>参数说明</strong>： obj : 要调用方法的对象；args:调用方式时所传递的实参；</p>
</li>
</ol>
<div><pre><code><span>package</span> <span>reflect</span><span>;</span>

<span>import</span> <span>java<span>.</span>lang<span>.</span>reflect<span>.</span></span><span>Field</span><span>;</span>
<span>import</span> <span>java<span>.</span>lang<span>.</span>reflect<span>.</span></span><span>Method</span><span>;</span>

<span>public</span> <span>class</span> <span>MethodTest</span> <span>{</span>
	<span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>

	 <span>HeroPlus</span> h <span>=</span> <span>new</span> <span>HeroPlus</span><span>(</span><span>)</span><span>;</span>

     <span>try</span> <span>{</span>
         <span>// 获取这个名字叫做setName，参数类型是String的方法</span>
         <span>Method</span> m <span>=</span> h<span>.</span><span>getClass</span><span>(</span><span>)</span><span>.</span><span>getMethod</span><span>(</span><span>"setName"</span><span>,</span> <span>String</span><span>.</span><span>class</span><span>)</span><span>;</span>
         <span>// 对h对象，调用这个方法</span>
         m<span>.</span><span>invoke</span><span>(</span>h<span>,</span> <span>"盖伦"</span><span>)</span><span>;</span>
         <span>// 使用传统的方式，调用getName方法</span>
         <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>h<span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>
         <span>// 使用反射读取</span>
         <span>Field</span> f <span>=</span> h<span>.</span><span>getClass</span><span>(</span><span>)</span><span>.</span><span>getDeclaredField</span><span>(</span><span>"name"</span><span>)</span><span>;</span>
         <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>f<span>.</span><span>get</span><span>(</span>h<span>)</span><span>)</span><span>;</span>

     <span>}</span> <span>catch</span> <span>(</span><span>Exception</span> e<span>)</span> <span>{</span>
         <span>// TODO Auto-generated catch block</span>
         e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>
     <span>}</span>

 <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br></div></div><hr>
<h3 id="五-获取main方法并使用"> （五）获取main方法并使用</h3>
<p>1、HeroPlus 新增main方法</p>
<div><pre><code><span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
		<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"执行main方法"</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>2、通过下面步骤获取main方法<a href="https://blog.csdn.net/lililuni/article/details/83449088?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161284956016780274151023%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=161284956016780274151023&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-7-83449088.pc_search_result_no_baidu_js&amp;utm_term=java%E5%8F%8D%E5%B0%84#fn1" target="_blank" rel="noopener noreferrer">1</a></p>
<div><pre><code><span>package</span> <span>reflect</span><span>;</span>

<span>import</span> <span>java<span>.</span>lang<span>.</span>reflect<span>.</span></span><span>Method</span><span>;</span>

<span>public</span> <span>class</span> <span>MainTest</span> <span>{</span>
	<span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
		<span>try</span> <span>{</span>
			<span>//1、获取HeroPlus对象的Class实例</span>
			<span>Class</span> clazz <span>=</span> <span>Class</span><span>.</span><span>forName</span><span>(</span><span>"reflect.HeroPlus"</span><span>)</span><span>;</span>

			<span>//2、获取main方法,第一个参数：方法名称，第二个参数：方法形参的类型，</span>
			 <span>Method</span> methodMain <span>=</span> clazz<span>.</span><span>getMethod</span><span>(</span><span>"main"</span><span>,</span> <span>String</span><span>[</span><span>]</span><span>.</span><span>class</span><span>)</span><span>;</span>
			<span>//3、调用main方法</span>
			<span>// methodMain.invoke(null, new String[]{"a","b","c"});</span>
			<span>//第一个参数，对象类型，因为方法是static静态的，所以为null可以，第二个参数是String数组，这里要注意在jdk1.4时是数组，jdk1.5之后是可变参数</span>
			<span>//这里拆的时候将  new String[]{"a","b","c"} 拆成3个对象。所以需要将它强转。</span>
			 methodMain<span>.</span><span>invoke</span><span>(</span><span>null</span><span>,</span> <span>(</span><span>Object</span><span>)</span><span>new</span> <span>String</span><span>[</span><span>]</span><span>{</span><span>"a"</span><span>,</span><span>"b"</span><span>,</span><span>"c"</span><span>}</span><span>)</span><span>;</span><span>//方式一</span>
			<span>// methodMain.invoke(null, new Object[]{new String[]{"a","b","c"}});//方式二</span>

		<span>}</span> <span>catch</span> <span>(</span><span>Exception</span> e<span>)</span> <span>{</span>
			e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>
		<span>}</span>


	<span>}</span>
<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div><h2 id="七、关于反射的用法举例"> 七、关于反射的用法举例</h2>
<p>反射非常强大，但是从上面的记录来看，反而觉得还不如直接调用方法来的直接和方便。</p>
<p>通常来说，需要在学习了Spring 的依赖注入，反转控制之后，才会对反射有更好的理解，所以先这里举两个例子，来演示一下反射的一种实际运用。</p>
<h3 id="一-通过反射读取配置文件内容"> （一）通过反射读取配置文件内容</h3>
<p>1、首先准备两个业务类</p>
<div><pre><code><span>package</span> <span>service</span><span>;</span>
<span>public</span> <span>class</span> <span>Service1</span> <span>{</span>
    <span>public</span> <span>void</span> <span>doService1</span><span>(</span><span>)</span><span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"业务方法1"</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>

<span>package</span> <span>service</span><span>;</span>
<span>public</span> <span>class</span> <span>Service2</span> <span>{</span>
	<span>public</span> <span>void</span> <span>doService2</span><span>(</span><span>)</span><span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"业务方法2"</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>2、当需要从第一个业务方法切换到第二个业务方法的时候，使用非反射方式，必须修改代码，并且重新编译运行，才可以达到效果</p>
<div><pre><code><span>package</span> <span>service</span><span>;</span>
<span>public</span> <span>class</span> <span>CommonTest</span> <span>{</span>
	  <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
		  <span>//new Service1().doService1();</span>
		  <span>//必须重新修改代码</span>
	        <span>new</span> <span>Service2</span><span>(</span><span>)</span><span>.</span><span>doService2</span><span>(</span><span>)</span><span>;</span>
	    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>3、使用反射方式则方便很多</p>
<ol>
<li>首先准备一个配置文件，叫做config.properties, 放在resource目录下，里面存放的是类的名称和要调用的方法名。</li>
<li>在测试类Test中，首先取出类名称和方法名，然后通过反射去调用这个方法。</li>
<li>当需要从调用第一个业务方法，切换到调用第二个业务方法的时候，不需要修改一行代码，也不需要重新编译，只需要修改配置文件spring.txt，再运行即可。</li>
</ol>
<p>config.properties内容</p>
<div><pre><code><span>class</span><span>=</span><span><span>service<span>.</span></span>Service1</span>
method<span>=</span>doService1
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>测试类</p>
<div><pre><code><span>package</span> <span>service</span><span>;</span>

<span>import</span> <span>java<span>.</span>io<span>.</span></span><span>IOException</span><span>;</span>
<span>import</span> <span>java<span>.</span>io<span>.</span></span><span>InputStream</span><span>;</span>
<span>import</span> <span>java<span>.</span>lang<span>.</span>reflect<span>.</span></span><span>Constructor</span><span>;</span>
<span>import</span> <span>java<span>.</span>lang<span>.</span>reflect<span>.</span></span><span>Method</span><span>;</span>
<span>import</span> <span>java<span>.</span>util<span>.</span></span><span>Properties</span><span>;</span>

<span>public</span> <span>class</span> <span>ReflectTest</span> <span>{</span>
	<span>@SuppressWarnings</span><span>(</span><span>{</span> <span>"rawtypes"</span><span>,</span> <span>"unchecked"</span> <span>}</span><span>)</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>

        <span>//从spring.txt中获取类名称和方法名称</span>
        <span>InputStream</span> in <span>=</span> <span>ReflectTest</span><span>.</span><span>class</span><span>.</span><span>getResourceAsStream</span><span>(</span><span>"/config.properties"</span><span>)</span><span>;</span>
        <span>Properties</span> properties <span>=</span> <span>new</span> <span>Properties</span><span>(</span><span>)</span><span>;</span>
        <span>try</span> <span>{</span>
            properties<span>.</span><span>load</span><span>(</span>in<span>)</span><span>;</span>
        <span>}</span> <span>catch</span> <span>(</span><span>IOException</span> e<span>)</span> <span>{</span>
            e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>
        <span>}</span>
        <span>String</span> className <span>=</span> <span>(</span><span>String</span><span>)</span> properties<span>.</span><span>get</span><span>(</span><span>"class"</span><span>)</span><span>;</span>
        <span>String</span> methodName <span>=</span> <span>(</span><span>String</span><span>)</span> properties<span>.</span><span>get</span><span>(</span><span>"method"</span><span>)</span><span>;</span>

        <span>//根据类名称获取类对象</span>
        <span>Class</span> clazz <span>=</span> <span>Class</span><span>.</span><span>forName</span><span>(</span>className<span>)</span><span>;</span>
        <span>//根据方法名称，获取方法对象</span>
        <span>Method</span> m <span>=</span> clazz<span>.</span><span>getMethod</span><span>(</span>methodName<span>)</span><span>;</span>
        <span>//获取构造器</span>
        <span>Constructor</span> c <span>=</span> clazz<span>.</span><span>getConstructor</span><span>(</span><span>)</span><span>;</span>
        <span>//根据构造器，实例化出对象</span>
        <span>Object</span> service <span>=</span> c<span>.</span><span>newInstance</span><span>(</span><span>)</span><span>;</span>
        <span>//调用对象的指定方法</span>
        m<span>.</span><span>invoke</span><span>(</span>service<span>)</span><span>;</span>

    <span>}</span>
<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br></div></div><h3 id="二-通过反射越过泛型检查"> （二）通过反射越过泛型检查</h3>
<p>泛型是在编译期间起作用的。在编译后的.class文件中是没有泛型的。所有比如T或者E类型啊，本质都是通过Object处理的。所以可以通过使用反射来越过泛型。</p>
<div><pre><code><span>package</span> <span>reflect</span><span>;</span>

<span>import</span> <span>java<span>.</span>lang<span>.</span>reflect<span>.</span></span><span>Method</span><span>;</span>
<span>import</span> <span>java<span>.</span>util<span>.</span></span><span>ArrayList</span><span>;</span>

<span>public</span> <span>class</span> <span>GenericityTest</span> <span>{</span>
	<span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>throws</span> <span>Exception</span><span>{</span>

	<span>ArrayList</span><span><span>&lt;</span><span>String</span><span>></span></span> list <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
	list<span>.</span><span>add</span><span>(</span><span>"this"</span><span>)</span><span>;</span>
	list<span>.</span><span>add</span><span>(</span><span>"is"</span><span>)</span><span>;</span>

   <span>//list.add(5); //报错</span>

	<span>/********** 越过泛型检查    **************/</span>

	<span>//获取ArrayList的Class对象，反向的调用add()方法，添加数据</span>
	<span>Class</span> listClass <span>=</span> list<span>.</span><span>getClass</span><span>(</span><span>)</span><span>;</span>
	<span>//获取add()方法</span>
	<span>Method</span> m <span>=</span> listClass<span>.</span><span>getMethod</span><span>(</span><span>"add"</span><span>,</span> <span>Object</span><span>.</span><span>class</span><span>)</span><span>;</span>
	<span>//调用add()方法</span>
	m<span>.</span><span>invoke</span><span>(</span>list<span>,</span> <span>5</span><span>)</span><span>;</span>

	<span>//遍历集合</span>
	<span>for</span><span>(</span><span>Object</span> obj <span>:</span> list<span>)</span><span>{</span>
		<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>obj<span>)</span><span>;</span>
		<span>}</span>
	<span>}</span>

<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br></div></div><div><p>参考</p>
<p><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1255945389098144" target="_blank" rel="noopener noreferrer">廖雪峰Java教程 - 反射</a></p>
<p><a href="https://blog.csdn.net/lililuni/article/details/83449088?ops_request_misc=%25257B%252522request%25255Fid%252522%25253A%252522161284956016780274151023%252522%25252C%252522scm%252522%25253A%25252220140713.130102334..%252522%25257D&amp;request_id=161284956016780274151023&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-7-83449088.pc_search_result_no_baidu_js&amp;utm_term=java%25E5%258F%258D%25E5%25B0%2584" target="_blank" rel="noopener noreferrer">皮卡卡西- Java 反射</a></p>
</div>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <category term="Java"/>
    <contributor>
      <name>南辞</name>
    </contributor>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">JavaSE-正则表达式</title>
    <id>http://qiqi.dreamagain.top/program/backend/java/regex/</id>
    <link href="http://qiqi.dreamagain.top/program/backend/java/regex/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<h2 id="一、概述"> 一、概述</h2>
<ul>
<li>用来描述或者匹配一系列符合某个语句规则的字符串</li>
</ul>
<h2 id="二、单字符匹配"> 二、单字符匹配</h2>
<p>单个字符的匹配规则主要有:</p>
<table>
<thead>
<tr>
<th style="text-align:left">正则表达式</th>
<th style="text-align:left">规则</th>
<th style="text-align:left">可以匹配</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>A</code></td>
<td style="text-align:left">指定字符</td>
<td style="text-align:left"><code>A</code></td>
</tr>
<tr>
<td style="text-align:left"><code>\u548c</code></td>
<td style="text-align:left">指定Unicode字符</td>
<td style="text-align:left"><code>和</code></td>
</tr>
<tr>
<td style="text-align:left"><code>.</code></td>
<td style="text-align:left">任意字符</td>
<td style="text-align:left"><code>a</code>，<code>b</code>，<code>&amp;</code>，<code>0</code></td>
</tr>
<tr>
<td style="text-align:left"><code>\d</code></td>
<td style="text-align:left">数字0~9</td>
<td style="text-align:left"><code>0</code>~<code>9</code></td>
</tr>
<tr>
<td style="text-align:left"><code>\w</code></td>
<td style="text-align:left">大小写字母，数字和下划线</td>
<td style="text-align:left"><code>a</code>~<code>z</code>，<code>A</code>~<code>Z</code>，<code>0</code>~<code>9</code>，<code>_</code></td>
</tr>
<tr>
<td style="text-align:left"><code>\s</code></td>
<td style="text-align:left">空格、Tab键</td>
<td style="text-align:left">空格，Tab</td>
</tr>
<tr>
<td style="text-align:left"><code>\D</code></td>
<td style="text-align:left">非数字</td>
<td style="text-align:left"><code>a</code>，<code>A</code>，<code>&amp;</code>，<code>_</code>，……</td>
</tr>
<tr>
<td style="text-align:left"><code>\W</code></td>
<td style="text-align:left">非\w</td>
<td style="text-align:left"><code>&amp;</code>，<code>@</code>，<code>中</code>，……</td>
</tr>
<tr>
<td style="text-align:left"><code>\S</code></td>
<td style="text-align:left">非\s</td>
<td style="text-align:left"><code>a</code>，<code>A</code>，<code>&amp;</code>，<code>_</code>，……</td>
</tr>
</tbody>
</table>
<p><strong>快捷符号</strong></p>
<p>1、<code>\d</code>表示<code>[0—9]</code></p>
<p>2、<code>\D</code>表示<code>[^0—9]</code></p>
<p>3、<code>\w</code>表示<code>[0—9A—Z_a—z]</code></p>
<p>4、<code>\W</code>表示<code>[^0—9A—Z_a—z]</code></p>
<p>5、<code>\s</code>表示<code>[\t\n\r\f]</code></p>
<p>6、<code>\S</code>表示<code>[^\t\n\r\f]</code></p>
<h2 id="三、多字符匹配"> 三、多字符匹配</h2>
<p>多个字符的匹配规则主要有：</p>
<table>
<thead>
<tr>
<th style="text-align:left">正则表达式</th>
<th style="text-align:left">规则</th>
<th style="text-align:left">可以匹配</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>A*</code></td>
<td style="text-align:left">任意个数字符</td>
<td style="text-align:left">空，<code>A</code>，<code>AA</code>，<code>AAA</code>，……</td>
</tr>
<tr>
<td style="text-align:left"><code>A+</code></td>
<td style="text-align:left">至少1个字符</td>
<td style="text-align:left"><code>A</code>，<code>AA</code>，<code>AAA</code>，……</td>
</tr>
<tr>
<td style="text-align:left"><code>A?</code></td>
<td style="text-align:left">0个或1个字符</td>
<td style="text-align:left">空，<code>A</code></td>
</tr>
<tr>
<td style="text-align:left"><code>A{3}</code></td>
<td style="text-align:left">指定个数字符</td>
<td style="text-align:left"><code>AAA</code></td>
</tr>
<tr>
<td style="text-align:left"><code>A{2,3}</code></td>
<td style="text-align:left">指定范围个数字符</td>
<td style="text-align:left"><code>AA</code>，<code>AAA</code></td>
</tr>
<tr>
<td style="text-align:left"><code>A{2,}</code></td>
<td style="text-align:left">至少n个字符</td>
<td style="text-align:left"><code>AA</code>，<code>AAA</code>，<code>AAAA</code>，……</td>
</tr>
<tr>
<td style="text-align:left"><code>A{0,3}</code></td>
<td style="text-align:left">最多n个字符</td>
<td style="text-align:left">空，<code>A</code>，<code>AA</code>，<code>AAA</code></td>
</tr>
</tbody>
</table>
<h2 id="四、复杂匹配"> 四、复杂匹配</h2>
<p>复杂匹配规则主要有：</p>
<table>
<thead>
<tr>
<th style="text-align:left">正则表达式</th>
<th style="text-align:left">规则</th>
<th style="text-align:left">可以匹配</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">^</td>
<td style="text-align:left">开头</td>
<td style="text-align:left">字符串开头</td>
</tr>
<tr>
<td style="text-align:left">$</td>
<td style="text-align:left">结尾</td>
<td style="text-align:left">字符串结束</td>
</tr>
<tr>
<td style="text-align:left">[ABC]</td>
<td style="text-align:left">[…]内任意字符</td>
<td style="text-align:left">A，B，C</td>
</tr>
<tr>
<td style="text-align:left">[A-F0-9xy]</td>
<td style="text-align:left">指定范围的字符</td>
<td style="text-align:left"><code>A</code>，……，<code>F</code>，<code>0</code>，……，<code>9</code>，<code>x</code>，<code>y</code></td>
</tr>
<tr>
<td style="text-align:left">[^A-F]</td>
<td style="text-align:left">指定范围外的任意字符</td>
<td style="text-align:left">非<code>A</code>~<code>F</code></td>
</tr>
<tr>
<td style="text-align:left">AB|CD|EF</td>
<td style="text-align:left">AB或CD或EF</td>
<td style="text-align:left"><code>AB</code>，<code>CD</code>，<code>EF</code></td>
</tr>
</tbody>
</table>
<h2 id="五、分组匹配"> 五、分组匹配</h2>
<p><code>(...)</code>可以用来把一个子规则括起来，这样写<code>learn\s(java|php|go)</code>就可以更方便地匹配</p>
<p><code>learn java</code>、<code>learn php</code>  、 <code>learn go</code>这样的长字符串了</p>
<p>除此以外，<code>(...)</code>还有一个重要作用，就是分组匹配</p>
<p>用<code>(...)</code>先把要提取的规则分组，把上述正则表达式变为像<code>(^0\d{2})-(\d{6,8})</code>这样。</p>
<p>现在问题又来了：匹配后，如何按括号提取子串？</p>
<p>现在我们没办法用<code>String.matches()</code>这样简单的判断方法了，必须引入<code>java.util.regex</code>包，用<code>Pattern</code>对象匹配，匹配后获得一个<code>Matcher</code>对象，如果匹配成功，就可以直接从<code>Matcher.group(index)</code>返回子串：</p>
<div><pre><code><span>public</span> <span>class</span> <span>Main</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>//匹配国内的电话号码规则：3~4位区号加7~8位电话，中间用-连接，且国内区号必须以0开头</span>
        <span>//例如：010-12345678</span>
        <span>Pattern</span> p <span>=</span> <span>Pattern</span><span>.</span><span>compile</span><span>(</span><span>"(^0\\d{2,3})-(\\d{7,8})"</span><span>)</span><span>;</span>
        <span>Matcher</span> m <span>=</span> p<span>.</span><span>matcher</span><span>(</span><span>"010-12345678"</span><span>)</span><span>;</span>
        <span>if</span> <span>(</span>m<span>.</span><span>matches</span><span>(</span><span>)</span><span>)</span> <span>{</span>
            <span>String</span> g1 <span>=</span> m<span>.</span><span>group</span><span>(</span><span>1</span><span>)</span><span>;</span>
            <span>String</span> g2 <span>=</span> m<span>.</span><span>group</span><span>(</span><span>2</span><span>)</span><span>;</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>g1<span>)</span><span>;</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>g2<span>)</span><span>;</span>
        <span>}</span> <span>else</span> <span>{</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"匹配失败!"</span><span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><div><p>注意</p>
<p>区分三个概念，原串，正则表达式，java字符串</p>
<p>原串是a&amp;c，那么由于&amp;在正则表达式中属于特殊字符，因此正则表达式中需要转义，即写为a&amp;c</p>
<p>又因为java字符串中，\也是特殊字符，因此需要转义写成\，综合写就是a\&amp;c</p>
<p>所以java字符串&quot;a\&amp;c&quot;表示的正则表达式为&quot;a&amp;c&quot;，表示的原串内容为&quot;a&amp;c&quot;</p>
</div>
<div><p>相关信息</p>
<p>正则表达式代码可以使用<code>String.matches()</code>方法，而我们在分组提取的代码中用的是<code>java.util.regex</code>包里面的<code>Pattern</code>类和<code>Matcher</code>类。实际上这两种代码本质上是一样的，因为<code>String.matches()</code>方法内部调用的就是<code>Pattern</code>和<code>Matcher</code>类的方法。</p>
</div>
<p>但是反复使用<code>String.matches()</code>对同一个正则表达式进行多次匹配效率较低，因为每次都会创建出一样的<code>Pattern</code>对象。完全可以先创建出一个<code>Pattern</code>对象，然后反复使用，就可以实现编译一次，多次匹配,如下示例：</p>
<div><pre><code><span>public</span> <span>class</span> <span>Main</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>Pattern</span> pattern <span>=</span> <span>Pattern</span><span>.</span><span>compile</span><span>(</span><span>"(^0\\d{2,3})-(\\d{7,8})"</span><span>)</span><span>;</span>
        pattern<span>.</span><span>matcher</span><span>(</span><span>"010-12345678"</span><span>)</span><span>.</span><span>matches</span><span>(</span><span>)</span><span>;</span> <span>// true</span>
        pattern<span>.</span><span>matcher</span><span>(</span><span>"021-123456"</span><span>)</span><span>.</span><span>matches</span><span>(</span><span>)</span><span>;</span> <span>// true</span>
        pattern<span>.</span><span>matcher</span><span>(</span><span>"022#1234567"</span><span>)</span><span>.</span><span>matches</span><span>(</span><span>)</span><span>;</span> <span>// false</span>
        <span>// 获得Matcher对象:</span>
        <span>Matcher</span> matcher <span>=</span> pattern<span>.</span><span>matcher</span><span>(</span><span>"010-12345678"</span><span>)</span><span>;</span>
        <span>if</span> <span>(</span>matcher<span>.</span><span>matches</span><span>(</span><span>)</span><span>)</span> <span>{</span>
            <span>String</span> whole <span>=</span> matcher<span>.</span><span>group</span><span>(</span><span>0</span><span>)</span><span>;</span> <span>// "010-12345678", 0表示匹配的整个字符串</span>
            <span>String</span> area <span>=</span> matcher<span>.</span><span>group</span><span>(</span><span>1</span><span>)</span><span>;</span> <span>// "010", 1表示匹配的第1个子串</span>
            <span>String</span> tel <span>=</span> matcher<span>.</span><span>group</span><span>(</span><span>2</span><span>)</span><span>;</span> <span>// "12345678", 2表示匹配的第2个子串</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>area<span>)</span><span>;</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>tel<span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><h2 id="六、非贪婪匹配"> 六、非贪婪匹配</h2>
<h3 id="一-贪婪匹配"> （一）贪婪匹配</h3>
<p>在介绍非贪婪匹配之前必须了解什么是贪婪匹配：</p>
<div><p>贪婪匹配</p>
<p>正则表达式默认使用贪婪匹配：任何一个规则，它总是尽可能多地向后匹配</p>
</div>
<p><strong>案例分析：</strong></p>
<p>期望将将字符串末尾的所有0提取，想到使用分组匹配，正则：<code>(\d+)(0*)</code></p>
<div><pre><code><span>public</span> <span>class</span> <span>Main</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>Pattern</span> pattern <span>=</span> <span>Pattern</span><span>.</span><span>compile</span><span>(</span><span>"(\\d+)(0*)"</span><span>)</span><span>;</span>
        <span>Matcher</span> matcher <span>=</span> pattern<span>.</span><span>matcher</span><span>(</span><span>"1230000"</span><span>)</span><span>;</span>
        <span>if</span> <span>(</span>matcher<span>.</span><span>matches</span><span>(</span><span>)</span><span>)</span> <span>{</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"group1="</span> <span>+</span> matcher<span>.</span><span>group</span><span>(</span><span>1</span><span>)</span><span>)</span><span>;</span> <span>// "1230000"</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"group2="</span> <span>+</span> matcher<span>.</span><span>group</span><span>(</span><span>2</span><span>)</span><span>)</span><span>;</span> <span>// ""</span>
        <span>}</span>
    <span>}</span>
<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>我们期望分组匹配结果是：</p>
<table>
<thead>
<tr>
<th style="text-align:left">input</th>
<th style="text-align:left"><code>\d+</code></th>
<th style="text-align:left"><code>0*</code></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">123000</td>
<td style="text-align:left">&quot;123&quot;</td>
<td style="text-align:left">&quot;000&quot;</td>
</tr>
<tr>
<td style="text-align:left">10100</td>
<td style="text-align:left">&quot;101&quot;</td>
<td style="text-align:left">&quot;00&quot;</td>
</tr>
<tr>
<td style="text-align:left">1001</td>
<td style="text-align:left">&quot;1001&quot;</td>
<td style="text-align:left">&quot;&quot;</td>
</tr>
</tbody>
</table>
<p>但实际的分组匹配结果是这样的：</p>
<table>
<thead>
<tr>
<th style="text-align:left">input</th>
<th style="text-align:left"><code>\d+</code></th>
<th style="text-align:left"><code>0*</code></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">123000</td>
<td style="text-align:left">&quot;123000&quot;</td>
<td style="text-align:left">&quot;&quot;</td>
</tr>
<tr>
<td style="text-align:left">10100</td>
<td style="text-align:left">&quot;10100&quot;</td>
<td style="text-align:left">&quot;&quot;</td>
</tr>
<tr>
<td style="text-align:left">1001</td>
<td style="text-align:left">&quot;1001&quot;</td>
<td style="text-align:left">&quot;&quot;</td>
</tr>
</tbody>
</table>
<p>分析原因：</p>
<p>因为<code>\d+</code>确实可以匹配后面任意个<code>0</code>。正则表达式默认使用贪婪匹配，因此，<code>\d+</code>总是会把后面的<code>0</code>包含进来。</p>
<p>要让<code>\d+</code>尽量少匹配，让<code>0*</code>尽量多匹配，我们就必须让<code>\d+</code>使用非贪婪匹配。在规则<code>\d+</code>后面加个<code>?</code>即可表示非贪婪匹配。我们改写正则表达式为<code>(\d+?)(0*)</code>即可得到我们期望的结果。</p>
<h3 id="二-非贪婪匹配"> （二）非贪婪匹配</h3>
<blockquote>
<p>正则表达式<code>(\d??)(9*)</code></p>
</blockquote>
<p>注意<code>\d?</code>表示匹配0个或1个数字，后面第二个<code>?</code>表示非贪婪匹配。</p>
<p>给定字符串<code>&quot;9999&quot;</code>，匹配到的两个子串分别是<code>&quot;&quot;</code>和<code>&quot;9999&quot;</code>，因为对于<code>\d?</code>来说，可以匹配1个<code>9</code>，也可以匹配0个<code>9</code>，但是因为后面的<code>?</code>表示非贪婪匹配，它就会尽可能少的匹配，结果是匹配了0个<code>9</code>。</p>
<div><p>小结</p>
<p>正则表达式匹配默认使用贪婪匹配，给定一个匹配规则，加上<code>?</code>后就变成了非贪婪匹配。</p>
<p>注意区分<code>?</code>的含义：<code>\d??</code>。</p>
</div>
<h2 id="七、正则相关类"> 七、正则相关类</h2>
<h3 id="一-类"> （一）类</h3>
<p>java.util.regex 包主要包括以下三个类：</p>
<ul>
<li>
<p>Pattern 类：</p>
<p>pattern 对象是一个正则表达式的编译表示。Pattern 类没有公共构造方法。要创建一个 Pattern 对象，你必须首先调用其公共静态编译方法，它返回一个 Pattern 对象。该方法接受一个正则表达式作为它的第一个参数。如：</p>
<div><pre><code> <span>Pattern</span> p <span>=</span> <span>Pattern</span><span>.</span><span>compile</span><span>(</span><span>"\\wo\\w"</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div></li>
<li>
<p>Matcher 类：</p>
<p>Matcher 对象是对输入字符串进行解释和匹配操作的引擎。与Pattern 类一样，Matcher 也没有公共构造方法。你需要调用 Pattern 对象的 matcher 方法来获得一个 Matcher 对象。如：</p>
<div><pre><code> <span>Matcher</span> m <span>=</span> p<span>.</span><span>matcher</span><span>(</span><span>"hello regex"</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div></li>
<li>
<p>PatternSyntaxException：</p>
<p>PatternSyntaxException 是一个非强制异常类，它表示一个正则表达式模式中的语法错误。</p>
</li>
</ul>
<h3 id="二-捕获组"> （二）捕获组</h3>
<p>正是上文提到的分组匹配，这里补充一些相关概念以及方法的使用</p>
<p>捕获组是通过从左至右计算其开括号来编号。例如，在表达式（（A）（B（C））），有四个这样的组：</p>
<ul>
<li>((A)(B(C)))</li>
<li>(A)</li>
<li>(B(C))</li>
<li>(C)</li>
</ul>
<p>可以通过调用 matcher 对象的 groupCount 方法来查看表达式有多少个分组。groupCount 方法返回一个 int 值，表示matcher对象当前有多个捕获组。其实很简单，就是 <mark>看括号的层数，跟数据结构中提到的广义表深度类似</mark>。</p>
<p>还有一个特殊的组（group(0)），它总是代表整个表达式。<strong>该组不包括在 groupCount 的返回值中</strong>。</p>
<p><strong>示例</strong>：</p>
<div><pre><code><span>package</span> <span>regex</span><span>;</span>


<span>import</span> <span>org<span>.</span>junit<span>.</span>jupiter<span>.</span>api<span>.</span></span><span>Test</span><span>;</span>

<span>import</span> <span>java<span>.</span>util<span>.</span></span><span>HashMap</span><span>;</span>
<span>import</span> <span>java<span>.</span>util<span>.</span></span><span>Map</span><span>;</span>
<span>import</span> <span>java<span>.</span>util<span>.</span>regex<span>.</span></span><span>Matcher</span><span>;</span>
<span>import</span> <span>java<span>.</span>util<span>.</span>regex<span>.</span></span><span>Pattern</span><span>;</span>

<span>import</span> <span>static</span> <span>org<span>.</span>junit<span>.</span>jupiter<span>.</span>api<span>.</span></span><span>Assertions</span><span>.</span>assertEquals<span>;</span>


<span>class</span> <span>TemplateTest</span> <span>{</span>

	<span>@Test</span>
	<span>public</span> <span>void</span> <span>testIsValidTel</span><span>(</span><span>)</span> <span>{</span>
		<span>Template</span> t <span>=</span> <span>new</span> <span>Template</span><span>(</span><span>"Hello, ${name}! You are learning ${lang}!"</span><span>)</span><span>;</span>
		<span>Map</span><span><span>&lt;</span><span>String</span><span>,</span> <span>Object</span><span>></span></span> data <span>=</span> <span>new</span> <span>HashMap</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
		data<span>.</span><span>put</span><span>(</span><span>"name"</span><span>,</span> <span>"Bob"</span><span>)</span><span>;</span>
		data<span>.</span><span>put</span><span>(</span><span>"lang"</span><span>,</span> <span>"Java"</span><span>)</span><span>;</span>
		<span>assertEquals</span><span>(</span><span>"Hello, Bob! You are learning Java!"</span><span>,</span> t<span>.</span><span>render</span><span>(</span>data<span>)</span><span>)</span><span>;</span>
	<span>}</span>
	<span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span> <span>String</span><span>[</span><span>]</span> args <span>)</span><span>{</span>

		<span>// 按指定模式在字符串查找</span>
		<span>String</span> line <span>=</span> <span>"This order was placed for QT3000! OK?"</span><span>;</span>
		<span>String</span> pattern <span>=</span> <span>"(\\D*)(\\d+)(.*)"</span><span>;</span>

		<span>// 创建 Pattern 对象</span>
		<span>Pattern</span> r <span>=</span> <span>Pattern</span><span>.</span><span>compile</span><span>(</span>pattern<span>)</span><span>;</span>

		<span>// 现在创建 matcher 对象</span>
		<span>Matcher</span> m <span>=</span> r<span>.</span><span>matcher</span><span>(</span>line<span>)</span><span>;</span>
		<span>if</span> <span>(</span>m<span>.</span><span>find</span><span>(</span> <span>)</span><span>)</span> <span>{</span>
			<span>// 多少个分组</span>
			<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>m<span>.</span><span>groupCount</span><span>(</span><span>)</span><span>)</span><span>;</span>
			<span>//特殊的组group(0)，它总是代表整个表达式。该组不包括在 groupCount 的返回值中</span>
			<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"Found value: "</span> <span>+</span> m<span>.</span><span>group</span><span>(</span><span>0</span><span>)</span> <span>)</span><span>;</span>
			<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"Found value: "</span> <span>+</span> m<span>.</span><span>group</span><span>(</span><span>1</span><span>)</span> <span>)</span><span>;</span>
			<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"Found value: "</span> <span>+</span> m<span>.</span><span>group</span><span>(</span><span>2</span><span>)</span> <span>)</span><span>;</span>
			<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"Found value: "</span> <span>+</span> m<span>.</span><span>group</span><span>(</span><span>3</span><span>)</span> <span>)</span><span>;</span>
		<span>}</span> <span>else</span> <span>{</span>
			<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"NO MATCH"</span><span>)</span><span>;</span>
		<span>}</span>
	<span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br></div></div><div><pre><code>结果：
3
Found value: This order was placed for QT3000! OK?
Found value: This order was placed for QT
Found value: 3000
Found value: ! OK?
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h2 id="八、java-中正则表达式的应用"> 八、Java 中正则表达式的应用</h2>
<h3 id="一-判断功能"> （一）判断功能</h3>
<ul>
<li><code>public boolean matches(String regex)</code></li>
</ul>
<p>案例：判断录入的手机号是否为13或者18开头</p>
<div><pre><code><span>package</span> <span>Lemon</span><span>;</span>

<span>import</span> <span>java<span>.</span>util<span>.</span></span><span>Scanner</span><span>;</span>

<span>public</span> <span>class</span> <span>RegexDm</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span><span>{</span>
        <span>Scanner</span> sc <span>=</span> <span>new</span> <span>Scanner</span><span>(</span><span>System</span><span>.</span>in<span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"请输入手机号："</span><span>)</span><span>;</span>
        <span>String</span> s <span>=</span> sc<span>.</span><span>nextLine</span><span>(</span><span>)</span><span>;</span>

        <span>String</span> regex <span>=</span> <span>"1[38]\\d{9}"</span><span>;</span><span>//定义手机好规则</span>
        <span>boolean</span> flag <span>=</span> s<span>.</span><span>matches</span><span>(</span>regex<span>)</span><span>;</span><span>//判断功能</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"flag:"</span><span>+</span>flag<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><h3 id="二-分割功能"> （二）分割功能</h3>
<ul>
<li><code>public String[] split(String regex)</code></li>
</ul>
<div><pre><code><span>"a b c"</span><span>.</span><span>split</span><span>(</span><span>"\\s"</span><span>)</span><span>;</span> <span>// { "a", "b", "c" }</span>
<span>"a b  c"</span><span>.</span><span>split</span><span>(</span><span>"\\s"</span><span>)</span><span>;</span> <span>// { "a", "b", "", "c" }</span>
<span>"a, b ;; c"</span><span>.</span><span>split</span><span>(</span><span>"[\\,\\;\\s]+"</span><span>)</span><span>;</span> <span>// { "a", "b", "c" }</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>案例：</p>
<div><pre><code><span>package</span> <span>Lemon</span><span>;</span>

<span>import</span> <span>java<span>.</span>util<span>.</span></span><span>Scanner</span><span>;</span>

<span>public</span> <span>class</span> <span>RegexDm</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span><span>{</span>
        <span>String</span> age <span>=</span> <span>"18-24"</span><span>;</span><span>//定义年龄范围</span>
        <span>String</span> regex <span>=</span> <span>"-"</span><span>;</span>
        <span>String</span><span>[</span><span>]</span> strArr <span>=</span> age<span>.</span><span>split</span><span>(</span>regex<span>)</span><span>;</span><span>//分割成字符串数组</span>

        <span>int</span> startAge <span>=</span> <span>Integer</span><span>.</span><span>parseInt</span><span>(</span>strArr<span>[</span><span>0</span><span>]</span><span>)</span><span>;</span>
        <span>int</span> endAge <span>=</span> <span>Integer</span><span>.</span><span>parseInt</span><span>(</span>strArr<span>[</span><span>1</span><span>]</span><span>)</span><span>;</span>

        <span>Scanner</span> sc <span>=</span> <span>new</span> <span>Scanner</span><span>(</span><span>System</span><span>.</span>in<span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"请输入您的年龄："</span><span>)</span><span>;</span>
        <span>int</span> a <span>=</span> sc<span>.</span><span>nextInt</span><span>(</span><span>)</span><span>;</span>
        <span>if</span> <span>(</span>a <span>>=</span> startAge <span>&amp;&amp;</span> a <span>&lt;=</span> endAge<span>)</span><span>{</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"你就是我想找的"</span><span>)</span><span>;</span>
        <span>}</span><span>else</span><span>{</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"滚"</span><span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><h3 id="三-搜索功能"> （三）搜索功能</h3>
<ul>
<li><code>Matcher.find()</code></li>
</ul>
<div><pre><code><span>public</span> <span>class</span> <span>Main</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>String</span> s <span>=</span> <span>"the quick brown fox jumps over the lazy dog."</span><span>;</span>
        <span>Pattern</span> p <span>=</span> <span>Pattern</span><span>.</span><span>compile</span><span>(</span><span>"\\wo\\w"</span><span>)</span><span>;</span>
        <span>Matcher</span> m <span>=</span> p<span>.</span><span>matcher</span><span>(</span>s<span>)</span><span>;</span>
        <span>while</span> <span>(</span>m<span>.</span><span>find</span><span>(</span><span>)</span><span>)</span> <span>{</span>
            <span>String</span> sub <span>=</span> s<span>.</span><span>substring</span><span>(</span>m<span>.</span><span>start</span><span>(</span><span>)</span><span>,</span> m<span>.</span><span>end</span><span>(</span><span>)</span><span>)</span><span>;</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>sub<span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
<span>/**
 * 输出结果：
 *row
 *fox
 *dog
 */</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p>我们获取到<code>Matcher</code>对象后，不需要调用<code>matches()</code>方法（因为匹配整个串肯定返回false），而是反复调用<code>find()</code>方法，在整个串中搜索能匹配上<code>\\wo\\w</code>规则的子串，并打印出来。这种方式比<code>String.indexOf()</code>要灵活得多，因为我们搜索的规则是3个字符：中间必须是<code>o</code>，前后两个必须是字符<code>[A-Za-z0-9_]</code>。</p>
<h3 id="四-替换功能"> （四）替换功能</h3>
<ul>
<li><code>public String replaceAll(String regex,String replacement)</code></li>
</ul>
<p>案例：</p>
<div><pre><code><span>package</span> <span>Lemon</span><span>;</span>

<span>public</span> <span>class</span> <span>RegexDm</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span><span>{</span>
        <span>String</span> s <span>=</span> <span>"12342jasfkgnas234"</span><span>;</span>
        <span>//把字符串里面的数字替换成*</span>
        <span>String</span> regex <span>=</span> <span>"\\d"</span><span>;</span>
        <span>String</span> ss <span>=</span> <span>"*"</span><span>;</span>
        <span>String</span> result <span>=</span> s<span>.</span><span>replaceAll</span><span>(</span>regex<span>,</span>ss<span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>result<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h3 id="五-反向引用"> （五）反向引用</h3>
<p>如果我们要把搜索到的指定字符串按规则替换，比如前后各加一个<code>&lt;b&gt;xxxx&lt;/b&gt;</code>，这个时候，使用<code>replaceAll()</code>的时候，我们传入的第二个参数可以使用<code>$1</code>、<code>$2</code>来反向引用匹配到的子串。例如：</p>
<div><pre><code><span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
    <span>String</span> s <span>=</span> <span>"the quick brown fox jumps over the lazy dog."</span><span>;</span>
    <span>String</span> r <span>=</span> s<span>.</span><span>replaceAll</span><span>(</span><span>"\\s([a-z]{4})\\s"</span><span>,</span> <span>" &lt;b>$1&lt;/b> "</span><span>)</span><span>;</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>r<span>)</span><span>;</span>
<span>}</span>
<span>}</span>
<span>// 运行结果：</span>
<span>// the quick brown fox jumps &lt;b>over&lt;/b> the &lt;b>lazy&lt;/b> dog.</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><div><p>提示</p>
<p>实现替换的关键就在于<code>&quot; &lt;b&gt;$1&lt;/b&gt; &quot;</code>，它用匹配的分组子串<code>([a-z]{4})</code>替换了<code>$1</code></p>
</div>
<h3 id="六-练习"> （六）练习</h3>
<p>模板引擎是指，定义一个字符串作为模板：</p>
<div><pre><code><span>Hello</span><span>,</span> $<span>{</span>name<span>}</span><span>!</span> <span>You</span> are learning $<span>{</span>lang<span>}</span><span>!</span>
</code></pre>
<div><span>1</span><br></div></div><p>其中，以<code>${key}</code>表示的是变量，也就是将要被替换的内容</p>
<p>当传入一个<code>Map&lt;String, String&gt;</code>给模板后，需要把对应的key替换为Map的value。</p>
<p>例如，传入<code>Map</code>为：</p>
<div><pre><code><span>{</span>
    <span>"name"</span><span>:</span> <span>"Bob"</span><span>,</span>
    <span>"lang"</span><span>:</span> <span>"Java"</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>然后，<code>${name}</code>被替换为<code>Map</code>对应的值&quot;Bob”，<code>${lang}</code>被替换为<code>Map</code>对应的值&quot;Java&quot;，最终输出的结果为：</p>
<div><pre><code><span>Hello</span><span>,</span> <span>Bob</span><span>!</span> <span>You</span> are learning <span>Java</span><span>!</span>
</code></pre>
<div><span>1</span><br></div></div><p>请编写一个简单的模板引擎，利用正则表达式实现这个功能。</p>
<div><pre><code><span>package</span> <span>regex</span><span>;</span>

<span>import</span> <span>java<span>.</span>util<span>.</span></span><span>Map</span><span>;</span>
<span>import</span> <span>java<span>.</span>util<span>.</span>regex<span>.</span></span><span>Matcher</span><span>;</span>
<span>import</span> <span>java<span>.</span>util<span>.</span>regex<span>.</span></span><span>Pattern</span><span>;</span>

<span>/**
 * Learn Java from https://www.liaoxuefeng.com/
 *
 * @author liaoxuefeng
 */</span>
<span>public</span> <span>class</span> <span>Template</span> <span>{</span>

	<span>final</span> <span>String</span> template<span>;</span>
	<span>final</span> <span>Pattern</span> pattern <span>=</span> <span>Pattern</span><span>.</span><span>compile</span><span>(</span><span>"\\$\\{(\\w+)\\}"</span><span>)</span><span>;</span>

	<span>public</span> <span>Template</span><span>(</span><span>String</span> template<span>)</span> <span>{</span>
		<span>this</span><span>.</span>template <span>=</span> template<span>;</span>
	<span>}</span>
	<span>public</span> <span>String</span> <span>render</span><span>(</span><span>Map</span><span><span>&lt;</span><span>String</span><span>,</span> <span>Object</span><span>></span></span> data<span>)</span> <span>{</span>
	    <span>Matcher</span> m <span>=</span> pattern<span>.</span><span>matcher</span><span>(</span>template<span>)</span><span>;</span>
	    <span>StringBuffer</span> sb<span>=</span><span>new</span> <span>StringBuffer</span><span>(</span><span>)</span><span>;</span>
	    <span>while</span> <span>(</span>m<span>.</span><span>find</span><span>(</span><span>)</span><span>)</span> <span>{</span>
            <span>//从头开始将template的字符复制到sb上直到有字符被替换。第一次复制完成，sb里面存的是“Hello, Bob”</span>
            m<span>.</span><span>appendReplacement</span><span>(</span>sb<span>,</span>data<span>.</span><span>get</span><span>(</span>m<span>.</span><span>group</span><span>(</span><span>1</span><span>)</span><span>)</span><span>.</span><span>toString</span><span>(</span><span>)</span><span>)</span><span>;</span>
	    <span>}</span>
	    <span>//循环结束时sb里面存的是“Hello, Bob! You are learning java”</span>
        m<span>.</span><span>appendTail</span><span>(</span>sb<span>)</span><span>;</span><span>//将最后一次替换后剩下的字符复制到sb上</span>
        <span>return</span> sb<span>.</span><span>toString</span><span>(</span><span>)</span><span>;</span><span>//“Hello, Bob! You are learning java!”</span>

	<span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br></div></div><p>测试：</p>
<div><pre><code><span>package</span> <span>regex</span><span>;</span>


<span>import</span> <span>org<span>.</span>junit<span>.</span>jupiter<span>.</span>api<span>.</span></span><span>Test</span><span>;</span>

<span>import</span> <span>java<span>.</span>util<span>.</span></span><span>HashMap</span><span>;</span>
<span>import</span> <span>java<span>.</span>util<span>.</span></span><span>Map</span><span>;</span>

<span>import</span> <span>static</span> <span>org<span>.</span>junit<span>.</span>jupiter<span>.</span>api<span>.</span></span><span>Assertions</span><span>.</span>assertEquals<span>;</span>


<span>class</span> <span>TemplateTest</span> <span>{</span>

	<span>@Test</span>
	<span>public</span> <span>void</span> <span>testIsValidTel</span><span>(</span><span>)</span> <span>{</span>
		<span>Template</span> t <span>=</span> <span>new</span> <span>Template</span><span>(</span><span>"Hello, ${name}! You are learning ${lang}!"</span><span>)</span><span>;</span>
		<span>Map</span><span><span>&lt;</span><span>String</span><span>,</span> <span>Object</span><span>></span></span> data <span>=</span> <span>new</span> <span>HashMap</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
		data<span>.</span><span>put</span><span>(</span><span>"name"</span><span>,</span> <span>"Bob"</span><span>)</span><span>;</span>
		data<span>.</span><span>put</span><span>(</span><span>"lang"</span><span>,</span> <span>"Java"</span><span>)</span><span>;</span>
		<span>assertEquals</span><span>(</span><span>"Hello, Bob! You are learning Java!"</span><span>,</span> t<span>.</span><span>render</span><span>(</span>data<span>)</span><span>)</span><span>;</span>
	<span>}</span>
<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><h2 id="九、常用正则表达式"> 九、常用正则表达式</h2>
<h4 id="元字符及其在正则表达式上下文中的行为"> 元字符及其在正则表达式上下文中的行为</h4>
<ul>
<li><code>\</code> 将下一个字符标记为一个特殊字符、或一个原义字符、或一个后向引用、或一个八进制转义符。</li>
<li><code>^</code> 匹配输入字符串的开始位置。如果设置了 RegExp 对象的Multiline 属性，<code>^</code> 也匹配 <code>\n</code>或 <code>\r</code>之后的位置。</li>
<li><code>$</code> 匹配输入字符串的结束位置。如果设置了 RegExp 对象的Multiline 属性，<code>$</code> 也匹配 <code>\n</code>或 <code>\r</code>之前的位置。</li>
<li><code>*</code> 匹配前面的子表达式零次或多次。</li>
<li><code>+</code> 匹配前面的子表达式一次或多次。<code>+</code> 等价于 <code>{1,}</code>。</li>
<li><code>?</code> 匹配前面的子表达式零次或一次。<code>?</code> 等价于 <code>{0,1}</code>。</li>
<li><code>{n}</code> n 是一个非负整数，匹配确定的n 次。</li>
<li><code>{n,}</code> n 是一个非负整数，至少匹配n 次。</li>
<li><code>{n,m}</code> m 和 n 均为非负整数，其中n &lt;= m。最少匹配 n 次且最多匹配 m 次。在逗号和两个数之间不能有空格。</li>
<li><code>?</code> 当该字符紧跟在任何一个其他限制符 <code>(*, +, ?, {n}, {n,}, {n,m})</code> 后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。</li>
<li><code>.</code> 匹配除 <code>\n</code>之外的任何单个字符。要匹配包括 <code>\n</code> 在内的任何字符，请使用象 <code>[.\n]</code>的模式。</li>
<li><code>(pattern)</code> 匹配pattern 并获取这一匹配。</li>
<li><code>(?:pattern)</code> 匹配pattern 但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。</li>
<li><code>(?=pattern)</code> 正向预查，在任何匹配 pattern 的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。</li>
<li><code>(?!pattern)</code> 负向预查，与<code>(?=pattern)</code>作用相反</li>
<li><code>x|y</code> 匹配 <code>x</code> 或 <code>y</code>。</li>
<li><code>[xyz]</code> 字符集合。</li>
<li><code>[^xyz]</code> 负值字符集合。</li>
<li><code>[a-z]</code> 字符范围，匹配指定范围内的任意字符。</li>
<li><code>[^a-z]</code> 负值字符范围，匹配任何不在指定范围内的任意字符。</li>
<li><code>\b</code> 匹配一个单词边界，也就是指单词和空格间的位置。</li>
<li><code>\B</code> 匹配非单词边界。</li>
<li><code>\cx</code> 匹配由x指明的控制字符。</li>
<li><code>\d</code> 匹配一个数字字符。等价于 <code>[0-9]</code>。</li>
<li><code>\D</code> 匹配一个非数字字符。等价于 <code>[^0-9]</code>。</li>
<li><code>\f</code> 匹配一个换页符。等价于 <code>\x0c</code> 和 <code>\cL</code>。</li>
<li><code>\n</code> 匹配一个换行符。等价于 <code>\x0a</code> 和 <code>\cJ</code>。</li>
<li><code>\r</code> 匹配一个回车符。等价于 <code>\x0d</code> 和 <code>\cM</code>。</li>
<li><code>\s</code> 匹配任何空白字符，包括空格、制表符、换页符等等。等价于<code>[ \f\n\r\t\v]</code>。</li>
<li><code>\S</code> 匹配任何非空白字符。等价于 <code>[^ \f\n\r\t\v]</code>。</li>
<li><code>\t</code> 匹配一个制表符。等价于 <code>\x09</code> 和 <code>\cI</code>。</li>
<li><code>\v</code> 匹配一个垂直制表符。等价于 <code>\x0b</code> 和 <code>\cK</code>。</li>
<li><code>\w</code> 匹配包括下划线的任何单词字符。等价于<code>[A-Za-z0-9_]</code>。</li>
<li><code>\W</code> 匹配任何非单词字符。等价于 <code>[^A-Za-z0-9_]</code>。</li>
<li><code>\xn</code> 匹配 <code>n</code>，其中 <code>n</code> 为十六进制转义值。十六进制转义值必须为确定的两个数字长。</li>
<li><code>\num</code> 匹配 <code>num</code>，其中<code>num</code>是一个正整数。对所获取的匹配的引用。</li>
<li><code>\n</code> 标识一个八进制转义值或一个后向引用。如果 <code>\n</code> 之前至少 n 个获取的子表达式，则 n 为后向引用。否则，如果 n 为八进制数字 (0-7)，则 n 为一个八进制转义值</li>
<li><code>\nm</code> 标识一个八进制转义值或一个后向引用。如果 <code>\nm</code> 之前至少有is preceded by at least nm 个获取得子表达式，则 nm 为后向引用。如果 <code>\nm</code> 之前至少有 n 个获取，则 n 为一个后跟文字 m 的后向引用。如果前面的条件都不满足，若 n 和 m 均为八进制数字 (0-7)，则 <code>\nm</code> 将匹配八进制转义值 <code>nm</code></li>
<li><code>\nml</code> 如果 <code>n</code> 为八进制数字 (0-3)，且 <code>m</code> 和 <code>l</code> 均为八进制数字 (0-7)，则匹配八进制转义值 <code>nml</code></li>
<li><code>\un</code> 匹配 <code>n</code>，其中 <code>n</code> 是一个用四个十六进制数字表示的Unicode字符。</li>
<li>匹配中文字符的正则表达式： <code>[u4e00-u9fa5]</code></li>
<li>匹配双字节字符(包括汉字在内)：<code>[^x00-xff]</code></li>
<li>匹配空行的正则表达式：<code>n[s| ]*r</code></li>
<li>匹配HTML标记的正则表达式：<code>/&lt;(.*)&gt;.*&lt;/1&gt;|&lt;(.*) /&gt;/</code></li>
<li>匹配首尾空格的正则表达式：<code>(^s*)|(s*$)</code></li>
<li>匹配Email地址的正则表达式：<code>w+([-+.]w+)*@w+([-.]w+)*.w+([-.]w+)*</code></li>
<li>匹配网址URL的正则表达式：<code>http://([w-]+.)+[w-]+(/[w- ./?%&amp;=]*)?</code></li>
</ul>
<div><p>参考</p>
<p><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1255945288020320" target="_blank" rel="noopener noreferrer">廖雪峰Java教程 - 正则表达式</a></p>
<p><a href="https://www.runoob.com/java/java-regular-expressions.html" target="_blank" rel="noopener noreferrer">菜鸟教程 - 正则表达式</a></p>
</div>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <category term="Java"/>
    <contributor>
      <name>南辞</name>
    </contributor>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">Java基础</title>
    <id>http://qiqi.dreamagain.top/program/backend/java/solution/Java%E5%9F%BA%E7%A1%80/</id>
    <link href="http://qiqi.dreamagain.top/program/backend/java/solution/Java%E5%9F%BA%E7%A1%80/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<h2 id="问题"> 问题：</h2>
<h3 id="一、java概述"> 一、Java概述</h3>
<p>1、何为编程</p>
<p>2、什么是Java</p>
<p>3、jdk1.5之后的三大版本</p>
<p>4、JVM、JRE和JDK的关系</p>
<p>5、什么是跨平台性？原理是什么</p>
<p>6、Java语言有哪些特点？</p>
<p>7、什么是字节码？采用字节码的最大好处是什么</p>
<p>8、什么是Java程序的主类？应用程序和小程序的主类有何不同？</p>
<p>9、Java应用程序与小程序之间有那些差别？</p>
<p>10、Java和C++的区别</p>
<p>11、Oracle JDK 和 OpenJDK 的对比</p>
<h3 id="二、基础语法"> 二、基础语法</h3>
<h4 id="一-数据类型"> （一）数据类型</h4>
<p>1、Java有哪些数据类型</p>
<p>2、switch 是否能作用在 byte 上，是否能作用在 long 上，是否能作用在 String 上</p>
<p>3、用最有效率的方法计算 2 乘以 8</p>
<p>4、Math.round(11.5) 等于多少？Math.round(-11.5)等于多少</p>
<p>5、float f=3.4;是否正确</p>
<p>6、short s1 = 1; s1 = s1 + 1;有错吗?short s1 = 1; s1 += 1;有错吗</p>
<h4 id="二-编码"> （二）编码</h4>
<p>1、Java语言采用何种编码方案？有何特点？</p>
<h4 id="三-注释"> （三）注释</h4>
<p>1、什么Java注释</p>
<h4 id="四-访问修饰符"> （四）访问修饰符</h4>
<p>1、访问修饰符 public,private,protected,以及不写（默认）时的区别</p>
<h4 id="五-运算符"> （五）运算符</h4>
<p>1、&amp;和&amp;&amp;的区别</p>
<h4 id="六-关键字"> （六）关键字</h4>
<p>1、Java 有没有 goto</p>
<p>2、final 有什么用？</p>
<p>3、final finally finalize区别</p>
<p>4、this关键字的用法</p>
<p>5、super关键字的用法</p>
<p>6、this与super的区别</p>
<p>7、static存在的主要意义</p>
<p>8、static的独特之处</p>
<p>9、static应用场景</p>
<p>10、static注意事项</p>
<h4 id="七-流程控制"> （七）流程控制</h4>
<p>1、break ,continue ,return 的区别及作用</p>
<p>2、在 Java 中，如何跳出当前的多重嵌套循环</p>
<h3 id="三、面向对象"> 三、面向对象</h3>
<h4 id="一-面向对象概述"> （一）面向对象概述</h4>
<p>1、面向对象和面向过程的区别</p>
<h4 id="二-面向对象三大特性"> （二）面向对象三大特性</h4>
<p>2、面向对象的特征有哪些方面</p>
<p>3、什么是多态机制？Java语言是如何实现多态的？</p>
<p>4、面向对象七大基本原则是什么？</p>
<h4 id="三-类与接口"> （三）类与接口</h4>
<p>1、抽象类和接口的对比</p>
<p>2、普通类和抽象类有哪些区别？</p>
<p>3、抽象类能使用 final 修饰吗？</p>
<p>4、创建一个对象用什么关键字？对象实例与对象引用有何不同？</p>
<h4 id="四-变量与方法"> （四）变量与方法</h4>
<p>1、成员变量与局部变量的区别有哪些？</p>
<p>2、在Java中定义一个不做事且没有参数的构造方法的作用</p>
<p>3、在调用子类构造方法之前会先调用父类没有参数的构造方法，其目的是？</p>
<p>4、一个类的构造方法的作用是什么？若一个类没有声明构造方法，该程序能正确执行吗？为什么？</p>
<p>5、构造方法有哪些特点？</p>
<p>6、静态变量和实例变量区别</p>
<p>7、静态变量与普通变量区别</p>
<p>8、静态方法和实例方法有何不同？</p>
<p>9、在一个静态方法内调用一个非静态成员为什么是非法的？</p>
<p>10、什么是方法的返回值？返回值的作用是什么？</p>
<h4 id="五-内部类"> （五）内部类</h4>
<p>1、什么是内部类？</p>
<p>2、内部类的分类有哪些？</p>
<p>3、内部类的优点</p>
<p>4、内部类有哪些应用场景</p>
<p>5、局部内部类和匿名内部类访问局部变量的时候，为什么变量必须要加上final？</p>
<p>6、内部类相关，看程序说出运行结果</p>
<h4 id="六-重写与重载"> （六）重写与重载</h4>
<p>1、构造器（constructor）是否可被重写（override）</p>
<p>2、重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？</p>
<h4 id="七-对象相等判断"> （七）对象相等判断</h4>
<p>1、== 和 equals 的区别是什么</p>
<p>2、hashCode与 equals 方法 (<mark>重要</mark>)</p>
<p>4、对象的相等与指向他们的引用相等，两者有什么不同？</p>
<h4 id="八-值传递"> （八）值传递</h4>
<p>1、当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递</p>
<p>2、Java 中对象作为形参为什么还是值传递</p>
<p>3、值传递和引用传递有什么区别</p>
<h4 id="九-java包"> （九）Java包</h4>
<p>1、JDK 中常用的包有哪些</p>
<p>2、import java和javax有什么区别</p>
<h3 id="四、常用api"> 四、常用API</h3>
<h4 id="一-string相关"> （一）String相关</h4>
<p>1、字符型常量和字符串常量的区别</p>
<p>2、什么是字符串常量池？</p>
<p>3、String 是最基本的数据类型吗</p>
<p>4、String有哪些特性</p>
<p>5、String为什么是不可变的吗？</p>
<p>6、String真的是不可变的吗？</p>
<p>7、是否可以继承 String 类</p>
<p>8、String str=&quot;i&quot;与 String str=new String(&quot;i&quot;)一样吗？</p>
<p>9、String s = new String(&quot;xyz&quot;);创建了几个字符串对象</p>
<p>10、如何将字符串反转？</p>
<p>11、数组有没有 length()方法？String 有没有 length()方法</p>
<p>12、String 类的常用方法都有那些？</p>
<p>13、在使用 HashMap 的时候，用 String 做 key 有什么好处？</p>
<p>14、String和StringBuffer、StringBuilder的区别是什么？String为什么是不可变的</p>
<h4 id="二-date相关"> （二）Date相关</h4>
<h4 id="三-包装类相关"> （三）包装类相关</h4>
<p>1、自动装箱与拆箱</p>
<p>2、int 和 Integer 有什么区别</p>
<p>3、Integer a= 127 与 Integer b = 127相等吗</p>
<h2 id="参考答案"> 参考答案：</h2>
<h3 id="一、java概述-2"> 一、Java概述</h3>
<blockquote>
<p>1、何为编程</p>
</blockquote>
<p>编程就是让计算机为解决某个问题而使用某种程序设计语言编写程序代码，并最终得到结果的过程。为了使计算机能够理解人的意图，</p>
<p>人类就必须要将需解决的问题的思路、方法、和手段通过计算机能够理解的形式告诉计算机，使得计算机能够根据人的指令一步一步去</p>
<p>工作，完成某种特定的任务。这种人和计算机之间交流的过程就是编程。</p>
<blockquote>
<p>2、什么是Java</p>
</blockquote>
<p>Java是一门面向对象编程语言，不仅吸收了C++语言的各种优点，还摒弃了C++里难以理解的多继承、指针等概念，因此Java语言具有功</p>
<p>能强大和简单易用两个特征。Java语言作为静态面向对象编程语言的代表，极好地实现了面向对象理论，允许程序员以优雅的思维方式</p>
<p>进行复杂的编程 。</p>
<blockquote>
<p>3、jdk1.5之后的三大版本</p>
</blockquote>
<ol>
<li><strong>Java SE</strong>（J2SE，Java 2 Platform Standard Edition，标准版）
Java SE 以前称为 J2SE。它允许开发和部署在桌面、服务器、嵌入式环境和实时环境中使用的 Java 应用程序。Java SE 包含了支持 Java Web 服务开发的类，并为Java EE和Java ME提供基础。</li>
<li><strong>Java EE</strong>（J2EE，Java 2 Platform Enterprise Edition，企业版）
Java EE 以前称为 J2EE。企业版本帮助开发和部署可移植、健壮、可伸缩且安全的服务器端Java 应用程序。Java EE 是在 Java SE 的基础上构建的，它提供 Web 服务、组件模型、管理和通信 API，可以用来实现企业级的面向服务体系结构（service-oriented architecture，SOA）和 Web2.0应用程序。2018年2月，Eclipse 宣布正式将 JavaEE 更名为 JakartaEE</li>
<li><strong>Java ME</strong>（J2ME，Java 2 Platform Micro Edition，微型版）
Java ME 以前称为 J2ME。Java ME 为在移动设备和嵌入式设备（比如手机、PDA、电视机顶盒和打印机）上运行的应用程序提供一个健壮且灵活的环境。Java ME 包括灵活的用户界面、健壮的安全模型、许多内置的网络协议以及对可以动态下载的连网和离线应用程序的丰富支持。基于 Java ME 规范的应用程序只需编写一次，就可以用于许多设备，而且可以利用每个设备的本机功能。</li>
</ol>
<blockquote>
<p>4、JVM、JRE和JDK的关系</p>
</blockquote>
<p><strong>JVM:</strong></p>
<ul>
<li>Java Virtual Machine是Java虚拟机，Java程序需要运行在虚拟机上</li>
<li>不同的平台有自己的虚拟机，因此Java语言可以实现跨平台。</li>
</ul>
<p><strong>JRE:</strong></p>
<ul>
<li>Java Runtime Environment包括Java虚拟机和Java程序所需的核心类库等。</li>
<li>核心类库主要是java.lang包：包含了运行Java程序必不可少的系统类，如基本数据类型、基本数学函数、字符串处理、线程、异常处理类等，系统缺省加载这个包</li>
<li>如果想要运行一个开发好的Java程序，计算机中只需要安装JRE即可。</li>
</ul>
<p><strong>JDK：</strong></p>
<ul>
<li>Java Development Kit是提供给Java开发人员使用的</li>
<li>JDK包含了Java的开发工具，也包括了JRE。所以安装了JDK，就无需再单独安装JRE了。</li>
<li>JDK的开发工具：编译工具(javac.exe)，打包工具(jar.exe)等</li>
</ul>
<p>JVM&amp;JRE&amp;JDK关系图</p>
<img src="./assets/01.jpg" style="zoom:80%;" />
<blockquote>
<p>5、什么是跨平台性？原理是什么</p>
</blockquote>
<p>所谓跨平台性，是指java语言编写的程序，一次编译后，可以在多个系统平台上运行。</p>
<p>实现原理：Java程序是通过java虚拟机在系统平台上运行的，只要该系统可以安装相应的java虚拟机，该系统就可以运行java程序。</p>
<blockquote>
<p>6、Java语言有哪些特点</p>
</blockquote>
<p>简单易学（Java语言的语法与C语言和C++语言很接近）</p>
<p>面向对象（封装，继承，多态）</p>
<p>平台无关性（Java虚拟机实现平台无关性）</p>
<p>支持网络编程并且很方便（Java语言诞生本身就是为简化网络编程设计的）</p>
<p>支持多线程（多线程机制使应用程序在同一时间并行执行多项任）</p>
<p>健壮性（Java语言的强类型机制、异常处理、垃圾的自动收集等）</p>
<p>安全性</p>
<blockquote>
<p>7、什么是字节码？采用字节码的最大好处是什么</p>
</blockquote>
<p><strong>字节码</strong>：</p>
<p>Java源代码经过虚拟机编译器编译后产生的文件（即扩展为 <mark>.class的文件</mark> ），它不面向任何特定的处理器，只面向虚拟机。</p>
<p><strong>采用字节码的好处：</strong></p>
<p>Java语言通过字节码的方式，在一定程度上 <mark>解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。</mark> 所以Java程序运行时比较高效，而且，由于字节码并不专对一种特定的机器，因此，Java程序无须重新编译便可在多种不同的计算机上运行。</p>
<p>先看下java中的编译器和解释器：</p>
<div><pre><code><span>Java</span>源代码<span>--</span><span>--</span><span>></span>编译器<span>--</span><span>--</span><span>></span>jvm可执行的<span>Java</span>字节码<span>(</span>即虚拟指令<span>)</span><span>--</span><span>--</span><span>></span>jvm<span>--</span><span>--</span><span>></span>jvm中解释器<span>--</span><span>--</span><span>-></span>机器可执行的二进制机器码<span>--</span><span>--</span><span>></span>程序运行。

</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><ol>
<li>
<p>Java中引入了虚拟机的概念，即在机器和编译程序之间加入了一层抽象的虚拟机器。</p>
</li>
<li>
<p>这台虚拟的机器在任何平台上都提供给编译程序一个共同的接口。</p>
</li>
<li>
<p>编译程序只需要面向虚拟机，生成虚拟机能够理解的代码，然后由解释器来将虚拟机代码转换为特定系统的机器码执行。</p>
</li>
<li>
<p>在Java中，这种供虚拟机理解的代码叫做字节码（即扩展为.class的文件），它不面向任何特定的处理器，只面向虚拟机。</p>
</li>
<li>
<p>每一种平台的解释器是不同的，但是实现的虚拟机是相同的。</p>
</li>
<li>
<p>Java源程序经过编译器编译后变成字节码，字节码由虚拟机解释执行，虚拟机将每一条要执行的字节码送给解释器，解释器将其翻译成特定机器上的机器码，然后在特定的机器上运行，这就是上面提到的<strong>Java的特点的编译与解释并存</strong>的解释。</p>
</li>
</ol>
<blockquote>
<p>8、什么是Java程序的主类？应用程序和小程序的主类有何不同？</p>
</blockquote>
<ol>
<li>
<p>一个程序中可以有多个类，但只能有一个类是主类。</p>
</li>
<li>
<p>在Java应用程序中，这个主类是指包含main()方法的类。</p>
</li>
<li>
<p>而在Java小程序中，这个主类是一个继承自系统类JApplet或Applet的子类。</p>
</li>
<li>
<p>应用程序的主类不一定要求是public类，但小程序的主类要求必须是public类。主类是Java程序执行的入口点。</p>
</li>
</ol>
<blockquote>
<p>9、Java应用程序与小程序之间有那些差别？</p>
</blockquote>
<ol>
<li>
<p>简单说应用程序是从主线程启动(也就是main()方法)。</p>
</li>
<li>
<p>applet小程序没有main方法，主要是嵌在浏览器页面上运行(调用init()线程或者run()来启动)，嵌入浏览器这点跟flash的小游戏类似</p>
</li>
</ol>
<blockquote>
<p>10、Java和C++的区别</p>
</blockquote>
<ul>
<li>都是面向对象的语言，都支持封装、继承和多态</li>
<li>Java不提供指针来直接访问内存，程序内存更加安全</li>
<li>Java的类是单继承的，C++支持多重继承；虽然Java的类不可以多继承，但是接口可以多继承。</li>
<li>Java有自动内存管理机制，不需要程序员手动释放无用内存</li>
</ul>
<blockquote>
<p>11、Oracle JDK 和 OpenJDK 的对比</p>
</blockquote>
<ol>
<li>
<p>Oracle JDK版本将每三年发布一次，而OpenJDK版本每三个月发布一次；</p>
</li>
<li>
<p>OpenJDK 是一个参考模型并且是完全开源的，而Oracle JDK是OpenJDK的一个实现，并不是完全开源的；</p>
</li>
<li>
<p>Oracle JDK 比 OpenJDK 更稳定。OpenJDK和Oracle JDK的代码几乎相同，但Oracle JDK有更多的类和一些错误修复。因此，如果您想开发企业/商业软件，我建议您选择Oracle JDK，因为它经过了彻底的测试和稳定。某些情况下，有些人提到在使用OpenJDK 可能会遇到了许多应用程序崩溃的问题，但是，只需切换到Oracle JDK就可以解决问题；</p>
</li>
<li>
<p>在响应性和JVM性能方面，Oracle JDK与OpenJDK相比提供了更好的性能；</p>
</li>
<li>
<p>Oracle JDK不会为即将发布的版本提供长期支持，用户每次都必须通过更新到最新版本获得支持来获取最新版本；</p>
</li>
<li>
<p>Oracle JDK根据<strong>二进制代码许可协议</strong>获得许可，而OpenJDK根据<strong>GPL v2许可</strong>获得许可。</p>
</li>
</ol>
<h3 id="二、基础语法-2"> 二、基础语法</h3>
<h4 id="一-数据类型-2"> （一）数据类型</h4>
<p>定义：Java语言是强类型语言，对于每一种数据都定义了明确的具体的数据类型，在内存中分配了不同大小的内存空间。</p>
<p><strong>分类：</strong></p>
<p><strong>（1）基本数据类型：</strong></p>
<ol>
<li>数值型
<ul>
<li>整数类型(byte,short,int,long)</li>
<li>浮点类型(float,double)</li>
</ul>
</li>
<li>字符型(char)</li>
<li>布尔型(boolean)</li>
</ol>
<p><strong>（2）引用数据类型：</strong></p>
<ol>
<li>类(class)</li>
<li>接口(interface)</li>
<li>数组([])</li>
</ol>
<blockquote>
<p>1、Java有哪些数据类型</p>
</blockquote>
<p><img src="./assets/02.jpg" alt=""></p>
<blockquote>
<p>2、switch 是否能作用在 byte 上，是否能作用在 long 上，是否能作用在 String 上</p>
</blockquote>
<ol>
<li>在 Java 5 以前，switch(expr)中，expr 只能是 byte、short、char、int。</li>
<li>从 Java5 开始，Java 中引入了枚举类型，expr 也可以是 enum 类型，</li>
<li>从 Java 7 开始，expr 还可以是字符串（String），但是长整型（long）在目前所有的版本中都是不可以的。</li>
<li></li>
</ol>
<blockquote>
<p>3、用最有效率的方法计算 2 乘以 8</p>
</blockquote>
<p><code>2 &lt;&lt; 3</code>（左移 3 位相当于乘以 2 的 3 次方，右移 3 位相当于除以 2 的 3 次方）。</p>
<blockquote>
<p>4、Math.round(11.5) 等于多少？Math.round(-11.5)等于多少</p>
</blockquote>
<p>Math.round(11.5)的返回值是 12，Math.round(-11.5)的返回值是-11。</p>
<p>四舍五入的原理是在参数上加 0.5 然后进行下取整。</p>
<blockquote>
<p>5、float f=3.4;是否正确</p>
</blockquote>
<p>不正确。</p>
<p>3.4 是双精度数，将双精度型（double）赋值给浮点型（float）属于下转型（down-casting，也称为窄化）会造成精度损失。</p>
<p>因此需要强制类型转换float f =(float)3.4; 或者写成 float f =3.4F;。</p>
<blockquote>
<p>6、short s1 = 1; s1 = s1 + 1;有错吗?short s1 = 1; s1 += 1;有错吗</p>
</blockquote>
<p>对于 short s1 = 1; s1 = s1 + 1;由于 1 是 int 类型，因此 s1+1 运算结果也是 int型，需要强制转换类型才能赋值给 short 型。</p>
<p>而 short s1 = 1; s1 += 1;可以正确编译，因为 s1+= 1;相当于 s1 = (short(s1 + 1);其中有隐含的强制类型转换。</p>
<h4 id="二-编码-2"> （二）编码</h4>
<blockquote>
<p>1、Java语言采用何种编码方案？有何特点？</p>
</blockquote>
<p>Java语言采用Unicode编码标准</p>
<p>Unicode（标准码），它为每个字符制订了一个唯一的数值，因此在任何的语言，平台，程序都可以放心的使用。</p>
<h4 id="三-注释-2"> （三）注释</h4>
<blockquote>
<p>1、什么Java注释</p>
</blockquote>
<p>定义：用于解释说明程序的文字</p>
<p>Java的三种注释：</p>
<ul>
<li>单行注释: // 注释文字</li>
<li>多行注释: /* 注释文字 */</li>
<li>文档注释：/** 注释文字 */</li>
</ul>
<p><strong>作用</strong>：在程序中，尤其是复杂的程序中，适当地加入注释可以 <mark>增加程序的可读性，有利于程序的修改、调试和交流</mark></p>
<p>注释的内容在程序编译的时候会被忽视，不会产生目标代码，注释的部分不会对程序的执行结果产生任何影响。</p>
<p><strong>注意事项</strong>：多行和文档注释都不能嵌套使用。</p>
<h4 id="四-访问修饰符-2"> （四）访问修饰符</h4>
<blockquote>
<p>1、访问修饰符 public,private,protected,以及不写（默认）时的区别</p>
</blockquote>
<p><strong>定义</strong>：Java中，可以使用访问修饰符来保护对类、变量、方法和构造方法的访问。</p>
<p>​			 Java 支持 4 种不同的访问权限，为实现封装性提供了条件。</p>
<p><strong>分类：</strong></p>
<p>private : 在同一类内可见。使用对象：变量、方法。 注意：不能修饰类（外部类）</p>
<p>default (即缺省，什么也不写，不使用任何关键字）: 在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法。</p>
<p>protected : 对同一包内的类和所有子类可见。使用对象：变量、方法。 注意：不能修饰类（外部类）。</p>
<p>public : 对所有类可见。使用对象：类、接口、变量、方法</p>
<p>访问修饰符图
<img src="./assets/03.jpg" alt=""></p>
<h4 id="五-运算符-2"> （五）运算符</h4>
<blockquote>
<p>1、&amp;和&amp;&amp;的区别</p>
</blockquote>
<p>&amp;运算符有两种用法：(1)按位与；(2)逻辑与。</p>
<ul>
<li>&amp;&amp;是短路与</li>
<li>&amp;是逻辑与</li>
</ul>
<p><strong>相同点</strong>：二者都要求运算符左右两端的布尔值都是true 整个表达式的值才是 true</p>
<p><strong>不同的</strong>：&amp;&amp;之所以称为短路运算，是因为如果&amp;&amp;左边的表达式的值是 false，右边的表达式会被直接短路掉，不会进行运算。</p>
<p>注意：逻辑或运算符（|）和短路或运算符（||）的差别也是如此。</p>
<h4 id="六-关键字-2"> （六）关键字</h4>
<blockquote>
<p>1、Java 有没有 goto</p>
</blockquote>
<p>goto 是 Java 中的保留字，在目前版本的 Java 中没有使用。</p>
<blockquote>
<p>2、final 有什么用？</p>
</blockquote>
<p>用于修饰类、属性和方法；</p>
<ul>
<li>被final修饰的类不可以被继承,如String类</li>
<li>被final修饰的方法不可以被重写</li>
<li>被final修饰的变量不可以被改变，被final修饰不可变的是变量的引用，而不是引用指向的内容，引用指向的内容是可以改变的</li>
</ul>
<blockquote>
<p>3、final finally finalize区别</p>
</blockquote>
<ul>
<li>
<p>final可以修饰类、变量、方法，修饰类表示该类不能被继承、修饰方法表示该方法不能被重写、修饰变量表
示该变量是一个常量不能被重新赋值。</p>
</li>
<li>
<p>finally一般作用在try-catch代码块中，在处理异常的时候，通常我们将一定要执行的代码方法finally代码块
中，表示不管是否出现异常，该代码块都会执行，一般用来存放一些关闭资源的代码。</p>
</li>
<li>
<p>finalize是一个方法，属于Object类的一个方法，而Object类是所有类的父类，该方法一般由垃圾回收器来调
用，当我们调用System.gc() 方法的时候,只是提醒垃圾回收器作一次垃圾回收的操作，由垃圾回收器调用finalize()，</p>
<p>回收垃圾，一个对象是否可回收的最后判断。</p>
</li>
</ul>
<blockquote>
<p>4、this关键字的用法</p>
</blockquote>
<p>this是自身的一个对象，代表对象本身，可以理解为：指向对象本身的一个指针。</p>
<p>this的用法在java中大体可以分为3种：</p>
<ul>
<li>
<p>普通的直接引用，this相当于是指向当前对象本身。</p>
</li>
<li>
<p>形参与成员名字重名，用this来区分：</p>
</li>
<li>
<p>引用本类的构造函数</p>
</li>
</ul>
<div><pre><code><span>public</span> <span>Person</span><span>(</span><span>String</span> name<span>,</span> <span>int</span> age<span>)</span> <span>{</span>
    <span>this</span><span>.</span>name <span>=</span> name<span>;</span>
    <span>this</span><span>.</span>age <span>=</span> age<span>;</span>
<span>}</span>

<span>class</span> <span>Person</span><span>{</span>
    <span>private</span> <span>String</span> name<span>;</span>
    <span>private</span> <span>int</span> age<span>;</span>
    
    <span>public</span> <span>Person</span><span>(</span><span>)</span> <span>{</span>
    <span>}</span>
 
    <span>public</span> <span>Person</span><span>(</span><span>String</span> name<span>)</span> <span>{</span>
        <span>this</span><span>.</span>name <span>=</span> name<span>;</span>
    <span>}</span>
    <span>public</span> <span>Person</span><span>(</span><span>String</span> name<span>,</span> <span>int</span> age<span>)</span> <span>{</span>
        <span>this</span><span>(</span>name<span>)</span><span>;</span>
        <span>this</span><span>.</span>age <span>=</span> age<span>;</span>
    <span>}</span>
<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><blockquote>
<p>5、super关键字的用法</p>
</blockquote>
<p>super可以理解为是指向自己超（父）类对象的一个指针，而这个超类指的是离自己最近的一个父类。</p>
<p>super也有三种用法：</p>
<ol>
<li>
<p>普通的调用</p>
<p>与this类似，super相当于是指向当前对象的父类的引用，这样就可以用<code>super.xxx</code>来引用父类的成员。</p>
<p>（注意：super不是一个对象的引用，这里 <mark>只是说作用类似，不能将它赋值给另一个变量</mark> ，它只是指示编译器去调用父类方法的一个特殊关键词，这是super与this的区别所在）</p>
</li>
<li>
<p>子类中的成员变量或方法与父类中的成员变量或方法同名时，用super进行区分</p>
</li>
<li>
<p>引用父类构造函数</p>
<ul>
<li>
<p>super（参数）：调用父类中的某一个构造函数（应该为构造函数中的第一条语句）。</p>
</li>
<li>
<p>this（参数）：调用本类中另一种形式的构造函数（应该为构造函数中的第一条语句）。</p>
<p><mark>因此在同意构造函数中不能同时有super和this关键字</mark></p>
</li>
</ul>
</li>
</ol>
<div><pre><code><span>class</span> <span>Person</span><span>{</span>
    <span>protected</span> <span>String</span> name<span>;</span>
 
    <span>public</span> <span>Person</span><span>(</span><span>String</span> name<span>)</span> <span>{</span>
        <span>this</span><span>.</span>name <span>=</span> name<span>;</span>
    <span>}</span>
 
<span>}</span>
 
<span>class</span> <span>Student</span> <span>extends</span> <span>Person</span><span>{</span>
    <span>private</span> <span>String</span> name<span>;</span>
 
    <span>public</span> <span>Student</span><span>(</span><span>String</span> name<span>,</span> <span>String</span> name1<span>)</span> <span>{</span>
        <span>super</span><span>(</span>name<span>)</span><span>;</span>
        <span>this</span><span>.</span>name <span>=</span> name1<span>;</span>
    <span>}</span>
 
    <span>public</span> <span>void</span> <span>getInfo</span><span>(</span><span>)</span><span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>this</span><span>.</span>name<span>)</span><span>;</span>      <span>//Child</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>super</span><span>.</span>name<span>)</span><span>;</span>     <span>//Father</span>
    <span>}</span>
 
<span>}</span>

<span>public</span> <span>class</span> <span>Test</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
       <span>Student</span> s1 <span>=</span> <span>new</span> <span>Student</span><span>(</span><span>"Father"</span><span>,</span><span>"Child"</span><span>)</span><span>;</span>
       s1<span>.</span><span>getInfo</span><span>(</span><span>)</span><span>;</span>
 
    <span>}</span>
<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br></div></div><blockquote>
<p>6、this与super的区别</p>
</blockquote>
<ul>
<li>
<p>super:　它引用当前对象的直接父类中的成员（用来 <mark>访问直接父类中被隐藏的父类中成员数据或函数</mark> ），基类与派生类中有相同成员定义时如：super.变量名 super.成员函数据名（实参）</p>
</li>
<li>
<p>this：它代表当前对象名（在程序中易产生二义性之处，应使用this来指明当前对象；如果函数的形参与类中的成员数据同名，这时需用this来指明成员变量名）</p>
</li>
<li>
<p>super()和this()类似,区别是，super()在子类中调用父类的构造方法，this()在本类内调用本类的其它构造方法。</p>
</li>
<li>
<p><strong>super()和this()均需放在构造方法内第一行。</strong></p>
</li>
<li>
<p>尽管可以用this调用一个构造器，但却不能调用两个。</p>
</li>
<li>
<p><mark>this和super不能同时出现在一个构造函数里面</mark> ，因为this必然会调用其它的构造函数，其它的构造函数必然也会有super语句的存在，所以在同一个构造函数里面有相同的语句，就失去了语句的意义，编译器也不会通过。</p>
</li>
<li>
<p>this()和super()都指的是对象，所以，<mark>均不可以在static环境中使用</mark>。包括：static变量,static方法，static语句块。</p>
</li>
<li>
<p>从本质上讲，<mark>this是一个指向本对象的指针</mark>, 然而 <mark>super是一个Java关键字</mark>。</p>
</li>
</ul>
<blockquote>
<p>7、static存在的主要意义</p>
</blockquote>
<ul>
<li>
<p>static的主要意义是在于<strong>创建独立于具体对象的域变量或者方法</strong>。以致于即使没有创建对象，也能使用属性和调用方法！</p>
</li>
<li>
<p>static关键字还有一个比较关键的作用就是 用来形成<strong>静态代码块以优化程序性能</strong>。static块可以置于类中的任何地方，类中可以有多个static块。在类初次被加载的时候，会按照static块的顺序来执行每个static块，并且只会执行一次。</p>
</li>
<li>
<p>为什么说static块可以用来优化程序性能，是因为它的特性:<strong>只会在类加载的时候执行一次</strong>。因此，很多时候会将一些只需要进行一次的初始化操作都放在static代码块中进行。</p>
</li>
</ul>
<blockquote>
<p>8、static的独特之处</p>
</blockquote>
<p>1、被static修饰的变量或者方法是独立于该类的任何对象，也就是说，这些变量和方法不属于任何一个实例对象，而是<strong>被类的实例对</strong></p>
<p><strong>象所共享。</strong></p>
<p>怎么理解 “被类的实例对象所共享” 这句话呢？就是说，一个类的静态成员，它是属于大伙的【大伙指的是这个类的多个对象实例，我们</p>
<p>都知道一个类可以创建多个实例！】，所有的类对象共享的，不像成员变量是自个的【自个指的是这个类的单个实例对象】</p>
<p>2、在该类被第一次加载的时候，就会去加载被static修饰的部分，而且<strong>只在类第一次使用时加载并进行初始化</strong>，注意这是第</p>
<p>一次用就要初始化，后面根据需要是可以再次赋值的。</p>
<p>3、static变量值在<strong>类加载的时候分配空间</strong>，以后创建类对象的时候不会重新分配。赋值的话，是<strong>可以任意赋值</strong>的！</p>
<p>4、<strong>被static修饰的变量或者方法是优先于对象存在</strong>的，也就是说当一个类加载完毕之后，即便没有创建对象，也可以去访问。</p>
<blockquote>
<p>9、static应用场景</p>
</blockquote>
<p>因为static是被类的实例对象所共享，因此如果某个成员变量是被所有对象所共享的，那么这个成员变量就应该定义为静态变量。</p>
<p>因此比较常见的static应用场景有：</p>
<ol>
<li>修饰成员变量</li>
<li>修饰成员方法</li>
<li>静态代码块</li>
<li>修饰类【只能修饰内部类也就是静态内部类】</li>
<li>静态导包</li>
</ol>
<blockquote>
<p>10、static注意事项</p>
</blockquote>
<p>1、静态只能访问静态。</p>
<p>2、非静态既可以访问非静态的，也可以访问静态的。</p>
<h4 id="七-流程控制-2"> （七）流程控制</h4>
<blockquote>
<p>1、break ,continue ,return 的区别及作用</p>
</blockquote>
<p>break 跳出总上一层循环，不再执行循环(结束当前的循环体)</p>
<p>continue 跳出本次循环，继续执行下次循环(结束正在执行的循环 进入下一个循环条件)</p>
<p>return 程序返回，不再执行下面的代码(结束当前的方法 直接返回)</p>
<blockquote>
<p>2、在 Java 中，如何跳出当前的多重嵌套循环</p>
</blockquote>
<p>在Java中，要想跳出多重循环，可以在外面的循环语句前定义一个标签，然后在里层循环体的代码中使用带有标号的break 语句，即可跳出外层循环。例如：</p>
<div><pre><code><span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
    ok<span>:</span>
    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>10</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>
        <span>for</span> <span>(</span><span>int</span> j <span>=</span> <span>0</span><span>;</span> j <span>&lt;</span> <span>10</span><span>;</span> j<span>++</span><span>)</span> <span>{</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"i="</span> <span>+</span> i <span>+</span> <span>",j="</span> <span>+</span> j<span>)</span><span>;</span>
            <span>if</span> <span>(</span>j <span>==</span> <span>5</span><span>)</span> <span>{</span>
                <span>break</span> ok<span>;</span>
            <span>}</span>

        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h3 id="三、面向对象-2"> 三、面向对象</h3>
<h4 id="一-面向对象概述-2"> （一）面向对象概述</h4>
<blockquote>
<p>1、面向对象和面向过程的区别</p>
</blockquote>
<p><strong>(1)面向过程：</strong></p>
<p>​		优点：性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源;比如单片机、嵌入式开发、Linux/Unix等一般采用面向过程开发，性能是最重要的因素。</p>
<p>​		缺点：没有面向对象易维护、易复用、易扩展</p>
<p><strong>(2)面向对象：</strong></p>
<p>​		优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统更加灵活、更加易于维护</p>
<p>​		缺点：性能比面向过程低</p>
<p>面向过程是具体化的，流程化的，解决一个问题，你需要一步一步的分析，一步一步的实现。</p>
<p>面向对象是模型化的，你只需抽象出一个类，这是一个封闭的盒子，在这里你拥有数据也拥有解决问题的方法。需要什么功能直接使用就可以了，不必去一步一步的实现，至于这个功能是如何实现的，管我们什么事？我们会用就可以了。</p>
<p>面向对象的<strong>底层其实还是面向过程</strong>，把面向过程抽象成类，然后封装，方便我们使用的就是面向对象了。</p>
<h4 id="二-面向对象三大特性-2"> （二）面向对象三大特性</h4>
<blockquote>
<p>1、面向对象的特征有哪些方面</p>
</blockquote>
<p><strong>抽象：</strong></p>
<p>​		抽象是将一类对象的共同特征总结出来构造类的过程，包括数据抽象和行为抽象两方面。抽象只关注对象有哪些属性和行为，并不关注这些行为的细节是什么。</p>
<p><strong>封装:</strong></p>
<p>​		封装把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法，如果属性不想被外界访问，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。</p>
<p><strong>继承:</strong></p>
<p>​		继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承我们能够非常方便地复用以前的代码。</p>
<p>关于继承记住如下 3 点：</p>
<ul>
<li>
<p>子类拥有父类非 private 的属性和方法。</p>
</li>
<li>
<p>子类可以拥有自己属性和方法，即子类可以对父类进行扩展。</p>
</li>
<li>
<p>子类可以用自己的方式实现父类的方法。</p>
</li>
</ul>
<p><strong>多态:</strong></p>
<p>​		所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编译时并不确定，而是在程序运行期间才确定，即一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。</p>
<p>在Java中有两种形式可以实现多态：<strong>继承</strong>（多个子类对同一方法的重写）和 <strong>接口</strong>（实现接口并覆盖接口中同一方法）。</p>
<p>其中Java 面向对象编程三大特性：<mark>封装 、继承、 多态</mark></p>
<p><strong>封装</strong>：隐藏对象的属性和实现细节，仅对外提供公共访问方式，将变化隔离，便于使用，提高复用性和安全性。</p>
<p><strong>继承</strong>：继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但					不能选择性地继承父类。通过使用继承可以提高代码复用性。继承是多态的前提。</p>
<p><strong>多态性</strong>：父类或接口定义的引用变量可以指向子类或具体实现类的实例对象。提高了程序的拓展性。在Java中有两种形式可以实现多						态：继承（多个子类对同一方法的重写）和接口（实现接口并覆盖接口中同一方法）。</p>
<p><mark>方法重载</mark>(overload)实现的是编译时的多态性（也称为前绑定/<strong>静态绑定</strong>），而 <mark>方法重写</mark> 实现的是运行时的多态性（也		称为后绑定/<strong>动态绑定</strong>）。</p>
<p>一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。运行时的多态是面向对象最精髓的东西。</p>
<p>要实现<strong>多态的条件</strong>：</p>
<ul>
<li>方法重写（子类继承父类并重写父类中已有的或抽象的方法）；</li>
<li>对象造型（用父类型引用子类型对象，这样同样的引用调用同样的方法就会根据子类对象的不同而表现出不同的行为）。</li>
</ul>
<blockquote>
<p>2、什么是多态机制？Java语言是如何实现多态的？</p>
</blockquote>
<p>所谓多态就是指:程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编译时并不确定，而是在程序运行期间才确定，即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。因为在程序运行时才确定具体的类，这样，不用修改源程序代码，就可以让引用变量绑定到各种不同的类实现上，从而导致该引用调用的具体方法随之改变，即不修改程序代码就可以改变程序运行时所绑定的具体代码，让程序可以选择多个运行状态，这就是多态性。</p>
<p>多态分为<strong>编译时多态</strong>和<strong>运行时多态</strong>。</p>
<ul>
<li>
<p>其中编译时多态是静态的，主要是指方法的重载，它是根据参数列表的不同来区分不同的函数，通过编译之后会变成两个不同的函数，在运行时谈不上多态。</p>
</li>
<li>
<p>而运行时多态是动态的，它是通过动态绑定来实现的，也就是我们所说的多态性。</p>
</li>
</ul>
<p><strong>多态的实现</strong></p>
<p>Java实现多态有三个必要条件：<mark>继承、重写、向上转型。</mark></p>
<p>继承：在多态中必须存在有继承关系的子类和父类。</p>
<p>重写：子类对父类中某些方法进行重新定义，在调用这些方法时就会调用子类的方法。</p>
<p>向上转型：在多态中需要 <mark>将子类的对象赋给父类引用</mark>，只有这样该引用才能够具备技能调用父类的方法和子类的方法。</p>
<p>只有满足了上述三个条件，我们才能够在同一个继承结构中使用统一的逻辑实现代码处理不同的对象，从而达到执行不同的行为。</p>
<p>对于Java而言，它多态的实现机制遵循一个【<strong>原则</strong>】：<mark>当超类对象引用子类对象时，被引用对象的类型决定了调用谁的成员方法，但是这个被调用的方法必须是在超类中定义过的，也就是说被子类覆盖的方法。</mark></p>
<blockquote>
<p>3、面向对象七大基本原则是什么（可选）</p>
</blockquote>
<ol>
<li>
<p><strong>单一职责原则</strong>SRP(Single Responsibility Principle)
类的功能要单一，不能包罗万象，跟杂货铺似的。</p>
</li>
<li>
<p><strong>开放封闭原则</strong>OCP(Open－Close Principle)
一个模块对于拓展是开放的，对于修改是封闭的，想要增加功能热烈欢迎，想要修改，哼，一万个不乐意。</p>
</li>
<li>
<p><strong>里式替换原则</strong>LSP(the Liskov Substitution Principle LSP)
子类可以替换父类，出现在父类能够出现的任何地方。比如你能代表你爸去你姥姥家干活。</p>
</li>
<li>
<p><strong>依赖倒置原则</strong>DIP(the Dependency Inversion Principle DIP)
高层次的模块不应该依赖于低层次的模块，他们都应该依赖于抽象。<mark>抽象不应该依赖于具体实现，具体实现应该依赖于抽象</mark>。就是你出国要说你是中国人，而不能说你是哪个村子的。比如说中国人是抽象的，下面有具体的xx省，xx市，xx县。你要依赖的抽象是中国人，而不是你是xx村的。</p>
</li>
<li>
<p><strong>接口分离原则</strong>ISP(the Interface Segregation Principle ISP)
设计时采用多个与特定客户类有关的接口比采用一个通用的接口要好。就比如一个手机拥有打电话，看视频，玩游戏等功能，把这几个功能拆分成不同的接口，比在一个接口里要好的多。</p>
</li>
<li>
<p><strong>迪米特法则</strong></p>
<p>只与你的朋友交谈，不与“陌生人”说话，（降低耦合度）</p>
</li>
<li>
<p><strong>合成复用原则</strong></p>
<p>尽量使用组合和聚合的关系来实现，然后才考虑使用继承，使用继承时要考虑里氏替换</p>
</li>
</ol>
<h4 id="三-类与接口-2"> （三）类与接口</h4>
<blockquote>
<p>1、抽象类和接口的对比</p>
</blockquote>
<p>抽象类是用来捕捉子类的通用特性的。接口是抽象方法的集合。</p>
<p>从设计层面来说，<mark>抽象类是对类的抽象</mark>，是一种模板设计，<mark>接口是行为的抽象</mark>，是一种行为的规范。</p>
<p><strong>相同点</strong></p>
<ul>
<li>接口和抽象类都不能实例化</li>
<li>都位于继承的顶端，用于被其他实现或继承</li>
<li>都包含抽象方法，其子类都必须覆写这些抽象方法</li>
</ul>
<p><strong>不同点</strong></p>
<table>
<thead>
<tr>
<th>参数</th>
<th>抽象类</th>
<th>接口</th>
</tr>
</thead>
<tbody>
<tr>
<td>声明</td>
<td>抽象类使用abstract关键字声明</td>
<td>接口使用interface关键字声明</td>
</tr>
<tr>
<td>实现</td>
<td>子类使用<strong>extends</strong>关键字来继承抽象类。如果子类不是抽象类的话，它需要提供抽象类中所有声明的方法的实现</td>
<td>子类使用implements关键字来实现接口。它需要提供接口中所有声明的方法的实现</td>
</tr>
<tr>
<td>构造器</td>
<td>抽象类可以有构造器</td>
<td>接口没有构造器</td>
</tr>
<tr>
<td>访问修饰符</td>
<td>抽象类中的方法可以是任意访问修饰符</td>
<td>接口方法默认修饰符是public。并且不允许定义为 private 或者 protected</td>
</tr>
<tr>
<td>多继承</td>
<td>一个类最多只能继承一个抽象类</td>
<td>一个类可以实现多个接口</td>
</tr>
<tr>
<td>字段声明</td>
<td>抽象类的字段声明可以是任意的</td>
<td>接口的字段默认都是 static 和 final 的</td>
</tr>
</tbody>
</table>
<p><strong>备注</strong>：Java8中的接口引入默认方法和静态方法，以此来减少抽象类和接口之间的差异。</p>
<p>现在，我们可以为接口提供默认实现的方法了，并且不用强制子类来实现它。</p>
<p>接口和抽象类各有优缺点，在接口和抽象类的选择上，必须遵守这样一个原则：</p>
<p><mark>行为模型应该总是通过接口而不是抽象类定义，所以通常是优先选用接口，尽量少用抽象类。</mark></p>
<p>选择抽象类的时候通常是如下情况：需要定义子类的行为，又要为子类提供通用的功能。</p>
<blockquote>
<p>2、普通类和抽象类有哪些区别？</p>
</blockquote>
<ul>
<li>普通类不能包含抽象方法，抽象类可以包含抽象方法。</li>
<li>抽象类不能直接实例化，普通类可以直接实例化。</li>
</ul>
<blockquote>
<p>3、抽象类能使用 final 修饰吗？</p>
</blockquote>
<p>不能</p>
<p>定义抽象类就是让其他类继承的，如果定义为 final 该类就不能被继承，这样彼此就会产生矛盾，所以 final 不能修饰抽象类</p>
<blockquote>
<p>4、创建一个对象用什么关键字？对象实例与对象引用有何不同？</p>
</blockquote>
<p>new关键字</p>
<ol>
<li>new创建对象实例（<mark>对象</mark> 实例在 <mark>堆内存</mark> 中）</li>
<li>对象引用指向对象实例（对象 <mark>引用</mark> 存放在 <mark>栈内存</mark> 中）。</li>
<li>一个对象引用可以指向0个或1个对象（一根绳子可以不系气球，也可以系一个气球）</li>
<li>一个对象可以有n个引用指向它（可以用n条绳子系住一个气球）</li>
</ol>
<h4 id="四-变量与方法-2"> （四）变量与方法</h4>
<blockquote>
<p>1、成员变量与局部变量的区别有哪些</p>
</blockquote>
<p>变量：在程序执行的过程中，在某个范围内其值可以发生改变的量。从本质上讲，变量其实是内存中的一小块区域</p>
<p>成员变量：方法外部，类内部定义的变量</p>
<p>局部变量：类的方法中的变量。</p>
<p><strong>成员变量和局部变量的区别</strong></p>
<ul>
<li>
<p><strong>作用域</strong></p>
<p>成员变量：针对整个类有效。
局部变量：只在某个范围内有效。(一般指的就是方法,语句体内)</p>
</li>
<li>
<p><strong>存储位置</strong></p>
<p>成员变量：随着对象的创建而存在，随着对象的消失而消失，存储在 <mark>堆内存</mark> 中。
局部变量：在方法被调用，或者语句被执行的时候存在，存储在 <mark>栈内存</mark> 中。当方法调用完，或者语句结束后，就自动释放。</p>
</li>
<li>
<p><strong>生命周期</strong></p>
<p>成员变量：随着对象的创建而存在，随着对象的消失而消失
局部变量：当方法调用完，或者语句结束后，就自动释放。</p>
</li>
<li>
<p><strong>初始值</strong></p>
<p>成员变量：有默认初始值。</p>
<p>局部变量：没有默认初始值，使用前必须赋值。</p>
</li>
<li>
<p><strong>使用原则</strong></p>
<p>在使用变量时需要遵循的原则为：就近原则
首先在局部范围找，有就使用；接着在成员位置找。</p>
</li>
</ul>
<blockquote>
<p>2、在Java中定义一个不做事且没有参数的构造方法的作用</p>
</blockquote>
<ul>
<li>Java程序在执行子类的构造方法之前，如果没有用super()来调用父类特定的构造方法，则会调用父类中“没有参数的构造方法”。</li>
<li>因此，如果父类中只定义了有参数的构造方法，而在子类的构造方法中又没有用super()来调用父类中特定的构造方法，则编译时将发生错误，因为Java程序在父类中找不到没有参数的构造方法可供执行。解决办法是在父类里加上一个不做事且没有参数的构造方法。</li>
</ul>
<blockquote>
<p>3、在调用子类构造方法之前会先调用父类没有参数的构造方法，其目的是？</p>
</blockquote>
<p>帮助子类做初始化工作。</p>
<blockquote>
<p>4、一个类的构造方法的作用是什么？若一个类没有声明构造方法，该程序能正确执行吗？为什么？</p>
</blockquote>
<ul>
<li>主要作用是完成对类对象的初始化工作。</li>
<li>可以执行。因为一个类即使没有声明构造方法也会有默认的不带参数的构造方法。</li>
</ul>
<blockquote>
<p>5、构造方法有哪些特点？</p>
</blockquote>
<ol>
<li>
<p>名字与类名相同；</p>
</li>
<li>
<p>没有返回值，但不能用void声明构造函数；</p>
</li>
<li>
<p>生成类的对象时自动执行，无需调用。</p>
</li>
</ol>
<blockquote>
<p>6、静态变量和实例变量区别</p>
</blockquote>
<ul>
<li>
<p>静态变量：</p>
<p>1、静态变量由于不属于任何实例对象，属于类的，所以在内存中只会有一份</p>
<p>2、在类的加载过程中，JVM只为静态变量分配一次内存空间。</p>
</li>
<li>
<p>实例变量：</p>
<p>每次创建对象，都会为每个对象分配成员变量内存空间，实例变量是属于实例对象的，</p>
<p>在内存中，创建几次对象，就有几份成员变量。</p>
</li>
</ul>
<blockquote>
<p>7、静态变量与普通变量区别</p>
</blockquote>
<p>static变量也称作静态变量</p>
<p>静态变量和非静态变量的<strong>区别</strong>是：</p>
<ol>
<li>静态变量被所有的对象所共享，在内存中只有一个副本，它当且仅当在类初次加载时会被初始化。</li>
<li>而非静态变量是对象所拥有的，在创建对象的时候被初始化，存在多个副本，各个对象拥有的副本互不影响。</li>
<li>还有一点就是<strong>static成员变量的初始化顺序按照定义的顺序进行初始化</strong></li>
</ol>
<blockquote>
<p>8、静态方法和实例方法有何不同？</p>
</blockquote>
<p>静态方法和实例方法的区别主要体现在两个方面：</p>
<ul>
<li>
<p>在外部调用静态方法时，可以使用&quot;类名.方法名&quot;的方式，也可以使用&quot;对象名.方法名&quot;的方式。而实例方法只有后面这种方式。也就是说，调用静态方法可以无需创建对象。</p>
</li>
<li>
<p>静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），而不允许访问实例成员变量和实例方法；实例方法则无此限制</p>
</li>
</ul>
<blockquote>
<p>9、在一个静态方法内调用一个非静态成员为什么是非法的？</p>
</blockquote>
<p>由于静态方法可以不通过对象进行调用，因此在静态方法里，不能调用其他非静态变量，也不可以访问非静态变量成员。</p>
<blockquote>
<p>10、什么是方法的返回值？返回值的作用是什么？</p>
</blockquote>
<ul>
<li>方法的返回值是指我们获取到的某个方法体中的代码执行后产生的结果！（前提是该方法可能产生结果）。</li>
<li>返回值的作用：接收出结果，使得它可以用于其他的操作！</li>
</ul>
<h4 id="五-内部类-2"> （五）内部类</h4>
<blockquote>
<p>1、什么是内部类？</p>
</blockquote>
<ul>
<li>在Java中，可以将一个类的定义放在另外一个类的定义内部，这就是<strong>内部类</strong>。</li>
<li>内部类本身就是类的一个属性，与其他属性定义方式一致。</li>
</ul>
<blockquote>
<p>2、内部类的分类有哪些</p>
</blockquote>
<p>内部类可以分为四种：<strong>成员内部类、局部内部类、匿名内部类和静态内部类</strong>。</p>
<p><strong>（1）静态内部类</strong></p>
<p>定义在类内部的静态类，就是静态内部类。</p>
<div><pre><code><span>public</span> <span>class</span> <span>Outer</span> <span>{</span>

    <span>private</span> <span>static</span> <span>int</span> radius <span>=</span> <span>1</span><span>;</span>

    <span>static</span> <span>class</span> <span>StaticInner</span> <span>{</span>
        <span>public</span> <span>void</span> <span>visit</span><span>(</span><span>)</span> <span>{</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"visit outer static  variable:"</span> <span>+</span> radius<span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>静态内部类可以访问外部类所有的静态变量，而不可访问外部类的非静态变量；</p>
<p>静态内部类的创建方式，<code>new 外部类.静态内部类()</code>，如下：</p>
<div><pre><code><span>Outer<span>.</span>StaticInner</span> inner <span>=</span> <span>new</span> <span>Outer<span>.</span>StaticInner</span><span>(</span><span>)</span><span>;</span>
inner<span>.</span><span>visit</span><span>(</span><span>)</span><span>;</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><strong>（2）成员内部类</strong></p>
<p>定义在类内部，成员位置上的非静态类，就是成员内部类</p>
<div><pre><code><span>public</span> <span>class</span> <span>Outer</span> <span>{</span>

    <span>private</span> <span>static</span>  <span>int</span> radius <span>=</span> <span>1</span><span>;</span>
    <span>private</span> <span>int</span> count <span>=</span><span>2</span><span>;</span>
    
     <span>class</span> <span>Inner</span> <span>{</span>
        <span>public</span> <span>void</span> <span>visit</span><span>(</span><span>)</span> <span>{</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"visit outer static  variable:"</span> <span>+</span> radius<span>)</span><span>;</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"visit outer   variable:"</span> <span>+</span> count<span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>成员内部类可以访问外部类所有的变量和方法，包括静态和非静态，私有和公有。成员内部类依赖于外部类的实例，</p>
<p>它的创建方式<code>外部类实例.new 内部类()</code>，如下：</p>
<div><pre><code><span>Outer</span> outer <span>=</span> <span>new</span> <span>Outer</span><span>(</span><span>)</span><span>;</span>
<span>Outer<span>.</span>Inner</span> inner <span>=</span> outer<span>.</span><span>new</span> <span>Inner</span><span>(</span><span>)</span><span>;</span>
inner<span>.</span><span>visit</span><span>(</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><strong>（3）局部内部类</strong></p>
<p>定义在方法中的内部类，就是局部内部类。</p>
<div><pre><code><span>public</span> <span>class</span> <span>Outer</span> <span>{</span>

    <span>private</span>  <span>int</span> out_a <span>=</span> <span>1</span><span>;</span>
    <span>private</span> <span>static</span> <span>int</span> <span>STATIC_b</span> <span>=</span> <span>2</span><span>;</span>

    <span>public</span> <span>void</span> <span>testFunctionClass</span><span>(</span><span>)</span><span>{</span>
        <span>int</span> inner_c <span>=</span><span>3</span><span>;</span>
        <span>class</span> <span>Inner</span> <span>{</span>
            <span>private</span> <span>void</span> <span>fun</span><span>(</span><span>)</span><span>{</span>
                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>out_a<span>)</span><span>;</span>
                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>STATIC_b</span><span>)</span><span>;</span>
                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>inner_c<span>)</span><span>;</span>
            <span>}</span>
        <span>}</span>
        <span>Inner</span>  inner <span>=</span> <span>new</span> <span>Inner</span><span>(</span><span>)</span><span>;</span>
        inner<span>.</span><span>fun</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
    <span>public</span> <span>static</span> <span>void</span> <span>testStaticFunctionClass</span><span>(</span><span>)</span><span>{</span>
        <span>int</span> d <span>=</span><span>3</span><span>;</span>
        <span>class</span> <span>Inner</span> <span>{</span>
            <span>private</span> <span>void</span> <span>fun</span><span>(</span><span>)</span><span>{</span>
                <span>// System.out.println(out_a); 编译错误，定义在静态方法中的局部类不可以访问外部类的实例变量</span>
                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>STATIC_b</span><span>)</span><span>;</span>
                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>d<span>)</span><span>;</span>
            <span>}</span>
        <span>}</span>
        <span>Inner</span>  inner <span>=</span> <span>new</span> <span>Inner</span><span>(</span><span>)</span><span>;</span>
        inner<span>.</span><span>fun</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br></div></div><p>定义在实例方法中的局部类可以访问外部类的所有变量和方法，定义在静态方法中的局部类只能访问外部类的静态变量和方法。</p>
<p>局部内部类的创建方式，在对应方法内，<code>new 内部类()</code>，如下：</p>
<div><pre><code> <span>public</span> <span>static</span> <span>void</span> <span>testStaticFunctionClass</span><span>(</span><span>)</span><span>{</span>
    <span>class</span> <span>Inner</span> <span>{</span>
    <span>}</span>
    <span>Inner</span>  inner <span>=</span> <span>new</span> <span>Inner</span><span>(</span><span>)</span><span>;</span>
 <span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p><strong>（4）匿名内部类</strong></p>
<p>匿名内部类就是没有名字的内部类，日常开发中使用的比较多。</p>
<div><pre><code><span>public</span> <span>class</span> <span>Outer</span> <span>{</span>

    <span>private</span> <span>void</span> <span>test</span><span>(</span><span>final</span> <span>int</span> i<span>)</span> <span>{</span>
        <span>new</span> <span>Service</span><span>(</span><span>)</span> <span>{</span>
            <span>public</span> <span>void</span> <span>method</span><span>(</span><span>)</span> <span>{</span>
                <span>for</span> <span>(</span><span>int</span> j <span>=</span> <span>0</span><span>;</span> j <span>&lt;</span> i<span>;</span> j<span>++</span><span>)</span> <span>{</span>
                    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"匿名内部类"</span> <span>)</span><span>;</span>
                <span>}</span>
            <span>}</span>
        <span>}</span><span>.</span><span>method</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
 <span>}</span>
 <span>//匿名内部类必须继承或实现一个已有的接口 </span>
 <span>interface</span> <span>Service</span><span>{</span>
    <span>void</span> <span>method</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>除了没有名字，匿名内部类还有以下特点：</p>
<ul>
<li><mark>匿名内部类必须继承一个抽象类或者实现一个接口。</mark></li>
<li>匿名内部类不能定义任何静态成员和静态方法。</li>
<li>当所在的方法的形参需要被匿名内部类使用时，必须声明为 final。</li>
<li>匿名内部类不能是抽象的，它必须要实现继承的类或者实现的接口的所有抽象方法。</li>
</ul>
<p>匿名内部类创建方式：</p>
<div><pre><code><span>new</span> 类<span>/</span>接口<span>{</span> 
  <span>//匿名内部类实现部分</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><blockquote>
<p>3、内部类的优点</p>
</blockquote>
<p>我们为什么要使用内部类呢？因为它有以下优点：</p>
<ul>
<li>一个内部类对象可以访问创建它的外部类对象的内容，包括私有数据！</li>
<li>内部类不为同一包的其他类所见，具有很好的封装性；</li>
<li>内部类有效实现了“多重继承”，优化 java 单继承的缺陷。</li>
<li>匿名内部类可以很方便的定义回调。</li>
</ul>
<blockquote>
<p>4、内部类有哪些应用场景</p>
</blockquote>
<ol>
<li>一些多算法场合</li>
<li>解决一些非面向对象的语句块。</li>
<li>适当使用内部类，使得代码更加灵活和富有扩展性。</li>
<li>当某个类除了它的外部类，不再被其他的类使用时。</li>
</ol>
<blockquote>
<p>5、局部内部类和匿名内部类访问 <mark>局部变量</mark> 的时候，为什么变量必须 <mark>要加上final</mark> ？</p>
</blockquote>
<p>先看这段代码：</p>
<div><pre><code><span>public</span> <span>class</span> <span>Outer</span> <span>{</span>

    <span>void</span> <span>outMethod</span><span>(</span><span>)</span><span>{</span>
        <span>final</span> <span>int</span> a <span>=</span><span>10</span><span>;</span>
        <span>class</span> <span>Inner</span> <span>{</span>
            <span>void</span> <span>innerMethod</span><span>(</span><span>)</span><span>{</span>
                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>a<span>)</span><span>;</span>
            <span>}</span>

        <span>}</span>
    <span>}</span>
<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>以上例子，为什么要加final呢？是因为生命周期不一致， 局部变量直接存储在栈中，当方法执行结束后，非final的局部变量就被销毁。</p>
<p>而局部内部类对局部变量的引用依然存在，如果局部内部类要调用局部变量时，就会出错。加了final，可以确保局部内部类使用的变量</p>
<p>与外层的局部变量区分开，解决了这个问题。</p>
<blockquote>
<p>6、内部类相关，看程序说出运行结果</p>
</blockquote>
<div><pre><code><span>public</span> <span>class</span> <span>Outer</span> <span>{</span>
    <span>private</span> <span>int</span> age <span>=</span> <span>12</span><span>;</span>

    <span>class</span> <span>Inner</span> <span>{</span>
        <span>private</span> <span>int</span> age <span>=</span> <span>13</span><span>;</span>
        <span>public</span> <span>void</span> <span>print</span><span>(</span><span>)</span> <span>{</span>
            <span>int</span> age <span>=</span> <span>14</span><span>;</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"局部变量："</span> <span>+</span> age<span>)</span><span>;</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"内部类变量："</span> <span>+</span> <span>this</span><span>.</span>age<span>)</span><span>;</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"外部类变量："</span> <span>+</span> <span>Outer</span><span>.</span><span>this</span><span>.</span>age<span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>

    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>Outer<span>.</span>Inner</span> in <span>=</span> <span>new</span> <span>Outer</span><span>(</span><span>)</span><span>.</span><span>new</span> <span>Inner</span><span>(</span><span>)</span><span>;</span>
        in<span>.</span><span>print</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>

<span>}</span>
运行结果
局部变量：<span>14</span>
内部类变量：<span>13</span>
外部类变量：<span>12</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><h4 id="六-重写与重载-2"> （六）重写与重载</h4>
<blockquote>
<p>1、构造器（constructor）是否可被重写（override）</p>
</blockquote>
<p>构造器不能被继承，因此不能被重写，但可以被重载。</p>
<blockquote>
<p>2、重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？</p>
</blockquote>
<p><mark>方法的重载和重写都是实现多态的方式</mark>，区别在于前者实现的是 <mark>编译时的多态性</mark> ，而后者实现的是 <mark>运行时的多态性</mark>。</p>
<ul>
<li>
<p><strong>重载：</strong></p>
<p>1、发生在同一个类中，方法名相同参数列表不同（参数类型不同、个数不同、顺序不同），</p>
<p>2、与方法返回值和访问修饰符无关，即重载的方法不能根据返回类型进行区分</p>
</li>
<li>
<p><strong>重写：</strong></p>
<p>1、发生在父子类中，方法名、参数列表必须相同，</p>
<p>2、返回值小于等于父类，抛出的异常小于等于父类，</p>
<p>3、访问修饰符大于等于父类（里氏替换原则）</p>
<p>4、如果父类方法访问修饰符为private则子类中就不是重写。</p>
</li>
</ul>
<h4 id="七-对象相等判断-2"> （七）对象相等判断</h4>
<blockquote>
<p>1、== 和 equals 的区别是什么</p>
</blockquote>
<p><mark>==和equals都是值比较</mark></p>
<p><strong>（1）==</strong></p>
<ul>
<li>
<p>基本数据类型 == 比较的是值</p>
</li>
<li>
<p>引用数据类型 == 比较的是内存地址值</p>
</li>
</ul>
<p><strong>（2）equals() :</strong></p>
<p>​	对象之间进行比较的方法</p>
<ul>
<li>
<p>equals内部先进行的还是==，判断是否是同一个对象</p>
</li>
<li>
<p>接着才会是对象内容的比较（重写过equals方法）</p>
</li>
</ul>
<p><strong>equals() 一般有两种使用情况：</strong></p>
<ul>
<li>
<p>情况1：类没有覆盖 equals() 方法。则通过 equals() 比较该类的两个对象时，等价于通过“==”比较这两个对象。</p>
</li>
<li>
<p>情况2：类覆盖了 equals() 方法。一般，我们都覆盖 equals() 方法来两个对象的内容相等；若它们的内容相等，则返回 true (即认   为这两个对象相等)。</p>
</li>
</ul>
<div><pre><code><span>public</span> <span>class</span> test1 <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>String</span> a <span>=</span> <span>new</span> <span>String</span><span>(</span><span>"ab"</span><span>)</span><span>;</span> <span>// a 为一个引用</span>
        <span>String</span> b <span>=</span> <span>new</span> <span>String</span><span>(</span><span>"ab"</span><span>)</span><span>;</span> <span>// b为另一个引用,对象的内容一样</span>
        <span>String</span> aa <span>=</span> <span>"ab"</span><span>;</span> <span>// 放在常量池中</span>
        <span>String</span> bb <span>=</span> <span>"ab"</span><span>;</span> <span>// 从常量池中查找</span>
        <span>if</span> <span>(</span>aa <span>==</span> bb<span>)</span> <span>// true</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"aa==bb"</span><span>)</span><span>;</span>
        <span>if</span> <span>(</span>a <span>==</span> b<span>)</span> <span>// false，非同一对象</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"a==b"</span><span>)</span><span>;</span>
        <span>if</span> <span>(</span>a<span>.</span><span>equals</span><span>(</span>b<span>)</span><span>)</span> <span>// true</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"aEQb"</span><span>)</span><span>;</span>
        <span>if</span> <span>(</span><span>42</span> <span>==</span> <span>42.0</span><span>)</span> <span>{</span> <span>// true</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"true"</span><span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p>说明：</p>
<ul>
<li>String中的equals方法是被重写过的，因为object的equals方法是比较的对象的内存地址，而String的equals方法比较的是对象的内容。</li>
<li>当创建String类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个String对象。</li>
</ul>
<blockquote>
<p>2、hashCode 与 equals 方法 ( <mark>重要</mark> )</p>
</blockquote>
<p><strong>HashSet如何检查重复？</strong></p>
<p>两个对象的 hashCode() 相同，则 equals() 也一定为 true，对吗？</p>
<p>hashCode和equals方法的关系</p>
<p>面试官可能会问你：“你重写过 hashcode 和 equals 么，为什么重写equals时必须重写hashCode方法？”</p>
<p><strong>（1）hashCode()介绍</strong></p>
<p>hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个int整数。这个哈希码的作用是确定该对象在哈希表中的索引位</p>
<p>置。hashCode() 定义在JDK的Object.java中，这就意味着Java中的任何类都包含有hashCode()函数。散列表存储的是键值对(key-</p>
<p>value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）</p>
<p><strong>（2）为什么要有 hashCode</strong></p>
<p>我们以“HashSet 如何检查重复”为例子来说明为什么要有 hashCode：</p>
<p>当你把对象加入 HashSet 时，HashSet 会先计算对象的 hashcode 值来判断对象加入的位置，同时也会与其他已经加入的对象的</p>
<p>hashcode 值作比较，如果没有相符的hashcode，HashSet会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时</p>
<p>会调用 equals()方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让加入操作成功。如果不同的话，就</p>
<p>会重新散列到其他位置。（摘自我的Java启蒙书《Head first java》第二版）。这样我们就 <mark>大大减少了 equals 的次数</mark> ，相应就大大提高</p>
<p>了执行速度。</p>
<p><strong>（3）hashCode()与equals()的相关规定</strong></p>
<ul>
<li>
<p>如果两个对象相等，则hashcode一定也是相同的</p>
</li>
<li>
<p>两个对象相等，对两个对象分别调用equals方法都返回true</p>
</li>
<li>
<p>两个对象有相同的hashcode值，它们也不一定是相等的</p>
</li>
<li>
<p>hashCode() 的默认行为是对堆上的对象产生独特值。如果没有重写 hashCode()，</p>
<p>则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）</p>
</li>
<li>
<p><mark>因此，equals 方法被覆盖过，则 hashCode 方法也必须被覆盖</mark></p>
</li>
</ul>
<blockquote>
<p>3、对象的相等与指向他们的引用相等，两者有什么不同？</p>
</blockquote>
<p>对象的相等比的是内存中存放的内容是否相等，而引用相等 比较的是他们指向的内存地址是否相等。</p>
<h4 id="八-值传递-2"> （八）值传递</h4>
<blockquote>
<p>1、当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递</p>
</blockquote>
<p>是值传递。</p>
<ul>
<li>
<p>Java 语言的方法调用只支持参数的值传递。</p>
</li>
<li>
<p>当一个对象实例作为一个参数被传递到方法中时，<mark>参数的值就是对该对象的引用</mark> 。</p>
</li>
<li>
<p>对象的属性可以在被调用过程中被改变，但对对象引用的改变是不会影响到调用者的</p>
</li>
</ul>
<blockquote>
<p>2、 Java 中对象作为形参为什么还是值传递</p>
</blockquote>
<p>首先回顾一下在程序设计语言中有关将参数传递给方法（或函数）的一些专业术语。</p>
<ul>
<li>按值调用(call by value)表示方法接收的是调用者提供的值，</li>
<li>而按引用调用（call by reference)表示方法接收的是调用者提供的变量地址。</li>
<li><mark>一个方法可以修改传递引用所对应的变量值，而不能修改传递值所对应的变量值</mark> 。 它用来描述各种程序设计语言（不只是Java)中方法参数传递方式。</li>
<li>Java程序设计语言总是采用按值调用。也就是说，<mark>方法得到的是所有参数值的一个拷贝</mark> ，也就是说，方法不能修改传递给它的任何参数变量的内容。</li>
</ul>
<p>下面通过 3 个例子来说明</p>
<p>example1：</p>
<div><pre><code><span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
    <span>int</span> num1 <span>=</span> <span>10</span><span>;</span>
    <span>int</span> num2 <span>=</span> <span>20</span><span>;</span>

    <span>swap</span><span>(</span>num1<span>,</span> num2<span>)</span><span>;</span>

    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"num1 = "</span> <span>+</span> num1<span>)</span><span>;</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"num2 = "</span> <span>+</span> num2<span>)</span><span>;</span>
<span>}</span>

<span>public</span> <span>static</span> <span>void</span> <span>swap</span><span>(</span><span>int</span> a<span>,</span> <span>int</span> b<span>)</span> <span>{</span>
    <span>int</span> temp <span>=</span> a<span>;</span>
    a <span>=</span> b<span>;</span>
    b <span>=</span> temp<span>;</span>

    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"a = "</span> <span>+</span> a<span>)</span><span>;</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"b = "</span> <span>+</span> b<span>)</span><span>;</span>
<span>}</span>
a <span>=</span> <span>20</span>
b <span>=</span> <span>10</span>
num1 <span>=</span> <span>10</span>
num2 <span>=</span> <span>20</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><p><img src="./assets/04.jpg" alt=""></p>
<p>在swap方法中，a、b的值进行交换，并不会影响到 num1、num2。因为，a、b中的值，只是从 num1、num2 的复制过来的。也就是说，a、b相当于num1、num2 的副本，副本的内容无论怎么修改，都不会影响到原件本身。</p>
<p>通过上面例子，我们已经知道了一个方法不能修改一个基本数据类型的参数，而 <mark>对象引用作为参数就不一样</mark></p>
<p>example2 ：</p>
<div><pre><code>    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>int</span><span>[</span><span>]</span> arr <span>=</span> <span>{</span> <span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>4</span><span>,</span> <span>5</span> <span>}</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>arr<span>[</span><span>0</span><span>]</span><span>)</span><span>;</span>
        <span>change</span><span>(</span>arr<span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>arr<span>[</span><span>0</span><span>]</span><span>)</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>static</span> <span>void</span> <span>change</span><span>(</span><span>int</span><span>[</span><span>]</span> array<span>)</span> <span>{</span>
        <span>// 将数组的第一个元素变为0</span>
        array<span>[</span><span>0</span><span>]</span> <span>=</span> <span>0</span><span>;</span>
    <span>}</span>
结果：
    <span>0</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p><img src="./assets/05.jpg" alt=""></p>
<ul>
<li>
<p>array 被初始化 arr 的拷贝也就是一个对象的引用，也就是说 array 和 arr 指向的时同一个数组对象。 因此，外部对引用对象的改变会反映到所对应的对象上。</p>
</li>
<li>
<p>通过 example2 我们已经看到，实现一个改变对象参数状态的方法并不是一件难事。理由很简单，方法得到的是 <mark>对象引用的拷贝</mark>，对象引用及其他的拷贝同时引用同一个对象。</p>
</li>
<li>
<p>很多程序设计语言（特别是，C++和Pascal)提供了两种参数传递的方式：值调用和引用调用。有些程序员 <mark>认为Java程序设计语言对对象采用的是引用调用，实际上，这种理解是不对的</mark>。由于这种误解具有一定的普遍性，所以下面给出一个反例来详细地阐述一下这个问题。</p>
</li>
</ul>
<p>example3:</p>
<div><pre><code><span>public</span> <span>class</span> <span>Test</span> <span>{</span>

    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>// TODO Auto-generated method stub</span>
        <span>Student</span> s1 <span>=</span> <span>new</span> <span>Student</span><span>(</span><span>"小张"</span><span>)</span><span>;</span>
        <span>Student</span> s2 <span>=</span> <span>new</span> <span>Student</span><span>(</span><span>"小李"</span><span>)</span><span>;</span>
        <span>//s1,s2都是对象的引用，有自己的地址，它们各自存储这相应对象的地址</span>
        <span>Test</span><span>.</span><span>swap</span><span>(</span>s1<span>,</span> s2<span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"s1:"</span> <span>+</span> s1<span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"s2:"</span> <span>+</span> s2<span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>static</span> <span>void</span> <span>swap</span><span>(</span><span>Student</span> x<span>,</span> <span>Student</span> y<span>)</span> <span>{</span>
        <span>Student</span> temp <span>=</span> x<span>;</span>
        x <span>=</span> y<span>;</span>
        y <span>=</span> temp<span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"x:"</span> <span>+</span> x<span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"y:"</span> <span>+</span> y<span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
结果：
    x<span>:</span>小李
	y<span>:</span>小张
	s1<span>:</span>小张
	s2<span>:</span>小李

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><p>交换前：</p>
<p><img src="./assets/06.jpg" alt=""></p>
<p>交换后：</p>
<p><img src="./assets/07.jpg" alt=""></p>
<p>通过上面两张图可以很清晰的看出： 方法并没有改变存储在变量 s1 和 s2 中的对象引用。swap方法的参数x和y被初始化为两个对象引用的拷贝，这个方法交换的是这两个拷贝</p>
<p><strong>总结</strong></p>
<ol>
<li>
<p>Java程序设计语言对对象采用的不是引用调用，实际上，对象引用是按值传递的，只不过这个值是对应的内存地址，与基本数据类型稍微不同而已</p>
</li>
<li>
<p>或者只需要记住传参都是进行拷贝，  <mark>对象引用的拷贝与引用传递不一样</mark></p>
</li>
<li>
<p>一个引用有自己的地址，它还存储着所引用对象的地址。</p>
</li>
<li>
<p><strong>对象引用的拷贝</strong>就是是 <mark>传递引用里存储的内存地址</mark> ，而<strong>引用传递</strong>是 <mark>传递引用自己本身的地址</mark>。</p>
<div><pre><code> <span>Student</span> s1 <span>=</span> <span>new</span> <span>Student</span><span>(</span><span>"小张"</span><span>)</span><span>;</span>
<span>//假设s1地址为123,所指向的对象的地址为456</span>
<span>//Java的值传递:将地址456拷贝给形参</span>
<span>//引用传递:将地址123拷贝给形参</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div></li>
</ol>
<p><strong>总结一下Java中方法参数的使用情况：</strong></p>
<ul>
<li>一个方法不能修改一个基本数据类型的参数（即数值型或布尔型》</li>
<li>一个方法可以改变一个对象参数的状态。</li>
<li><mark>一个方法不能让对象参数引用一个新的对象。</mark></li>
</ul>
<blockquote>
<p>3、值传递和引用传递有什么区别</p>
</blockquote>
<p><strong>值传递</strong> ：指的是在方法调用时，传递的参数是按值的拷贝传递，传递的是值的拷贝，也就是说传递后就互不相关了。</p>
<p><strong>引用传递</strong>：指的是在方法调用时，传递的参数是按引用进行传递，<mark>传递的是引用的地址</mark>，也就是变量所对应的内存空间的地址。传递							 的是值的引用，也就是说传递前和传递后都指向同一个引用（也就是同一个内存空间）。</p>
<h4 id="九-java包-2"> （九）Java包</h4>
<blockquote>
<p>1、JDK 中常用的包有哪些</p>
</blockquote>
<p>java.lang：这个是系统的基础类，不用显示导入</p>
<p>java.io：这里面是所有输入输出有关的类，比如文件操作等；</p>
<p>java.nio：为了完善 io 包中的功能，提高 io 包中性能而写的一个新包；</p>
<p>java.net：这里面是与网络有关的类；</p>
<p>java.util：这个是系统辅助类，特别是集合类；</p>
<p>java.sql：这个是数据库操作的类。</p>
<blockquote>
<p>2、import java和javax有什么区别</p>
</blockquote>
<p>刚开始的时候 JavaAPI 所必需的包是 java 开头的包，javax 当时只是作为扩展 API 包来使用。后来考虑到将扩展从 javax 包移动到 java</p>
<p>包太麻烦了，最终会破坏一堆现有的代码，最终决定将 javax 包作为标准API的一部分。</p>
<p>所以，实际上java和javax没有区别。这都是一个名字。</p>
<h3 id="四、常用api-2"> 四、常用API</h3>
<h4 id="一-string相关-2"> （一）String相关</h4>
<blockquote>
<p>1、字符型常量和字符串常量的区别</p>
</blockquote>
<ul>
<li>形式上: 字符常量是单引号引起的一个字符 字符串常量是双引号引起的若干个字符</li>
<li>含义上: 字符常量相当于一个整形值(ASCII值),可以参加表达式运算 ,字符串常量代表一个地址值(该字符串在内存中存放位置)</li>
<li>占内存大小: 字符常量只占一个字节 字符串常量占若干个字节(至少一个字符结束标志)</li>
</ul>
<blockquote>
<p>2、什么是字符串常量池？</p>
</blockquote>
<ul>
<li>字符串常量池位于<strong>堆内存</strong>中，专门用来存储字符串常量，可以提高内存的使用率，避免开辟多块空间存储相同的字符串</li>
<li>在创建字符串时 JVM 会首先检查字符串常量池，如果该字符串已经存在池中，则返回它的引用，如果不存在，则实例化一个字符串放到池中，并返回其引用。</li>
</ul>
<blockquote>
<p>3、String 是最基本的数据类型吗</p>
</blockquote>
<p>不是。</p>
<ul>
<li>
<p>Java 中的基本数据类型只有 8 个 ：byte、short、int、long、float、double、char、boolean；</p>
</li>
<li>
<p>除了基本类型（primitive type），剩下的都是引用类型（referencetype），Java 5 以后引入的枚举类型也算是一种比较特殊的引用类型。</p>
</li>
<li>
<p>这是很基础的东西，但是很多初学者却容易忽视，Java 的 8 种基本数据类型中不包括 String，基本数据类型中用来描述文本数据的是 char，但是它只能表示单个字符，比如 ‘a’,‘好’ 之类的，如果要描述一段文本，就需要用多个 char 类型的变量，也就是一个 char 类型数组，比如“你好” 就是长度为2的数组 char[] chars = {‘你’,‘好’};</p>
</li>
<li>
<p>但是使用数组过于麻烦，所以就有了 String，String 底层就是一个 char 类型的数组，只是使用的时候开发者不需要直接操作底层数组，用更加简便的方式即可完成对字符串的使用。</p>
</li>
</ul>
<blockquote>
<p>4、String有哪些特性</p>
</blockquote>
<ul>
<li>
<p>不变性：String 是只读字符串，是一个典型的 immutable 对象，对它进行任何操作，其实都是创建一个新的对象，再把引用指向该对象。不变模式的主要作用在于当一个对象需要被多线程共享并频繁访问时，可以保证数据的一致性。</p>
</li>
<li>
<p>常量池优化：String 对象创建之后，会在字符串常量池中进行缓存，如果下次创建同样的对象时，会直接返回缓存的引用。</p>
</li>
<li>
<p>final：使用 final 来定义 String 类，表示 String 类不能被继承，提高了系统的安全性。</p>
</li>
</ul>
<blockquote>
<p>5、String为什么是不可变的吗？</p>
</blockquote>
<p>简单来说就是String类利用了final修饰的char类型数组存储字符，源码如下图所以：</p>
<div><pre><code><span>/** The value is used for character storage. */</span>
<span>private</span> <span>final</span> <span>char</span> value<span>[</span><span>]</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><blockquote>
<p>6、String真的是不可变的吗？</p>
</blockquote>
<p>我觉得如果别人问这个问题的话，回答不可变就可以了。 下面只是给大家看两个有代表性的例子：</p>
<p><strong>1) String不可变但不代表引用(句柄)不可以变</strong></p>
<div><pre><code><span>String</span> str <span>=</span> <span>"Hello"</span><span>;</span>
str <span>=</span> str <span>+</span> <span>" World"</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"str="</span> <span>+</span> str<span>)</span><span>;</span>
结果：
    str<span>=</span><span>Hello</span> <span>World</span>
实际上，原来<span>String</span>的内容是不变的，只是str由原来指向<span>"Hello"</span>的内存地址转为指向<span>"Hello World"</span>的内存地址而已，也就是说多开辟了一块内存区域给<span>"Hello World"</span>字符串。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p><strong>2) 通过反射是可以修改所谓的“不可变”对象</strong></p>
<div><pre><code><span>// 创建字符串"Hello World"， 并赋给引用s</span>
<span>String</span> s <span>=</span> <span>"Hello World"</span><span>;</span>

<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"s = "</span> <span>+</span> s<span>)</span><span>;</span> <span>// Hello World</span>

<span>// 获取String类中的value字段</span>
<span>Field</span> valueFieldOfString <span>=</span> <span>String</span><span>.</span><span>class</span><span>.</span><span>getDeclaredField</span><span>(</span><span>"value"</span><span>)</span><span>;</span>

<span>// 改变value属性的访问权限</span>
valueFieldOfString<span>.</span><span>setAccessible</span><span>(</span><span>true</span><span>)</span><span>;</span>

<span>// 获取s对象上的value属性的值</span>
<span>char</span><span>[</span><span>]</span> value <span>=</span> <span>(</span><span>char</span><span>[</span><span>]</span><span>)</span> valueFieldOfString<span>.</span><span>get</span><span>(</span>s<span>)</span><span>;</span>

<span>// 改变value所引用的数组中的第5个字符</span>
value<span>[</span><span>5</span><span>]</span> <span>=</span> <span>'_'</span><span>;</span>

<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"s = "</span> <span>+</span> s<span>)</span><span>;</span> <span>// Hello_World</span>
结果：
    s <span>=</span> <span>Hello</span> <span>World</span>
	s <span>=</span> <span>Hello_World</span>
用反射可以访问私有成员， 然后反射出<span>String</span>对象中的value属性， 进而改变通过获得的value引用改变数组的结构。但是一般我们不会这么做，这里只是简单提一下有这个东西。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><blockquote>
<p>7、是否可以继承 String 类</p>
</blockquote>
<p>String 类是 final 类，不可以被继承。</p>
<blockquote>
<p>8、String str=&quot;i&quot;与 String str=new String(&quot;i&quot;)一样吗？</p>
</blockquote>
<p>不一样，因为内存的分配方式不一样。</p>
<ul>
<li>String str=&quot;i&quot;的方式，java 虚拟机会将其分配到常量池中</li>
<li>而 String str=new String(“i”) 则会被分到堆内存中。</li>
</ul>
<blockquote>
<p>9、String s = new String(&quot;xyz&quot;);创建了几个字符串对象</p>
</blockquote>
<p>两个对象，一个是静态区的&quot;xyz&quot;，一个是用new创建在堆上的对象。（前提是之前字符串常量池中没有&quot;xyz&quot;）</p>
<div><pre><code><span>String</span> str1 <span>=</span> <span>"hello"</span><span>;</span> <span>//str1指向静态区</span>
<span>String</span> str2 <span>=</span> <span>new</span> <span>String</span><span>(</span><span>"hello"</span><span>)</span><span>;</span>  <span>//str2指向堆上的对象</span>
<span>String</span> str3 <span>=</span> <span>"hello"</span><span>;</span>
<span>String</span> str4 <span>=</span> <span>new</span> <span>String</span><span>(</span><span>"hello"</span><span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>str1<span>.</span><span>equals</span><span>(</span>str2<span>)</span><span>)</span><span>;</span> <span>//true</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>str2<span>.</span><span>equals</span><span>(</span>str4<span>)</span><span>)</span><span>;</span> <span>//true</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>str1 <span>==</span> str3<span>)</span><span>;</span> <span>//true</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>str1 <span>==</span> str2<span>)</span><span>;</span> <span>//false</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>str2 <span>==</span> str4<span>)</span><span>;</span> <span>//false</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>str2 <span>==</span> <span>"hello"</span><span>)</span><span>;</span> <span>//false</span>
str2 <span>=</span> str1<span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>str2 <span>==</span> <span>"hello"</span><span>)</span><span>;</span> <span>//true</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><blockquote>
<p>10、如何将字符串反转？</p>
</blockquote>
<p>使用 StringBuilder 或者 stringBuffer 的 reverse() 方法</p>
<div><pre><code><span>// StringBuffer reverse</span>
<span>StringBuffer</span> stringBuffer <span>=</span> <span>new</span> <span>StringBuffer</span><span>(</span><span>)</span><span>;</span>
stringBuffer<span>.</span> <span>append</span><span>(</span><span>"abcdefg"</span><span>)</span><span>;</span>
<span>System</span><span>.</span> out<span>.</span> <span>println</span><span>(</span>stringBuffer<span>.</span> <span>reverse</span><span>(</span><span>)</span><span>)</span><span>;</span> <span>// gfedcba</span>
<span>// StringBuilder reverse</span>
<span>StringBuilder</span> stringBuilder <span>=</span> <span>new</span> <span>StringBuilder</span><span>(</span><span>)</span><span>;</span>
stringBuilder<span>.</span> <span>append</span><span>(</span><span>"abcdefg"</span><span>)</span><span>;</span>
<span>System</span><span>.</span> out<span>.</span> <span>println</span><span>(</span>stringBuilder<span>.</span> <span>reverse</span><span>(</span><span>)</span><span>)</span><span>;</span> <span>// gfedcba</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><blockquote>
<p>11、数组有没有 length()方法？String 有没有 length()方法</p>
</blockquote>
<ul>
<li>数组没有 length()方法 ，有 length 的属性。</li>
<li>String 有 length()方法。</li>
<li>JavaScript中，获得字符串的长度是通过 length 属性得到的，这一点容易和 Java 混淆。</li>
</ul>
<blockquote>
<p>12、String 类的常用方法都有那些？</p>
</blockquote>
<ul>
<li>
<p>indexOf()：返回指定字符的索引。</p>
</li>
<li>
<p>charAt()：返回指定索引处的字符。</p>
</li>
<li>
<p>replace()：字符串替换。</p>
</li>
<li>
<p>trim()：去除字符串两端空白。</p>
</li>
<li>
<p>split()：分割字符串，返回一个分割后的字符串数组。</p>
</li>
<li>
<p>getBytes()：返回字符串的 byte 类型数组。</p>
</li>
<li>
<p>length()：返回字符串长度。</p>
</li>
<li>
<p>toLowerCase()：将字符串转成小写字母。</p>
</li>
<li>
<p>toUpperCase()：将字符串转成大写字符。</p>
</li>
<li>
<p>substring()：截取字符串。</p>
</li>
<li>
<p>equals()：字符串比较。</p>
</li>
</ul>
<blockquote>
<p>13、在使用 HashMap 的时候，用 String 做 key 有什么好处？</p>
</blockquote>
<p>HashMap 内部实现是通过 key 的 hashcode 来确定 value 的存储位置，因为字符串是不可变的，所以当创建字符串时，它的</p>
<p>hashcode 被缓存下来，不需要再次计算，所以相比于其他对象更快。</p>
<blockquote>
<p>14、String和StringBuffer、StringBuilder的区别是什么？String为什么是不可变的</p>
</blockquote>
<p><strong>可变性</strong></p>
<p>String类中使用字符数组保存字符串，private　final　char　value[]，所以string对象是不可变的。StringBuilder与StringBuffer都继承自AbstractStringBuilder类，在AbstractStringBuilder中也是使用字符数组保存字符串，char[] value，这两种对象都是可变的。</p>
<p><strong>线程安全性</strong></p>
<p>String中的对象是不可变的，也就可以理解为常量，线程安全。AbstractStringBuilder是StringBuilder与StringBuffer的公共父类，定义了一些字符串的基本操作，如expandCapacity、append、insert、indexOf等公共方法。StringBuffer对方法加了<strong>同步锁</strong>或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder并没有对方法进行加同步锁，所以是非线程安全的。</p>
<p><strong>性能</strong></p>
<p>每次对String 类型进行改变的时候，都会生成一个新的String对象，然后将指针指向新的String 对象。StringBuffer每次都会对StringBuffer对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用StirngBuilder 相比使用StringBuffer 仅能获得10%~15% 左右的性能提升，但却要冒多线程不安全的风险。</p>
<p><strong>对于三者使用的总结</strong></p>
<p>如果要操作少量的数据用   String</p>
<p>单线程操作字符串缓冲区 下操作大量数据  StringBuilder</p>
<p>多线程操作字符串缓冲区 下操作大量数据  StringBuffer</p>
<h4 id="二-date相关-2"> （二）Date相关</h4>
<h4 id="三-包装类相关-2"> （三）包装类相关</h4>
<blockquote>
<p>1、自动装箱与拆箱</p>
</blockquote>
<p><strong>装箱</strong>：将基本类型用它们对应的引用类型包装起来；</p>
<p><strong>拆箱</strong>：将包装类型转换为基本数据类型；</p>
<blockquote>
<p>2、int 和 Integer 有什么区别</p>
</blockquote>
<ul>
<li>Java 是一个近乎纯洁的面向对象编程语言，但是为了编程的方便还是引入了基本数据类型，</li>
<li><mark>为了能够将这些基本数据类型当成对象操作</mark>，Java 为每一个基本数据类型都引入了对应的包装类型（wrapper class），</li>
<li>从 Java 5 开始引入了自动装箱/拆箱机制，使得二者可以相互转换。</li>
</ul>
<p>Java 为每个原始类型提供了<strong>包装类型</strong>：</p>
<ul>
<li>
<p>原始类型: boolean，char，byte，short，int，long，float，double</p>
</li>
<li>
<p>包装类型：Boolean，Character，Byte，Short，Integer，Long，Float，Double</p>
</li>
</ul>
<blockquote>
<p>3、Integer a= 127 与 Integer b = 127相等吗</p>
</blockquote>
<p>相等。</p>
<ul>
<li>对于对象引用类型：== 比较的是对象的内存地址。</li>
<li>对于基本数据类型：==比较的是值。</li>
</ul>
<p>如果整型字面量的值在-128到127之间，那么自动装箱时不会new新的Integer对象，而是直接引用 <mark>常量池</mark> 中的Integer对象，</p>
<p>超过范围 a==b的结果是false</p>
<div><pre><code><span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
    <span>Integer</span> a <span>=</span> <span>new</span> <span>Integer</span><span>(</span><span>3</span><span>)</span><span>;</span>
    <span>Integer</span> b <span>=</span> <span>3</span><span>;</span>  <span>// 将3自动装箱成Integer类型</span>
    <span>int</span> c <span>=</span> <span>3</span><span>;</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>a <span>==</span> b<span>)</span><span>;</span> <span>// false 两个引用没有引用同一对象</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>a <span>==</span> c<span>)</span><span>;</span> <span>// true a自动拆箱成int类型再和c比较</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>b <span>==</span> c<span>)</span><span>;</span> <span>// true</span>

    <span>Integer</span> a1 <span>=</span> <span>128</span><span>;</span>
    <span>Integer</span> b1 <span>=</span> <span>128</span><span>;</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>a1 <span>==</span> b1<span>)</span><span>;</span> <span>// false</span>

    <span>Integer</span> a2 <span>=</span> <span>127</span><span>;</span>
    <span>Integer</span> b2 <span>=</span> <span>127</span><span>;</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>a2 <span>==</span> b2<span>)</span><span>;</span> <span>// true</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><h3 id="五、常用工具类库"> 五、常用工具类库</h3>
<h3 id="六、单元测试"> 六、单元测试</h3>
<h3 id="七、日志"> 七、日志</h3>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <contributor>
      <name>南辞</name>
    </contributor>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">Java进阶</title>
    <id>http://qiqi.dreamagain.top/program/backend/java/solution/Java%E8%BF%9B%E9%98%B6/</id>
    <link href="http://qiqi.dreamagain.top/program/backend/java/solution/Java%E8%BF%9B%E9%98%B6/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<h2 id="问题"> 问题：</h2>
<h3 id="一、集合-容器"> 一、集合/容器</h3>
<h4 id="一-概述"> （一）概述</h4>
<ol>
<li>
<p>什么是集合</p>
</li>
<li>
<p>集合的特点</p>
</li>
<li>
<p>集合和数组的区别</p>
</li>
<li>
<p>使用集合框架的好处</p>
</li>
<li>
<p>常用的集合类有哪些？</p>
</li>
<li>
<p>List，Set，Map三者的区别？List、Set、Map 是否继承自 Collection 接口？List、Map、Set 三个接口存取元素时，各有什么特点？</p>
</li>
<li>
<p>哪些集合类是线程安全的？</p>
</li>
<li>
<p>Java集合的快速失败机制 “fail-fast”？</p>
</li>
<li>
<p>怎么确保一个集合不能被修改？</p>
</li>
</ol>
<h4 id="二-collection接口"> （二）Collection接口</h4>
<h5 id="_1-list接口"> （1）List接口</h5>
<ol>
<li>迭代器 Iterator 是什么？</li>
<li>Iterator 怎么使用？有什么特点？</li>
<li>如何边遍历边移除 Collection 中的元素？</li>
<li>Iterator 和 ListIterator 有什么区别？</li>
<li>遍历一个 List 有哪些不同的方式？每种方法的实现原理是什么？Java 中 List 遍历的最佳实践是什么？</li>
<li>说一下 ArrayList 的优缺点</li>
<li>如何实现数组和 List 之间的转换？</li>
<li>ArrayList 和 LinkedList 的区别是什么？</li>
<li>ArrayList 和 Vector 的区别是什么？</li>
<li>插入数据时，ArrayList、LinkedList、Vector谁速度较快？阐述 ArrayList、Vector、LinkedList 的存储性能和特性？</li>
<li>多线程场景下如何使用 ArrayList？</li>
<li>为什么 ArrayList 的 elementData 加上 transient 修饰？</li>
<li>List 和 Set 的区别</li>
</ol>
<h5 id="_2-set接口"> （2）Set接口</h5>
<ol>
<li>说一下 HashSet 的实现原理？</li>
<li>HashSet如何检查重复？HashSet是如何保证数据不可重复的？</li>
<li>HashSet与HashMap的区别</li>
</ol>
<h5 id="_3-queue接口"> （3）Queue接口</h5>
<ol>
<li>BlockingQueue是什么？</li>
<li>在 Queue 中 poll()和 remove()有什么区别？</li>
</ol>
<h4 id="三-map接口"> （三）Map接口</h4>
<ol>
<li>说一下 HashMap 的实现原理？</li>
<li>HashMap在JDK1.7和JDK1.8中有哪些不同？HashMap的底层实现</li>
<li>HashMap的put方法的具体流程？</li>
<li>HashMap的扩容操作是怎么实现的？</li>
<li>HashMap是怎么解决哈希冲突的？</li>
<li>能否使用任何类作为 Map 的 key？</li>
<li>为什么HashMap中String、Integer这样的包装类适合作为K？</li>
<li>如果使用Object作为HashMap的Key，应该怎么办呢？</li>
<li>HashMap为什么不直接使用hashCode()处理后的哈希值直接作为table的下标？</li>
<li>HashMap 的长度为什么是2的幂次方</li>
<li>HashMap 与 HashTable 有什么区别？</li>
<li>如何决定使用 HashMap 还是 TreeMap？</li>
<li>HashMap 和 ConcurrentHashMap 的区别</li>
<li>ConcurrentHashMap 和 Hashtable 的区别？</li>
</ol>
<h4 id="四-辅助工具类"> （四）辅助工具类</h4>
<ol>
<li>Array 和 ArrayList 有何区别？</li>
<li>如何实现 Array 和 List 之间的转换？</li>
<li>comparable 和 comparator的区别？</li>
<li>Collection 和 Collections 有什么区别？</li>
<li>TreeMap 和 TreeSet 在排序时如何比较元素？Collections 工具类中的 sort()方法如何比较元素？</li>
</ol>
<h3 id="二、泛型"> 二、泛型</h3>
<h3 id="三、异常"> 三、异常</h3>
<ol>
<li>Error 和 Exception 区别是什么？</li>
<li>运行时异常和一般异常(受检异常)区别是什么？</li>
<li>JVM 是如何处理异常的？</li>
<li>throw 和 throws 的区别是什么？</li>
<li>final、finally、finalize 有什么区别？</li>
<li>NoClassDefFoundError 和 ClassNotFoundException 区别？</li>
<li>try-catch-finally 中哪个部分可以省略？</li>
<li>try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？</li>
<li>类 ExampleA 继承 Exception，类 ExampleB 继承ExampleA。</li>
<li>常见的 RuntimeException 有哪些？</li>
<li>Java常见异常有哪些？</li>
</ol>
<h3 id="四、io流"> 四、IO流</h3>
<ol>
<li>Java 中 IO 流分为几种?</li>
<li>BIO,NIO,AIO 有什么区别?</li>
<li>Files的常用方法都有哪些？</li>
</ol>
<h3 id="五、注解"> 五、注解</h3>
<ol>
<li>谈谈你对Java中注解的理解</li>
<li>Java中的元注解有哪些？</li>
</ol>
<h3 id="六、反射"> 六、反射</h3>
<ol>
<li>什么是反射机制？</li>
<li>反射机制优缺点</li>
<li>反射机制的应用场景有哪些？</li>
<li>Java获取反射的三种方法</li>
</ol>
<h3 id="七、网络"> 七、网络</h3>
<ol>
<li>
<p>为什么TCP连接的时候是3次？2次不可以吗？</p>
</li>
<li>
<p>为什么TCP连接的时候是3次，关闭的时候却是4次？</p>
</li>
<li>
<p>为什么客户端发出第四次挥手的确认报文后要等2MSL的时间才能释放TCP连接？</p>
</li>
<li>
<p>如果已经建立了连接，但是客户端突然出现故障了怎么办？</p>
</li>
<li>
<p>什么是HTTP，HTTP 与 HTTPS 的区别</p>
</li>
<li>
<p>常用HTTP状态码</p>
</li>
<li>
<p>GET和POST区别</p>
</li>
<li>
<p>什么是对称加密与非对称加密</p>
</li>
<li>
<p>什么是HTTP2</p>
</li>
<li>
<p>Session、Cookie和Token的主要区别</p>
</li>
<li>
<p>Servlet是线程安全的吗</p>
</li>
<li>
<p>Servlet接口中有哪些方法及Servlet生命周期探秘</p>
</li>
<li>
<p>如果客户端禁止 cookie 能实现 session 还能用吗？</p>
</li>
</ol>
<h3 id="八、并发"> 八、并发</h3>
<h4 id="一-基础知识"> （一）基础知识</h4>
<h5 id="_1-并发编程的优缺点"> （1）并发编程的优缺点</h5>
<ol>
<li>为什么要使用并发编程（并发编程的优点）</li>
<li>并发编程有什么缺点</li>
<li>并发编程三要素是什么？在 Java 程序中怎么保证多线程的运行安全？</li>
<li>并行和并发有什么区别？</li>
<li>什么是多线程，多线程的优劣？</li>
</ol>
<h5 id="_2-线程和进程区别"> （2）线程和进程区别</h5>
<ol>
<li>什么是线程和进程?</li>
<li>进程与线程的区别</li>
<li>什么是上下文切换?</li>
<li>守护线程和用户线程有什么区别呢？</li>
<li>如何在 Windows 和 Linux 上查找哪个线程cpu利用率最高？</li>
<li>什么是线程死锁</li>
<li>形成死锁的四个必要条件是什么</li>
<li>如何避免线程死锁</li>
</ol>
<h5 id="_3-创建线程的四种方式"> （3）创建线程的四种方式</h5>
<ul>
<li>创建线程有哪几种方式？</li>
<li>说一下 runnable 和 callable 有什么区别？</li>
<li>线程的 run()和 start()有什么区别？</li>
<li>为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？</li>
<li>什么是 Callable 和 Future?</li>
<li>什么是 FutureTask？</li>
</ul>
<h5 id="_4-线程的状态和基本操作"> （4）线程的状态和基本操作</h5>
<ol>
<li>说说线程的生命周期及五种基本状态？</li>
<li>Java 中用到的线程调度算法是什么？</li>
<li>线程的调度策略？</li>
<li>什么是线程调度器(Thread Scheduler)和时间分片(Time Slicing )？</li>
<li>请说出与线程同步以及线程调度相关的方法。</li>
<li>sleep() 和 wait() 有什么区别？</li>
<li>你是如何调用 wait() 方法的？使用 if 块还是循环？为什么？</li>
<li>为什么线程通信的方法 wait(), notify()和 notifyAll()被定义在 Object 类里？</li>
<li>为什么 wait(), notify()和 notifyAll()必须在同步方法或者同步块中被调用？</li>
<li>Thread 类中的 yield 方法有什么作用？</li>
<li>为什么 Thread 类的 sleep()和 yield ()方法是静态的？</li>
<li>线程的 sleep()方法和 yield()方法有什么区别？</li>
<li>如何停止一个正在运行的线程？</li>
<li>Java 中 interrupted 和 isInterrupted 方法的区别？</li>
<li>什么是阻塞式方法？</li>
<li>Java 中你怎样唤醒一个阻塞的线程？</li>
<li>notify() 和 notifyAll() 有什么区别？</li>
<li>如何在两个线程间共享数据？</li>
<li>Java 如何实现多线程之间的通讯和协作？</li>
<li>同步方法和同步块，哪个是更好的选择？</li>
<li>什么是线程同步和线程互斥，有哪几种实现方式？</li>
<li>在监视器(Monitor)内部，是如何做线程同步的？程序应该做哪种级别的同步？</li>
<li>如果你提交任务时，线程池队列已满，这时会发生什么</li>
<li>什么叫线程安全？servlet 是线程安全吗?</li>
<li>在 Java 程序中怎么保证多线程的运行安全？</li>
<li>你对线程优先级的理解是什么？</li>
<li>线程类的构造方法、静态块是被哪个线程调用的</li>
<li>Java 中怎么获取一份线程 dump 文件？你如何在 Java 中获取线程堆栈？</li>
<li>一个线程运行时发生异常会怎样？</li>
<li>Java 线程数过多会造成什么异常？</li>
</ol>
<h4 id="二-并发理论"> （二）并发理论</h4>
<h5 id="_1-java内存模型"> （1）Java内存模型</h5>
<ol>
<li>Java中垃圾回收有什么目的？什么时候进行垃圾回收？</li>
<li>如果对象的引用被置为null，垃圾收集器是否会立即释放对象占用的内存？</li>
<li>finalize()方法什么时候被调用？析构函数(finalization)的目的是什么？</li>
</ol>
<h5 id="_2-重排序与数据依赖性"> （2）重排序与数据依赖性</h5>
<ol>
<li>为什么代码会重排序？</li>
</ol>
<h5 id="_3-as-if-serial规则和happens-before规则的区别"> （3）as-if-serial规则和happens-before规则的区别</h5>
<h4 id="三-并发关键字"> （三）并发关键字</h4>
<h5 id="_1-synchronized"> （1）synchronized</h5>
<ol>
<li>synchronized 的作用？</li>
<li>说说自己是怎么使用 synchronized 关键字，在项目中用到了吗</li>
<li>说一下 synchronized 底层实现原理？</li>
<li>什么是自旋</li>
<li>多线程中 synchronized 锁升级的原理是什么？</li>
<li>线程 B 怎么知道线程 A 修改了变量</li>
<li>当一个线程进入一个对象的 synchronized 方法 A 之后，其它线程是否可进入此对象的 synchronized 方法 B？</li>
<li>synchronized、volatile、CAS 比较</li>
<li>synchronized 和 Lock 有什么区别？</li>
<li>synchronized 和 ReentrantLock 区别是什么？</li>
</ol>
<h5 id="_2-volatile"> （2）volatile</h5>
<ol>
<li>volatile 关键字的作用</li>
<li>Java 中能创建 volatile 数组吗？</li>
<li>volatile 变量和 atomic 变量有什么不同？</li>
<li>volatile 能使得一个非原子操作变成原子操作吗？</li>
<li>volatile 修饰符的有过什么实践？</li>
<li>synchronized 和 volatile 的区别是什么？</li>
</ol>
<h5 id="_3-final"> （3）final</h5>
<ol>
<li>什么是不可变对象，它对写并发应用有什么帮助？</li>
</ol>
<h4 id="四-lock体系"> （四）Lock体系</h4>
<h5 id="_1-lock简介与初识aqs"> （1）Lock简介与初识AQS</h5>
<ol>
<li>Java Concurrency API 中的 Lock 接口(Lock interface)是什么？对比同步它有什么优势？</li>
<li>乐观锁和悲观锁的理解及如何实现，有哪些实现方式？</li>
<li>什么是 CAS</li>
<li>CAS 的会产生什么问题？</li>
<li>什么是死锁？</li>
<li>产生死锁的条件是什么？怎么防止死锁？</li>
<li>死锁与活锁的区别，死锁与饥饿的区别？</li>
<li>多线程锁的升级原理是什么？</li>
</ol>
<h5 id="_2-aqs-abstractqueuedsynchronizer-详解与源码分析"> （2）AQS(AbstractQueuedSynchronizer)详解与源码分析</h5>
<ol>
<li>AQS 介绍</li>
<li>AQS 原理分析</li>
</ol>
<h5 id="_3-reentrantlock-重入锁-实现原理与公平锁非公平锁区别"> （3）ReentrantLock(重入锁)实现原理与公平锁非公平锁区别</h5>
<ol>
<li>什么是可重入锁（ReentrantLock）？</li>
</ol>
<h5 id="_4-读写锁reentrantreadwritelock源码分析"> （4）读写锁ReentrantReadWriteLock源码分析</h5>
<ol>
<li>ReadWriteLock 是什么</li>
</ol>
<h5 id="_5-condition源码分析与等待通知机制"> （5）Condition源码分析与等待通知机制</h5>
<h5 id="_6-locksupport详解"> （6）LockSupport详解</h5>
<h4 id="五-并发容器"> （五）并发容器</h4>
<h5 id="_1-并发容器之concurrenthashmap详解-jdk1-8版本-与源码分析"> （1）并发容器之ConcurrentHashMap详解(JDK1.8版本)与源码分析</h5>
<ol>
<li>什么是ConcurrentHashMap？</li>
<li>Java 中 ConcurrentHashMap 的并发度是什么？</li>
<li>什么是并发容器的实现？</li>
<li>Java 中的同步集合与并发集合有什么区别？</li>
<li>SynchronizedMap 和 ConcurrentHashMap 有什么区别？</li>
</ol>
<h5 id="_2-并发容器之copyonwritearraylist详解"> （2）并发容器之CopyOnWriteArrayList详解</h5>
<ol>
<li>CopyOnWriteArrayList 是什么，可以用于什么应用场景？有哪些优缺点？</li>
</ol>
<h5 id="_3-并发容器之threadlocal详解"> （3）并发容器之ThreadLocal详解</h5>
<ol>
<li>ThreadLocal 是什么？有哪些使用场景？</li>
<li>什么是线程局部变量？</li>
</ol>
<h5 id="_4-threadlocal内存泄漏分析与解决方案"> （4）ThreadLocal内存泄漏分析与解决方案</h5>
<ol>
<li>ThreadLocal造成内存泄漏的原因？</li>
<li>ThreadLocal内存泄漏解决方案？</li>
</ol>
<h5 id="_5-并发容器之blockingqueue详解"> （5）并发容器之BlockingQueue详解</h5>
<ol>
<li>什么是阻塞队列？阻塞队列的实现原理是什么？如何使用阻塞队列来实现生产者-消费者模型？</li>
</ol>
<h5 id="_6-并发容器之concurrentlinkedqueue详解与源码分析"> （6）并发容器之ConcurrentLinkedQueue详解与源码分析</h5>
<h5 id="_7-并发容器之arrayblockingqueue与linkedblockingqueue详解"> （7）并发容器之ArrayBlockingQueue与LinkedBlockingQueue详解</h5>
<h4 id="六-线程池"> （六）线程池</h4>
<h5 id="_1-executors类创建四种常见线程池"> （1）Executors类创建四种常见线程池</h5>
<ol>
<li>什么是线程池？有哪几种创建方式？</li>
<li>线程池有什么优点？</li>
<li>线程池都有哪些状态？</li>
<li>什么是 Executor 框架？为什么使用 Executor 框架？</li>
<li>在 Java 中 Executor 和 Executors 的区别？</li>
<li>线程池中 submit() 和 execute() 方法有什么区别？</li>
<li>什么是线程组，为什么在 Java 中不推荐使用？</li>
</ol>
<h5 id="_2-线程池之threadpoolexecutor详解"> （2）线程池之ThreadPoolExecutor详解</h5>
<ol>
<li>Executors和ThreaPoolExecutor创建线程池的区别</li>
<li>你知道怎么创建线程池吗？</li>
<li>ThreadPoolExecutor构造函数重要参数分析</li>
<li>ThreadPoolExecutor饱和策略</li>
<li>一个简单的线程池Demo:<code>Runnable</code>+<code>ThreadPoolExecutor</code></li>
</ol>
<h5 id="_3-线程池之scheduledthreadpoolexecutor详解"> （3）线程池之ScheduledThreadPoolExecutor详解</h5>
<h5 id="_4-futuretask详解"> （4）FutureTask详解</h5>
<h4 id="七-原子操作类"> （七）原子操作类</h4>
<ol>
<li>什么是原子操作？在 Java Concurrency API 中有哪些原子类(atomic classes)？</li>
<li>说一下 atomic 的原理？</li>
</ol>
<h4 id="八-并发工具"> （八）并发工具</h4>
<h5 id="_1-countdownlatch与cyclicbarrier"> （1）CountDownLatch与CyclicBarrier</h5>
<ol>
<li>在 Java 中 CycliBarriar 和 CountdownLatch 有什么区别？</li>
</ol>
<h5 id="_2-semaphore与exchanger"> （2）Semaphore与Exchanger</h5>
<ol>
<li>Semaphore 有什么作用</li>
<li>什么是线程间交换数据的工具Exchanger</li>
<li>常用的并发工具类有哪些？</li>
</ol>
<h3 id="九、jvm"> 九、JVM</h3>
<p>（一）JVM 的主要组成部分及其作用</p>
<h2 id="参考答案"> 参考答案：</h2>
<h3 id="一、集合-容器-2"> 一、集合/容器</h3>
<h4 id="一-概述-2"> （一）概述</h4>
<blockquote>
<p>1、什么是集合</p>
</blockquote>
<p>集合框架：<strong>用于存储数据的容器</strong>。集合框架是为表示和操作集合而规定的一种统一的标准的体系结构。</p>
<p>任何集合框架都包含三大块内容：对外的接口、接口的实现和对集合运算的算法。</p>
<ul>
<li><strong>接口</strong>：表示集合的抽象数据类型。接口允许我们操作集合时不必关注具体实现，从而达到“多态”。在面向对象编程语言中，接口通常用来形成规范。</li>
<li><strong>实现</strong>：集合接口的具体实现，是重用性很高的数据结构。</li>
<li><strong>算法</strong>：在一个实现了某个集合框架中的接口的对象身上完成某种有用的计算的方法，例如查找、排序等。这些算法通常是多态的，因为相同的方法可以在同一个接口被多个类实现时有不同的表现。事实上，算法是可复用的函数。
它减少了程序设计的辛劳。</li>
</ul>
<p><strong>设计集合的目的</strong>：</p>
<ol>
<li>集合框架通过提供有用的数据结构和算法使你能集中注意力于你的程序的重要部分上，而不是为了让程序能正常运转而将注意力于低层设计上。</li>
<li>通过这些在无关API之间的简易的互用性，使你免除了为改编对象或转换代码以便联合这些API而去写大量的代码。 它提高了程序速度和质量。</li>
</ol>
<blockquote>
<p>2、集合的特点</p>
</blockquote>
<p>集合的特点主要有如下两点：</p>
<ul>
<li>
<p>对象封装数据，对象多了也需要存储。集合用于存储对象。</p>
</li>
<li>
<p>对象的个数确定可以使用数组，对象的个数不确定的可以用集合。因为集合是可变长度的。</p>
</li>
</ul>
<blockquote>
<p>3、集合和数组的区别</p>
</blockquote>
<ul>
<li>
<p>数组是固定长度的；集合可变长度的。</p>
</li>
<li>
<p>数组可以存储基本数据类型，也可以存储引用数据类型；集合只能存储引用数据类型。</p>
</li>
<li>
<p>数组存储的元素必须是同一个数据类型；集合存储的对象可以是不同数据类型。</p>
</li>
</ul>
<p><strong>数据结构</strong>：就是容器中存储数据的方式。</p>
<p>对于集合容器，有很多种。因为每一个容器的自身特点不同，其实原理在于每个容器的内部数据结构不同。</p>
<p>集合容器在不断向上抽取过程中，出现了集合体系。在使用一个体系的<strong>原则</strong>： <mark>参阅顶层内容。建立底层对象。</mark></p>
<blockquote>
<p>4、使用集合框架的好处</p>
</blockquote>
<ul>
<li>容量自增长；</li>
<li>提供了高性能的数据结构和算法，使编码更轻松，提高了程序速度和质量；</li>
<li>允许不同 API 之间的互操作，API之间可以来回传递集合；</li>
<li>可以方便地扩展或改写集合，提高代码复用性和可操作性。</li>
<li>通过使用JDK自带的集合类，可以降低代码维护和学习新API成本。</li>
</ul>
<blockquote>
<p>5、常用的集合类有哪些？</p>
</blockquote>
<p><strong>Map接口和Collection接口是所有集合框架的父接口</strong></p>
<p><strong>Collection接口</strong>的子接口包括：<strong>Set</strong>接口和List接口</p>
<ul>
<li>
<p>Set接口的实现类主要有：</p>
<p>1、HashSet</p>
<p>2、TreeSet</p>
<p>3、LinkedHashSet等</p>
</li>
<li>
<p>List接口的实现类主要有：</p>
<p>1、ArrayList</p>
<p>2、LinkedList</p>
<p>3、Stack</p>
<p>4、Vector等</p>
</li>
</ul>
<p><strong>Map接口</strong>的实现类主要有：</p>
<ol>
<li>HashMap</li>
<li>TreeMap</li>
<li>Hashtable</li>
<li>ConcurrentHashMap</li>
<li>Properties</li>
</ol>
<p><img src="./assets/08.jpg" alt=""></p>
<blockquote>
<p>6、List，Set，Map三者的区别？List、Set、Map 是否继承自 Collection 接口？List、Map、Set 三个接口存取元素时，各有什么特点？</p>
</blockquote>
<p>Java 容器分为 Collection 和 Map 两大类，Collection集合的子接口有Set、List、Queue三种子接口。</p>
<p>我们比较常用的是Set、List。Map接口不是collection的子接口。</p>
<p><strong>Collection集合</strong>主要有List和Set两大接口</p>
<ul>
<li>List：一个有序（元素存入集合的顺序和取出的顺序一致）容器，元素可以重复，可以插入多个null元素，元素都有索引。常用的实现类有 ArrayList、LinkedList 和 Vector。</li>
<li>Set：一个无序（存入和取出顺序有可能不一致）容器，不可以存储重复元素，只允许存入一个null元素，必须保证元素唯一性。Set 接口常用实现类是 HashSet、LinkedHashSet 以及 TreeSet。</li>
</ul>
<p><strong>Map集合</strong></p>
<ul>
<li>
<p>Map没有继承于Collection接口，从Map集合中检索元素时，只要给出键对象，就会返回对应的值对象。</p>
</li>
<li>
<p>Map是一个键值对集合，存储键、值和之间的映射。 Key无序，唯一；value 不要求有序，允许重复。</p>
</li>
<li>
<p>Map 的常用实现类：HashMap、TreeMap、HashTable、LinkedHashMap、ConcurrentHashMap</p>
</li>
</ul>
<blockquote>
<p>7、集合框架底层数据结构</p>
</blockquote>
<p><strong>List接口</strong>：</p>
<ul>
<li>Arraylist： Object数组</li>
<li>Vector： Object数组</li>
<li>LinkedList： 双向循环链表</li>
</ul>
<p><strong>Set接口</strong>：</p>
<ul>
<li>HashSet（无序，唯一）：基于 HashMap 实现的，底层采用 HashMap 来保存元素</li>
<li>LinkedHashSet： LinkedHashSet 继承与 HashSet，并且其内部是通过 LinkedHashMap 来实现的。有点类似于我们之前说的LinkedHashMap 其内部是基于 HashMap 实现一样，不过还是有一点点区别的。</li>
<li>TreeSet（有序，唯一）： 红黑树(自平衡的排序二叉树。)</li>
</ul>
<p><strong>Map接口</strong>：</p>
<ul>
<li>
<p>HashMap： JDK1.8之前HashMap由<strong>数组+链表</strong>组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）.JDK1.8以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间</p>
</li>
<li>
<p>LinkedHashMap：LinkedHashMap 继承自 HashMap，所以它的底层仍然是基于<strong>拉链式散列结构</strong>即由数组和链表或红黑树组成。另外，LinkedHashMap 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。</p>
</li>
<li>
<p>HashTable： HashTable除了实现同步外跟HashMap没什么区别，在实际应用中很少用到</p>
</li>
<li>
<p>TreeMap： 红黑树（自平衡的排序二叉树）</p>
</li>
</ul>
<blockquote>
<p>8、Java集合的快速失败机制 “fail-fast”？</p>
</blockquote>
<p>是java集合的一种<strong>错误检测机制</strong>，当多个线程对集合进行结构上的改变的操作时，有可能会产生 fail-fast 机制。</p>
<ul>
<li>例如：假设存在两个线程（线程1、线程2），线程1通过Iterator在遍历集合A中的元素，在某个时候线程2修改了集合A的结构（是结构上面的修改，而不是简单的修改集合元素的内容），那么这个时候程序就会抛出 ConcurrentModificationException 异常，从而产生fail-fast机制。</li>
<li>原因：迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个 <strong>modCount</strong> 变量。集合在被遍历期间如果内容发生变化，就会改变modCount的值。每当迭代器使用hashNext()/next()遍历下一个元素之前，都会检测modCount变量是否为expectedmodCount值，是的话就返回遍历；否则抛出异常，终止遍历。</li>
</ul>
<p><strong>解决办法</strong>：</p>
<ol>
<li>在遍历过程中，所有涉及到改变modCount值得地方全部加上synchronized。</li>
<li>使用CopyOnWriteArrayList来替换ArrayList</li>
</ol>
<blockquote>
<p>9、怎么确保一个集合不能被修改？</p>
</blockquote>
<p>可以使用 Collections. unmodifiableCollection(Collection c) 方法来创建一个只读集合，这样改变集合的任何操作都会抛出 Java. lang. UnsupportedOperationException 异常。</p>
<p>示例代码如下：</p>
<div><pre><code><span>List</span><span><span>&lt;</span><span>String</span><span>></span></span> list <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
list<span>.</span> <span>add</span><span>(</span><span>"x"</span><span>)</span><span>;</span>
<span>Collection</span><span><span>&lt;</span><span>String</span><span>></span></span> clist <span>=</span> <span>Collections</span><span>.</span> <span>unmodifiableCollection</span><span>(</span>list<span>)</span><span>;</span>
clist<span>.</span> <span>add</span><span>(</span><span>"y"</span><span>)</span><span>;</span> <span>// 运行时此行报错</span>
<span>System</span><span>.</span> out<span>.</span> <span>println</span><span>(</span>list<span>.</span> <span>size</span><span>(</span><span>)</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h4 id="二-collection接口-2"> （二）Collection接口</h4>
<h5 id="_1-list接口-2"> （1）List接口</h5>
<blockquote>
<p>1、迭代器 Iterator 是什么？</p>
</blockquote>
<ul>
<li>Iterator 接口提供遍历任何 Collection 接口的方法。</li>
<li>我们可以从一个 Collection 中使用迭代器方法来获取迭代器实例。</li>
<li>迭代器取代了 Java 集合框架中的 Enumeration，迭代器允许调用者在迭代过程中移除元素。</li>
</ul>
<blockquote>
<p>2、Iterator 怎么使用？有什么特点？</p>
</blockquote>
<p>Iterator 使用代码如下：</p>
<div><pre><code><span>List</span><span><span>&lt;</span><span>String</span><span>></span></span> list <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
<span>Iterator</span><span><span>&lt;</span><span>String</span><span>></span></span> it <span>=</span> list<span>.</span> <span>iterator</span><span>(</span><span>)</span><span>;</span>
<span>while</span><span>(</span>it<span>.</span> <span>hasNext</span><span>(</span><span>)</span><span>)</span><span>{</span>
  <span>String</span> obj <span>=</span> it<span>.</span> <span>next</span><span>(</span><span>)</span><span>;</span>
  <span>System</span><span>.</span> out<span>.</span> <span>println</span><span>(</span>obj<span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>Iterator 的特点是只能单向遍历，但是更加安全，因为它可以确保，在当前遍历的集合元素被更改的时候，就会抛出</p>
<p>ConcurrentModificationException 异常。</p>
<blockquote>
<p>3、如何边遍历边移除 Collection 中的元素？</p>
</blockquote>
<p>边遍历边修改 Collection 的唯一正确方式是使用 Iterator.remove() 方法，如下：</p>
<div><pre><code><span>Iterator</span><span><span>&lt;</span><span>Integer</span><span>></span></span> it <span>=</span> list<span>.</span><span>iterator</span><span>(</span><span>)</span><span>;</span>
<span>while</span><span>(</span>it<span>.</span><span>hasNext</span><span>(</span><span>)</span><span>)</span><span>{</span>
   <span>*</span><span>// do something*</span>
   it<span>.</span><span>remove</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>一种最常见的<strong>错误</strong>代码如下：</p>
<div><pre><code><span>for</span><span>(</span><span>Integer</span> i <span>:</span> list<span>)</span><span>{</span>
   list<span>.</span><span>remove</span><span>(</span>i<span>)</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>运行以上错误代码会报 <strong>ConcurrentModificationException 异常</strong>。</p>
<p>这是因为当使用 foreach(for(Integer i : list)) 语句时，会自动生成一个iterator 来遍历该 list，但同时该 list 正在被 Iterator.remove() 修</p>
<p>改。Java 一般不允许一个线程在遍历 Collection 时另一个线程修改它。</p>
<blockquote>
<p>4、Iterator 和 ListIterator 有什么区别？</p>
</blockquote>
<ul>
<li>Iterator 可以遍历 Set 和 List 集合，而 ListIterator 只能遍历 List。</li>
<li>Iterator 只能单向遍历，而 ListIterator 可以双向遍历（向前/后遍历）。</li>
<li>ListIterator 实现 Iterator 接口，然后添加了一些额外的功能，比如添加一个元素、替换一个元素、获取前面或后面元素的索引位置。</li>
</ul>
<blockquote>
<p>5、遍历一个 List 有哪些不同的方式？每种方法的实现原理是什么？Java 中 List 遍历的最佳实践是什么？</p>
</blockquote>
<p>遍历方式有以下几种：</p>
<ol>
<li>for 循环遍历，基于计数器。在集合外部维护一个计数器，然后依次读取每一个位置的元素，当读取到最后一个元素后停止。</li>
<li>迭代器遍历，Iterator。Iterator 是面向对象的一个设计模式，目的是屏蔽不同数据集合的特点，统一遍历集合的接口。Java 在 Collections 中支持了 Iterator 模式。</li>
<li>foreach 循环遍历。foreach 内部也是采用了 Iterator 的方式实现，使用时不需要显式声明 Iterator 或计数器。优点是代码简洁，不易出错；缺点是只能做简单的遍历，不能在遍历过程中操作数据集合，例如删除、替换。</li>
</ol>
<p>最佳实践：Java Collections 框架中提供了一个 RandomAccess 接口，用来标记 List 实现是否支持 Random Access。</p>
<ul>
<li>如果一个数据集合实现了该接口，就意味着它支持 Random Access，按位置读取元素的平均时间复杂度为 O(1)，如ArrayList。</li>
<li>如果没有实现该接口，表示不支持 Random Access，如LinkedList。</li>
</ul>
<p>推荐的做法就是，支持 Random Access 的列表可用 for 循环遍历，否则建议用 Iterator 或 foreach 遍历。</p>
<blockquote>
<p>6、说一下 ArrayList 的优缺点</p>
</blockquote>
<p>ArrayList的优点如下：</p>
<ul>
<li>ArrayList 底层以数组实现，是一种随机访问模式。ArrayList 实现了 RandomAccess 接口，因此查找的时候非常快。</li>
<li>ArrayList 在顺序添加一个元素的时候非常方便。</li>
</ul>
<p>ArrayList 的缺点如下：</p>
<ul>
<li>删除元素的时候，需要做一次元素复制操作。如果要复制的元素很多，那么就会比较耗费性能。</li>
<li>插入元素的时候，也需要做一次元素复制操作，缺点同上。</li>
</ul>
<p>ArrayList 比较适合顺序添加、随机访问的场景。</p>
<blockquote>
<p>7、如何实现数组和 List 之间的转换？</p>
</blockquote>
<ul>
<li>数组转 List：使用 Arrays. asList(array) 进行转换。</li>
<li>List 转数组：使用 List 自带的 toArray() 方法。</li>
</ul>
<p>代码示例：</p>
<div><pre><code><span>// list to array</span>
<span>List</span><span><span>&lt;</span><span>String</span><span>></span></span> list <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>String</span><span>></span></span><span>(</span><span>)</span><span>;</span>
list<span>.</span><span>add</span><span>(</span><span>"123"</span><span>)</span><span>;</span>
list<span>.</span><span>add</span><span>(</span><span>"456"</span><span>)</span><span>;</span>
list<span>.</span><span>toArray</span><span>(</span><span>)</span><span>;</span>

<span>// array to list</span>
<span>String</span><span>[</span><span>]</span> array <span>=</span> <span>new</span> <span>String</span><span>[</span><span>]</span><span>{</span><span>"123"</span><span>,</span><span>"456"</span><span>}</span><span>;</span>
<span>Arrays</span><span>.</span><span>asList</span><span>(</span>array<span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><blockquote>
<p>8、ArrayList 和 LinkedList 的区别是什么？</p>
</blockquote>
<ul>
<li>数据结构实现：ArrayList 是动态数组的数据结构实现，而 LinkedList 是双向链表的数据结构实现。</li>
<li>随机访问效率：ArrayList 比 LinkedList 在随机访问的时候效率要高，因为 LinkedList 是线性的数据存储方式，所以需要移动指针从前往后依次查找。</li>
<li>增加和删除效率：在非首尾的增加和删除操作，LinkedList 要比 ArrayList 效率要高，因为 ArrayList 增删操作要影响数组内的其他数据的下标。</li>
<li>内存空间占用：LinkedList 比 ArrayList 更占内存，因为 LinkedList 的节点除了存储数据，还存储了两个引用，一个指向前一个元素，一个指向后一个元素。</li>
<li>线程安全：ArrayList 和 LinkedList 都是不同步的，也就是不保证线程安全；</li>
</ul>
<p>综合来说，在需要频繁读取集合中的元素时，更推荐使用 ArrayList，而在插入和删除操作较多时，更推荐使用 LinkedList。</p>
<p>补充：数据结构基础之双向链表</p>
<p>双向链表也叫双链表，是链表的一种，它的每个数据结点中都有两个指针，分别指向直接后继和直接前驱。所以，从双向链表中的任意一个结点开始，都可以很方便地访问它的前驱结点和后继结点。</p>
<blockquote>
<p>9、ArrayList 和 Vector 的区别是什么？</p>
</blockquote>
<p>这两个类都实现了 List 接口（List 接口继承了 Collection 接口），他们都是有序集合</p>
<ul>
<li>线程安全：Vector 使用了 Synchronized 来实现线程同步，是线程安全的，而 ArrayList 是非线程安全的。</li>
<li>性能：ArrayList 在性能方面要优于 Vector。</li>
<li>扩容：ArrayList 和 Vector 都会根据实际的需要动态的调整容量，只不过在 Vector 扩容每次会增加 1 倍，而 ArrayList 只会增加 50%。</li>
</ul>
<p>Vector类的所有方法都是同步的。可以由两个线程安全地访问一个Vector对象、但是一个线程访问Vector的话代码要在同步操作上耗费大量的时间。</p>
<p>Arraylist不是同步的，所以在不需要保证线程安全时时建议使用Arraylist。</p>
<blockquote>
<p>10、插入数据时，ArrayList、LinkedList、Vector谁速度较快？阐述 ArrayList、Vector、LinkedList 的存储性能和特性？</p>
</blockquote>
<ul>
<li>ArrayList、Vector 底层的实现都是使用数组方式存储数据。数组元素数大于实际存储的数据以便增加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入数据慢。</li>
<li>Vector 中的方法由于加了 synchronized 修饰，因此 <strong>Vector</strong> <strong>是线程安全容器，但性能上较ArrayList差</strong>。</li>
<li>LinkedList 使用双向链表实现存储，按序号索引数据需要进行前向或后向遍历，但插入数据时只需要记录当前项的前后项即可，所以 <strong>LinkedList</strong> <strong>插入速度较快</strong>。</li>
</ul>
<blockquote>
<p>11、多线程场景下如何使用 ArrayList？</p>
</blockquote>
<p>ArrayList 不是线程安全的，如果遇到多线程场景，可以通过 Collections 的 synchronizedList 方法将其转换成线程安全的容器后再使</p>
<p>用。例如像下面这样：</p>
<div><pre><code><span>List</span><span><span>&lt;</span><span>String</span><span>></span></span> synchronizedList <span>=</span> <span>Collections</span><span>.</span><span>synchronizedList</span><span>(</span>list<span>)</span><span>;</span>
synchronizedList<span>.</span><span>add</span><span>(</span><span>"aaa"</span><span>)</span><span>;</span>
synchronizedList<span>.</span><span>add</span><span>(</span><span>"bbb"</span><span>)</span><span>;</span>

<span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> synchronizedList<span>.</span><span>size</span><span>(</span><span>)</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>synchronizedList<span>.</span><span>get</span><span>(</span>i<span>)</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><blockquote>
<p>12、为什么 ArrayList 的 elementData 加上 transient 修饰？</p>
</blockquote>
<p>ArrayList 中的数组定义如下：</p>
<div><pre><code><span>private</span> <span>transient</span> <span>Object</span><span>[</span><span>]</span> elementData<span>;</span>

</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>再看一下 ArrayList 的定义：</p>
<div><pre><code><span>public</span> <span>class</span> <span>ArrayList</span><span><span>&lt;</span><span>E</span><span>></span></span> <span>extends</span> <span>AbstractList</span><span><span>&lt;</span><span>E</span><span>></span></span>
     <span>implements</span> <span>List</span><span><span>&lt;</span><span>E</span><span>></span></span><span>,</span> <span>RandomAccess</span><span>,</span> <span>Cloneable</span><span>,</span> <span><span>java<span>.</span>io<span>.</span></span>Serializable</span>
    
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>可以看到 ArrayList 实现了 Serializable 接口，这意味着 ArrayList 支持序列化。transient 的作用是说不希望 elementData 数组被序列化，重写了 writeObject 实现：</p>
<div><pre><code><span>private</span> <span>void</span> <span>writeObject</span><span>(</span><span><span>java<span>.</span>io<span>.</span></span>ObjectOutputStream</span> s<span>)</span> <span>throws</span> <span><span>java<span>.</span>io<span>.</span></span>IOException</span><span>{</span>
    <span>*</span><span>// Write out element count, and any hidden stuff*</span>
        <span>int</span> expectedModCount <span>=</span> modCount<span>;</span>
    s<span>.</span><span>defaultWriteObject</span><span>(</span><span>)</span><span>;</span>
    <span>*</span><span>// Write out array length*</span>
        s<span>.</span><span>writeInt</span><span>(</span>elementData<span>.</span>length<span>)</span><span>;</span>
    <span>*</span><span>// Write out all elements in the proper order.*</span>
        <span>for</span> <span>(</span><span>int</span> i<span>=</span><span>0</span><span>;</span> i<span>&lt;</span>size<span>;</span> i<span>++</span><span>)</span>
            s<span>.</span><span>writeObject</span><span>(</span>elementData<span>[</span>i<span>]</span><span>)</span><span>;</span>
    <span>if</span> <span>(</span>modCount <span>!=</span> expectedModCount<span>)</span> <span>{</span>
        <span>throw</span> <span>new</span> <span>ConcurrentModificationException</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>每次序列化时，先调用 defaultWriteObject() 方法序列化 ArrayList 中的非 transient 元素，然后遍历 elementData，只序列化已存入的元素，这样既加快了序列化的速度，又减小了序列化之后的文件大小。</p>
<blockquote>
<p>13、List 和 Set 的区别</p>
</blockquote>
<ul>
<li>List , Set 都是继承自Collection 接口</li>
<li>List 特点：一个有序（元素存入集合的顺序和取出的顺序一致）容器，元素可以重复，可以插入多个null元素，元素都有索引。常用的实现类有 ArrayList、LinkedList 和 Vector。</li>
<li>Set 特点：一个无序（存入和取出顺序有可能不一致）容器，不可以存储重复元素，只允许存入一个null元素，必须保证元素唯一性。Set 接口常用实现类是 HashSet、LinkedHashSet 以及 TreeSet。</li>
<li>另外 List 支持for循环，也就是通过下标来遍历，也可以用迭代器，但是set只能用迭代，因为他无序，无法用下标来取得想要的值。</li>
<li>Set：检索元素效率低下，删除和插入效率高，插入和删除不会引起元素位置改变。List：和数组类似，List可以动态增长，查找元素效率高，插入删除元素效率低，因为会引起其他元素位置改变</li>
</ul>
<h5 id="_2-set接口-2"> （2）Set接口</h5>
<blockquote>
<p>1、说一下 HashSet 的实现原理？</p>
</blockquote>
<p>HashSet 是基于 HashMap 实现的，HashSet的值存放于HashMap的key上，HashMap的value统一为PRESENT，因此 HashSet 的实</p>
<p>现比较简单，相关 HashSet 的操作，基本上都是直接调用底层 HashMap 的相关方法来完成，HashSet 不允许重复的值。</p>
<blockquote>
<p>2、HashSet如何检查重复？HashSet是如何保证数据不可重复的？</p>
</blockquote>
<ul>
<li>向HashSet 中add ()元素时，判断元素是否存在的依据，不仅要比较hash值，同时还要结合equles 方法比较。HashSet 中的add ()方法会使用HashMap 的put()方法。</li>
<li>HashMap 的 key 是唯一的，由源码可以看出 HashSet 添加进去的值就是作为HashMap 的key，并且在HashMap中如果K/V相同时，会用新的V覆盖掉旧的V，然后返回旧的V。所以不会重复（ HashMap 比较key是否相等是先比较hashcode 再比较equals ）。</li>
</ul>
<p>以下是HashSet 部分源码：</p>
<div><pre><code><span>private</span> <span>static</span> <span>final</span> <span>Object</span> PRESENT <span>=</span> <span>new</span> <span>Object</span><span>(</span><span>)</span><span>;</span>
<span>private</span> <span>transient</span> <span>HashMap</span><span><span>&lt;</span><span>E</span><span>,</span><span>Object</span><span>></span></span> map<span>;</span>

<span>public</span> <span>HashSet</span><span>(</span><span>)</span> <span>{</span>
    map <span>=</span> <span>new</span> <span>HashMap</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
<span>}</span>

<span>public</span> <span>boolean</span> <span>add</span><span>(</span><span>E</span> e<span>)</span> <span>{</span>
    <span>// 调用HashMap的put方法,PRESENT是一个至始至终都相同的虚值</span>
	<span>return</span> map<span>.</span><span>put</span><span>(</span>e<span>,</span> PRESENT<span>)</span><span>==</span><span>null</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p><strong>hashCode（）与equals（）的相关规定</strong>：</p>
<ol>
<li>如果两个对象相等，则hashcode一定也是相同的</li>
<li>两个对象相等,对两个equals方法返回true</li>
<li>两个对象有相同的hashcode值，它们也不一定是相等的</li>
<li>综上，equals方法被覆盖过，则hashCode方法也必须被覆盖</li>
<li>hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写hashCode()，则该class的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）。</li>
</ol>
<p><strong>==与equals的区别</strong></p>
<ol>
<li>==是判断两个变量或实例是不是指向同一个内存空间 equals是判断两个变量或实例所指向的内存空间的值是不是相同</li>
<li>==是指对内存地址进行比较 equals()是对字符串的内容进行比较</li>
<li>==指引用是否相同 equals()指的是值是否相同</li>
</ol>
<blockquote>
<p>3、HashSet与HashMap的区别</p>
</blockquote>
<table>
<thead>
<tr>
<th>HashMap</th>
<th>HashSet</th>
</tr>
</thead>
<tbody>
<tr>
<td>实现了Map接口</td>
<td>实现Set接口</td>
</tr>
<tr>
<td>存储键值对</td>
<td>仅存储对象</td>
</tr>
<tr>
<td>调用put（）向map中添加元素</td>
<td>调用add（）方法向Set中添加元素</td>
</tr>
<tr>
<td>HashMap使用键（Key）计算Hashcode</td>
<td>HashSet使用成员对象来计算hashcode值，对于两个对象来说hashcode可能相同，所以equals()方法用来判断对象的相等性，如果两个对象不同的话，那么返回false</td>
</tr>
<tr>
<td>HashMap相对于HashSet较快，因为它是使用唯一的键获取对象</td>
<td>HashSet较HashMap来说比较慢</td>
</tr>
</tbody>
</table>
<h5 id="_3-queue"> （3）Queue</h5>
<blockquote>
<p>1、BlockingQueue是什么？</p>
</blockquote>
<p>Java.util.concurrent.BlockingQueue是一个队列，在进行检索或移除一个元素的时候，它会等待队列变为非空；当在添加一个元素时，它会等待队列中的可用空间。</p>
<p>BlockingQueue接口是Java集合框架的一部分，主要用于<strong>实现生产者-消费者模式</strong>。我们不需要担心等待生产者有可用的空间，或消费者有可用的对象，因为它都在BlockingQueue的实现类中被处理了。Java提供了几种BlockingQueue的实现，比如ArrayBlockingQueue、LinkedBlockingQueue、PriorityBlockingQueue,、SynchronousQueue等。</p>
<blockquote>
<p>2、在 Queue 中 poll()和 remove()有什么区别？</p>
</blockquote>
<ul>
<li>相同点：都是返回第一个元素，并在队列中删除返回的对象。</li>
<li>不同点：如果没有元素 poll()会返回 null，而 remove()会直接抛出 NoSuchElementException 异常。</li>
</ul>
<p>代码示例：</p>
<div><pre><code><span>Queue</span><span><span>&lt;</span><span>String</span><span>></span></span> queue <span>=</span> <span>new</span> <span>LinkedList</span><span><span>&lt;</span><span>String</span><span>></span></span><span>(</span><span>)</span><span>;</span>
queue<span>.</span> <span>offer</span><span>(</span><span>"string"</span><span>)</span><span>;</span> <span>// add</span>
<span>System</span><span>.</span> out<span>.</span> <span>println</span><span>(</span>queue<span>.</span> <span>poll</span><span>(</span><span>)</span><span>)</span><span>;</span>
<span>System</span><span>.</span> out<span>.</span> <span>println</span><span>(</span>queue<span>.</span> <span>remove</span><span>(</span><span>)</span><span>)</span><span>;</span>
<span>System</span><span>.</span> out<span>.</span> <span>println</span><span>(</span>queue<span>.</span> <span>size</span><span>(</span><span>)</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h4 id="三-map接口-2"> （三）Map接口</h4>
<blockquote>
<p>1、说一下 HashMap 的实现原理？</p>
</blockquote>
<p>HashMap概述： HashMap是基于哈希表的Map接口的非同步实现。此实现提供所有可选的映射操作，并允许使用null值和null键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。</p>
<p>HashMap的数据结构： 在Java编程语言中，最基本的结构就是两种，一个是数组，另外一个是模拟指针（引用），所有的数据结构都可以用这两个基本结构来构造的，HashMap也不例外。HashMap实际上是一个“链表散列”的数据结构，即数组和链表的结合体。</p>
<p>HashMap 基于 Hash 算法实现的</p>
<ol>
<li>
<p>当我们往HashMap中put元素时，利用key的hashCode重新hash，计算出当前对象的元素在数组中的下标</p>
</li>
<li>
<p>存储时，如果出现hash值相同的key，此时有两种情况。</p>
<p>(1)如果key相同，则覆盖原始值；</p>
<p>(2)如果key不同（出现冲突），则将当前的key-value放入链表中</p>
</li>
<li>
<p>获取时，直接找到hash值对应的下标，在进一步判断key是否相同，从而找到对应值。</p>
</li>
<li>
<p>理解了以上过程就不难明白HashMap是如何解决hash冲突的问题，核心就是使用了数组的存储方式，然后将冲突的key的对象放入链表中，一旦发现冲突就在链表中做进一步的对比。</p>
</li>
</ol>
<p>需要注意<strong>Jdk 1.8中对HashMap的实现做了优化</strong>： <mark>当链表中的节点数据超过八个之后，该链表会转为红黑树来提高查询效率，从原来的O(n)到O(logn)</mark></p>
<blockquote>
<p>2、HashMap在JDK1.7和JDK1.8中有哪些不同？HashMap的底层实现</p>
</blockquote>
<p>在Java中，保存数据有两种比较简单的数据结构：数组和链表。数组的特点是：寻址容易，插入和删除困难；链表的特点是：寻址困难，但插入和删除容易；所以我们将数组和链表结合在一起，发挥两者各自的优势，使用一种叫做<strong>拉链法</strong>的方式可以解决哈希冲突。</p>
<p><strong>（1）JDK1.8之前</strong></p>
<p>JDK1.8之前采用的是拉链法。<strong>拉链法</strong>：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。</p>
<p><img src="./assets/09.png" alt="jdk1.7中HashMap数据结构"></p>
<p><strong>（2）JDK1.8之后</strong></p>
<p>相比于之前的版本，jdk1.8在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。</p>
<p><img src="./assets/10.png" alt="jdk1.8中HashMap数据结构"></p>
<p><strong>（3）JDK1.7 VS JDK1.8</strong></p>
<p>JDK1.8主要解决或优化了一下问题：</p>
<ol>
<li>resize 扩容优化</li>
<li>引入了红黑树，目的是避免单条链表过长而影响查询效率，<a href="">红黑树算法</a></li>
<li>解决了多线程死循环问题，但仍是非线程安全的，多线程时可能会造成数据丢失问题。</li>
</ol>
<table>
<thead>
<tr>
<th>不同</th>
<th>JDK 1.7</th>
<th>JDK 1.8</th>
</tr>
</thead>
<tbody>
<tr>
<td>存储结构</td>
<td>数组 + 链表</td>
<td>数组 + 链表 + 红黑树</td>
</tr>
<tr>
<td>初始化方式</td>
<td>单独函数：<code>inflateTable()</code></td>
<td>直接集成到了扩容函数<code>resize()</code>中</td>
</tr>
<tr>
<td>hash值计算方式</td>
<td>扰动处理 = 9次扰动 = 4次位运算 + 5次异或运算</td>
<td>扰动处理 = 2次扰动 = 1次位运算 + 1次异或运算</td>
</tr>
<tr>
<td>存放数据的规则</td>
<td>无冲突时，存放数组；冲突时，存放链表</td>
<td>无冲突时，存放数组；冲突 &amp; 链表长度 &lt; 8：存放单链表；冲突 &amp; 链表长度 &gt; 8：树化并存放红黑树</td>
</tr>
<tr>
<td>插入数据方式</td>
<td>头插法（先讲原位置的数据移到后1位，再插入数据到该位置）</td>
<td>尾插法（直接插入到链表尾部/红黑树）</td>
</tr>
<tr>
<td>扩容后存储位置的计算方式</td>
<td>全部按照原来方法进行计算（即hashCode -&gt;&gt; 扰动函数 -&gt;&gt; (h&amp;length-1)）</td>
<td>按照扩容后的规律计算（即扩容后的位置=原位置 or 原位置 + 旧容量）</td>
</tr>
</tbody>
</table>
<blockquote>
<p>3、HashMap的put方法的具体流程？</p>
</blockquote>
<p>当我们put的时候，首先计算 <code>key</code>的<code>hash</code>值，这里调用了 <code>hash</code>方法，<code>hash</code>方法实际是让<code>key.hashCode()</code>与<code>key.hashCode()&gt;&gt;&gt;16</code>进行异或操作，高16bit补0，一个数和0异或不变，所以 hash 函数大概的作用就是：<strong>高16bit不变，低16bit和高16bit做了一个异或，目的是减少碰撞</strong>。按照函数注释，因为bucket数组大小是2的幂，计算下标<code>index = (table.length - 1) &amp; hash</code>，如果不做 hash 处理，相当于散列生效的只有几个低 bit 位，为了减少散列的碰撞，设计者综合考虑了速度、作用、质量之后，使用高16bit和低16bit异或来简单处理减少碰撞，而且JDK8中用了复杂度 O（logn）的树结构来提升碰撞下的性能。</p>
<p>putVal方法执行流程图</p>
<p><img src="./assets/11.png" alt="putVal方法执行流程图"></p>
<div><pre><code><span>public</span> <span>V</span> <span>put</span><span>(</span><span>K</span> key<span>,</span> <span>V</span> value<span>)</span> <span>{</span>
    <span>return</span> <span>putVal</span><span>(</span><span>hash</span><span>(</span>key<span>)</span><span>,</span> key<span>,</span> value<span>,</span> <span>false</span><span>,</span> <span>true</span><span>)</span><span>;</span>
<span>}</span>

<span>static</span> <span>final</span> <span>int</span> <span>hash</span><span>(</span><span>Object</span> key<span>)</span> <span>{</span>
    <span>int</span> h<span>;</span>
    <span>return</span> <span>(</span>key <span>==</span> <span>null</span><span>)</span> <span>?</span> <span>0</span> <span>:</span> <span>(</span>h <span>=</span> key<span>.</span><span>hashCode</span><span>(</span><span>)</span><span>)</span> <span>^</span> <span>(</span>h <span>>>></span> <span>16</span><span>)</span><span>;</span>
<span>}</span>

<span>//实现Map.put和相关方法</span>
<span>final</span> <span>V</span> <span>putVal</span><span>(</span><span>int</span> hash<span>,</span> <span>K</span> key<span>,</span> <span>V</span> value<span>,</span> <span>boolean</span> onlyIfAbsent<span>,</span>
                   <span>boolean</span> evict<span>)</span> <span>{</span>
    <span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span><span>[</span><span>]</span> tab<span>;</span> <span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> p<span>;</span> <span>int</span> n<span>,</span> i<span>;</span>
    <span>// 步骤①：tab为空则创建 </span>
    <span>// table未初始化或者长度为0，进行扩容</span>
    <span>if</span> <span>(</span><span>(</span>tab <span>=</span> table<span>)</span> <span>==</span> <span>null</span> <span>||</span> <span>(</span>n <span>=</span> tab<span>.</span>length<span>)</span> <span>==</span> <span>0</span><span>)</span>
        n <span>=</span> <span>(</span>tab <span>=</span> <span>resize</span><span>(</span><span>)</span><span>)</span><span>.</span>length<span>;</span>
    <span>// 步骤②：计算index，并对null做处理  </span>
    <span>// (n - 1) &amp; hash 确定元素存放在哪个桶中(相当于取余)，桶为空，新生成结点放入桶中(此时，这个结点是放在数组中)</span>
    <span>if</span> <span>(</span><span>(</span>p <span>=</span> tab<span>[</span>i <span>=</span> <span>(</span>n <span>-</span> <span>1</span><span>)</span> <span>&amp;</span> hash<span>]</span><span>)</span> <span>==</span> <span>null</span><span>)</span>
        tab<span>[</span>i<span>]</span> <span>=</span> <span>newNode</span><span>(</span>hash<span>,</span> key<span>,</span> value<span>,</span> <span>null</span><span>)</span><span>;</span>
    <span>// 桶中已经存在元素</span>
    <span>else</span> <span>{</span>
        <span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> e<span>;</span> <span>K</span> k<span>;</span>
        <span>// 步骤③：节点key存在，直接覆盖value </span>
        <span>// 比较桶中第一个元素(数组中的结点)的hash值相等，key相等</span>
        <span>if</span> <span>(</span>p<span>.</span>hash <span>==</span> hash <span>&amp;&amp;</span>
            <span>(</span><span>(</span>k <span>=</span> p<span>.</span>key<span>)</span> <span>==</span> key <span>||</span> <span>(</span>key <span>!=</span> <span>null</span> <span>&amp;&amp;</span> key<span>.</span><span>equals</span><span>(</span>k<span>)</span><span>)</span><span>)</span><span>)</span>
                <span>// 将第一个元素赋值给e，用e来记录</span>
                e <span>=</span> p<span>;</span>
        <span>// 步骤④：判断该链为红黑树 </span>
        <span>// hash值不相等，即key不相等；为红黑树结点</span>
        <span>// 如果当前元素类型为TreeNode，表示为红黑树，putTreeVal返回待存放的node, e可能为null</span>
        <span>else</span> <span>if</span> <span>(</span>p <span>instanceof</span> <span>TreeNode</span><span>)</span>
            <span>// 放入树中</span>
            e <span>=</span> <span>(</span><span>(</span><span>TreeNode</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span><span>)</span>p<span>)</span><span>.</span><span>putTreeVal</span><span>(</span><span>this</span><span>,</span> tab<span>,</span> hash<span>,</span> key<span>,</span> value<span>)</span><span>;</span>
        <span>// 步骤⑤：该链为链表 </span>
        <span>// 为链表结点</span>
        <span>else</span> <span>{</span>
            <span>// 在链表最末插入结点</span>
            <span>for</span> <span>(</span><span>int</span> binCount <span>=</span> <span>0</span><span>;</span> <span>;</span> <span>++</span>binCount<span>)</span> <span>{</span>
                <span>// 到达链表的尾部</span>
                
                <span>//判断该链表尾部指针是不是空的</span>
                <span>if</span> <span>(</span><span>(</span>e <span>=</span> p<span>.</span>next<span>)</span> <span>==</span> <span>null</span><span>)</span> <span>{</span>
                    <span>// 在尾部插入新结点</span>
                    p<span>.</span>next <span>=</span> <span>newNode</span><span>(</span>hash<span>,</span> key<span>,</span> value<span>,</span> <span>null</span><span>)</span><span>;</span>
                    <span>//判断链表的长度是否达到转化红黑树的临界值，临界值为8</span>
                    <span>if</span> <span>(</span>binCount <span>>=</span> TREEIFY_THRESHOLD <span>-</span> <span>1</span><span>)</span> <span>// -1 for 1st</span>
                        <span>//链表结构转树形结构</span>
                        <span>treeifyBin</span><span>(</span>tab<span>,</span> hash<span>)</span><span>;</span>
                    <span>// 跳出循环</span>
                    <span>break</span><span>;</span>
                <span>}</span>
                <span>// 判断链表中结点的key值与插入的元素的key值是否相等</span>
                <span>if</span> <span>(</span>e<span>.</span>hash <span>==</span> hash <span>&amp;&amp;</span>
                    <span>(</span><span>(</span>k <span>=</span> e<span>.</span>key<span>)</span> <span>==</span> key <span>||</span> <span>(</span>key <span>!=</span> <span>null</span> <span>&amp;&amp;</span> key<span>.</span><span>equals</span><span>(</span>k<span>)</span><span>)</span><span>)</span><span>)</span>
                    <span>// 相等，跳出循环</span>
                    <span>break</span><span>;</span>
                <span>// 用于遍历桶中的链表，与前面的e = p.next组合，可以遍历链表</span>
                p <span>=</span> e<span>;</span>
            <span>}</span>
        <span>}</span>
        <span>//判断当前的key已经存在的情况下，再来一个相同的hash值、key值时，返回新来的value这个值</span>
        <span>if</span> <span>(</span>e <span>!=</span> <span>null</span><span>)</span> <span>{</span> 
            <span>// 记录e的value</span>
            <span>V</span> oldValue <span>=</span> e<span>.</span>value<span>;</span>
            <span>// onlyIfAbsent为false或者旧值为null</span>
            <span>if</span> <span>(</span><span>!</span>onlyIfAbsent <span>||</span> oldValue <span>==</span> <span>null</span><span>)</span>
                <span>//用新值替换旧值</span>
                e<span>.</span>value <span>=</span> value<span>;</span>
            <span>// 访问后回调</span>
            <span>afterNodeAccess</span><span>(</span>e<span>)</span><span>;</span>
            <span>// 返回旧值</span>
            <span>return</span> oldValue<span>;</span>
        <span>}</span>
    <span>}</span>
    <span>// 结构性修改</span>
    <span>++</span>modCount<span>;</span>
    <span>// 步骤⑥：超过最大容量就扩容 </span>
    <span>// 实际大小大于阈值则扩容</span>
    <span>if</span> <span>(</span><span>++</span>size <span>></span> threshold<span>)</span>
        <span>resize</span><span>(</span><span>)</span><span>;</span>
    <span>// 插入后回调</span>
    <span>afterNodeInsertion</span><span>(</span>evict<span>)</span><span>;</span>
    <span>return</span> <span>null</span><span>;</span>
<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br></div></div><p>①.判断键值对数组table[i]是否为空或为null，否则执行resize()进行扩容；</p>
<p>②.根据键值key计算hash值得到插入的数组索引i，如果table[i]==null，直接新建节点添加，转向⑥，如果table[i]不为空，转向③；</p>
<p>③.判断table[i]的首个元素是否和key一样，如果相同直接覆盖value，否则转向④，这里的相同指的是hashCode以及equals；</p>
<p>④.判断table[i] 是否为treeNode，即table[i] 是否是红黑树，如果是红黑树，则直接在树中插入键值对，否则转向⑤；</p>
<p>⑤.遍历table[i]，判断链表长度是否大于8，大于8的话把链表转换为红黑树，在红黑树中执行插入操作，否则进行链表的插入操作；遍历过程中若发现key已经存在直接覆盖value即可；</p>
<p>⑥.插入成功后，判断实际存在的键值对数量size是否超多了最大容量threshold，如果超过，进行扩容。</p>
<blockquote>
<p>4、HashMap的扩容操作是怎么实现的？</p>
</blockquote>
<p>①.在jdk1.8中，resize()方法是在hashmap中的键值对大于阀值时或者初始化时，就调用resize()方法进行扩容；</p>
<p>②.每次扩展的时候，都是扩展2倍；</p>
<p>③.扩展后Node对象的位置要么在原位置，要么移动到原偏移量两倍的位置。</p>
<p>在putVal()中，我们看到在这个函数里面使用到了2次resize()方法，resize()方法表示的在进行第一次<strong>初始化时</strong>会对其进行扩容，或者当该<strong>数组的实际大小大于其临界值值(第一次为12),</strong></p>
<p>这个时候在扩容的同时也会伴随的桶上面的元素进行重新分发，这也是JDK1.8版本的一个优化的地方，</p>
<ul>
<li>在1.7中，扩容之后需要重新去计算其Hash值，根据Hash值对其进行分发</li>
<li>但在1.8版本中，则是根据在同一个桶的位置中进行判断(e.hash &amp; oldCap)是否为0，重新进行hash分配后，该元素的位置要么停留在原始位置，要么移动到原始位置+增加的数组大小这个位置上</li>
</ul>
<div><pre><code><span>final</span> <span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span><span>[</span><span>]</span> <span>resize</span><span>(</span><span>)</span> <span>{</span>
    <span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span><span>[</span><span>]</span> oldTab <span>=</span> table<span>;</span><span>//oldTab指向hash桶数组</span>
    <span>int</span> oldCap <span>=</span> <span>(</span>oldTab <span>==</span> <span>null</span><span>)</span> <span>?</span> <span>0</span> <span>:</span> oldTab<span>.</span>length<span>;</span>
    <span>int</span> oldThr <span>=</span> threshold<span>;</span>
    <span>int</span> newCap<span>,</span> newThr <span>=</span> <span>0</span><span>;</span>
    <span>if</span> <span>(</span>oldCap <span>></span> <span>0</span><span>)</span> <span>{</span><span>//如果oldCap不为空的话，就是hash桶数组不为空</span>
        <span>if</span> <span>(</span>oldCap <span>>=</span> MAXIMUM_CAPACITY<span>)</span> <span>{</span><span>//如果大于最大容量了，就赋值为整数最大的阀值</span>
            threshold <span>=</span> <span>Integer</span><span>.</span>MAX_VALUE<span>;</span>
            <span>return</span> oldTab<span>;</span><span>//返回</span>
        <span>}</span><span>//如果当前hash桶数组的长度在扩容后仍然小于最大容量 并且oldCap大于默认值16</span>
        <span>else</span> <span>if</span> <span>(</span><span>(</span>newCap <span>=</span> oldCap <span>&lt;&lt;</span> <span>1</span><span>)</span> <span><span>&lt;</span> MAXIMUM_CAPACITY <span>&amp;</span><span>&amp;</span>
                 oldCap <span>></span></span><span>=</span> DEFAULT_INITIAL_CAPACITY<span>)</span>
            newThr <span>=</span> oldThr <span>&lt;&lt;</span> <span>1</span><span>;</span> <span>// double threshold 双倍扩容阀值threshold</span>
    <span>}</span>
    <span>// 旧的容量为0，但threshold大于零，代表有参构造有cap传入，threshold已经被初始化成最小2的n次幂</span>
    <span>// 直接将该值赋给新的容量</span>
    <span>else</span> <span>if</span> <span>(</span>oldThr <span>></span> <span>0</span><span>)</span> <span>// initial capacity was placed in threshold</span>
        newCap <span>=</span> oldThr<span>;</span>
    <span>// 无参构造创建的map，给出默认容量和threshold 16, 16*0.75</span>
    <span>else</span> <span>{</span>               <span>// zero initial threshold signifies using defaults</span>
        newCap <span>=</span> DEFAULT_INITIAL_CAPACITY<span>;</span>
        newThr <span>=</span> <span>(</span><span>int</span><span>)</span><span>(</span>DEFAULT_LOAD_FACTOR <span>*</span> DEFAULT_INITIAL_CAPACITY<span>)</span><span>;</span>
    <span>}</span>
    <span>// 新的threshold = 新的cap * 0.75</span>
    <span>if</span> <span>(</span>newThr <span>==</span> <span>0</span><span>)</span> <span>{</span>
        <span>float</span> ft <span>=</span> <span>(</span><span>float</span><span>)</span>newCap <span>*</span> loadFactor<span>;</span>
        newThr <span>=</span> <span>(</span>newCap <span>&lt;</span> MAXIMUM_CAPACITY <span>&amp;&amp;</span> ft <span>&lt;</span> <span>(</span><span>float</span><span>)</span>MAXIMUM_CAPACITY <span>?</span>
                  <span>(</span><span>int</span><span>)</span>ft <span>:</span> <span>Integer</span><span>.</span>MAX_VALUE<span>)</span><span>;</span>
    <span>}</span>
    threshold <span>=</span> newThr<span>;</span>
    <span>// 计算出新的数组长度后赋给当前成员变量table</span>
    <span>@SuppressWarnings</span><span>(</span><span>{</span><span>"rawtypes"</span><span>,</span><span>"unchecked"</span><span>}</span><span>)</span>
        <span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span><span>[</span><span>]</span> newTab <span>=</span> <span>(</span><span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span><span>[</span><span>]</span><span>)</span><span>new</span> <span>Node</span><span>[</span>newCap<span>]</span><span>;</span><span>//新建hash桶数组</span>
    table <span>=</span> newTab<span>;</span><span>//将新数组的值复制给旧的hash桶数组</span>
    <span>// 如果原先的数组没有初始化，那么resize的初始化工作到此结束，否则进入扩容元素重排逻辑，使其均匀的分散</span>
    <span>if</span> <span>(</span>oldTab <span>!=</span> <span>null</span><span>)</span> <span>{</span>
        <span>// 遍历新数组的所有桶下标</span>
        <span>for</span> <span>(</span><span>int</span> j <span>=</span> <span>0</span><span>;</span> j <span>&lt;</span> oldCap<span>;</span> <span>++</span>j<span>)</span> <span>{</span>
            <span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> e<span>;</span>
            <span>if</span> <span>(</span><span>(</span>e <span>=</span> oldTab<span>[</span>j<span>]</span><span>)</span> <span>!=</span> <span>null</span><span>)</span> <span>{</span>
                <span>// 旧数组的桶下标赋给临时变量e，并且解除旧数组中的引用，否则就数组无法被GC回收</span>
                oldTab<span>[</span>j<span>]</span> <span>=</span> <span>null</span><span>;</span>
                <span>// 如果e.next==null，代表桶中就一个元素，不存在链表或者红黑树</span>
                <span>if</span> <span>(</span>e<span>.</span>next <span>==</span> <span>null</span><span>)</span>
                    <span>// 用同样的hash映射算法把该元素加入新的数组</span>
                    newTab<span>[</span>e<span>.</span>hash <span>&amp;</span> <span>(</span>newCap <span>-</span> <span>1</span><span>)</span><span>]</span> <span>=</span> e<span>;</span>
                <span>// 如果e是TreeNode并且e.next!=null，那么处理树中元素的重排</span>
                <span>else</span> <span>if</span> <span>(</span>e <span>instanceof</span> <span>TreeNode</span><span>)</span>
                    <span>(</span><span>(</span><span>TreeNode</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span><span>)</span>e<span>)</span><span>.</span><span>split</span><span>(</span><span>this</span><span>,</span> newTab<span>,</span> j<span>,</span> oldCap<span>)</span><span>;</span>
                <span>// e是链表的头并且e.next!=null，那么处理链表中元素重排</span>
                <span>else</span> <span>{</span> <span>// preserve order</span>
                    <span>// loHead,loTail 代表扩容后不用变换下标，见注1</span>
                    <span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> loHead <span>=</span> <span>null</span><span>,</span> loTail <span>=</span> <span>null</span><span>;</span>
                    <span>// hiHead,hiTail 代表扩容后变换下标，见注1</span>
                    <span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> hiHead <span>=</span> <span>null</span><span>,</span> hiTail <span>=</span> <span>null</span><span>;</span>
                    <span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> next<span>;</span>
                    <span>// 遍历链表</span>
                    <span>do</span> <span>{</span>             
                        next <span>=</span> e<span>.</span>next<span>;</span>
                        <span>if</span> <span>(</span><span>(</span>e<span>.</span>hash <span>&amp;</span> oldCap<span>)</span> <span>==</span> <span>0</span><span>)</span> <span>{</span>
                            <span>if</span> <span>(</span>loTail <span>==</span> <span>null</span><span>)</span>
                                <span>// 初始化head指向链表当前元素e，e不一定是链表的第一个元素，初始化后loHead</span>
                                <span>// 代表下标保持不变的链表的头元素</span>
                                loHead <span>=</span> e<span>;</span>
                            <span>else</span>                                
                                <span>// loTail.next指向当前e</span>
                                loTail<span>.</span>next <span>=</span> e<span>;</span>
                            <span>// loTail指向当前的元素e</span>
                            <span>// 初始化后，loTail和loHead指向相同的内存，所以当loTail.next指向下一个元素时，</span>
                            <span>// 底层数组中的元素的next引用也相应发生变化，造成lowHead.next.next.....</span>
                            <span>// 跟随loTail同步，使得lowHead可以链接到所有属于该链表的元素。</span>
                            loTail <span>=</span> e<span>;</span>                           
                        <span>}</span>
                        <span>else</span> <span>{</span>
                            <span>if</span> <span>(</span>hiTail <span>==</span> <span>null</span><span>)</span>
                                <span>// 初始化head指向链表当前元素e, 初始化后hiHead代表下标更改的链表头元素</span>
                                hiHead <span>=</span> e<span>;</span>
                            <span>else</span>
                                hiTail<span>.</span>next <span>=</span> e<span>;</span>
                            hiTail <span>=</span> e<span>;</span>
                        <span>}</span>
                    <span>}</span> <span>while</span> <span>(</span><span>(</span>e <span>=</span> next<span>)</span> <span>!=</span> <span>null</span><span>)</span><span>;</span>
                    <span>// 遍历结束, 将tail指向null，并把链表头放入新数组的相应下标，形成新的映射。</span>
                    <span>if</span> <span>(</span>loTail <span>!=</span> <span>null</span><span>)</span> <span>{</span>
                        loTail<span>.</span>next <span>=</span> <span>null</span><span>;</span>
                        newTab<span>[</span>j<span>]</span> <span>=</span> loHead<span>;</span>
                    <span>}</span>
                    <span>if</span> <span>(</span>hiTail <span>!=</span> <span>null</span><span>)</span> <span>{</span>
                        hiTail<span>.</span>next <span>=</span> <span>null</span><span>;</span>
                        newTab<span>[</span>j <span>+</span> oldCap<span>]</span> <span>=</span> hiHead<span>;</span>
                    <span>}</span>
                <span>}</span>
            <span>}</span>
        <span>}</span>
    <span>}</span>
    <span>return</span> newTab<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br><span>96</span><br><span>97</span><br></div></div><blockquote>
<p>5、HashMap是怎么解决哈希冲突的？</p>
</blockquote>
<p>在解决这个问题之前，我们首先需要知道<strong>什么是哈希冲突</strong>，而在了解哈希冲突之前我们还要知道<strong>什么是哈希</strong>才行；</p>
<p><strong>（1）什么是哈希？</strong></p>
<p>Hash，一般翻译为“散列”，也有直接音译为“哈希”的，这就是把任意长度的输入通过散列算法，变换成固定长度的输出，该输出就是散列值（哈希值）；这种转换是一种压缩映射，也就是，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，所以不可能从散列值来唯一的确定输入值。<strong>简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数</strong>。</p>
<p>所有散列函数都有如下一个基本特性：<strong>一定不同根据同一散列函数计算出的散列值如果不同，那么输入值肯定也不同；输入值不同，根据同一散列函数计算出的散列值可能相同</strong>。</p>
<p><strong>（2）什么是哈希冲突？</strong></p>
<p>当两个不同的输入值，根据同一散列函数计算出相同的散列值的现象，我们就把它叫做碰撞（哈希碰撞）。</p>
<p><strong>（3）HashMap的数据结构</strong></p>
<p>HashMap使用一种叫做<strong>链地址法</strong>的方式可以解决哈希冲突：</p>
<p><img src="./assets/12.png" alt="image-20210115113459601"></p>
<p>这样我们就可以将拥有相同哈希值的对象组织成一个链表放在hash值所对应的bucket下， <strong>但相比于hashCode返回的int类型，我们HashMap初始的容量大小<code>DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4</code>（即2的四次方16）要远小于int类型的范围，所以我们如果只是单纯的用hashCode取余来获取对应的bucket这将会大大增加哈希碰撞的概率，并且最坏情况下还会将HashMap变成一个单链表，所以我们还需要对hashCode作一定的优化</strong></p>
<p><strong>（4）hash()函数</strong></p>
<p>上面提到的问题，主要是因为如果使用hashCode取余，那么相当于<strong>参与运算的只有hashCode的低位</strong>，高位是没有起到任何作用的，所以我们的思路就是让hashCode取值出的高位也参与运算，进一步降低hash碰撞的概率，使得数据分布更平均，我们把这样的操作称为<strong>扰动</strong>，在<strong>JDK 1.8</strong>中的hash()函数如下：</p>
<div><pre><code><span>static</span> <span>final</span> <span>int</span> <span>hash</span><span>(</span><span>Object</span> key<span>)</span> <span>{</span>
    <span>int</span> h<span>;</span>
    <span>return</span> <span>(</span>key <span>==</span> <span>null</span><span>)</span> <span>?</span> <span>0</span> <span>:</span> <span>(</span>h <span>=</span> key<span>.</span><span>hashCode</span><span>(</span><span>)</span><span>)</span> <span>^</span> <span>(</span>h <span>>>></span> <span>16</span><span>)</span><span>;</span><span>// 与自己右移16位进行异或运算（高低位异或）</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>这比在<strong>JDK 1.7</strong>中，更为简洁，<strong>相比在1.7中的4次位运算，5次异或运算（9次扰动），在1.8中，只进行了1次位运算和1次异或运算（2次扰动）</strong>；</p>
<p><strong>（5）JDK1.8新增红黑树</strong></p>
<p><img src="./assets/13.png" alt="img"></p>
<p>通过上面的<strong>链地址法（使用散列表）<strong>和</strong>扰动函数</strong>我们成功让我们的数据分布更平均，哈希碰撞减少，但是当我们的HashMap中存在大量数据时，加入我们某个bucket下对应的链表有n个元素，那么遍历时间复杂度就为O(n)，为了针对这个问题，JDK1.8在HashMap中新增了红黑树的数据结构，进一步使得遍历复杂度降低至O(logn)；</p>
<p><strong>（4）总结</strong></p>
<p>简单总结一下HashMap是使用了哪些方法来有效解决哈希冲突的：</p>
<ol>
<li>
<p>使用链地址法（使用散列表）来链接拥有相同hash值的数据；</p>
</li>
<li>
<p>使用2次扰动函数（hash函数）来降低哈希冲突的概率，使得数据分布更平均；</p>
</li>
<li>
<p>引入红黑树进一步降低遍历的时间复杂度，使得遍历更快；</p>
</li>
</ol>
<blockquote>
<p>6、能否使用任何类作为Map的 key？</p>
</blockquote>
<p><strong>可以，</strong> 然而在使用之前，需要考虑以下几点：</p>
<ul>
<li>如果类重写了 equals() 方法，也应该重写 hashCode() 方法。</li>
<li>类的所有实例需要遵循与 equals() 和 hashCode() 相关的规则。</li>
<li>如果一个类没有使用 equals()，不应该在 hashCode() 中使用它。</li>
<li>用户自定义 Key 类最佳实践是使之为不可变的，这样 hashCode() 值可以被缓存起来，拥有更好的性能。不可变的类也可以确保 hashCode() 和 equals() 在未来不会改变，这样就会解决与可变相关的问题了。</li>
</ul>
<blockquote>
<p>7、为什么HashMap中String、Integer这样的包装类适合作为K？</p>
</blockquote>
<p>String、Integer等包装类的特性能够保证Hash值的不可更改性和计算准确性，能够有效的减少Hash碰撞的几率</p>
<ol>
<li>都是final类型，即不可变性，保证key的不可更改性，不会存在获取hash值不同的情况</li>
<li>内部已重写了<code>equals()</code>、<code>hashCode()</code>等方法，遵守了HashMap内部的规范，不容易出现Hash值计算错误的情况；</li>
</ol>
<blockquote>
<p>8、如果使用Object作为HashMap的Key，应该怎么办呢？</p>
</blockquote>
<p>重写hashCode()和equals()方法</p>
<ol>
<li><strong>重写hashCode()是因为需要计算存储数据的存储位置</strong>，需要注意不要试图从散列码计算中排除掉一个对象的关键部分来提高性能，这样虽然能更快但可能会导致更多的Hash碰撞；</li>
<li><strong>重写equals()方法</strong>，需要遵守自反性、对称性、传递性、一致性以及对于任何非null的引用值x，x.equals(null)必须返回false的这几个特性，<strong>目的是为了保证key在哈希表中的唯一性</strong>；</li>
</ol>
<blockquote>
<p>9、HashMap为什么不直接使用hashCode()处理后的哈希值直接作为table的下标？</p>
</blockquote>
<ul>
<li>hashCode()方法返回的是int整数类型，其范围为-(2 ^ 31)~(2 ^ 31 - 1)，约有40亿个映射空间，</li>
<li>而HashMap的容量范围是在16（初始化默认值）~2 ^ 30，</li>
<li>HashMap通常情况下是取不到最大值的，并且设备上也难以提供这么多的存储空间，</li>
<li>通过hashCode()计算出的哈希值可能不在数组大小范围内，进而无法匹配存储位置，因此不能直接作为下标</li>
</ul>
<blockquote>
<p>10、HashMap 的长度为什么是2的幂次方</p>
</blockquote>
<p>为了能让 HashMap 存取高效，尽量较少碰撞，也就是要尽量把数据分配均匀，</p>
<p>每个链表/红黑树长度大致相同。这个实现就是把数据存到哪个链表/红黑树中的算法。</p>
<p><strong>这个算法应该如何设计呢？</strong></p>
<p>我们首先可能会想到采用%取余的操作来实现。但是，重点来了：“取余(%)操作中如果除数是2的幂次则等价于与其除数减一的与(&amp;)操</p>
<p>作（也就是说 hash%length==hash&amp;(length-1)的前提是 length 是2的 n 次方；）。” 并且 采用二进制位操作 &amp;，相对于%能够提高运</p>
<p>算效率，这就解释了 HashMap 的长度为什么是2的幂次方。</p>
<p><strong>那为什么是两次扰动呢？</strong></p>
<p>这样就是加大哈希值低位的随机性，使得分布更均匀，从而提高对应数组存储下标位置的随机性&amp;均匀性，最终减少Hash冲突，</p>
<p>两次就够了，已经达到了高位低位同时参与运算的目的；</p>
<blockquote>
<p>11、HashMap 与 HashTable 有什么区别？</p>
</blockquote>
<ol>
<li><strong>线程安全</strong>： HashMap 是非线程安全的，HashTable 是线程安全的；HashTable 内部的方法基本都经过 <code>synchronized</code> 修饰。HashTable已经不推荐使用（如果你要保证线程安全的话就使用 <code>ConcurrentHashMap</code>！）；</li>
<li><strong>效率</strong>： 因为线程安全的问题，HashMap 要比 HashTable 效率高一点。另外，HashTable 基本被淘汰，不要在代码中使用它；</li>
<li><strong>对Null key 和Null value的支持</strong>： HashMap 中，null 可以作为键，这样的键只有一个，可以有一个或多个键所对应的值为 null。但是在 HashTable 中 put 进的键值只要有一个 null，直接抛NullPointerException。</li>
<li><strong>初始容量大小和每次扩充容量大小的不同</strong>  ： ①创建时如果不指定容量初始值，Hashtable 默认的初始大小为11，之后每次扩充，容量变为原来的2n+1。HashMap 默认的初始化大小为16。之后每次扩充，容量变为原来的2倍。②创建时如果给定了容量初始值，那么 Hashtable 会直接使用你给定的大小，而 HashMap 会将其扩充为2的幂次方大小。也就是说 HashMap 总是使用2的幂作为哈希表的大小，后面会介绍到为什么是2的幂次方。</li>
<li><strong>底层数据结构</strong>： JDK1.8 以后的 HashMap 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。Hashtable 没有这样的机制。</li>
<li>推荐使用：在 Hashtable 的类注释可以看到，Hashtable 是保留类不建议使用，推荐在单线程环境下使用 HashMap 替代，如果需要多线程使用则用 ConcurrentHashMap 替代。</li>
</ol>
<blockquote>
<p>12、如何决定使用 HashMap 还是 TreeMap？</p>
</blockquote>
<ul>
<li>对于在Map中插入、删除和定位元素这类操作，HashMap是最好的选择。</li>
<li>然而，假如你需要对一个有序的key集合进行遍历，TreeMap是更好的选择。</li>
<li>基于你的collection的大小，也许向HashMap中添加元素会更快，将map换为TreeMap进行有序key的遍历。</li>
</ul>
<blockquote>
<p>13、HashMap 和 ConcurrentHashMap 的区别</p>
</blockquote>
<ul>
<li>
<p>ConcurrentHashMap对整个桶数组进行了分割分段(Segment)，然后在每一个分段上都用lock锁进行保护，</p>
<p>相对于HashTable的synchronized锁的粒度更精细了一些，并发性能更好，</p>
<p>而HashMap没有锁机制，不是线程安全的。（JDK1.8之后ConcurrentHashMap启用了一种全新的方式实现,利用<strong>CAS算法</strong>。）</p>
</li>
<li>
<p>HashMap的键值对允许有null，但是ConCurrentHashMap都不允许。</p>
</li>
</ul>
<blockquote>
<p>14、 ConcurrentHashMap 和 Hashtable 的区别？</p>
</blockquote>
<p>ConcurrentHashMap 结合了 HashMap 和 HashTable 二者的优势。HashMap 没有考虑同步，HashTable 考虑了同步的问题。但是</p>
<p>HashTable 在每次同步执行时都要锁住整个结构。 ConcurrentHashMap 锁的方式是稍微细粒度的。</p>
<p>ConcurrentHashMap 和 Hashtable 的区别主要体现在实现线程安全的方式上不同。</p>
<ul>
<li>
<p><strong>底层数据结构</strong>： JDK1.7的 ConcurrentHashMap 底层采用 <strong>分段的数组+链表</strong> 实现，JDK1.8 采用的数据结构跟HashMap1.8的结构一样，数组+链表/红黑二叉树。Hashtable 和 JDK1.8 之前的 HashMap 的底层数据结构类似都是采用 <strong>数组+链表</strong> 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的；</p>
</li>
<li>
<p><strong>实现线程安全的方式（重要）</strong>：</p>
<p>① <strong>在JDK1.7的时候，ConcurrentHashMap（分段锁）</strong> 对整个桶数组进行了分割分段(Segment)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。（默认分配16个Segment，比Hashtable效率提高16倍。） <strong>到了 JDK1.8 的时候已经摒弃了Segment的概念，而是直接用 Node 数组+链表+红黑树的数据结构来实现，并发控制使用 synchronized 和 CAS 来操作。（JDK1.6以后 对 synchronized锁做了很多优化）</strong> 整个看起来就像是优化过且线程安全的 HashMap，虽然在JDK1.8中还能看到 Segment 的数据结构，但是已经简化了属性，只是为了兼容旧版本；</p>
<p>② <strong>Hashtable(同一把锁)</strong> :使用 synchronized 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。</p>
</li>
</ul>
<p><strong>两者的对比图</strong>：</p>
<p>HashTable:</p>
<p><img src="./assets/14.png" alt="img"></p>
<p>JDK1.7的ConcurrentHashMap：</p>
<p><img src="./assets/15.png" alt="img"></p>
<p>JDK1.8的ConcurrentHashMap（TreeBin: 红黑二叉树节点 Node: 链表节点）：</p>
<p><img src="./assets/16.png" alt="img"></p>
<blockquote>
<p>15、ConcurrentHashMap 底层具体实现知道吗？实现原理是什么？</p>
</blockquote>
<p><strong>JDK1.7</strong></p>
<p>首先将数据分为一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问。</p>
<p>在JDK1.7中，ConcurrentHashMap采用Segment + HashEntry的方式进行实现，结构如下：</p>
<ul>
<li>一个 ConcurrentHashMap 里包含一个 Segment 数组。Segment 的结构和HashMap类似，是一种数组和链表结构，</li>
<li>一个 Segment 包含一个 HashEntry 数组，每个 HashEntry 是一个链表结构的元素，每个 Segment 守护着一个HashEntry数组里的元素，</li>
<li>当对 HashEntry 数组的数据进行修改时，必须首先获得对应的 Segment的锁。</li>
</ul>
<p><img src="./assets/17.png" alt="img"></p>
<ol>
<li>该类包含两个<strong>静态内部类</strong> HashEntry 和 Segment ；前者用来封装映射表的键值对，后者用来充当锁的角色；</li>
<li>Segment 是一种<strong>可重入的锁</strong> ReentrantLock，每个 Segment 守护一个HashEntry 数组里的元素，当对 HashEntry 数组的数据进行修改时，必须首先获得对应的 Segment 锁。</li>
</ol>
<p><strong>JDK1.8</strong></p>
<p>在<strong>JDK1.8中，放弃了Segment臃肿的设计，取而代之的是采用Node + CAS + Synchronized来保证并发安全进行实现</strong>，synchronized只锁定当前链表或红黑二叉树的首节点，这样只要hash不冲突，就不会产生并发，效率又提升N倍。</p>
<p>结构如下：</p>
<p><img src="./assets/18.png" alt="img"></p>
<p><strong>附加源码，有需要的可以看看</strong></p>
<p>插入元素过程（建议去看看源码）：</p>
<p>如果相应位置的Node还没有初始化，则调用CAS插入相应的数据；</p>
<div><pre><code><span>else</span> <span>if</span> <span>(</span><span>(</span>f <span>=</span> <span>tabAt</span><span>(</span>tab<span>,</span> i <span>=</span> <span>(</span>n <span>-</span> <span>1</span><span>)</span> <span>&amp;</span> hash<span>)</span><span>)</span> <span>==</span> <span>null</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span><span>casTabAt</span><span>(</span>tab<span>,</span> i<span>,</span> <span>null</span><span>,</span> <span>new</span> <span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span><span>(</span>hash<span>,</span> key<span>,</span> value<span>,</span> <span>null</span><span>)</span><span>)</span><span>)</span>
        <span>break</span><span>;</span>                   <span>// no lock when adding to empty bin</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>如果相应位置的Node不为空，且当前该节点不处于移动状态，则对该节点加synchronized锁，如果该节点的hash不小于0，则遍历链表更新节点或插入新节点；</p>
<div><pre><code><span>if</span> <span>(</span>fh <span>>=</span> <span>0</span><span>)</span> <span>{</span>
    binCount <span>=</span> <span>1</span><span>;</span>
    <span>for</span> <span>(</span><span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> e <span>=</span> f<span>;</span><span>;</span> <span>++</span>binCount<span>)</span> <span>{</span>
        <span>K</span> ek<span>;</span>
        <span>if</span> <span>(</span>e<span>.</span>hash <span>==</span> hash <span>&amp;&amp;</span>
            <span>(</span><span>(</span>ek <span>=</span> e<span>.</span>key<span>)</span> <span>==</span> key <span>||</span>
             <span>(</span>ek <span>!=</span> <span>null</span> <span>&amp;&amp;</span> key<span>.</span><span>equals</span><span>(</span>ek<span>)</span><span>)</span><span>)</span><span>)</span> <span>{</span>
            oldVal <span>=</span> e<span>.</span>val<span>;</span>
            <span>if</span> <span>(</span><span>!</span>onlyIfAbsent<span>)</span>
                e<span>.</span>val <span>=</span> value<span>;</span>
            <span>break</span><span>;</span>
        <span>}</span>
        <span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> pred <span>=</span> e<span>;</span>
        <span>if</span> <span>(</span><span>(</span>e <span>=</span> e<span>.</span>next<span>)</span> <span>==</span> <span>null</span><span>)</span> <span>{</span>
            pred<span>.</span>next <span>=</span> <span>new</span> <span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span><span>(</span>hash<span>,</span> key<span>,</span> value<span>,</span> <span>null</span><span>)</span><span>;</span>
            <span>break</span><span>;</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><ol>
<li>如果该节点是TreeBin类型的节点，说明是红黑树结构，则通过putTreeVal方法往红黑树中插入节点；如果binCount不为0，说明put操作对数据产生了影响，如果当前链表的个数达到8个，则通过treeifyBin方法转化为红黑树，如果oldVal不为空，说明是一次更新操作，没有对元素个数产生影响，则直接返回旧值；</li>
<li>如果插入的是一个新节点，则执行addCount()方法尝试更新元素个数baseCount；</li>
</ol>
<h4 id="四-辅助工具类-2"> （四）辅助工具类</h4>
<blockquote>
<p>1、Array 和 ArrayList 有何区别？</p>
</blockquote>
<ul>
<li>Array 可以存储基本数据类型和对象，ArrayList 只能存储对象。</li>
<li>Array 是指定固定大小的，而 ArrayList 大小是自动扩展的。</li>
<li>Array 内置方法没有 ArrayList 多，比如 addAll、removeAll、iteration 等方法只有 ArrayList 有。</li>
</ul>
<p>对于基本类型数据，集合使用自动装箱来减少编码工作量。但是，当处理固定大小的基本数据类型的时候，这种方式相对比较慢。</p>
<blockquote>
<p>2、如何实现 Array 和 List 之间的转换？</p>
</blockquote>
<ul>
<li>Array 转 List： Arrays. asList(array) ；</li>
<li>List 转 Array：List 的 toArray() 方法。</li>
</ul>
<blockquote>
<p>3、comparable 和 comparator的区别？</p>
</blockquote>
<ul>
<li>comparable接口实际上是出自java.lang包，它有一个 compareTo(Object obj)方法用来排序</li>
<li>comparator接口实际上是出自 java.util 包，它有一个compare(Object obj1, Object obj2)方法用来排序</li>
</ul>
<ol>
<li>
<p>一般我们需要对一个集合使用自定义排序时，我们就要重写compareTo方法或compare方法，</p>
</li>
<li>
<p>当我们需要对某一个集合实现两种排序方式，</p>
<p>比如一个song对象中的歌名和歌手名分别采用一种排序方法的话，我们可以</p>
<p>①重写compareTo方法和使用自制的Comparator方法</p>
<p>②以两个Comparator来实现歌名排序和歌星名排序</p>
<p>第二种代表我们只能使用两个参数版的Collections.sort().</p>
</li>
</ol>
<blockquote>
<p>4、Collection 和 Collections 有什么区别？</p>
</blockquote>
<ul>
<li>java.util.Collection 是一个集合接口（集合类的一个顶级接口）。它提供了对集合对象进行基本操作的通用接口方法。Collection接口在Java 类库中有很多具体的实现。Collection接口的意义是为各种具体的集合提供了最大化的统一操作方式，其直接继承接口有List与Set。</li>
<li>Collections则是集合类的一个工具类/帮助类，其中提供了一系列静态方法，用于对集合中元素进行排序、搜索以及线程安全等各种操作。</li>
</ul>
<blockquote>
<p>5、TreeMap 和 TreeSet 在排序时如何比较元素？Collections 工具类中的 sort()方法如何比较元素？</p>
</blockquote>
<ol>
<li>TreeSet 要求存放的<strong>对象</strong>所属的类必须实现 <strong>Comparable 接口</strong>，该接口提供了比较元素的 compareTo()方法，当插入元素时会回调该方法比较元素的大小。</li>
<li>TreeMap 要求存放的键值对映射的<strong>键</strong>必须实现 <strong>Comparable 接口</strong>从而根据键对元素进行排序。</li>
</ol>
<p>Collections 工具类的 sort 方法有两种重载的形式，</p>
<ul>
<li>第一种：要求传入的待排序容器中存放的<strong>对象</strong>比较实现 <strong>Comparable 接口</strong>以实现元素的比较；</li>
<li>第二种：不强制性的要求容器中的元素必须可比较，但是要求传入第二个参数，<strong>参数是Comparator 接口的子类型</strong>（需要重写 compare 方法实现元素的比较），相当于一个临时定义的排序规则，其实就是通过 <mark>接口注入</mark> 比较元素大小的算法，也是对 <mark>回调模式</mark> 的应用（Java 中对函数式编程的支持）。</li>
</ul>
<h3 id="二、泛型-2"> 二、泛型</h3>
<h3 id="三、异常-2"> 三、异常</h3>
<blockquote>
<p>1、Error 和 Exception 区别是什么？</p>
</blockquote>
<ol>
<li>Error 类型的错误通常为虚拟机相关错误，如系统崩溃，内存不足，堆栈溢出等，编译器不会对这类错误进行检测，JAVA 应用程序也不应对这类错误进行捕获，一旦这类错误发生，通常应用程序会被终止，仅靠应用程序本身无法恢复；</li>
<li>Exception 类的错误是可以在应用程序中进行捕获并处理的，通常遇到这种错误，应对其进行处理，使应用程序可以继续正常运行。</li>
</ol>
<blockquote>
<p>2、运行时异常和一般异常(受检异常)区别是什么？</p>
</blockquote>
<p>运行时异常包括 RuntimeException 类及其子类，表示 JVM 在运行期间可能出现的异常。 Java 编译器不会检查运行时异常。</p>
<p>受检异常是Exception 中除 RuntimeException 及其子类之外的异常。 Java 编译器会检查受检异常。</p>
<p><strong>RuntimeException异常和受检异常之间的区别</strong>：</p>
<ul>
<li>是否强制要求调用者必须处理此异常，如果强制要求调用者必须进行处理，那么就使用受检异常，</li>
<li>否则就选择非受检异常(RuntimeException)。一般来讲，如果没有特殊的要求，我们建议使用RuntimeException异常。</li>
</ul>
<blockquote>
<p>3、JVM 是如何处理异常的？</p>
</blockquote>
<ol>
<li>在一个方法中如果发生异常，这个方法会创建一个异常对象，并转交给 JVM，该异常对象包含异常名称，异常描述以及异常发生时应用程序的状态。创建异常对象并转交给 JVM 的过程称为<strong>抛出异常</strong>。可能有一系列的方法调用，最终才进入抛出异常的方法，这一系列方法调用的有序列表叫做调用栈。</li>
<li>JVM 会顺着调用栈去查找看是否有可以处理异常的代码，如果有，则调用异常处理代码。当 JVM 发现可以处理异常的代码时，会把发生的异常传递给它。如果 JVM 没有找到可以处理该异常的代码块，JVM 就会将该异常转交给默认的异常处理器（默认处理器为 JVM 的一部分），默认异常处理器打印出异常信息并终止应用程序。</li>
</ol>
<blockquote>
<p>4、throw 和 throws 的区别是什么？</p>
</blockquote>
<p>Java 中的异常处理除了包括捕获异常和处理异常之外，还包括声明异常和拋出异常，可以通过 throws 关键字在方法上声明该方法要拋</p>
<p>出的异常，或者在方法内部通过 throw 拋出异常对象。</p>
<p><strong>throws 关键字和 throw 关键字在使用上的几点区别如下</strong>：</p>
<ul>
<li>throw 关键字用在方法内部，只能用于抛出一种异常，用来抛出方法或代码块中的异常，受查异常和非受查异常都可以被抛出。</li>
<li>throws 关键字用在方法声明上，可以抛出多个异常，用来标识该方法可能抛出的异常列表。一个方法用 throws 标识了可能抛出的异常列表，调用该方法的方法中必须包含可处理异常的代码，否则也要在方法签名中用 throws 关键字声明相应的异常。</li>
</ul>
<blockquote>
<p>5、final、finally、finalize 有什么区别？</p>
</blockquote>
<ul>
<li>final可以修饰类、变量、方法，修饰类表示该类不能被继承、修饰方法表示该方法不能被重写、修饰变量表示该变量是一个常量不能被重新赋值。</li>
<li>finally一般作用在try-catch代码块中，在处理异常的时候，通常我们将一定要执行的代码方法finally代码块中，表示不管是否出现异常，该代码块都会执行，一般用来存放一些关闭资源的代码。</li>
<li>finalize是一个方法，属于Object类的一个方法，而Object类是所有类的父类，Java 中允许使用 finalize()方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。</li>
</ul>
<blockquote>
<p>6、NoClassDefFoundError 和 ClassNotFoundException 区别？</p>
</blockquote>
<ul>
<li>
<p>NoClassDefFoundError 是一个 Error 类型的异常，是由 JVM 引起的，不应该尝试捕获这个异常。</p>
<p>1、引起该异常的原因是 JVM 或 ClassLoader 尝试加载某类时在内存中找不到该类的定义，</p>
<p>2、该动作发生在运行期间，即编译时该类存在，但是在运行时却找不到了，可能是编译后被删除了等原因导致；</p>
</li>
<li>
<p>ClassNotFoundException 是一个受查异常，需要显式地使用 try-catch 对其进行捕获和处理，或在方法签名中用 throws 关键字进行声明。</p>
<p>1、当使用 Class.forName, ClassLoader.loadClass 或 ClassLoader.findSystemClass 动态加载类到内存的时候，通过传入的类路径参数没有找到该类，就会抛出该异常；</p>
<p>2、另一种抛出该异常的可能原因是某个类已经由一个类加载器加载至内存中，另一个加载器又尝试去加载它。</p>
</li>
</ul>
<blockquote>
<p>7、try-catch-finally 中哪个部分可以省略？</p>
</blockquote>
<p>catch 可以省略</p>
<p><strong>原因</strong></p>
<ol>
<li>更为严格的说法其实是：try只适合处理运行时异常，try+catch适合处理运行时异常+普通异常。也就是说，如果你只用try去处理普通异常却不加以catch处理，编译是通不过的，因为编译器硬性规定，普通异常如果选择捕获，则必须用catch显示声明以便进一步处理。而运行时异常在编译时没有如此规定，所以catch可以省略，你加上catch编译器也觉得无可厚非。</li>
<li>理论上，编译器看任何代码都不顺眼，都觉得可能有潜在的问题，所以你即使对所有代码加上try，代码在运行期时也只不过是在正常运行的基础上加一层皮。但是你一旦对一段代码加上try，就等于显示地承诺编译器，对这段代码可能抛出的异常进行捕获而非向上抛出处理。如果是普通异常，编译器要求必须用catch捕获以便进一步处理；如果运行时异常，捕获然后丢弃并且+finally扫尾处理，或者加上catch捕获以便进一步处理。</li>
<li>至于加上finally，则是在不管有没捕获异常，都要进行的“扫尾”处理。</li>
</ol>
<blockquote>
<p>8、try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？</p>
</blockquote>
<p>答：会执行，在 return 前执行。</p>
<p><strong>注意</strong>：在 finally 中改变返回值的做法是不好的，因为如果存在 finally 代码块，<strong>try中的 return 语句不会立马返回调用者</strong>，而是</p>
<p>记录下返回值待 finally 代码块执行完毕之后再向调用者返回其值，然后如果在 finally 中修改了返回值，就会返回修改后的值。显然，</p>
<p>在 finally 中返回或者修改返回值会对程序造成很大的困扰，C#中直接用编译错误的方式来阻止程序员干这种龌龊的事情，Java 中也可</p>
<p>以通过提升编译器的语法检查级别来产生警告或错误。</p>
<p><strong>代码示例1：</strong></p>
<div><pre><code><span>public</span> <span>static</span> <span>int</span> <span>getInt</span><span>(</span><span>)</span> <span>{</span>
    <span>int</span> a <span>=</span> <span>10</span><span>;</span>
    <span>try</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>a <span>/</span> <span>0</span><span>)</span><span>;</span>
        a <span>=</span> <span>20</span><span>;</span>
    <span>}</span> <span>catch</span> <span>(</span><span>ArithmeticException</span> e<span>)</span> <span>{</span>
        a <span>=</span> <span>30</span><span>;</span>
        <span>return</span> a<span>;</span>
        <span>/*
         * return a 在程序执行到这一步的时候，这里不是return a 而是 return 30；这个返回路径就形成了
         * 但是呢，它发现后面还有finally，所以继续执行finally的内容，a=40
         * 再次回到以前的路径,继续走return 30，形成返回路径之后，这里的a就不是a变量了，而是常量30
         */</span>
    <span>}</span> <span>finally</span> <span>{</span>
        a <span>=</span> <span>40</span><span>;</span>
    <span>}</span>
	<span>return</span> a<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><p>执行结果：30</p>
<p><strong>代码示例2：</strong></p>
<div><pre><code><span>public</span> <span>static</span> <span>int</span> <span>getInt</span><span>(</span><span>)</span> <span>{</span>
    <span>int</span> a <span>=</span> <span>10</span><span>;</span>
    <span>try</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>a <span>/</span> <span>0</span><span>)</span><span>;</span>
        a <span>=</span> <span>20</span><span>;</span>
    <span>}</span> <span>catch</span> <span>(</span><span>ArithmeticException</span> e<span>)</span> <span>{</span>
        a <span>=</span> <span>30</span><span>;</span>
        <span>return</span> a<span>;</span>
    <span>}</span> <span>finally</span> <span>{</span>
        a <span>=</span> <span>40</span><span>;</span>
        <span>//如果这样，就又重新形成了一条返回路径，由于只能通过1个return返回，所以这里直接返回40</span>
        <span>return</span> a<span>;</span> 
    <span>}</span>

<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>执行结果：40</p>
<blockquote>
<p>9、类 ExampleA 继承 Exception，类 ExampleB 继承ExampleA。</p>
</blockquote>
<p>有如下代码片断：</p>
<div><pre><code><span>try</span> <span>{</span>
	<span>throw</span> <span>new</span> <span>ExampleB</span><span>(</span><span>"b"</span><span>)</span>
<span>}</span> <span>catch</span>（<span>ExampleA</span> e）<span>{</span>
	<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"ExampleA"</span><span>)</span><span>;</span>
<span>}</span> <span>catch</span>（<span>Exception</span> e）<span>{</span>
	<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"Exception"</span><span>)</span><span>;</span>
<span>}</span>
<span>1234567</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>请问执行此段代码的输出是什么？</p>
<p><strong>答</strong>：</p>
<p>输出：ExampleA。（根据里<strong>氏代换原则</strong>[能使用父类型的地方一定能使用子类型]，抓取 ExampleA 类型异常的 catch 块能够抓住 try 块中抛出的 ExampleB 类型的异常）</p>
<p>面试题 - 说出下面代码的运行结果。（此题的出处是《Java 编程思想》一书）</p>
<div><pre><code><span>class</span> <span>Annoyance</span> <span>extends</span> <span>Exception</span> <span>{</span>
<span>}</span>
<span>class</span> <span>Sneeze</span> <span>extends</span> <span>Annoyance</span> <span>{</span>
<span>}</span>
<span>class</span> <span>Human</span> <span>{</span>
	<span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span>
	<span>throws</span> <span>Exception</span> <span>{</span>
		<span>try</span> <span>{</span>
			<span>try</span> <span>{</span>
				<span>throw</span> <span>new</span> <span>Sneeze</span><span>(</span><span>)</span><span>;</span>
			<span>}</span> <span>catch</span> <span>(</span> <span>Annoyance</span> a <span>)</span> <span>{</span>
				<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"Caught Annoyance"</span><span>)</span><span>;</span>
				<span>throw</span> a<span>;</span>
			<span>}</span>
		<span>}</span> <span>catch</span> <span>(</span> <span>Sneeze</span> s <span>)</span> <span>{</span>
			<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"Caught Sneeze"</span><span>)</span><span>;</span>
			<span>return</span> <span>;</span>
		<span>}</span> <span>finally</span> <span>{</span>
			<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"Hello World!"</span><span>)</span><span>;</span>
		<span>}</span>
	<span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><p>结果</p>
<div><pre><code><span>Caught</span> <span>Annoyance</span>
<span>Caught</span> <span>Sneeze</span>
<span>Hello</span> <span>World</span><span>!</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><blockquote>
<p>10、常见的 RuntimeException 有哪些？</p>
</blockquote>
<ul>
<li>ClassCastException(类转换异常)</li>
<li>IndexOutOfBoundsException(数组越界)</li>
<li>NullPointerException(空指针)</li>
<li>ArrayStoreException(数据存储异常，操作数组时类型不一致)</li>
<li>还有IO操作的BufferOverflowException异常</li>
</ul>
<blockquote>
<p>11、Java常见异常有哪些？</p>
</blockquote>
<ul>
<li>java.lang.<strong>IllegalAccessError</strong>：违法访问错误。当一个应用试图访问、修改某个类的域（Field）或者调用其方法，但是又违反域或方法的可见性声明，则抛出该异常。</li>
<li>java.lang.<strong>InstantiationError</strong>：实例化错误。当一个应用试图通过Java的new操作符构造一个抽象类或者接口时抛出该异常.</li>
<li>java.lang.<strong>OutOfMemoryError</strong>：内存不足错误。当可用内存不足以让Java虚拟机分配给一个对象时抛出该错误。</li>
<li>java.lang.<strong>StackOverflowError</strong>：堆栈溢出错误。当一个应用递归调用的层次太深而导致堆栈溢出或者陷入死循环时抛出该错误。</li>
<li>java.lang.<strong>ClassCastException</strong>：类造型异常。假设有类A和B（A不是B的父类或子类），O是A的实例，那么当强制将O构造为类B的实例时抛出该异常。该异常经常被称为强制类型转换异常。</li>
<li>java.lang.<strong>ClassNotFoundException</strong>：找不到类异常。当应用试图根据字符串形式的类名构造类，而在遍历CLASSPAH之后找不到对应名称的class文件时，抛出该异常。</li>
<li>java.lang.<strong>ArithmeticException</strong>：算术条件异常。譬如：整数除零等。</li>
<li>java.lang.<strong>ArrayIndexOutOfBoundsExceptio</strong>n：数组索引越界异常。当对数组的索引值为负数或大于等于数组大小时抛出。</li>
<li>java.lang.<strong>IndexOutOfBoundsException</strong>：索引越界异常。当访问某个序列的索引值小于0或大于等于序列大小时，抛出该异常。</li>
<li>java.lang.<strong>InstantiationException</strong>：实例化异常。当试图通过newInstance()方法创建某个类的实例，而该类是一个抽象类或接口时，抛出该异常。</li>
<li>java.lang.<strong>NoSuchFieldException</strong>：属性不存在异常。当访问某个类的不存在的属性时抛出该异常。</li>
<li>java.lang.<strong>NoSuchMethodException</strong>：方法不存在异常。当访问某个类的不存在的方法时抛出该异常。</li>
<li>java.lang.<strong>NullPointerException</strong>：空指针异常。当应用试图在要求使用对象的地方使用了null时，抛出该异常。譬如：调用null对象的实例方法、访问null对象的属性、计算null对象的长度、使用throw语句抛出null等等。</li>
<li>java.lang.<strong>NumberFormatException</strong>：数字格式异常。当试图将一个String转换为指定的数字类型，而该字符串确不满足数字类型要求的格式时，抛出该异常。</li>
<li>java.lang.<strong>StringIndexOutOfBoundsException</strong>：字符串索引越界异常。当使用索引值访问某个字符串中的字符，而该索引值小于0或大于等于序列大小时，抛出该异常。</li>
</ul>
<h3 id="四、io流-2"> 四、IO流</h3>
<blockquote>
<p>1、Java 中 IO 流分为几种?</p>
</blockquote>
<ul>
<li>
<p>按照流的流向分，可以分为输入流和输出流；</p>
</li>
<li>
<p>按照操作单元划分，可以划分为字节流和字符流；</p>
</li>
<li>
<p>按照流的角色划分为节点流和处理流。
Java IO流共涉及40多个类，这些类看上去很杂乱，但实际上很有规则，而且彼此之间存在非常紧密的联系， Java IO流的40多个类都是从如下4个抽象类基类中派生出来的。</p>
</li>
<li>
<p>InputStream/Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。</p>
</li>
<li>
<p>OutputStream/Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流。</p>
</li>
</ul>
<p>按操作方式分类结构图：
<img src="./assets/19.jpg" alt=""></p>
<p>按操作对象分类结构图：</p>
<p>​	<img src="./assets/20.jpg" alt=""></p>
<blockquote>
<p>2、BIO,NIO,AIO 有什么区别?</p>
</blockquote>
<p><strong>简答</strong></p>
<ul>
<li>
<p>BIO：Blocking IO 同步<strong>阻塞式 IO</strong>，就是我们平常使用的<strong>传统 IO</strong>，它的特点是模式简单使用方便，<strong>并发处理能力低</strong>。</p>
</li>
<li>
<p>NIO：New IO 同步<strong>非阻塞 IO</strong>，是传统 IO 的升级，客户端和服务器端通过 Channel（通道）通讯，实现了<strong>多路复用</strong>。</p>
</li>
<li>
<p>AIO：Asynchronous IO 是 NIO 的升级，也叫 NIO2，实现了<strong>异步非堵塞 IO</strong> ，异步 IO 的操作基于<strong>事件和回调机制</strong>。</p>
</li>
</ul>
<p><strong>使用场景：</strong></p>
<ul>
<li>对于低负载、低并发的应用程序，可以使用同步阻塞I/O来提升开发速率和更好的维护性；</li>
<li>对于高负载、高并发的（网络）应用，应使用 NIO 的非阻塞模式来开发</li>
</ul>
<p><strong>详细回答</strong></p>
<ul>
<li>BIO (Blocking I/O): 同步阻塞I/O模式，数据的读取写入必须阻塞在一个线程内等待其完成。在活动连接数不是特别高（小于单机1000）的情况下，这种模型是比较不错的，可以让每一个连接专注于自己的 I/O 并且编程模型简单，也不用过多考虑系统的过载、限流等问题。线程池本身就是一个天然的漏斗，可以缓冲一些系统处理不了的连接或请求。但是，当面对十万甚至百万级连接的时候，传统的 BIO 模型是无能为力的。因此，我们需要一种更高效的 I/O 处理模型来应对更高的并发量。</li>
<li>NIO (New I/O): NIO是一种同步非阻塞的I/O模型，在<strong>Java 1.4</strong> 中引入了NIO框架，对应 java.nio 包，提供了 <strong>Channel , Selector，Buffer</strong>等抽象。NIO中的N可以理解为Non-blocking，不单纯是New。它支持面向缓冲的，基于通道的I/O操作方法。 NIO提供了与传统BIO模型中的 Socket 和 ServerSocket 相对应的 SocketChannel 和 ServerSocketChannel 两种不同的套接字通道实现,两种通道都支持阻塞和非阻塞两种模式。阻塞模式使用就像传统中的支持一样，比较简单，但是性能和可靠性都不好；非阻塞模式正好与之相反。</li>
<li>AIO (Asynchronous I/O): AIO 也就是 NIO 2。在 <strong>Java 7</strong> 中引入了 NIO 的改进版 NIO 2,它是异步非阻塞的IO模型。异步 IO 是<strong>基于事件和回调机制</strong>实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。AIO 是异步IO的缩写，虽然 NIO 在网络操作中，提供了非阻塞的方法，但是 NIO 的 IO 行为还是同步的。对于 NIO 来说，我们的业务线程是在 IO 操作准备好时，得到通知，接着就由这个线程自行进行 IO 操作，IO操作本身是同步的。查阅网上相关资料，我发现就目前来说 AIO 的应用还不是很广泛，Netty 之前也尝试使用过 AIO，不过又放弃了。</li>
</ul>
<blockquote>
<p>3、Files的常用方法都有哪些？</p>
</blockquote>
<p>Files. exists()：检测文件路径是否存在。</p>
<p>Files. createFile()：创建文件。</p>
<p>Files. createDirectory()：创建文件夹。</p>
<p>Files. delete()：删除一个文件或目录。</p>
<p>Files. copy()：复制文件。</p>
<p>Files. move()：移动文件。</p>
<p>Files. size()：查看文件个数。</p>
<p>Files. read()：读取文件。</p>
<p>Files. write()：写入文件。</p>
<h3 id="五、注解-2"> 五、注解</h3>
<h3 id="六、反射-2"> 六、反射</h3>
<blockquote>
<p>1、什么是反射机制？</p>
</blockquote>
<p>JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种<strong>动态获取的信息以及动态调用对象的方法的功能</strong>称为java语言的反射机制。</p>
<p>静态编译和动态编译</p>
<p><strong>静态编译</strong>：在编译时确定类型，绑定对象</p>
<p><strong>动态编译</strong>：运行时确定类型，绑定对象</p>
<blockquote>
<p>2、反射机制优缺点</p>
</blockquote>
<p>优点： 运行期类型的判断，动态加载类，提高代码灵活度。</p>
<p>缺点： 性能瓶颈：反射相当于一系列解释操作，通知 JVM 要做的事情，性能比直接的java代码要慢很多。</p>
<blockquote>
<p>3、反射机制的应用场景有哪些？</p>
</blockquote>
<p><strong>反射是框架设计的灵魂。</strong></p>
<p>在我们平时的项目开发过程中，基本上很少会直接使用到反射机制，但这不能说明反射机制没有用，实际上有很多设计、开发都与反射机制有关，例如：</p>
<ul>
<li>模块化的开发，通过反射去调用对应的字节码；</li>
<li>动态代理设计模式也采用了反射机制，</li>
<li>还有我们日常使用的 Spring／Hibernate 等框架也大量使用到了反射机制。</li>
</ul>
<p><strong>举例：</strong></p>
<p>1、我们在使用JDBC连接数据库时使用Class.forName()通过反射加载数据库的驱动程序；</p>
<p>2、Spring框架也用到很多反射机制，最经典的就是xml的配置模式。</p>
<p>Spring 通过 XML 配置模式装载 Bean 的过程：</p>
<ul>
<li>1）将程序内所有 XML 或 Properties 配置文件加载入内存中;</li>
<li>2）Java类里面解析xml或properties里面的内容，得到对应实体类的字节码字符串以及相关的属性信息;</li>
<li>3）使用反射机制，根据这个字符串获得某个类的Class实例;</li>
<li>4）动态配置实例的属性</li>
</ul>
<blockquote>
<p>4、Java获取反射的三种方法</p>
</blockquote>
<p>1.通过new对象实现反射机制</p>
<p>2.通过路径实现反射机制</p>
<p>3.通过类名实现反射机制</p>
<div><pre><code><span>public</span> <span>class</span> <span>Student</span> <span>{</span>
    <span>private</span> <span>int</span> id<span>;</span>
    <span>String</span> name<span>;</span>
    <span>protected</span> <span>boolean</span> sex<span>;</span>
    <span>public</span> <span>float</span> score<span>;</span>
<span>}</span>

<span>public</span> <span>class</span> <span>Get</span> <span>{</span>
    <span>//获取反射机制三种方式</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>throws</span> <span>ClassNotFoundException</span> <span>{</span>
        <span>//方式一(通过建立对象)</span>
        <span>Student</span> stu <span>=</span> <span>new</span> <span>Student</span><span>(</span><span>)</span><span>;</span>
        <span>Class</span> classobj1 <span>=</span> stu<span>.</span><span>getClass</span><span>(</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>classobj1<span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>
        <span>//方式二（通过所在路径-相对路径）</span>
        <span>Class</span> classobj2 <span>=</span> <span>Class</span><span>.</span><span>forName</span><span>(</span><span>"fanshe.Student"</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>classobj2<span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>
        <span>//方式三（通过类名）</span>
        <span>Class</span> classobj3 <span>=</span> <span>Student</span><span>.</span><span>class</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>classobj3<span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><h3 id="七、网络-2"> 七、网络</h3>
<blockquote>
<p>1、为什么TCP连接的时候是3次？2次不可以吗？</p>
</blockquote>
<ol>
<li>因为需要考虑连接时丢包的问题，如果只握手2次，第二次握手时如果服务端发给客户端的确认报文段丢失，此时服务端已经准备好了收发数(可以理解服务端已经连接成功)据，而客户端一直没收到服务端的确认报文，所以客户端就不知道服务端是否已经准备好了(可以理解为客户端未连接成功)，这种情况下客户端不会给服务端发数据，也会忽略服务端发过来的数据。</li>
<li>如果是三次握手，即便发生丢包也不会有问题，比如如果第三次握手客户端发的确认ack报文丢失，服务端在一段时间内没有收到确认ACK报文的话就会重新进行第二次握手，也就是服务端会重发SYN报文段，客户端收到重发的报文段后会再次给服务端发送确认ACK报文。</li>
</ol>
<p>客户端：兄弟，在吗？</p>
<p>服务端：在的，老铁</p>
<p>客户端：回个消息磨磨唧唧，都等你半天了</p>
<p><img src="./assets/21.png" alt=""></p>
<ul>
<li><strong>第一次握手</strong>：客户端要向服务端发起连接请求，首先客户端随机生成一个起始序列号ISN(比如是100)，那客户端向服务端发送的报文段包含SYN标志位(也就是SYN=1)，序列号seq=100。</li>
<li><strong>第二次握手</strong>：服务端收到客户端发过来的报文后，发现SYN=1，知道这是一个连接请求，于是将客户端的起始序列号100存起来，并且随机生成一个服务端的起始序列号(比如是300)。然后给客户端回复一段报文，回复报文包含SYN和ACK标志(也就是SYN=1,ACK=1)、序列号seq=300、确认号ack=101(客户端发过来的序列号+1)。</li>
<li><strong>第三次握手</strong>：客户端收到服务端的回复后发现ACK=1并且ack=101,于是知道服务端已经收到了序列号为100的那段报文；同时发现SYN=1，知道了服务端同意了这次连接，于是就将服务端的序列号300给存下来。然后客户端再回复一段报文给服务端，报文包含ACK标志位(ACK=1)、ack=301(服务端序列号+1)、seq=101(第一次握手时发送报文是占据一个序列号的，所以这次seq就从101开始，需要注意的是不携带数据的ACK报文是不占据序列号的，所以后面第一次正式发送数据时seq还是101)。当服务端收到报文后发现ACK=1并且ack=301，就知道客户端收到序列号为300的报文了，就这样客户端和服务端通过TCP建立了连接。</li>
</ul>
<blockquote>
<p>2、为什么TCP连接的时候是3次，关闭的时候却是4次？</p>
</blockquote>
<p>因为只有在客户端和服务端都没有数据要发送的时候才能断开TCP。而客户端发出FIN报文时只能保证客户端没有数据发了，服务端还有没有数据发客户端是不知道的。而服务端收到客户端的FIN报文后只能先回复客户端一个确认报文来告诉客户端我服务端已经收到你的FIN报文了，但我服务端还有一些数据没发完，等这些数据发完了服务端才能给客户端发FIN报文(所以不能一次性将确认报文和FIN报文发给客户端，就是这里多出来了一次)。</p>
<p>客户端：我要准备溜了</p>
<p>服务端：收到，老铁。不过等一下，我还有点东西要发你</p>
<p>服务端：也不是啥重要的，算了，不发了，滚你</p>
<p>客户端：****</p>
<p>服务端断开连接....</p>
<p>2MSL后</p>
<p>客户端断开连接......</p>
<p><img src="./assets/22.png" alt=""></p>
<p>比如客户端初始化的序列号ISA=100，服务端初始化的序列号ISA=300。TCP连接成功后客户端总共发送了1000个字节的数据，服务端在客户端发FIN报文前总共回复了2000个字节的数据。</p>
<ul>
<li>
<p><strong>第一次挥手</strong>：当客户端的数据都传输完成后，客户端向服务端发出连接释放报文(当然数据没发完时也可以发送连接释放报文并停止发送数据)，释放连接报文包含FIN标志位(FIN=1)、序列号seq=1101(100+1+1000，其中的1是建立连接时占的一个序列号)。需要注意的是客户端发出FIN报文段后只是不能发数据了，但是还可以正常收数据；另外FIN报文段即使不携带数据也要占据一个序列号。</p>
</li>
<li>
<p><strong>第二次挥手</strong>：服务端收到客户端发的FIN报文后给客户端回复确认报文，确认报文包含ACK标志位(ACK=1)、确认号ack=1102(客户端FIN报文序列号1101+1)、序列号seq=2300(300+2000)。此时服务端处于关闭等待状态，而不是立马给客户端发FIN报文，这个状态还要持续一段时间，因为服务端可能还有数据没发完。</p>
</li>
<li>
<p><strong>第三次挥手</strong>：服务端将最后数据(比如50个字节)发送完毕后就向客户端发出连接释放报文，报文包含FIN和ACK标志位(FIN=1,ACK=1)、确认号和第二次挥手一样ack=1102、序列号seq=2350(2300+50)。</p>
</li>
<li>
<p><strong>第四次挥手</strong>：客户端收到服务端发的FIN报文后，向服务端发出确认报文，确认报文包含ACK标志位(ACK=1)、确认号ack=2351、序列号seq=1102。注意客户端发出确认报文后不是立马释放TCP连接，而是要经过2MSL(最长报文段寿命的2倍时长)后才释放TCP连接。而服务端一旦收到客户端发出的确认报文就会立马释放TCP连接，所以服务端结束TCP连接的时间要比客户端早一些。</p>
</li>
</ul>
<blockquote>
<p>3、为什么客户端发出第四次挥手的确认报文后要等2MSL的时间才能释放TCP连接？</p>
</blockquote>
<p>这里同样是要考虑丢包的问题，如果第四次挥手的报文丢失，服务端就收到确认ACK报文，这样服务端就会就会重发第三次挥手的报文。这样以来，客户端从发出第四次挥手的报文到再次收到第三次挥手的报文经历的最长时间就是2MSL，所以需要等这么长时间来确认服务端确实已经收到了。</p>
<blockquote>
<p>4、如果已经建立了连接，但是客户端突然出现故障了怎么办？</p>
</blockquote>
<p>TCP设有一个<strong>保活计时器</strong>，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为<strong>2小时</strong>，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后<strong>每隔75秒</strong>钟发送一次。若一连发送<strong>10个探测报文</strong>仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。</p>
<blockquote>
<p>5、什么是HTTP，HTTP 与 HTTPS 的区别</p>
</blockquote>
<p>HTTP 是一个在计算机世界里专门在两点之间传输文字、图片、音频、视频等<strong>超文本数据的约定和规范</strong></p>
<table>
<thead>
<tr>
<th>区别</th>
<th>HTTP</th>
<th>HTTPS</th>
</tr>
</thead>
<tbody>
<tr>
<td>协议</td>
<td>运行在 TCP 之上，明文传输，<strong>客户端与服务器端都无法验证对方的身份</strong></td>
<td>身披 SSL( Secure Socket Layer )外壳的 HTTP，运行于 SSL 上，SSL 运行于 TCP 之上， <strong>是添加了加密和认证机制的 HTTP</strong>。</td>
</tr>
<tr>
<td>端口</td>
<td>80</td>
<td>443</td>
</tr>
<tr>
<td>资源消耗</td>
<td>较少</td>
<td>由于加解密处理，会消耗更多的 CPU 和内存资源</td>
</tr>
<tr>
<td>开销</td>
<td>无需证书</td>
<td>需要证书，而证书一般需要向认证机构购买</td>
</tr>
<tr>
<td>加密机制</td>
<td>无</td>
<td>共享密钥加密和公开密钥加密并用的混合加密机制</td>
</tr>
<tr>
<td>安全性</td>
<td>弱</td>
<td>由于加密机制，安全性强</td>
</tr>
</tbody>
</table>
<blockquote>
<p>6、常用HTTP状态码</p>
</blockquote>
<p>HTTP状态码表示客户端HTTP请求的返回结果、标识服务器处理是否正常、表明请求出现的错误等。</p>
<p><strong>状态码的类别：</strong></p>
<table>
<thead>
<tr>
<th>类别</th>
<th>原因短语</th>
</tr>
</thead>
<tbody>
<tr>
<td>1XX</td>
<td>Informational（信息性状态码） 接受的请求正在处理</td>
</tr>
<tr>
<td>2XX</td>
<td>Success（成功状态码） 请求正常处理完毕</td>
</tr>
<tr>
<td>3XX</td>
<td>Redirection（重定向状态码） 需要进行附加操作以完成请求</td>
</tr>
<tr>
<td>4XX</td>
<td>Client Error（客户端错误状态码） 服务器无法处理请求</td>
</tr>
<tr>
<td>5XX</td>
<td>Server Error（服务器错误状态码） 服务器处理请求出错</td>
</tr>
</tbody>
</table>
<p><strong>常用HTTP状态码：</strong></p>
<table>
<thead>
<tr>
<th>2XX</th>
<th>成功（这系列表明请求被正常处理了）</th>
</tr>
</thead>
<tbody>
<tr>
<td>200</td>
<td>OK，表示从客户端发来的请求在服务器端被正确处理</td>
</tr>
<tr>
<td>204</td>
<td>No content，表示请求成功，但响应报文不含实体的主体部分</td>
</tr>
<tr>
<td>206</td>
<td>Partial Content，进行范围请求成功</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>3XX</th>
<th>重定向（表明浏览器要执行特殊处理）</th>
</tr>
</thead>
<tbody>
<tr>
<td>301</td>
<td>moved permanently，永久性重定向，表示资源已被分配了新的 URL</td>
</tr>
<tr>
<td>302</td>
<td>found，临时性重定向，表示资源临时被分配了新的 URL</td>
</tr>
<tr>
<td>303</td>
<td>see other，表示资源存在着另一个 URL，应使用 GET 方法获取资源（对于301/302/303响应，几乎所有浏览器都会删除报文主体并自动用GET重新请求）</td>
</tr>
<tr>
<td>304</td>
<td>not modified，表示服务器允许访问资源，但请求未满足条件的情况（与重定向无关）</td>
</tr>
<tr>
<td>307</td>
<td>temporary redirect，临时重定向，和302含义类似，但是期望客户端保持请求方法不变向新的地址发出请求</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>4XX</th>
<th>客户端错误</th>
</tr>
</thead>
<tbody>
<tr>
<td>400</td>
<td>bad request，请求报文存在语法错误</td>
</tr>
<tr>
<td>401</td>
<td>unauthorized，表示发送的请求需要有通过 HTTP 认证的认证信息</td>
</tr>
<tr>
<td>403</td>
<td>forbidden，表示对请求资源的访问被服务器拒绝，可在实体主体部分返回原因描述</td>
</tr>
<tr>
<td>404</td>
<td>not found，表示在服务器上没有找到请求的资源</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>5XX</th>
<th>服务器错误</th>
</tr>
</thead>
<tbody>
<tr>
<td>500</td>
<td>internal sever error，表示服务器端在执行请求时发生了错误</td>
</tr>
<tr>
<td>501</td>
<td>Not Implemented，表示服务器不支持当前请求所需要的某个功能</td>
</tr>
<tr>
<td>503</td>
<td>service unavailable，表明服务器暂时处于超负载或正在停机维护，无法处理请求</td>
</tr>
</tbody>
</table>
<blockquote>
<p>7、GET和POST区别</p>
</blockquote>
<p>1、说到GET和POST，就不得不提HTTP协议，因为浏览器和服务器的交互是通过HTTP协议执行的，而GET和POST也是HTTP协议中的			  两种方法。</p>
<p>2、HTTP全称为Hyper Text Transfer Protocol，中文翻译为超文本传输协议，目的是保证浏览器与服务器之间的通信。HTTP的工作方			 式是客户端与服务器之间的请求-应答协议。</p>
<p>3、HTTP协议中定义了浏览器和服务器进行交互的不同方法，基本方法有4种，分别是GET，POST，PUT，DELETE。这四种方法可以理         	          解为，对服务器资源的查，改，增，删。</p>
<ul>
<li>GET：从服务器上获取数据，也就是所谓的查，仅仅是获取服务器资源，不进行修改。</li>
<li>POST：向服务器提交数据，这就涉及到了数据的更新，也就是更改服务器的数据。</li>
<li>PUT：英文含义是放置，也就是向服务器新添加数据，就是所谓的增。</li>
<li>DELETE：从字面意思也能看出，这种方式就是删除服务器数据的过程。</li>
</ul>
<p><strong>GET和POST区别</strong></p>
<ol>
<li>
<p><strong>Get是不安全的</strong>，因为在传输过程，数据被放在请求的URL中；Post的所有操作对用户来说都是不可见的。 但是这种做法也不时绝对的，大部分人的做法也是按照上面的说法来的，但是也可以在get请求加上 request body，给 post请求带上 URL 参数。</p>
</li>
<li>
<p>Get请求提交的url中的数据<strong>最多只能是2048字节</strong>，这个限制是<strong>浏览器或者服务器给添加的</strong>，http协议并没有对url长度进行限制，目的是为了保证服务器和浏览器能够正常运行，防止有人恶意发送请求。POST请求则没有大小限制。</p>
</li>
<li>
<p>Get限制Form表单的数据集的值必须为ASCII字符；而POST支持整个ISO10646字符集。</p>
</li>
<li>
<p>Get执行效率却比POST方法好。Get是Form提交的默认方法。</p>
</li>
<li>
<p>GET产生一个TCP数据包；POST产生两个TCP数据包。</p>
<p>对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；</p>
<p>而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。</p>
</li>
</ol>
<blockquote>
<p>8、什么是对称加密与非对称加密</p>
</blockquote>
<ul>
<li>对称密钥加密是指加密和解密使用同一个密钥的方式，<strong>这种方式存在的最大问题就是密钥发送问题，即如何安全地将密钥发给对方；</strong></li>
<li>而非对称加密是指使用一对非对称密钥，即公钥和私钥，公钥可以随意发布，但私钥只有自己知道。发送密文的一方使用对方的公钥进行加密处理，对方接收到加密信息后，使用自己的私钥进行解密。</li>
<li>由于非对称加密的方式不需要发送用来解密的私钥，所以可以保证安全性；但是和对称加密比起来，非常的慢</li>
</ul>
<blockquote>
<p>9、什么是HTTP2</p>
</blockquote>
<ul>
<li>HTTP2 可以提高了网页的性能。</li>
<li>在 HTTP1 中浏览器限制了同一个域名下的请求数量（Chrome 下一般是六个），当在请求很多资源的时候，由于队头阻塞，此时当浏览器达到最大请求数量，剩余的资源只能等待当前的六个请求完成后才能发起请求。</li>
<li>HTTP2 中引入了<strong>多路复用</strong>的技术，这个技术可以只通过一个 TCP 连接就可以传输所有的请求数据。多路复用可以<strong>绕过浏览器限制同一个域名下的请求数量的问题</strong>，进而提高了网页的性能。</li>
</ul>
<blockquote>
<p>10、Session、Cookie和Token的主要区别</p>
</blockquote>
<p>HTTP协议本身是 <mark>无状态</mark> 的。什么是无状态呢，<mark>即服务器无法判断用户身份。</mark></p>
<p><strong>（1）什么是cookie</strong></p>
<ul>
<li>cookie是<strong>由Web服务器保存在用户浏览器上的小文件（key-value格式）</strong>，包含用户相关的信息。</li>
<li>客户端向服务器发起请求，如果服务器需要记录该用户状态，就使用response向客户端浏览器颁发一个Cookie。</li>
<li>客户端浏览器会把Cookie保存起来。当浏览器再请求该网站时，浏览器把请求的网址连同该Cookie一同提交给服务器。服务器检查该Cookie，以此来辨认用户身份。</li>
</ul>
<p><strong>（2）什么是session</strong></p>
<ul>
<li>session是<strong>依赖Cookie实现</strong>的。session是服务器端对象</li>
<li>session 是浏览器和服务器会话过程中，服务器分配的一块储存空间。服务器默认浏览器在cookie中设置 sessionid，浏览器在向服务器请求过程中传输 cookie 包含 sessionid ，服务器根据 sessionid 获取出会话中存储的信息，然后确定会话的身份信息。</li>
</ul>
<p><strong>（3）cookie与session区别</strong></p>
<ul>
<li>存储位置与安全性：cookie数据存放在客户端上，安全性较差，session数据放在服务器上，安全性相对更高；</li>
<li>存储空间：单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie，session无此限制</li>
<li>占用服务器资源：session一定时间内保存在服务器上，当访问增多，占用服务器性能，考虑到服务器性能方面，应当使用cookie。</li>
</ul>
<p><strong>（4）什么是Token</strong></p>
<ul>
<li>Token的引入：Token是在客户端频繁向服务端请求数据，服务端频繁的去数据库查询用户名和密码并进行对比，判断用户名和密码正确与否，并作出相应提示，在这样的背景下，Token便应运而生。</li>
<li>Token的定义：<strong>Token是服务端生成的一串字符串</strong>，以作客户端进行请求的一个<strong>令牌</strong>，当第一次登录后，服务器生成一个Token便将此Token返回给客户端，以后客户端只需带上这个Token前来请求数据即可，无需再次带上用户名和密码。</li>
<li>使用Token的目的：Token的目的是<strong>为了减轻服务器的压力，减少频繁的查询数据库，使服务器更加健壮。</strong></li>
<li>Token 是在服务端产生的。如果前端使用用户名/密码向服务端请求认证，服务端认证成功，那么在服务端会返回 Token 给前端。前端可以在每次请求的时候带上 Token 证明自己的合法地位</li>
</ul>
<p><strong>（5）session与token区别</strong></p>
<ul>
<li>session机制存在服务器压力增大，CSRF跨站伪造请求攻击，扩展性不强等问题；</li>
<li>session存储在服务器端，token存储在客户端</li>
<li>token提供<strong>认证和授权</strong>功能，作为身份认证，<strong>token安全性比session好</strong>；</li>
<li>session这种会话存储方式方式只适用于客户端代码和服务端代码运行在同一台服务器上，token适用于项目级的前后端分离（前后端代码运行在不同的服务器下）</li>
</ul>
<blockquote>
<p>11、Servlet是线程安全的吗</p>
</blockquote>
<p><strong>Servlet不是线程安全的，多线程并发的读写会导致数据不同步的问题。</strong></p>
<ul>
<li>
<p>解决的办法是尽量不要定义name属性，而是要把name变量分别定义在doGet()和doPost()方法内。</p>
<p>虽然使用synchronized(name){}语句块可以解决问题，但是会造成线程的等待，不是很科学的办法。</p>
</li>
<li>
<p>注意：</p>
<p>1、多线程的并发的读写Servlet类属性会导致数据不同步。</p>
<p>2、但是如果只是并发地读取属性而不写入，则不存在数据不同步的问题。因此Servlet里的只读属性最好定义为final类型的。</p>
</li>
</ul>
<blockquote>
<p>12、Servlet接口中有哪些方法及Servlet生命周期探秘</p>
</blockquote>
<p>在Java Web程序中，<strong>Servlet</strong>主要负责接收用户请求<strong>HttpServletRequest</strong>，在doGet()、doPost()中做相应的处理，并将回应HttpServletResponse反馈给用户。Servlet可以设置初始化参数，供Servlet内部使用。</p>
<p>Servlet接口定义了5个方法，其中<strong>前三个方法与Servlet生命周期相关</strong>：</p>
<ul>
<li>
<p>void <strong>init</strong>(ServletConfig config) throws ServletException</p>
</li>
<li>
<p>void <strong>service</strong>(ServletRequest req, ServletResponse resp) throws ServletException, java.io.IOException</p>
</li>
<li>
<p>void <strong>destory</strong>()</p>
</li>
<li>
<p>java.lang.String <strong>getServletInfo()</strong></p>
</li>
<li>
<p>ServletConfig <strong>getServletConfig()</strong></p>
</li>
</ul>
<p><strong>生命周期：</strong></p>
<ul>
<li>
<p><strong>Web容器加载Servlet并将其实例化后，Servlet生命周期开始</strong>，容器运行其<strong>init()方法</strong>进行Servlet的初始化；</p>
</li>
<li>
<p>请求到达时调用Servlet的<strong>service()方法</strong>，service()方法会根据需要调用与请求对应的<strong>doGet或doPost</strong>等方法；</p>
</li>
<li>
<p>当服务器关闭或项目被卸载时服务器会将Servlet实例销毁，此时会调用Servlet的<strong>destroy()方法</strong>。</p>
</li>
<li>
<p><strong>init方法和destory方法只会执行一次，service方法客户端每次请求Servlet都会执行</strong>。Servlet中有时会用到一些需要初始化与销毁的资源，因此可以把初始化资源的代码放入init方法中，销毁资源的代码放入destroy方法中，这样就不需要每次处理客户端的请求都要初始化与销毁资源。</p>
</li>
</ul>
<blockquote>
<p>13、如果客户端禁止 cookie 能实现 session 还能用吗？</p>
</blockquote>
<p><strong>不能。</strong></p>
<ul>
<li>Cookie 与 Session，一般认为是两个独立的东西，Session采用的是在服务器端保持状态的方案，而Cookie采用的是在客户端保持状态的方案。</li>
<li>但为什么禁用Cookie就不能得到Session呢？因为Session是用Session ID来确定当前对话所对应的服务器Session，而Session ID是通过Cookie来传递的，禁用Cookie相当于失去了Session ID，也就得不到Session了。</li>
</ul>
<p>假定用户关闭Cookie的情况下使用Session，其实现途径有以下几种：</p>
<ol>
<li>手动通过URL传值、隐藏表单传递Session ID。</li>
<li>用文件、数据库等形式保存Session ID，在跨页过程中手动调用。</li>
</ol>
<h3 id="八、并发-2"> 八、并发</h3>
<h3 id="九、jvm-2"> 九、JVM</h3>
<h6 id=""> </h6>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <contributor>
      <name>南辞</name>
    </contributor>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">JavaSE-时间与日期</title>
    <id>http://qiqi.dreamagain.top/program/backend/java/time/</id>
    <link href="http://qiqi.dreamagain.top/program/backend/java/time/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<h2 id="一、基本概念"> 一、基本概念</h2>
<p>在计算机中，我们经常需要处理日期和时间。</p>
<p>这是日期：</p>
<ul>
<li>2019-11-20</li>
<li>2020-1-1</li>
</ul>
<p>这是时间：</p>
<ul>
<li>12:30:59</li>
<li>2020-1-1 20:21:59</li>
</ul>
<p>日期是指某一天，它不是连续变化的，而是应该被看成离散的。</p>
<p>而时间有两种概念，一种是不带日期的时间，例如，12:30:59。另一种是带日期的时间，例如，2020-1-1 20:21:59，只有这种带日期的时间能唯一确定某个时刻，不带日期的时间是无法确定一个唯一时刻的。</p>
<h3 id="一-本地时间"> （一）本地时间</h3>
<p>当我们说当前时刻是2019年11月20日早上8:15的时候，我们说的实际上是本地时间。在国内就是北京时间。在这个时刻，如果地球上不同地方的人们同时看一眼手表，他们各自的本地时间是不同的：</p>
<p><img src="./assets/java-05.png" alt=""></p>
<p>所以，不同的时区，在同一时刻，本地时间是不同的。全球一共分为24个时区，伦敦所在的时区称为标准时区，其他时区按东／西偏移的小时区分，北京所在的时区是东八区。</p>
<h3 id="二-时区"> （二）时区</h3>
<p>因为光靠本地时间还无法唯一确定一个准确的时刻，所以我们还需要给本地时间加上一个时区。时区有好几种表示方式。</p>
<p>一种是以<code>GMT</code>或者<code>UTC</code>加时区偏移表示，例如：<code>GMT+08:00</code>或者<code>UTC+08:00</code>表示东八区。</p>
<p><code>GMT</code>和<code>UTC</code>可以认为基本是等价的，只是<code>UTC</code>使用更精确的原子钟计时，每隔几年会有一个闰秒，我们在开发程序的时候可以忽略两者的误差，因为计算机的时钟在联网的时候会自动与时间服务器同步时间。</p>
<p>另一种是缩写，例如，<code>CST</code>表示<code>China Standard Time</code>，也就是中国标准时间。但是<code>CST</code>也可以表示美国中部时间<code>Central Standard Time USA</code>，因此，缩写容易产生混淆，我们尽量不要使用缩写。</p>
<p>最后一种是以洲／城市表示，例如，<code>Asia/Shanghai</code>，表示上海所在地的时区。特别注意城市名称不是任意的城市，而是由国际标准组织规定的城市。</p>
<p>因为时区的存在，东八区的2019年11月20日早上8:15，和西五区的2019年11月19日晚上19:15，他们的时刻是相同的：</p>
<p><img src="./assets/java-06.png" alt=""></p>
<p>时刻相同的意思就是，分别在两个时区的两个人，如果在这一刻通电话，他们各自报出自己手表上的时间，虽然本地时间是不同的，但是这两个时间表示的时刻是相同的。</p>
<h3 id="三-夏令时"> （三）夏令时</h3>
<p>时区还不是最复杂的，更复杂的是夏令时。所谓夏令时，就是夏天开始的时候，把时间往后拨1小时，夏天结束的时候，再把时间往前拨1小时。我们国家实行过一段时间夏令时，1992年就废除了，但是矫情的美国人到现在还在使用，所以时间换算更加复杂。</p>
<p><img src="./assets/java-07.png" alt=""></p>
<p>因为涉及到夏令时，相同的时区，如果表示的方式不同，转换出的时间是不同的。我们举个栗子：</p>
<p>对于2019-11-20和2019-6-20两个日期来说，假设北京人在纽约：</p>
<ul>
<li>如果以<code>GMT</code>或者<code>UTC</code>作为时区，无论日期是多少，时间都是<code>19:00</code>；</li>
<li>如果以国家／城市表示，例如<code>America／NewYork</code>，虽然纽约也在西五区，但是，因为夏令时的存在，在不同的日期，<code>GMT</code>时间和纽约时间可能是不一样的：</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">时区</th>
<th style="text-align:left">2019-11-20</th>
<th style="text-align:left">2019-6-20</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">GMT-05:00</td>
<td style="text-align:left">19:00</td>
<td style="text-align:left">19:00</td>
</tr>
<tr>
<td style="text-align:left">UTC-05:00</td>
<td style="text-align:left">19:00</td>
<td style="text-align:left">19:00</td>
</tr>
<tr>
<td style="text-align:left">America/New_York</td>
<td style="text-align:left">19:00</td>
<td style="text-align:left">20:00</td>
</tr>
</tbody>
</table>
<p>实行夏令时的不同地区，进入和退出夏令时的时间很可能是不同的。同一个地区，根据历史上是否实行过夏令时，标准时间在不同年份换算成当地时间也是不同的。因此，计算夏令时，没有统一的公式，必须按照一组给定的规则来算，并且，该规则要定期更新。</p>
<p>计算夏令时请使用标准库提供的相关类，不要试图自己计算夏令时。</p>
<h3 id="四-本地化"> （四）本地化</h3>
<p>在计算机中，通常使用<code>Locale</code>表示一个国家或地区的日期、时间、数字、货币等格式。<code>Locale</code>由<code>语言_国家</code>的字母缩写构成，例如，<code>zh_CN</code>表示中文+中国，<code>en_US</code>表示英文+美国。语言使用小写，国家使用大写。</p>
<p>对于日期来说，不同的Locale，例如，中国和美国的表示方式如下：</p>
<ul>
<li>zh_CN：2016-11-30</li>
<li>en_US：11/30/2016</li>
</ul>
<p>计算机用<code>Locale</code>在日期、时间、货币和字符串之间进行转换。一个电商网站会根据用户所在的<code>Locale</code>对用户显示如下：</p>
<table>
<thead>
<tr>
<th style="text-align:left"></th>
<th style="text-align:left">中国用户</th>
<th style="text-align:left">美国用户</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">购买价格</td>
<td style="text-align:left">12000.00</td>
<td style="text-align:left">12,000.00</td>
</tr>
<tr>
<td style="text-align:left">购买日期</td>
<td style="text-align:left">2016-11-30</td>
<td style="text-align:left">11/30/2016</td>
</tr>
</tbody>
</table>
<div><p>小结</p>
<p>在编写日期和时间的程序前，我们要准确理解日期、时间和时刻的概念。</p>
<p>由于存在本地时间，我们需要理解时区的概念，并且必须牢记由于夏令时的存在，同一地区用<code>GMT/UTC</code>和城市表示的时区可能导致时间不同。</p>
<p>计算机通过<code>Locale</code>来针对当地用户习惯格式化日期、时间、数字、货币等。</p>
</div>
<h2 id="二、日期和时间的存储与表示"> 二、日期和时间的存储与表示</h2>
<p><strong>在计算机中，应该如何表示日期和时间呢？</strong></p>
<p>我们经常看到的日期和时间表示方式如下：</p>
<ul>
<li>2019-11-20 0:15:00 GMT+00:00</li>
<li>2019年11月20日8:15:00</li>
<li>11/19/2019 19:15:00 America/New_York</li>
</ul>
<p>如果直接以字符串的形式存储，那么不同的格式，不同的语言会让表示方式非常繁琐。</p>
<p>在理解日期和时间的表示方式之前，我们先要理解数据的存储和展示。</p>
<p>当我们定义一个整型变量并赋值时：</p>
<div><pre><code><span>int</span> n <span>=</span> <span>123400</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div><p>编译器会把上述字符串（程序源码就是一个字符串）编译成字节码。在程序的运行期，变量<code>n</code>指向的内存实际上是一个4字节区域：</p>
<div><pre><code>┌──┬──┬──┬──┐
│00│01│e2│08│
└──┴──┴──┴──┘
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>注意到计算机内存除了二进制的<code>0</code>/<code>1</code>外没有其他任何格式。上述十六进制是为了简化表示。（回顾计算机组成原理）</p>
<p>当我们用<code>System.out.println(n)</code>打印这个整数的时候，实际上<code>println()</code>这个方法在内部把<code>int</code>类型转换成<code>String</code>类型，然后打印出字符串<code>123400</code>。</p>
<p>类似的，我们也可以以十六进制的形式打印这个整数，或者，如果<code>n</code>表示一个价格，我们就以<code>$123,400.00</code>的形式来打印它：</p>
<div><pre><code><span>import</span> <span>java<span>.</span>text<span>.</span></span><span>*</span><span>;</span> 
<span>import</span> <span>java<span>.</span>util<span>.</span></span><span>*</span><span>;</span> 
<span>public</span> <span>class</span> <span>Main</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>int</span> n <span>=</span> <span>123400</span><span>;</span>
        <span>// 123400</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>n<span>)</span><span>;</span>
        <span>// 1e208</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Integer</span><span>.</span><span>toHexString</span><span>(</span>n<span>)</span><span>)</span><span>;</span>
        <span>// $123,400.00</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>NumberFormat</span><span>.</span><span>getCurrencyInstance</span><span>(</span><span>Locale</span><span>.</span>US<span>)</span><span>.</span><span>format</span><span>(</span>n<span>)</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>可见，整数<code>123400</code>是数据的存储格式，它的存储格式非常简单。而我们打印的各种各样的字符串，则是数据的展示格式。展示格式有多种形式，但本质上它就是一个转换方法：</p>
<div><pre><code><span>String</span> <span>toDisplay</span><span>(</span><span>int</span> n<span>)</span> <span>{</span> <span>.</span><span>.</span><span>.</span> <span>}</span>
</code></pre>
<div><span>1</span><br></div></div><p>理解了数据的存储和展示，我们回头看看以下几种日期和时间：</p>
<ul>
<li>2019-11-20 0:15:01 GMT+00:00</li>
<li>2019年11月20日8:15:01</li>
<li>11/19/2019 19:15:01 America/New_York</li>
</ul>
<p>它们实际上是数据的展示格式，分别按英国时区、中国时区、纽约时区对同一个时刻进行展示。而这个“同一个时刻”在计算机中存储的本质上只是一个整数，我们称它为<code>Epoch Time</code>。</p>
<p><code>Epoch Time</code>是计算从1970年1月1日零点（格林威治时区／GMT+00:00）到现在所经历的秒数，例如：</p>
<p><code>1574208900</code>表示从从1970年1月1日零点GMT时区到该时刻一共经历了1574208900秒，换算成伦敦、北京和纽约时间分别是：</p>
<div><pre><code>1574208900 = 北京时间2019-11-20 8:15:00
           = 伦敦时间2019-11-20 0:15:00
           = 纽约时间2019-11-19 19:15:00
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><img src="./assets/java-08.png" alt=""></p>
<p>因此，在计算机中，只需要存储一个整数<code>1574208900</code>表示某一时刻。当需要显示为某一地区的当地时间时，我们就把它格式化为一个字符串：</p>
<div><pre><code>String displayDateTime(int n, String timezone) { ... }
</code></pre>
<div><span>1</span><br></div></div><p><code>Epoch Time</code>又称为 <mark>时间戳</mark> ，在不同的编程语言中，会有几种存储方式：</p>
<ul>
<li>以秒为单位的整数：1574208900，缺点是精度只能到秒；</li>
<li>以毫秒为单位的整数：1574208900123，最后3位表示毫秒数；</li>
<li>以秒为单位的浮点数：1574208900.123，小数点后面表示零点几秒。</li>
</ul>
<p>它们之间转换非常简单。而在Java程序中，时间戳通常是用<code>long</code>表示的毫秒数，即：</p>
<div><pre><code><span>long</span> t <span>=</span> <span>1574208900123L</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div><p>转换成北京时间就是<code>2019-11-20T8:15:00.123</code>。要获取当前时间戳，可以使用<code>System.currentTimeMillis()</code>，这是Java程序获取时间戳最常用的方法。</p>
<h2 id="三、标准库api"> 三、标准库API</h2>
<p>我们再来看一下Java标准库提供的API。Java标准库有两套处理日期和时间的API：</p>
<ul>
<li>一套定义在<code>java.util</code>这个包里面，主要包括<code>Date</code>、<code>Calendar</code>和<code>TimeZone</code>这几个类；</li>
<li>一套新的API是在Java 8引入的，定义在<code>java.time</code>这个包里面，主要包括<code>LocalDateTime</code>、<code>ZonedDateTime</code>、<code>ZoneId</code>等。</li>
</ul>
<p>为什么会有新旧两套API呢？因为历史遗留原因，旧的API存在很多问题，所以引入了新的API。</p>
<p>那么我们能不能跳过旧的API直接用新的API呢？如果涉及到遗留代码就不行，因为很多遗留代码仍然使用旧的API，所以目前仍然需要对旧的API有一定了解，很多时候还需要在新旧两种对象之间进行转换。</p>
<h3 id="一-旧api的常用类型和方法"> （一）旧API的常用类型和方法</h3>
<blockquote>
<h4 id="_1、date"> 1、Date</h4>
</blockquote>
<p><code>java.util.Date</code>是用于表示一个日期和时间的对象，注意与<code>java.sql.Date</code>区分，后者用在数据库中。如果观察Date的源码，可以发现它实际上存储了一个long类型的以毫秒表示的时间戳：</p>
<div><pre><code><span>public</span> <span>class</span> <span>Date</span> <span>implements</span> <span>Serializable</span><span>,</span> <span>Cloneable</span><span>,</span> <span>Comparable</span><span><span>&lt;</span><span>Date</span><span>></span></span> <span>{</span>

    <span>private</span> <span>transient</span> <span>long</span> fastTime<span>;</span>

    <span>.</span><span>.</span><span>.</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>Date的基本用法：</p>
<div><pre><code><span>public</span> <span>class</span> <span>Main</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>// 获取当前时间:</span>
        <span>Date</span> date <span>=</span> <span>new</span> <span>Date</span><span>(</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>date<span>.</span><span>getYear</span><span>(</span><span>)</span> <span>+</span> <span>1900</span><span>)</span><span>;</span> <span>// 必须加上1900</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>date<span>.</span><span>getMonth</span><span>(</span><span>)</span> <span>+</span> <span>1</span><span>)</span><span>;</span> <span>// 0~11，必须加上1</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>date<span>.</span><span>getDate</span><span>(</span><span>)</span><span>)</span><span>;</span> <span>// 1~31，不能加1</span>
        <span>// 转换为String:</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>date<span>.</span><span>toString</span><span>(</span><span>)</span><span>)</span><span>;</span>
        <span>// 转换为GMT时区:</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>date<span>.</span><span>toGMTString</span><span>(</span><span>)</span><span>)</span><span>;</span>
        <span>// 转换为本地时区:</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>date<span>.</span><span>toLocaleString</span><span>(</span><span>)</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><div><p>注意点</p>
<ul>
<li><code>getYear()</code>返回的年份必须加上<code>1900</code>;</li>
<li><code>getMonth()</code>返回的月份是<code>0</code>~<code>11</code>分别表示1~12月，所以要加1;</li>
<li><code>getDate()</code>返回的日期范围是<code>1</code>~<code>31</code>，又不能加1。</li>
</ul>
</div>
<p>打印本地时区表示的日期和时间时，不同的计算机可能会有不同的结果。</p>
<p>如果我们想要针对用户的偏好精确地控制日期和时间的格式，就可以使用<code>SimpleDateFormat</code>对一个<code>Date</code>进行转换。它用预定义的字符串表示格式化：</p>
<ul>
<li>yyyy：年</li>
<li>MM：月</li>
<li>dd: 日</li>
<li>HH: 小时</li>
<li>mm: 分钟</li>
<li>ss: 秒</li>
</ul>
<p>我们来看如何以自定义的格式输出</p>
<div><pre><code><span>public</span> <span>class</span> <span>Main</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>// 获取当前时间:</span>
        <span>Date</span> date <span>=</span> <span>new</span> <span>Date</span><span>(</span><span>)</span><span>;</span>
        <span>var</span> sdf <span>=</span> <span>new</span> <span>SimpleDateFormat</span><span>(</span><span>"yyyy-MM-dd HH:mm:ss"</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>sdf<span>.</span><span>format</span><span>(</span>date<span>)</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
输出结果：
    <span>2020</span><span>-</span><span>02</span><span>-</span><span>10</span> <span>04</span><span>:</span><span>50</span><span>:</span><span>13</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>Java的格式化预定义了许多不同的格式，以<code>MMM</code>和<code>E</code>为例</p>
<div><pre><code><span>public</span> <span>class</span> <span>Main</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>// 获取当前时间:</span>
        <span>Date</span> date <span>=</span> <span>new</span> <span>Date</span><span>(</span><span>)</span><span>;</span>
        <span>var</span> sdf <span>=</span> <span>new</span> <span>SimpleDateFormat</span><span>(</span><span>"E MMM dd, yyyy"</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>sdf<span>.</span><span>format</span><span>(</span>date<span>)</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>上述代码在不同的语言环境会打印出类似<code>Sun Sep 15, 2019</code>这样的日期。可以从<a href="https://docs.oracle.com/en/java/javase/12/docs/api/java.base/java/text/SimpleDateFormat.html" target="_blank" rel="noopener noreferrer">JDK文档</a>查看详细的格式说明。一般来说，字母越长，输出越长。以<code>M</code>为例，假设当前月份是9月：</p>
<ul>
<li><code>M</code>：输出<code>9</code></li>
<li><code>MM</code>：输出<code>09</code></li>
<li><code>MMM</code>：输出<code>Sep</code></li>
<li><code>MMMM</code>：输出<code>September</code></li>
</ul>
<div><p>注意</p>
<p><code>Date</code>对象有几个严重的问题：</p>
<ul>
<li>它不能转换时区，除了<code>toGMTString()</code>可以按<code>GMT+0:00</code>输出外，Date总是以当前计算机系统的默认时区为基础进行输出。</li>
<li>此外，我们也很难对日期和时间进行加减，计算两个日期相差多少天，计算某个月第一个星期一的日期等。</li>
</ul>
</div>
<br/>
<blockquote>
<h4 id="_2、calendar"> 2、Calendar</h4>
</blockquote>
<p><code>Calendar</code>可以用于获取并设置年、月、日、时、分、秒，它和<code>Date</code>比，主要多了一个可以做简单的日期和时间运算的功能。</p>
<p><code>Calendar</code>的基本用法：</p>
<div><pre><code><span>public</span> <span>class</span> <span>Main</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>// 获取当前时间:</span>
        <span>Calendar</span> c <span>=</span> <span>Calendar</span><span>.</span><span>getInstance</span><span>(</span><span>)</span><span>;</span>
        <span>int</span> y <span>=</span> c<span>.</span><span>get</span><span>(</span><span>Calendar</span><span>.</span>YEAR<span>)</span><span>;</span>
        <span>int</span> m <span>=</span> <span>1</span> <span>+</span> c<span>.</span><span>get</span><span>(</span><span>Calendar</span><span>.</span>MONTH<span>)</span><span>;</span>
        <span>int</span> d <span>=</span> c<span>.</span><span>get</span><span>(</span><span>Calendar</span><span>.</span>DAY_OF_MONTH<span>)</span><span>;</span>
        <span>int</span> w <span>=</span> c<span>.</span><span>get</span><span>(</span><span>Calendar</span><span>.</span>DAY_OF_WEEK<span>)</span><span>;</span>
        <span>int</span> hh <span>=</span> c<span>.</span><span>get</span><span>(</span><span>Calendar</span><span>.</span>HOUR_OF_DAY<span>)</span><span>;</span>
        <span>int</span> mm <span>=</span> c<span>.</span><span>get</span><span>(</span><span>Calendar</span><span>.</span>MINUTE<span>)</span><span>;</span>
        <span>int</span> ss <span>=</span> c<span>.</span><span>get</span><span>(</span><span>Calendar</span><span>.</span>SECOND<span>)</span><span>;</span>
        <span>int</span> ms <span>=</span> c<span>.</span><span>get</span><span>(</span><span>Calendar</span><span>.</span>MILLISECOND<span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>y <span>+</span> <span>"-"</span> <span>+</span> m <span>+</span> <span>"-"</span> <span>+</span> d <span>+</span> <span>" "</span> <span>+</span> w <span>+</span> <span>" "</span> <span>+</span> hh <span>+</span> <span>":"</span> <span>+</span> mm <span>+</span> <span>":"</span> <span>+</span> ss <span>+</span> <span>"."</span> <span>+</span> ms<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
运行结果：
    <span>2020</span><span>-</span><span>2</span><span>-</span><span>10</span> <span>4</span> <span>4</span><span>:</span><span>55</span><span>:</span><span>54.418</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><div><p>注意到</p>
<ul>
<li><code>Calendar</code>获取年月日这些信息变成了<code>get(int field)</code>;</li>
<li>返回的年份不必转换，返回的月份仍然要加1;</li>
<li>返回的星期要特别注意，<code>1</code>~<code>7</code>分别表示周日，周一，……，周六。</li>
</ul>
</div>
<p><code>Calendar</code>只有一种方式获取，即<code>Calendar.getInstance()</code>，而且一获取到就是当前时间。如果我们想给它设置成特定的一个日期和时间，就必须先清除所有字段：</p>
<div><pre><code><span>public</span> <span>class</span> <span>Main</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>// 当前时间:</span>
        <span>Calendar</span> c <span>=</span> <span>Calendar</span><span>.</span><span>getInstance</span><span>(</span><span>)</span><span>;</span>
        <span>// 清除所有:</span>
        c<span>.</span><span>clear</span><span>(</span><span>)</span><span>;</span>
        <span>// 设置2019年:</span>
        c<span>.</span><span>set</span><span>(</span><span>Calendar</span><span>.</span>YEAR<span>,</span> <span>2019</span><span>)</span><span>;</span>
        <span>// 设置9月:注意8表示9月:</span>
        c<span>.</span><span>set</span><span>(</span><span>Calendar</span><span>.</span>MONTH<span>,</span> <span>8</span><span>)</span><span>;</span>
        <span>// 设置2日:</span>
        c<span>.</span><span>set</span><span>(</span><span>Calendar</span><span>.</span>DATE<span>,</span> <span>2</span><span>)</span><span>;</span>
        <span>// 设置时间:</span>
        c<span>.</span><span>set</span><span>(</span><span>Calendar</span><span>.</span>HOUR_OF_DAY<span>,</span> <span>21</span><span>)</span><span>;</span>
        c<span>.</span><span>set</span><span>(</span><span>Calendar</span><span>.</span>MINUTE<span>,</span> <span>22</span><span>)</span><span>;</span>
        c<span>.</span><span>set</span><span>(</span><span>Calendar</span><span>.</span>SECOND<span>,</span> <span>23</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>new</span> <span>SimpleDateFormat</span><span>(</span><span>"yyyy-MM-dd HH:mm:ss"</span><span>)</span><span>.</span><span>format</span><span>(</span>c<span>.</span><span>getTime</span><span>(</span><span>)</span><span>)</span><span>)</span><span>;</span>
        <span>// 2019-09-02 21:22:23</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><div><p>提示</p>
<p>利用<code>Calendar.getTime()</code>可以将一个<code>Calendar</code>对象转换成<code>Date</code>对象，然后就可以用<code>SimpleDateFormat</code>进行格式化了。</p>
</div>
<br/>
<blockquote>
<h4 id="_3、timezone"> 3、TimeZone</h4>
</blockquote>
<p><code>Calendar</code>和<code>Date</code>相比，它提供了时区转换的功能。时区用<code>TimeZone</code>对象表示：</p>
<div><pre><code><span>public</span> <span>class</span> <span>Main</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>TimeZone</span> tzDefault <span>=</span> <span>TimeZone</span><span>.</span><span>getDefault</span><span>(</span><span>)</span><span>;</span> <span>// 当前时区</span>
        <span>TimeZone</span> tzGMT9 <span>=</span> <span>TimeZone</span><span>.</span><span>getTimeZone</span><span>(</span><span>"GMT+09:00"</span><span>)</span><span>;</span> <span>// GMT+9:00时区</span>
        <span>TimeZone</span> tzNY <span>=</span> <span>TimeZone</span><span>.</span><span>getTimeZone</span><span>(</span><span>"America/New_York"</span><span>)</span><span>;</span> <span>// 纽约时区</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>tzDefault<span>.</span><span>getID</span><span>(</span><span>)</span><span>)</span><span>;</span> <span>// Etc/UTC</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>tzGMT9<span>.</span><span>getID</span><span>(</span><span>)</span><span>)</span><span>;</span> <span>// GMT+09:00</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>tzNY<span>.</span><span>getID</span><span>(</span><span>)</span><span>)</span><span>;</span> <span>// America/New_York</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>时区的唯一标识是以字符串表示的ID，我们获取指定<code>TimeZone</code>对象也是以这个ID为参数获取，<code>GMT+09:00</code>、<code>Asia/Shanghai</code>都是有效的时区ID。要列出系统支持的所有ID，请使用<code>TimeZone.getAvailableIDs()</code>。</p>
<p>有了时区，我们就可以对指定时间进行转换。</p>
<p>例如，下面的例子演示了如何将北京时间<code>2019-11-20 8:15:00</code>转换为纽约时间：</p>
<div><pre><code><span>public</span> <span>class</span> <span>Main</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>// 当前时间:</span>
        <span>Calendar</span> c <span>=</span> <span>Calendar</span><span>.</span><span>getInstance</span><span>(</span><span>)</span><span>;</span>
        <span>// 清除所有:</span>
        c<span>.</span><span>clear</span><span>(</span><span>)</span><span>;</span>
        <span>// 设置为北京时区:</span>
        c<span>.</span><span>setTimeZone</span><span>(</span><span>TimeZone</span><span>.</span><span>getTimeZone</span><span>(</span><span>"Asia/Shanghai"</span><span>)</span><span>)</span><span>;</span>
        <span>// 设置年月日时分秒:</span>
        c<span>.</span><span>set</span><span>(</span><span>2019</span><span>,</span> <span>10</span> <span>/* 11月 */</span><span>,</span> <span>20</span><span>,</span> <span>8</span><span>,</span> <span>15</span><span>,</span> <span>0</span><span>)</span><span>;</span>
        <span>// 显示时间:</span>
        <span>var</span> sdf <span>=</span> <span>new</span> <span>SimpleDateFormat</span><span>(</span><span>"yyyy-MM-dd HH:mm:ss"</span><span>)</span><span>;</span>
        sdf<span>.</span><span>setTimeZone</span><span>(</span><span>TimeZone</span><span>.</span><span>getTimeZone</span><span>(</span><span>"America/New_York"</span><span>)</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>sdf<span>.</span><span>format</span><span>(</span>c<span>.</span><span>getTime</span><span>(</span><span>)</span><span>)</span><span>)</span><span>;</span> <span>// 利用Calendar.getTime()可以将一个Calendar对象转换成Date对象</span>
       
        <span>// 2019-11-19 19:15:00</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><p>可见，利用<code>Calendar</code>进行时区转换的步骤是：</p>
<ol>
<li>清除所有字段；</li>
<li>设定指定时区；</li>
<li>设定日期和时间；</li>
<li>创建<code>SimpleDateFormat</code>并设定目标时区；</li>
<li>格式化获取的<code>Date</code>对象（注意<code>Date</code>对象无时区信息，时区信息存储在<code>SimpleDateFormat</code>中）。</li>
</ol>
<p>因此，本质上时区转换只能通过<code>SimpleDateFormat</code>在显示的时候完成</p>
<p><code>Calendar</code>也可以对日期和时间进行简单的加减：</p>
<div><pre><code><span>public</span> <span>class</span> <span>Main</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>// 当前时间:</span>
        <span>Calendar</span> c <span>=</span> <span>Calendar</span><span>.</span><span>getInstance</span><span>(</span><span>)</span><span>;</span>
        <span>// 清除所有:</span>
        c<span>.</span><span>clear</span><span>(</span><span>)</span><span>;</span>
        <span>// 设置年月日时分秒:</span>
        c<span>.</span><span>set</span><span>(</span><span>2019</span><span>,</span> <span>10</span> <span>/* 11月 */</span><span>,</span> <span>20</span><span>,</span> <span>8</span><span>,</span> <span>15</span><span>,</span> <span>0</span><span>)</span><span>;</span>
        <span>// 加5天并减去2小时:</span>
        c<span>.</span><span>add</span><span>(</span><span>Calendar</span><span>.</span>DAY_OF_MONTH<span>,</span> <span>5</span><span>)</span><span>;</span>
        c<span>.</span><span>add</span><span>(</span><span>Calendar</span><span>.</span>HOUR_OF_DAY<span>,</span> <span>-</span><span>2</span><span>)</span><span>;</span>
        <span>// 显示时间:</span>
        <span>var</span> sdf <span>=</span> <span>new</span> <span>SimpleDateFormat</span><span>(</span><span>"yyyy-MM-dd HH:mm:ss"</span><span>)</span><span>;</span>
        <span>Date</span> d <span>=</span> c<span>.</span><span>getTime</span><span>(</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>sdf<span>.</span><span>format</span><span>(</span>d<span>)</span><span>)</span><span>;</span>
        <span>// 2019-11-25 6:15:00</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><h3 id="二-新api常用类型和方法"> （二）新API常用类型和方法</h3>
<p>从Java 8开始，<code>java.time</code>包提供了新的日期和时间API，主要涉及的类型有：</p>
<ul>
<li>本地日期和时间：<code>LocalDateTime</code>，<code>LocalDate</code>，<code>LocalTime</code>；</li>
<li>带时区的日期和时间：<code>ZonedDateTime</code>；</li>
<li>时刻：<code>Instant</code>；</li>
<li>时区：<code>ZoneId</code>，<code>ZoneOffset</code>；</li>
<li>时间间隔：<code>Duration</code>。</li>
</ul>
<p>以及一套新的用于取代<code>SimpleDateFormat</code>的格式化类型<code>DateTimeFormatter</code>。</p>
<p>和旧的API相比，新API严格区分了时刻、本地日期、本地时间和带时区的日期时间，并且，对日期和时间进行运算更加方便。</p>
<p>此外，新API修正了旧API不合理的常量设计：</p>
<ul>
<li>Month的范围用1~12表示1月到12月；</li>
<li>Week的范围用1~7表示周一到周日。</li>
</ul>
<p>最后，新API的类型几乎全部是不变类型（和String类似），可以放心使用不必担心被修改</p>
<blockquote>
<h4 id="_1、localdatetime"> 1、LocalDateTime</h4>
</blockquote>
<p>最常用的<code>LocalDateTime</code>，它表示一个本地日期和时间：</p>
<div><pre><code><span>public</span> <span>class</span> <span>Main</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>LocalDate</span> d <span>=</span> <span>LocalDate</span><span>.</span><span>now</span><span>(</span><span>)</span><span>;</span> <span>// 当前日期</span>
        <span>LocalTime</span> t <span>=</span> <span>LocalTime</span><span>.</span><span>now</span><span>(</span><span>)</span><span>;</span> <span>// 当前时间</span>
        <span>LocalDateTime</span> dt <span>=</span> <span>LocalDateTime</span><span>.</span><span>now</span><span>(</span><span>)</span><span>;</span> <span>// 当前日期和时间</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>d<span>)</span><span>;</span> <span>// 严格按照ISO 8601格式打印</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>t<span>)</span><span>;</span> <span>// 严格按照ISO 8601格式打印</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>dt<span>)</span><span>;</span> <span>// 严格按照ISO 8601格式打印</span>
    <span>}</span>
<span>}</span>
打印结果<span>:</span>
<span>2020</span><span>-</span><span>02</span><span>-</span><span>10</span>
<span>05</span><span>:</span><span>26</span><span>:</span><span>43.439104583</span>
<span>2020</span><span>-</span><span>02</span><span>-</span><span>10</span>T05<span>:</span><span>26</span><span>:</span><span>43.439140240</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>本地日期和时间通过now()获取到的总是以当前默认时区返回的，和旧API不同，<code>LocalDateTime</code>、<code>LocalDate</code>和<code>LocalTime</code>默认严格按照<a href="https://www.iso.org/iso-8601-date-and-time-format.html" target="_blank" rel="noopener noreferrer">ISO 8601</a>规定的日期和时间格式进行打印。</p>
<p>上述代码其实有一个小问题，在获取3个类型的时候，由于执行一行代码总会消耗一点时间，因此，3个类型的日期和时间很可能对不上（时间的毫秒数基本上不同）。为了保证获取到同一时刻的日期和时间，可以改写如下：</p>
<div><pre><code><span>LocalDateTime</span> dt <span>=</span> <span>LocalDateTime</span><span>.</span><span>now</span><span>(</span><span>)</span><span>;</span> <span>// 当前日期和时间</span>
<span>LocalDate</span> d <span>=</span> dt<span>.</span><span>toLocalDate</span><span>(</span><span>)</span><span>;</span> <span>// 转换到当前日期</span>
<span>LocalTime</span> t <span>=</span> dt<span>.</span><span>toLocalTime</span><span>(</span><span>)</span><span>;</span> <span>// 转换到当前时间</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>反过来，通过指定的日期和时间创建<code>LocalDateTime</code>可以通过<code>of()</code>方法：</p>
<div><pre><code><span>// 指定日期和时间:</span>
<span>LocalDate</span> d2 <span>=</span> <span>LocalDate</span><span>.</span><span>of</span><span>(</span><span>2019</span><span>,</span> <span>11</span><span>,</span> <span>30</span><span>)</span><span>;</span> <span>// 2019-11-30, 注意11=11月</span>
<span>LocalTime</span> t2 <span>=</span> <span>LocalTime</span><span>.</span><span>of</span><span>(</span><span>15</span><span>,</span> <span>16</span><span>,</span> <span>17</span><span>)</span><span>;</span> <span>// 15:16:17</span>
<span>LocalDateTime</span> dt2 <span>=</span> <span>LocalDateTime</span><span>.</span><span>of</span><span>(</span><span>2019</span><span>,</span> <span>11</span><span>,</span> <span>30</span><span>,</span> <span>15</span><span>,</span> <span>16</span><span>,</span> <span>17</span><span>)</span><span>;</span>
<span>LocalDateTime</span> dt3 <span>=</span> <span>LocalDateTime</span><span>.</span><span>of</span><span>(</span>d2<span>,</span> t2<span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>因为严格按照ISO 8601的格式，因此，将字符串转换为<code>LocalDateTime</code>就可以传入标准格式：</p>
<div><pre><code><span>LocalDateTime</span> dt <span>=</span> <span>LocalDateTime</span><span>.</span><span>parse</span><span>(</span><span>"2019-11-19T15:16:17"</span><span>)</span><span>;</span>
<span>LocalDate</span> d <span>=</span> <span>LocalDate</span><span>.</span><span>parse</span><span>(</span><span>"2019-11-19"</span><span>)</span><span>;</span>
<span>LocalTime</span> t <span>=</span> <span>LocalTime</span><span>.</span><span>parse</span><span>(</span><span>"15:16:17"</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>注意ISO 8601规定的日期和时间分隔符是<code>T</code>。标准格式如下：</p>
<ul>
<li>日期：yyyy-MM-dd</li>
<li>时间：HH:mm:ss</li>
<li>带毫秒的时间：HH:mm:ss.SSS</li>
<li>日期和时间：yyyy-MM-dd'T'HH:mm:ss</li>
<li>带毫秒的日期和时间：yyyy-MM-dd'T'HH:mm:ss.SSS</li>
</ul>
<p><strong>日期和时间的加减</strong></p>
<p><code>LocalDateTime</code>提供了对日期和时间进行加减的非常简单的链式调用：</p>
<div><pre><code><span>public</span> <span>class</span> <span>Main</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>LocalDateTime</span> dt <span>=</span> <span>LocalDateTime</span><span>.</span><span>of</span><span>(</span><span>2019</span><span>,</span> <span>10</span><span>,</span> <span>26</span><span>,</span> <span>20</span><span>,</span> <span>30</span><span>,</span> <span>59</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>dt<span>)</span><span>;</span>
        <span>// 加5天减3小时:</span>
        <span>LocalDateTime</span> dt2 <span>=</span> dt<span>.</span><span>plusDays</span><span>(</span><span>5</span><span>)</span><span>.</span><span>minusHours</span><span>(</span><span>3</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>dt2<span>)</span><span>;</span> <span>// 2019-10-31T17:30:59</span>
        <span>// 减1月:</span>
        <span>LocalDateTime</span> dt3 <span>=</span> dt2<span>.</span><span>minusMonths</span><span>(</span><span>1</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>dt3<span>)</span><span>;</span> <span>// 2019-09-30T17:30:59</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>注意到月份加减会自动调整日期，例如从<code>2019-10-31</code>减去1个月得到的结果是<code>2019-09-30</code>，因为9月没有31日。</p>
<p><strong>日期和时间的调整</strong></p>
<p>对日期和时间进行调整则使用<code>withXxx()</code>方法，例如：<code>withHour(15)</code>会把<code>10:11:12</code>变为<code>15:11:12</code>：</p>
<ul>
<li>调整年：withYear()</li>
<li>调整月：withMonth()</li>
<li>调整日：withDayOfMonth()</li>
<li>调整时：withHour()</li>
<li>调整分：withMinute()</li>
<li>调整秒：withSecond()</li>
</ul>
<div><pre><code><span>public</span> <span>class</span> <span>Main</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>LocalDateTime</span> dt <span>=</span> <span>LocalDateTime</span><span>.</span><span>of</span><span>(</span><span>2019</span><span>,</span> <span>10</span><span>,</span> <span>26</span><span>,</span> <span>20</span><span>,</span> <span>30</span><span>,</span> <span>59</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>dt<span>)</span><span>;</span>
        <span>// 日期变为31日:</span>
        <span>LocalDateTime</span> dt2 <span>=</span> dt<span>.</span><span>withDayOfMonth</span><span>(</span><span>31</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>dt2<span>)</span><span>;</span> <span>// 2019-10-31T20:30:59</span>
        <span>// 月份变为9:</span>
        <span>LocalDateTime</span> dt3 <span>=</span> dt2<span>.</span><span>withMonth</span><span>(</span><span>9</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>dt3<span>)</span><span>;</span> <span>// 2019-09-30T20:30:59</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>同样注意到调整月份时，会相应地调整日期，即把<code>2019-10-31</code>的月份调整为<code>9</code>时，日期也自动变为<code>30</code>。</p>
<p>实际上，<code>LocalDateTime</code>还有一个通用的<code>with()</code>方法允许我们做更复杂的运算。例如：</p>
<div><pre><code><span>public</span> <span>class</span> <span>Main</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>// 本月第一天0:00时刻:</span>
        <span>LocalDateTime</span> firstDay <span>=</span> <span>LocalDate</span><span>.</span><span>now</span><span>(</span><span>)</span><span>.</span><span>withDayOfMonth</span><span>(</span><span>1</span><span>)</span><span>.</span><span>atStartOfDay</span><span>(</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>firstDay<span>)</span><span>;</span>

        <span>// 本月最后1天:</span>
        <span>LocalDate</span> lastDay <span>=</span> <span>LocalDate</span><span>.</span><span>now</span><span>(</span><span>)</span><span>.</span><span>with</span><span>(</span><span>TemporalAdjusters</span><span>.</span><span>lastDayOfMonth</span><span>(</span><span>)</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>lastDay<span>)</span><span>;</span>

        <span>// 下月第1天:</span>
        <span>LocalDate</span> nextMonthFirstDay <span>=</span> <span>LocalDate</span><span>.</span><span>now</span><span>(</span><span>)</span><span>.</span><span>with</span><span>(</span><span>TemporalAdjusters</span><span>.</span><span>firstDayOfNextMonth</span><span>(</span><span>)</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>nextMonthFirstDay<span>)</span><span>;</span>

        <span>// 本月第1个周一:</span>
        <span>LocalDate</span> firstWeekday <span>=</span> <span>LocalDate</span><span>.</span><span>now</span><span>(</span><span>)</span><span>.</span><span>with</span><span>(</span><span>TemporalAdjusters</span><span>.</span><span>firstInMonth</span><span>(</span><span>DayOfWeek</span><span>.</span>MONDAY<span>)</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>firstWeekday<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><p>对于计算某个月第1个周日这样的问题，新的API可以轻松完成。</p>
<p>要判断两个<code>LocalDateTime</code>的先后，可以使用<code>isBefore()</code>、<code>isAfter()</code>方法，对于<code>LocalDate</code>和<code>LocalTime</code>类似：</p>
<div><pre><code><span>public</span> <span>class</span> <span>Main</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>LocalDateTime</span> now <span>=</span> <span>LocalDateTime</span><span>.</span><span>now</span><span>(</span><span>)</span><span>;</span>
        <span>LocalDateTime</span> target <span>=</span> <span>LocalDateTime</span><span>.</span><span>of</span><span>(</span><span>2019</span><span>,</span> <span>11</span><span>,</span> <span>19</span><span>,</span> <span>8</span><span>,</span> <span>15</span><span>,</span> <span>0</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>now<span>.</span><span>isBefore</span><span>(</span>target<span>)</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>LocalDate</span><span>.</span><span>now</span><span>(</span><span>)</span><span>.</span><span>isBefore</span><span>(</span><span>LocalDate</span><span>.</span><span>of</span><span>(</span><span>2019</span><span>,</span> <span>11</span><span>,</span> <span>19</span><span>)</span><span>)</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>LocalTime</span><span>.</span><span>now</span><span>(</span><span>)</span><span>.</span><span>isAfter</span><span>(</span><span>LocalTime</span><span>.</span><span>parse</span><span>(</span><span>"08:15:00"</span><span>)</span><span>)</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><div><p>提示</p>
<p>注意到<code>LocalDateTime</code>无法与时间戳进行转换，因为<code>LocalDateTime</code>没有时区，无法确定某一时刻。</p>
<p>后面要介绍的<code>ZonedDateTime</code>相当于<code>LocalDateTime</code>加时区的组合，它具有时区，可以与<code>long</code>表示的时间戳进行转换。</p>
</div>
<p><strong>自定义格式</strong></p>
<p>如果要自定义输出的格式，或者要把一个非ISO 8601格式的字符串解析成<code>LocalDateTime</code>，可以使用新的<code>DateTimeFormatter</code>：</p>
<div><pre><code><span>public</span> <span>class</span> <span>Main</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>// 自定义格式化:</span>
        <span>DateTimeFormatter</span> dtf <span>=</span> <span>DateTimeFormatter</span><span>.</span><span>ofPattern</span><span>(</span><span>"yyyy/MM/dd HH:mm:ss"</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>dtf<span>.</span><span>format</span><span>(</span><span>LocalDateTime</span><span>.</span><span>now</span><span>(</span><span>)</span><span>)</span><span>)</span><span>;</span>

        <span>// 用自定义格式解析成ISO 8601格式:</span>
        <span>LocalDateTime</span> dt2 <span>=</span> <span>LocalDateTime</span><span>.</span><span>parse</span><span>(</span><span>"2019/11/30 15:16:17"</span><span>,</span> dtf<span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>dt2<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
运行结果<span>:</span>
<span>2020</span><span>/</span><span>02</span><span>/</span><span>10</span> <span>05</span><span>:</span><span>31</span><span>:</span><span>57</span>
<span>2019</span><span>-</span><span>11</span><span>-</span><span>30</span>T15<span>:</span><span>16</span><span>:</span><span>17</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><br/>
<blockquote>
<h4 id="_2、duration和period"> 2、Duration和Period</h4>
</blockquote>
<p><code>Duration</code>表示两个时刻之间的时间间隔。另一个类似的<code>Period</code>表示两个日期之间的天数：</p>
<div><pre><code><span>public</span> <span>class</span> <span>Main</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>LocalDateTime</span> start <span>=</span> <span>LocalDateTime</span><span>.</span><span>of</span><span>(</span><span>2019</span><span>,</span> <span>11</span><span>,</span> <span>19</span><span>,</span> <span>8</span><span>,</span> <span>15</span><span>,</span> <span>0</span><span>)</span><span>;</span>
        <span>LocalDateTime</span> end <span>=</span> <span>LocalDateTime</span><span>.</span><span>of</span><span>(</span><span>2020</span><span>,</span> <span>1</span><span>,</span> <span>9</span><span>,</span> <span>19</span><span>,</span> <span>25</span><span>,</span> <span>30</span><span>)</span><span>;</span>
        <span>Duration</span> d <span>=</span> <span>Duration</span><span>.</span><span>between</span><span>(</span>start<span>,</span> end<span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>d<span>)</span><span>;</span> <span>// PT1235H10M30S</span>

        <span>Period</span> p <span>=</span> <span>LocalDate</span><span>.</span><span>of</span><span>(</span><span>2019</span><span>,</span> <span>11</span><span>,</span> <span>19</span><span>)</span><span>.</span><span>until</span><span>(</span><span>LocalDate</span><span>.</span><span>of</span><span>(</span><span>2020</span><span>,</span> <span>1</span><span>,</span> <span>9</span><span>)</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>p<span>)</span><span>;</span> <span>// P1M21D</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><ul>
<li>注意到两个<code>LocalDateTime</code>之间的差值使用<code>Duration</code>表示，类似<code>PT1235H10M30S</code>，表示1235小时10分钟30秒。</li>
<li>而两个<code>LocalDate</code>之间的差值用<code>Period</code>表示，类似<code>P1M21D</code>，表示1个月21天。</li>
</ul>
<p><code>Duration</code>和<code>Period</code>的表示方法也符合ISO 8601的格式，它以<code>P...T...</code>的形式表示，<code>P...T</code>之间表示日期间隔，<code>T</code>后面表示时间间隔。如果是<code>PT...</code>的格式表示仅有时间间隔。利用<code>ofXxx()</code>或者<code>parse()</code>方法也可以直接创建<code>Duration</code>：</p>
<div><pre><code><span>Duration</span> d1 <span>=</span> <span>Duration</span><span>.</span><span>ofHours</span><span>(</span><span>10</span><span>)</span><span>;</span> <span>// 10 hours</span>
<span>Duration</span> d2 <span>=</span> <span>Duration</span><span>.</span><span>parse</span><span>(</span><span>"P1DT2H3M"</span><span>)</span><span>;</span> <span>// 1 day, 2 hours, 3 minutes</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>有的童鞋可能发现Java 8引入的<code>java.time</code>API。怎么和一个开源的<a href="https://www.joda.org/" target="_blank" rel="noopener noreferrer">Joda Time</a>很像？难道JDK也开始抄袭开源了？其实正是因为开源的Joda Time设计很好，应用广泛，所以JDK团队邀请Joda Time的作者Stephen Colebourne共同设计了<code>java.time</code>API。</p>
<br/>
<blockquote>
<h4 id="_3、zoneddatetime"> 3、ZonedDateTime</h4>
</blockquote>
<p><code>LocalDateTime</code>总是表示本地日期和时间，要表示一个带时区的日期和时间，我们就需要<code>ZonedDateTime</code>。</p>
<p>可以简单地把<code>ZonedDateTime</code>理解成<code>LocalDateTime</code>加<code>ZoneId</code>。<code>ZoneId</code>是<code>java.time</code>引入的新的时区类，注意和旧的<code>java.util.TimeZone</code>区别。</p>
<p>要创建一个<code>ZonedDateTime</code>对象，有以下几种方法，一种是通过<code>now()</code>方法返回当前时间：</p>
<div><pre><code><span>public</span> <span>class</span> <span>Main</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>ZonedDateTime</span> zbj <span>=</span> <span>ZonedDateTime</span><span>.</span><span>now</span><span>(</span><span>)</span><span>;</span> <span>// 默认时区</span>
        <span>ZonedDateTime</span> zny <span>=</span> <span>ZonedDateTime</span><span>.</span><span>now</span><span>(</span><span>ZoneId</span><span>.</span><span>of</span><span>(</span><span>"America/New_York"</span><span>)</span><span>)</span><span>;</span> <span>// 用指定时区获取当前时间</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>zbj<span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>zny<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>观察打印的两个<code>ZonedDateTime</code>，发现它们时区不同，但表示的时间都是同一时刻（毫秒数不同是执行语句时的时间差）：</p>
<div><pre><code>2019-09-15T20:58:18.786182+08:00[Asia/Shanghai]
2019-09-15T08:58:18.788860-04:00[America/New_York]
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>另一种方式是通过给一个<code>LocalDateTime</code>附加一个<code>ZoneId</code>，就可以变成<code>ZonedDateTime</code>：</p>
<div><pre><code><span>public</span> <span>class</span> <span>Main</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>LocalDateTime</span> ldt <span>=</span> <span>LocalDateTime</span><span>.</span><span>of</span><span>(</span><span>2019</span><span>,</span> <span>9</span><span>,</span> <span>15</span><span>,</span> <span>15</span><span>,</span> <span>16</span><span>,</span> <span>17</span><span>)</span><span>;</span>
        <span>ZonedDateTime</span> zbj <span>=</span> ldt<span>.</span><span>atZone</span><span>(</span><span>ZoneId</span><span>.</span><span>systemDefault</span><span>(</span><span>)</span><span>)</span><span>;</span>
        <span>ZonedDateTime</span> zny <span>=</span> ldt<span>.</span><span>atZone</span><span>(</span><span>ZoneId</span><span>.</span><span>of</span><span>(</span><span>"America/New_York"</span><span>)</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>zbj<span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>zny<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>以这种方式创建的<code>ZonedDateTime</code>，它的日期和时间与<code>LocalDateTime</code>相同，但附加的时区不同，因此是两个不同的时刻：</p>
<div><pre><code>2019-09-15T15:16:17+08:00[Asia/Shanghai]
2019-09-15T15:16:17-04:00[America/New_York]
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><strong>时区转换</strong></p>
<p>要转换时区，首先我们需要有一个<code>ZonedDateTime</code>对象，然后，通过<code>withZoneSameInstant()</code>将关联时区转换到另一个时区，转换后日期和时间都会相应调整。</p>
<p>下面的代码演示了如何将北京时间转换为纽约时间：</p>
<div><pre><code><span>public</span> <span>class</span> <span>Main</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>// 以中国时区获取当前时间:</span>
        <span>ZonedDateTime</span> zbj <span>=</span> <span>ZonedDateTime</span><span>.</span><span>now</span><span>(</span><span>ZoneId</span><span>.</span><span>of</span><span>(</span><span>"Asia/Shanghai"</span><span>)</span><span>)</span><span>;</span>
        <span>// 转换为纽约时间:</span>
        <span>ZonedDateTime</span> zny <span>=</span> zbj<span>.</span><span>withZoneSameInstant</span><span>(</span><span>ZoneId</span><span>.</span><span>of</span><span>(</span><span>"America/New_York"</span><span>)</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>zbj<span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>zny<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>要特别注意，时区转换的时候，由于夏令时的存在，不同的日期转换的结果很可能是不同的。这是北京时间9月15日的转换结果：</p>
<div><pre><code>2019-09-15T21:05:50.187697+08:00[Asia/Shanghai]
2019-09-15T09:05:50.187697-04:00[America/New_York]
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>这是北京时间11月15日的转换结果：</p>
<div><pre><code>2019-11-15T21:05:50.187697+08:00[Asia/Shanghai]
2019-11-15T08:05:50.187697-05:00[America/New_York]
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>两次转换后的纽约时间有1小时的夏令时时差。</p>
<p>涉及到时区时，千万不要自己计算时差，否则难以正确处理夏令时。</p>
<p>有了<code>ZonedDateTime</code>，将其转换为本地时间就非常简单：</p>
<div><pre><code>ZonedDateTime zdt = ...
LocalDateTime ldt = zdt.toLocalDateTime();
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>转换为<code>LocalDateTime</code>时，直接丢弃了时区信息。</p>
<blockquote>
<h4 id="_4、datetimeformatter"> 4、DateTimeFormatter</h4>
</blockquote>
<p>使用旧的<code>Date</code>对象时，我们用<code>SimpleDateFormat</code>进行格式化显示。使用新的<code>LocalDateTime</code>或<code>ZonedLocalDateTime</code>时，我们要进行格式化显示，就要使用<code>DateTimeFormatter</code>。</p>
<p>和<code>SimpleDateFormat</code>不同的是，<code>DateTimeFormatter</code>不但是不变对象，它还是线程安全的。因为<code>SimpleDateFormat</code>不是线程安全的，使用的时候，只能在方法内部创建新的局部变量。而<code>DateTimeFormatter</code>可以只创建一个实例，到处引用。</p>
<p>创建<code>DateTimeFormatter</code>时，我们仍然通过传入格式化字符串实现：</p>
<div><pre><code><span>DateTimeFormatter</span> formatter <span>=</span> <span>DateTimeFormatter</span><span>.</span><span>ofPattern</span><span>(</span><span>"yyyy-MM-dd HH:mm"</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div><p>格式化字符串的使用方式与<code>SimpleDateFormat</code>完全一致。</p>
<p>另一种创建<code>DateTimeFormatter</code>的方法是，传入格式化字符串时，同时指定<code>Locale</code>：</p>
<div><pre><code><span>DateTimeFormatter</span> formatter <span>=</span> <span>DateTimeFormatter</span><span>.</span><span>ofPattern</span><span>(</span><span>"E, yyyy-MMMM-dd HH:mm"</span><span>,</span> <span>Locale</span><span>.</span>US<span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div><p>这种方式可以按照<code>Locale</code>默认习惯格式化。我们来看实际效果：</p>
<div><pre><code><span>public</span> <span>class</span> <span>Main</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>ZonedDateTime</span> zdt <span>=</span> <span>ZonedDateTime</span><span>.</span><span>now</span><span>(</span><span>)</span><span>;</span>
        <span>var</span> formatter <span>=</span> <span>DateTimeFormatter</span><span>.</span><span>ofPattern</span><span>(</span><span>"yyyy-MM-dd'T'HH:mm ZZZZ"</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>formatter<span>.</span><span>format</span><span>(</span>zdt<span>)</span><span>)</span><span>;</span>

        <span>var</span> zhFormatter <span>=</span> <span>DateTimeFormatter</span><span>.</span><span>ofPattern</span><span>(</span><span>"yyyy MMM dd EE HH:mm"</span><span>,</span> <span>Locale</span><span>.</span>CHINA<span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>zhFormatter<span>.</span><span>format</span><span>(</span>zdt<span>)</span><span>)</span><span>;</span>

        <span>var</span> usFormatter <span>=</span> <span>DateTimeFormatter</span><span>.</span><span>ofPattern</span><span>(</span><span>"E, MMMM/dd/yyyy HH:mm"</span><span>,</span> <span>Locale</span><span>.</span>US<span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>usFormatter<span>.</span><span>format</span><span>(</span>zdt<span>)</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>在格式化字符串中，如果需要输出固定字符，可以用<code>'xxx'</code>表示。</p>
<p>运行上述代码，分别以默认方式、中国地区和美国地区对当前时间进行显示，结果如下：</p>
<div><pre><code>2019-09-15T23:16 GMT+08:00
2019 9月 15 周日 23:16
Sun, September/15/2019 23:16
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>当我们直接调用<code>System.out.println()</code>对一个<code>ZonedDateTime</code>或者<code>LocalDateTime</code>实例进行打印的时候，实际上，调用的是它们的<code>toString()</code>方法，默认的<code>toString()</code>方法显示的字符串就是按照<code>ISO 8601</code>格式显示的，我们可以通过<code>DateTimeFormatter</code>预定义的几个静态变量来引用：</p>
<div><pre><code>var ldt = LocalDateTime.now();
System.out.println(DateTimeFormatter.ISO_DATE.format(ldt));
System.out.println(DateTimeFormatter.ISO_DATE_TIME.format(ldt));
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>得到的输出和<code>toString()</code>类似：</p>
<div><pre><code>2019-09-15
2019-09-15T23:16:51.56217
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><br/>
<blockquote>
<h4 id="_5、instant"> 5、Instant</h4>
</blockquote>
<p>我们已经讲过，计算机存储的当前时间，本质上只是一个不断递增的整数。Java提供的<code>System.currentTimeMillis()</code>返回的就是以毫秒表示的当前时间戳。</p>
<p>这个当前时间戳在<code>java.time</code>中以<code>Instant</code>类型表示，我们用<code>Instant.now()</code>获取当前时间戳，效果和<code>System.currentTimeMillis()</code>类似：</p>
<div><pre><code><span>public</span> <span>class</span> <span>Main</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>Instant</span> now <span>=</span> <span>Instant</span><span>.</span><span>now</span><span>(</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>now<span>.</span><span>getEpochSecond</span><span>(</span><span>)</span><span>)</span><span>;</span> <span>// 秒</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>now<span>.</span><span>toEpochMilli</span><span>(</span><span>)</span><span>)</span><span>;</span> <span>// 毫秒</span>
    <span>}</span>
<span>}</span>
打印的结果类似：
<span>1568568760</span>
<span>1568568760316</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>实际上，<code>Instant</code>内部只有两个核心字段：</p>
<div><pre><code>public final class Instant implements ... {
    private final long seconds;
    private final int nanos;
}
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>一个是以秒为单位的时间戳，一个是更精确的纳秒精度。它和<code>System.currentTimeMillis()</code>返回的<code>long</code>相比，只是多了更高精度的纳秒。</p>
<p>既然<code>Instant</code>就是时间戳，那么，给它附加上一个时区，就可以创建出<code>ZonedDateTime</code>：</p>
<div><pre><code><span>// 以指定时间戳创建Instant:</span>
<span>Instant</span> ins <span>=</span> <span>Instant</span><span>.</span><span>ofEpochSecond</span><span>(</span><span>1568568760</span><span>)</span><span>;</span>
<span>ZonedDateTime</span> zdt <span>=</span> ins<span>.</span><span>atZone</span><span>(</span><span>ZoneId</span><span>.</span><span>systemDefault</span><span>(</span><span>)</span><span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>zdt<span>)</span><span>;</span> <span>// 2019-09-16T01:32:40+08:00[Asia/Shanghai]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>可见，对于某一个时间戳，给它关联上指定的<code>ZoneId</code>，就得到了<code>ZonedDateTime</code>，继而可以获得了对应时区的<code>LocalDateTime</code>。</p>
<p>所以，<code>LocalDateTime</code>，<code>ZoneId</code>，<code>Instant</code>，<code>ZonedDateTime</code>和<code>long</code>都可以互相转换：</p>
<div><pre><code>┌─────────────┐
│LocalDateTime│────┐
└─────────────┘    │    ┌─────────────┐
                   ├───&gt;│ZonedDateTime│
┌─────────────┐    │    └─────────────┘
│   ZoneId    │────┘           ▲
└─────────────┘      ┌─────────┴─────────┐
                     │                   │
                     ▼                   ▼
              ┌─────────────┐     ┌─────────────┐
              │   Instant   │&lt;───&gt;│    long     │
              └─────────────┘     └─────────────┘
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>转换的时候，只需要留意<code>long</code>类型以毫秒还是秒为单位即可。</p>
<h3 id="三-旧api-──-新api"> （三）旧API&lt;──&gt;新API</h3>
<p>由于Java提供了新旧两套日期和时间的API，除非涉及到遗留代码，否则我们应该坚持使用新的API。</p>
<p>如果需要与遗留代码打交道，如何在新旧API之间互相转换呢？</p>
<blockquote>
<h4 id="_1、旧api转新api"> 1、旧API转新API</h4>
</blockquote>
<p>如果要把旧式的<code>Date</code>或<code>Calendar</code>转换为新API对象，可以通过<code>toInstant()</code>方法转换为<code>Instant</code>对象，再继续转换为<code>ZonedDateTime</code>：</p>
<div><pre><code><span>// Date -> Instant:</span>
<span>Instant</span> ins1 <span>=</span> <span>new</span> <span>Date</span><span>(</span><span>)</span><span>.</span><span>toInstant</span><span>(</span><span>)</span><span>;</span>

<span>// Calendar -> Instant -> ZonedDateTime:</span>
<span>Calendar</span> calendar <span>=</span> <span>Calendar</span><span>.</span><span>getInstance</span><span>(</span><span>)</span><span>;</span>
<span>Instant</span> ins2 <span>=</span> calendar<span>.</span><span>toInstant</span><span>(</span><span>)</span><span>;</span>
<span>ZonedDateTime</span> zdt <span>=</span> ins2<span>.</span><span>atZone</span><span>(</span>calendar<span>.</span><span>getTimeZone</span><span>(</span><span>)</span><span>.</span><span>toZoneId</span><span>(</span><span>)</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>从上面的代码还可以看到，旧的<code>TimeZone</code>提供了一个<code>toZoneId()</code>，可以把自己变成新的<code>ZoneId</code>。</p>
<br/>
<blockquote>
<h4 id="_2、新api转旧api"> 2、新API转旧API</h4>
</blockquote>
<p>如果要把新的<code>ZonedDateTime</code>转换为旧的API对象，只能借助<code>long</code>型时间戳做一个“中转”：</p>
<div><pre><code>// ZonedDateTime -&gt; long:
ZonedDateTime zdt = ZonedDateTime.now();
long ts = zdt.toEpochSecond() * 1000;

// long -&gt; Date:
Date date = new Date(ts);

// long -&gt; Calendar:
Calendar calendar = Calendar.getInstance();
calendar.clear();
calendar.setTimeZone(TimeZone.getTimeZone(zdt.getZone().getId()));
calendar.setTimeInMillis(zdt.toEpochSecond() * 1000);
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>从上面的代码还可以看到，新的<code>ZoneId</code>转换为旧的<code>TimeZone</code>，需要借助<code>ZoneId.getId()</code>返回的<code>String</code>完成。</p>
<br/>
<blockquote>
<h4 id="_3、在数据库中存储日期和时间"> 3、在数据库中存储日期和时间</h4>
</blockquote>
<p>除了旧式的<code>java.util.Date</code>，我们还可以找到另一个<code>java.sql.Date</code>，它继承自<code>java.util.Date</code>，但会自动忽略所有时间相关信息,仅保留日期。这个奇葩的设计原因要追溯到数据库的日期与时间类型。</p>
<p>在数据库中，也存在几种日期和时间类型：</p>
<ul>
<li><code>DATETIME</code>：表示日期和时间；</li>
<li><code>DATE</code>：仅表示日期；</li>
<li><code>TIME</code>：仅表示时间；</li>
<li><code>TIMESTAMP</code>：和<code>DATETIME</code>类似，但是数据库会在创建或者更新记录的时候同时修改<code>TIMESTAMP</code>。</li>
</ul>
<p>在使用Java程序操作数据库时，我们需要把数据库类型与Java类型映射起来。下表是数据库类型与Java新旧API的映射关系：</p>
<table>
<thead>
<tr>
<th style="text-align:left">数据库</th>
<th style="text-align:left">对应Java类（旧）</th>
<th style="text-align:left">对应Java类（新）</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">DATETIME</td>
<td style="text-align:left">java.util.Date</td>
<td style="text-align:left">LocalDateTime</td>
</tr>
<tr>
<td style="text-align:left">DATE</td>
<td style="text-align:left">java.sql.Date</td>
<td style="text-align:left">LocalDate</td>
</tr>
<tr>
<td style="text-align:left">TIME</td>
<td style="text-align:left">java.sql.Time</td>
<td style="text-align:left">LocalTime</td>
</tr>
<tr>
<td style="text-align:left">TIMESTAMP</td>
<td style="text-align:left">java.sql.Timestamp</td>
<td style="text-align:left">LocalDateTime</td>
</tr>
</tbody>
</table>
<p>实际上，在数据库中，我们需要存储的最常用的是时刻（<code>Instant</code>），因为有了时刻信息，就可以根据用户自己选择的时区，显示出正确的本地时间。所以，最好的方法是直接用长整数<code>long</code>表示，在数据库中存储为<code>BIGINT</code>类型。</p>
<p>通过存储一个<code>long</code>型时间戳，我们可以编写一个<code>timestampToString()</code>的方法，非常简单地为不同用户以不同的偏好来显示不同的本地时间：</p>
<h2 id="总结"> 总结</h2>
<p><strong>基本概念:</strong></p>
<ul>
<li>在编写日期和时间的程序前，我们要准确理解日期、时间和时刻的概念</li>
<li>由于存在本地时间，我们需要理解时区的概念，并且必须牢记由于夏令时的存在，同一地区用<code>GMT/UTC</code>和城市表示的时区可能导致时间不同</li>
<li>计算机通过<code>Locale</code>来针对当地用户习惯格式化日期、时间、数字、货币等</li>
</ul>
<p><strong>存储和表示：</strong></p>
<ul>
<li>
<p>计算机表示的时间是以整数表示的时间戳存储的，即<code>Epoch Time</code></p>
</li>
<li>
<p>Java使用<code>long</code>型来表示以毫秒为单位的时间戳，可以通过<code>System.currentTimeMillis()</code>获取当前时间戳</p>
</li>
<li>
<p>Java有两套日期和时间的API：</p>
<ul>
<li>
<p>旧的Date、Calendar和TimeZone；</p>
</li>
<li>
<p>新的LocalDateTime、ZonedDateTime、ZoneId等</p>
</li>
</ul>
<p>分别位于<code>java.util</code>和<code>java.time</code>包中</p>
</li>
</ul>
<p><strong>标准库API：</strong></p>
<ul>
<li>
<p>Java 8引入了新的日期和时间API，它们是不变类，默认按ISO 8601标准格式化和解析</p>
</li>
<li>
<p>使用<code>LocalDateTime</code>可以非常方便地对日期和时间进行加减，或者调整日期和时间，它总是返回新对象</p>
</li>
<li>
<p>使用<code>isBefore()</code>和<code>isAfter()</code>可以判断日期和时间的先后</p>
</li>
<li>
<p>使用<code>Duration</code>和<code>Period</code>可以表示两个日期和时间的“区间间隔”</p>
</li>
<li>
<p><code>ZonedDateTime</code>是带时区的日期和时间，可用于时区转换</p>
</li>
<li>
<p><code>ZonedDateTime</code>和<code>LocalDateTime</code>可以相互转换</p>
</li>
<li>
<p>对<code>ZonedDateTime</code>或<code>LocalDateTime</code>进行格式化，需要使用<code>DateTimeFormatter</code>类</p>
</li>
<li>
<p><code>DateTimeFormatter</code>可以通过格式化字符串和<code>Locale</code>对日期和时间进行定制输出</p>
</li>
<li>
<p><code>Instant</code>表示高精度时间戳，它可以和<code>ZonedDateTime</code>以及<code>long</code>互相转换</p>
</li>
<li>
<p>处理日期和时间时，尽量使用新的<code>java.time</code>包</p>
</li>
<li>
<p>在数据库中存储时间戳时，尽量使用<code>long</code>型时间戳，它具有省空间，效率高，不依赖数据库的优点</p>
</li>
</ul>
<h2 id="练习"> 练习</h2>
<p>1、某航线从北京飞到纽约需要13小时20分钟，请根据北京起飞日期和时间计算到达纽约的当地日期和时间。</p>
<div><pre><code><span>public</span> <span>class</span> <span>Main</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>LocalDateTime</span> departureAtBeijing <span>=</span> <span>LocalDateTime</span><span>.</span><span>of</span><span>(</span><span>2019</span><span>,</span> <span>9</span><span>,</span> <span>15</span><span>,</span> <span>13</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>)</span><span>;</span>
        <span>int</span> hours <span>=</span> <span>13</span><span>;</span>
        <span>int</span> minutes <span>=</span> <span>20</span><span>;</span>
        <span>LocalDateTime</span> arrivalAtNewYork <span>=</span> <span>calculateArrivalAtNY</span><span>(</span>departureAtBeijing<span>,</span> hours<span>,</span> minutes<span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>departureAtBeijing <span>+</span> <span>" -> "</span> <span>+</span> arrivalAtNewYork<span>)</span><span>;</span>
        <span>// test:</span>
        <span>if</span> <span>(</span><span>!</span><span>LocalDateTime</span><span>.</span><span>of</span><span>(</span><span>2019</span><span>,</span> <span>10</span><span>,</span> <span>15</span><span>,</span> <span>14</span><span>,</span> <span>20</span><span>,</span> <span>0</span><span>)</span>
                <span>.</span><span>equals</span><span>(</span><span>calculateArrivalAtNY</span><span>(</span><span>LocalDateTime</span><span>.</span><span>of</span><span>(</span><span>2019</span><span>,</span> <span>10</span><span>,</span> <span>15</span><span>,</span> <span>13</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>)</span><span>,</span> <span>13</span><span>,</span> <span>20</span><span>)</span><span>)</span><span>)</span> <span>{</span>
            <span>System</span><span>.</span>err<span>.</span><span>println</span><span>(</span><span>"测试失败!"</span><span>)</span><span>;</span>
        <span>}</span> <span>else</span> <span>if</span> <span>(</span><span>!</span><span>LocalDateTime</span><span>.</span><span>of</span><span>(</span><span>2019</span><span>,</span> <span>11</span><span>,</span> <span>15</span><span>,</span> <span>13</span><span>,</span> <span>20</span><span>,</span> <span>0</span><span>)</span>
                <span>.</span><span>equals</span><span>(</span><span>calculateArrivalAtNY</span><span>(</span><span>LocalDateTime</span><span>.</span><span>of</span><span>(</span><span>2019</span><span>,</span> <span>11</span><span>,</span> <span>15</span><span>,</span> <span>13</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>)</span><span>,</span> <span>13</span><span>,</span> <span>20</span><span>)</span><span>)</span><span>)</span> <span>{</span>
            <span>System</span><span>.</span>err<span>.</span><span>println</span><span>(</span><span>"测试失败!"</span><span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>

    <span>static</span> <span>LocalDateTime</span> <span>calculateArrivalAtNY</span><span>(</span><span>LocalDateTime</span> bj<span>,</span> <span>int</span> h<span>,</span> <span>int</span> m<span>)</span> <span>{</span>
        <span>return</span> bj<span>.</span><span>atZone</span><span>(</span><span>ZoneId</span><span>.</span><span>of</span><span>(</span><span>"Asia/Shanghai"</span><span>)</span><span>)</span><span>.</span><span>withZoneSameInstant</span><span>(</span><span>ZoneId</span><span>.</span><span>of</span><span>(</span><span>"America/New_York"</span><span>)</span><span>)</span><span>.</span><span>plusHours</span><span>(</span>h<span>)</span><span>.</span><span>plusMinutes</span><span>(</span>m<span>)</span><span>.</span><span>toLocalDateTime</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><div><p>整理自</p>
<p><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1255943660631584" target="_blank" rel="noopener noreferrer">Java教程 - 日期与时间</a></p>
</div>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <category term="Java"/>
    <contributor>
      <name>南辞</name>
    </contributor>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">编程语言</title>
    <id>http://qiqi.dreamagain.top/program/backend/language/</id>
    <link href="http://qiqi.dreamagain.top/program/backend/language/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<h2 id="一、如何快速入门"> 一、如何快速入门</h2>
<p>一门编程语言的入门学习最好参考网上优质网站教程、视频教程和参考书籍，尤其对于有编程基础的人而言，通过网站教程和参考书是最快的入门方式，虽然没有视频教程来得直观，但是学完后印象会比较深刻。</p>
<div><p>提示</p>
<p>学习一门语言的基本顺序是:</p>
<ul>
<li>了解数据结构</li>
<li>了解变量声明与赋值</li>
<li>了解判断和循环体结构</li>
<li>了解函数声明</li>
<li>了解输入输出</li>
</ul>
</div>
<h2 id="二、java"> 二、<a href="./java/">Java</a></h2>
<h3 id="一-学习教程"> （一）学习教程</h3>
<h4 id="网站"> 网站：</h4>
<ul>
<li><a href="https://www.liaoxuefeng.com/wiki/1252599548343744" target="_blank" rel="noopener noreferrer">廖雪峰 - Java教程</a> <i>Not supported content</i><i>Not supported content</i></li>
<li><a href="https://www.runoob.com/java/java-tutorial.html" target="_blank" rel="noopener noreferrer">菜鸟教程</a> <i>Not supported content</i></li>
<li><a href="https://www.w3cschool.cn/java/" target="_blank" rel="noopener noreferrer">w3cschool</a> <i>Not supported content</i> <i>Not supported content</i> <i>Not supported content</i></li>
<li><a href="https://www.sxt.cn/Java_jQuery_in_action/History_Direction.html" target="_blank" rel="noopener noreferrer">速学堂 Java教程</a><i>Not supported content</i> <i>Not supported content</i></li>
</ul>
<h4 id="视频"> 视频</h4>
<ul>
<li><a href="https://www.bilibili.com/video/BV1Kb411W75N" target="_blank" rel="noopener noreferrer">宋红康老师 - Java零基础教程</a></li>
<li><a href="https://www.bilibili.com/video/BV137411V7Y1?from=search&amp;seid=12229606472951180090" target="_blank" rel="noopener noreferrer">尚学堂 - Java教程</a></li>
<li><a href="https://www.bilibili.com/video/BV187411B7iv?from=search&amp;seid=6206316045477009865" target="_blank" rel="noopener noreferrer">圣思园张龙 - 深入理解JVM虚拟机</a></li>
</ul>
<h3 id="二-学习笔记"> （二）学习笔记</h3>
<p>Java基础重点掌握面向对象、泛型、集合、IO流、反射、异常处理、多线程</p>
<ul>
<li><a href="./java/generics.html">JavaSE 泛型</a></li>
<li><a href="./java/collection.html">JavaSE 集合</a></li>
<li><a href="./java/annotation.html">JavaSE 注解</a></li>
</ul>
<h3 id="三-基础知识-面试"> （三）基础知识/面试</h3>
<p>因为我们平时都是基于框架编程，有的基础知识时间长后很容易忘记。 虽然网上分享的面试题总结都是为了营销，但用来查缺补漏也不失为一种不错的方式。整理自互联网，仅供参考</p>
<ul>
<li><a href="./java/solution/Java基础.html">Java基础</a></li>
<li><a href="./java/solution/Java进阶.html">Java进阶</a></li>
</ul>
<h2 id="三、python"> 三、Python</h2>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <category term="编程语言"/>
    <contributor>
      <name>南辞</name>
    </contributor>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">后端指南</title>
    <id>http://qiqi.dreamagain.top/program/backend/</id>
    <link href="http://qiqi.dreamagain.top/program/backend/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <summary type="html"><![CDATA[<blockquote>
<p><img src="https://img.shields.io/badge/%E5%90%8E%E7%AB%AF-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80-success.svg" alt="img">   <img src="https://img.shields.io/badge/%E5%90%8E%E7%AB%AF-%E6%A1%86%E6%9E%B6-success.svg" alt="img"></p>
</blockquote>
]]></summary>
    <content type="html"><![CDATA[<blockquote>
<p><img src="https://img.shields.io/badge/%E5%90%8E%E7%AB%AF-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80-success.svg" alt="img">   <img src="https://img.shields.io/badge/%E5%90%8E%E7%AB%AF-%E6%A1%86%E6%9E%B6-success.svg" alt="img"></p>
</blockquote>

<h2 id="编程语言"> 编程语言</h2>
<ul>
<li><a href="./java/">Java</a></li>
</ul>
<h2 id="后端框架"> 后端框架</h2>
<ul>
<li><a href="./backframe/spring.html">Spring framework</a></li>
</ul>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <contributor>
      <name>南辞</name>
    </contributor>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">JavaScript</title>
    <id>http://qiqi.dreamagain.top/program/frontend/js/</id>
    <link href="http://qiqi.dreamagain.top/program/frontend/js/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<h2 id="初学者教程"> 初学者教程</h2>
<ul>
<li><a href="./../language/js/guide/">快速上手</a></li>
</ul>
<h3 id="javascript-手册"> JavaScript 手册</h3>
<ul>
<li><a href="./../language/js/">JavaScript 学习教程</a></li>
</ul>
<h3 id="在线教程"> 在线教程</h3>
<ul>
<li>
<p><a href="http://www.w3school.com.cn/js/index.asp" target="_blank" rel="noopener noreferrer">W3School 教程</a></p>
</li>
<li>
<p><a href="https://www.runoob.com/js/js-tutorial.html" target="_blank" rel="noopener noreferrer">菜鸟教程</a></p>
</li>
<li>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript" target="_blank" rel="noopener noreferrer">MDN 教程</a></p>
</li>
</ul>
<h3 id="es6"> ES6</h3>
<p>ES6 是 JavaScript 的 2015 标注，现已基本被广泛使用和支持；</p>
<ul>
<li><a href="./../language/js/es6/">ES6 教程</a></li>
</ul>
<div><p>提示</p>
<p>此教程由阮一峰老师书写(<strong>真·大佬</strong>)，建议深刻理解 JavaScript 原理(大概一年左右)之后再看。</p>
</div>
<blockquote>
<p>开始下一章学习前，您需要跳转到 <a href="./../language/js/guide/">JS 快速入门章节</a> 了解 JavaScript，或 <a href="./../language/js/">深入学习 JavaScript</a> 后，方能进入 jQuery 学习。</p>
</blockquote>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <category term="JavaScript"/>
    <contributor>
      <name>南辞</name>
    </contributor>
    <published>2019-09-01T00:00:00.000Z</published>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">前端指南</title>
    <id>http://qiqi.dreamagain.top/program/frontend/</id>
    <link href="http://qiqi.dreamagain.top/program/frontend/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <summary type="html"><![CDATA[<blockquote>
<p><img src="https://img.shields.io/badge/%E5%89%8D%E7%AB%AF-HTML-blue.svg" alt="img"> <img src="https://img.shields.io/badge/%E5%89%8D%E7%AB%AF-CSSL-blue.svg" alt="img"> <img src="https://img.shields.io/badge/%E5%89%8D%E7%AB%AF-JavaScript-blue.svg" alt="img"> <img src="https://img.shields.io/badge/%E5%89%8D%E7%AB%AF-jQuery-blue.svg" alt="img">  <img src="https://img.shields.io/badge/%E6%A1%86%E6%9E%B6-Vue-blue.svg" alt="img"> <img src="https://img.shields.io/badge/%E6%A1%86%E6%9E%B6-React-blue.svg" alt="img"> <img src="https://img.shields.io/badge/%E6%A1%86%E6%9E%B6-Angular-blue.svg" alt="img"></p>
</blockquote>
]]></summary>
    <content type="html"><![CDATA[<blockquote>
<p><img src="https://img.shields.io/badge/%E5%89%8D%E7%AB%AF-HTML-blue.svg" alt="img"> <img src="https://img.shields.io/badge/%E5%89%8D%E7%AB%AF-CSSL-blue.svg" alt="img"> <img src="https://img.shields.io/badge/%E5%89%8D%E7%AB%AF-JavaScript-blue.svg" alt="img"> <img src="https://img.shields.io/badge/%E5%89%8D%E7%AB%AF-jQuery-blue.svg" alt="img">  <img src="https://img.shields.io/badge/%E6%A1%86%E6%9E%B6-Vue-blue.svg" alt="img"> <img src="https://img.shields.io/badge/%E6%A1%86%E6%9E%B6-React-blue.svg" alt="img"> <img src="https://img.shields.io/badge/%E6%A1%86%E6%9E%B6-Angular-blue.svg" alt="img"></p>
</blockquote>

<p>编写前端网页需要掌握三件套: <strong>HTML</strong>、<strong>CSS</strong> 和 <strong>JavaScript</strong>。</p>
<ol>
<li>HTML 定义了网页的内容</li>
<li>CSS 描述了网页的样式</li>
<li>JavaScript 编写网页的行为</li>
</ol>
<div><p>提示</p>
<p>一个大型的网站，很少是直接使用原生代码写的。</p>
<p>最新的网站大多数都是用三大框架(、、)搭建，并引入 npm 上的 UI 库编写而成。</p>
<p>稍微老的网站会使用其他框架作为辅助，比如、等。</p>
</div>
<div><p>网页标准指定</p>
<p>互联网网页标准由 W3C 组织制定，它的全称是万维网联盟组织。</p>
</div>
<h2 id="html"> HTML</h2>
<p>HTML 指的是超文本标记语言 (Hyper Text Markup Language)，描述了网页的骨架(具体结构)。</p>
<ul>
<li><a href="./html/">HTML 教程</a></li>
</ul>
<h2 id="css"> CSS</h2>
<p>CSS 指层叠样式表 (Cascading Style Sheets)，声明了网页的样式(具体布局)。</p>
<ul>
<li><a href="./css/">CSS 教程</a></li>
</ul>
<h2 id="emmet"> Emmet</h2>
<p>Emmet 是一种快速输入 HTML 和 CSS 的语法。</p>
<ul>
<li><a href="./emmet/">Emmet 用法介绍</a></li>
</ul>
<h2 id="javascript"> JavaScript</h2>
<p>JavaScript 是一种编程语言，声明了网页的交互逻辑。</p>
<p>JavaScript 是一种轻量级的编程语言，为可插入 HTML 页面的编程代码。所有现代的 HTML 页面都使用 JavaScript。</p>
<ul>
<li><a href="./js.html">JS 教程</a></li>
</ul>
<h3 id="typescript"> TypeScript</h3>
<p>TypeScript 是 JavaScript 的一个超集，使得 JS 变成了一种强定义语言。TypeScript 由于其诸多优良特性，目前在前端的份额越来越大。</p>
<ul>
<li><a href="./../language/typescript/">TypeScript 教程</a></li>
</ul>
<h2 id="node-js"> Node.js</h2>
<p>在深入了解并进行前端开发后，就避不开 Node。</p>
<p>Node.js 是一款全球使用广泛的框架，可以用在前端与后端上，拥有大量的模块。Node.js 主要以其丰富并及其容易导入的 Node.js package，以及其方便管理 npm (Node.js Package Manager)闻名。</p>
<ul>
<li><a href="./src/program/language/node.js/">Node.js 教程</a></li>
</ul>
<h2 id="历史前端框架"> 历史前端框架</h2>
<h3 id="jquery"> jQuery</h3>
<p>jQuery 是一个 JavaScript 库，极大地简化了 JavaScript 编程，很容易学习。</p>
<p>jQuery 的优势在于它能够在互联网发展早期兼容各式各样的浏览器，并轻松的选定与操作 DOM。</p>
<p>由于 NVVM 的兴起，目前 jQuery 已逐步被前端三大框架所取代。</p>
<ul>
<li>
<p><a href="./jQuery/">jQuery 教程</a></p>
</li>
<li>
<p><a href="http://www.w3school.com.cn/jquery/index.asp" target="_blank" rel="noopener noreferrer">W3School</a></p>
</li>
<li>
<p><a href="https://www.runoob.com/jquery/jquery-tutorial.html" target="_blank" rel="noopener noreferrer">菜鸟教程</a></p>
</li>
</ul>
<h3 id="bootstrap4"> Bootstrap4</h3>
<p>Bootstrap 是全球最受欢迎的前端组件库，用于开发响应式布局、移动设备优先的 WEB 项目。</p>
<p>Bootstrap 是一套用于 HTML、CSS 和 JS 开发的开源工具集。利用提供的 Sass 变量和大量 mixin、响应式栅格系统、可扩展的预制组件、基于 jQuery 的强大的插件系统，能够快速为您的想法开发出原型或者构建整个 app 。</p>
<ul>
<li>
<p><a href="https://getbootstrap.com/docs/4.1/getting-started/introduction/" target="_blank" rel="noopener noreferrer">bootstrap 官方文档</a></p>
</li>
<li>
<p><a href="https://v4.bootcss.com/docs/4.0/getting-started/introduction/" target="_blank" rel="noopener noreferrer">bootstrap 4.0 中文文档</a></p>
</li>
</ul>
<h2 id="现代前端框架"> 现代前端框架</h2>
<h3 id="vue"> Vue</h3>
<p>Vue 是一套轻量化的前端渐进式框架框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。</p>
<p>Vue 与 React、Angular 一起合称前端三大框架。</p>
<ul>
<li>
<p><a href="./../vue/">Vue 学习教程</a></p>
</li>
<li>
<p><a href="https://cn.vuejs.org/v2/guide/" target="_blank" rel="noopener noreferrer">Vue 官方文档</a></p>
</li>
</ul>
<h3 id="react"> React</h3>
<ul>
<li><a href="./src/program/webframe/react/">React 教程</a></li>
</ul>
<h3 id="angular"> Angular</h3>
<ul>
<li><a href="./../angular/">Angular 教程</a></li>
</ul>
<h2 id="其他文档"> 其他文档</h2>
<ul>
<li><a href="./https.html">HTTPS 介绍</a></li>
</ul>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <category term="前端"/>
    <contributor>
      <name>南辞</name>
    </contributor>
    <published>2019-09-01T00:00:00.000Z</published>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">编程开发</title>
    <id>http://qiqi.dreamagain.top/program/</id>
    <link href="http://qiqi.dreamagain.top/program/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <summary type="html"><![CDATA[<blockquote>
<p><img src="https://img.shields.io/badge/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-blue.svg" alt=""> <img src="https://img.shields.io/badge/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80-blue.svg" alt=""> <img src="https://img.shields.io/badge/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91-blue.svg" alt="">  <img src="https://img.shields.io/badge/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91-blue.svg" alt=""> <img src="https://img.shields.io/badge/%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%91-blue.svg" alt=""> <img src="https://img.shields.io/badge/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91-blue.svg" alt=""> <img src="https://img.shields.io/badge/%E5%AD%A6%E4%B9%A0%E7%BD%91%E7%AB%99-blue.svg" alt=""></p>
</blockquote>
]]></summary>
    <content type="html"><![CDATA[<blockquote>
<p><img src="https://img.shields.io/badge/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-blue.svg" alt=""> <img src="https://img.shields.io/badge/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80-blue.svg" alt=""> <img src="https://img.shields.io/badge/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91-blue.svg" alt="">  <img src="https://img.shields.io/badge/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91-blue.svg" alt=""> <img src="https://img.shields.io/badge/%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%91-blue.svg" alt=""> <img src="https://img.shields.io/badge/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91-blue.svg" alt=""> <img src="https://img.shields.io/badge/%E5%AD%A6%E4%B9%A0%E7%BD%91%E7%AB%99-blue.svg" alt=""></p>
</blockquote>
 
<h2 id="目录"> 目录</h2>
<ul>
<li>
<p><a href="./backend/">后端开发</a></p>
</li>
<li>
<p><a href="./frontend/">前端开发</a></p>
</li>
</ul>
<h2 id="编程学习网站"> 编程学习网站</h2>
<h3 id="优质网站"> 优质网站</h3>
<ul>
<li>
<p><a href="https://wangdoc.com/" target="_blank" rel="noopener noreferrer">网道</a></p>
</li>
<li>
<p><a href="https://www.liaoxuefeng.com/" target="_blank" rel="noopener noreferrer">廖雪峰的网站</a></p>
</li>
<li>
<p><a href="https://developer.mozilla.org/zh-CN/" target="_blank" rel="noopener noreferrer">MDN</a></p>
<div><p>相关信息</p>
<p>MDN 的中文文档翻译很差，大多都是机翻，十分建议直接阅读英文文档。</p>
</div>
</li>
</ul>
<h3 id="杂牌网站"> 杂牌网站</h3>
<ul>
<li>
<p><a href="https://www.runoob.com/" target="_blank" rel="noopener noreferrer">菜鸟教程</a> <i>Not supported content</i></p>
</li>
<li>
<p><a href="https://www.w3cschool.cn" target="_blank" rel="noopener noreferrer">w3cschool</a> <i>Not supported content</i> <i>Not supported content</i> <i>Not supported content</i></p>
</li>
<li>
<p><a href="http://www.w3school.com.cn/" target="_blank" rel="noopener noreferrer">w3school</a> <i>Not supported content</i></p>
</li>
</ul>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <category term="编程开发"/>
    <contributor>
      <name>南辞</name>
    </contributor>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">七七部落 | 主页</title>
    <id>http://qiqi.dreamagain.top/</id>
    <link href="http://qiqi.dreamagain.top/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <author>
      <name>南辞</name>
    </author>
    <contributor>
      <name>南辞</name>
    </contributor>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">Apache</title>
    <id>http://qiqi.dreamagain.top/software/Apache/</id>
    <link href="http://qiqi.dreamagain.top/software/Apache/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <summary type="html"><![CDATA[<p>Apache 是世界使用排名第一的 Web 服务器软件。它可以运行在几乎所有广泛使用的计算机平台上，由于其跨平台和安全性被广泛使用，是最流行的 Web 服务器端软件之一。它快速、可靠并且可通过简单的 API 扩充，将 Perl/Python 等解释器编译到服务器中。</p>
]]></summary>
    <content type="html"><![CDATA[<p>Apache 是世界使用排名第一的 Web 服务器软件。它可以运行在几乎所有广泛使用的计算机平台上，由于其跨平台和安全性被广泛使用，是最流行的 Web 服务器端软件之一。它快速、可靠并且可通过简单的 API 扩充，将 Perl/Python 等解释器编译到服务器中。</p>

<h2 id="apache-是什么"> Apache 是什么</h2>
<p>Apache HTTP Server (简称 Apache )是 Apache 软件基金会的一个开放源码的网页服务器，可以在大多数计算机操作系统中运行，由于其多平台和安全性被广泛使用，是最流行的 Web 服务器端软件之一。它快速、可靠并且可通过简单的 API 扩展，将 Perl/Python 等解释器编译到服务器中。</p>
<p>Apache HTTP 服务器是一个模块化的服务器，源于 NCSAhttpd 服务器，经过多次修改，成为世界使用排名第一的 Web 服务器软件。
它可以运行在几乎所有广泛使用的计算机平台上。</p>
<h2 id="apache-模块"> Apache 模块</h2>
<p>Apache 通过引入各种模块来完成不同的功能。</p>
<h2 id="apache-官方文档"> Apache 官方文档</h2>
<ul>
<li><a href="https://httpd.apache.org/docs/2.4/zh-cn/" target="_blank" rel="noopener noreferrer">文档地址</a></li>
</ul>
<h2 id="apache-配置"> Apache 配置</h2>
<p>Apache 通过 conf 文件夹下的 httpd.conf 来配置。</p>
<div><pre><code><span># 此处填入 Apache 的路径</span>
<span>Define</span> SRVROOT <span>"U:/Apache"</span>
<span>ServerRoot</span> <span>"<span>${SRVROOT}</span>"</span>
<span>Listen</span> 127.0.0.1:80
<span>Listen</span> 127.0.0.1:443

<span>LoadModule</span> auth_basic_module modules/mod_auth_basic.so
<span>LoadModule</span> authz_core_module modules/mod_authz_core.so
<span>LoadModule</span> deflate_module modules/mod_deflate.so
<span>LoadModule</span> dir_module modules/mod_dir.so
<span>LoadModule</span> env_module modules/mod_env.so
<span>LoadModule</span> isapi_module modules/mod_isapi.so
<span>LoadModule</span> log_config_module modules/mod_log_config.so
<span>LoadModule</span> mime_module modules/mod_mime.so
<span>LoadModule</span> negotiation_module modules/mod_negotiation.so
<span>LoadModule</span> proxy_http2_module modules/mod_proxy_http2.so
<span>LoadModule</span> ratelimit_module modules/mod_ratelimit.so
<span>LoadModule</span> rewrite_module modules/mod_rewrite.so
<span>LoadModule</span> setenvif_module modules/mod_setenvif.so
<span>LoadModule</span> ssl_module modules/mod_ssl.so
<span># 此处填入 PHP 的 ssh 组件路径</span>
<span>LoadFile</span> <span>"u:/php/libssh2.dll"</span>
<span># 此处填入 PHP 的 Apache 组件路径</span>
<span>LoadModule</span> php7_module <span>"u:/PHP/php7apache2_4.dll"</span>
<span># 此处填入 PHP 的路径</span>
PHPIniDir <span>"u:/PHP"</span>

<span><span><span>&lt;</span>IfModule</span><span> unixd_module</span><span>></span></span>
<span>User</span> daemon
<span>Group</span> daemon
<span><span><span>&lt;/</span>IfModule</span><span>></span></span>

<span>ServerAdmin</span> zhangbowang1998@gmail.com
<span>ServerName</span> localhost

<span><span><span>&lt;</span>Directory</span><span> /</span><span>></span></span>
  <span>AllowOverride</span> none
  <span>Require</span> all denied
<span><span><span>&lt;/</span>Directory</span><span>></span></span>

<span>DocumentRoot</span> <span>"<span>${SRVROOT}</span>/htdocs"</span>
<span><span><span>&lt;</span>Directory</span><span> <span>"<span>${SRVROOT}</span>/htdocs"</span></span><span>></span></span>
  <span>Options</span> FollowSymLinks
  <span>AllowOverride</span> All
  <span>Require</span> all granted
<span><span><span>&lt;/</span>Directory</span><span>></span></span>

<span><span><span>&lt;</span>IfModule</span><span> dir_module</span><span>></span></span>
  <span>DirectoryIndex</span> index.html index.php
<span><span><span>&lt;/</span>IfModule</span><span>></span></span>

<span><span><span>&lt;</span>Files</span><span> <span>".ht*"</span></span><span>></span></span>
  <span>Require</span> all denied
<span><span><span>&lt;/</span>Files</span><span>></span></span>

<span>ErrorLog</span> <span>"logs/error.log"</span>
<span>LogLevel</span> info

<span><span><span>&lt;</span>IfModule</span><span> log_config_module</span><span>></span></span>
  <span>LogFormat</span> <span>"<span>%h</span> <span>%l</span> <span>%u</span> <span>%t</span> \"<span>%r</span>\" %>s <span>%b</span> \"<span>%{Referer}</span>i\" \"<span>%{User-Agent}</span>i\""</span> combined
  <span>LogFormat</span> <span>"<span>%h</span> <span>%l</span> <span>%u</span> <span>%t</span> \"<span>%r</span>\" %>s <span>%b</span>"</span> common
  <span><span><span>&lt;</span>IfModule</span><span> logio_module</span><span>></span></span>
    <span>LogFormat</span> <span>"<span>%h</span> <span>%l</span> <span>%u</span> <span>%t</span> \"<span>%r</span>\" %>s <span>%b</span> \"<span>%{Referer}</span>i\" \"<span>%{User-Agent}</span>i\" <span>%I</span> <span>%O</span>"</span> combinedio
  <span><span><span>&lt;/</span>IfModule</span><span>></span></span>
  <span>CustomLog</span> <span>"logs/access.log"</span> common
<span><span><span>&lt;/</span>IfModule</span><span>></span></span>

<span><span><span>&lt;</span>IfModule</span><span> alias_module</span><span>></span></span>
  <span>ScriptAlias</span> /cgi-bin/ <span>"<span>${SRVROOT}</span>/cgi-bin/"</span>
<span><span><span>&lt;/</span>IfModule</span><span>></span></span>

<span><span><span>&lt;</span>Directory</span><span> <span>"<span>${SRVROOT}</span>/cgi-bin"</span></span><span>></span></span>
  <span>AllowOverride</span> None
  <span>Options</span> None
  <span>Require</span> all granted
<span><span><span>&lt;/</span>Directory</span><span>></span></span>

<span><span><span>&lt;</span>IfModule</span><span> headers_module</span><span>></span></span>
  <span>RequestHeader</span> unset Proxy early
<span><span><span>&lt;/</span>IfModule</span><span>></span></span>

<span><span><span>&lt;</span>IfModule</span><span> mime_module</span><span>></span></span>
  <span>TypesConfig</span> conf/mime.types
  <span>AddHandler</span> application/x-httpd-php .php
  <span>AddType</span> application/x-compress .Z
  <span>AddType</span> application/x-gzip .gz .tgz
  <span>AddType</span> application/x-httpd-php .php .html
<span><span><span>&lt;/</span>IfModule</span><span>></span></span>

<span><span><span>&lt;</span>IfModule</span><span> proxy_html_module</span><span>></span></span>
  <span>Include</span> conf/extra/proxy-html.conf
<span><span><span>&lt;/</span>IfModule</span><span>></span></span>
<span><span><span>&lt;</span>IfModule</span><span> ssl_module</span><span>></span></span>
  <span>SSLRandomSeed</span> startup builtin
  <span>SSLRandomSeed</span> connect builtin
<span><span><span>&lt;/</span>IfModule</span><span>></span></span>

<span><span><span>&lt;</span>VirtualHost</span><span> *<span>:</span>80</span><span>></span></span>
  <span>ServerAdmin</span> zhangbowang1998@gmail.com
  <span>ServerName</span> nenu.com
  <span>ServerAlias</span> innenu
  <span>DocumentRoot</span> <span>"<span>${SRVROOT}</span>/htdocs"</span>
<span><span><span>&lt;/</span>VirtualHost</span><span>></span></span>

<span><span><span>&lt;</span>VirtualHost</span><span> *<span>:</span>443</span><span>></span></span>
  <span>ServerAdmin</span> zhangbowang1998@gmail.com
  <span>ServerName</span> mrhope.com
  <span>ServerAlias</span> mrhope
  <span>DocumentRoot</span> <span>"<span>${SRVROOT}</span>/htdocs"</span>
<span><span><span>&lt;/</span>VirtualHost</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br><span>96</span><br><span>97</span><br><span>98</span><br><span>99</span><br><span>100</span><br><span>101</span><br><span>102</span><br><span>103</span><br><span>104</span><br><span>105</span><br><span>106</span><br><span>107</span><br><span>108</span><br><span>109</span><br><span>110</span><br></div></div><ul>
<li>
<h3 id="serverroot"> ServerRoot</h3>
<p>指定服务器的根目录</p>
</li>
<li>
<h3 id="listen"> Listen</h3>
<p>指定服务器监听的 IP 与 port</p>
</li>
<li>
<h3 id="loadmodule"> LoadModule</h3>
<p>加载指定的模块来使服务器调用</p>
</li>
<li>
<h3 id="phpinidir"> PHPIniDir</h3>
<p>指定 PHP 目录</p>
</li>
<li>
<h3 id="unixd-module"> unixd_module</h3>
<p>分配用户权限</p>
</li>
<li>
<h3 id="serveradmin"> ServerAdmin</h3>
<p>服务器管理员</p>
</li>
<li>
<h3 id="servername"> ServerName</h3>
<p>服务器名称</p>
</li>
</ul>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <category term="服务器"/>
    <contributor>
      <name>南辞</name>
    </contributor>
    <published>2019-12-12T00:00:00.000Z</published>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">Chrome</title>
    <id>http://qiqi.dreamagain.top/software/Chrome/</id>
    <link href="http://qiqi.dreamagain.top/software/Chrome/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <summary type="html"><![CDATA[<p>Chrome 是谷歌出品的浏览器。其内核使用 Chromium，基于 JavaScript V8，是全球比例最大的浏览器内核。</p>
]]></summary>
    <content type="html"><![CDATA[<p>Chrome 是谷歌出品的浏览器。其内核使用 Chromium，基于 JavaScript V8，是全球比例最大的浏览器内核。</p>

<h2 id="简介"> 简介</h2>
<p>Chrome 如今可以说是一家独大。很多国内浏览器都是基于 Chromium 内核的套壳浏览器。</p>
<p>Chrome 内核更新频繁，速度和安全性高，对新特性支持非常良好。另外谷歌具有十分强大的开发者工具，是前端开发使用的首选浏览器。目前最新的版本是 85。</p>
<h2 id="配置"> 配置</h2>
<p>由于 Chrome 是谷歌出品的浏览器，所以搜索栏默认使用 Google 搜索，而在中国无法访问 Google 服务，所以需要在右上角的菜单中选择设置，在搜索引擎设置中改为百度即可正常使用。</p>
<p><img src="./assets/searchEngine.png" alt="更改页面"></p>
<h2 id="快捷键"> 快捷键</h2>
<p>Chrome 具有很多快捷键，熟练掌握后可以大幅减少时间。</p>
<ul>
<li><code>Ctrl + J</code>: 打开下载页面；</li>
<li><code>Ctrl + H</code>: 打开历史页面；</li>
<li><code>Ctrl + T</code>: 打开新标签页；</li>
<li><code>Ctrl + Shift + T</code>: 恢复上一个关闭的标签页；</li>
<li><code>Ctrl + N</code>: 打开新的窗口；</li>
<li><code>Ctrl + W</code>: 关闭当前标签页；</li>
<li><code>Ctrl + Tab</code>: 切换标签页；</li>
<li><code>Ctrl + Shift + Tab</code>: 反向切换标签页；</li>
<li><code>Ctrl + F</code>: 反向切换标签页；</li>
<li><code>Ctrl + Shift + I</code> 或 <code>F12</code>: 打开开发者工具；</li>
</ul>
<h2 id="开发者工具"> 开发者工具</h2>
<p><img src="./assets/devTool.png" alt="开发者工具"></p>
<p>使用 <code>Ctrl + Shift + I</code> 或 <code>F12</code> 即可打开开发者工具，在开发者工具里，您可以自由的对任何网页进行调试。</p>
<h2 id="chrome-推荐扩展"> Chrome 推荐扩展</h2>
<ul>
<li>AdGuard: 广告屏蔽；</li>
<li>Adobe Acrobat: 将当前网页转为 Adobe PDF 文件；</li>
<li>Betternet Unlimited Free VPN Proxy: 免费的 VPN 代理；</li>
<li>Checker Plus for Gmail™: Gmail 邮件管理；</li>
<li>Convertio: 非常强大的文件在线转换；</li>
<li>Dark Reader: 为网页启用夜间模式；</li>
<li>Enhanced GitHub: 能够展示仓库大小，文件大小和快速下载按钮；</li>
<li>Evernote Web Clipper: 印象笔记剪藏，非常好用的保存工具；</li>
<li>Google 翻译: 谷歌翻译软件；</li>
<li>ImTranslator: 翻译，字典，声音</li>
<li>Infinity: 一款非常好的标签页软件；</li>
<li>Office Online: 在线查看并编辑 Office 文件；</li>
<li>React Developer Tools: React 开发者工具</li>
<li>Save to Pocket: 离线网页的最佳插件；</li>
<li>VPN Free - Betternet Unlimited VPN Proxy: 一款免费的 VPN 插件；</li>
<li>Vue.js Devtools: Vue.js 的开发者工具；</li>
</ul>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <category term="软件"/>
    <contributor>
      <name>南辞</name>
    </contributor>
    <published>2019-12-13T00:00:00.000Z</published>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">MySQL-01</title>
    <id>http://qiqi.dreamagain.top/software/database/SQL/MySQL/MySQL-01/</id>
    <link href="http://qiqi.dreamagain.top/software/database/SQL/MySQL/MySQL-01/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <summary type="html"><![CDATA[MySQL介绍]]></summary>
    <content type="html"><![CDATA[<p><code>MySQL介绍</code></p>

<h2 id="概述"> 概述</h2>
<h3 id="为什么学习数据库"> 为什么学习数据库？</h3>
<ul>
<li>实现数据持久化</li>
<li>使用完整的管理系统统一管理，易于查询</li>
</ul>
<h3 id="数据库的相关概念"> 数据库的相关概念</h3>
<ul>
<li>DB：数据库（database）：存储数据的“仓库”。它保存了一系列有组织的数据。</li>
<li>DBMS
<ul>
<li>数据库管理系统（Database Management System）。数据库是通过DBMS创建和操作的容器</li>
<li>常见的数据库管理系统：MySQL、Oracle、DB2、SqlServer等。</li>
</ul>
</li>
<li>SQL
<ul>
<li>结构化查询语言（Structure Query Language）：专门用来与数据库通信的语言。</li>
<li>SQL的优点：①简单易学；②不是某个特定数据库供应商专有的语言，几乎所有DBMS都支持SQL；③虽然简单，但实际上是一种强有力的语言，灵活使用其语言元素，可以进行非常复杂和高级的数据库操作。</li>
</ul>
</li>
</ul>
<blockquote>
<p>DBA、DBS、DBMS、SQL、DB之间的关系：</p>
</blockquote>
<p><img src="https://gitee.com/small-universe/blog_data/raw/images/%20database/MySQL/%E5%85%B3%E7%B3%BB.jpg" alt="关系"></p>
<hr>
<h3 id="数据库存储数据的特点"> 数据库存储数据的特点</h3>
<ul>
<li>1、将数据放到表中，表再放到库中</li>
<li>2、一个数据库中可以有多个表，每个表都有一个的名字，用来标识自己。表名具有唯一性。</li>
<li>3、表具有一些特性，这些特性定义了数据在表中如何存储，类似java中 “类”的设计。</li>
<li>4、表由列组成，我们也称为字段。所有表都是由一个或多个列组成的，每一列类似java 中的”属性”。</li>
<li>5、表中的数据是按行存储的，每一行类似于java中的“对象”。</li>
</ul>
<h3 id="mysql软件"> MySQL软件</h3>
<ul>
<li>
<p>介绍</p>
<ul>
<li>MySQL数据库原属于MySQLAB公司，总部位于瑞典，后被Oracle收购。</li>
<li>优点：①成本低：开放源代码，免费，可定制；②简单：很容易安装和使用；③性能高：轻巧、执行sql很快。</li>
</ul>
</li>
<li>
<p>安装</p>
<ul>
<li>
<p>DBMS分为两类：</p>
<p>①基于共享文件系统的DBMS （Access）；</p>
<p>②基于客户机——服务器的DBMS（MySQL、Oracle、SqlServer）。</p>
</li>
<li>
<p>版本可分为：社区版（免费），企业版（收费）。</p>
</li>
<li>
<p>Windows平台下下载社区版：http://dev.mysql.com/downloads/mysql</p>
</li>
<li>
<p>下载后解压缩文件到指定文件夹并配置环境变量即可</p>
<p>eg:  变量名<code>MySQL_HOME</code> 路径<code>D:\dev_softs\mysql-8.0.20-winx64</code></p>
</li>
</ul>
</li>
<li>
<p>启动和停止MySQL服务</p>
<ul>
<li>
<p>方式一：右击此电脑—管理—服务—启动或停止MySQL服务</p>
</li>
<li>
<p>方式二：DOS窗口中使用如下命令</p>
<div><pre><code>启动：net start 服务名
停止：net stop 服务名

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div></li>
</ul>
</li>
<li>
<p>MySQL服务端的登录和退出</p>
<div><pre><code>登录
mysql 【–h 主机名 -P 端口号】 –u 用户名 –p密码
例：mysql -h localhost -u root -proot

退出
exit或ctrl+C
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div></li>
<li>
<p>MySQL常见命令介绍</p>
<div><pre><code>进入mysql, 在命令行中输入
mysql–uroot–p####  (其中：####表示密码）
例：mysql -uroot -proot

查看mysql中有哪些个数据库
show databases;

新建一个数据库
create database 数据库名;
例：create database book;

选择一个数据库
use 数据库名称;
例：use test;

查询数据表
show tables;

查看指定的数据库中有哪些数据表
show tables from 数据库名;
例：show tables from mysql;

查询当前所在数据库
select database();

新建一个数据表
create table math(
    id int,
    name varchar(20)
);

查看表的结构
desc 表名;
例：desc math;

查看表中的所有记录
select * from 表名;
例： select * from math;

向表中插入记录
insert into 表名(列名列表) values(列对应的值的列表);
注意：插入varchar或date 型的数据要用单引号或双引号引起来
例：insert into math (id,name) values(1,&#39;ton&#39;);

修改记录
update 表名set 列1 = 列1的值, 列2 = 列2的值where ..
例：update math set name=&quot;wugang&quot; where id=1;

删除记录
delete from 表名 where ...
例：delete from math where id=1;

删除数据表
drop table 表名;
例：drop table math;
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br></div></div></li>
<li>
<p>查看MySQL服务端版本</p>
<div><pre><code>登录到mysql服务端
<span>SELECT</span> VERSION<span>(</span><span>)</span> <span>AS</span> <span>'MySQL版本'</span><span>;</span>

没有登录到mysql服务端
在cmd命令界面输入：mysql <span>--version</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div></li>
<li>
<p>MySQL的语法规范</p>
<ul>
<li>不区分大小写,但建议关键字大写，表名、列名小写</li>
<li>每句话用;或\g、\G结尾，最好用分号结尾</li>
<li>每条命令根据需要，可以进行缩进或换行</li>
<li>注释：①单行注释：#注释文字；②单行注释：-- 注释文字；③多行注释：/* 注释文字 */</li>
</ul>
</li>
<li>
<p>图形化用户界面客户端</p>
<ul>
<li>
<p>介绍：主要分为两种——SQLyog 12、Navicat 12 for mysql</p>
</li>
<li>
<p>安装：傻瓜式安装</p>
</li>
<li>
<p>卸载：方法一：控制面板选中SQLyog直接卸载；方法二：卸载时担心注册表清除不干净,百度geek下载工具，下载免费版即可。下载后，放到桌面，双击后可直接选中要卸载的软件进行卸载,最后可根据选择是否清除注册表。</p>
</li>
<li>
<p>注意：<code>SQLyog连接数据库报错</code>plugin caching_sha2_password could not be loaded，解决方法如下</p>
<div><pre><code>打开cmd：mysql -uroot -p 
进入mysql依次执行下面语句
ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;password&#39; PASSWORD EXPIRE NEVER; #修改加密规则 
ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED WITH mysql_native_password BY &#39;password&#39;; #更新一下用户的密码 

FLUSH PRIVILEGES; #刷新权限
alter user &#39;root&#39;@&#39;localhost&#39; identified by &#39;xzx123456&#39;;#重置密码，xzx123456就是变更后的密码，自己的密码自己更改下哦
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div></li>
</ul>
<div><p>提示</p>
<p>MySQL8.0+的驱动需要设置时区</p>
<p>如:
jdbc:mysql://localhost:3306/myemployees?serverTimezone=Asia/Shanghai</p>
</div>
</li>
</ul>
<p>&amp;useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=true</p>
<p>:::</p>
<h2 id="sql语言的分类"> SQL语言的分类</h2>
<blockquote>
<p>对于这个，网上有三种、四种、五种、六种很多，但综合来说，是5种！！</p>
<p>因为大部分用到的是DQL和DML，偶尔会用到DDL，一般的开发人员很少会用到DCL</p>
</blockquote>
<ul>
<li>DQL（Data Query Language）：数据查询语言，用于检索数据库中的数据，主要是SELECT语句；</li>
<li>DML（Data Manipulation Language)：数据操纵语言，用于改变数据库中的数据，主要包括INSERT、UPDATE和DELETE语句；</li>
<li>DDL（Data Definition Language)：数据定义语言，用于库和表的创建、修改、删除。主要包括CREATE、DROP、ALTER语句；</li>
<li>DCL（Data Control Language)：数据控制语言，用于定义用户的访问权限和安全级别。主要包括GRANT和REVOKE语句；</li>
<li>TCL（Transaction Control Language)：事务控制语言，用于维护数据的一致性，包括COMMIT、ROLLBACK和SAVEPOINT语句。</li>
</ul>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <category term="数据库"/>
    <contributor>
      <name>南辞</name>
    </contributor>
    <published>2020-12-28T00:00:00.000Z</published>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">常用关系型数据库</title>
    <id>http://qiqi.dreamagain.top/software/database/SQL/</id>
    <link href="http://qiqi.dreamagain.top/software/database/SQL/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<h1 id="常用关系型数据库"> 常用关系型数据库</h1>
<h2 id="一、mysql"> 一、MySQL</h2>
<h2 id="二、oracle"> 二、Oracle</h2>
<h2 id="三、sql-server"> 三、SQL Server</h2>
<h2 id="四、postgresql"> 四、PostgreSQL</h2>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <contributor>
      <name>南辞</name>
    </contributor>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">数据库</title>
    <id>http://qiqi.dreamagain.top/software/database/</id>
    <link href="http://qiqi.dreamagain.top/software/database/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<h1 id="数据库"> 数据库</h1>
<h2 id="一、关系型数据库与菲关系型数据库的区别"> 一、关系型数据库与菲关系型数据库的区别</h2>
<h2 id="二、关系型数据库"> 二、关系型数据库</h2>
<h2 id="三、菲关系型数据库"> 三、菲关系型数据库</h2>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <contributor>
      <name>南辞</name>
    </contributor>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">代码编辑器</title>
    <id>http://qiqi.dreamagain.top/software/editor/</id>
    <link href="http://qiqi.dreamagain.top/software/editor/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<ul>
<li>
<p><a href="./vscode/">VS Code</a></p>
<p>VS Code 的全称是 Visual Studio Code，是一款开源的、免费的、跨平台的、高性能的、轻量级的代码编辑器。它在性能、语言支持、开源社区方面，都做的很不错。</p>
<p>VS Code 具有最大的编辑器社区，插件是所有编辑器里最全的。可以通过安装扩展实现几乎所有的功能，但扩展设置界面对新手不够友好，适合有一定经验的开发者。</p>
<div><p>提示</p>
<p>推荐使用轻量的 Visual Studio Code。</p>
</div>
</li>
<li>
<p>其他代码编辑器</p>
<p>在不同领域的开发者可能会偏向不同种类的开发工具。下面列举其他常见的代码编辑器。</p>
<ul>
<li>WebStorm 是专业的 web 开发工具，提供格式化、代码补全等选项。</li>
<li>PhpStorm 是专业的 php 开发工具，提供格式化、代码补全等选项。</li>
<li><a href="https://notepad-plus-plus.org/" target="_blank" rel="noopener noreferrer">notepad++</a></li>
<li><a href="https://atom.io/" target="_blank" rel="noopener noreferrer">atom</a></li>
<li><a href="https://www.sublimetext.com/3" target="_blank" rel="noopener noreferrer">sublime text</a></li>
</ul>
</li>
</ul>
<div><p>IDE 与编辑器</p>
<p>IDE 和编辑器是有区别的:</p>
<ul>
<li>
<p>IDE: 对代码会有较好的智能提示，同时侧重于工程项目，对项目的开发、调试工作有较好的图像化界面的支持，因此比较笨重。比如 Eclipse 的定位就是 IDE。</p>
</li>
<li>
<p>编辑器: 要相对轻量许多，侧重于文本的编辑。比如 Sublime Text 的定位就是编辑器。再比如 Windows 系统自带的「记事本」就是最简单的编辑器。</p>
</li>
</ul>
<p>需要注意的是，VS Code 的定位是编辑器，而非 IDE。但 VS Code 又比一般的编辑器的功能要丰富许多。</p>
</div>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <category term="编辑器"/>
    <contributor>
      <name>南辞</name>
    </contributor>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">分支管理</title>
    <id>http://qiqi.dreamagain.top/software/git/branch/</id>
    <link href="http://qiqi.dreamagain.top/software/git/branch/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<h2 id="概述"> 概述</h2>
<p>分支就是科幻电影里面的平行宇宙，当您正在电脑前努力学习 Git 的时候，另一个您正在另一个平行宇宙里努力学习 SVN。</p>
<p>如果两个平行宇宙互不干扰，那对现在的您也没啥影响。不过，在某个时间点，两个平行宇宙合并了，结果，您既学会了 Git 又学会了 SVN!</p>
<p><img src="./assets/learn-branches.png" alt="Learn branches"></p>
<p>分支在实际中有什么用呢? 假设您准备开发一个新功能，但是需要两周才能完成，第一周您写了 50% 的代码，如果立刻提交，由于代码还没写完，不完整的代码库会导致别人不能干活了。如果等代码全部写完再一次提交，又存在丢失每天进度的巨大风险。</p>
<p>现在有了分支，就不用怕了。您创建了一个属于您自己的分支，别人看不到，还继续在原来的分支上正常工作，而您在自己的分支上干活，想提交就提交，直到开发完毕后，再一次性合并到原来的分支上，这样，既安全，又不影响别人工作。</p>
<p>其他版本控制系统如 SVN 等都有分支管理，但是用过之后您会发现，这些版本控制系统创建和切换分支比蜗牛还慢，简直让人无法忍受，结果分支功能成了摆设，大家都不去用。</p>
<p>但 Git 的分支是与众不同的，无论创建、切换和删除分支，Git 在 1 秒钟之内就能完成! 无论您的版本库是 1 个文件还是 1 万个文件。</p>
<h2 id="创建与合并分支"> 创建与合并分支</h2>
<p>在版本回退里，您已经知道，每次提交，Git 都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在 Git 里，这个分支叫主分支，即 <code>master</code> 分支。<code>HEAD</code> 严格来说不是指向提交，而是指向 <code>master</code>，<code>master</code> 才是指向提交的，所以，<code>HEAD</code> 指向的就是当前分支。</p>
<p>一开始的时候，<code>master</code> 分支是一条线，Git 用 <code>master</code> 指向最新的提交，再用 <code>HEAD</code> 指向 <code>master</code>，就能确定当前分支，以及当前分支的提交点:</p>
<p><img src="./assets/git6.png" alt="示意图"></p>
<p>每次提交，<code>master</code> 分支都会向前移动一步，这样，随着您不断提交，<code>master</code> 分支的线也越来越长:</p>
<p>当我们创建新的分支，例如 dev 时，Git 新建了一个指针叫 <code>dev</code>，指向 <code>master</code> 相同的提交，再把 <code>HEAD</code> 指向 <code>dev</code>，就表示当前分支在 dev 上:</p>
<p><img src="./assets/git7.png" alt="示意图"></p>
<p>您看，Git 创建一个分支很快，因为除了增加一个 <code>dev</code> 指针，改改 <code>HEAD</code> 的指向，工作区的文件都没有任何变化!</p>
<p>不过，从现在开始，对工作区的修改和提交就是针对 dev 分支了，比如新提交一次后，<code>dev</code> 指针往前移动一步，而 <code>master</code> 指针不变:</p>
<p><img src="./assets/git8.png" alt="示意图"></p>
<p>假如我们在 dev 上的工作完成了，就可以把 dev 合并到 master 上。Git 怎么合并呢? 最简单的方法，就是直接把 master 指向 dev 的当前提交，就完成了合并:</p>
<p><img src="./assets/git9.png" alt="示意图"></p>
<p>所以 Git 合并分支也很快! 就改改指针，工作区内容也不变!</p>
<p>合并完分支后，甚至可以删除 dev 分支。删除 dev 分支就是把 dev 指针给删掉，删掉后，我们就剩下了一条 master 分支:</p>
<p><img src="./assets/git10.png" alt="示意图"></p>
<p>下面开始实战。首先，我们创建 dev 分支，然后切换到 dev 分支:</p>
<div><pre><code>$ <span>git</span> checkout -b dev
Switched to a new branch <span>'dev'</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><code>git checkout</code> 命令加上 <code>-b</code> 参数表示创建并切换，相当于以下两条命令:</p>
<div><pre><code>$ <span>git</span> branch dev
<span># nothing</span>
$ <span>git</span> checkout dev
Switched to branch <span>'dev'</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>然后，用 <code>git branch</code> 命令查看当前分支:</p>
<div><pre><code>$ <span>git</span> branch
* dev
  master
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><code>git branch</code> 命令会列出所有分支，当前分支前面会标一个 <code>*</code> 号。</p>
<p>然后，我们就可以在 dev 分支上正常提交，比如对 <code>readme.txt</code> 做个修改，加上一行:</p>
<div><pre><code>Creating a new branch is quick.
</code></pre>
<div><span>1</span><br></div></div><p>然后提交:</p>
<div><pre><code>$ <span>git</span> <span>add</span> readme.txt
<span># nothing</span>
$ <span>git</span> commit -m <span>"branch test"</span>
<span>[</span>dev b17d20e<span>]</span> branch <span>test</span>
 <span>1</span> <span>file</span> changed, <span>1</span> insertion<span>(</span>+<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>现在，dev 分支的工作完成，我们就可以切换回 master 分支:</p>
<div><pre><code>$ <span>git</span> checkout master
Switched to branch <span>'master'</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>切换回 master 分支后，再查看一个 <code>readme.txt</code> 文件，刚才添加的内容不见了! 因为那个提交是在 dev 分支上，而 master 分支此刻的提交点并没有变:</p>
<p><img src="./assets/git11.png" alt="示例图"></p>
<p>现在，我们把 dev 分支的工作成果合并到 master 分支上:</p>
<div><pre><code>$ <span>git</span> merge dev
Updating d46f35e<span>..</span>b17d20e
Fast-forward
 readme.txt <span>|</span> <span>1</span> +
 <span>1</span> <span>file</span> changed, <span>1</span> insertion<span>(</span>+<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p><code>git merge</code> 命令用于合并指定分支到当前分支。合并后，再查看 readme.txt 的内容，就可以看到，和 dev 分支的最新提交是完全一样的。</p>
<p>注意到上面的 <code>Fast-forward</code> 信息，Git 告诉我们，这次合并是 “快进模式”，也就是直接把 master 指向 dev 的当前提交，所以合并速度非常快。当然，也不是每次合并都能 <code>Fast-forward</code>。合并完成后，就可以放心地删除 dev 分支了:</p>
<div><pre><code>$ <span>git</span> branch -d dev
Deleted branch dev <span>(</span>was b17d20e<span>)</span>.
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>删除后，查看 <code>branch</code>，就只剩下 <code>master</code> 分支了:</p>
<div><pre><code>$ <span>git</span> branch
* master
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>因为创建、合并和删除分支非常快，所以 Git 鼓励您使用分支完成某个任务，合并后再删掉分支，这和直接在 <code>master</code> 分支上工作效果是一样的，但过程更安全。</p>
<h3 id="分支小结"> 分支小结</h3>
<ul>
<li>
<p>查看分支: <code>git branch</code></p>
</li>
<li>
<p>创建分支: <code>git branch &lt;name&gt;</code></p>
</li>
<li>
<p>切换分支: <code>git checkout &lt;name&gt;</code></p>
</li>
<li>
<p>创建+切换分支: <code>git checkout -b &lt;name&gt;</code></p>
</li>
<li>
<p>合并某分支到当前分支: <code>git merge &lt;name&gt;</code></p>
</li>
<li>
<p>删除分支: <code>git branch -d &lt;name&gt;</code></p>
</li>
</ul>
<hr>
<h2 id="冲突"> 冲突</h2>
<p>人生不如意之事十之八九，合并分支往往也不是一帆风顺的。</p>
<p>准备新的 <code>feature1</code> 分支，继续我们的新分支开发:</p>
<div><pre><code>$ <span>git</span> checkout -b feature1
Switched to a new branch <span>'feature1'</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>修改 readme.txt 最后一行，改为:</p>
<div><pre><code>Creating a new branch is quick AND simple.
</code></pre>
<div><span>1</span><br></div></div><p>在 <code>feature1</code> 分支上提交:</p>
<div><pre><code>git add readme.txt

\$ git commit -m "AND simple"
[feature1 14096d0] AND simple
1 file changed, 1 insertion(+), 1 deletion(-)
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>切换到 <code>master</code> 分支:</p>
<div><pre><code>$ <span>git</span> checkout master
Switched to branch <span>'master'</span>
Your branch is ahead of <span>'origin/master'</span> by <span>1</span> commit.
  <span>(</span>use <span>"git push"</span> to publish your <span>local</span> commits<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>Git 还会自动提示我们当前 <code>master</code> 分支比远程的 <code>master</code> 分支要超前 1 个提交。</p>
<p>在 <code>master</code> 分支上把 readme.txt 文件的最后一行改为:</p>
<div><pre><code>Creating a new branch is quick &amp; simple.
</code></pre>
<div><span>1</span><br></div></div><p>提交:</p>
<div><pre><code><span>git</span> <span>add</span> readme.txt
$ <span>git</span> commit -m <span>"&amp; simple"</span>
<span>[</span>master 5dc6824<span>]</span> <span>&amp;</span> simple
 <span>1</span> <span>file</span> changed, <span>1</span> insertion<span>(</span>+<span>)</span>, <span>1</span> deletion<span>(</span>-<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>现在，<code>master</code> 分支和 <code>feature1</code> 分支各自都分别有新的提交，变成了这样:</p>
<p><img src="./assets/git12.png" alt="示例图"></p>
<p>这种情况下，Git 无法执行“快速合并”，只能试图把各自的修改合并起来，但这种合并就可能会有冲突，我们试试看:</p>
<div><pre><code>$ <span>git</span> merge feature1
Auto-merging readme.txt
CONFLICT <span>(</span>content<span>)</span>: Merge conflict <span>in</span> readme.txt
Automatic merge failed<span>;</span> fix conflicts and <span>then</span> commit the result.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>果然冲突了! Git 告诉我们，<code>readme.txt</code> 文件存在冲突，必须手动解决冲突后再提交。<code>git status</code> 也可以告诉我们冲突的文件:</p>
<div><pre><code>$ <span>git</span> status
On branch master
Your branch is ahead of <span>'origin/master'</span> by <span>2</span> commits.
  <span>(</span>use <span>"git push"</span> to publish your <span>local</span> commits<span>)</span>

You have unmerged paths.
  <span>(</span>fix conflicts and run <span>"git commit"</span><span>)</span>
  <span>(</span>use <span>"git merge --abort"</span> to abort the merge<span>)</span>

Unmerged paths:
  <span>(</span>use <span>"git add &lt;file>..."</span> to mark resolution<span>)</span>

    both modified:   readme.txt

no changes added to commit <span>(</span>use <span>"git add"</span> and/or <span>"git commit -a"</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>我们可以直接查看 readme.txt 的内容:</p>
<div><pre><code>Git is a distributed version control system.
Git is free software distributed under the GPL.
Git has a mutable index called stage.
Git tracks changes of files.
<span><span>&lt;</span><span>&lt;&lt;&lt;&lt;&lt;&lt; HEAD
</span></span>Creating a new branch is quick &amp; simple.
=======
Creating a new branch is quick AND simple.
<span><span>></span><span>>>>>>> feature1
</span></span></code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>Git 用 <code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>，<code>=======</code>，<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code> 标记出不同分支的内容，我们修改如下后保存:</p>
<div><pre><code>Creating a new branch is quick and simple.
</code></pre>
<div><span>1</span><br></div></div><p>再提交:</p>
<div><pre><code>$ <span>git</span> <span>add</span> readme.txt
<span># nothing</span>
$ <span>git</span> commit -m <span>"conflict fixed"</span>
<span>[</span>master cf810e4<span>]</span> conflict fixed
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>现在，<code>master</code> 分支和 <code>feature1</code> 分支变成了下图所示:</p>
<p><img src="./assets/git13.png" alt="示例图"></p>
<p>用带参数的 <code>git log</code> 也可以看到分支的合并情况:</p>
<div><pre><code>$ <span>git</span> log --graph --pretty<span>=</span>oneline --abbrev-commit
*   cf810e4 <span>(</span>HEAD -<span>></span> master<span>)</span> conflict fixed
<span>|</span><span>\</span>
<span>|</span> * 14096d0 <span>(</span>feature1<span>)</span> AND simple
* <span>|</span> 5dc6824 <span>&amp;</span> simple
<span>|</span>/
* b17d20e branch <span>test</span>
* d46f35e <span>(</span>origin/master<span>)</span> remove test.txt
* b84166e <span>add</span> test.txt
* 519219b <span>git</span> tracks changes
* e43a48b understand how stage works
* 1094adb append GPL
* e475afc <span>add</span> distributed
* eaadf4e wrote a readme <span>file</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>最后，删除 feature1 分支:</p>
<div><pre><code>$ <span>git</span> branch -d feature1
Deleted branch feature1 <span>(</span>was 14096d0<span>)</span>.
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h3 id="冲突小结"> 冲突小结</h3>
<ul>
<li>
<p>当 Git 无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。解决冲突就是把 Git 合并失败的文件手动编辑为我们希望的内容，再提交。</p>
</li>
<li>
<p>用 <code>git log --graph</code> 命令可以看到分支合并图。</p>
</li>
</ul>
<h2 id="分支管理策略"> 分支管理策略</h2>
<p>通常，合并分支时，如果可能，Git 会用 <code>Fast forward</code> 模式，但这种模式下，删除分支后，会丢掉分支信息。</p>
<p>如果要强制禁用 <code>Fast forward</code> 模式，Git 就会在 merge 时生成一个新的 commit，这样，从分支历史上就可以看出分支信息。</p>
<p>实战一下 <code>--no-ff</code> 方式的 <code>git merge</code>。首先，仍然创建并切换 <code>dev</code> 分支:</p>
<div><pre><code>$ <span>git</span> checkout -b dev
Switched to a new branch <span>'dev'</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>修改 readme.txt 文件，并提交一个新的 <code>commit</code>:</p>
<div><pre><code>$ <span>git</span> <span>add</span> readme.txt
<span># nothing</span>
$ <span>git</span> commit -m <span>"add merge"</span>
<span>[</span>dev f52c633<span>]</span> <span>add</span> merge
 <span>1</span> <span>file</span> changed, <span>1</span> insertion<span>(</span>+<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>现在，我们切换回 <code>master</code>:</p>
<div><pre><code>$ <span>git</span> checkout master
Switched to branch <span>'master'</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>准备合并 <code>dev</code> 分支，请注意 <code>--no-ff</code> 参数，表示禁用 <code>Fast forward</code>:</p>
<div><pre><code>$ <span>git</span> merge --no-ff -m <span>"merge with no-ff"</span> dev
Merge made by the <span>'recursive'</span> strategy.
 readme.txt <span>|</span> <span>1</span> +
 <span>1</span> <span>file</span> changed, <span>1</span> insertion<span>(</span>+<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>因为本次合并要创建一个新的 <code>commit</code>，所以加上 <code>-m</code> 参数，把 <code>commit</code> 描述写进去。</p>
<p>合并后，我们用 <code>git log</code> 看看分支历史:</p>
<div><pre><code>$ <span>git</span> log --graph --pretty<span>=</span>oneline --abbrev-commit
*   e1e9c68 <span>(</span>HEAD -<span>></span> master<span>)</span> merge with no-ff
<span>|</span><span>\</span>
<span>|</span> * f52c633 <span>(</span>dev<span>)</span> <span>add</span> merge
<span>|</span>/
*   cf810e4 conflict fixed
<span>..</span>.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>可以看到，不使用 <code>Fast forward</code> 模式，<code>merge</code> 后就像这样:</p>
<p><img src="./assets/git14.png" alt="示例图"></p>
<h3 id="分支管理惯例"> 分支管理惯例</h3>
<p>在实际开发中，我们应该按照几个基本原则进行分支管理:</p>
<p>首先，<code>master</code> 分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；</p>
<p>那在哪干活呢? 干活都在 <code>dev</code> 分支上，也就是说，<code>dev</code> 分支是不稳定的，到某个时候，比如 <code>1.0</code> 版本发布时，再把 <code>dev</code> 分支合并到 <code>master</code> 上，在 <code>master</code> 分支发布 <code>1.0</code> 版本；</p>
<p>您和您的小伙伴们每个人都在 <code>dev</code> 分支上干活，每个人都有自己的分支，时不时地往 <code>dev</code> 分支上合并就可以了。</p>
<p>所以，团队合作的分支看起来就像这样:</p>
<p><img src="./assets/git15.png" alt="示例图"></p>
<h3 id="分支管理小结"> 分支管理小结</h3>
<ul>
<li>
<p>Git 分支十分强大，在团队开发中应该充分应用。</p>
</li>
<li>
<p>合并分支时，加上 <code>--no-ff</code> 参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而 <code>fast forward</code> 合并就看不出来曾经做过合并。</p>
</li>
</ul>
<hr>
<h2 id="bug-分支"> Bug 分支</h2>
<p>软件开发中，bug 就像家常便饭一样。有了 bug 就需要修复，在 Git 中，由于分支是如此的强大，所以，每个 bug 都可以通过一个新的临时分支来修复，修复后，合并分支，然后将临时分支删除。</p>
<p>当您接到一个修复一个代号 101 的 bug 的任务时，很自然地，您想创建一个分支 <code>issue-101</code> 来修复它，但是，等等，当前正在 dev 上进行的工作还没有提交:</p>
<div><pre><code>$ <span>git</span> status
On branch dev
Changes to be committed:
  <span>(</span>use <span>"git reset HEAD &lt;file>..."</span> to unstage<span>)</span>

    new file:   hello.py

Changes not staged <span>for</span> commit:
  <span>(</span>use <span>"git add &lt;file>..."</span> to update what will be committed<span>)</span>
  <span>(</span>use <span>"git checkout -- &lt;file>..."</span> to discard changes <span>in</span> working directory<span>)</span>

    modified:   readme.txt
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>并不是您不想提交，而是工作只进行到一半，还没法提交，预计完成还需 1 天时间。但是，必须在两个小时内修复该 bug，怎么办?</p>
<p>幸好，Git 还提供了一个 <code>stash</code> 功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作:</p>
<div><pre><code>$ <span>git</span> stash
Saved working directory and index state WIP on dev: f52c633 <span>add</span> merge
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>现在，用 <code>git status</code> 查看工作区，就是干净的(除非有没有被 Git 管理的文件)，因此可以放心地创建分支来修复 bug。</p>
<p>首先确定要在哪个分支上修复 bug，假定需要在 master 分支上修复，就从 master 创建临时分支:</p>
<div><pre><code>$ <span>git</span> checkout master
Switched to branch <span>'master'</span>
Your branch is ahead of <span>'origin/master'</span> by <span>6</span> commits.
  <span>(</span>use <span>"git push"</span> to publish your <span>local</span> commits<span>)</span>

$ <span>git</span> checkout -b issue-101
Switched to a new branch <span>'issue-101'</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>现在修复 bug，需要把“Git is free software ...”改为“Git is a free software ...”，然后提交:</p>
<div><pre><code><span>git</span> <span>add</span> readme.txt
$ <span>git</span> commit -m <span>"fix bug 101"</span>
<span>[</span>issue-101 4c805e2<span>]</span> fix bug <span>101</span>
 <span>1</span> <span>file</span> changed, <span>1</span> insertion<span>(</span>+<span>)</span>, <span>1</span> deletion<span>(</span>-<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>修复完成后，切换到 <code>master</code> 分支，并完成合并，最后删除 <code>issue-101</code> 分支:</p>
<div><pre><code>$ <span>git</span> checkout master
Switched to branch <span>'master'</span>
Your branch is ahead of <span>'origin/master'</span> by <span>6</span> commits.
  <span>(</span>use <span>"git push"</span> to publish your <span>local</span> commits<span>)</span>

$ <span>git</span> merge --no-ff -m <span>"merged bug fix 101"</span> issue-101
Merge made by the <span>'recursive'</span> strategy.
 readme.txt <span>|</span> <span>2</span> +-
 <span>1</span> <span>file</span> changed, <span>1</span> insertion<span>(</span>+<span>)</span>, <span>1</span> deletion<span>(</span>-<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>太棒了，原计划两个小时的 bug 修复只花了 5 分钟! 现在，是时候接着回到 <code>dev</code> 分支干活了!</p>
<div><pre><code>$ <span>git</span> checkout dev
Switched to branch <span>'dev'</span>

$ <span>git</span> status
On branch dev
nothing to commit, working tree clean
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>工作区是干净的，刚才的工作现场存到哪去了? 用 <code>git stash list</code> 命令看看:</p>
<div><pre><code>$ <span>git</span> stash list
stash@<span>{</span><span>0</span><span>}</span>: WIP on dev: f52c633 <span>add</span> merge
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>工作现场还在，Git 把 stash 内容存在某个地方了，但是需要恢复一下，有两个办法:</p>
<p>一是用 <code>git stash apply</code> 恢复，但是恢复后，<code>stash</code> 内容并不删除，您需要用 <code>git stash drop</code> 来删除；</p>
<p>另一种方式是用 <code>git stash pop</code>，恢复的同时把 <code>stash</code> 内容也删了:</p>
<div><pre><code>$ <span>git</span> stash pop
On branch dev
Changes to be committed:
  <span>(</span>use <span>"git reset HEAD &lt;file>..."</span> to unstage<span>)</span>

    new file:   hello.py

Changes not staged <span>for</span> commit:
  <span>(</span>use <span>"git add &lt;file>..."</span> to update what will be committed<span>)</span>
  <span>(</span>use <span>"git checkout -- &lt;file>..."</span> to discard changes <span>in</span> working directory<span>)</span>

    modified:   readme.txt

Dropped refs/stash@<span>{</span><span>0</span><span>}</span> <span>(</span>5d677e2ee266f39ea296182fb2354265b91b3b2a<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>再用 <code>git stash list</code> 查看，就看不到任何 stash 内容了。您可以多次 stash，恢复的时候，先用 <code>git stash list</code> 查看，然后恢复指定的 stash，用命令:</p>
<div><pre><code><span>git</span> stash apply stash@<span>{</span><span>0</span><span>}</span>
</code></pre>
<div><span>1</span><br></div></div><h3 id="暂存小结"> 暂存小结</h3>
<ul>
<li>
<p>修复 bug 时，我们会通过创建新的 bug 分支进行修复，然后合并，最后删除；</p>
</li>
<li>
<p>当手头工作没有完成时，先把工作现场 <code>git stash</code> 一下，然后去修复 bug，修复后，再 <code>git stash pop</code>，回到工作现场。</p>
</li>
</ul>
<hr>
<h2 id="feature-分支"> Feature 分支</h2>
<p>软件开发中，总有无穷无尽的新的功能要不断添加进来。</p>
<p>添加一个新功能时，您肯定不希望因为一些实验性质的代码，把主分支搞乱了，所以，每添加一个新功能，最好新建一个 <code>feature</code> 分支，在上面开发，完成后，合并，最后，删除该 <code>feature</code> 分支。</p>
<p>现在，您终于接到了一个新任务: 开发代号为 <code>Vulcan</code> 的新功能，该功能计划用于下一代星际飞船。</p>
<p>于是准备开发:</p>
<div><pre><code>$ <span>git</span> checkout -b feature-vulcan
Switched to a new branch <span>'feature-vulcan'</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>5 分钟后，开发完毕:</p>
<div><pre><code><span>git</span> <span>add</span> vulcan.py

$ <span>git</span> status
On branch feature-vulcan
Changes to be committed:
  <span>(</span>use <span>"git reset HEAD &lt;file>..."</span> to unstage<span>)</span>

    new file:   vulcan.py

$ <span>git</span> commit -m <span>"add feature vulcan"</span>
<span>[</span>feature-vulcan 287773e<span>]</span> <span>add</span> feature vulcan
 <span>1</span> <span>file</span> changed, <span>2</span> insertions<span>(</span>+<span>)</span>
 create mode <span>100644</span> vulcan.py
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>切回 <code>dev</code>，准备合并:</p>
<div><pre><code><span>git</span> checkout dev
</code></pre>
<div><span>1</span><br></div></div><p>一切顺利的话，feature 分支和 bug 分支是类似的，合并，然后删除。</p>
<p>但是!</p>
<p>就在此时，接到上级命令，因经费不足，新功能必须取消!</p>
<p>虽然白干了，但是这个包含机密资料的分支还是必须就地销毁:</p>
<div><pre><code>$ <span>git</span> branch -d feature-vulcan
error: The branch <span>'feature-vulcan'</span> is not fully merged.
If you are sure you want to delete it, run <span>'git branch -D feature-vulcan'</span><span>.</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>销毁失败。Git 友情提醒，feature-vulcan 分支还没有被合并，如果删除，将丢失掉修改，如果要强行删除，需要使用大写的 <code>-D</code> 参数。。</p>
<p>现在我们强行删除:</p>
<div><pre><code>$ <span>git</span> branch -D feature-vulcan
Deleted branch feature-vulcan <span>(</span>was 287773e<span>)</span>.
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>终于删除成功!</p>
<h3 id="删除小结"> 删除小结</h3>
<ul>
<li>
<p>开发一个新 feature，最好新建一个分支；</p>
</li>
<li>
<p>如果要丢弃一个没有被合并过的分支，可以通过 <code>git branch -D &lt;name&gt;</code> 强行删除。</p>
</li>
</ul>
<hr>
<h2 id="多人协作"> 多人协作</h2>
<p>当您从远程仓库克隆时，实际上 Git 自动把本地的 <code>master</code> 分支和远程的 <code>master</code> 分支对应起来了，并且，远程仓库的默认名称是 <code>origin</code>。</p>
<p>要查看远程库的信息，用 <code>git remote</code>:</p>
<div><pre><code>$ <span>git</span> remote
origin
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>或者，用 <code>git remote -v</code> 显示更详细的信息:</p>
<div><pre><code>$ <span>git</span> remote -v
origin  git@github.com:Hope-Studio/learngit.git <span>(</span>fetch<span>)</span>
origin  git@github.com:Hope-Studio/learngit.git <span>(</span>push<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>上面显示了可以抓取和推送的 <code>origin</code> 的地址。如果没有推送权限，就看不到 push 的地址。</p>
<h3 id="推送分支"> 推送分支</h3>
<p>推送分支，就是把该分支上的所有本地提交推送到远程库。推送时，要指定本地分支，这样，Git 就会把该分支推送到远程库对应的远程分支上:</p>
<div><pre><code><span>git</span> push origin master
</code></pre>
<div><span>1</span><br></div></div><p>如果要推送其他分支，比如 <code>dev</code>，就改成:</p>
<div><pre><code><span>git</span> push origin dev
</code></pre>
<div><span>1</span><br></div></div><p>但是，并不是一定要把本地分支往远程推送，那么，哪些分支需要推送，哪些不需要呢?</p>
<p><code>master</code> 分支是主分支，因此要时刻与远程同步；</p>
<p><code>dev</code> 分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步；</p>
<p><code>bug</code> 分支只用于在本地修复 bug，就没必要推到远程了，除非老板要看看您每周到底修复了几个 bug；</p>
<p><code>feature</code> 分支是否推到远程，取决于您是否和您的小伙伴合作在上面开发。</p>
<p>总之，就是在 Git 中，分支完全可以在本地自己藏着玩，是否推送，视您的心情而定!</p>
<h3 id="抓取分支"> 抓取分支</h3>
<p>多人协作时，大家都会往 <code>master</code> 和 <code>dev</code> 分支上推送各自的修改。</p>
<p>现在，模拟一个您的小伙伴，可以在另一台电脑 (注意要把 SSH Key 添加到 GitHub) 或者同一台电脑的另一个目录下克隆:</p>
<div><pre><code>$ <span>git</span> clone git@github.com:Hope-Studio/learngit.git
Cloning into <span>'learngit'</span><span>..</span>.
remote: Counting objects: <span>40</span>, done.
remote: Compressing objects: <span>100</span>% <span>(</span><span>21</span>/21<span>)</span>, done.
remote: Total <span>40</span> <span>(</span>delta <span>14</span><span>)</span>, reused <span>40</span> <span>(</span>delta <span>14</span><span>)</span>, pack-reused <span>0</span>
Receiving objects: <span>100</span>% <span>(</span><span>40</span>/40<span>)</span>, done.
Resolving deltas: <span>100</span>% <span>(</span><span>14</span>/14<span>)</span>, done.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>当您的小伙伴从远程库 clone 时，默认情况下，您的小伙伴只能看到本地的 <code>master</code> 分支。不信可以用 <code>git branch</code> 命令看看:</p>
<div><pre><code>$ <span>git</span> branch
* master
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>现在，您的小伙伴要在 <code>dev</code> 分支上开发，就必须创建远程 <code>origin</code> 的 <code>dev</code> 分支到本地，于是他用这个命令创建本地 <code>dev</code> 分支:</p>
<div><pre><code><span>git</span> checkout -b dev origin/dev
</code></pre>
<div><span>1</span><br></div></div><p>现在，他就可以在 <code>dev</code> 上继续修改，然后，时不时地把 <code>dev</code> 分支 push 到远程:</p>
<div><pre><code><span>git</span> <span>add</span> env.txt

$ <span>git</span> commit -m <span>"add env"</span>
<span>[</span>dev 7a5e5dd<span>]</span> <span>add</span> <span>env</span>
 <span>1</span> <span>file</span> changed, <span>1</span> insertion<span>(</span>+<span>)</span>
 create mode <span>100644</span> env.txt

$ <span>git</span> push origin dev
Counting objects: <span>3</span>, done.
Delta compression using up to <span>4</span> threads.
Compressing objects: <span>100</span>% <span>(</span><span>2</span>/2<span>)</span>, done.
Writing objects: <span>100</span>% <span>(</span><span>3</span>/3<span>)</span>, <span>308</span> bytes <span>|</span> <span>308.00</span> KiB/s, done.
Total <span>3</span> <span>(</span>delta <span>0</span><span>)</span>, reused <span>0</span> <span>(</span>delta <span>0</span><span>)</span>
To github.com:Hope-Studio/learngit.git
   f52c633<span>..</span>7a5e5dd  dev -<span>></span> dev
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>您的小伙伴已经向 <code>origin/dev</code> 分支推送了他的提交，想要获取他的工作，您可以执行 <code>git fetch origin dev</code>。</p>
<p>如果这时碰巧您也对同样的文件作了修改，并试图推送:</p>
<div><pre><code>$ <span>cat</span> env.txt
<span>env</span>

<span>git</span> <span>add</span> env.txt

$ <span>git</span> commit -m <span>"add new env"</span>
<span>[</span>dev 7bd91f1<span>]</span> <span>add</span> new <span>env</span>
 <span>1</span> <span>file</span> changed, <span>1</span> insertion<span>(</span>+<span>)</span>
 create mode <span>100644</span> env.txt

$ <span>git</span> push origin dev
To github.com:Hope-Studio/learngit.git
 <span>!</span> <span>[</span>rejected<span>]</span>        dev -<span>></span> dev <span>(</span>non-fast-forward<span>)</span>
error: failed to push some refs to <span>'git@github.com:Hope-Studio/learngit.git'</span>
hint: Updates were rejected because the tip of your current branch is behind
hint: its remote counterpart. Integrate the remote changes <span>(</span>e.g.
hint: <span>'git pull ...'</span><span>)</span> before pushing again.
hint: See the <span>'Note about fast-forwards'</span> <span>in</span> <span>'git push --help'</span> <span>for</span> details.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><p>推送失败，因为您的小伙伴的最新提交和您试图推送的提交有冲突，解决办法也很简单，Git 已经提示我们，先用 <code>git pull</code> 把最新的提交从 <code>origin/dev</code> 抓下来，然后，在本地合并，解决冲突，再推送:</p>
<div><pre><code>$ <span>git</span> pull
There is no tracking information <span>for</span> the current branch.
Please specify <span>which</span> branch you want to merge with.
See git-pull<span>(</span><span>1</span><span>)</span> <span>for</span> details.

    <span>git</span> pull <span>&lt;</span>remote<span>></span> <span>&lt;</span>branch<span>></span>

If you wish to <span>set</span> tracking information <span>for</span> this branch you can <span>do</span> so with:

    <span>git</span> branch --set-upstream-to<span>=</span>origin/<span>&lt;</span>branch<span>></span> dev
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p><code>git pull</code> 也失败了，原因是没有指定本地 <code>dev</code> 分支与远程 <code>origin/dev</code> 分支的链接，根据提示，设置 <code>dev</code> 和 <code>origin/dev</code> 的链接:</p>
<div><pre><code>$ <span>git</span> branch --set-upstream-to<span>=</span>origin/dev dev
Branch <span>'dev'</span> <span>set</span> up to track remote branch <span>'dev'</span> from <span>'origin'</span><span>.</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>再 pull:</p>
<div><pre><code>$ <span>git</span> pull
Auto-merging env.txt
CONFLICT <span>(</span>add/add<span>)</span>: Merge conflict <span>in</span> env.txt
Automatic merge failed<span>;</span> fix conflicts and <span>then</span> commit the result.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>这回 <code>git pull</code> 成功，但是合并有冲突，需要手动解决，解决的方法和分支管理中的解决冲突完全一样。解决后，提交，再 push:</p>
<div><pre><code>$ <span>git</span> commit -m <span>"fix env conflict"</span>
<span>[</span>dev 57c53ab<span>]</span> fix <span>env</span> conflict

$ <span>git</span> push origin dev
Counting objects: <span>6</span>, done.
Delta compression using up to <span>4</span> threads.
Compressing objects: <span>100</span>% <span>(</span><span>4</span>/4<span>)</span>, done.
Writing objects: <span>100</span>% <span>(</span><span>6</span>/6<span>)</span>, <span>621</span> bytes <span>|</span> <span>621.00</span> KiB/s, done.
Total <span>6</span> <span>(</span>delta <span>0</span><span>)</span>, reused <span>0</span> <span>(</span>delta <span>0</span><span>)</span>
To github.com:Hope-Studio/learngit.git
   7a5e5dd<span>..</span>57c53ab  dev -<span>></span> dev
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>因此，多人协作的工作模式通常是这样:</p>
<p>首先，可以试图用 <code>git push origin &lt;branch-name&gt;</code> 推送自己的修改；</p>
<p>如果推送失败，则因为远程分支比您的本地更新，需要先用 <code>git pull</code> 试图合并；</p>
<p>如果合并有冲突，则解决冲突，并在本地提交；</p>
<p>没有冲突或者解决掉冲突后，再用 <code>git push origin &lt;branch-name&gt;</code> 推送就能成功!</p>
<p>如果 <code>git pull</code> 提示 <code>no tracking information</code>，则说明本地分支和远程分支的链接关系没有创建，用命令 <code>git branch --set-upstream-to &lt;branch-name&gt; origin/&lt;branch-name&gt;</code>。</p>
<p>这就是多人协作的工作模式，一旦熟悉了，就非常简单。</p>
<h3 id="多人协作小结"> 多人协作小结</h3>
<ul>
<li>
<p>查看远程库信息，使用 <code>git remote -v</code>；</p>
</li>
<li>
<p>本地新建的分支如果不推送到远程，对其他人就是不可见的；</p>
</li>
<li>
<p>从本地推送分支，使用 <code>git push origin branch-name</code>，如果推送失败，先用 <code>git pull</code> 抓取远程的新提交；</p>
</li>
<li>
<p>在本地创建和远程分支对应的分支，使用 <code>git checkout -b branch-name origin/branch-name</code>，本地和远程分支的名称最好一致；</p>
</li>
<li>
<p>建立本地分支和远程分支的关联，使用 <code>git branch --set-upstream branch-name origin/branch-name</code>；</p>
</li>
<li>
<p>从远程拉取分支，使用 <code>git fetch</code>。</p>
</li>
<li>
<p><code>git pull</code>，相当于 <code>git fetch</code> + <code>git merge</code>，如果您的修改并没有和远程的修改发生冲突，两者会自动合并到您的本地，您可以直接推送上去。如果有冲突，要先处理冲突。</p>
</li>
</ul>
<hr>
<h2 id="rebase"> Rebase</h2>
<p>在上一节我们看到了，多人在同一个分支上协作时，很容易出现冲突。即使没有冲突，后 <code>push</code> 的童鞋不得不先 <code>pull</code>，在本地合并，然后才能 <code>push</code> 成功。</p>
<p>每次合并再 <code>push</code> 后，分支变成了这样:</p>
<div><pre><code>$ <span>git</span> log --graph --pretty<span>=</span>oneline --abbrev-commit
* d1be385 <span>(</span>HEAD -<span>></span> master, origin/master<span>)</span> init hello
*   e5e69f1 Merge branch <span>'dev'</span>
<span>|</span><span>\</span>
<span>|</span> *   57c53ab <span>(</span>origin/dev, dev<span>)</span> fix <span>env</span> conflict
<span>|</span> <span>|</span><span>\</span>
<span>|</span> <span>|</span> * 7a5e5dd <span>add</span> <span>env</span>
<span>|</span> * <span>|</span> 7bd91f1 <span>add</span> new <span>env</span>
<span>|</span> <span>|</span>/
* <span>|</span>   12a631b merged bug fix <span>101</span>
<span>|</span><span>\</span> <span>\</span>
<span>|</span> * <span>|</span> 4c805e2 fix bug <span>101</span>
<span>|</span>/ /
* <span>|</span>   e1e9c68 merge with no-ff
<span>|</span><span>\</span> <span>\</span>
<span>|</span> <span>|</span>/
<span>|</span> * f52c633 <span>add</span> merge
<span>|</span>/
*   cf810e4 conflict fixed
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><p>总之看上去很乱，有强迫症的童鞋会问: 为什么 Git 的提交历史不能是一条干净的直线? 其实是可以做到的!</p>
<p>Git 有一种称为 <code>rebase</code> 的操作，有人把它翻译成“变基”。</p>
<p>先不要随意展开想象。我们还是从实际问题出发，看看怎么把分叉的提交变成直线。</p>
<p>在和远程分支同步后，我们对 <code>hello.py</code> 这个文件做了两次提交。用 <code>git log</code> 命令看看:</p>
<div><pre><code>$ <span>git</span> log --graph --pretty<span>=</span>oneline --abbrev-commit
* 582d922 <span>(</span>HEAD -<span>></span> master<span>)</span> <span>add</span> author
* <span>8875536</span> <span>add</span> comment
* d1be385 <span>(</span>origin/master<span>)</span> init hello
*   e5e69f1 Merge branch <span>'dev'</span>
<span>|</span><span>\</span>
<span>|</span> *   57c53ab <span>(</span>origin/dev, dev<span>)</span> fix <span>env</span> conflict
<span>|</span> <span>|</span><span>\</span>
<span>|</span> <span>|</span> * 7a5e5dd <span>add</span> <span>env</span>
<span>|</span> * <span>|</span> 7bd91f1 <span>add</span> new <span>env</span>
<span>..</span>.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>注意到 Git 用 <code>(HEAD -&gt; master)</code> 和 <code>(origin/master)</code> 标识出当前分支的 <code>HEAD</code> 和远程 <code>origin</code> 的位置分别是 <code>582d922 add author</code> 和 <code>d1be385 init hello</code>，本地分支比远程分支快两个提交。</p>
<p>现在我们尝试推送本地分支:</p>
<div><pre><code>$ <span>git</span> push origin master
To github.com:Hope-Studio/learngit.git
 <span>!</span> <span>[</span>rejected<span>]</span>        master -<span>></span> master <span>(</span>fetch first<span>)</span>
error: failed to push some refs to <span>'git@github.com:Hope-Studio/learngit.git'</span>
hint: Updates were rejected because the remote contains work that you <span>do</span>
hint: not have locally. This is usually caused by another repository pushing
hint: to the same ref. You may want to first integrate the remote changes
hint: <span>(</span>e.g., <span>'git pull ...'</span><span>)</span> before pushing again.
hint: See the <span>'Note about fast-forwards'</span> <span>in</span> <span>'git push --help'</span> <span>for</span> details.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>很不幸，失败了，这说明有人先于我们推送了远程分支。按照经验，先 pull 一下:</p>
<div><pre><code>$ <span>git</span> pull
remote: Counting objects: <span>3</span>, done.
remote: Compressing objects: <span>100</span>% <span>(</span><span>1</span>/1<span>)</span>, done.
remote: Total <span>3</span> <span>(</span>delta <span>1</span><span>)</span>, reused <span>3</span> <span>(</span>delta <span>1</span><span>)</span>, pack-reused <span>0</span>
Unpacking objects: <span>100</span>% <span>(</span><span>3</span>/3<span>)</span>, done.
From github.com:Hope-Studio/learngit
   d1be385<span>..</span>f005ed4  master     -<span>></span> origin/master
 * <span>[</span>new tag<span>]</span>         v1.0       -<span>></span> v1.0
Auto-merging hello.py
Merge made by the <span>'recursive'</span> strategy.
 hello.py <span>|</span> <span>1</span> +
 <span>1</span> <span>file</span> changed, <span>1</span> insertion<span>(</span>+<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>再用 <code>git status</code> 看看状态:</p>
<div><pre><code>$ <span>git</span> status
On branch master
Your branch is ahead of <span>'origin/master'</span> by <span>3</span> commits.
  <span>(</span>use <span>"git push"</span> to publish your <span>local</span> commits<span>)</span>

nothing to commit, working tree clean
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>加上刚才合并的提交，现在我们本地分支比远程分支超前 3 个提交。</p>
<p>用 <code>git log</code> 看看:</p>
<div><pre><code>$ <span>git</span> log --graph --pretty<span>=</span>oneline --abbrev-commit
*   e0ea545 <span>(</span>HEAD -<span>></span> master<span>)</span> Merge branch <span>'master'</span> of github.com:Hope-Studio/learngit
<span>|</span><span>\</span>
<span>|</span> * f005ed4 <span>(</span>origin/master<span>)</span> <span>set</span> <span>exit</span><span>=</span><span>1</span>
* <span>|</span> 582d922 <span>add</span> author
* <span>|</span> <span>8875536</span> <span>add</span> comment
<span>|</span>/
* d1be385 init hello
<span>..</span>.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>对强迫症童鞋来说，现在事情有点不对头，提交历史分叉了。如果现在把本地分支 <code>push</code> 到远程，有没有问题?</p>
<p>有!</p>
<p>什么问题?</p>
<p>不好看!</p>
<p>有没有解决方法?</p>
<p>有!</p>
<p>这个时候，rebase 就派上了用场。我们输入命令 <code>git rebase</code> 试试:</p>
<div><pre><code>$ <span>git</span> rebase
First, rewinding <span>head</span> to replay your work on <span>top</span> of it<span>..</span>.
Applying: <span>add</span> comment
Using index info to reconstruct a base tree<span>..</span>.
M    hello.py
Falling back to patching base and <span>3</span>-way merge<span>..</span>.
Auto-merging hello.py
Applying: <span>add</span> author
Using index info to reconstruct a base tree<span>..</span>.
M    hello.py
Falling back to patching base and <span>3</span>-way merge<span>..</span>.
Auto-merging hello.py
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>输出了一大堆操作，到底是啥效果? 再用 <code>git log</code> 看看:</p>
<div><pre><code>$ <span>git</span> log --graph --pretty<span>=</span>oneline --abbrev-commit
* 7e61ed4 <span>(</span>HEAD -<span>></span> master<span>)</span> <span>add</span> author
* 3611cfe <span>add</span> comment
* f005ed4 <span>(</span>origin/master<span>)</span> <span>set</span> <span>exit</span><span>=</span><span>1</span>
* d1be385 init hello
<span>..</span>.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>原本分叉的提交现在变成一条直线了! 这种神奇的操作是怎么实现的? 其实原理非常简单。我们注意观察，发现 Git 把我们本地的提交“挪动”了位置，放到了 <code>f005ed4 (origin/master) set exit=1</code> 之后，这样，整个提交历史就成了一条直线。<code>rebase</code> 操作前后，最终的提交内容是一致的，但是，我们本地的 commit 修改内容已经变化了，它们的修改不再基于 <code>d1be385 init hello</code>，而是基于 <code>f005ed4 (origin/master) set exit=1</code>，但最后的提交 <code>7e61ed4</code> 内容是一致的。</p>
<p>这就是 <code>rebase</code> 操作的特点: 把分叉的提交历史“整理”成一条直线，看上去更直观。缺点是本地的分叉提交已经被修改过了。</p>
<p>最后，通过 <code>push</code> 操作把本地分支推送到远程:</p>
<div><pre><code>Mac:~/learngit michael$ <span>git</span> push origin master
Counting objects: <span>6</span>, done.
Delta compression using up to <span>4</span> threads.
Compressing objects: <span>100</span>% <span>(</span><span>5</span>/5<span>)</span>, done.
Writing objects: <span>100</span>% <span>(</span><span>6</span>/6<span>)</span>, <span>576</span> bytes <span>|</span> <span>576.00</span> KiB/s, done.
Total <span>6</span> <span>(</span>delta <span>2</span><span>)</span>, reused <span>0</span> <span>(</span>delta <span>0</span><span>)</span>
remote: Resolving deltas: <span>100</span>% <span>(</span><span>2</span>/2<span>)</span>, completed with <span>1</span> <span>local</span> object.
To github.com:Hope-Studio/learngit.git
   f005ed4<span>..</span>7e61ed4  master -<span>></span> master
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>再用 <code>git log</code> 看看效果:</p>
<div><pre><code>$ <span>git</span> log --graph --pretty<span>=</span>oneline --abbrev-commit
* 7e61ed4 <span>(</span>HEAD -<span>></span> master, origin/master<span>)</span> <span>add</span> author
* 3611cfe <span>add</span> comment
* f005ed4 <span>set</span> <span>exit</span><span>=</span><span>1</span>
* d1be385 init hello
<span>..</span>.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>远程分支的提交历史也是一条直线。</p>
<h2 id="rebase-小结"> Rebase 小结</h2>
<ul>
<li>
<p><code>rebase</code> 操作可以把本地未 <code>push</code> 的分叉提交历史整理成直线；</p>
</li>
<li>
<p><code>rebase</code> 的目的是使得我们在查看历史提交的变化时更容易，因为分叉的提交需要三方对比。</p>
</li>
</ul>
]]></content>
    <author>
      <name>廖雪峰</name>
    </author>
    <category term="Git"/>
    <contributor>
      <name>廖雪峰</name>
    </contributor>
    <rights>Copyright by 廖雪峰 Edited by Mr.Hope</rights>
  </entry>
  <entry>
    <title type="html">修改管理</title>
    <id>http://qiqi.dreamagain.top/software/git/change/</id>
    <link href="http://qiqi.dreamagain.top/software/git/change/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<h2 id="管理修改"> 管理修改</h2>
<p>Git 比其他版本控制系统设计得优秀，因为 Git 跟踪并管理的是修改，而非文件。</p>
<p>您会问，什么是修改? 比如您新增了一行，这就是一个修改，删除了一行，也是一个修改，更改了某些字符，也是一个修改，删了一些又加了一些，也是一个修改，甚至创建一个新文件，也算一个修改。</p>
<p>为什么说 Git 管理的是修改，而不是文件呢? 我们还是做实验。第一步，对 readme.txt 做一个修改，比如加一行内容:</p>
<div><pre><code>$ <span>cat</span> readme.txt
Git is a distributed version control system.
Git is <span>free</span> software distributed under the GPL.
Git has a mutable index called stage.
Git tracks changes.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>然后，添加:</p>
<div><pre><code>$ <span>git</span> <span>add</span> readme.txt
<span># nothing</span>
$ <span>git</span> status
  On branch master
  Changes to be committed:
    <span>(</span>use <span>"git reset HEAD &lt;file>..."</span> to unstage<span>)</span>
        modified:   readme.txt
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>然后，再修改 readme.txt:</p>
<div><pre><code>$ <span>cat</span> readme.txt
Git is a distributed version control system.
Git is <span>free</span> software distributed under the GPL.
Git has a mutable index called stage.
Git tracks changes of files.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>提交:</p>
<div><pre><code>$ <span>git</span> commit -m <span>"git tracks changes"</span>
<span>[</span>master 519219b<span>]</span> <span>git</span> tracks changes
 <span>1</span> <span>file</span> changed, <span>1</span> insertion<span>(</span>+<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>提交后，再看看状态:</p>
<div><pre><code>$ <span>git</span> status
On branch master
Changes not staged <span>for</span> commit:
  <span>(</span>use <span>"git add &lt;file>..."</span> to update what will be committed<span>)</span>
  <span>(</span>use <span>"git checkout -- &lt;file>..."</span> to discard changes <span>in</span> working directory<span>)</span>

    modified:   readme.txt

no changes added to commit <span>(</span>use <span>"git add"</span> and/or <span>"git commit -a"</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>怎么第二次的修改没有被提交? 我们回顾一下操作过程:</p>
<p>第一次修改 → <code>git add</code> → 第二次修改 → <code>git commit</code></p>
<p>您看，我们前面讲了，Git 管理的是修改，当您用 <code>git add</code> 命令后，在工作区的第一次修改被放入暂存区，准备提交，但是，在工作区的第二次修改并没有放入暂存区，所以，<code>git commit</code> 只负责把暂存区的修改提交了，也就是第一次的修改被提交了，第二次的修改不会被提交。</p>
<p>提交后，用 <code>git diff HEAD -- readme.txt</code> 命令可以查看工作区和版本库里面最新版本的区别:</p>
<div><pre><code>$ <span>git</span> <span>diff</span> HEAD -- readme.txt
<span>diff</span> --git a/readme.txt b/readme.txt
index 76d770f<span>..</span>a9c5755 <span>100644</span>
--- a/readme.txt
+++ b/readme.txt
@@ -1,4 +1,4 @@
 Git is a distributed version control system.
 Git is <span>free</span> software distributed under the GPL.
 Git has a mutable index called stage.
-Git tracks changes.
+Git tracks changes of files.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>可见，第二次修改确实没有被提交。</p>
<p>那怎么提交第二次修改呢? 您可以继续 <code>git add</code> 再 <code>git commit</code>，也可以别着急提交第一次修改，先 <code>git add</code> 第二次修改，再 <code>git commit</code>，就相当于把两次修改合并后一块提交了:</p>
<p>第一次修改 → <code>git add</code> → 第二次修改 → <code>git add</code> → <code>git commit</code></p>
<p>好，现在，把第二次修改提交了，然后开始小结。</p>
<h3 id="管理小结"> 管理小结</h3>
<p>现在，您又理解了 Git 是如何跟踪修改的，每次修改，如果不用 <code>git add</code> 到暂存区，那就不会加入到 <code>commit</code> 中。</p>
<h2 id="撤消对文件的修改"> 撤消对文件的修改</h2>
<p>自然，您是不会犯错的。不过现在是凌晨两点，您正在赶一份工作报告，您在 readme.txt 中添加了一行:</p>
<div><pre><code>$ <span>cat</span> readme.txt
Git is a distributed version control system.
Git is <span>free</span> software distributed under the GPL.
Git has a mutable index called stage.
Git tracks changes of files.
My stupid boss still prefers SVN.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>在您准备提交前，一杯咖啡起了作用，您猛然发现了 <code>'stupid boss'</code> 可能会让您丢掉这个月的奖金!</p>
<p>既然错误发现得很及时，就可以很容易地纠正它。您可以删掉最后一行，手动把文件恢复到上一个版本的状态。如果用 <code>git status</code> 查看一下:</p>
<div><pre><code>$ <span>git</span> status
On branch master
Changes not staged <span>for</span> commit:
  <span>(</span>use <span>"git add &lt;file>..."</span> to update what will be committed<span>)</span>
  <span>(</span>use <span>"git checkout -- &lt;file>..."</span> to discard changes <span>in</span> working directory<span>)</span>

    modified:   readme.txt

no changes added to commit <span>(</span>use <span>"git add"</span> and/or <span>"git commit -a"</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>您可以发现，Git 会告诉您，<code>git checkout -- &lt;file&gt;</code> 可以丢弃工作区的修改:</p>
<div><pre><code><span>git</span> checkout -- readme.txt
</code></pre>
<div><span>1</span><br></div></div><p>命令 <code>git checkout -- readme.txt</code> 意思就是，把 readme.txt 文件在工作区的修改全部撤销，这里有两种情况:</p>
<p>一种是 readme.txt 自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；</p>
<p>一种是 readme.txt 已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。</p>
<p>总之，就是让这个文件回到最近一次 <code>git commit</code> 或 <code>git add</code> 时的状态。</p>
<p>现在，看看 readme.txt 的文件内容:</p>
<div><pre><code>$ <span>cat</span> readme.txt
Git is a distributed version control system.
Git is <span>free</span> software distributed under the GPL.
Git has a mutable index called stage.
Git tracks changes of files.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>文件内容果然复原了。</p>
<p><code>git checkout -- file</code> 命令中的 <code>--</code> 很重要，没有 <code>--</code>，就变成了“切换到另一个分支”的命令，我们在后面的分支管理中会再次遇到 <code>git checkout</code> 命令。</p>
<div><p>注意</p>
<p>请务必记得 <code>git checkout -- &lt;file&gt;</code> 是一个危险的命令。您对那个文件在本地的任何修改都会消失——Git 会用最近提交的版本覆盖掉它。</p>
<p>除非您确实清楚不想要对那个文件的本地修改了，否则请不要使用这个命令。</p>
</div>
<h2 id="取消暂存的文件"> 取消暂存的文件</h2>
<p>现在假定是凌晨 3 点，您不但写了一些胡话，还 <code>git add</code> 到暂存区了:</p>
<div><pre><code>$ <span>cat</span> readme.txt
Git is a distributed version control system.
Git is <span>free</span> software distributed under the GPL.
Git has a mutable index called stage.
Git tracks changes of files.
My stupid boss still prefers SVN.

<span>git</span> <span>add</span> readme.txt
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>庆幸的是，在 <code>commit</code> 之前，您发现了这个问题。用 <code>git status</code> 查看一下，修改只是添加到了暂存区，还没有提交:</p>
<div><pre><code>$ <span>git</span> status
On branch master
Changes to be committed:
  <span>(</span>use <span>"git reset HEAD &lt;file>..."</span> to unstage<span>)</span>

    modified:   readme.txt
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>Git 同样告诉我们，用命令 <code>git reset HEAD &lt;file&gt;</code> 可以把暂存区的修改撤销掉(unstage)，重新放回工作区:</p>
<div><pre><code>$ <span>git</span> reset HEAD readme.txt
Unstaged changes after reset:
M    readme.txt
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><code>git reset</code> 命令既可以回退版本，也可以把暂存区的修改回退到工作区。当我们用 <code>HEAD</code> 时，表示当前的指针(最新的版本)。</p>
<p>再用 <code>git status</code> 查看一下，现在暂存区是干净的，工作区有修改:</p>
<div><pre><code>$ <span>git</span> status
On branch master
Changes not staged <span>for</span> commit:
  <span>(</span>use <span>"git add &lt;file>..."</span> to update what will be committed<span>)</span>
  <span>(</span>use <span>"git checkout -- &lt;file>..."</span> to discard changes <span>in</span> working directory<span>)</span>

    modified:   readme.txt
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>还记得如何丢弃工作区的修改吗?</p>
<div><pre><code><span>git</span> checkout -- readme.txt

$ <span>git</span> status
On branch master
nothing to commit, working tree clean
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>整个世界终于清静了!</p>
<div><p>提示</p>
<p>那么如果您想要丢弃工作区和暂存区全部更改呢? 不要忘了 <code>HEAD</code> 就是当前指针，所以</p>
<div><pre><code><span>git</span> reset --hard HEAD
</code></pre>
<div><span>1</span><br></div></div><p>就是丢弃工作区与暂存区的全部文件啦。</p>
</div>
<p>现在，假设您不但改错了东西，还从暂存区提交到了版本库，怎么办呢? 还记得版本回退一节吗? 可以回退到上一个版本。不过，这是有条件的，就是您还没有把自己的本地版本库推送到远程。还记得 Git 是分布式版本控制系统吗? 我们后面会讲到远程版本库，一旦您把 <code>stupid boss</code> 提交推送到远程版本库，您就真的惨了……</p>
<h3 id="撤销小结"> 撤销小结</h3>
<p>场景 1: 当您改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令 <code>git checkout -- file</code>。</p>
<p>场景 2: 当您不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令 <code>git reset HEAD &lt;file&gt;</code>，就回到了场景 1，第二步按场景 1 操作。</p>
<p>场景 3: 已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退一节，不过前提是没有推送到远程库。</p>
<hr>
<h2 id="删除文件"> 删除文件</h2>
<h3 id="如何删除文件"> 如何删除文件</h3>
<p>在 Git 中，删除也是一个修改操作，我们实战一下，先添加一个新文件 test.txt 到 Git 并且提交:</p>
<div><pre><code><span>git</span> <span>add</span> test.txt

$ <span>git</span> commit -m <span>"add test.txt"</span>
<span>[</span>master b84166e<span>]</span> <span>add</span> test.txt
 <span>1</span> <span>file</span> changed, <span>1</span> insertion<span>(</span>+<span>)</span>
 create mode <span>100644</span> test.txt
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>一般情况下，您通常直接在文件管理器中把没用的文件删了，或者用 <code>rm</code> 命令删了:</p>
<div><pre><code><span>rm</span> test.txt
</code></pre>
<div><span>1</span><br></div></div><p>这个时候，Git 知道您删除了文件，因此，工作区和版本库就不一致了，<code>git status</code> 命令会立刻告诉您哪些文件被删除了:</p>
<div><pre><code>$ <span>git</span> status
On branch master
Changes not staged <span>for</span> commit:
  <span>(</span>use <span>"git add/rm &lt;file>..."</span> to update what will be committed<span>)</span>
  <span>(</span>use <span>"git checkout -- &lt;file>..."</span> to discard changes <span>in</span> working directory<span>)</span>

    deleted:    test.txt

no changes added to commit <span>(</span>use <span>"git add"</span> and/or <span>"git commit -a"</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>现在您有两个选择，一是确实要从版本库中删除该文件，那就用命令 <code>git rm</code> 删掉，并且 <code>git commit</code>:</p>
<div><pre><code>$ <span>git</span> <span>rm</span> test.txt
<span>rm</span> <span>'test.txt'</span>

$ <span>git</span> commit -m <span>"remove test.txt"</span>
<span>[</span>master d46f35e<span>]</span> remove test.txt
 <span>1</span> <span>file</span> changed, <span>1</span> deletion<span>(</span>-<span>)</span>
 delete mode <span>100644</span> test.txt
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>现在，文件就从版本库中被删除了。</p>
<h3 id="撤销删除"> 撤销删除</h3>
<p>另一种情况是删错了，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本:</p>
<div><pre><code><span>git</span> checkout -- test.txt
</code></pre>
<div><span>1</span><br></div></div><p><code>git checkout</code> 其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。</p>
<h3 id="删除小结"> 删除小结</h3>
<p>命令 <code>git rm</code> 用于删除一个文件。如果一个文件已经被提交到版本库，那么您永远不用担心误删，但是要小心，您只能恢复文件到最新版本，您会丢失最近一次提交后您修改的内容。</p>
]]></content>
    <author>
      <name>廖雪峰</name>
    </author>
    <category term="Git"/>
    <contributor>
      <name>廖雪峰</name>
    </contributor>
    <rights>Copyright by 廖雪峰 Edited by Mr.Hope</rights>
  </entry>
  <entry>
    <title type="html">Git 仓库</title>
    <id>http://qiqi.dreamagain.top/software/git/create-repo/</id>
    <link href="http://qiqi.dreamagain.top/software/git/create-repo/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <summary type="html"><![CDATA[<p>什么是仓库呢? 英文名<strong>repository</strong>，您可以简单理解成一个目录，这个目录里面的所有文件都可以被 Git 管理起来，每个文件的修改、删除， Git 都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。</p>
]]></summary>
    <content type="html"><![CDATA[<p>什么是仓库呢? 英文名<strong>repository</strong>，您可以简单理解成一个目录，这个目录里面的所有文件都可以被 Git 管理起来，每个文件的修改、删除， Git 都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。</p>

<h2 id="初始化仓库"> 初始化仓库</h2>
<p>创建一个仓库非常简单，首先，选择一个合适的地方，创建一个空目录:</p>
<div><pre><code><span># open shell (PowerShell on Windows) in a proper directory</span>
$ <span>mkdir</span> learngit
$ <span>cd</span> learngit
$ <span>pwd</span>
/users/hope-studio/learngit
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p><code>pwd</code> 命令用于显示当前目录。</p>
<div><p>提示</p>
<ul>
<li>使用 Windows 系统时，为了避免遇到各种莫名其妙的问题，请确保目录名(包括父目录)不包含中文。</li>
<li>为了确保能够执行跨平台的命令，请在 Windows 上安装 PowerShell 并设置为 VS Code 的默认终端。</li>
</ul>
</div>
<p>第二步，通过 <code>git init</code> 命令把这个目录变成 Git 可以管理的仓库:</p>
<div><pre><code>$ <span>git</span> init
Initialized empty Git repository <span>in</span> /users/hope-studio/learngit/.git/
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>瞬间 Git 就把仓库建好了，而且告诉您是一个空的仓库(empty Git repository)，可以发现当前目录下多了一个.git 的目录，这个目录是 Git 来跟踪管理仓库的，如果这个目录里面的文件破坏了，Git 仓库也破坏了。</p>
<p>如果您没有看到 .git 目录，那是因为这个目录默认是隐藏的，用 <code>ls -ah</code> 命令就可以看见。</p>
<p>也不一定必须在空目录下创建 Git 仓库，选择一个已经有东西的目录也是可以的。</p>
<div><p>警告</p>
<p>请不要用已经在使用的项目练习 Git!</p>
</div>
<h2 id="把文件添加到仓库"> 把文件添加到仓库</h2>
<p>首先这里再明确一下，所有的版本控制系统，其实只能跟踪文本文件的改动，比如 TXT 文件，网页，所有的程序代码等等，Git 也不例外。版本控制系统可以告诉您每次的改动，比如在第 5 行加了一个单词“Linux”，在第 8 行删了一个单词“Windows”。而图片、视频这些二进制文件，虽然也能由版本控制系统管理，但没法跟踪文件的变化，只能把二进制文件每次改动串起来，也就是只知道图片从 100KB 改成了 120KB，但到底改了啥，版本控制系统不知道，也没法知道。(Microsoft 的 Word 格式是二进制格式，所以很不幸) 所以要使用版本控制系统，就要以纯文本方式编写文件。</p>
<div><p>提示</p>
<p>因为文本是有编码的，比如中文有常用的 GBK 编码，日文有 Shift_JIS 编码，如果没有历史遗留问题，强烈建议使用标准的 UTF-8 编码，所有语言使用同一种编码，既没有冲突，又被所有平台所支持。</p>
<ul>
<li>具体详情请见 <a href="./../../code/basic/encoding.html">文件编码</a></li>
</ul>
</div>
<div><p>注意</p>
<p>千万不要使用 Windows 自带的记事本编辑任何文本文件。</p>
<ul>
<li>具体详情请见 <a href="./../../code/windows/notepad.html">记事本遗留问题</a></li>
</ul>
</div>
<p>现在编写一个 readme.txt 文件，内容如下:</p>
<div><pre><code>Git is a version control system.
Git is free software.
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>一定要放到 <code>learngit</code> 目录下(子目录也行)，因为这是一个 Git 仓库，放到其他地方 Git 再厉害也找不到这个文件。</p>
<p>把一个文件放到 Git 仓库只需要两步:</p>
<ol>
<li>
<p>用命令 <code>git add</code> 告诉 Git，把文件添加到仓库:</p>
<div><pre><code><span>git</span> <span>add</span> readme.txt
</code></pre>
<div><span>1</span><br></div></div><p>执行上面的命令，没有任何显示，这就对了，Unix 的哲学是“没有消息就是好消息”，说明添加成功。</p>
</li>
<li>
<p>用命令 <code>git commit</code> 告诉 Git，把文件提交到仓库:</p>
<div><pre><code>$ <span>git</span> commit -m <span>"wrote a readme file"</span>
<span>[</span>master <span>(</span>root-commit<span>)</span> eaadf4e<span>]</span> wrote a readme <span>file</span>
 <span>1</span> <span>file</span> changed, <span>2</span> insertions<span>(</span>+<span>)</span>
 create mode <span>100644</span> readme.txt
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p><code>git commit</code> 命令，<code>-m</code> 后面输入的是本次提交的说明，这样您就能从历史记录里方便地找到改动记录。</p>
<p><code>git commit</code> 命令执行成功后会告诉您，<code>1 file changed</code>: 1 个文件被改动(我们新添加的 readme.txt 文件)；<code>2 insertions</code>: 插入了两行内容(readme.txt 有两行内容)。</p>
</li>
</ol>
<p>为什么 Git 添加文件需要 <code>add</code>，<code>commit</code> 一共两步呢? 因为 <code>commit</code> 可以一次提交很多文件，所以您可以多次 <code>add</code> 不同的文件，比如:</p>
<div><pre><code><span>git</span> <span>add</span> file1.txt
<span>git</span> <span>add</span> file2.txt file3.txt
<span>git</span> commit -m <span>"add 3 files."</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id="小结"> 小结</h2>
<ul>
<li>
<p>初始化一个 Git 仓库，使用 <code>git init</code> 命令。</p>
</li>
<li>
<p>添加文件到 Git 仓库，分两步:</p>
<ol>
<li>使用命令 <code>git add &lt;file&gt;</code>，可反复多次使用，添加多个文件；</li>
<li>使用命令 <code>git commit -m &lt;message&gt;</code>，完成。</li>
</ol>
</li>
</ul>
]]></content>
    <author>
      <name>廖雪峰</name>
    </author>
    <category term="Git"/>
    <contributor>
      <name>廖雪峰</name>
    </contributor>
    <rights>Copyright by 廖雪峰 Edited by Mr.Hope</rights>
  </entry>
  <entry>
    <title type="html">自定义 Git</title>
    <id>http://qiqi.dreamagain.top/software/git/custom/</id>
    <link href="http://qiqi.dreamagain.top/software/git/custom/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<p>在安装 Git 一节中，我们已经配置了 <code>user.name</code> 和 <code>user.email</code>，实际上，Git 还有很多可配置项。</p>
<p>比如，让 Git 显示颜色，会让命令输出看起来更醒目:</p>
<div><pre><code><span>git</span> config --global color.ui <span>true</span>
</code></pre>
<div><span>1</span><br></div></div><p>这样，Git 会适当地显示不同的颜色，比如 <code>git status</code> 命令，文件名就会标上颜色。</p>
<h2 id="配置别名"> 配置别名</h2>
<p>有没有经常敲错命令? 比如 <code>git status</code>? <code>status</code> 这个单词真心不好记。</p>
<p>如果敲 <code>git st</code> 就表示 <code>git status</code> 那就简单多了，当然这种偷懒的办法我们是极力赞成的。</p>
<p>我们只需要敲一行命令，告诉 Git，以后 <code>st</code> 就表示 <code>status</code>:</p>
<div><pre><code><span>git</span> config --global alias.st status
</code></pre>
<div><span>1</span><br></div></div><p>好了，现在敲 <code>git st</code> 看看效果。</p>
<p>当然还有别的命令可以简写，很多人都用 <code>co</code> 表示 <code>checkout</code>，<code>ci</code> 表示 <code>commit</code>，<code>br</code> 表示 <code>branch</code>:</p>
<div><pre><code><span>git</span> config --global alias.co checkout
<span>git</span> config --global alias.ci commit
<span>git</span> config --global alias.br branch
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>以后提交就可以简写成:</p>
<div><pre><code><span>git</span> ci -m <span>"bala bala bala..."</span>
</code></pre>
<div><span>1</span><br></div></div><p><code>--global</code> 参数是全局参数，也就是这些命令在这台电脑的所有 Git 仓库下都有用。</p>
<p>在撤销修改一节中，我们知道，命令 <code>git reset HEAD file</code> 可以把暂存区的修改撤销掉(unstage)，重新放回工作区。既然是一个 <code>unstage</code> 操作，就可以配置一个 <code>unstage</code> 别名:</p>
<div><pre><code><span>git</span> config --global alias.unstage <span>'reset HEAD'</span>
</code></pre>
<div><span>1</span><br></div></div><p>当您敲入命令:</p>
<div><pre><code><span>git</span> unstage test.py
</code></pre>
<div><span>1</span><br></div></div><p>实际上 Git 执行的是:</p>
<div><pre><code><span>git</span> reset HEAD test.py
</code></pre>
<div><span>1</span><br></div></div><p>配置一个 <code>git last</code>，让其显示最后一次提交信息:</p>
<div><pre><code><span>git</span> config --global alias.last <span>'log -1'</span>
</code></pre>
<div><span>1</span><br></div></div><p>这样，用 <code>git last</code> 就能显示最近一次的提交:</p>
<div><pre><code>$ <span>git</span> last
commit adca45d317e6d8a4b23f9811c3d7b7f0f180bfe2
Merge: bd6ae48 291bea8
Author: Mr-Hope <span>&lt;</span>zhangbowang1998@gmail.com<span>></span>
Date:   Thu Aug <span>22</span> <span>22</span>:49:22 <span>2013</span> +0800

    merge <span>&amp;</span> fix hello.py
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>甚至还有人丧心病狂地把 <code>lg</code> 配置成了:</p>
<div><pre><code><span>git</span> config --global alias.lg <span>"log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an>%Creset' --abbrev-commit"</span>
</code></pre>
<div><span>1</span><br></div></div><p>来看看 <code>git lg</code> 的效果:</p>
<p><img src="./assets/git16.png" alt="命令 git lg 示例图"></p>
<p>为什么不早点告诉我? 别激动，咱不是为了多记几个英文单词嘛!</p>
<h2 id="配置文件"> 配置文件</h2>
<p>配置 Git 的时候，加上 <code>--global</code> 是针对当前用户起作用的，如果不加，那只针对当前的仓库起作用。</p>
<p>配置文件放哪了? 每个仓库的 Git 配置文件都放在 <code>.git/config</code> 文件中:</p>
<div><pre><code>$ <span>cat</span> .git/config
<span>[</span>core<span>]</span>
    repositoryformatversion <span>=</span> <span>0</span>
    filemode <span>=</span> <span>true</span>
    bare <span>=</span> <span>false</span>
    logallrefupdates <span>=</span> <span>true</span>
    ignorecase <span>=</span> <span>true</span>
    precomposeunicode <span>=</span> <span>true</span>
<span>[</span>remote <span>"origin"</span><span>]</span>
    url <span>=</span> git@github.com:michaelliao/learngit.git
    fetch <span>=</span> +refs/heads/*:refs/remotes/origin/*
<span>[</span>branch <span>"master"</span><span>]</span>
    remote <span>=</span> origin
    merge <span>=</span> refs/heads/master
<span>[</span>alias<span>]</span>
    last <span>=</span> log -1
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>别名就在 <code>[alias]</code> 后面，要删除别名，直接把对应的行删掉即可。</p>
<p>而当前用户的 Git 配置文件放在用户主目录下的一个隐藏文件 <code>.gitconfig</code> 中:</p>
<div><pre><code>$ <span>cat</span> .gitconfig
<span>[</span>alias<span>]</span>
    co <span>=</span> checkout
    ci <span>=</span> commit
    br <span>=</span> branch
    st <span>=</span> status
<span>[</span>user<span>]</span>
    name <span>=</span> Your Name
    email <span>=</span> your@email.com
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>配置别名也可以直接修改这个文件，如果改错了，可以删掉文件重新通过命令配置。</p>
<h3 id="别名小结"> 别名小结</h3>
<ul>
<li>给 Git 配置好别名，就可以输入命令时偷个懒。我们鼓励偷懒。</li>
</ul>
]]></content>
    <author>
      <name>廖雪峰</name>
    </author>
    <category term="Git"/>
    <contributor>
      <name>廖雪峰</name>
    </contributor>
    <rights>Copyright by 廖雪峰 Edited by Mr.Hope</rights>
  </entry>
  <entry>
    <title type="html">Git Large File Storage</title>
    <id>http://qiqi.dreamagain.top/software/git/gitLFS/</id>
    <link href="http://qiqi.dreamagain.top/software/git/gitLFS/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<h1 id="git-large-file-storage"> Git Large File Storage</h1>
<p>Git Large File Storage (LFS) replaces large files such as audio samples, videos, datasets, and graphics with text pointers inside Git, while storing the file contents on a remote server like GitHub.com or GitHub Enterprise.</p>
<h2 id="getting-started"> Getting Started</h2>
<ol>
<li>
<p>Download and install the Git command-line extension. Once downloaded and installed, set up Git LFS and its respective hooks by running:</p>
<div><pre><code><span>git</span> lfs <span>install</span>
</code></pre>
<div><span>1</span><br></div></div><p>You’ll need to run this in your repository directory, once per repository.</p>
</li>
<li>
<p>Select the file types you’d like Git LFS to manage (or directly edit your .gitattributes). You can configure file extensions at anytime.</p>
<div><pre><code><span>git</span> lfs track <span>"*.psd"</span>
</code></pre>
<div><span>1</span><br></div></div><p>Make sure to track <code>.gitattributes</code></p>
<div><pre><code><span>git</span> <span>add</span> .gitattributes
</code></pre>
<div><span>1</span><br></div></div></li>
</ol>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <category term="Git"/>
    <contributor>
      <name>南辞</name>
    </contributor>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">Github Pages</title>
    <id>http://qiqi.dreamagain.top/software/git/github/actions/</id>
    <link href="http://qiqi.dreamagain.top/software/git/github/actions/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<h2 id="官方文档"> 官方文档</h2>
<ul>
<li>
<p><a href="https://help.github.com/en/actions/reference/events-that-trigger-workflows" target="_blank" rel="noopener noreferrer">Workflow 触发事件</a></p>
</li>
<li>
<p><a href="https://help.github.com/en/actions/reference/workflow-syntax-for-github-actions" target="_blank" rel="noopener noreferrer">Workflow 配置</a></p>
</li>
</ul>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <category term="Github"/>
    <contributor>
      <name>南辞</name>
    </contributor>
    <published>2019-09-18T00:00:00.000Z</published>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">自动部署</title>
    <id>http://qiqi.dreamagain.top/software/git/github/deploy/</id>
    <link href="http://qiqi.dreamagain.top/software/git/github/deploy/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <summary type="html"><![CDATA[<p>本文介绍如何利用 Git 和 GitHub Action，自动部署代码到服务器。</p>
]]></summary>
    <content type="html"><![CDATA[<p>本文介绍如何利用 Git 和 GitHub Action，自动部署代码到服务器。</p>

<div><p>提示</p>
<p>由于 Centos 仍然是用 GitV1，本教程使用 Ubuntu 18.04 进行教学。</p>
</div>
<h2 id="添加账户"> 添加账户</h2>
<p>为了安全，首先需要使用命令创建 Git 用户，为了安全请务必设置密码。</p>
<div><pre><code><span>sudo</span> adduser <span>git</span>
</code></pre>
<div><span>1</span><br></div></div><p>之后，查看部署目录所在组，git 用户添加到组中。</p>
<div><pre><code><span>usermod</span> -a -G <span>&lt;</span>目录所在组<span>></span> <span>git</span>
</code></pre>
<div><span>1</span><br></div></div><p>然后将部署目录的权限设置为 <code>775</code>，即允许同组访问。这样 git 就有权限访问部署目录。</p>
<h2 id="添加权限"> 添加权限</h2>
<p>创建 <code>~/.ssh/</code> 文件夹，生成 <code>authorized_keys</code> 文件，并设置其权限为 <code>600</code>。</p>
<div><pre><code><span>mkdir</span> -p ~/.ssh/

<span>touch</span> ~/.ssh/authorized_keys

<span>chmod</span> <span>600</span> ~/.ssh/authorized_keys
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>之后将需要赋予权限的用户公钥依次粘贴至该文件。</p>
<h2 id="创建仓库"> 创建仓库</h2>
<p>回到 <code>/home/git/</code>，创建所需的文件夹:</p>
<div><pre><code><span>cd</span> ~
<span>mkdir</span> <span>&lt;</span>仓库名<span>></span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>进入文件夹，使用</p>
<div><pre><code><span>git</span> init --separate-git-dir<span>=</span>. <span>&lt;</span>部署位置<span>></span>
</code></pre>
<div><span>1</span><br></div></div><p>这会将 git 库保持在 <code>/home/git/&lt;仓库名&gt;</code> 下，同时将工作区设置到部署文件夹中。</p>
<p>接下来执行:</p>
<div><pre><code><span>git</span> config receive.denyCurrentBranch ignore
</code></pre>
<div><span>1</span><br></div></div><p>这是由于 Git 默认拒绝外部对当前的推送操作，因为这可能会覆盖或变更工作区文件。</p>
<h2 id="github-actions-构建"> GitHub Actions 构建</h2>
<p>在正常的工作流程中，完成页面的构建，并将其推送到 gh-pages 上。</p>
<p>之后只需要使用 GitHub Action 推送到 <code>git@&lt;ip&gt;:&lt;部署目录&gt; gh-pages</code> 即可。</p>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <category term="Git"/>
    <contributor>
      <name>南辞</name>
    </contributor>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">GitHub 简介</title>
    <id>http://qiqi.dreamagain.top/software/git/github/intro/</id>
    <link href="http://qiqi.dreamagain.top/software/git/github/intro/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<h2 id="gayhub-github-是世界上最大的-同性交友-代码托管网站"> <s>Gayhub</s> GitHub 是世界上最大的 <s>同性交友</s> 代码托管网站</h2>
<p>😋当然在上面交友也是极好的(这是重点，圈起来要考的😎)。</p>
<h2 id="基本概念"> 基本概念</h2>
<h3 id="repository"> repository</h3>
<p>仓库，简称 <strong>Repo</strong>。一个仓库即是一个项目。仓库是 GitHub 上的主要内容。每当您新建一个项目并想要在 GitHub。</p>
<h3 id="star"> Star</h3>
<p>收藏。在每一个仓库主页的上方可以看到 star 按钮。其上的数值为收藏该项目的人数。点击星星即可将当前仓库收藏到您的账号上。您可以收藏一些您比较喜欢，或者项目对您来说有很大价值的项目。同时，点击数字可以看到哪些人收藏了这个项目。</p>
<h3 id="fork"> fork</h3>
<p>复刻。在每一个仓库主页的上方可以看到 Fork 按钮。点击该按钮的作用是将当前项目复刻一份到自己的仓库中，这样，您就可以在此仓库仓库上查看当前、历史的版本，切换分支、或者是随心所欲的进行修改。原项目的新的推送、对历史版本的修改、甚至原作者删除了他的 repo，都不会对您 fork 的项目产生任何影响。</p>
<h3 id="issue"> issue</h3>
<p>议题。这是一个类似讨论区的地方。如果您在使用该项目的过程中遇到了问题，可以在相应项目的 Issue 板块按照项目的要求提出 Issue。在 Issue 中可以汇报一个 bug，或者是提出一个 Feature Request (功能请求)。项目的拥有者会针对您汇报的情况对您做出回复。同时，项目拥有者还可以为此 issue 增加 label (标签)，以帮助项目成员或是项目的其他使用者更好的理解您提出 issue。也可以将您的 issue assign (分派) 给特定的项目成员解决。</p>
<div><p>提示</p>
<p>为了 GitHub 的友好交流环境，请在汇报 bug 时永远带上 bug 的一个简易的复现流程，可以直接建立一个简单的 bug repository 并把链接放置在您提出的 issue 中。</p>
</div>
<h3 id="pull-request"> pull request</h3>
<p>发起推送请求，简称 <strong>PR</strong>。如果是您自己的项目，您可以从一个分支向另一个分支发起推送请求。如果您想对别人的(您无权进行推送)项目进行代码的推送请求的化，需要先 fork 这个仓库。在自己 fork 的项目上进行修改，然后提交到自己的项目上，之后，建立一个从自己仓库到对方仓库的 PR。如果对方觉得您的新改动很不错，在经过测试或者 review 后就会接受它，这样原有项目就可拥有这些新的代码了.</p>
<h3 id="watch"> watch</h3>
<p>关注，在每一个仓库主页的上方可以看到 Watch 按钮。如果您关注了某个项目,那么这个项目有了变化的时候,您就会得到通知.在您点击关注后，您还可以点击下拉列表进一步设置关注级别。您可以选择接受 Release (新发布) 通知，也可以选择 Watching 来监听所有的通知。当您选择 Ignore 的话，即使有人在这个仓库中 metion (提到) 了您，您也不会得到通知。</p>
<h3 id="review"> review</h3>
<p>审查。当项目收到 PR 时，项目的拥有成员可以对这份 PR 的代码改动进行审查，在 Review 的过程中，可以对代码的特定行或特定几行通过 comment(评论) 的方式来提出自己对代码改动的意见。</p>
<h2 id="主页"> 主页</h2>
<p><img src="./assets/mainPage.png" alt="个人主页"></p>
<p><a href="https://github.com" target="_blank" rel="noopener noreferrer">https://github.com</a></p>
<p>主页，在您登陆后，屏幕的左侧会展示您和您加入团队的项目，以及您的团队详情。中部会显示您关注的项目、人的动态，右侧会根据算法展示一些您可能会感兴趣的 repo。</p>
<h2 id="个人主页"> 个人主页</h2>
<p><img src="./assets/profile.png" alt="个人主页"></p>
<p><strong>地址:</strong> <code>https://github.com/&lt;您的用户名&gt;</code></p>
<p>个人主页会有几个主要面板:</p>
<h3 id="overview"> Overview</h3>
<p>个人概览，您可以在上方 pin(固定) 最多六个您想要展示给他人的仓库。</p>
<p>下方就是您过去一年里向 GitHub 的提交数量分布图，以及您在 GitHub 上的活动比例。</p>
<p>最下方是近几年您在 GitHub 上的活动记录。</p>
<h3 id="repositories"> Repositories</h3>
<p><img src="./assets/personalRepo.png" alt="个人仓库"></p>
<p>仓库列表，该面板会按照最后更新时间的倒序，展示该用户拥有的所有 reo，同时也会在面板上展示项目的 Descript(描述)、Star 数、Fork 数、语言、协议、标签，以及过去一年内项目的 commit 分布数量。这些都能够帮助浏览者在不进入具体仓库页面的情况下大致了解每一个仓库的内容、欢迎程度与维护情况。</p>
<h3 id="projects"> Projects</h3>
<p>个人拥有的项目，在管理自己与团队跨仓库的活动日程时很有用。可以设置涉及到的仓库，提出任务、代办、时间表等。</p>
<h3 id="packages"> Packages</h3>
<p>个人在 GitHub 上拥有的包。目前较少人在 GitHub 上发布相关的包。</p>
<h3 id="stars"> Stars</h3>
<p>和仓库列表完全相同，只不过展示该用户收藏的 repo。</p>
<h3 id="followers-following"> Followers / Following</h3>
<p>关注您的人 / 关注的人。在个人主页的左侧就有 follow 按钮，follow 一个人意味着这个人在 GitHub 的的活动会出现在 GitHub 主页的 Activity List 上。</p>
<h2 id="仓库主页"> 仓库主页</h2>
<p><img src="./assets/repo.png" alt="仓库主页"></p>
<p>仓库主页主要显示项目的信息。从左到右的面板依次是: Code(代码)，Issues (问题)、Pull Requests (提交请求)、Actions (自动流程)、 Projects (项目)、 Wiki (项目介绍)、 Security (项目安全)、 Insights (项目数据统计) 与 Settings (项目设置)。</p>
<p>在下方会展示代码文件以及项目说明 README.md 文件。</p>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <category term="Git"/>
    <contributor>
      <name>南辞</name>
    </contributor>
    <published>2019-11-20T00:00:00.000Z</published>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">Pull Request</title>
    <id>http://qiqi.dreamagain.top/software/git/github/pr/</id>
    <link href="http://qiqi.dreamagain.top/software/git/github/pr/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<h2 id="简介"> 简介</h2>
<p>对于一个用户的公开仓库，在默认情况下虽然其他用户可以拉取该库的代码，但是他们并不能够直接向这个库进行推送。</p>
<p>GitHub 是一个代码社区，这意味着鼓励大家互相提交与贡献代码。所以这就是 Fork 和 Pull Request 出现的意义。没有人会给一个陌生人添加访问自己仓库的权限，所以我们需要一种方式，能够让大家向仓库所有者发起贡献代码的请求。这就是 pull request 的由来。</p>
<h2 id="提交自己贡献的代码"> 提交自己贡献的代码</h2>
<p>对于代码贡献者来说，他需要用一种方法将自己贡献的代码推送到远程库上，以便发起请求，最好的办法就是 fork 原仓库。</p>
<p><img src="./assets/fork.png" alt="Fork 仓库"></p>
<div><p>相关信息</p>
<p>相关介绍，请见 <a href="./intro.html#fork">GitHub 简介 → fork</a></p>
</div>
<p>这样，贡献者在自己的账号上获得一个和原仓库完全相同的副本。</p>
<p>既然副本已经创建在自己的账号上，贡献者自然可以:</p>
<ol>
<li>克隆这个项目到本地</li>
<li>在这个项目上贡献自己的代码</li>
<li>将贡献的代码推送到这个副本上</li>
</ol>
<h2 id="发送请求"> 发送请求</h2>
<p>pull request 是请求仓库所有者拉取指定仓库分支代码的请求。</p>
<p>在贡献自己的代码并推送到自己的 fork 仓库后，贡献者即可到原仓库去选择自己仓库的对应分支发送这个拉取请求。仓库所有者随时可以批准这个更改，使其自动添加到自己的库中，或是拒绝这个请求。</p>
<p><img src="./assets/pull-request.png" alt="Pull request"></p>
<blockquote>
<p>这个仓库我已经删了所以显示 <code>unknown repository</code>，原为 <code>Mister-Hope:master</code></p>
</blockquote>
<p>这个页面允许所有人在主要对话线上交换自己的意见。</p>
<p>在 Pull request 里，一旦请求被创建，仓库所有者应该可以直观地看到哪些文件发生了怎样的改变。</p>
<p><img src="./assets/file-changes.png" alt="文件改动"></p>
<p>同时，他们也可以对贡献者的代码进行审查，对特定行或片段标注，并陈述自己的意见，同时将这个意见根据程度标注为“探讨”、“改进”或者“必须更改”，以便贡献者进行交流讨论与完善修改。</p>
<p><img src="./assets/pull-request-review.png" alt="代码审查"></p>
<p>同时，对于一个大型库来说，仓库所有者应该可以看到贡献的代码是否通过了所有测试。</p>
<p><img src="./assets/pull-request-check.png" alt="测试通过情况"></p>
<p>如果审查者认为没有问题，他可能就会通过这个拉取请求，拉取对应的代码到自己的仓库上。这样您就完成了对这个仓库的贡献。</p>
<h2 id="同步原仓库"> 同步原仓库</h2>
<p>需要注意的是，fork 创建的是一个时刻副本，也就是自己 fork 产生的仓库，会保持 fork 时的状态，原仓库的任何变动都不会自动同步到 fork 的仓库上。</p>
<p>有些时候，在自己 fork 原仓库、自己编写代码并提交的这段时间里，原仓库已经进行了很多提交。这时，我们就需要同步原仓库的更新到自己的副本上，以确保自己贡献的代码并未和新增代码发生冲突、可以正常工作。</p>
<p>这个时候只需反向拉取，在自己的仓库创建原仓库特定分支到自己仓库特定分支的 Pull request，并批准这个 pull request。这样即可很方便的将原仓库特定分支的更新同步到自己的副本上。</p>
<p>您当然可以在本地添加原仓库的远程库，将最新的更改直接 fetch 到本地，在本地测试通过并完成合并后，由本地推送至自己的 fork 仓库。</p>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <contributor>
      <name>南辞</name>
    </contributor>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">Github</title>
    <id>http://qiqi.dreamagain.top/software/git/github/</id>
    <link href="http://qiqi.dreamagain.top/software/git/github/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<h2 id="快速上手"> 快速上手</h2>
<ul>
<li>
<p><a href="./intro.html">GitHub 介绍</a></p>
</li>
<li>
<p><a href="./pr.html">Pull Request</a></p>
</li>
<li>
<p><a href="./semantic.html">语义化提交</a></p>
</li>
</ul>
<h2 id="官方文档"> 官方文档</h2>
<ul>
<li><a href="https://docs.github.com/cn/free-pro-team@latest/github" target="_blank" rel="noopener noreferrer">全部文档</a></li>
</ul>
<h3 id="入门指南"> 入门指南</h3>
<ul>
<li><a href="https://docs.github.com/cn/free-pro-team@latest/github/getting-started-with-github" target="_blank" rel="noopener noreferrer">查看详情</a></li>
</ul>
<h3 id="快速入门"> 快速入门</h3>
<ul>
<li><a href="https://docs.github.com/cn/free-pro-team@latest/github/getting-started-with-github/set-up-git" target="_blank" rel="noopener noreferrer">设置 Git</a></li>
<li><a href="https://docs.github.com/cn/free-pro-team@latest/github/getting-started-with-github/create-a-repo" target="_blank" rel="noopener noreferrer">创建仓库</a></li>
<li><a href="https://docs.github.com/cn/free-pro-team@latest/github/getting-started-with-github/fork-a-repo" target="_blank" rel="noopener noreferrer">复刻仓库</a></li>
<li><a href="https://docs.github.com/cn/free-pro-team@latest/github/getting-started-with-github/be-social" target="_blank" rel="noopener noreferrer">社交化</a></li>
</ul>
<h3 id="了解-github"> 了解 GitHub</h3>
<ul>
<li><a href="https://docs.github.com/cn/free-pro-team@latest/github/getting-started-with-github/types-of-github-accounts" target="_blank" rel="noopener noreferrer">账户类型</a></li>
<li><a href="https://docs.github.com/cn/free-pro-team@latest/github/getting-started-with-github/access-permissions-on-github#%E4%B8%AA%E4%BA%BA%E7%94%A8%E6%88%B7%E5%B8%90%E6%88%B7" target="_blank" rel="noopener noreferrer">GitHub 上的访问权限</a></li>
<li><a href="https://docs.github.com/cn/free-pro-team@latest/github/getting-started-with-github/github-glossary" target="_blank" rel="noopener noreferrer">GitHub 词汇表</a></li>
</ul>
<h2 id="生态系统"> 生态系统</h2>
<h3 id="github-cli"> GitHub Cli</h3>
<p>GitHub CLI 是用于在计算机上使用 GitHub 功能的命令行工具。</p>
<p>GitHub CLI 是用于从计算机的命令行使用 GitHub 的开源工具。从命令行操作时，您可以使用 GitHub CLI 来节省时间并避免切换上下文。</p>
<p>您可以将以下 GitHub 功能与 GitHub CLI 结合使用。</p>
<ul>
<li>查看、创建、克隆和复刻仓库</li>
<li>创建、关闭和列出议题和拉取请求</li>
<li>审查、差异和合并拉取请求</li>
<li>创建、编辑、列出和查看 Gist</li>
</ul>
<p>有关 GitHub CLI 用途的更多信息，请参阅 <a href="https://cli.github.com/manual" target="_blank" rel="noopener noreferrer">GitHub CLI 手册</a>。</p>
<h3 id="github-desktop"> GitHub Desktop</h3>
<p>GitHub Desktop 使用可视界面扩展并简化您的 Git 和 GitHub 工作流程。</p>
<p>GitHub Desktop 是一种开源工具，可帮助您提高工作效率。GitHub Desktop 鼓励您和您的团队使用最佳实践协作处理 Git 和 GitHub。</p>
<p>您可以使用 GitHub Desktop 执行许多任务，包括:</p>
<ul>
<li>以交互方式将更改添加到提交中</li>
<li>快速将合作作者提交到提交中</li>
<li>检出具有拉取请求的分支并查看 CI 状态</li>
<li>比较更改的图像</li>
</ul>
<p>有关 GitHub Desktop 的更多信息，请参阅 GitHub Desktop 文档中的 <a href="https://docs.github.com/cn/free-pro-team@latest/desktop/installing-and-configuring-github-desktop" target="_blank" rel="noopener noreferrer">安装和配置 GitHub Desktop</a>。</p>
<h3 id="手机版-github"> 手机版 GitHub</h3>
<p>从移动设备对 GitHub 上的工作进行分类、协作和管理。</p>
<p>手机版 GitHub 目前作为 Android 和 iOS app 提供给 GitHub.com 用户。</p>
<p>手机版 GitHub 为您提供随时随地快速高效使用 GitHub 的方式。手机版 GitHub 是通过可信的第一方客户端应用程序访问 GitHub 数据的安全可靠方式。</p>
<p>通过 手机版 GitHub，您可以:</p>
<ul>
<li>管理、分类和清除通知</li>
<li>阅读、审查及协作处理问题和拉取请求</li>
<li>搜索、浏览用户、仓库和组织以及与之交互</li>
<li>当有人提及您的用户名时收到推送通知</li>
</ul>
<h4 id="安装-手机版-github"> 安装 手机版 GitHub</h4>
<p>要安装 Android 或 iOS 版 手机版 GitHub，请参阅 <a href="https://github.com/mobile" target="_blank" rel="noopener noreferrer">手机版 GitHub</a>。</p>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <category term="Git"/>
    <contributor>
      <name>南辞</name>
    </contributor>
    <published>2019-11-20T00:00:00.000Z</published>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">语义化提交</title>
    <id>http://qiqi.dreamagain.top/software/git/github/semantic/</id>
    <link href="http://qiqi.dreamagain.top/software/git/github/semantic/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<h2 id="semantic"> Semantic</h2>
<p>对于一个大型项目，几千个 commit 是很常见的，这些 commit 部分是项目维护者提交的 commit，部分是一些热心的开发者通过 PR 贡献的。</p>
<p>无论是对于项目维护者，还是想要贡献代码的热心开发者来说，一个简洁明了的 commit 描述都是必不可少的。也就是说我们需要用尽可能简短的备注信息，备注每一个 commit 的作用，以便大家查看。所以我们需要一种规范的，语义化的备注格式，很快由知名项目牵头，全球接收并统一了一种语义化的备注格式，这就是 semantic 规范的来源。</p>
<h2 id="优势"> 优势</h2>
<p>当一个仓库所有的 commit 信息都是用标准的 semantic 格式时，用户可以很方便的理解每一个 commit 的作用。</p>
<p>同时，senmantic 支持直接将某个提交或 PR 与特定 issue 链接，并自动关闭或引用这些 issue。</p>
<p>通过一些第三方工具，大家可以基于这些备注信息进行过滤查找，更新日志生成等操作。</p>
<h2 id="格式"> 格式</h2>
<div><pre><code>&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;
&lt;body&gt;

&lt;footer&gt;
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id="header"> header</h3>
<p>第一行被称为 <code>header</code>，它必须只有一行，包括三个字段: <code>&lt;type&gt;</code>(必需)、<code>&lt;scope&gt;</code>(可选)和 <code>&lt;subject&gt;</code>(必需)</p>
<h3 id="type"> type</h3>
<p>commit 的类型。</p>
<p>规范中规定了如下类型:</p>
<ul>
<li><code>feat</code>: feature, 新增功能</li>
<li><code>fix</code> : bug fix, 修复 bug</li>
<li><code>docs</code>: documentation, 仅仅修改了文档，如 <code>readme.md</code></li>
<li><code>style</code>: styke, 仅仅是对格式进行修改，如逗号、缩进、空格等，不改变代码逻辑</li>
<li><code>refactor</code>: refactor, 代码重构，一般更改了源文件或测试文件，但没有新增功能或修复 bug</li>
<li><code>perf</code>: preformance, 优化相关，如提升性能、用户体验等</li>
<li><code>test</code>: test, 测试用例，包括单元测试，集成测试</li>
<li><code>chore</code>: chore, 对于库的其他内容的改变，一般不涉及到源文件或测试文件，比如更改 CI 设置，提升仓库以来等</li>
<li><code>revert</code>: 版本回滚</li>
</ul>
<h3 id="scope"> scope</h3>
<p>用于说明 commit 影响的范围，比如: <code>views</code> , <code>component</code>, <code>utils</code>, <code>test</code>。这个是由项目的内容与结构决定的。</p>
<h3 id="subject"> subject</h3>
<p>commit 目的的简短描述，最好小于 50 字符，一般不超过 65 个字符，最长不超过 80 字符。</p>
<p>当 subject 限制的字符数无法详细说明此 commit 的变动时，将 commit 的具体变动放置在 body 中</p>
<h3 id="body"> body</h3>
<p>对本次 commit 修改内容的具体描述，可以分为多行。<code>body</code> 是可选的，而且 <code>body</code> 可以有多行。</p>
<h3 id="footer"> footer</h3>
<p>可选的，前面有一空行。可以添加一些备注，一般放置 <code>BREAKING CHANGE</code>(一些破坏性的变动) 或修复的 bug(涉及的 issue)的链接。</p>
<h2 id="semantic-commit-与-changelog-生成"> Semantic commit 与 Changelog 生成</h2>
<p>不同语言环境都有很多种工具来帮助您创建一个 semantic commit 或者自动生成 changelog。</p>
<div><p>案例</p>
<p>Node.js 环境下可以使用:</p>
<ul>
<li>
<p><a href="https://github.com/commitizen/cz-conventional-changelog" target="_blank" rel="noopener noreferrer"><code>cz-conventional-changelog</code></a> 提供 <code>git cz</code> 命令辅助创建 semantic commit。</p>
</li>
<li>
<p><a href="https://github.com/conventional-changelog/conventional-changelog" target="_blank" rel="noopener noreferrer"><code>conventional-changelog-cli</code></a> 来快速生成更新日志，如 <a href="https://github.com/Mister-Hope/vuepress-theme-hope/blob/master/CHANGELOG.md" target="_blank" rel="noopener noreferrer">vuepress-theme-hope 的更改日志</a></p>
</li>
</ul>
</div>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <contributor>
      <name>南辞</name>
    </contributor>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">忽略特殊文件</title>
    <id>http://qiqi.dreamagain.top/software/git/ignore/</id>
    <link href="http://qiqi.dreamagain.top/software/git/ignore/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<p>有些时候，您必须把某些文件放到 Git 工作目录中，但又不能提交它们，比如保存了数据库密码的配置文件啦，等等，每次 <code>git status</code> 都会显示 <code>Untracked files</code> ...，有强迫症的童鞋心里肯定不爽。</p>
<p>好在 Git 考虑到了大家的感受，这个问题解决起来也很简单，在 Git 工作区的根目录下创建一个特殊的 <code>.gitignore</code> 文件，然后把要忽略的文件名填进去，Git 就会自动忽略这些文件。</p>
<p>忽略文件的原则是:</p>
<ul>
<li>忽略操作系统自动生成的文件，比如缩略图等；</li>
<li>忽略编译生成的中间文件、可执行文件等，也就是如果一个文件是通过另一个文件自动生成的，那自动生成的文件就没必要放进版本库，比如 Java 编译产生的 <code>.class</code> 文件；</li>
<li>忽略您自己的带有敏感信息的配置文件，比如存放口令的配置文件。</li>
</ul>
<p>举个例子:</p>
<p>假设您在 Windows 下进行 Python 开发，Windows 会自动在有图片的目录下生成隐藏的缩略图文件，如果有自定义目录，目录下就会有 <code>Desktop.ini</code> 文件，因此您需要忽略 Windows 自动生成的垃圾文件:</p>
<div><pre><code><span>Thumbs.db</span>
<span>ehthumbs.db</span>
<span>Desktop.ini</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>然后，继续忽略 Python 编译产生的 <code>.pyc</code>、<code>.pyo</code>、<code>dist</code> 等文件或目录:</p>
<div><pre><code><span>_.py<span>[cod]</span></span>
<span>_.so</span>
<span>_.egg</span>
<span>_.egg-info</span>
<span>dist</span>
<span>build</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>加上您自己定义的文件，最终得到一个完整的 <code>.gitignore</code> 文件，内容如下:</p>
<div><pre><code><span># Windows:</span>

<span>Thumbs.db</span>
<span>ehthumbs.db</span>
<span>Desktop.ini</span>

<span># Python:</span>

<span>_.py<span>[cod]</span></span>
<span>_.so</span>
<span>_.egg</span>
<span>_.egg-info</span>
<span>dist</span>
<span>build</span>

<span># My configurations:</span>

<span>db.ini</span>
<span>deploy_key_rsa</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><p>最后一步就是把 <code>.gitignore</code> 也提交到 Git，就完成了! 当然检验 <code>.gitignore</code> 的标准是 <code>git status</code> 命令是不是说 <code>working directory clean</code>。</p>
<p>使用 Windows 的童鞋注意了，如果您在资源管理器里新建一个 <code>.gitignore</code> 文件，它会非常弱智地提示您必须输入文件名，但是在文本编辑器里“保存”或者“另存为”就可以把文件保存为 <code>.gitignore</code> 了。</p>
<p>有些时候，您想添加一个文件到 Git，但发现添加不了，原因是这个文件被 <code>.gitignore</code> 忽略了:</p>
<div><pre><code>$ <span>git</span> <span>add</span> App.class
The following paths are ignored by one of your .gitignore files:
App.class
Use -f <span>if</span> you really want to <span>add</span> them.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>如果您确实想添加该文件，可以用 <code>-f</code> 强制添加到 Git:</p>
<div><pre><code><span>git</span> <span>add</span> -f App.class
</code></pre>
<div><span>1</span><br></div></div><p>或者您发现，可能是 <code>.gitignore</code> 写得有问题，需要找出来到底哪个规则写错了，可以用 <code>git check-ignore</code> 命令检查:</p>
<div><pre><code>$ <span>git</span> check-ignore -v App.class
.gitignore:3:*.class    App.class
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>Git 会告诉我们，<code>.gitignore</code> 的第 3 行规则忽略了该文件，于是我们就可以知道应该修订哪个规则。</p>
<h2 id="格式规范"> 格式规范</h2>
<ul>
<li>
<p>所有空行或者以 # 开头的行都会被 Git 忽略。</p>
</li>
<li>
<p>可以使用标准的 glob 模式匹配，它会递归地应用在整个工作区中。</p>
</li>
<li>
<p>匹配模式可以以(<code>/</code>)开头防止递归。</p>
</li>
<li>
<p>匹配模式可以以(<code>/</code>)结尾指定目录。</p>
</li>
<li>
<p>要忽略指定模式以外的文件或目录，可以在模式前加上叹号(<code>!</code>)取反。</p>
</li>
</ul>
<div><p>glob 模式</p>
<p>所谓的 glob 模式是指 shell 所使用的简化了的正则表达式。星号(<code>*</code>)匹配零个或多个任意字符；<code>[abc]</code> 匹配任何一个列在方括号中的字符 (这个例子要么匹配一个 <code>a</code>，要么匹配一个 <code>b</code>，要么匹配一个 <code>c</code>)； 问号(<code>?</code>)只匹配一个任意字符；如果在方括号中使用短划线分隔两个字符， 表示所有在这两个字符范围内的都可以匹配(比如 <code>[0-9]</code> 表示匹配所有 <code>0</code> 到 <code>9</code> 的数字)。使用两个星号(<code>**</code>)表示匹配任意中间目录，比如 <code>a/**/z</code> 可以匹配 <code>a/z</code> 、<code>a/b/z</code> 或 <code>a/b/c/z</code> 等。</p>
</div>
<p>一个具体的例子:</p>
<div><pre><code><span># 忽略所有的 .a 文件</span>
<span><span>*</span>.a</span>

<span># 但跟踪所有的 lib.a，即便您在前面忽略了 .a 文件</span>
<span><span>!</span>lib.a</span>

<span># 只忽略当前目录下的 TODO 文件，而不忽略 subdir/TODO</span>
<span><span>/</span>TODO</span>

<span># 忽略任何目录下名为 build 的文件夹</span>
<span>build<span>/</span></span>

<span># 忽略 doc/notes.txt，但不忽略 doc/server/arch.txt</span>
<span>doc<span>/</span><span>*</span>.txt</span>

<span># 忽略 doc/ 目录及其所有子目录下的 .pdf 文件</span>
<span>doc<span>/</span><span>**</span><span>/</span><span>*</span>.pdf</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><div><p>提示</p>
<p>GitHub 有一个十分详细的针对数十种项目及语言的 .gitignore 文件列表， 您可以在 <a href="https://github.com/github/gitignore" target="_blank" rel="noopener noreferrer">https://github.com/github/gitignore</a> 找到它。</p>
</div>
<div><p>多个 .gitignore</p>
<p>在最简单的情况下，一个仓库可能只根目录下有一个 .gitignore 文件，它递归地应用到整个仓库中。然而，子目录下也可以有额外的 .gitignore 文件。子目录中的 .gitignore 文件中的规则只作用于它所在的目录中。(Linux 内核的源码库拥有 206 个 .gitignore 文件。)</p>
</div>
<h2 id="小结"> 小结</h2>
<ul>
<li>
<p>忽略某些文件时，需要编写 <code>.gitignore</code>；</p>
</li>
<li>
<p><code>.gitignore</code> 文件本身要放到版本库里，并且可以对 <code>.gitignore</code> 做版本管理!</p>
</li>
</ul>
]]></content>
    <author>
      <name>廖雪峰</name>
    </author>
    <category term="Git"/>
    <contributor>
      <name>廖雪峰</name>
    </contributor>
    <rights>Copyright by 廖雪峰 Edited by Mr.Hope</rights>
  </entry>
  <entry>
    <title type="html">安装与配置</title>
    <id>http://qiqi.dreamagain.top/software/git/install/</id>
    <link href="http://qiqi.dreamagain.top/software/git/install/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<h2 id="git-下载"> Git 下载</h2>
<p>官网在国外，网速较慢。在安装 Git 前推荐安装好 <a href="./../vscode/">VS Code</a>。</p>
<ul>
<li><a href="https://git-scm.com/downloads/" target="_blank" rel="noopener noreferrer">官网下载</a></li>
</ul>
<h2 id="git-的安装"> Git 的安装</h2>
<ol>
<li>
<p>同意协议并选择安装位置 (不建议更改安装位置)</p>
<p><img src="./assets/install1.png" alt="安装协议"></p>
<p><img src="./assets/install2.png" alt="安装位置"></p>
</li>
<li>
<p>启用 LFS 支持，其他随意 (影响不大)</p>
<p><img src="./assets/install3.png" alt="组件选择"></p>
</li>
<li>
<p>自行决定是否创建启动菜单</p>
<p><img src="./assets/install4.png" alt="是否创建启动菜"></p>
</li>
<li>
<p>选择使用 VS Code 作为 git 的默认编辑器。</p>
<p><img src="./assets/install5.png" alt="设置默认编辑器"></p>
</li>
<li>
<p>选择 Git 使用的默认分支名，GitHub 已经将默认分支名称改为 main。</p>
<p><img src="./assets/install6.png" alt="设置默认分支名称"></p>
<div><p>相关信息</p>
<p>在 2020 年的黑人运动中，部分黑人认为 master 这个词是对它们的冒犯。</p>
</div>
</li>
<li>
<p>选择第二项，这将允许您在第三方工具中使用 Git，同时不会覆盖默认的 Windows 命令。</p>
<p><img src="./assets/install7.png" alt="Git 命令行"></p>
</li>
<li>
<p>使用 OpenSSL Library</p>
<p><img src="./assets/install8.png" alt="Git SSL"></p>
<div><p>提示</p>
<p>如果自己公司有 CA，或者在开发中需要 Git 承认某些自签 CA，则需要选择第二项。</p>
</div>
</li>
<li>
<p>务必选择最后一项 “原样检出与提交”</p>
<p><img src="./assets/install9.png" alt="Git 行尾设置"></p>
</li>
<li>
<p>选择 Git 终端</p>
<p><img src="./assets/install10.png" alt="Git 终端"></p>
<div><p>提示</p>
<p>如果您对 VSCode 和 PowerShell 还不熟悉，建议选择 MinTTY，以方便您接下来在学习中对 Git Bash 的临时使用。</p>
</div>
</li>
<li>
<p>选择 <code>git pull</code> 的默认行为，保持默认不要改动</p>
<p><img src="./assets/install11.png" alt="Git Pull Action"></p>
</li>
<li>
<p>选择凭据储存管理器，请选择第一个跨平台管理器</p>
<p><img src="./assets/install12.png" alt="凭据储存管理器设置"></p>
</li>
<li>
<p>额外的选项确认，均勾选即可</p>
<p><img src="./assets/install13.png" alt="额外选项"></p>
</li>
<li>
<p>一些实验性的功能，通常不太稳定或有 bug，不同 Git 版本会有差异，可根据自身情况确定</p>
<p><img src="./assets/install14.png" alt="实验性功能"></p>
</li>
</ol>
<h2 id="git-bash"> Git Bash</h2>
<p>安装完成后，您可以通过搜索找到“Git Bash” (Mac 上叫 Git Shell)，这是一个 Git 提供的命令窗口，您可以在这里运行 Git 命令。</p>
<p><img src="./assets/shell.png" alt="Git Bash"></p>
<div><p>提示</p>
<p>如果您对 VSCode 和 PowerShell 还不熟悉，您可以在接下来的学习与操作中使用 Git Bash。</p>
</div>
<h2 id="git-的初次配置"> Git 的初次配置</h2>
<ol>
<li>
<p>为 Git 全局配置用户名和邮箱。</p>
<div><pre><code><span>git</span> config --global user.name <span>"Your Name"</span>
<span>git</span> config --global user.email <span>"email@example.com"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>将上方的字符串换成您自己的名字和邮箱。</p>
<p>如:</p>
<div><pre><code><span>git</span> config --global user.name <span>"Mr.Hope"</span>
<span>git</span> config --global user.email <span>"zhangbowang1998@gmail.com"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><div><p>相关信息</p>
<p>由于 Git 是一个多人协作的版本控制系统，首先您应当设置您的身份。</p>
</div>
</li>
<li>
<p>创建 SSH Key。打开 Shell (Windows 下打开 cmd)，创建 SSH Key:</p>
<div><pre><code>ssh-keygen -t rsa -C <span>"youremail@example.com"</span>
</code></pre>
<div><span>1</span><br></div></div><p>您需要把邮件地址换成您自己的邮件地址，然后一路回车，使用默认值即可，由于这个 Key 也不是用于军事目的，所以也无需设置密码。</p>
<p>如果一切顺利的话，可以在用户主目录里找到 .ssh 目录，里面有 id_rsa 和 id_rsa.pub 两个文件，这两个就是 SSH Key 的秘钥对，id_rsa 是私钥，不能泄露出去，id_rsa.pub 是公钥，可以放心地告诉任何人。</p>
<div><p>提示</p>
<ul>
<li>
<p>ssh-keygen 用来生成一堆密钥，作为您的身份识别信息，您可以放心的把公钥交给别人，留下自己的私钥。</p>
</li>
<li>
<p><code>.ssh</code> 目录是默认隐藏的。Win10 查看隐藏文件详见 <a href="./../../code/windows/hidden-file.html">显示隐藏的文件</a></p>
</li>
</ul>
</div>
<div><p>RSA</p>
<p>RSA 是一种不对称加密，公钥的加密只能通过私钥解开，反之私钥的加密只能由公钥解开。也就是说当您给别人自己的公钥的时候，他们也无法冒充您。</p>
</div>
</li>
<li>
<p>打开 <a href="https://github.com" target="_blank" rel="noopener noreferrer">GitHub</a> 并选择 &quot;Sign in&quot; 注册自己的账号。</p>
<p><img src="./assets/github.png" alt="GitHub 界面简介"></p>
<p>登陆 GitHub 后，点击右上角头像，进入设置。</p>
<p>进入 &quot;安全设置&quot; 下的 &quot;SSH 公钥&quot; 界面。</p>
<p><img src="./assets/githubSSH.png" alt="GitHub 界面简介"></p>
<p>在标题中填写公钥的备注名称，把 id_rsa.pub 文件的内容粘贴到底下的输入框中，设置一个标识此电脑的备注。</p>
</li>
</ol>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <category term="Git"/>
    <contributor>
      <name>南辞</name>
    </contributor>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">Git 介绍</title>
    <id>http://qiqi.dreamagain.top/software/git/intro/</id>
    <link href="http://qiqi.dreamagain.top/software/git/intro/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <summary type="html"><![CDATA[<p>Git 是什么?</p>
<p>Git 是目前世界上最先进的分布式版本控制系统(没有之一)。</p>
]]></summary>
    <content type="html"><![CDATA[<p>Git 是什么?</p>
<p>Git 是目前世界上最先进的分布式版本控制系统(没有之一)。</p>

<h2 id="版本控制系统"> 版本控制系统</h2>
<p>什么是“版本控制”? 版本控制是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。您可以对任何类型的文件进行版本控制。</p>
<ul>
<li>如果您是位图形或网页设计师，可能会需要保存某一幅图片或页面布局文件的所有修订版本(这或许是您非常渴望拥有的功能)</li>
<li>如果您是一名作家，您可能需要保存您对作品的每一次修改以便将来如果随着情节发展需要变动可以撤销它们。</li>
<li>甚至您是一名学生，您的论文也可以进行版本控制。</li>
<li>哪怕您工作了，保存各种报表的各种版本也是没有坏处的。</li>
</ul>
<p>在很多情况下，采用版本控制系统(VCS)都是个明智的选择! 有了它您就可以将选定的文件回溯到之前的状态，甚至将整个项目都回退到过去某个时间点的状态，您可以比较文件的变化细节，查出最后是谁修改了哪个地方，从而找出导致怪异问题出现的原因，又是谁在何时报告了某个功能缺陷等等。使用版本控制系统通常还意味着，就算您乱来一气把整个项目中的文件改的改删的删，您也照样可以轻松恢复到原先的样子。但额外增加的工作量却微乎其微。</p>
<h3 id="本地版本控制系统"> 本地版本控制系统</h3>
<p>许多人习惯用复制整个项目目录的方式来保存不同的版本，或许还会改名加上备份时间以示区别。这么做唯一的好处就是简单，但是特别容易犯错。有时候会混淆所在的工作目录，一不小心会写错文件或者覆盖意想外的文件。为了解决这个问题，人们很久以前就开发了许多种本地版本控制系统，大多都是采用某种简单的数据库来记录文件的历次更新差异。</p>
<p><img src="./assets/RCS.png" alt="本地版本控制系统"></p>
<blockquote>
<p>其中最流行的一种叫做 RCS，现今许多计算机系统上都还看得到它的踪影。RCS 的工作原理是在硬盘上保存补丁集(补丁是指文件修订前后的变化)；通过应用所有的补丁，可以重新计算出各个版本的文件内容。</p>
</blockquote>
<h3 id="集中化的版本控制系统"> 集中化的版本控制系统</h3>
<p>接下来人们又遇到一个问题，如何让在不同系统上的开发者协同工作? 于是，集中化的版本控制系统(Centralized Version Control Systems，简称 CVCS)应运而生。这类系统，诸如 CVS、Subversion 以及 Perforce 等，都有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新。多年以来，这已成为版本控制系统的标准做法。</p>
<p>集中式版本控制系统版本库是集中存放在中央服务器的，而干活的时候，用的都是自己的电脑，所以要先从中央服务器取得最新的版本，然后开始干活，干完活了，再把自己的活推送给中央服务器。中央服务器就好比是一个图书馆，您要改一本书，必须先从图书馆借出来，然后回到家自己改，改完了，再放回图书馆。</p>
<p>这种做法带来了许多好处，特别是相较于老式的本地 VCS 来说 现在，每个人都可以在一定程度上看到项目中的其他人正在做些什么。而管理员也可以轻松掌控每个开发者的权限，并且管理一个 CVCS 要远比在各个客户端上维护本地数据库来得轻松容易。</p>
<p><img src="./assets/intro.jpg" alt="Git示例图"></p>
<p>CVS 作为最早的开源而且免费的集中式版本控制系统，直到现在还有不少人在用。由于 CVS 自身设计的问题，会造成提交文件不完整，版本库莫名其妙损坏的情况。同样是开源而且免费的 SVN 修正了 CVS 的一些稳定性问题，是目前用得最多的集中式版本库控制系统。</p>
<p>事分两面，有好有坏。集中式版本控制系统最大的毛病就是必须联网才能工作，如果在局域网内还好，带宽够大，速度够快，可如果在互联网上，遇到网速慢的话，可能提交一个 10M 的文件就需要 5 分钟。另外若中央服务器的单点故障。如果宕机一小时，那么在这一小时内，谁都无法提交更新，也就无法协同工作。如果中心数据库所在的磁盘发生损坏，又没有做恰当备份，毫无疑问您将丢失所有数据——包括项目的整个变更历史，只剩下人们在各自机器上保留的单独快照。本地版本控制系统也存在类似问题，只要整个项目的历史记录被保存在单一位置，就有丢失所有历史更新记录的风险。</p>
<h3 id="分布式版本控制系统"> 分布式版本控制系统</h3>
<p>于是分布式版本控制系统(Distributed Version Control System，简称 DVCS)面世了。</p>
<p>分布式版本控制系统根本没有“中央服务器”，每个人的电脑上都是一个完整的版本库，这样，您工作的时候，就不需要联网了，因为版本库就在您自己的电脑上。既然每个人电脑上都有一个完整的版本库，那多个人如何协作呢? 比方说您在自己电脑上改了文件 A，您的同事也在他的电脑上改了文件 A，这时，您们俩之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。</p>
<p>和集中式版本控制系统相比，分布式版本控制系统的安全性要高很多，因为每个人电脑里都有完整的版本库，某一个人的电脑坏掉了不要紧，随便从其他人那里复制一个就可以了。而集中式版本控制系统的中央服务器要是出了问题，所有人都没法干活了。</p>
<p><img src="./assets/DVCS.png" alt="分布式版本控制系统"></p>
<div><p>提示</p>
<p>在实际使用分布式版本控制系统的时候，其实很少在两人之间的电脑上推送版本库的修改，因为可能您们俩不在一个局域网内，两台电脑互相访问不了，也可能今天您的同事病了，他的电脑压根没有开机。因此，分布式版本控制系统通常也有一台充当“中央服务器”的电脑，但这个服务器的作用仅仅是用来方便“交换”大家的修改，没有它大家也一样干活，只是交换修改不方便而已。</p>
</div>
<p>在这类系统中，像 Git、Mercurial、Bazaar 以及 Darcs 等，客户端并不只提取最新版本的文件快照，而是把代码仓库完整地镜像下来，包括完整的历史记录。这么一来，任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜像出来的本地仓库恢复。因为每一次的克隆操作，实际上都是一次对代码仓库的完整备份。</p>
<p>更进一步，许多这类系统都可以指定和若干不同的远端代码仓库进行交互。籍此，您就可以在同一个项目中，分别和不同工作小组的人相互协作。您可以根据需要设定不同的协作流程，比如层次模型式的工作流，而这在以前的集中式系统中是无法实现的。</p>
]]></content>
    <author>
      <name>Mr.Hope &amp; 廖雪峰</name>
    </author>
    <category term="Git"/>
    <contributor>
      <name>Mr.Hope &amp; 廖雪峰</name>
    </contributor>
    <rights>Copyright by 廖雪峰 Edited by Mr.Hope</rights>
  </entry>
  <entry>
    <title type="html">Git</title>
    <id>http://qiqi.dreamagain.top/software/git/</id>
    <link href="http://qiqi.dreamagain.top/software/git/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <summary type="html"><![CDATA[<p>Git 是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。在开发中分布式文件管理系统，可以便于多人协作开发。</p>
<div><p>交互式学习</p>
<p>如果您觉得本文太枯燥，这里有一个 <a href="http://learngitbranching.js.org/" target="_blank" rel="noopener noreferrer">交互式的分支演示与学习网站</a>。您可以在这里领略 Git 的魅力。</p>
<p>但 Mr.Hope 仍建议您操作完再系统的学习并阅读以下内容。</p>
</div>
]]></summary>
    <content type="html"><![CDATA[<p>Git 是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。在开发中分布式文件管理系统，可以便于多人协作开发。</p>
<div><p>交互式学习</p>
<p>如果您觉得本文太枯燥，这里有一个 <a href="http://learngitbranching.js.org/" target="_blank" rel="noopener noreferrer">交互式的分支演示与学习网站</a>。您可以在这里领略 Git 的魅力。</p>
<p>但 Mr.Hope 仍建议您操作完再系统的学习并阅读以下内容。</p>
</div>

<h2 id="git-安装"> Git 安装</h2>
<ul>
<li><a href="./install.html">安装教程</a></li>
</ul>
<h2 id="git-教程"> Git 教程</h2>
<ul>
<li>
<p><a href="./intro.html">Git 介绍</a></p>
</li>
<li>
<p><a href="./create-repo.html">创建版本库</a></p>
</li>
<li>
<p><a href="./status.html">纵向查看</a></p>
</li>
<li>
<p><a href="./recall.html">撤销操作</a></p>
</li>
<li>
<p><a href="./reset.html">版本回退</a></p>
</li>
<li>
<p><a href="./working-directory.html">工作区和暂存区</a></p>
</li>
<li>
<p><a href="./change.html">修改管理</a></p>
</li>
<li>
<p><a href="./remote.html">远程仓库</a></p>
</li>
<li>
<p><a href="./branch.html">分支管理</a></p>
</li>
<li>
<p><a href="./tag.html">标签管理</a></p>
</li>
<li>
<p><a href="./ignore.html">忽略特殊文件</a></p>
</li>
</ul>
<h2 id="深入-git"> 深入 Git</h2>
<ul>
<li>
<p><a href="./working.html">Git 原理</a></p>
</li>
<li>
<p><a href="./custom.html">自定义 Git</a></p>
</li>
<li>
<p><a href="./gitLFS.html">大文件管理存储</a></p>
</li>
<li>
<p><a href="./server.html">搭建 Git 服务器</a></p>
</li>
</ul>
<h2 id="扩展阅读"> 扩展阅读</h2>
<ul>
<li>
<p><a href="https://git-scm.com/doc" target="_blank" rel="noopener noreferrer">官方文档</a></p>
</li>
<li>
<p><a href="/file/git/gitCheatSheet.pdf">Git-cheatSheet</a> (PDF)</p>
</li>
<li>
<p><a href="/file/git/progit_v2.1.45.pdf">Pro Git</a> (PDF)</p>
</li>
</ul>
<div><p>TODO</p>
<p>完善分支合并部分，加入更多命令介绍。如 <code>cherry-pick</code>。</p>
</div>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <category term="Git"/>
    <contributor>
      <name>南辞</name>
    </contributor>
    <rights>Copyright by 廖雪峰 Edited by Mr.Hope</rights>
  </entry>
  <entry>
    <title type="html">撤销操作</title>
    <id>http://qiqi.dreamagain.top/software/git/recall/</id>
    <link href="http://qiqi.dreamagain.top/software/git/recall/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<p>在任何一个阶段，您都有可能想要撤消某些操作。这里，我们将会学习几个撤消您所做修改的基本工具。注
意，有些撤消操作是不可逆的。这是在使用 Git 的过程中，会因为操作失误而导致之前的工作丢失的少有的几个
地方之一。</p>
<p>有时候我们提交完了才发现漏掉了几个文件没有添加，或者提交信息写错了。此时，可以运行带有 <code>--amend</code> 选
项的提交命令来重新提交:</p>
<div><pre><code><span>git</span> commit --amend
</code></pre>
<div><span>1</span><br></div></div><p>这个命令会将暂存区中的文件提交。如果自上次提交以来您还未做任何修改(例如，在上次提交后马上执行了
此命令)， 那么快照会保持不变，而您所修改的只是提交信息。</p>
<p>文本编辑器启动后，可以看到之前的提交信息。编辑后保存会覆盖原来的提交信息。</p>
<p>例如，您提交后发现忘记了暂存某些需要的修改，可以像下面这样操作:</p>
<div><pre><code><span>git</span> commit -m <span>'initial commit'</span>
<span>git</span> <span>add</span> forgotten_file
<span>git</span> commit --amend
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>最终您只会有一个提交——第二次提交将代替第一次提交的结果。</p>
<div><p>提示</p>
<p>当您在修补最后的提交时，并不是通过用改进后的提交 原位替换 掉旧有提交的方式来修复
的， 理解这一点非常重要。从效果上来说，就像是旧有的提交从未存在过一样，它并不会出
现在仓库的历史中。</p>
<p>修补提交最明显的价值是可以稍微改进您最后的提交，而不会让“啊，忘了添加一个文件”或
者 “小修补，修正笔误”这种提交信息弄乱您的仓库历史。</p>
</div>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <category term="Git"/>
    <contributor>
      <name>南辞</name>
    </contributor>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">远程仓库</title>
    <id>http://qiqi.dreamagain.top/software/git/remote/</id>
    <link href="http://qiqi.dreamagain.top/software/git/remote/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<h2 id="什么是远程仓库"> 什么是远程仓库</h2>
<p>Git 是分布式版本控制系统，同一个 Git 仓库，可以分布到不同的机器上。怎么分布呢? 最早，肯定只有一台机器有一个原始版本库，此后，别的机器可以“克隆”这个原始版本库，而且每台机器的版本库其实都是一样的，并没有主次之分。</p>
<p>实际情况往往是这样，找一台电脑充当服务器的角色，每天 24 小时开机，其他每个人都从这个“服务器”仓库克隆一份到自己的电脑上，并且各自把各自的提交推送到服务器仓库里，也从服务器仓库中拉取别人的提交。</p>
<p>完全可以自己搭建一台运行 Git 的服务器，不过现阶段，为了学 Git 先搭个服务器绝对是小题大作。好在这个世界上有个叫 GitHub 的神奇的网站，从名字就可以看出，这个网站就是提供 Git 仓库托管服务的，所以，只要注册一个 GitHub 账号，就可以免费获得 Git 远程仓库。</p>
<p>在继续阅读后续内容前，请自行注册 GitHub 账号。由于您的本地 Git 仓库和 GitHub 仓库之间的传输是通过 SSH 加密的，所以，需要一点设置:</p>
<ul>
<li>
<p>第 1 步: 创建 SSH Key。在用户主目录下，看看有没有.ssh 目录，如果有，再看看这个目录下有没有 id_rsa 和 id_rsa.pub 这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开 Shell (Windows 下打开 Git Bash)，创建 SSH Key:</p>
<div><pre><code>ssh-keygen -t rsa -C <span>"youremail@example.com"</span>
</code></pre>
<div><span>1</span><br></div></div><p>您需要把邮件地址换成您自己的邮件地址，然后一路回车，使用默认值即可，由于这个 Key 也不是用于军事目的，所以也无需设置密码。</p>
<p>如果一切顺利的话，可以在用户主目录里找到.ssh 目录，里面有 id_rsa 和 id_rsa.pub 两个文件，这两个就是 SSH Key 的秘钥对，id_rsa 是私钥，不能泄露出去，id_rsa.pub 是公钥，可以放心地告诉任何人。</p>
</li>
<li>
<p>第 2 步: 登陆 GitHub，点击右上角头像，进入设置。</p>
<p>进入安全设置下的 SSH 公钥界面。</p>
<p>在标题中填写公钥的备注名称，把 id_rsa.pub 文件的内容粘贴到底下的输入框中。</p>
</li>
</ul>
<p>为什么 GitHub 需要 SSH Key 呢? 因为 GitHub 需要识别出您推送的提交确实是您推送的，而不是别人冒充的，而 Git 支持 SSH 协议，所以，GitHub 只要知道了您的公钥，就可以确认只有您自己才能推送。</p>
<p>当然，GitHub 允许您添加多个 Key。假定您有若干电脑，您一会儿在公司提交，一会儿在家里提交，只要把每台电脑的 Key 都添加到 GitHub，就可以在每台电脑上往 GitHub 推送了。</p>
<p>最后友情提示，在 GitHub 上免费托管的 Git 仓库，任何人都可以看到喔(但只有您自己才能改)。所以，不要把敏感信息放进去。</p>
<p>如果您不想让别人看到 Git 库，一是让 GitHub 把公开的仓库变成私有的，这样别人就看不见了(不可读更不可写)。另一个办法是自己动手，搭一个 Git 服务器，因为是您自己的 Git 服务器，所以别人也是看不见的。</p>
<p>确保您拥有一个 GitHub 账号后，我们就即将开始远程仓库的学习。</p>
<h2 id="添加远程库"> 添加远程库</h2>
<p>现在的情景是，您已经在本地创建了一个 Git 仓库后，又想在 GitHub 创建一个 Git 仓库，并且让这两个仓库进行远程同步，这样，GitHub 上的仓库既可以作为备份，又可以让其他人通过该仓库来协作，真是一举多得。</p>
<p>首先，登陆 GitHub，然后，在右上角找到 “+” 按钮，点击 &quot;New Repository&quot;。</p>
<p>在项目填入 learngit，其他保持默认设置，点击“创建”按钮，就成功地创建了一个新的 Git 仓库:</p>
<p>目前，在 GitHub 上的这个 learngit 仓库还是空的，GitHub 告诉我们，可以从这个仓库克隆出新的仓库，也可以把一个已有的本地仓库与之关联，然后，把本地仓库的内容推送到 GitHub 仓库。</p>
<p>现在，我们根据 GitHub 的提示，在本地的 learngit 仓库下运行命令:</p>
<div><pre><code><span>git</span> remote <span>add</span> origin git@github.com:Hope-Studio/learngit.git
</code></pre>
<div><span>1</span><br></div></div><p>请千万注意，把上面的 Hope-Studio 替换成您自己的 GitHub 账户名，否则，您在本地关联的就是希望工作室的远程库，关联没有问题，但是推送是推不上去的，因为您的 SSH Key 公钥不在希望工作室的账户列表中。</p>
<p>添加后，远程库的名字就是 <code>origin</code>，这是 Git 默认的叫法，也可以改成别的。</p>
<p>下一步，就可以把本地库的所有内容推送到远程库上:</p>
<div><pre><code>$ <span>git</span> push -u origin master
Counting objects: <span>20</span>, done.
Delta compression using up to <span>4</span> threads.
Compressing objects: <span>100</span>% <span>(</span><span>15</span>/15<span>)</span>, done.
Writing objects: <span>100</span>% <span>(</span><span>20</span>/20<span>)</span>, <span>1.64</span> KiB <span>|</span> <span>560.00</span> KiB/s, done.
Total <span>20</span> <span>(</span>delta <span>5</span><span>)</span>, reused <span>0</span> <span>(</span>delta <span>0</span><span>)</span>
remote: Resolving deltas: <span>100</span>% <span>(</span><span>5</span>/5<span>)</span>, done.
To github.com:Hope-Studio/learngit.git
 * <span>[</span>new branch<span>]</span>      master -<span>></span> master
Branch <span>'master'</span> <span>set</span> up to track remote branch <span>'master'</span> from <span>'origin'</span><span>.</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>把本地库的内容推送到远程，用 <code>git push</code> 命令，实际上是把当前分支 <code>master</code> 推送到远程。</p>
<p>由于远程库是空的，我们第一次推送 <code>master</code> 分支时，加上了 <code>-u</code> 参数，Git 不但会把本地的 <code>master</code> 分支内容推送的远程新的 <code>master</code> 分支，还会把本地的 <code>master</code> 分支和远程的 <code>master</code> 分支关联起来，在以后的推送或者拉取时就可以简化命令。</p>
<p>推送成功后，可以立刻在 GitHub 页面中看到远程库的内容已经和本地一模一样:</p>
<p>从现在起，只要本地作了提交，就可以通过命令:</p>
<div><pre><code><span>git</span> push origin master
</code></pre>
<div><span>1</span><br></div></div><p>把本地 <code>master</code> 分支的最新修改推送至 GitHub，现在，您就拥有了真正的分布式版本库!</p>
<h2 id="ssh-警告"> SSH 警告</h2>
<p>当您第一次使用 Git 的 clone 或者 push 命令连接 GitHub 时，会得到一个警告:</p>
<div><pre><code>The authenticity of <span>host</span> <span>'github.com (xx.xx.xx.xx)'</span> can't be established.
RSA key fingerprint is xx.xx.xx.xx.xx.
Are you sure you want to <span>continue</span> connecting <span>(</span>yes/no<span>)</span>?
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>这是因为 Git 使用 SSH 连接，而 SSH 连接在第一次验证 GitHub 服务器的 Key 时，需要您确认 GitHub 的 Key 的指纹信息是否真的来自 GitHub 的服务器，输入 <code>yes</code> 回车即可。</p>
<p>Git 会输出一个警告，告诉您已经把 GitHub 的 Key 添加到本机的一个信任列表里了:</p>
<div><pre><code>Warning: Permanently added 'github.com' (RSA) to the list of known hosts.
</code></pre>
<div><span>1</span><br></div></div><p>这个警告只会出现一次，后面的操作就不会有任何警告了。</p>
<p>如果您实在担心有人冒充 GitHub 服务器，输入 <code>yes</code> 前可以对照 GitHub 的 RSA Key 的指纹信息是否与 SSH 连接给出的一致。</p>
<h3 id="关联小结"> 关联小结</h3>
<p>要关联一个远程库，使用命令 <code>git remote add origin git@&lt;server-name&gt;:&lt;path&gt;/&lt;repo-name&gt;.git</code>；</p>
<p>关联后，使用命令 <code>git push -u origin master</code> 第一次推送 master 分支的所有内容；</p>
<p>此后，每次本地提交后，只要有必要，就可以使用命令 <code>git push origin master</code> 推送最新修改；</p>
<p>分布式版本系统的最大好处之一是在本地工作完全不需要考虑远程库的存在，也就是有没有联网都可以正常工作，而 SVN 在没有联网的时候是拒绝干活的! 当有网络的时候，再把本地提交推送一下就完成了同步，真是太方便了!</p>
<h2 id="从远程库克隆"> 从远程库克隆</h2>
<p>上次我们讲了先有本地库，后有远程库的时候，如何关联远程库。</p>
<p>现在，假设我们从零开发，那么最好的方式是先创建远程库，然后，从远程库克隆。</p>
<p>首先，登陆 GitHub，创建一个新的仓库，名字叫 <code>gitskills</code>:</p>
<p>我们勾选使用 “readme 初始化项目”，这样 GitHub 会自动为我们创建一个 README.md 文件。创建完毕后，可以看到 README.md 文件。</p>
<p>现在，远程库已经准备好了，下一步是用命令 <code>git clone</code> 克隆一个本地库:</p>
<div><pre><code>$ <span>git</span> clone git@github.com:Hope-Studio/gitskills.git
Cloning into <span>'gitskills'</span><span>..</span>.
remote: Counting objects: <span>3</span>, done.
remote: Total <span>3</span> <span>(</span>delta <span>0</span><span>)</span>, reused <span>0</span> <span>(</span>delta <span>0</span><span>)</span>, pack-reused <span>3</span>
Receiving objects: <span>100</span>% <span>(</span><span>3</span>/3<span>)</span>, done.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><div><p>提示</p>
<p>如果您使用 clone 命令克隆了一个仓库，命令会自动将其添加为远程仓库并默认以 “origin” 为简写。</p>
</div>
<p>注意把 Git 库的地址换成您自己的，然后进入 <code>gitskills</code> 目录看看，已经有 README.md 文件了:</p>
<div><pre><code>$ <span>cd</span> gitskills
$ <span>ls</span>
README.md
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>如果有多个人协作开发，那么每个人各自从远程克隆一份就可以了。</p>
<p>您也许还注意到，GitHub 给出的地址不止一个，还可以用 <a href="https://github.com/Hope-Studio/gitskills.git" target="_blank" rel="noopener noreferrer">https://github.com/Hope-Studio/gitskills.git</a> 这样的地址。实际上，Git 支持多种协议，默认的 <code>git://</code> 使用 ssh，但也可以使用 HTTPS 等其他协议。</p>
<p>使用 HTTPS 除了速度慢以外，还有个最大的麻烦是每次推送都必须输入口令，但是在某些只开放 http 端口的公司内部就无法使用 ssh 协议而只能用 https。</p>
<h3 id="克隆小结"> 克隆小结</h3>
<p>要克隆一个仓库，首先必须知道仓库的地址，然后使用 <code>git clone</code> 命令克隆。</p>
<p>Git 支持多种协议，包括 https，但通过 ssh 支持的原生 git 协议速度最快。</p>
<h2 id="从远程仓库中抓取"> 从远程仓库中抓取</h2>
<p>从远程仓库中获得数据，可以执行:</p>
<div><pre><code><span>git</span> fetch <span>&lt;</span>remote<span>></span>
</code></pre>
<div><span>1</span><br></div></div><p>这个命令会访问远程仓库，从中拉取所有您还没有的数据。执行完成后，您将会拥有那个远程仓库中所有分支的引用，可以随时合并或查看。</p>
<p><code>git fetch origin</code> 会抓取克隆(或上一次抓取)后新推送的所有工作。必须注意 <code>git fetch</code> 命令只会将数据下载到您的本地仓库——它并不会自动合并或修改您当前的工作。当准备好时您必须手动将其合并入您的工作。</p>
<h2 id="推送到远程仓库"> 推送到远程仓库</h2>
<p>当您想分享您的项目时，必须将其推送到上游。这个命令很简单: <code>git push &lt;remote&gt; &lt;branch&gt;</code>。当您
想要将 master 分支推送到 origin 服务器时(再次说明，克隆时通常会自动帮您设置好那两个名字)， 那么
运行这个命令就可以将您所做的备份到服务器:</p>
<div><pre><code><span>git</span> push origin master
</code></pre>
<div><span>1</span><br></div></div><p>只有当您有所克隆服务器的写入权限，并且之前没有人推送过时，这条命令才能生效。当您和其他人在同一时间克隆，他们先推送到上游然后您再推送到上游，您的推送就会毫无疑问地被拒绝。您必须先抓取他们的工作并将其合并进您的工作后才能推送。</p>
<h2 id="查看某个远程仓库"> 查看某个远程仓库</h2>
<p>如果想要查看某一个远程仓库的更多信息，可以使用 <code>git remote show &lt;remote&gt;</code> 命令。如果想以一个特
定的缩写名运行这个命令，例如 origin，会得到像下面类似的信息:</p>
<div><pre><code>$ <span>git</span> remote show origin
* remote origin
Fetch URL: https://github.com/schacon/ticgit
Push URL: https://github.com/schacon/ticgit
HEAD branch: master
Remote branches:
master tracked
dev-branch tracked
Local branch configured <span>for</span> <span>'git pull'</span><span>:</span>
master merges with remote master
Local ref configured <span>for</span> <span>'git push'</span><span>:</span>
master pushes to master <span>(</span>up to <span>date</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>它同样会列出远程仓库的 URL 与跟踪分支的信息。这些信息非常有用，它告诉您正处于 master 分支，并且如果运行 <code>git pull</code>，就会抓取所有的远程引用，然后将远程 master 分支合并到本地 master 分支。它也会列出拉取到的所有远程引用。</p>
<h2 id="远程仓库的重命名与移除"> 远程仓库的重命名与移除</h2>
<p>您可以运行 <code>git remote rename</code> 来修改一个远程仓库的简写名。例如，想要将 pb 重命名为 paul，可以用 <code>git remote rename</code> 这样做:</p>
<div><pre><code>$ <span>git</span> remote <span>rename</span> pb paul
$ <span>git</span> remote
origin
paul
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>值得注意的是这同样也会修改您所有远程跟踪的分支名字。那些过去引用 <code>pb/master</code> 的现在会引用 <code>paul/master</code>。</p>
<p>如果因为一些原因想要移除一个远程仓库——您已经从服务器上搬走了或不再想使用某一个特定的镜像了，又或者某一个贡献者不再贡献了——可以使用 <code>git remote remove</code> 或 <code>git remote rm</code>:</p>
<div><pre><code>$ <span>git</span> remote remove paul
$ <span>git</span> remote
origin
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>一旦您使用这种方式删除了一个远程仓库，那么所有和这个远程仓库相关的远程跟踪分支以及配置信息也会一起被删除。</p>
]]></content>
    <author>
      <name>廖雪峰</name>
    </author>
    <category term="Git"/>
    <contributor>
      <name>廖雪峰</name>
    </contributor>
    <rights>Copyright by 廖雪峰 Edited by Mr.Hope</rights>
  </entry>
  <entry>
    <title type="html">版本回退</title>
    <id>http://qiqi.dreamagain.top/software/git/reset/</id>
    <link href="http://qiqi.dreamagain.top/software/git/reset/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<p>修改 readme.txt 文件如下:</p>
<div><pre><code>Git is a distributed version control system.
Git is free software distributed under the GPL.
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>然后尝试提交:</p>
<div><pre><code>$ <span>git</span> <span>add</span> readme.txt
<span># nothing displayed</span>
$ <span>git</span> commit -m <span>"append GPL"</span>
<span>[</span>master 1094adb<span>]</span> append GPL
 <span>1</span> <span>file</span> changed, <span>1</span> insertion<span>(</span>+<span>)</span>, <span>1</span> deletion<span>(</span>-<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>像这样不断对文件进行修改，然后不断提交修改到版本库里，每当文件修改到一定程度的时候，就可以“保存一个快照”，这个快照在 Git 中被称为 <code>commit</code>。如果把文件改乱了，或者误删了文件，还可以从最近的一个 <code>commit</code> 恢复，然后继续工作，而不是把几个月的工作成果全部丢失。</p>
<p>现在，我们回顾一下 <code>readme.txt</code> 文件一共有几个版本被提交到 Git 仓库里了:</p>
<ul>
<li>版本 1: wrote a readme file</li>
</ul>
<div><pre><code>Git is a version control system.
Git is free software.
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><ul>
<li>版本 2: add distributed</li>
</ul>
<div><pre><code>Git is a distributed version control system.
Git is free software.
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><ul>
<li>版本 3: append GPL</li>
</ul>
<div><pre><code>Git is a distributed version control system.
Git is free software distributed under the GPL.
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h2 id="查看版本信息"> 查看版本信息</h2>
<p>版本控制系统用 <code>git log</code> 命令可以告诉我们历史记录，在 Git 中，我们查看:</p>
<div><pre><code>$ <span>git</span> log
commit 1094adb7b9b3807259d8cb349e7df1d4d6477073 <span>(</span>HEAD -<span>></span> master<span>)</span>
Author: Michael Liao <span>&lt;</span>askxuefeng@gmail.com<span>></span>
Date:   Fri May <span>18</span> <span>21</span>:06:15 <span>2018</span> +0800

    append GPL

commit e475afc93c209a690c39c13a46716e8fa000c366
Author: Michael Liao <span>&lt;</span>askxuefeng@gmail.com<span>></span>
Date:   Fri May <span>18</span> <span>21</span>:03:36 <span>2018</span> +0800

    <span>add</span> distributed

commit eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0
Author: Michael Liao <span>&lt;</span>askxuefeng@gmail.com<span>></span>
Date:   Fri May <span>18</span> <span>20</span>:59:18 <span>2018</span> +0800

    wrote a readme <span>file</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><p><code>git log</code> 命令显示从最近到最远的提交日志，我们可以看到 3 次提交，最近的一次是 <code>append GPL</code>，上一次是 <code>add distributed</code>，最早的一次是 <code>wrote a readme file</code>。</p>
<p>如果嫌输出信息太多，看得眼花缭乱的，可以试试加上 <code>--pretty=oneline</code> 参数:</p>
<div><pre><code>$ <span>git</span> log --pretty<span>=</span>oneline
1094adb7b9b3807259d8cb349e7df1d4d6477073 <span>(</span>HEAD -<span>></span> master<span>)</span> append GPL
e475afc93c209a690c39c13a46716e8fa000c366 <span>add</span> distributed
eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0 wrote a readme <span>file</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>一大串类似 <code>1094adb...</code> 的是 commit id (版本号)，和 SVN 不一样，Git 的 commit id 不是 1，2，3…… 递增的数字，而是一个 SHA1 计算出来的一个非常大的数字，用十六进制表示，为什么 commit id 需要用这么一大串数字表示呢? 因为 Git 是分布式的版本控制系统，多人在同一个版本库里工作，如果大家都用 1，2，3…… 作为版本号，那肯定就冲突了。</p>
<p>每提交一个新版本，实际上 Git 就会把它们自动串成一条时间线。如果使用可视化工具查看 Git 历史，就可以更清楚地看到提交历史的时间线:</p>
<p><img src="./assets/timeline.jpg" alt="Git 时间线"></p>
<div><p>更多选项</p>
<p>关于 <code>git log</code> 的更多选项，请见 <a href="/file/git/progit_v2.1.45.pdf">ProGit 书籍</a> 的 P43。</p>
</div>
<h2 id="回退版本"> 回退版本</h2>
<p>好了，现在准备把 readme.txt 回退到上一个版本，也就是 <code>add distributed</code> 的那个版本，怎么做呢?</p>
<p>首先，Git 必须知道当前版本是哪个版本，在 Git 中，用 <code>HEAD</code> 表示当前版本，也就是最新的提交 <code>1094adb...</code> (注意我的提交 ID 和您的肯定不一样)，上一个版本就是 <code>HEAD^</code>，上上一个版本就是 <code>HEAD^^</code>，当然往上 100 个版本写 100 个 <code>^</code> 比较容易数不过来，所以写成 <code>HEAD~100</code>。</p>
<p>现在，要把当前版本 <code>append GPL</code> 回退到上一个版本 <code>add distributed</code>，就可以使用 <code>git reset</code> 命令:</p>
<div><pre><code>$ <span>git</span> reset --hard HEAD^
HEAD is now at e475afc <span>add</span> distributed
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>看看 readme.txt 的内容是不是版本 add distributed:</p>
<div><pre><code>$ <span>cat</span> readme.txt
Git is a distributed version control system.
Git is <span>free</span> software.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>果然被还原了。</p>
<p>还可以继续回退到上一个版本 wrote a readme file，不过且慢，然我们用 <code>git log</code> 再看看现在版本库的状态:</p>
<div><pre><code>$ <span>git</span> log
commit e475afc93c209a690c39c13a46716e8fa000c366 <span>(</span>HEAD -<span>></span> master<span>)</span>
Author: Michael Liao <span>&lt;</span>askxuefeng@gmail.com<span>></span>
Date:   Fri May <span>18</span> <span>21</span>:03:36 <span>2018</span> +0800

    <span>add</span> distributed

commit eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0
Author: Michael Liao <span>&lt;</span>askxuefeng@gmail.com<span>></span>
Date:   Fri May <span>18</span> <span>20</span>:59:18 <span>2018</span> +0800

    wrote a readme <span>file</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>最新的那个版本 append GPL 已经看不到了! 肿么办?</p>
<p>办法其实还是有的，只要上面的命令行窗口还没有被关掉，您就可以顺着往上找啊找啊，找到那个 append GPL 的 commit id 是 1094adb...，于是就可以指定回到未来的某个版本:</p>
<div><pre><code>$ <span>git</span> reset --hard 1094a
HEAD is now at 83b0afe append GPL
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>版本号没必要写全，前几位就可以了，Git 会自动去找。当然也不能只写前一两位，因为 Git 可能会找到多个版本号，就无法确定是哪一个了。</p>
<p>再小心翼翼地看看 readme.txt 的内容:</p>
<div><pre><code>$ <span>cat</span> readme.txt
Git is a distributed version control system.
Git is <span>free</span> software distributed under the GPL.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>果然，我胡汉三又回来了。</p>
<p>Git 的版本回退速度非常快，因为 Git 在内部有个指向当前版本的 <code>HEAD</code> 指针，当您回退版本的时候，Git 仅仅是把 <code>HEAD</code> 从指向 append GPL:</p>
<p><img src="./assets/git1.jpg" alt="示例图4"></p>
<p>改为指向 <code>add distributed</code>:</p>
<p><img src="./assets/git2.jpg" alt="示例图5"></p>
<p>然后顺便把工作区的文件更新了。所以您让 <code>HEAD</code> 指向哪个版本号，您就把当前版本定位在哪。</p>
<h2 id="找回-commit-id"> 找回 commit id</h2>
<p>如果回退到了某个版本找不到新版本的 <code>commit id</code>，在 Git 中，就无法用 <code>$ git reset --hard HEAD^</code> 回退。</p>
<p>所以 Git 提供了一个命令 <code>git reflog</code> 用来记录您的每一次命令:</p>
<div><pre><code>$ <span>git</span> reflog
e475afc HEAD@<span>{</span><span>1</span><span>}</span>: reset: moving to HEAD^
1094adb <span>(</span>HEAD -<span>></span> master<span>)</span> HEAD@<span>{</span><span>2</span><span>}</span>: commit: append GPL
e475afc HEAD@<span>{</span><span>3</span><span>}</span>: commit: <span>add</span> distributed
eaadf4e HEAD@<span>{</span><span>4</span><span>}</span>: commit <span>(</span>initial<span>)</span>: wrote a readme <span>file</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><div><pre><code>$ <span>git</span> reflog
e475afc HEAD@<span>{</span><span>1</span><span>}</span>: reset: moving to HEAD^
1094adb <span>(</span>HEAD -<span>></span> master<span>)</span> HEAD@<span>{</span><span>2</span><span>}</span>: commit: append GPL
e475afc HEAD@<span>{</span><span>3</span><span>}</span>: commit: <span>add</span> distributed
eaadf4e HEAD@<span>{</span><span>4</span><span>}</span>: commit <span>(</span>initial<span>)</span>: wrote a readme <span>file</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>终于舒了口气，从输出可知，append GPL 的 commit id 是 1094adb，现在，您又可以乘坐时光机回到未来了。</p>
<h2 id="小结"> 小结</h2>
<ul>
<li>
<p><code>HEAD</code> 指向的版本就是当前版本，因此，Git 允许我们在版本的历史之间穿梭，使用命令 <code>git reset --hard commit_id</code>。</p>
</li>
<li>
<p>用 <code>git log</code> 可以查看提交历史，以便确定要回退到哪个版本。</p>
</li>
<li>
<p>用 <code>git reflog</code> 查看命令历史，以便确定要回到未来的哪个版本。</p>
</li>
</ul>
]]></content>
    <author>
      <name>廖雪峰</name>
    </author>
    <category term="Git"/>
    <contributor>
      <name>廖雪峰</name>
    </contributor>
    <rights>Copyright by 廖雪峰 Edited by Mr.Hope</rights>
  </entry>
  <entry>
    <title type="html">服务器搭建</title>
    <id>http://qiqi.dreamagain.top/software/git/server/</id>
    <link href="http://qiqi.dreamagain.top/software/git/server/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <summary type="html"><![CDATA[<p>在远程仓库一节中，我们讲了远程仓库实际上和本地仓库没啥不同，纯粹为了 7x24 小时开机并交换大家的修改。</p>
<p>GitHub 就是一个免费托管代码的远程仓库。但是对于某些视源代码如生命的商业公司来说，不想将源代码提交给任何第三方，这种情况下，就需要搭建 Git 服务器。</p>
]]></summary>
    <content type="html"><![CDATA[<p>在远程仓库一节中，我们讲了远程仓库实际上和本地仓库没啥不同，纯粹为了 7x24 小时开机并交换大家的修改。</p>
<p>GitHub 就是一个免费托管代码的远程仓库。但是对于某些视源代码如生命的商业公司来说，不想将源代码提交给任何第三方，这种情况下，就需要搭建 Git 服务器。</p>

<p>搭建 Git 服务器需要准备一台运行 Linux 的机器，强烈推荐用 Ubuntu 或 Debian，这样，通过几条简单的 <code>apt</code> 命令就可以完成安装。</p>
<ul>
<li>
<p><strong>Ubuntu</strong> 或 <strong>Debian</strong></p>
<p>假设您已经有 sudo 权限的用户账号，下面，正式开始安装。</p>
<ul>
<li>
<p>第一步，安装 git:</p>
<div><pre><code><span>sudo</span> <span>apt-get</span> <span>install</span> <span>git</span>
</code></pre>
<div><span>1</span><br></div></div></li>
<li>
<p>第二步，创建一个 git 用户，用来运行 git 服务:</p>
<div><pre><code><span>sudo</span> adduser <span>git</span>
</code></pre>
<div><span>1</span><br></div></div></li>
<li>
<p>第三步，创建证书登录:</p>
<p>收集所有需要登录的用户的公钥，就是他们自己的 <code>id_rsa.pub</code> 文件，把所有公钥导入到 <code>/home/git/.ssh/authorized_keys</code> 文件里，一行一个。</p>
</li>
<li>
<p>第四步，初始化 Git 仓库:</p>
<p>先选定一个目录作为 Git 仓库，假定是 <code>/srv/sample.git</code>，在 <code>/srv</code> 目录下输入命令:</p>
<div><pre><code><span>sudo</span> <span>git</span> init --bare sample.git
</code></pre>
<div><span>1</span><br></div></div><p>Git 就会创建一个裸仓库，裸仓库没有工作区，因为服务器上的 Git 仓库纯粹是为了共享，所以不让用户直接登录到服务器上去改工作区，并且服务器上的 Git 仓库通常都以 <code>.git</code> 结尾。然后，把 owner 改为 git:</p>
<div><pre><code><span>sudo</span> <span>chown</span> -R git:git sample.git
</code></pre>
<div><span>1</span><br></div></div></li>
<li>
<p>第五步，禁用 shell 登录:</p>
<p>出于安全考虑，第二步创建的 git 用户不允许登录 shell，这可以通过编辑 <code>/etc/passwd</code> 文件完成。找到类似下面的一行:</p>
<div><pre><code>git:x:1001:1001:,,,:/home/git:/bin/bash
</code></pre>
<div><span>1</span><br></div></div><p>改为:</p>
<div><pre><code>git:x:1001:1001:,,,:/home/git:/usr/bin/git-shell
</code></pre>
<div><span>1</span><br></div></div><p>这样，git 用户可以正常通过 ssh 使用 git，但无法登录 shell，因为我们为 git 用户指定的 git-shell 每次一登录就自动退出。</p>
</li>
<li>
<p>第六步，克隆远程仓库:</p>
<p>现在，可以通过 <code>git clone</code> 命令克隆远程仓库了，在各自的电脑上运行:</p>
<div><pre><code>$ <span>git</span> clone git@server:/srv/sample.git
Cloning into <span>'sample'</span><span>..</span>.
warning: You appear to have cloned an empty repository.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>剩下的推送就简单了。</p>
</li>
</ul>
</li>
<li>
<p><strong>Centos</strong></p>
<ol>
<li>
<p>安装 Git</p>
<div><pre><code>yum <span>install</span> curl-devel expat-devel gettext-devel openssl-devel zlib-devel perl-devel
yum <span>install</span> <span>git</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>接下来创建一个 git 用户组和用户，用来运行 git 服务:</p>
<div><pre><code><span>groupadd</span> <span>git</span>
<span>useradd</span> <span>git</span> -g <span>git</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div></li>
<li>
<p>创建证书登录</p>
<p>收集所有需要登录的用户的公钥，公钥位于 <code>id_rsa.pub</code> 文件中，将公钥导入到 <code>/home/git/.ssh/authorized_keys</code> 文件里，一行一个。</p>
<p>如果没有该文件创建它:</p>
<div><pre><code><span>cd</span> /home/git/
<span>mkdir</span> .ssh
<span>chmod</span> <span>755</span> .ssh
<span>touch</span> .ssh/authorized_keys
<span>chmod</span> <span>644</span> .ssh/authorized_keys
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div></li>
<li>
<p>初始化 Git 仓库</p>
<p>首先我们选定一个目录作为 Git 仓库，假定是 <code>/home/gitrepo/test.git</code>，在 <code>/home/gitrepo</code> 目录下输入命令:</p>
<div><pre><code>$ <span>cd</span> /home
$ <span>mkdir</span> gitrepo
$ <span>chown</span> git:git gitrepo/
$ <span>cd</span> gitrepo

$ <span>git</span> init --bare test.git
Initialized empty Git repository <span>in</span> /home/gitrepo/runoob.git/
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>以上命令 Git 创建一个空仓库，服务器上的 Git 仓库通常都以 <code>.git</code> 结尾。然后，把仓库所属用户改为 git:</p>
<div><pre><code><span>chown</span> -R git:git runoob.git
</code></pre>
<div><span>1</span><br></div></div></li>
<li>
<p>克隆仓库</p>
</li>
</ol>
<div><pre><code>$ <span>git</span> clone git@192.168.45.4:/home/gitrepo/runoob.git
Cloning into <span>'runoob'</span><span>..</span>.
warning: You appear to have cloned an empty repository.
Checking connectivity<span>..</span>. done.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>192.168.45.4 为 Git 所在服务器 ip ，您需要将其修改为您自己的 Git 服务 ip。</p>
<p>这样我们的 Git 服务器安装就完成。</p>
</li>
</ul>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <category term="Git"/>
    <contributor>
      <name>南辞</name>
    </contributor>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">纵向查看</title>
    <id>http://qiqi.dreamagain.top/software/git/status/</id>
    <link href="http://qiqi.dreamagain.top/software/git/status/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<p>我们已经成功地添加并提交了一个 readme.txt 文件，继续修改 readme.txt 文件，改成如下内容:</p>
<div><pre><code>Git is a distributed version control system.
Git is free software.
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>现在，运行 <code>git status</code> 命令看看结果:</p>
<div><pre><code>$ <span>git</span> status
On branch master
Changes not staged <span>for</span> commit:
  <span>(</span>use <span>"git add &lt;file>..."</span> to update what will be committed<span>)</span>
  <span>(</span>use <span>"git checkout -- &lt;file>..."</span> to discard changes <span>in</span> working directory<span>)</span>

    modified:   readme.txt

no changes added to commit <span>(</span>use <span>"git add"</span> and/or <span>"git commit -a"</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p><code>git status</code> 命令可以输出仓库当前的状态，上面的命令输出告诉我们，readme.txt 被修改过了，但还没有准备提交的修改。</p>
<div><p>简介输出</p>
<p><code>git status</code> 命令的输出十分详细，但其用语有些繁琐。Git 有一个选项可以帮您缩短状态命令的输出，这样可以以简洁的方式查看更改。如果您使用 <code>git status -s</code> 命令或 <code>git status --short</code> 命令，您将得到一种格式更为紧凑的输出。</p>
<p>输出中有两栏，左栏指明了暂存区的状态，右栏指明了工作区的状态。</p>
<p>新添加的未跟踪文件前面有 <code>??</code> 标记，新添加到暂存区中的文件前面有 <code>A</code> 标记，修改过的文件前面有 <code>M</code> 标记。</p>

          <div
            id="code-demo-5afacdea"
           
  
 data-title="%E6%A1%88%E4%BE%8B"

            data-code="%7B%22sh%22%3A%22%24%20git%20status%20-s%5Cn%C2%A0M%20README%5CnMM%20Rakefile%5CnA%20%20lib%2Fgit.rb%5CnM%20%20lib%2Fsimplegit.rb%5Cn%3F%3F%20LICENSE.txt%5Cn%22%7D"
          >
              <div>
                
              </div>
              <div>
                <div>
<div><pre><code>$ <span>git</span> status -s
 M README
MM Rakefile
A  lib/git.rb
M  lib/simplegit.rb
?? LICENSE.txt
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>上面的状态报告显示: <code>README</code> 文件在工作区已修改但尚未暂存，而 <code>lib/simplegit.rb</code> 文件已修改且已暂存。<code>Rakefile</code> 文件已修改，暂存后又作了修改，因此该文件的修改中既有已暂存的部分，又有未暂存的部分。</p>

            </div>
          </div>
          
        </div>
<p>:
:::</p>
<p>Git 现在只告诉我们 readme.txt 被修改了，我们用 <code>git diff</code> 这个命令能看看具体修改了什么内容:</p>
<div><pre><code>$ <span>git</span> <span>diff</span> readme.txt
<span>diff</span> --git a/readme.txt b/readme.txt
index 46d49bf<span>..</span>9247db6 <span>100644</span>
--- a/readme.txt
+++ b/readme.txt
@@ -1,2 +1,2 @@
-Git is a version control system.
+Git is a distributed version control system.
 Git is <span>free</span> software.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p><code>git diff</code> 顾名思义就是查看 difference，显示的格式正是 Unix 通用的 diff 格式，可以从上面的命令输出看到，我们在第一行添加了一个 distributed 单词。</p>
<p>知道了对 readme.txt 作了什么修改后，再把它提交到仓库就放心多了，提交修改和提交新文件是一样的两步，第一步是 <code>git add</code>:</p>
<div><pre><code>$ <span>git</span> <span>add</span> readme.txt
--no output --
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>同样没有任何输出。在执行第二步 <code>git commit</code> 之前，我们再运行 <code>git status</code> 看看当前仓库的状态:</p>
<div><pre><code>$ <span>git</span> status
On branch master
Changes to be committed:
  <span>(</span>use <span>"git reset HEAD &lt;file>..."</span> to unstage<span>)</span>

    modified:   readme.txt
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p><code>git status</code> 告诉我们，将要被提交的修改包括 readme.txt，下一步，就可以放心地提交了:</p>
<div><pre><code>$ <span>git</span> commit -m <span>"add distributed"</span>
<span>[</span>master e475afc<span>]</span> <span>add</span> distributed
 <span>1</span> <span>file</span> changed, <span>1</span> insertion<span>(</span>+<span>)</span>, <span>1</span> deletion<span>(</span>-<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>提交后，我们再用 <code>git status</code> 命令看看仓库的当前状态:</p>
<div><pre><code>$ <span>git</span> status
On branch master
nothing to commit, working tree clean
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>Git 告诉我们当前没有需要提交的修改，而且，工作目录是干净(working tree clean)的。</p>
<h2 id="小结"> 小结</h2>
<ul>
<li>
<p>要随时掌握工作区的状态，使用 <code>git status</code> 命令。</p>
</li>
<li>
<p>如果 <code>git status</code> 告诉您有文件被修改过，用 <code>git diff</code> 可以查看修改内容。</p>
</li>
</ul>
</div>
]]></content>
    <author>
      <name>廖雪峰</name>
    </author>
    <category term="Git"/>
    <contributor>
      <name>廖雪峰</name>
    </contributor>
    <rights>Copyright by 廖雪峰 Edited by Mr.Hope</rights>
  </entry>
  <entry>
    <title type="html">标签管理</title>
    <id>http://qiqi.dreamagain.top/software/git/tag/</id>
    <link href="http://qiqi.dreamagain.top/software/git/tag/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<h2 id="为什么要有-tag"> 为什么要有 tag</h2>
<p>发布一个版本时，我们通常先在版本库中打一个标签 (<code>tag</code>)，这样，就唯一确定了打标签时刻的版本。将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。所以，标签也是版本库的一个快照。</p>
<p>Git 的标签虽然是版本库的快照，但其实它就是指向某个 <code>commit</code> 的指针(跟分支很像对不对? 但是分支可以移动，标签不能移动)，所以，创建和删除标签都是瞬间完成的。</p>
<p>Git 有 <code>commit</code>，为什么还要引入 <code>tag</code>?</p>
<p>“请把上周一的那个版本打包发布，<code>commit</code> 号是 6a5819e...”</p>
<p>“一串乱七八糟的数字不好找! ”</p>
<p>如果换一个办法:</p>
<p>“请把上周一的那个版本打包发布，版本号是 <code>v1.2</code>”</p>
<p>“好的，按照 <code>tag v1.2</code> 查找 <code>commit</code> 就行! ”</p>
<p>所以，<code>tag</code> 就是一个让人容易记住的有意义的名字，它跟某个 <code>commit</code> 绑在一起。</p>
<div><p>提示</p>
<p>推荐的标签规范是以小写字母 <code>v</code> 开头，后接 <code>x.x</code> 或 <code>x.x.x</code> 等若干位版本号。</p>
</div>
<h2 id="创建轻量标签"> 创建轻量标签</h2>
<p>在 Git 中打标签非常简单，首先，切换到需要打标签的分支上:</p>
<div><pre><code>$ <span>git</span> branch
* dev
  master
$ <span>git</span> checkout master
Switched to branch <span>'master'</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>然后，敲命令 <code>git tag &lt;name&gt;</code> 就可以打一个新标签:</p>
<div><pre><code>$ <span>git</span> tag v1.0
-- no output --
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>可以用命令 <code>git tag</code> 查看所有标签:</p>
<div><pre><code>$ <span>git</span> tag
v1.0
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>默认标签是打在最新提交的 <code>commit</code> 上的。有时候，如果忘了打标签，比如，现在已经是周五了，但应该在周一打的标签没有打，怎么办?</p>
<p>方法是找到历史提交的 <code>commit id</code>，然后打上就可以了:</p>
<div><pre><code>$ <span>git</span> log --pretty<span>=</span>oneline --abbrev-commit
12a631b <span>(</span>HEAD -<span>></span> master, tag: v1.0, origin/master<span>)</span> merged bug fix <span>101</span>
4c805e2 fix bug <span>101</span>
e1e9c68 merge with no-ff
f52c633 <span>add</span> merge
cf810e4 conflict fixed
5dc6824 <span>&amp;</span> simple
14096d0 AND simple
b17d20e branch <span>test</span>
d46f35e remove test.txt
b84166e <span>add</span> test.txt
519219b <span>git</span> tracks changes
e43a48b understand how stage works
1094adb append GPL
e475afc <span>add</span> distributed
eaadf4e wrote a readme <span>file</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>比方说要对 <code>add merge</code> 这次提交打标签，它对应的 <code>commit id</code> 是 <code>f52c633</code>，敲入命令:</p>
<div><pre><code>$ <span>git</span> tag v0.9 f52c633
--no output --
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>再用命令 <code>git tag</code> 查看标签:</p>
<div><pre><code>$ <span>git</span> tag
v0.9
v1.0
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>注意，标签不是按时间顺序列出，而是按字母排序的。可以用 <code>git show &lt;tagname&gt;</code> 查看标签信息:</p>
<div><pre><code>$ <span>git</span> show v0.9
commit f52c63349bc3c1593499807e5c8e972b82c8f286 <span>(</span>tag: v0.9<span>)</span>
Author: Michael Liao <span>&lt;</span>askxuefeng@gmail.com<span>></span>
Date:   Fri May <span>18</span> <span>21</span>:56:54 <span>2018</span> +0800

    <span>add</span> merge

<span>diff</span> --git a/readme.txt b/readme.txt
<span>..</span>.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>可以看到，<code>v0.9</code> 确实打在 <code>add merge</code> 这次提交上。</p>
<h2 id="附注标签"> 附注标签</h2>
<p>Git 还可以创建带有说明的标签，用 <code>-a</code> 指定标签名，<code>-m</code> 指定说明文字:</p>
<div><pre><code>$ <span>git</span> tag -a v0.1 -m <span>"version 0.1 released"</span> 1094adb
--no output --
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>用命令 <code>git show &lt;tagname&gt;</code> 可以看到说明文字:</p>
<div><pre><code>$ <span>git</span> show v0.1
tag v0.1
Tagger: Michael Liao <span>&lt;</span>askxuefeng@gmail.com<span>></span>
Date:   Fri May <span>18</span> <span>22</span>:48:43 <span>2018</span> +0800

version <span>0.1</span> released

commit 1094adb7b9b3807259d8cb349e7df1d4d6477073 <span>(</span>tag: v0.1<span>)</span>
Author: Michael Liao <span>&lt;</span>askxuefeng@gmail.com<span>></span>
Date:   Fri May <span>18</span> <span>21</span>:06:15 <span>2018</span> +0800

    append GPL

<span>diff</span> --git a/readme.txt b/readme.txt
<span>..</span>.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><div><p>提示</p>
<p>标签总是和某个 commit 挂钩。如果这个 commit 既出现在 master 分支，又出现在 dev 分支，那么在这两个分支上都可以看到这个标签。</p>
</div>
<h3 id="添加小结"> 添加小结</h3>
<p>命令 <code>git tag &lt;tagname&gt;</code> 用于新建一个标签，默认为 <code>HEAD</code>，也可以指定一个 <code>commit id</code>；</p>
<p>命令 <code>git tag -a &lt;tagname&gt; -m &quot;blablabla...&quot;</code> 可以指定标签信息；</p>
<p>命令 <code>git tag</code> 可以查看所有标签。</p>
<h2 id="操作标签"> 操作标签</h2>
<p>如果标签打错了，也可以删除:</p>
<div><pre><code>$ <span>git</span> tag -d v0.1
Deleted tag <span>'v0.1'</span> <span>(</span>was f15b0dd<span>)</span><span>\</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>因为创建的标签都只存储在本地，不会自动推送到远程。所以，打错的标签可以在本地安全删除。</p>
<p>如果要推送某个标签到远程，使用命令 <code>git push origin &lt;tagname&gt;</code>:</p>
<div><pre><code>$ <span>git</span> push origin v1.0
Total <span>0</span> <span>(</span>delta <span>0</span><span>)</span>, reused <span>0</span> <span>(</span>delta <span>0</span><span>)</span>
To github.com:Hope-Studio/learngit.git
 * <span>[</span>new tag<span>]</span>         v1.0 -<span>></span> v1.0
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>或者，一次性推送全部尚未推送到远程的本地标签:</p>
<div><pre><code>$ <span>git</span> push origin --tags
Total <span>0</span> <span>(</span>delta <span>0</span><span>)</span>, reused <span>0</span> <span>(</span>delta <span>0</span><span>)</span>
To github.com:Hope-Studio/learngit.git
 * <span>[</span>new tag<span>]</span>         v0.9 -<span>></span> v0.9
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>如果标签已经推送到远程，要删除远程标签就麻烦一点，先从本地删除:</p>
<div><pre><code>$ <span>git</span> tag -d v0.9
Deleted tag <span>'v0.9'</span> <span>(</span>was f52c633<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>然后，从远程删除。删除命令也是 push，但是格式如下:</p>
<div><pre><code>$ <span>git</span> push origin :refs/tags/v0.9
To github.com:Hope-Studio/learngit.git
 - <span>[</span>deleted<span>]</span>         v0.9
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>要看看是否真的从远程库删除了标签，可以登陆 GitHub 查看。</p>
<h3 id="管理标签小结"> 管理标签小结</h3>
<ul>
<li>
<p>命令 <code>git push origin &lt;tagname&gt;</code> 可以推送一个本地标签；</p>
</li>
<li>
<p>命令 <code>git push origin --tags</code> 可以推送全部未推送过的本地标签；</p>
</li>
<li>
<p>命令 <code>git tag -d &lt;tagname&gt;</code> 可以删除一个本地标签；</p>
</li>
<li>
<p>命令 <code>git push origin :refs/tags/&lt;tagname&gt;</code> 可以删除一个远程标签。</p>
</li>
</ul>
]]></content>
    <author>
      <name>廖雪峰</name>
    </author>
    <category term="Git"/>
    <contributor>
      <name>廖雪峰</name>
    </contributor>
    <rights>Copyright by 廖雪峰 Edited by Mr.Hope</rights>
  </entry>
  <entry>
    <title type="html">工作区和暂存区</title>
    <id>http://qiqi.dreamagain.top/software/git/working-directory/</id>
    <link href="http://qiqi.dreamagain.top/software/git/working-directory/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <summary type="html"><![CDATA[<p>Git 和其他版本控制系统如 SVN 的一个不同之处就是有暂存区的概念。</p>
]]></summary>
    <content type="html"><![CDATA[<p>Git 和其他版本控制系统如 SVN 的一个不同之处就是有暂存区的概念。</p>

<h2 id="工作区-working-directory"> 工作区(Working Directory)</h2>
<p>就是您在电脑里能看到的目录，比如 learngit 文件夹就是一个工作区:</p>
<h2 id="版本库-repository"> 版本库(Repository)</h2>
<p>工作区有一个隐藏目录.git，这个不算工作区，而是 Git 的版本库。</p>
<p>Git 的版本库里存了很多东西，其中最重要的就是称为 stage(或者叫 index)的暂存区，还有 Git 为我们自动创建的第一个分支 <code>master</code>，以及指向 master 的一个指针叫 <code>HEAD</code>。</p>
<p><img src="./assets/git3.jpg" alt="版本库图例"></p>
<p>前面讲了我们把文件往 Git 版本库里添加的时候，提交更改，实际上就是把暂存区的所有内容提交到当前分支。我们创建 Git 版本库时，Git 自动为我们创建了唯一一个 <code>master</code> 分支，所以，现在，<code>git commit</code> 就是往 master 分支上提交更改。</p>
<p>您可以简单理解为，需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。</p>
<p>先对 readme.txt 做个修改，比如加上一行内容:</p>
<div><pre><code>Git is a distributed version control system.
Git is free software distributed under the GPL.
Git has a mutable index called stage.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>然后，在工作区新增一个 LICENSE 文本文件(内容随便写)。</p>
<p>先用 <code>git status</code> 查看一下状态:</p>
<div><pre><code>$ <span>git</span> status
On branch master
Changes not staged <span>for</span> commit:
  <span>(</span>use <span>"git add &lt;file>..."</span> to update what will be committed<span>)</span>
  <span>(</span>use <span>"git checkout -- &lt;file>..."</span> to discard changes <span>in</span> working directory<span>)</span>

    modified:   readme.txt

Untracked files:
  <span>(</span>use <span>"git add &lt;file>..."</span> to include <span>in</span> what will be committed<span>)</span>

    LICENSE

no changes added to commit <span>(</span>use <span>"git add"</span> and/or <span>"git commit -a"</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>Git 非常清楚地告诉我们，readme.txt 被修改了，而 LICENSE 还从来没有被添加过，所以它的状态是 <code>Untracked</code>。</p>
<p>现在，使用两次命令 <code>git add</code>，把 readme.txt 和 LICENSE 都添加后，用 <code>git status</code> 再查看一下:</p>
<div><pre><code>$ <span>git</span> status
On branch master
Changes to be committed:
  <span>(</span>use <span>"git reset HEAD &lt;file>..."</span> to unstage<span>)</span>

    new file:   LICENSE
    modified:   readme.txt
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>现在，暂存区的状态就变成这样了:</p>
<p><img src="./assets/git4.jpg" alt="状态示意图"></p>
<p>所以，<code>git add</code> 命令实际上就是把要提交的所有修改放到暂存区(Stage)，然后，执行 <code>git commit</code> 就可以一次性把暂存区的所有修改提交到分支。</p>
<div><pre><code>$ <span>git</span> commit -m <span>"understand how stage works"</span>
<span>[</span>master e43a48b<span>]</span> understand how stage works
 <span>2</span> files changed, <span>2</span> insertions<span>(</span>+<span>)</span>
 create mode <span>100644</span> LICENSE
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>一旦提交后，如果您又没有对工作区做任何修改，那么工作区就是“干净”的:</p>
<div><pre><code>$ <span>git</span> status
On branch master
nothing to commit, working tree clean
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div>]]></content>
    <author>
      <name>廖雪峰</name>
    </author>
    <category term="Git"/>
    <contributor>
      <name>廖雪峰</name>
    </contributor>
    <rights>Copyright by 廖雪峰 Edited by Mr.Hope</rights>
  </entry>
  <entry>
    <title type="html">Git 原理</title>
    <id>http://qiqi.dreamagain.top/software/git/working/</id>
    <link href="http://qiqi.dreamagain.top/software/git/working/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<p>Git 究竟是怎样的一个系统呢? 尽管 Git 用起来与其它的版本控制系统非常相似，但它在对信息的存储和认知方式上却有很大差异。</p>
<h2 id="直接记录快照-而非差异比较"> 直接记录快照，而非差异比较</h2>
<p>Git 和其它版本控制系统(包括 Subversion 和近似工具)的主要差别在于 Git 对待数据的方法。从概念上来说，其它大部分系统以文件变更列表的方式存储信息，这类系统(CVS、Subversion、Perforce、Bazaar 等等)将它们存储的信息看作是一组基本文件和每个文件随时间逐步累积的差异 (它们通常称作 基于差异(delta-based) 的版本控制)。</p>
<p><img src="./assets/delta-based.png" alt="基于差异"></p>
<p>Git 不按照以上方式对待或保存数据。反之，Git 更像是把数据看作是对小型文件系统的一系列快照。在 Git 中，每当您提交更新或保存项目状态时，它基本上就会对当时的全部文件创建一个快照并保存这个快照的索引。为了效率，如果文件没有修改，Git 不再重新存储该文件，而是只保留一个链接指向之前存储的文件。Git 对待数据更像是一个 <strong>快照流</strong>。</p>
<p><img src="./assets/snapshot.png" alt="基于快照"></p>
<h2 id="近乎所有操作都是本地执行"> 近乎所有操作都是本地执行</h2>
<p>在 Git 中的绝大多数操作都只需要访问本地文件和资源，一般不需要来自网络上其它计算机的信息。如果您习惯于所有操作都有网络延时开销的集中式版本控制系统，Git 在这方面会让您感到速度之神赐给了 Git 超凡的能量。因为您在本地磁盘上就有项目的完整历史，所以大部分操作看起来瞬间完成。举个例子，要浏览项目的历史，Git 不需外连到服务器去获取历史，然后再显示出来——它只需直接从本地数据库中读取。您能立即看到项目历史。如果您想查看当前版本与一个月前的版本之间引入的修改， Git 会查找到一个月前的文件做一次本地的差异计算，而不是由远程服务器处理或从远程服务器拉回旧版本文件再来本地处理。</p>
<h2 id="git-保证完整性"> Git 保证完整性</h2>
<p>Git 中所有的数据在存储前都计算校验和，然后以校验和来引用。这意味着不可能在 Git 不知情时更改任何文件内容或目录内容。这个功能建构在 Git 底层，是构成 Git 哲学不可或缺的部分。若您在传送过程中丢失信息或损坏文件，Git 就能发现。</p>
<p>Git 用以计算校验和的机制叫做 SHA-1 散列(hash，哈希)。这是一个由 40 个十六进制字符(0-9 和 a-f)组成的字符串，基于 Git 中文件的内容或目录结构计算出来。Git 中使用这种哈希值的情况很多，您将经常看到这种哈希值。实际上，Git 数据库中保存的信息都是以文件内容的哈希值来索引，而不是文件名。</p>
<h2 id="git-一般只添加数据"> Git 一般只添加数据</h2>
<p>您执行的 Git 操作，几乎只往 Git 数据库中 添加 数据。您很难让 Git 执行任何不可逆操作，或者让它以任何方式清除数据。同别的 VCS 一样，未提交更新时有可能丢失或弄乱修改的内容。但是一旦您提交快照到 Git 中， 就难以再丢失数据，特别是如果您定期的推送数据库到其它仓库的话。</p>
<p>这使得我们使用 Git 成为一个安心愉悦的过程，因为我们深知可以尽情做各种尝试，而没有把事情弄糟的危险。</p>
<h2 id="三种状态"> 三种状态</h2>
<p>Git 有三种状态，您的文件可能处于其中之一: 已提交(committed)、已修改(modified) 和 已暂存(staged)。</p>
<ul>
<li>已修改表示修改了文件，但还没保存到数据库中。</li>
<li>已暂存表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。</li>
<li>已提交表示数据已经安全地保存在本地数据库中。</li>
</ul>
<p>这会让我们的 Git 项目拥有三个阶段: 工作区、暂存区以及 Git 目录。</p>
<p>工作区是对项目的某个版本独立提取出来的内容。这些从 Git 仓库的压缩数据库中提取出来的文件，放在磁盘上供您使用或修改。
暂存区是一个文件，保存了下次将要提交的文件列表信息，一般在 Git 仓库目录中。按照 Git 的术语叫做“索引”，不过一般说法还是叫“暂存区”。
Git 仓库目录是 Git 用来保存项目的元数据和对象数据库的地方。这是 Git 中最重要的部分，从其它计算机克隆仓库时，复制的就是这里的数据。
基本的 Git 工作流程如下:</p>
<ol>
<li>在工作区中修改文件。</li>
<li>将您想要下次提交的更改选择性地暂存，这样只会将更改的部分添加到暂存区。</li>
<li>提交更新，找到暂存区的文件，将快照永久性存储到 Git 目录。</li>
</ol>
<p>如果 Git 目录中保存着特定版本的文件，就属于 已提交 状态。如果文件已修改并放入暂存区，就属于 已暂存 状态。如果自上次检出后，作了修改但还没有放到暂存区域，就是 已修改 状态。</p>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <category term="Git"/>
    <contributor>
      <name>南辞</name>
    </contributor>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">WSL</title>
    <id>http://qiqi.dreamagain.top/software/linux/WSL/</id>
    <link href="http://qiqi.dreamagain.top/software/linux/WSL/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <summary type="html"><![CDATA[<p>WSL 可以直接在 Windows 系统上安装并运行 Linux。目前最新的版本是 WSL2。</p>
]]></summary>
    <content type="html"><![CDATA[<p>WSL 可以直接在 Windows 系统上安装并运行 Linux。目前最新的版本是 WSL2。</p>

<h2 id="ubuntu"> Ubuntu</h2>
<p>Windows 上的功能有很大缺失。已知不能用 Snap。</p>
<h2 id="wsl-文件位置"> WSL 文件位置</h2>
<div><pre><code>C:\Users\%USERNAME%\AppData\Local\Packages\CanonicalGroupLimited.UbuntuonWindows_79rhkp1fndgsc\LocalState\rootfs
</code></pre>
<div><span>1</span><br></div></div><h2 id="重启-wsl"> 重启 WSL</h2>
<p>使用</p>
<div><pre><code>net stop LxssManager
</code></pre>
<div><span>1</span><br></div></div><p>和</p>
<div><pre><code>net start LxssManager
</code></pre>
<div><span>1</span><br></div></div>]]></content>
    <author>
      <name>南辞</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>南辞</name>
    </contributor>
    <published>2019-11-23T00:00:00.000Z</published>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">归档和备份</title>
    <id>http://qiqi.dreamagain.top/software/linux/bash/archives/archiving/</id>
    <link href="http://qiqi.dreamagain.top/software/linux/bash/archives/archiving/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<h1 id="归档和备份"> 归档和备份</h1>
<h2 id="gzip"> gzip</h2>
<p>gzip 程序用来压缩文件，原文件的压缩版(添加 <code>gz</code> 后缀名)会替代原文件。gunzip 程序用来还原压缩版本。</p>
<div><pre><code><span>gzip</span> foo.txt
gunzip foo.txt.gz
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><code>gzip</code> 的参数如下。</p>
<ul>
<li>-c 把输出写入到标准输出，并且保留原始文件。也有可能用--stdout 和--to-stdout 选项来指定。</li>
<li>-d 解压缩。正如 gunzip 命令一样。也可以用--decompress 或者--uncompress 选项来指定.</li>
<li>-f 强制压缩，即使原始文件的压缩文件已经存在了，也要执行。也可以用--force 选项来指定。</li>
<li>-h 显示用法信息。也可用--help 选项来指定。</li>
<li>-l 列出每个被压缩文件的压缩数据。也可用--list 选项。</li>
<li>-r 若命令的一个或多个参数是目录，则递归地压缩目录中的文件。也可用--recursive 选项来指定。</li>
<li>-t 测试压缩文件的完整性。也可用--test 选项来指定。</li>
<li>-v 显示压缩过程中的信息。也可用--verbose 选项来指定。</li>
<li>-number 设置压缩指数。number 是一个在 1(最快，最小压缩)到 9(最慢，最大压缩)之间的整数。数值 1 和 9 也可以各自用--fast 和--best 选项来表示。默认值是整数 6。</li>
</ul>
<p>下面是一些例子。</p>
<div><pre><code><span># 查看解压缩后的内容</span>
$ gunzip -c foo.txt <span>|</span> <span>less</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><code>zcat</code> 程序等同于带有-c 选项的 gunzip 命令。它可以像 <code>cat</code> 命令那样，用来查看 <code>gzip</code> 压缩文件。</p>
<div><pre><code>zcat foo.txt.gz <span>|</span> <span>less</span>
</code></pre>
<div><span>1</span><br></div></div><h2 id="bzip2"> bzip2</h2>
<p><code>bzip2</code> 程序与 <code>gzip</code> 程序相似，但是使用了不同的压缩算法，舍弃了压缩速度，实现了更高的压缩级别。在大多数情况下，它的工作模式等同于 <code>gzip</code>。由 <code>bzip2</code> 压缩的文件，用扩展名 <code>.bz2</code> 表示。</p>
<div><pre><code><span>bzip2</span> foo.txt
bunzip2 foo.txt.bz2
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>gzip 程序的所有选项(除了 <code>-r</code>)，bzip2 程序同样也支持。同样有 bunzip2 和 bzcat 程序来解压缩文件。bzip2 文件也带有 bzip2recover 程序，其会 试图恢复受损的 .bz2 文件。</p>
<h2 id="zip"> zip</h2>
<p><code>zip</code> 程序既是压缩工具，也是一个打包工具，读取和写入.zip 文件。</p>
<div><pre><code><span>zip</span> options zipfile file<span>..</span>.
</code></pre>
<div><span>1</span><br></div></div><p>它的用法如下。</p>
<div><pre><code><span># 将指定目录压缩成zip文件</span>
$ <span>zip</span> -r playground.zip playground
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><code>zip</code> 与 <code>tar</code> 命令有一个相反之处。如果压缩文件已存在，其将被更新而不是被替代。这意味着会保留此文件包，但是会添加新文件，同时替换匹配的文件。</p>
<p>解压使用 <code>unzip</code> 命令。</p>
<div><pre><code><span>unzip</span> <span>..</span>/playground.zip
</code></pre>
<div><span>1</span><br></div></div><p><code>unzip</code> 命令的参数如下。</p>
<ul>
<li><code>-l</code> 列出文件包中的内容而不解压</li>
<li><code>-v</code> 显示冗余信息</li>
<li><code>-p</code> 输出发送到标准输出</li>
</ul>
<div><pre><code><span>unzip</span> -p ls-etc.zip <span>|</span> <span>less</span>
</code></pre>
<div><span>1</span><br></div></div><h2 id="tar"> tar</h2>
<p><code>tar</code> 是 tape archive 的简称，原来是一款制作磁带备份的工具，现在主要用于打包。一个 tar 包可以由一组独立的文件，一个或者多个目录，或者两者混合体组成。</p>
<p><code>tar</code> 程序的语法如下。</p>
<div><pre><code><span>tar</span> mode<span>[</span>options<span>]</span> pathname<span>..</span>.
</code></pre>
<div><span>1</span><br></div></div><p>tar 支持以下模式。</p>
<ul>
<li>c 表示 create，为文件和／或目录列表创建归档文件。</li>
<li>x 抽取归档文件。</li>
<li>r 追加具体的路径到归档文件的末尾。</li>
<li>t 列出归档文件的内容。</li>
</ul>
<p>支持的参数如下。</p>
<ul>
<li>f 表示 file，用来指定生成的文件。</li>
</ul>
<p>模式和参数可以写在一起，而且不需要开头的短横线。注意，必须首先指定模式，然后才是其它的选项。</p>
<div><pre><code><span># 创建子目录的tar包</span>
$ <span>tar</span> cf playground.tar playground

<span># 查看tar包内容</span>
$ <span>tar</span> tf playground.tar

<span># 查看更详细的列表信息</span>
$ <span>tar</span> tvf playground.tar

<span># 还原归档文件</span>
$ <span>tar</span> xf playground.tar

<span># 还原单个文件</span>
$ <span>tar</span> xf archive.tar pathname

<span># 还原文件到指定目录</span>
$ <span>tar</span> xvf archive.tar -C /home/me/

<span># 追加文件</span>
$ <span>tar</span> rf archive.tar file.txt

<span># 验证归档文件内容是否正确</span>
$ <span>tar</span> tvfW archive.tar

<span># 支持通配符</span>
$ <span>tar</span> xf <span>..</span>/playground2.tar --wildcards <span>'home/me/playground/\*.txt'</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><p>注意，<code>tar</code> 命令还原的时候，总是还原为相对路径。如果归档的时候，保存的是绝对路径，那么还原的时候，这个绝对路径会整个变成相对路径。</p>
<p><code>find</code> 命令可以与 <code>tar</code> 命令配合使用。</p>
<div><pre><code><span>find</span> playground -name <span>'file.txt'</span> -exec <span>tar</span> rf playground.tar <span>'{}'</span> <span>'+'</span>
</code></pre>
<div><span>1</span><br></div></div><p>上面的命令先用 <code>find</code> 程序找到所有名为 <code>file.txt</code> 的文件，然后使用追加模式(<code>r</code>)的 <code>tar</code> 命令，把匹配的文件添加到归档文件 <code>playground.tar</code> 里面。</p>
<p>这种 <code>tar</code> 和 <code>find</code> 的配合使用，可以创建逐渐增加的目录树或者整个系统的备份。通过 <code>find</code> 命令匹配新于某个时间戳的文件，我们就能够创建一个归档文件，其只包含新于上一个 tar 包的文件。</p>
<p>tar 支持压缩功能。</p>
<div><pre><code><span># 打成gzip压缩包</span>
$ <span>tar</span> czvf assets.tar.gz dist

<span># 打成bz2压缩包</span>
$ <span>tar</span> cvfj assets.tar.bz2 dist

<span># 解压 tar.gz 文件</span>
$ <span>tar</span> xzv archive.tar.gz
$ <span>tar</span> xvf archive.tar.gz

<span># 解压bz2压缩包</span>
$ <span>tar</span> xvf archive.tar.bz2

<span># 显示gzip压缩包内容</span>
$ <span>tar</span> tvf archive.tar.gz

<span># 显示bz2压缩包内容</span>
$ <span>tar</span> tvf archive.tar.bz2

<span># 从gzip压缩包取出单个文件</span>
$ <span>tar</span> zxvf archive.tar.gz file.txt

<span># 从bz2压缩包取出单个文件</span>
$ <span>tar</span> jxvf archive.tar.bz2 file.txt

<span># 按通配符取出文件</span>
$ <span>tar</span> zxvf archive.tar.gz --wildcards <span>'*.php'</span>
$ <span>tar</span> jxvf archive.tar.bz2 --wildcards <span>'*.php'</span>

<span># 追加文件到压缩包</span>
$ <span>tar</span> rvf archive.tar.gz xyz.txt
$ <span>tar</span> rvf archive.tar.bz2 xyz.txt
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br></div></div><h2 id="rsync"> rsync</h2>
<p><code>rsync</code> 命令用于在多个目录之间、或者本地与远程目录之间同步。字母 <code>r</code> 表示 <code>remote</code>。</p>
<div><pre><code><span>rsync</span> options <span>source</span> destination
</code></pre>
<div><span>1</span><br></div></div><p>source 和 destination 是下列选项之一:</p>
<ul>
<li>一个本地文件或目录</li>
<li>一个远端文件或目录，以 <code>[user@]host:path</code> 的形式存在</li>
<li>一个远端 rsync 服务器，由 <code>rsync://[user@]host[:port]/path</code> 指定</li>
</ul>
<p>注意 source 和 destination 两者之一必须是本地文件。rsync 不支持远端到远端的复制。</p>
<p><code>rsync</code> 命令的参数如下。</p>
<ul>
<li><code>-a</code> 递归和保护文件属性</li>
<li><code>-v</code> 冗余输出</li>
<li><code>--delete</code> 删除可能在备份设备中已经存在但却不再存在于源设备中的文件</li>
<li><code>--rsh=ssh</code> 使用 ssh 程序作为远程 shell，目的地必须标注主机名。</li>
</ul>
<div><pre><code><span># 同步两个本地目录</span>
$ <span>rsync</span> -av playground foo

<span># 删除源设备不存在的文件</span>
$ <span>sudo</span> <span>rsync</span> -av --delete /etc /home /usr/local /media/BigDisk/backup

<span># 远程同步</span>
$ <span>sudo</span> <span>rsync</span> -av --delete --rsh<span>=</span>ssh /etc /home /usr/local remote-sys:/backup

<span># 与远程rsync主机同步</span>
$ <span>rsync</span> -av -delete rsync://rsync.gtlib.gatech.edu/path/to/oss fedora-devel
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div>]]></content>
    <author>
      <name>南辞</name>
    </author>
    <contributor>
      <name>南辞</name>
    </contributor>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">异步任务</title>
    <id>http://qiqi.dreamagain.top/software/linux/bash/archives/async/</id>
    <link href="http://qiqi.dreamagain.top/software/linux/bash/archives/async/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<h1 id="异步任务"> 异步任务</h1>
<p>Bash 脚本有时候需要同时执行多个任务。通常这涉及到启动一个脚本，依次，启动一个或多个子脚本来执行额外的任务，而父脚本继续运行。然而，当一系列脚本 以这种方式运行时，要保持父子脚本之间协调工作，会有一些问题。也就是说，若父脚本或子脚本依赖于另一方，并且 一个脚本必须等待另一个脚本结束任务之后，才能完成它自己的任务，这应该怎么办?</p>
<p>bash 有一个内置命令，能帮助管理诸如此类的异步执行的任务。wait 命令导致一个父脚本暂停运行，直到一个 特定的进程(例如，子脚本)运行结束。</p>
<p>首先我们将演示一下 wait 命令的用法。为此，我们需要两个脚本，一个父脚本:</p>
<div><pre><code><span>#!/bin/bash</span>
<span># async-parent : Asynchronous execution demo (parent)</span>
<span>echo</span> <span>"Parent: starting..."</span>
<span>echo</span> <span>"Parent: launching child script..."</span>
async-child <span>&amp;</span>
<span>pid</span><span>=</span><span>$!</span>
<span>echo</span> <span>"Parent: child (PID= <span>$pid</span>) launched."</span>
<span>echo</span> <span>"Parent: continuing..."</span>
<span>sleep</span> <span>2</span>
<span>echo</span> <span>"Parent: pausing to wait for child to finish..."</span>
<span>wait</span> <span>$pid</span>
<span>echo</span> <span>"Parent: child is finished. Continuing..."</span>
<span>echo</span> <span>"Parent: parent is done. Exiting."</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>和一个子脚本:</p>
<div><pre><code><span>#!/bin/bash</span>
<span># async-child : Asynchronous execution demo (child)</span>
<span>echo</span> <span>"Child: child is running..."</span>
<span>sleep</span> <span>5</span>
<span>echo</span> <span>"Child: child is done. Exiting."</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>在这个例子中，我们看到该子脚本是非常简单的。真正的操作通过父脚本完成。在父脚本中，子脚本被启动， 并被放置到后台运行。子脚本的进程 ID 记录在 pid 变量中，这个变量的值是 $! shell 参数的值，它总是 包含放到后台执行的最后一个任务的进程 ID 号。</p>
<p>父脚本继续，然后执行一个以子进程 PID 为参数的 wait 命令。这就导致父脚本暂停运行，直到子脚本退出， 意味着父脚本结束。</p>
<p>当执行后，父子脚本产生如下输出:</p>
<div><pre><code>$ async-parent
Parent: starting<span>..</span>.
Parent: launching child script<span>..</span>.
Parent: child <span>(</span>PID<span>=</span> <span>6741</span><span>)</span> launched.
Parent: continuing<span>..</span>.
Child: child is running<span>..</span>.
Parent: pausing to <span>wait</span> <span>for</span> child to finish<span>..</span>.
Child: child is done. Exiting.
Parent: child is finished. Continuing<span>..</span>.
Parent: parent is done. Exiting.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div>]]></content>
    <author>
      <name>南辞</name>
    </author>
    <contributor>
      <name>南辞</name>
    </contributor>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">cal</title>
    <id>http://qiqi.dreamagain.top/software/linux/bash/archives/commands/cal/</id>
    <link href="http://qiqi.dreamagain.top/software/linux/bash/archives/commands/cal/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<h1 id="cal"> cal</h1>
<p><code>cal</code> 命令显示本月的日历。</p>
<div><pre><code><span>cal</span>
</code></pre>
<div><span>1</span><br></div></div>]]></content>
    <author>
      <name>南辞</name>
    </author>
    <contributor>
      <name>南辞</name>
    </contributor>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">awk</title>
    <id>http://qiqi.dreamagain.top/software/linux/bash/archives/commands/awk/</id>
    <link href="http://qiqi.dreamagain.top/software/linux/bash/archives/commands/awk/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<h1 id="awk"> awk</h1>
<p><a href="https://en.wikipedia.org/wiki/AWK" target="_blank" rel="noopener noreferrer"><code>awk</code></a>是处理文本文件的一个应用程序，几乎所有 Linux 系统都自带这个程序。</p>
<p>它依次处理文件的每一行，并读取里面的每一个字段。对于日志、CSV 那样的每行格式相同的文本文件，<code>awk</code> 可能是最方便的工具。</p>
<p><img src="https://www.wangbase.com/blogimg/asset/201811/bg2018110702.jpg" alt="Book"></p>
<p><code>awk</code> 其实不仅仅是工具软件，还是一种编程语言。不过，这里只介绍它的命令行用法，对于大多数场合，应该足够用了。</p>
<h2 id="基本用法"> 基本用法</h2>
<p><code>awk</code> 的基本用法就是下面的形式。</p>
<div><pre><code><span># 格式</span>
$ <span>awk</span> 动作 文件名

<span># 示例</span>
$ <span>awk</span> <span>'{print <span>$0</span>}'</span> demo.txt
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>上面示例中，<code>demo.txt</code> 是 <code>awk</code> 所要处理的文本文件。前面单引号内部有一个大括号，里面就是每一行的处理动作 <code>print $0</code>。其中，<code>print</code> 是打印命令，<code>$0</code> 代表当前行，因此上面命令的执行结果，就是把每一行原样打印出来。</p>
<p>下面，我们先用标准输入(stdin)演示上面这个例子。</p>
<div><pre><code>$ <span>echo</span> <span>'this is a test'</span> <span>|</span> <span>awk</span> <span>'{print <span>$0</span>}'</span>
this is a <span>test</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>上面代码中，<code>print $0</code> 就是把标准输入 <code>this is a test</code>，重新打印了一遍。</p>
<p><code>awk</code> 会根据空格和制表符，将每一行分成若干字段，依次用<code>$1</code>、<code>$2</code>、<code>$3</code> 代表第一个字段、第二个字段、第三个字段等等。</p>
<div><pre><code>$ <span>echo</span> <span>'this is a test'</span> <span>|</span> <span>awk</span> <span>'{print <span>$3</span>}'</span>
a
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>上面代码中，<code>$3</code> 代表 <code>this is a test</code> 的第三个字段 <code>a</code>。</p>
<p>下面，为了便于举例，我们把<code>/etc/passwd</code> 文件保存成 <code>demo.txt</code>。</p>
<div><pre><code>root:x:0:0:root:/root:/usr/bin/zsh
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
sync:x:4:65534:sync:/bin:/bin/sync
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>这个文件的字段分隔符是冒号(<code>:</code>)，所以要用 <code>-F</code> 参数指定分隔符为冒号。然后，才能提取到它的第一个字段。</p>
<div><pre><code>$ <span>awk</span> -F <span>':'</span> <span>'{ print <span>$1</span> }'</span> demo.txt
root
daemon
bin
sys
<span>sync</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h2 id="变量"> 变量</h2>
<p>除了<code>$ + 数字</code>表示某个字段，<code>awk</code> 还提供其他一些变量。</p>
<p>变量 <code>NF</code> 表示当前行有多少个字段，因此<code>$NF</code> 就代表最后一个字段。</p>
<div><pre><code>$ <span>echo</span> <span>'this is a test'</span> <span>|</span> <span>awk</span> <span>'{print <span>$NF</span>}'</span>
<span>test</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><code>$(NF-1)</code> 代表倒数第二个字段。</p>
<div><pre><code>$ <span>awk</span> -F <span>':'</span> <span>'{print <span>$1</span>, <span><span>$(</span>NF-1<span>)</span></span>}'</span> demo.txt
root /root
daemon /usr/sbin
bin /bin
sys /dev
<span>sync</span> /bin
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>上面代码中，<code>print</code> 命令里面的逗号，表示输出的时候，两个部分之间使用空格分隔。</p>
<p>变量 <code>NR</code> 表示当前处理的是第几行。</p>
<div><pre><code>$ <span>awk</span> -F <span>':'</span> <span>'{print NR ") " <span>$1</span>}'</span> demo.txt
<span>1</span><span>)</span> root
<span>2</span><span>)</span> daemon
<span>3</span><span>)</span> bin
<span>4</span><span>)</span> sys
<span>5</span><span>)</span> <span>sync</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>上面代码中，<code>print</code> 命令里面，如果原样输出字符，要放在双引号里面。</p>
<p><code>awk</code> 的其他内置变量如下。</p>
<blockquote>
<ul>
<li><code>FILENAME</code>: 当前文件名</li>
<li><code>FS</code>: 字段分隔符，默认是空格和制表符。</li>
<li><code>RS</code>: 行分隔符，用于分割每一行，默认是换行符。</li>
<li><code>OFS</code>: 输出字段的分隔符，用于打印时分隔字段，默认为空格。</li>
<li><code>ORS</code>: 输出记录的分隔符，用于打印时分隔记录，默认为换行符。</li>
<li><code>OFMT</code>: 数字输出的格式，默认为<code>％.6g</code>。</li>
</ul>
</blockquote>
<h2 id="函数"> 函数</h2>
<p><code>awk</code> 还提供了一些内置函数，方便对原始数据的处理。</p>
<p>函数 <code>toupper()</code> 用于将字符转为大写。</p>
<div><pre><code>$ <span>awk</span> -F <span>':'</span> <span>'{ print toupper(<span>$1</span>) }'</span> demo.txt
ROOT
DAEMON
BIN
SYS
SYNC
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>上面代码中，第一个字段输出时都变成了大写。</p>
<p>其他常用函数如下。</p>
<blockquote>
<ul>
<li><code>tolower()</code>: 字符转为小写。</li>
<li><code>length()</code>: 返回字符串长度。</li>
<li><code>substr()</code>: 返回子字符串。</li>
<li><code>sin()</code>: 正弦。</li>
<li><code>cos()</code>: 余弦。</li>
<li><code>sqrt()</code>: 平方根。</li>
<li><code>rand()</code>: 随机数。</li>
</ul>
</blockquote>
<p><code>awk</code> 内置函数的完整列表，可以查看<a href="https://www.gnu.org/software/gawk/manual/html_node/Built_002din.html#Built_002din" target="_blank" rel="noopener noreferrer">手册</a>。</p>
<h2 id="条件"> 条件</h2>
<p><code>awk</code> 允许指定输出条件，只输出符合条件的行。</p>
<p>输出条件要写在动作的前面。</p>
<div><pre><code><span>awk</span> <span>'条件 动作'</span> 文件名
</code></pre>
<div><span>1</span><br></div></div><p>请看下面的例子。</p>
<div><pre><code>$ <span>awk</span> -F <span>':'</span> <span>'/usr/ {print <span>$1</span>}'</span> demo.txt
root
daemon
bin
sys
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>上面代码中，<code>print</code> 命令前面是一个正则表达式，只输出包含 <code>usr</code> 的行。</p>
<p>下面的例子只输出奇数行，以及输出第三行以后的行。</p>
<div><pre><code><span># 输出奇数行</span>
$ <span>awk</span> -F <span>':'</span> <span>'NR % 2 == 1 {print <span>$1</span>}'</span> demo.txt
root
bin
<span>sync</span>

<span># 输出第三行以后的行</span>
$ <span>awk</span> -F <span>':'</span> <span>'NR >3 {print <span>$1</span>}'</span> demo.txt
sys
<span>sync</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>下面的例子输出第一个字段等于指定值的行。</p>
<div><pre><code>$ <span>awk</span> -F <span>':'</span> <span>'<span>$1</span> == "root" {print <span>$1</span>}'</span> demo.txt
root

$ <span>awk</span> -F <span>':'</span> <span>'<span>$1</span> == "root" || <span>$1</span> == "bin" {print <span>$1</span>}'</span> demo.txt
root
bin
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h2 id="if-语句"> if 语句</h2>
<p><code>awk</code> 提供了 <code>if</code> 结构，用于编写复杂的条件。</p>
<div><pre><code>$ <span>awk</span> -F <span>':'</span> <span>'{if (<span>$1</span> > "m") print <span>$1</span>}'</span> demo.txt
root
sys
<span>sync</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>上面代码输出第一个字段的第一个字符大于 <code>m</code> 的行。</p>
<p><code>if</code> 结构还可以指定 <code>else</code> 部分。</p>
<div><pre><code>$ <span>awk</span> -F <span>':'</span> <span>'{if (<span>$1</span> > "m") print <span>$1</span>; else print "---"}'</span> demo.txt
root
---
---
sys
<span>sync</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h2 id="参考链接"> 参考链接</h2>
<ul>
<li><a href="https://gregable.com/2010/09/why-you-should-know-just-little-awk.html" target="_blank" rel="noopener noreferrer">An Awk tutorial by Example</a>, Greg Grothaus</li>
<li><a href="https://likegeeks.com/awk-command/" target="_blank" rel="noopener noreferrer">30 Examples for Awk Command in Text Processing</a>, Mokhtar Ebrahim</li>
</ul>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <contributor>
      <name>南辞</name>
    </contributor>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">cat</title>
    <id>http://qiqi.dreamagain.top/software/linux/bash/archives/commands/cat/</id>
    <link href="http://qiqi.dreamagain.top/software/linux/bash/archives/commands/cat/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<h1 id="cat"> cat</h1>
<p><code>cat</code> 命令用于显示一个文本文件的内容。</p>
<p><code>cat - &gt;&gt; filename</code> 用于向一个现有文件的尾部追加内容。</p>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <contributor>
      <name>南辞</name>
    </contributor>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">clear</title>
    <id>http://qiqi.dreamagain.top/software/linux/bash/archives/commands/clear/</id>
    <link href="http://qiqi.dreamagain.top/software/linux/bash/archives/commands/clear/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<h1 id="clear"> clear</h1>
<p><code>clear</code> 命令用来清除当前屏幕的显示，运行后会只留下一个提示符。</p>
<div><pre><code><span>clear</span>
</code></pre>
<div><span>1</span><br></div></div>]]></content>
    <author>
      <name>南辞</name>
    </author>
    <contributor>
      <name>南辞</name>
    </contributor>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">cp 命令</title>
    <id>http://qiqi.dreamagain.top/software/linux/bash/archives/commands/cp/</id>
    <link href="http://qiqi.dreamagain.top/software/linux/bash/archives/commands/cp/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<h1 id="cp-命令"> cp 命令</h1>
<p><code>cp</code> 命令用于复制文件。</p>
<h2 id="参数"> 参数</h2>
<p><code>-u</code> 参数只复制那些目标目录里面还不存在的文件，以及那些虽然存在、但是比源目录对应文件更陈旧的文件。</p>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <contributor>
      <name>南辞</name>
    </contributor>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">cut</title>
    <id>http://qiqi.dreamagain.top/software/linux/bash/archives/commands/cut/</id>
    <link href="http://qiqi.dreamagain.top/software/linux/bash/archives/commands/cut/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<h1 id="cut"> cut</h1>
<p><code>cut</code> 命令用于在命令行输出文本文件的指定位置的内容。</p>
<p>它的使用格式如下。</p>
<div><pre><code><span>cut</span> OPTION <span>[</span>FILE<span>]</span>
</code></pre>
<div><span>1</span><br></div></div><p>如果没有指定文件名，将读取标准输入。</p>
<p><code>-b</code> 参数用来指定读取的字节。</p>
<div><pre><code><span># 输出前三个字节</span>
$ <span>cut</span> file1.txt -b1,2,3

<span># 输出前十个字节</span>
$ <span>cut</span> file1.txt -b1-10

<span># 输出从第5个字节开始的所有字节</span>
$ <span>cut</span> file1.txt -b5-

<span># 输出前5个字节</span>
$ <span>cut</span> file1.txt -b-5
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p><code>-c</code> 参数用来指定读取的字符，用法与 <code>-b</code> 一样。有的字符是多字节字符，这时候就应该用 <code>-c</code> 代替 <code>-b</code>。</p>
<p><code>-d</code> 参数用来指定分隔符，默认分隔符为制表符。</p>
<p><code>-f</code> 参数用来指定字段。</p>
<div><pre><code><span># 指定每一行的分隔符为逗号，</span>
<span># 输出第一和第三个字段</span>
$ <span>cut</span> file1.txt -d, -f1,3

<span># 输出第一、第二、第四和第五个字段</span>
$ <span>cut</span> -f <span>1</span>-2,4-5 data.txt
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div>]]></content>
    <author>
      <name>南辞</name>
    </author>
    <contributor>
      <name>南辞</name>
    </contributor>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">date</title>
    <id>http://qiqi.dreamagain.top/software/linux/bash/archives/commands/date/</id>
    <link href="http://qiqi.dreamagain.top/software/linux/bash/archives/commands/date/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<h1 id="date"> date</h1>
<p><code>date</code> 命令显示当前的日期和时间。</p>
<div><pre><code><span>date</span>
</code></pre>
<div><span>1</span><br></div></div>]]></content>
    <author>
      <name>南辞</name>
    </author>
    <contributor>
      <name>南辞</name>
    </contributor>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">dd</title>
    <id>http://qiqi.dreamagain.top/software/linux/bash/archives/commands/dd/</id>
    <link href="http://qiqi.dreamagain.top/software/linux/bash/archives/commands/dd/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<h1 id="dd"> dd</h1>
<p><code>dd</code> 命令用于复制磁盘或文件系统。</p>
<h2 id="复制磁盘"> 复制磁盘</h2>
<div><pre><code><span>dd</span> <span>if</span><span>=</span>/dev/sda <span>of</span><span>=</span>/dev/sdb
</code></pre>
<div><span>1</span><br></div></div><p>上面命令表示将<code>/dev/sda</code> 磁盘复制到<code>/dev/sdb</code> 设备。参数 <code>if</code> 表示来源地，<code>of</code> 表示目的地。</p>
<p>除了复制，<code>dd</code> 还允许将磁盘做成一个镜像文件。</p>
<div><pre><code><span>dd</span> <span>if</span><span>=</span>/dev/sda <span>of</span><span>=</span>/home/username/sdadisk.img
</code></pre>
<div><span>1</span><br></div></div><p><code>dd</code> 还可以复制单个分区。</p>
<div><pre><code><span>dd</span> <span>if</span><span>=</span>/dev/sda2 <span>of</span><span>=</span>/home/username/partition2.img <span>bs</span><span>=</span><span>4096</span>
</code></pre>
<div><span>1</span><br></div></div><p>上面命令中，参数 <code>bs</code> 表示单次拷贝的字节数(bytes)。</p>
<p>要将镜像文件复原，也很简单。</p>
<div><pre><code><span>dd</span> <span>if</span><span>=</span>sdadisk.img <span>of</span><span>=</span>/dev/sdb
</code></pre>
<div><span>1</span><br></div></div><h2 id="清除数据"> 清除数据</h2>
<p><code>dd</code> 也可以用于清除磁盘数据。</p>
<div><pre><code><span># 磁盘数据写满 0</span>
$ <span>dd</span> <span>if</span><span>=</span>/dev/zero <span>of</span><span>=</span>/dev/sda1

<span># 磁盘数据写满随机字符</span>
$ <span>dd</span> <span>if</span><span>=</span>/dev/urandom <span>of</span><span>=</span>/dev/sda1
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h2 id="监控进展"> 监控进展</h2>
<p>磁盘的复制通常需要很久，为了监控进展，可以使用 Pipe Viewer 工具软件。如果没有安装这个软件，可以使用下面的命令安装。</p>
<div><pre><code><span>sudo</span> <span>apt</span> <span>install</span> <span>pv</span>
</code></pre>
<div><span>1</span><br></div></div><p>然后，来源地和目的地之间插入广告，就可以看到进展了。</p>
<div><pre><code>$ <span>dd</span> <span>if</span><span>=</span>/dev/urandom <span>|</span> <span>pv</span> <span>|</span> <span>dd</span> <span>of</span><span>=</span>/dev/sda1
<span>4</span>,14MB <span>0</span>:00:05 <span>[</span> 98kB/s<span>]</span> <span>[</span>      <span>&lt;</span><span>=</span><span>></span>                  <span>]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h2 id="参考链接"> 参考链接</h2>
<ul>
<li>David Clinton, <a href="https://opensource.com/article/18/7/how-use-dd-linux" target="_blank" rel="noopener noreferrer">How to use dd in Linux without destroying your disk</a></li>
</ul>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <contributor>
      <name>南辞</name>
    </contributor>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">df</title>
    <id>http://qiqi.dreamagain.top/software/linux/bash/archives/commands/df/</id>
    <link href="http://qiqi.dreamagain.top/software/linux/bash/archives/commands/df/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<h1 id="df"> df</h1>
<p><code>df</code> 命令显示磁盘信息。</p>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <contributor>
      <name>南辞</name>
    </contributor>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">du</title>
    <id>http://qiqi.dreamagain.top/software/linux/bash/archives/commands/du/</id>
    <link href="http://qiqi.dreamagain.top/software/linux/bash/archives/commands/du/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<h1 id="du"> du</h1>
<p><code>du</code> 命令显示某个文件或目录的磁盘使用量。</p>
<div><pre><code><span>du</span> filename
</code></pre>
<div><span>1</span><br></div></div><p><code>-h</code> 参数将返回的大小显示为人类可读的格式，即显示单位为 K、M、G 等。</p>
<p><code>-s</code> 参数表示总结(summarize)。</p>
<p><code>-x</code> 参数表示不显示不在当前分区的目录，通常会忽略<code>/dev</code>、<code>/proc</code>、<code>/sys</code> 等目录。</p>
<p><code>-c</code> 参数表示显示当前目录总共占用的空间大小。</p>
<div><pre><code><span># 显示根目录下各级目录占用的空间大小</span>
$ <span>sudo</span> <span>du</span> -shxc /*
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><code>--exclude</code> 参数用于排除某些目录或文件。</p>
<div><pre><code><span>sudo</span> <span>du</span> -shxc /* --exclude<span>=</span>proc
<span>sudo</span> <span>du</span> -sh --exclude<span>=</span>*.iso
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><code>--max-depth</code> 参数用于设定目录大小统计到第几层。如果设为 <code>-–max-depth=0</code>，那么等同于 <code>-s</code> 参数。</p>
<div><pre><code><span>sudo</span> <span>du</span> /home/ -hc --max-depth<span>=</span><span>2</span>
</code></pre>
<div><span>1</span><br></div></div>]]></content>
    <author>
      <name>南辞</name>
    </author>
    <contributor>
      <name>南辞</name>
    </contributor>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">egrep</title>
    <id>http://qiqi.dreamagain.top/software/linux/bash/archives/commands/egrep/</id>
    <link href="http://qiqi.dreamagain.top/software/linux/bash/archives/commands/egrep/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<h1 id="egrep"> egrep</h1>
<p><code>egrep</code> 命令用于显示匹配正则模式的行，与 <code>grep -E</code> 命令等价。</p>
<p>下面是 <code>example.txt</code> 文件的内容。</p>
<div><pre><code>Lorem ipsum
dolor sit amet,
consetetur
sadipscing elitr,
sed diam nonumy
eirmod tempor
invidunt ut labore
et dolore magna
aliquyam erat, sed
diam voluptua. At
vero eos et
accusam et justo
duo dolores et ea
rebum. Stet clita
kasd gubergren,
no sea takimata
sanctus est Lorem
ipsum dolor sit
amet.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><p><code>egrep</code> 命令显示包括 <code>Lorem</code> 或 <code>dolor</code> 的行。</p>
<div><pre><code>$ <span>egrep</span> <span>'(Lorem|dolor)'</span> example.txt
<span># 或者</span>
$ <span>grep</span> -E <span>'(Lorem|dolor)'</span> example.txt
Lorem ipsum
dolor sit amet,
et dolore magna
duo dolores et ea
sanctus est Lorem
ipsum dolor sit
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div>]]></content>
    <author>
      <name>南辞</name>
    </author>
    <contributor>
      <name>南辞</name>
    </contributor>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">export</title>
    <id>http://qiqi.dreamagain.top/software/linux/bash/archives/commands/export/</id>
    <link href="http://qiqi.dreamagain.top/software/linux/bash/archives/commands/export/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<h1 id="export"> export</h1>
<p><code>export</code> 命令用于向子 Shell 输出变量。</p>
<div><pre><code><span>export</span> <span>hotellogs</span><span>=</span><span>"/workspace/hotel-api/storage/logs"</span>
</code></pre>
<div><span>1</span><br></div></div><p>然后执行下面的命令，新建一个子 Shell。</p>
<div><pre><code><span>bash</span>
<span>cd</span> hotellogs
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>上面命令的执行结果会进入 <code>hotellogs</code> 变量指向的目录。</p>
<p><code>export</code> 命令还可以显示所有环境变量。</p>
<div><pre><code>$ <span>export</span>
<span><span>SHELL</span></span><span>=</span>/bin/zsh
<span>AWS_HOME</span><span>=</span>/Users/adnanadnan/.aws
<span><span>LANG</span></span><span>=</span>en_US.UTF-8
<span>LC_CTYPE</span><span>=</span>en_US.UTF-8
<span>LESS</span><span>=</span>-R
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>如果想查看单个变量，使用 <code>echo $VARIABLE_NAME</code>。</p>
<div><pre><code>$ <span>echo</span> <span>$SHELL</span>
/usr/bin/zsh
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div>]]></content>
    <author>
      <name>南辞</name>
    </author>
    <contributor>
      <name>南辞</name>
    </contributor>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">file</title>
    <id>http://qiqi.dreamagain.top/software/linux/bash/archives/commands/file/</id>
    <link href="http://qiqi.dreamagain.top/software/linux/bash/archives/commands/file/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<h1 id="file"> file</h1>
<p><code>file</code> 命令用来某个文件的类型。</p>
<div><pre><code>$ <span>file</span> index.html
 index.html: HTML document, ASCII text
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>file 工具可以对所给的文件一行简短的介绍，它用文件后缀、头部信息和一些其他的线索来判断文件。您在检查一堆您不熟悉的文件时使用 find 非常方便:</p>
<div><pre><code>$ <span>find</span> -exec <span>file</span> <span>{</span><span>}</span> <span>\</span><span>;</span>
.:            directory
./hanoi:      Perl script, ASCII text executable
./.hanoi.swp: Vim swap file, version <span>7.3</span>
./factorial:  Perl script, ASCII text executable
./bits.c:     C source, ASCII text
./bits:       ELF <span>32</span>-bit LSB executable, Intel <span>80386</span>, version <span>..</span>.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div>]]></content>
    <author>
      <name>南辞</name>
    </author>
    <contributor>
      <name>南辞</name>
    </contributor>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">find</title>
    <id>http://qiqi.dreamagain.top/software/linux/bash/archives/commands/find/</id>
    <link href="http://qiqi.dreamagain.top/software/linux/bash/archives/commands/find/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<h1 id="find"> find</h1>
<p><code>find</code> 命令用于寻找文件，会包括当前目录的所有下级目录。</p>
<p>如果不带任何参数，<code>find</code> 文件会列出当前目录的所有文件，甚至还包括相对路径。如果把结果导入 <code>sort</code> 效果更好。</p>
<div><pre><code>$ <span>find</span> <span>|</span> <span>sort</span>
<span>.</span>
./Makefile
./README
./build
./client.c
./client.h
./common.h
./project.c
./server.c
./server.h
./tests
./tests/suite1.pl
./tests/suite2.pl
./tests/suite3.pl
./tests/suite4.pl
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>如果想要 <code>ls -l</code> 样式的列表，只要在 <code>find</code> 后面加上 <code>-ls</code>。</p>
<div><pre><code><span>find</span> -ls
</code></pre>
<div><span>1</span><br></div></div><p><code>find</code> 有它自己的一套复杂的过滤语句。下面列举的是一些最常用的您可以用以获取某些文件列表的过滤器:</p>
<ul>
<li><code>find -name '*.c'</code> —— 查找符合某 shell 式样式的文件名的文件。用 iname 开启大小写不敏感搜索。</li>
<li><code>find -path '_test_'</code> —— 查找符合某 shell 式样式的路径的文件。用 ipath 开启大小写不敏感搜索。</li>
<li><code>find -mtime -5</code> —— 查找近五天内编辑过的文件。您也可以用 +5 来查找五天之前编辑过的文件。</li>
<li><code>find -newer server.c</code> —— 查找比 server.c 更新的文件。</li>
<li><code>find -type d</code> —— 查找所有文件夹。如果想找出所有文件，那就用 <code>-type f</code>；找符号连接就用 <code>-type l</code>。</li>
</ul>
<p>要注意，上面提到的这些过滤器都是可以组合使用的，例如找出近两天内编辑过的 C 源码:</p>
<div><pre><code><span>find</span> -name <span>'*.c'</span> -mtime -2
</code></pre>
<div><span>1</span><br></div></div><p>默认情况下， find 对搜索结果所采取的动作只是简单地通过标准输出输出一个列表，然而其实还有其他一些有用的后续动作。</p>
<ul>
<li>-ls —— 如前文，提供了一种类 ls -l 式的列表。</li>
<li>-delete —— 删除符合查找条件的文件。</li>
<li>-exec —— 对搜索结果里的每个文件都运行某个命令， <code>{}</code> 会被替换成适当的文件名，并且命令用 <code>\;</code> 终结。</li>
</ul>
<div><pre><code><span>find</span> -name <span>'*.pl'</span> -exec perl -c <span>{</span><span>}</span> <span>\</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div><p>您也可以使用 <code>+</code> 作为终止符来对所有结果运行一次命令。我还发现一个我经常使用的小技巧，就是用 <code>find</code> 生成一个文件列表，然后在 Vim 的垂直分窗中编辑:</p>
<div><pre><code><span>find</span> -name <span>'*.c'</span> -exec <span>vim</span> <span>{</span><span>}</span> +
</code></pre>
<div><span>1</span><br></div></div>]]></content>
    <author>
      <name>南辞</name>
    </author>
    <contributor>
      <name>南辞</name>
    </contributor>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">fmt</title>
    <id>http://qiqi.dreamagain.top/software/linux/bash/archives/commands/fmt/</id>
    <link href="http://qiqi.dreamagain.top/software/linux/bash/archives/commands/fmt/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<h1 id="fmt"> fmt</h1>
<p><code>fmt</code> 命令用于对文本指定样式。</p>
<p>下面是 <code>example.txt</code> 的内容，是非常长的一行。</p>
<div><pre><code>Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum dolor sit amet.
</code></pre>
<div><span>1</span><br></div></div><p><code>fmt</code> 可以将其输出为每行 80 个字符。</p>
<div><pre><code><span>cat</span> example.txt <span>|</span> <span>fmt</span> -w <span>20</span>
Lorem ipsum
dolor sit amet,
consetetur
sadipscing elitr,
<span>sed</span> diam nonumy
eirmod tempor
invidunt ut labore
et dolore magna
aliquyam erat, <span>sed</span>
diam voluptua. At
vero eos et
accusam et justo
duo dolores et ea
rebum. Stet clita
kasd gubergren,
no sea takimata
sanctus est Lorem
ipsum dolor sit
amet.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div>]]></content>
    <author>
      <name>南辞</name>
    </author>
    <contributor>
      <name>南辞</name>
    </contributor>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">grep</title>
    <id>http://qiqi.dreamagain.top/software/linux/bash/archives/commands/grep/</id>
    <link href="http://qiqi.dreamagain.top/software/linux/bash/archives/commands/grep/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<h1 id="grep"> grep</h1>
<p><code>grep</code> 命令用于文件内容的搜索，返回所有匹配的行。</p>
<div><pre><code><span>grep</span> pattern filename
</code></pre>
<div><span>1</span><br></div></div><p>下面是一个例子。</p>
<div><pre><code>$ <span>grep</span> admin /etc/passwd
_kadmin_admin:*:218:-2:Kerberos Admin Service:/var/empty:/usr/bin/false
_kadmin_changepw:*:219:-2:Kerberos Change Password Service:/var/empty:/usr/bin/false
_krb_kadmin:*:231:-2:Open Directory Kerberos Admin Service:/var/empty:/usr/bin/false
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>一般情况下，应该使用 <code>grep -R</code>，递归地找出当前目录下符合 <code>someVar</code> 的文件。</p>
<div><pre><code><span>grep</span> -FR <span>'someVar'</span> <span>.</span>
</code></pre>
<div><span>1</span><br></div></div><p>別忘了大小不敏感的参数，因为 grep 默认搜索是大小写敏感的。</p>
<div><pre><code><span>grep</span> -iR <span>'somevar'</span> <span>.</span>
</code></pre>
<div><span>1</span><br></div></div><p>也可以用 <code>grep -l</code> 光打印出符合条件的文件名而非文件内容选段。</p>
<div><pre><code><span>grep</span> -lR <span>'somevar'</span> <span>.</span>
</code></pre>
<div><span>1</span><br></div></div><p>如果您写的脚本或批处理任务需要上面的输出内容，可以使用 while 和 read 来处理文件名中的空格和其他特殊字符:</p>
<div><pre><code><span>grep</span> -lR someVar <span>|</span> <span>while</span> <span><span>IFS</span></span><span>=</span> <span>read</span> -r <span>file</span><span>;</span> <span>do</span>
    <span>head</span> <span>"<span>$file</span>"</span>
<span>done</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>如果您在您的项目里使用了版本控制软件，它通常会在 .svn， .git， .hg 目录下包含一些元数据。您也可以很容易地用 grep -v 把这些目录移出搜索范围，当然得用 grep -F 指定一个恰当且确定的字符串，即要移除的目录名:</p>
<div><pre><code><span>grep</span> -R <span>'someVar'</span> <span>.</span> <span>|</span> <span>grep</span> -vF <span>'.svn'</span>
</code></pre>
<div><span>1</span><br></div></div><p>部分版本的 grep 包含了 --exclude 和 --exclude-dir 选项，这看起来更加易读。</p>
<h2 id="参数"> 参数</h2>
<p><code>-i</code> 参数表示忽略大小写。</p>
<p><code>-r</code> 表示搜索某个目录下面的所有文件。</p>
<div><pre><code><span>grep</span> -r admin /etc/
</code></pre>
<div><span>1</span><br></div></div><p><code>-v</code> 过滤包含某个词的行，即 <code>grep</code> 的逆操作。</p>
<div><pre><code><span># 显示所有包含 vim，但不包含 grep 的行</span>
$ <span>ps</span> <span>|</span> <span>grep</span> <span>vim</span> <span>|</span> <span>grep</span> -v <span>grep</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div>]]></content>
    <author>
      <name>南辞</name>
    </author>
    <contributor>
      <name>南辞</name>
    </contributor>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">gunzip</title>
    <id>http://qiqi.dreamagain.top/software/linux/bash/archives/commands/gunzip/</id>
    <link href="http://qiqi.dreamagain.top/software/linux/bash/archives/commands/gunzip/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<h1 id="gunzip"> gunzip</h1>
<p><code>gunzip</code> 命令用于解压 <code>gzip</code> 命令压缩的文件。</p>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <contributor>
      <name>南辞</name>
    </contributor>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">gzcat</title>
    <id>http://qiqi.dreamagain.top/software/linux/bash/archives/commands/gzcat/</id>
    <link href="http://qiqi.dreamagain.top/software/linux/bash/archives/commands/gzcat/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<h1 id="gzcat"> gzcat</h1>
<p><code>gzcat</code> 命令用于查看一个 <code>gz</code> 文件，但并不实际解压它。</p>
<div><pre><code>gzcat filename
</code></pre>
<div><span>1</span><br></div></div>]]></content>
    <author>
      <name>南辞</name>
    </author>
    <contributor>
      <name>南辞</name>
    </contributor>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">gzip</title>
    <id>http://qiqi.dreamagain.top/software/linux/bash/archives/commands/gzip/</id>
    <link href="http://qiqi.dreamagain.top/software/linux/bash/archives/commands/gzip/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<h1 id="gzip"> gzip</h1>
<p><code>gzip</code> 命令用于压缩文件。</p>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <contributor>
      <name>南辞</name>
    </contributor>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">kill</title>
    <id>http://qiqi.dreamagain.top/software/linux/bash/archives/commands/kill/</id>
    <link href="http://qiqi.dreamagain.top/software/linux/bash/archives/commands/kill/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<h1 id="kill"> kill</h1>
<p><code>kill</code> 命令用户终止指定进程。</p>
<div><pre><code><span>kill</span> PID
</code></pre>
<div><span>1</span><br></div></div>]]></content>
    <author>
      <name>南辞</name>
    </author>
    <contributor>
      <name>南辞</name>
    </contributor>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">killall</title>
    <id>http://qiqi.dreamagain.top/software/linux/bash/archives/commands/killall/</id>
    <link href="http://qiqi.dreamagain.top/software/linux/bash/archives/commands/killall/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<h1 id="killall"> killall</h1>
<p><code>killall</code> 命令终止给定名字的一系列相关进程。</p>
<div><pre><code><span>killall</span> processname
</code></pre>
<div><span>1</span><br></div></div>]]></content>
    <author>
      <name>南辞</name>
    </author>
    <contributor>
      <name>南辞</name>
    </contributor>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">last</title>
    <id>http://qiqi.dreamagain.top/software/linux/bash/archives/commands/last/</id>
    <link href="http://qiqi.dreamagain.top/software/linux/bash/archives/commands/last/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<h1 id="last"> last</h1>
<p><code>last</code> 命令显示用户登录系统的记录。</p>
<div><pre><code>last
</code></pre>
<div><span>1</span><br></div></div><p><code>last</code> 命令后面加上用户名，会显示该用户上次登录的信息。</p>
<div><pre><code>last yourUsername
</code></pre>
<div><span>1</span><br></div></div>]]></content>
    <author>
      <name>南辞</name>
    </author>
    <contributor>
      <name>南辞</name>
    </contributor>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">lpq</title>
    <id>http://qiqi.dreamagain.top/software/linux/bash/archives/commands/lpq/</id>
    <link href="http://qiqi.dreamagain.top/software/linux/bash/archives/commands/lpq/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<h1 id="lpq"> lpq</h1>
<p><code>lpq</code> 命令显示打印机队列。</p>
<div><pre><code>$ lpq
Rank    Owner   Job     File<span>(</span>s<span>)</span>                         Total Size
active  adnanad <span>59</span>      demo                            <span>399360</span> bytes
1st     adnanad <span>60</span>      <span>(</span>stdin<span>)</span>                         <span>0</span> bytes
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div>]]></content>
    <author>
      <name>南辞</name>
    </author>
    <contributor>
      <name>南辞</name>
    </contributor>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">lpr</title>
    <id>http://qiqi.dreamagain.top/software/linux/bash/archives/commands/lpr/</id>
    <link href="http://qiqi.dreamagain.top/software/linux/bash/archives/commands/lpr/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<h1 id="lpr"> lpr</h1>
<p><code>lpr</code> 命令用于打印文件。</p>
<div><pre><code><span>lpr</span> filename
</code></pre>
<div><span>1</span><br></div></div>]]></content>
    <author>
      <name>南辞</name>
    </author>
    <contributor>
      <name>南辞</name>
    </contributor>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">ls</title>
    <id>http://qiqi.dreamagain.top/software/linux/bash/archives/commands/ls/</id>
    <link href="http://qiqi.dreamagain.top/software/linux/bash/archives/commands/ls/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<h1 id="ls"> ls</h1>
<p><code>ls</code> 命令用于列出当前目录里面的文件和子目录。</p>
<h2 id="参数"> 参数</h2>
<ul>
<li>a: 列出隐藏文件</li>
<li>l: 以长格式列出文件</li>
<li>t: 按最后编辑日期排序，最新的最先。这在某个大目录里找出最近修改的文件列表时很有用，比如将结果导入( pipe ) head 或者 sed 10q。或许加上 -l 会效果更好。当然如果您想获取最旧的文件列表，只要加 -r 反转列表即可。</li>
<li>X: 按文件类型分类。这在多语言或多后缀的项目中特别方便，比如头文件和源文件分开，或区分开源文件和生成文件或目录。</li>
<li>v: 按照文件名里的版本号排序。</li>
<li>S: 按文件大小排序。</li>
<li>R: 递归地列举文件。这个选项和 -l 组合使用并将结果导出到 less 效果很好。</li>
</ul>
<p>可以把结果导出给类似 vim 的进程。</p>
<div><pre><code><span>ls</span> -XR <span>|</span> <span>vim</span> -
</code></pre>
<div><span>1</span><br></div></div>]]></content>
    <author>
      <name>南辞</name>
    </author>
    <contributor>
      <name>南辞</name>
    </contributor>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">nl</title>
    <id>http://qiqi.dreamagain.top/software/linux/bash/archives/commands/nl/</id>
    <link href="http://qiqi.dreamagain.top/software/linux/bash/archives/commands/nl/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<h1 id="nl"> nl</h1>
<p><code>nl</code> 命令用于显示行号。</p>
<p>下面是 <code>example.txt</code> 文件的内容。</p>
<div><pre><code>Lorem ipsum
dolor sit amet,
consetetur
sadipscing elitr,
<span>sed</span> diam nonumy
eirmod tempor
invidunt ut labore
et dolore magna
aliquyam erat, <span>sed</span>
diam voluptua. At
vero eos et
accusam et justo
duo dolores et ea
rebum. Stet clita
kasd gubergren,
no sea takimata
sanctus est Lorem
ipsum dolor sit
amet.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><p><code>nl</code> 命令让上面这段文本显示行号。</p>
<div><pre><code>$ <span>nl</span> -s<span>". "</span> example.txt
     <span>1</span>. Lorem ipsum
     <span>2</span>. dolor sit amet,
     <span>3</span>. consetetur
     <span>4</span>. sadipscing elitr,
     <span>5</span>. <span>sed</span> diam nonumy
     <span>6</span>. eirmod tempor
     <span>7</span>. invidunt ut labore
     <span>8</span>. et dolore magna
     <span>9</span>. aliquyam erat, <span>sed</span>
    <span>10</span>. diam voluptua. At
    <span>11</span>. vero eos et
    <span>12</span>. accusam et justo
    <span>13</span>. duo dolores et ea
    <span>14</span>. rebum. Stet clita
    <span>15</span>. kasd gubergren,
    <span>16</span>. no sea takimata
    <span>17</span>. sanctus est Lorem
    <span>18</span>. ipsum dolor sit
    <span>19</span>. amet.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><p><code>-s</code> 参数表示行号的后缀。</p>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <contributor>
      <name>南辞</name>
    </contributor>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">ps</title>
    <id>http://qiqi.dreamagain.top/software/linux/bash/archives/commands/ps/</id>
    <link href="http://qiqi.dreamagain.top/software/linux/bash/archives/commands/ps/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<h1 id="ps"> ps</h1>
<p><code>ps</code> 命令列出当前正在执行的进程信息。</p>
<p>由于进程很多，所以为了快速找到某个进程，一般与 <code>grep</code> 配合使用。</p>
<div><pre><code><span># 找出正在运行 vim 的进程</span>
$ <span>ps</span> <span>|</span> <span>grep</span> <span>vi</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h2 id="参数"> 参数</h2>
<p><code>-u</code> 参数列出指定用户拥有的进程。</p>
<div><pre><code><span>ps</span> -u yourusername
</code></pre>
<div><span>1</span><br></div></div>]]></content>
    <author>
      <name>南辞</name>
    </author>
    <contributor>
      <name>南辞</name>
    </contributor>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">scp</title>
    <id>http://qiqi.dreamagain.top/software/linux/bash/archives/commands/scp/</id>
    <link href="http://qiqi.dreamagain.top/software/linux/bash/archives/commands/scp/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<h1 id="scp"> scp</h1>
<h2 id="基本用法"> 基本用法</h2>
<p><code>scp</code> 是 secure copy 的缩写，用来在两台主机之间加密传送文件。它的底层是 SSH 协议，默认端口是 22。</p>
<p>它主要用于以下三种复制操作。</p>
<ul>
<li>从本地系统到远程系统。</li>
<li>从远程系统到本地系统。</li>
<li>在本地系统的两个远程系统之间。</li>
</ul>
<p>使用 <code>scp</code> 传输数据时，文件和密码都是加密的，不会泄漏敏感信息。</p>
<p><code>scp</code> 的语法类似 <code>cp</code> 的语法。</p>
<p>注意，如果传输的文件在本机和远程系统，有相同的名称和位置，<code>scp</code> 会在没有警告的情况下覆盖文件。</p>
<h3 id="本地文件复制到远程系统"> 本地文件复制到远程系统</h3>
<p>复制本机文件到远程系统的基本语法如下。</p>
<div><pre><code><span># 语法</span>
$ <span>scp</span> SourceFile user@host:directory/TargetFile

<span># 示例</span>
$ <span>scp</span> file.txt remote_username@10.10.0.2:/remote/directory
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>下面是复制整个目录。</p>
<div><pre><code><span># 将本机的 documents 目录拷贝到远程主机，</span>
<span># 会在远程主机创建 documents 目录</span>
$ <span>scp</span> -r documents username@server_ip:/path_to_remote_directory

<span># 将本机整个目录拷贝到远程目录下</span>
$ <span>scp</span> -r localmachine/path_to_the_directory username@server_ip:/path_to_remote_directory/

<span># 将本机目录下的所有内容拷贝到远程目录下</span>
$ <span>scp</span> -r localmachine/path_to_the_directory/* username@server_ip:/path_to_remote_directory/
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h3 id="远程文件复制到本地"> 远程文件复制到本地</h3>
<p>从远程主机复制文件到本地的语法如下。</p>
<div><pre><code><span># 语法</span>
$ <span>scp</span> user@host:directory/SourceFile TargetFile

<span># 示例</span>
$ <span>scp</span> remote_username@10.10.0.2:/remote/file.txt /local/directory
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>下面是复制整个目录的例子。</p>
<div><pre><code><span># 拷贝一个远程目录到本机目录下</span>
$ <span>scp</span> -r username@server_ip:/path_to_remote_directory local-machine/path_to_the_directory/

<span># 拷贝远程目录下的所有内容，到本机目录下</span>
$ <span>scp</span> -r username@server_ip:/path_to_remote_directory/* local-machine/path_to_the_directory/
$ <span>scp</span> -r user@host:directory/SourceFolder TargetFolder
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h3 id="两个远程系统之间的复制"> 两个远程系统之间的复制</h3>
<p>本机发出指令，从远程主机 A 拷贝到远程主机 B 的语法如下。</p>
<div><pre><code><span># 语法</span>
$ <span>scp</span> user@host1:directory/SourceFile user@host2:directory/SourceFile

<span># 示例</span>
$ <span>scp</span> user1@host1.com:/files/file.txt user2@host2.com:/files
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>系统将提示您输入两个远程帐户的密码。数据将直接从一个远程主机传输到另一个远程主机。</p>
<h2 id="参数"> 参数</h2>
<p><code>-P</code> 用来指定远程主机的 SSH 端口。如果远程主机使用非默认端口 22，可以在命令中指定。</p>
<div><pre><code><span>scp</span> -P <span>2222</span> user@host:directory/SourceFile TargetFile
</code></pre>
<div><span>1</span><br></div></div><p><code>-p</code> 参数用来保留修改时间(modification time)、访问时间(access time)、文件状态(mode)等原始文件的信息。</p>
<div><pre><code><span>scp</span> -C -p ~/test.txt root@192.168.1.3:/some/path/test.txt
</code></pre>
<div><span>1</span><br></div></div><p><code>-l</code> 参数用来限制传输数据的带宽速率，单位是 Kbit/sec。对于多人分享的带宽，这个参数可以留出一部分带宽供其他人使用。</p>
<div><pre><code><span>scp</span> -l <span>80</span> yourusername@yourserver:/home/yourusername/* <span>.</span>
</code></pre>
<div><span>1</span><br></div></div><p>上面代码中，<code>scp</code> 命令占用的带宽限制为每秒 80K 比特位，即每秒 10K 字节。</p>
<p><code>-c</code> 参数用来指定加密算法。</p>
<div><pre><code><span>scp</span> -c blowfish some_file your_username@remotehost.edu:~
</code></pre>
<div><span>1</span><br></div></div><p>上面代码指定加密算法为 <code>blowfish</code>。</p>
<p><code>-C</code> 表示是否在传输时压缩文件。</p>
<div><pre><code><span>scp</span> -c blowfish -C local_file your_username@remotehost.edu:~
</code></pre>
<div><span>1</span><br></div></div><p><code>-q</code> 参数用来关闭显示拷贝的进度条。</p>
<div><pre><code><span>scp</span> -q Label.pdf mrarianto@202.x.x.x:.
</code></pre>
<div><span>1</span><br></div></div><p><code>-F</code> 参数用来指定 ssh_config 文件。</p>
<div><pre><code><span>scp</span> -F /home/pungki/proxy_ssh_config Label.pdf
</code></pre>
<div><span>1</span><br></div></div><p><code>-v</code> 参数用来显示详细的输出。</p>
<div><pre><code><span>scp</span> -v ~/test.txt root@192.168.1.3:/root/help2356.txt
</code></pre>
<div><span>1</span><br></div></div><p><code>-i</code> 参数用来指定密钥。</p>
<div><pre><code><span>scp</span> -vCq -i private_key.pem ~/test.txt root@192.168.1.3:/some/path/test.txt
</code></pre>
<div><span>1</span><br></div></div><p><code>-r</code> 参数表示是否以递归方式复制目录。</p>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <contributor>
      <name>南辞</name>
    </contributor>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">sed</title>
    <id>http://qiqi.dreamagain.top/software/linux/bash/archives/commands/sed/</id>
    <link href="http://qiqi.dreamagain.top/software/linux/bash/archives/commands/sed/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<h1 id="sed"> sed</h1>
<p><code>sed</code> 命令用于对文本进行过滤和变形处理。</p>
<p>下面是 <code>example.txt</code> 文件的内容。</p>
<div><pre><code>Hello This is a Test <span>1</span> <span>2</span> <span>3</span> <span>4</span>
replace all spaces with hyphens
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><code>sed</code> 命令将所有的空格换成连词线 <code>-</code>。</p>
<div><pre><code>$ <span>sed</span> <span>'s/ /-/g'</span> example.txt
Hello-This-is-a-Test-1-2-3-4
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>下面的命令将数字换成字母 <code>d</code>。</p>
<div><pre><code>$ <span>sed</span> <span>'s/[0-9]/d/g'</span> example.txt
Hello This is a Test d d d d
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div>]]></content>
    <author>
      <name>南辞</name>
    </author>
    <contributor>
      <name>南辞</name>
    </contributor>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">sort</title>
    <id>http://qiqi.dreamagain.top/software/linux/bash/archives/commands/sort/</id>
    <link href="http://qiqi.dreamagain.top/software/linux/bash/archives/commands/sort/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<h1 id="sort"> sort</h1>
<p><code>sort</code> 命令用于文本文件的排序。</p>
<p>下面是 <code>example.txt</code> 文件的内容。</p>
<div><pre><code>f
b
c
g
a
e
d
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>执行 <code>sort</code> 命令对其进行排序。</p>
<div><pre><code>$ <span>sort</span> example.txt
a
b
c
d
e
f
g
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h2 id="参数"> 参数</h2>
<p><code>-R</code> 参数表示随机排序。</p>
<div><pre><code><span>sort</span> -R example.txt
b
d
a
c
g
e
f
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div>]]></content>
    <author>
      <name>南辞</name>
    </author>
    <contributor>
      <name>南辞</name>
    </contributor>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">tr</title>
    <id>http://qiqi.dreamagain.top/software/linux/bash/archives/commands/tr/</id>
    <link href="http://qiqi.dreamagain.top/software/linux/bash/archives/commands/tr/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<h1 id="tr"> tr</h1>
<p><code>tr</code> 命令用于按照给定模式转换文本。</p>
<p>下面是 <code>example.txt</code> 文件的内容。</p>
<div><pre><code>Hello World Foo Bar Baz<span>!</span>
</code></pre>
<div><span>1</span><br></div></div><p><code>tr</code> 命令可以将所有小写字母转换为大写字母。</p>
<div><pre><code>$ <span>cat</span> example.txt <span>|</span> <span>tr</span> <span>'a-z'</span> <span>'A-Z'</span>
HELLO WORLD FOO BAR BAZ<span>!</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><code>tr</code> 命令还可以将所有空格转为换行符。</p>
<div><pre><code>$ <span>cat</span> example.txt <span>|</span> <span>tr</span> <span>' '</span> <span>'<span title="\n">\n</span>'</span>
Hello
World
Foo
Bar
Baz<span>!</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div>]]></content>
    <author>
      <name>南辞</name>
    </author>
    <contributor>
      <name>南辞</name>
    </contributor>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">uname</title>
    <id>http://qiqi.dreamagain.top/software/linux/bash/archives/commands/uname/</id>
    <link href="http://qiqi.dreamagain.top/software/linux/bash/archives/commands/uname/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<h1 id="uname"> uname</h1>
<p><code>uname</code> 命令用来显示内核信息。</p>
<div><pre><code><span>uname</span> -a
</code></pre>
<div><span>1</span><br></div></div>]]></content>
    <author>
      <name>南辞</name>
    </author>
    <contributor>
      <name>南辞</name>
    </contributor>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">uniq</title>
    <id>http://qiqi.dreamagain.top/software/linux/bash/archives/commands/uniq/</id>
    <link href="http://qiqi.dreamagain.top/software/linux/bash/archives/commands/uniq/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<h1 id="uniq"> uniq</h1>
<p><code>uniq</code> 用于过滤掉重复的行，该命令只对排序后的文件有效。</p>
<p>下面是 <code>example.txt</code> 文件的内容。</p>
<div><pre><code>a
a
b
a
b
c
d
c
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>对该文件进行排序后，再过滤掉重复的行。</p>
<div><pre><code>$ <span>sort</span> example.txt <span>|</span> <span>uniq</span>
a
b
c
d
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h2 id="参数"> 参数</h2>
<p><code>-c</code> 参数会显示每行一共出现了多少次。</p>
<div><pre><code><span>sort</span> example.txt <span>|</span> <span>uniq</span> -c
    <span>3</span> a
    <span>2</span> b
    <span>2</span> c
    <span>1</span> d
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div>]]></content>
    <author>
      <name>南辞</name>
    </author>
    <contributor>
      <name>南辞</name>
    </contributor>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">uptime</title>
    <id>http://qiqi.dreamagain.top/software/linux/bash/archives/commands/uptime/</id>
    <link href="http://qiqi.dreamagain.top/software/linux/bash/archives/commands/uptime/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<h1 id="uptime"> uptime</h1>
<p><code>uptime</code> 命令显示本次开机运行的时间。</p>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <contributor>
      <name>南辞</name>
    </contributor>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">w</title>
    <id>http://qiqi.dreamagain.top/software/linux/bash/archives/commands/w/</id>
    <link href="http://qiqi.dreamagain.top/software/linux/bash/archives/commands/w/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<h1 id="w"> w</h1>
<p><code>w</code> 命令显示当期谁在线。</p>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <contributor>
      <name>南辞</name>
    </contributor>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">wc</title>
    <id>http://qiqi.dreamagain.top/software/linux/bash/archives/commands/wc/</id>
    <link href="http://qiqi.dreamagain.top/software/linux/bash/archives/commands/wc/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<h1 id="wc"> wc</h1>
<p><code>wc</code> 命令返回某个文件的行数、词数和字符数。</p>
<div><pre><code>$ <span>wc</span> demo.txt
<span>7459</span>   <span>15915</span>  <span>398400</span> demo.txt
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>上面代码中，<code>7459</code> 是行数，<code>15915</code> 是词数，<code>398400</code> 是字符数。</p>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <contributor>
      <name>南辞</name>
    </contributor>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">whereis</title>
    <id>http://qiqi.dreamagain.top/software/linux/bash/archives/commands/whereis/</id>
    <link href="http://qiqi.dreamagain.top/software/linux/bash/archives/commands/whereis/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<h1 id="whereis"> whereis</h1>
<p><code>whereis</code> 用来显示某个命令的位置。如果有多个程序符合条件，会全部列出。</p>
<div><pre><code>$ <span>whereis</span> node
/usr/bin/node /usr/sbin/node
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div>]]></content>
    <author>
      <name>南辞</name>
    </author>
    <contributor>
      <name>南辞</name>
    </contributor>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">which</title>
    <id>http://qiqi.dreamagain.top/software/linux/bash/archives/commands/which/</id>
    <link href="http://qiqi.dreamagain.top/software/linux/bash/archives/commands/which/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<h1 id="which"> which</h1>
<p><code>which</code> 命令根据 <code>PATH</code> 环境变量指定的顺序，返回最早发现某个命令的位置。即不指定路径时，实际执行的命令的完整路径。</p>
<div><pre><code>$ <span>which</span> node
/usr/bin/node
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div>]]></content>
    <author>
      <name>南辞</name>
    </author>
    <contributor>
      <name>南辞</name>
    </contributor>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">who</title>
    <id>http://qiqi.dreamagain.top/software/linux/bash/archives/commands/who/</id>
    <link href="http://qiqi.dreamagain.top/software/linux/bash/archives/commands/who/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<h1 id="who"> who</h1>
<p><code>who</code> 命令显示已经登录的用户。</p>
<h2 id="参数"> 参数</h2>
<p><code>-b</code> 参数显示上一次系统启动的时间。</p>
<div><pre><code>$ <span>who</span> -b
system boot  <span>2017</span>-06-20 <span>17</span>:41
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div>]]></content>
    <author>
      <name>南辞</name>
    </author>
    <contributor>
      <name>南辞</name>
    </contributor>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">标准 I/O</title>
    <id>http://qiqi.dreamagain.top/software/linux/bash/archives/deleted/stdio/</id>
    <link href="http://qiqi.dreamagain.top/software/linux/bash/archives/deleted/stdio/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<h1 id="标准-i-o"> 标准 I/O</h1>
<h2 id="echo"> echo</h2>
<p><code>echo</code> 命令用于将指定内容输出到显示屏(标准输出)。</p>
<div><pre><code>$ <span>echo</span> this is a <span>test</span>
this is a <span>test</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>它的参数如下。</p>
<ul>
<li><code>-e</code> 解释转义字符。</li>
<li><code>-n</code> 不输出行尾的换行符</li>
</ul>
<div><pre><code>$ <span>echo</span> <span>"a<span title="\n">\n</span>b"</span>
a<span>\</span>nb

$ <span>echo</span> -e <span>"a<span title="\n">\n</span>b"</span>
a
b
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>上面代码中，如果不加 <code>-e</code> 参数，<code>\n</code> 就会按字面形式输出；加了以后，就被解释成了换行符。</p>
<p>引号之中可以包括多个换行符，即可以输出多行文本。</p>
<div><pre><code><span>echo</span> <span>"&lt;HTML>
    &lt;HEAD>
          &lt;TITLE>Page Title&lt;/TITLE>
    &lt;/HEAD>
    &lt;BODY>
          Page body.
    &lt;/BODY>
&lt;/HTML>"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h2 id="read"> read</h2>
<p><code>read</code> 命令被用来从标准输入读取单行数据。这个命令可以用来读取键盘输入，当使用重定向的时候，读取文件中的一行数据。</p>
<div><pre><code><span>read</span> <span>[</span>-options<span>]</span> <span>[</span>variable<span>..</span>.<span>]</span>
</code></pre>
<div><span>1</span><br></div></div><p>上面的 variable 用来存储输入数值的一个或多个变量名。如果没有提供变量名，shell 变量 <code>REPLY</code> 会包含数据行。</p>
<p>基本上，read 会把来自标准输入的字段赋值给具体的变量。</p>
<div><pre><code><span>echo</span> -n <span>"Please enter an integer -> "</span>
<span>read</span> int
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><code>read</code> 可以给多个变量赋值。</p>
<div><pre><code><span>#!/bin/bash</span>
<span># read-multiple: read multiple values from keyboard</span>
<span>echo</span> -n <span>"Enter one or more values > "</span>
<span>read</span> var1 var2 var3 var4 var5
<span>echo</span> <span>"var1 = '<span>$var1</span>'"</span>
<span>echo</span> <span>"var2 = '<span>$var2</span>'"</span>
<span>echo</span> <span>"var3 = '<span>$var3</span>'"</span>
<span>echo</span> <span>"var4 = '<span>$var4</span>'"</span>
<span>echo</span> <span>"var5 = '<span>$var5</span>'"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>上面脚本的用法如下。</p>
<div><pre><code>$ read-multiple
Enter one or <span>more</span> values <span>></span> a b c d e
var1 <span>=</span> <span>'a'</span>
var2 <span>=</span> <span>'b'</span>
var3 <span>=</span> <span>'c'</span>
var4 <span>=</span> <span>'d'</span>
var5 <span>=</span> <span>'e'</span>

$ read-multiple
Enter one or <span>more</span> values <span>></span> a
var1 <span>=</span> <span>'a'</span>
var2 <span>=</span> <span>''</span>
var3 <span>=</span> <span>''</span>
var4 <span>=</span> <span>''</span>
var5 <span>=</span> <span>''</span>

$ read-multiple
Enter one or <span>more</span> values <span>></span> a b c d e f g
var1 <span>=</span> <span>'a'</span>
var2 <span>=</span> <span>'b'</span>
var3 <span>=</span> <span>'c'</span>
var4 <span>=</span> <span>'d'</span>
var5 <span>=</span> <span>'e f g'</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><p>如果 read 命令接受到变量值数目少于期望的数字，那么额外的变量值为空，而多余的输入数据则会 被包含到最后一个变量中。</p>
<p>如果 read 命令之后没有列出变量名，则一个 shell 变量 <code>REPLY</code>，将会包含所有的输入。</p>
<div><pre><code><span>#!/bin/bash</span>
<span># read-single: read multiple values into default variable</span>
<span>echo</span> -n <span>"Enter one or more values > "</span>
<span>read</span>
<span>echo</span> <span>"REPLY = '<span>$REPLY</span>'"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>上面脚本的输出结果如下。</p>
<div><pre><code>$ read-single
Enter one or <span>more</span> values <span>></span> a b c d
<span>REPLY</span> <span>=</span> <span>'a b c d'</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>read 命令的参数如下。</p>
<ul>
<li><code>-a array</code> 把输入赋值到数组 array 中，从索引号零开始。</li>
<li><code>-d delimiter</code> 用字符串 delimiter 中的第一个字符指示输入结束，而不是一个换行符。</li>
<li><code>-e</code> 使用 Readline 来处理输入。这使得与命令行相同的方式编辑输入。</li>
<li><code>-n num</code> 读取 num 个输入字符，而不是整行。</li>
<li><code>-p prompt</code> 为输入显示提示信息，使用字符串 prompt。</li>
<li><code>-r</code> Raw mode. 不把反斜杠字符解释为转义字符。</li>
<li><code>-s</code> Silent mode. 不会在屏幕上显示输入的字符。当输入密码和其它确认信息的时候，这会很有帮助。</li>
<li><code>-t seconds</code> 超时. 几秒钟后终止输入。read 会返回一个非零退出状态，若输入超时。</li>
<li><code>-u fd</code> 使用文件描述符 fd 中的输入，而不是标准输入。</li>
</ul>
<p><code>-p</code> 的例子。</p>
<div><pre><code><span>read</span> -p <span>"Enter one or more values > "</span>
<span>echo</span> <span>"REPLY = '<span>$REPLY</span>'"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><code>-t</code> 和 <code>-s</code> 的例子。</p>
<div><pre><code><span>if</span> <span>read</span> -t <span>10</span> -sp <span>"Enter secret pass phrase > "</span> secret_pass<span>;</span> <span>then</span>
    <span>echo</span> -e <span>"<span title="\n">\n</span>Secret pass phrase = '<span>$secret_pass</span>'"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>上面这个脚本提示用户输入一个密码，并等待输入 10 秒钟。如果在特定的时间内没有完成输入， 则脚本会退出并返回一个错误。因为包含了一个 -s 选项，所以输入的密码不会出现在屏幕上。</p>
<p>Shell 的内部变量 <code>IFS</code> 可以控制输入字段的分离。例如，这个 /etc/passwd 文件包含的数据行 使用冒号作为字段分隔符。通过把 IFS 的值更改为单个冒号，我们可以使用 read 读取 /etc/passwd 中的内容，并成功地把字段分给不同的变量。</p>
<div><pre><code><span>#!/bin/bash</span>
<span># read-ifs: read fields from a file</span>
<span>FILE</span><span>=</span>/etc/passwd
<span>read</span> -p <span>"Enter a user name > "</span> user_name
<span>file_info</span><span>=</span><span><span>$(</span><span>grep</span> <span>"^<span>$user_name</span>:"</span> $FILE<span>)</span></span>
<span>if</span> <span>[</span> -n <span>"<span>$file_info</span>"</span> <span>]</span><span>;</span> <span>then</span>
    <span><span>IFS</span></span><span>=</span><span>":"</span> <span>read</span> user pw uid gid name home shell <span>&lt;&lt;&lt;</span> <span>"<span>$file_info</span>"</span>
    <span>echo</span> <span>"User = '<span>$user</span>'"</span>
    <span>echo</span> <span>"UID = '<span>$uid</span>'"</span>
    <span>echo</span> <span>"GID = '<span>$gid</span>'"</span>
    <span>echo</span> <span>"Full Name = '<span>$name</span>'"</span>
    <span>echo</span> <span>"Home Dir. = '<span>$home</span>'"</span>
    <span>echo</span> <span>"Shell = '<span>$shell</span>'"</span>
<span>else</span>
    <span>echo</span> <span>"No such user '<span>$user_name</span>'"</span> <span>></span><span>&amp;2</span>
    <span>exit</span> <span>1</span>
<span>fi</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p>Shell 允许在一个命令之前立即发生一个或多个变量赋值。这些赋值为跟随着的命令更改环境变量。这个赋值的影响是暂时的；只是在命令存在期间改变环境变量。</p>
<p>虽然通常 read 命令接受标准输入，但是您不能这样做:</p>
<div><pre><code><span>echo</span> “foo” <span>|</span> <span>read</span>
</code></pre>
<div><span>1</span><br></div></div><p>我们期望这个命令能生效，但是它不能。这个命令将显示成功，但是 REPLY 变量 总是为空。为什么会这样?</p>
<p>答案与 shell 处理管道线的方式有关系。在 bash(和其它 shells，例如 sh)中，管道线 会创建子 shell。它们是 shell 的副本，且用来执行命令的环境变量在管道线中。上面示例中，read 命令将在子 shell 中执行。</p>
<p>在类 Unix 的系统中，子 shell 执行的时候，会为进程创建父环境的副本。当进程结束 之后，环境副本就会被破坏掉。这意味着一个子 shell 永远不能改变父进程的环境。read 赋值变量， 然后会变为环境的一部分。在上面的例子中，read 在它的子 shell 环境中，把 foo 赋值给变量 REPLY， 但是当命令退出后，子 shell 和它的环境将被破坏掉，这样赋值的影响就会消失。</p>
<p>使用 here 字符串是解决此问题的一种方法。</p>
<p>下面是生成菜单的一个例子。</p>
<div><pre><code><span>#!/bin/bash</span>
<span># read-menu: a menu driven system information program</span>
<span>clear</span>
<span>echo</span> <span>"
Please Select:

    1. Display System Information
    2. Display Disk Space
    3. Display Home Space Utilization
    0. Quit
"</span>
<span>read</span> -p <span>"Enter selection [0-3] > "</span>

<span>if</span> <span>[</span><span>[</span> <span>$REPLY</span> <span>=</span>~ ^<span>[</span><span>0</span>-3<span>]</span>$ <span>]</span><span>]</span><span>;</span> <span>then</span>
    <span>if</span> <span>[</span><span>[</span> <span>$REPLY</span> <span>==</span> <span>0</span> <span>]</span><span>]</span><span>;</span> <span>then</span>
        <span>echo</span> <span>"Program terminated."</span>
        <span>exit</span>
    <span>fi</span>
    <span>if</span> <span>[</span><span>[</span> <span>$REPLY</span> <span>==</span> <span>1</span> <span>]</span><span>]</span><span>;</span> <span>then</span>
        <span>echo</span> <span>"Hostname: <span>$HOSTNAME</span>"</span>
        <span>uptime</span>
        <span>exit</span>
    <span>fi</span>
    <span>if</span> <span>[</span><span>[</span> <span>$REPLY</span> <span>==</span> <span>2</span> <span>]</span><span>]</span><span>;</span> <span>then</span>
        <span>df</span> -h
        <span>exit</span>
    <span>fi</span>
    <span>if</span> <span>[</span><span>[</span> <span>$REPLY</span> <span>==</span> <span>3</span> <span>]</span><span>]</span><span>;</span> <span>then</span>
        <span>if</span> <span>[</span><span>[</span> <span><span>$(</span><span>id</span> -u<span>)</span></span> -eq <span>0</span> <span>]</span><span>]</span><span>;</span> <span>then</span>
            <span>echo</span> <span>"Home Space Utilization (All Users)"</span>
            <span>du</span> -sh /home/*
        <span>else</span>
            <span>echo</span> <span>"Home Space Utilization (<span>$USER</span>)"</span>
            <span>du</span> -sh <span>$HOME</span>
        <span>fi</span>
        <span>exit</span>
    <span>fi</span>
<span>else</span>
    <span>echo</span> <span>"Invalid entry."</span> <span>></span><span>&amp;2</span>
    <span>exit</span> <span>1</span>
<span>fi</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br></div></div>]]></content>
    <author>
      <name>南辞</name>
    </author>
    <contributor>
      <name>南辞</name>
    </contributor>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">文件操作</title>
    <id>http://qiqi.dreamagain.top/software/linux/bash/archives/file-operation/</id>
    <link href="http://qiqi.dreamagain.top/software/linux/bash/archives/file-operation/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<h1 id="文件操作"> 文件操作</h1>
<h2 id="cp"> cp</h2>
<p><code>cp</code> 命令用于将文件(或目录)拷贝到目的地。</p>
<div><pre><code><span># 拷贝单个文件</span>
$ <span>cp</span> <span>source</span> dest

<span># 拷贝多个文件</span>
$ <span>cp</span> source1 source2 source3 dest

<span># -i 目的地有同名文件时会提示确认</span>
$ <span>cp</span> -i file1 file2

<span># -r 递归拷贝，将dir1拷贝到dir2，完成后dir2生成一个子目录dir1</span>
<span># dir2如果不存在，将被创建</span>
<span># 拷贝目录时，该参数是必需的</span>
$ <span>cp</span> -r dir1 dir2

<span># -u --update 只拷贝目的地没有的文件，或者比目的地同名文件更新的文件</span>
$ <span>cp</span> -u *.html destination
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>其他参数</p>
<ul>
<li><code>-a</code> 拷贝时保留所有属性，包括所有者与权限</li>
<li><code>-v</code> 显示拷贝的详细信息</li>
</ul>
<h2 id="mkdir"> mkdir</h2>
<p><code>mkdir</code> 命令用于新建目录。</p>
<div><pre><code><span># 新建多个目录</span>
$ <span>mkdir</span> dir1 dir2 dir3
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h2 id="mv"> mv</h2>
<p><code>mv</code> 命令用于将源文件移动到目的地。</p>
<div><pre><code><span># 移动单个文件</span>
$ <span>mv</span> item1 item2

<span># 移动多个文件</span>
$ <span>mv</span> file1 file2 dir1

<span># 将dir1拷贝进入dir2，完成后dir2将多出一个子目录dir1</span>
<span># 如果dir2不存在，将会被创建</span>
$ <span>mv</span> dir1 dir2
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>参数</p>
<ul>
<li><code>-i</code> 覆盖已经存在的文件时，会提示确认</li>
<li><code>-u</code> 只移动目的地不存在的文件，或比目的地更新的文件</li>
</ul>
<h2 id="rm"> rm</h2>
<p><code>rm</code> 命令用于删除文件。</p>
<p>参数。</p>
<ul>
<li><code>-i</code> 文件存在时，会提示确认。</li>
<li><code>-r</code> 递归删除一个子目录</li>
<li><code>-f</code> 如果删除不存在的文件，不报错</li>
<li><code>-v</code> 删除时展示详细信息</li>
</ul>
<h2 id="ln"> ln</h2>
<p><code>ln</code> 命令用于建立链接文件。</p>
<div><pre><code><span># 新建硬链接</span>
$ <span>ln</span> <span>file</span> <span>link</span>

<span># 新建软链接</span>
$ <span>ln</span> -s item <span>link</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div>]]></content>
    <author>
      <name>南辞</name>
    </author>
    <contributor>
      <name>南辞</name>
    </contributor>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">文件系统</title>
    <id>http://qiqi.dreamagain.top/software/linux/bash/archives/file/</id>
    <link href="http://qiqi.dreamagain.top/software/linux/bash/archives/file/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<h1 id="文件系统"> 文件系统</h1>
<h2 id="pwd"> pwd</h2>
<p><code>pwd</code> 命令显示列出当前所在的目录。</p>
<div><pre><code><span>pwd</span>
</code></pre>
<div><span>1</span><br></div></div><h2 id="cd"> cd</h2>
<p><code>cd</code> 命令用来改变用户所在的目录。</p>
<div><pre><code><span># 进入用户的主目录</span>
$ <span>cd</span>

<span># 进入前一个工作目录</span>
$ <span>cd</span> -

<span># 进入指定用户的主目录</span>
$ <span>cd</span> ~user_name
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h2 id="ls"> ls</h2>
<p><code>ls</code> 目录可以显示指定目录的内容。不加参数时，显示当前目录的内容。</p>
<div><pre><code><span>ls</span>
</code></pre>
<div><span>1</span><br></div></div><p>上面命令显示当前目录的内容。</p>
<p><code>ls</code> 命令也可以显示指定文件是否存在。</p>
<div><pre><code>$ <span>ls</span> foo.txt
foo.txt
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><code>-l</code> 参数可以显示文件的详细信息。</p>
<div><pre><code>$ <span>ls</span> -l foo.txt
-rw-rw-r-- <span>1</span> me   me   <span>0</span> <span>2016</span>-03-06 <span>14</span>:52 foo.txt
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>上面命令输出结果的第一栏，是文件的类型和权限。</p>
<p>文件类型分为以下几种。</p>
<ul>
<li><code>-</code> 普通文件</li>
<li><code>d</code> 目录</li>
<li><code>l</code> 符号链接。注意，对于符号链接文件，剩余的文件属性总是&quot;rwxrwxrwx&quot;。</li>
<li><code>c</code> 字符设备文件，指按照字节流处理数据的设备，比如调制解调器。</li>
<li><code>b</code> 块设备文件，指按照数据块处理数据的设备，比如硬盘。</li>
</ul>
<p>其他参数的用法。</p>
<div><pre><code><span># 显示多个目录的内容</span>
$ <span>ls</span> ~ /usr

<span># -a --all 显示隐藏文件</span>
$ <span>ls</span> -a

<span># -A 与-a类似，但是不显示当前目录和上一级目录两个点文件</span>
$ <span>ls</span> -A

<span># -l 显示详细信息</span>
$ <span>ls</span> -l

<span># -1 单列显示，每行只显示一个文件</span>
$ <span>ls</span> -1

<span># -d 显示当前目录本身，而不是它的内容</span>
<span># 通常与-l配合使用，列出一个目录本身的详细信息</span>
$ <span>ls</span> -dl

<span># -F 目录名之后添加斜杠，可执行文件后面添加星号</span>
$ <span>ls</span> -F

<span># -h 与-l配合使用，将文件大小显示为人类可读的格式</span>

<span># -t 按文件修改时间排序，修改晚的排在前面</span>
$ <span>ls</span> -t

<span># -s 按文件大小排序，</span>

<span># --reverse 显示结果倒序排列</span>
$ <span>ls</span> -lt --reverse
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br></div></div><p>如果只显示一个目录里面的子目录，不显示文件，可以使用下面这些命令。</p>
<div><pre><code><span># 只显示常规目录</span>
$ <span>ls</span> -d */
$ <span>ls</span> -F <span>|</span> <span>grep</span> /
$ <span>ls</span> -l <span>|</span> <span>grep</span> ^d
$ tree -dL <span>1</span>

<span># 只显示隐藏目录</span>
$ <span>ls</span> -d .*/

<span># 隐藏目录和非隐藏目录都显示</span>
$ <span>find</span> -maxdepth <span>1</span> -type d
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>另一个简便方法是利用自动补全功能，先键入 <code>cd</code> 命令，然后连按两下 <code>tab</code> 键。</p>
<h2 id="stat"> stat</h2>
<p><code>stat</code> 命令是加强版的 <code>ls</code> 命令，可以显示一个文件的详细信息。</p>
<div><pre><code>$ <span>stat</span> timestamp
File: <span>'timestamp'</span>
Size: <span>0</span> Blocks: <span>0</span> IO Block: <span>4096</span> regular empty <span>file</span>
Device: 803h/2051d Inode: <span>14265061</span> Links: <span>1</span>
Access: <span>(</span>0644/-rw-r--r--<span>)</span> Uid: <span>(</span> <span>1001</span>/ me<span>)</span> Gid: <span>(</span> <span>1001</span>/ me<span>)</span>
Access: <span>2008</span>-10-08 <span>15</span>:15:39.000000000 -0400
Modify: <span>2008</span>-10-08 <span>15</span>:15:39.000000000 -0400
Change: <span>2008</span>-10-08 <span>15</span>:15:39.000000000 -0400
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h2 id="touch"> touch</h2>
<p><code>touch</code> 用来设置或更新文件的访问，更改，和修改时间。然而，如果一个文件名参数是一个 不存在的文件，则会创建一个空文件。</p>
<div><pre><code><span>touch</span> timestamp
</code></pre>
<div><span>1</span><br></div></div><p>上面命令创建了一个名为 <code>timestamp</code> 空文件。如果该文件已经存在，就会把它的修改时间设置为当前时间。</p>
<div><pre><code><span>mkdir</span> -p playground/dir-<span>{</span>00<span>{</span><span>1</span><span>..</span><span>9</span><span>}</span>,0<span>{</span><span>10</span><span>..</span><span>99</span><span>}</span>,100<span>}</span>
<span>touch</span> playground/dir-<span>{</span>00<span>{</span><span>1</span><span>..</span><span>9</span><span>}</span>,0<span>{</span><span>10</span><span>..</span><span>99</span><span>}</span>,100<span>}</span>/file-<span>{</span>A<span>..</span>Z<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>上面的命令创建了一个包含一百个子目录，每个子目录中包含了 26 个空文件。</p>
<h2 id="file"> file</h2>
<p><code>file</code> 命令显示指定文件的类型。</p>
<div><pre><code>$ <span>file</span> picture.jpg
picture.jpg: JPEG image data, JFIF standard <span>1.01</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h2 id="chmod"> chmod</h2>
<p><code>chmod</code> 命令用于更改文件的权限，是“change mode”的缩写。</p>
<div><pre><code><span>chmod</span> <span>600</span> foo.txt
</code></pre>
<div><span>1</span><br></div></div><p>上面命令将 <code>foo.txt</code> 的权限改成了 600。</p>
<p><code>chmod</code> 还可以接受四个缩写，为不同的对象单独设置权限。</p>
<ul>
<li><code>u</code> 所有者“user”的简写</li>
<li><code>g</code> 用户组“group”的缩写</li>
<li><code>o</code> 其他所有人“others”的简写</li>
<li><code>a</code> 所有人“all”的简写</li>
</ul>
<div><pre><code><span># 为所有者添加可执行权限</span>
$ <span>chmod</span> u+x foo.txt

<span># 删除所有者的可执行权限</span>
$ <span>chmod</span> u-x foo.txt

<span># 为所有人添加可执行权限，等价于 a+x</span>
$ <span>chmod</span> +x foo.txt

<span># 删除其他人的读权限和写权限。</span>
$ <span>chmod</span> o-rw foo.txt

<span># 设定用户组和其他人的权限是读权限和写权限</span>
$ <span>chmod</span> <span>go</span><span>=</span>rw foo.txt

<span># 为所有者添加执行权限，设定用户组和其他人为读权限和写权限，多种设定用逗号分隔</span>
$ <span>chmod</span> u+x,go<span>=</span>rw foo.txt
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p>添加权限。</p>
<ul>
<li>+x 添加执行权限</li>
<li>+r 设置读权限</li>
<li>+w 设置写权限</li>
<li>+rwx 设置所有读、写和执行权限。</li>
</ul>
<p>删除权限只需将 <code>+</code> 更改为 <code>-</code>，就可以删除任何已设置的指定权限。可以使用 <code>-R</code>(或 <code>--recursive</code>)选项来递归地操作目录和文件。</p>
<p>设置精确权限，可以使用<code>=</code>代替 <code>+</code> 或 <code>-</code> 来实现此操作。如果想为用户、组或其他用户设置不同的权限，可以使用逗号将不同表达式分开(例如 <code>ug=rwx,o=rx</code>)。</p>
<p>由于一共有 3 种可能的权限。也可以使用八进制数代替符号来设置权限。通过这种方式设置的权限最多使用 3 个八进制数。第 1 个数定义用户权限，第 2 个数定义组权限，第 3 个数定义其他权限。这 3 个数中的每一个都通过添加想要的权限设置来构造: 读 (4)、写 (2) 和执行 (1)。</p>
<ul>
<li>rwx 7</li>
<li>rw- 6</li>
<li>r-x 5</li>
<li>r-- 4</li>
<li>-wx 3</li>
<li>-w- 2</li>
<li>--x 1</li>
<li>--- 0</li>
</ul>
<h2 id="umask"> umask</h2>
<p><code>umask</code> 用来查看和设置权限掩码。</p>
<div><pre><code>$ <span>umask</span>
0022
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>上面命令显示当前系统之中，默认的文件掩码是 <code>0022</code>，转为二进制就是 <code>000 000 010 010</code>。</p>
<p>可以看到，这个掩码是一个 12 位的二进制数，后面的 9 位分别代表文件三种使用对象的三类权限。只要对应位置上是 <code>1</code>，就表示关闭该项权限，所以 <code>010</code> 就表示关闭读权限。</p>
<p>新建文件时，通常不会带有执行权限，也就是说，新建文件的默认权限是 <code>rw-rw-rw-</code>。如果文件掩码是 <code>0022</code>，那么用户组和其他人的写权限也会被拿掉。</p>
<div><pre><code>$ <span>touch</span> new.txt
$ <span>ls</span> -l new.txt
-rw-r--r-- <span>1</span> me   me   <span>0</span> <span>2016</span>-03-06 <span>14</span>:52 new.txt
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>上面代码中，<code>new.txt</code> 的用户组和其他人的写权限就没了。</p>
<p><code>umask</code> 后面跟着参数，就表示设置权限掩码。</p>
<div><pre><code><span>umask</span> 0000
</code></pre>
<div><span>1</span><br></div></div><p>上面命令将权限掩码设为 <code>0000</code>，实际上就是关闭了权限掩码。</p>
<p><code>umask</code> 命令设置的掩码值只能在当前 Shell 会话中生效，若当前 Shell 会话结束后，则必须重新设置。</p>
<h2 id="du"> du</h2>
<p><code>du</code> 命令用于查看指定目录的大小。</p>
<div><pre><code><span>du</span> -hs /path/to/directory
</code></pre>
<div><span>1</span><br></div></div><p>显示第一层子目录的大小。</p>
<div><pre><code><span>du</span> -h --max-depth<span>=</span><span>1</span> /path/to/folder
</code></pre>
<div><span>1</span><br></div></div><p>参数的含义。</p>
<ul>
<li><code>-h</code> 表示人类可读的格式</li>
<li><code>-s</code> 表示总结信息，否则会显示该目录内所有文件和子目录的信息。</li>
</ul>
<p><code>tree</code> 命令也可以显示子目录大小。</p>
<div><pre><code>tree --du -h /path/to/directory
</code></pre>
<div><span>1</span><br></div></div><h2 id="md5sum"> md5sum</h2>
<p><code>md5sum</code> 命令用来显示一个文件的 md5 校验码。</p>
<div><pre><code>$ md5sum image.iso
34e354760f9bb7fbf85c96f6a3f94ece    image.iso
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h2 id="locate"> locate</h2>
<p><code>locate</code> 程序快速搜索本机的路径名数据库，并且输出每个与给定字符串相匹配的文件名。</p>
<div><pre><code>$ <span>locate</span> bin/zip
/usr/bin/zip
/usr/bin/zipcloak
/usr/bin/zipgrep
/usr/bin/zipinfo
/usr/bin/zipnote
/usr/bin/zipsplit
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p><code>locate</code> 数据库由另一个叫做 <code>updatedb</code> 的程序创建。大多数装有 locate 的系统会每隔一天运行一回 updatedb 程序。因为数据库不能被持续地更新，所以当使用 locate 时，您会发现 目前最新的文件不会出现。为了克服这个问题，可以手动运行 updatedb 程序， 更改为超级用户身份，在提示符下运行 updatedb 命令。</p>
<p><code>locate</code> 支持正则查找。<code>--regexp</code> 参数支持基本的正则表达式，<code>--regex</code> 参数支持扩展的正则表达式。</p>
<div><pre><code><span>locate</span> --regex <span>'bin/(bz|gz|zip)'</span>
</code></pre>
<div><span>1</span><br></div></div><h2 id="find"> find</h2>
<p><code>locate</code> 程序只能依据文件名来查找文件，而 <code>find</code> 程序能基于各种各样的属性，搜索一个给定目录(以及它的子目录)，来查找文件。</p>
<div><pre><code><span># 输出当前目录的所有子目录和文件(含子目录)</span>
$ <span>find</span>
$ <span>find</span> <span>.</span>

<span># 显示当前目录的文件总数</span>
$ <span>find</span> <span>.</span> <span>|</span> <span>wc</span> -l

<span># 当前目录的子目录总数</span>
$ <span>find</span> <span>.</span> -type d <span>|</span> <span>wc</span> -l

<span># 当前目录的文件总数(不含子目录)</span>
$ <span>find</span> <span>.</span> -type f <span>|</span> <span>wc</span> -l

<span># 当前目录的文件名匹配“*.JPG”且大于1M的文件总数</span>
$ <span>find</span> <span>.</span> -type f -name <span>"\*.JPG"</span> -size +1M <span>|</span> <span>wc</span> -l
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p><code>-type</code> 参数支持的文件类型。</p>
<ul>
<li><code>b</code> 块设备文件</li>
<li><code>c</code> 字符设备文件</li>
<li><code>d</code> 目录</li>
<li><code>f</code> 普通文件</li>
<li><code>l</code> 符号链接</li>
</ul>
<p><code>-size</code> 参数支持的文件大小类型。</p>
<ul>
<li>b 512 个字节块。如果没有指定单位，则这是默认值。</li>
<li>c 字节</li>
<li>w 两个字节的字</li>
<li>k 千字节</li>
<li>M 兆字节</li>
<li>G 千兆字节</li>
</ul>
<p><code>find</code> 程序支持的查询参数。</p>
<ul>
<li>-cmin n 匹配的文件和目录的内容或属性最后修改时间正好在 n 分钟之前。指定少于 n 分钟之前，使用 -n，指定多于 n 分钟之前，使用 +n。</li>
<li>-cnewer file 匹配的文件和目录的内容或属性最后修改时间早于那些文件。</li>
<li>-ctime n 匹配的文件和目录的内容和属性最后修改时间在 n*24 小时之前。</li>
<li>-empty 匹配空文件和目录。</li>
<li>-group name 匹配的文件和目录属于一个组。组可以用组名或组 ID 来表示。</li>
<li>-iname pattern 就像-name 测试条件，但是不区分大小写。</li>
<li>-inum n 匹配的文件的 inode 号是 n。这对于找到某个特殊 inode 的所有硬链接很有帮助。</li>
<li>-mmin n 匹配的文件或目录的内容被修改于 n 分钟之前。</li>
<li>-mtime n 匹配的文件或目录的内容被修改于 n*24 小时之前。</li>
<li>-name pattern 用指定的通配符模式匹配的文件和目录。</li>
<li>-newer file 匹配的文件和目录的内容早于指定的文件。当编写 shell 脚本，做文件备份时，非常有帮助。每次您制作一个备份，更新文件(比如说日志)，然后使用 find 命令来决定自从上次更新，哪一个文件已经更改了。</li>
<li>-nouser 匹配的文件和目录不属于一个有效用户。这可以用来查找 属于删除帐户的文件或监测攻击行为。</li>
<li>-nogroup 匹配的文件和目录不属于一个有效的组。</li>
<li>-perm mode 匹配的文件和目录的权限已经设置为指定的 mode。mode 可以用 八进制或符号表示法。</li>
<li>-samefile name 相似于-inum 测试条件。匹配和文件 name 享有同样 inode 号的文件。</li>
<li>-size n 匹配的文件大小为 n。</li>
<li>-type c 匹配的文件类型是 c。</li>
<li>-user name 匹配的文件或目录属于某个用户。这个用户可以通过用户名或用户 ID 来表示。</li>
<li>-depth 指导 find 程序先处理目录中的文件，再处理目录自身。当指定-delete 行为时，会自动 应用这个选项。</li>
<li>-maxdepth levels 当执行测试条件和行为的时候，设置 find 程序陷入目录树的最大级别数</li>
<li>-mindepth levels 在应用测试条件和行为之前，设置 find 程序陷入目录数的最小级别数。</li>
<li>-mount 指导 find 程序不要搜索挂载到其它文件系统上的目录。</li>
<li>-regex 指定正则表达式</li>
</ul>
<div><pre><code><span># 找出包括空格或其它不规范字符的文件名或路径名</span>
$ <span>find</span> <span>.</span> -regex <span>'.*[^-\_./0-9a-zA-Z].*'</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><code>find</code> 程序还支持逻辑操作符。</p>
<ul>
<li><code>-and</code> 如果操作符两边的测试条件都是真，则匹配。可以简写为 -a。注意若没有使用操作符，则默认使用 -and。</li>
<li><code>-or</code> 若操作符两边的任一个测试条件为真，则匹配。可以简写为 -o。</li>
<li><code>-not</code> 若操作符后面的测试条件是真，则匹配。可以简写为一个感叹号(!)。</li>
<li><code>()</code> 把测试条件和操作符组合起来形成更大的表达式。这用来控制逻辑计算的优先级。注意 因为圆括号字符对于 shell 来说有特殊含义，所以在命令行中使用它们的时候，它们必须 用引号引起来，才能作为实参传递给 find 命令。通常反斜杠字符被用来转义圆括号字符。</li>
</ul>
<div><pre><code><span># 或关系</span>
<span>(</span> expression <span>1</span> <span>)</span> -or <span>(</span> expression <span>2</span> <span>)</span>

<span># 找出不是600权限的文件，或者不是700权限的目录</span>
$ <span>find</span> ~ <span>\</span><span>(</span> -type f -not -perm 0600 <span>\</span><span>)</span> -or <span>\</span><span>(</span> -type d -not -perm 0700 <span>\</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p><code>find</code> 程序的逻辑表达式，具有“短路运算”的特点，即对于 <code>expr1 -operator expr2</code> 这个表达式，<code>expr2</code> 不一定执行。这是为了提高运行速度。</p>
<ul>
<li>expr1 为真，且操作符为 <code>-and</code>，expr2 总是执行</li>
<li>expr1 为假，且操作符为 <code>-and</code>，expr2 从不执行</li>
<li>expr1 为真，且操作符为 <code>-or</code>，expr2 从不执行</li>
<li>expr1 为假，且操作符为 <code>-or</code>，expr2 总是执行</li>
</ul>
<p>为了方便执行一些常见操作，<code>find</code> 程序定义了一些预定义操作。</p>
<ul>
<li>-delete 删除当前匹配的文件。</li>
<li>-ls 对匹配的文件执行等同的 ls -dils 命令。并将结果发送到标准输出。</li>
<li>-print 把匹配文件的全路径名输送到标准输出。如果没有指定其它操作，这是 默认操作。</li>
<li>-quit 一旦找到一个匹配，退出。</li>
</ul>
<div><pre><code><span># 找到匹配的文件，并显示在标准输出</span>
<span># -print 是默认操作，可以省略</span>
$ <span>find</span> <span>.</span> -print

<span># 删除后缀名为BAK的文件</span>
<span># 执行 delete 操作前，最好先执行 print 操作，确认要删除哪些文件</span>
$ <span>find</span> <span>.</span> -type f -name <span>'*.BAK'</span> -delete
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>预定义操作可以与逻辑表达式，结合使用。</p>
<div><pre><code><span>find</span> ~ -type f -and -name <span>'*.BAK'</span> -and -print
</code></pre>
<div><span>1</span><br></div></div><p>除了预定义操作以外，用户还可以使用 <code>-exec</code> 参数自定义操作。</p>
<div><pre><code>-exec <span>command</span> <span>{</span><span>}</span> <span>;</span>
</code></pre>
<div><span>1</span><br></div></div><p>上面的命令中，<code>command</code> 是一个命令行命令，<code>{}</code> 用来指代当前路径，分号表示命令结束。</p>
<div><pre><code><span># 预定义的 -delete 操作，等同于下面的操作</span>
-exec <span>rm</span> <span>'{}'</span> <span>';'</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><code>-exec</code> 使用时，每次找到一个匹配的文件，会启动一个新的指定命令的实例。</p>
<div><pre><code><span>find</span> ~ -type f -name <span>'foo*'</span> -exec <span>ls</span> -l <span>'{}'</span> <span>';'</span>
</code></pre>
<div><span>1</span><br></div></div><p>执行上面的命令，<code>ls</code> 程序可能会被调用多次。</p>
<div><pre><code><span>ls</span> -l file1
<span>ls</span> -l file2
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>如果想改成 <code>ls</code> 程序只调用一次，要把 <code>find</code> 命令里面的分号，改成加号。</p>
<div><pre><code>$ <span>ls</span> -l file1 file2
<span># 相当于</span>
$ <span>find</span> ~ -type f -name <span>'foo*'</span> -exec <span>ls</span> -l <span>'{}'</span> +
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id="xargs"> xargs</h2>
<p><code>xargs</code> 命令从标准输入接受输入，并把输入转换为一个特定命令的参数列表。</p>
<div><pre><code><span>find</span> ~ -type f -name <span>'foo\*'</span> -print <span>|</span> <span>xargs</span> <span>ls</span> -l
</code></pre>
<div><span>1</span><br></div></div>]]></content>
    <author>
      <name>南辞</name>
    </author>
    <contributor>
      <name>南辞</name>
    </contributor>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">硬件操作</title>
    <id>http://qiqi.dreamagain.top/software/linux/bash/archives/hardware/</id>
    <link href="http://qiqi.dreamagain.top/software/linux/bash/archives/hardware/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<h1 id="硬件操作"> 硬件操作</h1>
<h2 id="df"> df</h2>
<p><code>df</code> 命令查看硬盘信息。</p>
<div><pre><code>$ <span>df</span>
Filesystem 1K-blocks Used Available Use% Mounted on
/dev/sda2 <span>15115452</span> <span>5012392</span> <span>9949716</span> <span>34</span>% /
/dev/sda5 <span>59631908</span> <span>26545424</span> <span>30008432</span> <span>47</span>% /home
/dev/sda1 <span>147764</span> <span>17370</span> <span>122765</span> <span>13</span>% /boot
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h2 id="free"> free</h2>
<p><code>free</code> 命令查看内存占用情况。</p>
<div><pre><code>$ <span>free</span>
 total used <span>free</span> shared buffers cached
Mem: <span>513712</span> <span>503976</span> <span>9736</span> <span>0</span> <span>5312</span> <span>122916</span>
-/+ buffers/cache: <span>375748</span> <span>137964</span>
Swap: <span>1052248</span> <span>104712</span> <span>947536</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h2 id="硬盘"> 硬盘</h2>
<p>文件<code>/etc/fstab</code> 配置系统启动时要挂载的设备。</p>
<div><pre><code>LABEL=/12               /               ext3        defaults        1   1
LABEL=/home             /home           ext3        defaults        1   2
LABEL=/boot             /boot           ext3        defaults        1   2
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>输出结果一共有 6 个字段，含义依次如下。</p>
<ul>
<li>设备名: 与物理设备相关联的设备文件(或设备标签)的名字，比如说<code>/dev/hda1</code>(第一个 IDE 通道上第一个主设备分区)。</li>
<li>挂载点: 设备所连接到的文件系统树的目录。</li>
<li>文件系统类型: Linux 允许挂载许多文件系统类型。</li>
<li>选项: 文件系统可以通过各种各样的选项来挂载。</li>
<li>频率: 一位数字，指定是否和在什么时间用 dump 命令来备份一个文件系统。</li>
<li>次序: 一位数字，指定 fsck 命令按照什么次序来检查文件系统。</li>
</ul>
<h2 id="mount"> mount</h2>
<p><code>mount</code> 不带参数时，显示当前挂载的文件系统。</p>
<div><pre><code>$ <span>mount</span>
/dev/sda2 on / <span>type</span> ext3 <span>(</span>rw<span>)</span>
proc on /proc <span>type</span> proc <span>(</span>rw<span>)</span>
sysfs on /sys <span>type</span> sysfs <span>(</span>rw<span>)</span>
devpts on /dev/pts <span>type</span> devpts <span>(</span>rw,gid<span>=</span><span>5</span>,mode<span>=</span><span>620</span><span>)</span>
/dev/sda5 on /home <span>type</span> ext3 <span>(</span>rw<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>这个列表的格式是: 设备 on 挂载点 type 文件系统类型(可选的)。</p>
<p><code>mount</code> 带参数时，用于将设备文件挂载到挂载点，<code>-t</code> 参数用来指定文件系统类型。</p>
<div><pre><code>$ <span>mount</span> -t iso9660 /dev/hdc /mnt/cdrom

<span># 挂载一个iso文件</span>
$ <span>mount</span> -t iso9660 -o loop image.iso /mnt/iso_image
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h2 id="umount"> umount</h2>
<p><code>umount</code> 命令用来卸载设备。</p>
<div><pre><code><span>umount</span> <span>[</span>设备名<span>]</span>

<span>umount</span> /dev/hdc
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id="fdisk"> fdisk</h2>
<p><code>fdisk</code> 命令用于格式化磁盘。</p>
<div><pre><code><span>sudo</span> <span>umount</span> /dev/sdb1
<span>sudo</span> <span>fdisk</span> /dev/sdb
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h2 id="mkfs"> mkfs</h2>
<p><code>mkfs</code> 命令用于在一个设备上新建文件系统。</p>
<div><pre><code><span>sudo</span> <span>mkfs</span> -t ext3 /dev/sdb1
<span>sudo</span> <span>mkfs</span> -t vfat /dev/sdb1
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h2 id="fsck"> fsck</h2>
<p><code>fsck</code> 命令用于检查(修复)文件系统。</p>
<div><pre><code><span>sudo</span> <span>fsck</span> /dev/sdb1
</code></pre>
<div><span>1</span><br></div></div><h2 id="dd"> dd</h2>
<p><code>dd</code> 命令用于将大型数据块，从一个磁盘复制到另一个磁盘。</p>
<div><pre><code>$ <span>dd</span> <span>if</span><span>=</span>input_file <span>of</span><span>=</span>output_file <span>[</span>bs<span>=</span>block_size <span>[</span>count<span>=</span>blocks<span>]</span><span>]</span>

<span># 将 /dev/sdb 的所有数据复制到 /dev/sdc</span>
$ <span>dd</span> <span>if</span><span>=</span>/dev/sdb <span>of</span><span>=</span>/dev/sdc

<span># 将 /dev/sdb 的所有数据拷贝到一个镜像文件</span>
$ <span>dd</span> <span>if</span><span>=</span>/dev/sdb <span>of</span><span>=</span>flash_drive.img

<span># 从cdrom制作一个iso文件</span>
$ <span>dd</span> <span>if</span><span>=</span>/dev/cdrom <span>of</span><span>=</span>ubuntu.iso
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h2 id="dmidecode"> dmidecode</h2>
<p><code>dmidecode</code> 命令用于输出 BIOS 信息。</p>
<div><pre><code><span>sudo</span> dmidecode
</code></pre>
<div><span>1</span><br></div></div><p>以上命令会输出全部 BIOS 信息。为了便于查看，往往需要指定所需信息的类别。</p>
<ul>
<li>0 BIOS</li>
<li>1 System</li>
<li>2 Base Board</li>
<li>3 Chassis 4 Processor</li>
<li>5 Memory Controller</li>
<li>6 Memory Module</li>
<li>7 Cache</li>
<li>8 Port Connector</li>
<li>9 System Slots</li>
<li>10 On Board Devices</li>
<li>11 OEM Strings</li>
<li>12 System Configuration Options</li>
<li>13 BIOS Language</li>
<li>14 Group Associations</li>
<li>15 System Event Log</li>
<li>16 Physical Memory Array</li>
<li>17 Memory Device</li>
<li>18 32-bit Memory Error</li>
<li>19 Memory Array Mapped Address</li>
<li>20 Memory Device Mapped Address</li>
<li>21 Built-in Pointing Device</li>
<li>22 Portable Battery</li>
<li>23 System Reset</li>
<li>24 Hardware Security</li>
<li>25 System Power Controls</li>
<li>26 Voltage Probe</li>
<li>27 Cooling Device</li>
<li>28 Temperature Probe</li>
<li>29 Electrical Current Probe</li>
<li>30 Out-of-band Remote Access</li>
<li>31 Boot Integrity Services</li>
<li>32 System Boot</li>
<li>33 64-bit Memory Error</li>
<li>34 Management Device</li>
<li>35 Management Device Component</li>
<li>36 Management Device Threshold Data</li>
<li>37 Memory Channel</li>
<li>38 IPMI Device</li>
<li>39 Power Supply</li>
</ul>
<p>查看内存信息的命令如下。</p>
<div><pre><code>$ <span>sudo</span> dmidecode -t <span>17</span>
<span># 或者</span>
$ dmidecode --type <span>17</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>以下是其他一些选项。</p>
<div><pre><code><span># 查看BIOS信息</span>
$ <span>sudo</span> dmidecode –t <span>0</span>

<span># 查看CPU信息</span>
$ <span>sudo</span> dmidecode -t <span>4</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p><code>dmidecode</code> 也支持关键词查看，关键词与类别的对应关系如下。</p>
<ul>
<li>bios 0, 13</li>
<li>system 1, 12, 15, 23, 32</li>
<li>baseboard 2, 10</li>
<li>chassis 3</li>
<li>processor 4</li>
<li>memory 5, 6, 16, 17</li>
<li>cache 7</li>
<li>connector 8</li>
<li>slot 9</li>
</ul>
<p>查看系统信息的命令如下。</p>
<div><pre><code><span>sudo</span> dmidecode -t system
</code></pre>
<div><span>1</span><br></div></div><h2 id="lspci"> lspci</h2>
<p><code>lspci</code> 命令列出本机的所有 PCI 设备。</p>
<div><pre><code>lspci
</code></pre>
<div><span>1</span><br></div></div><p>该命令输出信息的格式如下。</p>
<div><pre><code>03:00.0 Unassigned class <span>[</span>ff00<span>]</span>: Realtek Semiconductor Co., Ltd. RTS5209 PCI Express Card Reader <span>(</span>rev 01<span>)</span>
</code></pre>
<div><span>1</span><br></div></div><p>输出信息一共分成三个字段。</p>
<ul>
<li>Field 1: PCI bus slot 的编号</li>
<li>Field 2: PCI slot 的名字</li>
<li>Field 3: 设备名和厂商名</li>
</ul>
<p>如果想查看更详细信息，可以使用下面的命令。</p>
<div><pre><code>lspci -vmm
</code></pre>
<div><span>1</span><br></div></div><h2 id="lsusb"> lsusb</h2>
<p><code>lsusb</code> 命令用于操作 USB 端口。</p>
<p>下面命令列出本机所有 USB 端口。</p>
<div><pre><code>lsusb
</code></pre>
<div><span>1</span><br></div></div><p>它的输出格式如下。</p>
<div><pre><code>Bus 002 Device 003: ID 0781:5567 SanDisk Corp. Cruzer Blade
</code></pre>
<div><span>1</span><br></div></div><p>各个字段的含义如下。</p>
<ul>
<li>Bus 002 : bus 编号</li>
<li>Device 003: bus 002 连接的第三个设备</li>
<li>ID 0781:5567: 当前设备的编号，冒号前是厂商编号，冒号后是设备编号</li>
<li>SanDisk Corp. Cruzer Blade: 厂商和设备名</li>
</ul>
<p>找出本机有多少个 USB 接口可用。</p>
<div><pre><code>$ <span>find</span> /dev/bus/
/dev/bus/
/dev/bus/usb
/dev/bus/usb/002
/dev/bus/usb/002/006
/dev/bus/usb/002/005
/dev/bus/usb/002/004
/dev/bus/usb/002/002
/dev/bus/usb/002/001
/dev/bus/usb/001
/dev/bus/usb/001/007
/dev/bus/usb/001/003
/dev/bus/usb/001/002
/dev/bus/usb/001/001
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>查看某个 USB 设备的详细情况。</p>
<div><pre><code>lsusb -D /dev/bus/usb/002/005
</code></pre>
<div><span>1</span><br></div></div><p>查看所有设备的详细情况。</p>
<div><pre><code>lsusb -v
</code></pre>
<div><span>1</span><br></div></div><p>查看 USB 端口的版本。</p>
<div><pre><code>lsusb -v <span>|</span> <span>grep</span> -i bcdusb
</code></pre>
<div><span>1</span><br></div></div>]]></content>
    <author>
      <name>南辞</name>
    </author>
    <contributor>
      <name>南辞</name>
    </contributor>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">主机管理</title>
    <id>http://qiqi.dreamagain.top/software/linux/bash/archives/host/</id>
    <link href="http://qiqi.dreamagain.top/software/linux/bash/archives/host/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<h1 id="主机管理"> 主机管理</h1>
<h2 id="hostname-命令"> hostname 命令</h2>
<p><code>hostname</code> 命令返回当前服务器的主机名。</p>
<div><pre><code><span>hostname</span>
</code></pre>
<div><span>1</span><br></div></div>]]></content>
    <author>
      <name>南辞</name>
    </author>
    <contributor>
      <name>南辞</name>
    </contributor>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">命名管道</title>
    <id>http://qiqi.dreamagain.top/software/linux/bash/archives/named-pipe/</id>
    <link href="http://qiqi.dreamagain.top/software/linux/bash/archives/named-pipe/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<h1 id="命名管道"> 命名管道</h1>
<p>在大多数类似 Unix 的操作系统中，有可能创建一种特殊类型的文件，叫做命名管道。命名管道用来在 两个进程之间建立连接，也可以像其它类型的文件一样使用。</p>
<p>命令管道的行为类似于文件，但实际上形成了先入先出(FIFO)的缓冲。和普通(未命令的)管道一样， 数据从一端进入，然后从另一端出现。通过命令管道，有可能像这样设置一些东西:</p>
<div><pre><code>process1 <span>></span> named_pipe
</code></pre>
<div><span>1</span><br></div></div><p>和</p>
<div><pre><code>process2 <span>&lt;</span> named_pipe
</code></pre>
<div><span>1</span><br></div></div><p>表现出来就像这样:</p>
<div><pre><code>process1 <span>|</span> process2
</code></pre>
<div><span>1</span><br></div></div><h2 id="设置一个命名管道"> 设置一个命名管道</h2>
<p>使用 mkfifo 命令能够创建命令管道:</p>
<div><pre><code>$ <span>mkfifo</span> pipe1
$ <span>ls</span> -l pipe1
prw-r--r-- <span>1</span> me me <span>0</span> <span>2009</span>-07-17 06:41 pipe1
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>这里我们使用 mkfifo 创建了一个名为 pipe1 的命名管道。使用 ls 命令，我们查看这个文件， 看到位于属性字段的第一个字母是 “p”，表明它是一个命名管道。</p>
<h2 id="使用命名管道"> 使用命名管道</h2>
<p>为了演示命名管道是如何工作的，我们将需要两个终端窗口(或用两个虚拟控制台代替)。在第一个终端中，我们输入一个简单命令，并把命令的输出重定向到命名管道:</p>
<div><pre><code><span>ls</span> -l <span>></span> pipe1
</code></pre>
<div><span>1</span><br></div></div><p>我们按下 Enter 按键之后，命令将会挂起。这是因为在管道的另一端没有任何接受数据。当这种现象发生的时候， 据说是管道阻塞了。一旦我们绑定一个进程到管道的另一端，该进程开始从管道中读取输入的时候，这种情况会消失。使用第二个终端窗口，我们输入这个命令。</p>
<div><pre><code><span>cat</span> <span>&lt;</span> pipe1
</code></pre>
<div><span>1</span><br></div></div><p>然后产自第一个终端窗口的目录列表出现在第二个终端中，并作为来自 cat 命令的输出。在第一个终端 窗口中的 ls 命令一旦它不再阻塞，会成功地结束。</p>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <contributor>
      <name>南辞</name>
    </contributor>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">进程管理</title>
    <id>http://qiqi.dreamagain.top/software/linux/bash/archives/process/</id>
    <link href="http://qiqi.dreamagain.top/software/linux/bash/archives/process/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<h1 id="进程管理"> 进程管理</h1>
<h2 id="ps"> ps</h2>
<p><code>ps</code> 命令用来列出进程信息。</p>
<div><pre><code>$ <span>ps</span>
PID TTY           TIME CMD
<span>5198</span> pts/1    00:00:00 <span>bash</span>
<span>10129</span> pts/1   00:00:00 <span>ps</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>不带任何参数时，<code>ps</code> 只列出与当前 Session 相关的进程。输出结果中，<code>PID</code> 是进程 ID、<code>TTY</code> 是进程的终端号(如果显示<code>?</code>，则表示进程没有终端)，<code>TIME</code> 是消耗的 CPU 时间，<code>CMD</code> 是触发进程的命令。</p>
<p><code>x</code> 参数列出所有进程的详细信息，包括不在当前 Session 的信息。</p>
<div><pre><code>$ <span>ps</span> x
PID TTY   STAT   TIME COMMAND
<span>2799</span> ?    Ssl    <span>0</span>:00 /usr/libexec/bonobo-activation-server –ac
<span>2820</span> ?    Sl     <span>0</span>:01 /usr/libexec/evolution-data-server-1.10 --
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>这时的输出结果，会多出 <code>STAT</code> 一栏，表示状态。它的各种值如下。</p>
<ul>
<li><code>R</code> 正在运行或准备运行</li>
<li><code>S</code> 正在睡眠，即没有运行，正在等待一个事件唤醒</li>
<li><code>D</code> 不可中断睡眠。进程正在等待 I/O，比如磁盘驱动器的 I/O</li>
<li><code>T</code> 已停止，即进程停止运行</li>
<li><code>Z</code> “僵尸”进程。即这是一个已经终止的子进程，但父进程还没有清空它(没有把子进程从进程表中删除)</li>
<li><code>&lt;</code> 高优先级进程。这可能会授予一个进程更多重要的资源，给它更多的 CPU 时间。</li>
<li><code>N</code> 低优先级进程。一个低优先级进程(一个“好”进程)只有当其它高优先级进程执行之后，才会得到处理器时间。</li>
</ul>
<p><code>aux</code> 参数可以显示更多信息。</p>
<div><pre><code>$ <span>ps</span> aux
<span>USER</span>   PID  %CPU  %MEM     VSZ    RSS  TTY   STAT   START   TIME  COMMAND
root     <span>1</span>   <span>0.0</span>   <span>0.0</span>    <span>2136</span>    <span>644</span>  ?     Ss     Mar05   <span>0</span>:31  init
root     <span>2</span>   <span>0.0</span>   <span>0.0</span>       <span>0</span>      <span>0</span>  ?     S<span>&amp;</span>lt<span>;</span>     Mar05   <span>0</span>:00  <span>[</span>kt<span>]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>输出结果包含的列的含义如下。</p>
<ul>
<li><code>USER</code> 用户 ID，表示进程的所有者</li>
<li><code>%CPU</code> 百分比表示的 CPU 使用率</li>
<li><code>%MEM</code> 百分比表示的内存使用率</li>
<li><code>VSZ</code> 虚拟内存大小</li>
<li><code>RSS</code> 进程占用的物理内存的大小，以千字节为单位。</li>
<li><code>START</code> 进程运行的起始时间。若超过 24 小时，则用天表示。</li>
</ul>
<h2 id="top"> top</h2>
<p><code>top</code> 命令可以查看机器的当前状态。</p>
<div><pre><code><span>top</span>
</code></pre>
<div><span>1</span><br></div></div><p>它的输出结果分为两部分，最上面是系统概要，下面是进程列表，以 CPU 的使用率排序。</p>
<p>输出结果是动态更新的，默认每三分钟更新一次。</p>
<h2 id="jobs"> jobs</h2>
<p><code>jobs</code> 命令用来查看后台任务。</p>
<div><pre><code>$ <span>jobs</span>
<span>[</span><span>1</span><span>]</span>+ Running            xlogo <span>&amp;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>输出结果之中，每个后台任务会有一个编号。上面结果中，<code>xlogo</code> 的编号是 <code>1</code>，<code>+</code> 表示正在运行。</p>
<h2 id="fg"> fg</h2>
<p><code>fg</code> 命令用于将后台任务切换到前台。</p>
<div><pre><code><span>fg</span> %1
</code></pre>
<div><span>1</span><br></div></div><p><code>fg</code> 命令之后，跟随着一个百分号和工作序号，用来指定切换哪一个后台任务。如果只有一个后台任务，那么 <code>fg</code> 命令可以不带参数。</p>
<h2 id="bg"> bg</h2>
<p><code>bg</code> 命令用于将一个暂停的前台任务，转移到后台。只有暂停的任务，才能使用 <code>bg</code> 命令，因为正在运行的任务，命令行是无法输入的。</p>
<div><pre><code><span>bg</span> %1
</code></pre>
<div><span>1</span><br></div></div><p><code>Ctrl + z</code> 可以暂停正在运行的前台任务。</p>
<h2 id="kill"> kill</h2>
<p><code>kill</code> 命令用于杀死进程。它的参数是进程 ID。</p>
<div><pre><code><span>kill</span> <span>28401</span>
</code></pre>
<div><span>1</span><br></div></div><p><code>kill</code> 命令的实质是操作系统向进程发送信号。在使用 Ctrl-c 的情况下，会发送一个叫做 INT(中断)的信号；当使用 Ctrl-z 时，则发送一个叫做 TSTP(终端停止)的信号。</p>
<p><code>kill</code> 命令可以用来向进程发送指定信号。</p>
<div><pre><code><span>kill</span> <span>[</span>-signal<span>]</span> PID
</code></pre>
<div><span>1</span><br></div></div><p>下面是常见信号。</p>
<ul>
<li>HUP: 编号 1，表示挂起。发送这个信号到前台程序，程序会终止。许多守护进程也使用这个信号，来重新初始化。这意味着，当发送这个信号到一个守护进程后， 这个进程会重新启动，并且重新读取它的配置文件。Apache 网络服务器守护进程就是一个例子。</li>
<li>INT: 编号 2，中断。实现和 <code>Ctrl-c</code> 一样的功能，由终端发送。通常，它会终止一个程序。</li>
<li>KILL: 编号 9，杀死。进程可能选择忽略这个信号。所以，操作系统不发送该信号到目标进程，而是内核立即终止这个进程。当一个进程以这种方式终止的时候，它没有机会去做些“清理”工作，或者是保存劳动成果。因为这个原因，把 KILL 信号看作杀手锏，当其它终止信号失败后，再使用它。</li>
<li>TERM: 编号 15，终止。这是 kill 命令发送的默认信号。如果程序仍然“活着”，可以接受信号，那么这个信号终止。</li>
<li>CONT: 编号 18，继续。在停止一段时间后，进程恢复运行。</li>
<li>STOP: 编号 19，停止。这个信号导致进程停止运行，而没有终止。像 KILL 信号，它不被 发送到目标进程，因此它不能被忽略。</li>
<li>QUIT: 编号 3，退出</li>
<li>SEGV: 编号 11，段错误。如果一个程序非法使用内存，就会发送这个信号。也就是说，程序试图写入内存，而这个内存空间是不允许此程序写入的。</li>
<li>TSTP: 编号 20，终端停止。当按下 Ctrl-z 组合键后，终端发送这个信号。不像 STOP 信号， TSTP 信号由目标进程接收，且可能被忽略。</li>
<li>WINCH: 编号 28，改变窗口大小。当改变窗口大小时，系统会发送这个信号。一些程序，像 top 和 less 程序会响应这个信号，按照新窗口的尺寸，刷新显示的内容。</li>
</ul>
<p><code>-l</code> 参数可以列出所有信号。</p>
<div><pre><code><span>kill</span> -l
</code></pre>
<div><span>1</span><br></div></div><h2 id="killall"> killall</h2>
<p><code>killall</code> 命令用于向指定的程序或用户发送信号。</p>
<div><pre><code><span>killall</span> <span>[</span>-u user<span>]</span> <span>[</span>-signal<span>]</span> name
</code></pre>
<div><span>1</span><br></div></div><h2 id="其他进程相关命令"> 其他进程相关命令</h2>
<ul>
<li><code>pstree</code> 输出树型结构的进程列表，这个列表展示了进程间父/子关系。</li>
<li><code>vmstat</code> 输出一个系统资源使用快照，包括内存，交换分区和磁盘 I/O。为了看到连续的显示结果，则在命令名后加上延时的时间(以秒为单位)。例如，“vmstat 5”。终止输出，按下 Ctrl-c 组合键。</li>
<li><code>xload</code> 一个图形界面程序，可以画出系统负载的图形。</li>
<li><code>tload</code> 与 <code>xload</code> 程序相似，但是在终端中画出图形。使用 Ctrl-c，来终止输出。</li>
</ul>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <contributor>
      <name>南辞</name>
    </contributor>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">重定向</title>
    <id>http://qiqi.dreamagain.top/software/linux/bash/archives/redirection/</id>
    <link href="http://qiqi.dreamagain.top/software/linux/bash/archives/redirection/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<h1 id="重定向"> 重定向</h1>
<p>重定向指的是将命令行输出写入指定位置。</p>
<ul>
<li><code>cmd1 | cmd2</code>: Pipe; take standard output of cmd1 as standard input to cmd2.</li>
<li><code>&gt; file</code>: Direct standard output to file.</li>
<li><code>&lt; file</code>: Take standard input from file.</li>
<li><code>&gt;&gt; file</code>: Direct standard output to file; append to file if it already exists.</li>
<li><code>&gt;| file</code>: Force standard output to file even if noclobber is set.</li>
<li><code>n&gt;| file</code>: Force output to file from file descriptor n even if noclobber is set.</li>
<li><code>&lt;&gt; file</code>: Use file as both standard input and standard output.</li>
<li><code>n&lt;&gt; file</code>: Use file as both input and output for file descriptor n.</li>
<li><code>&lt;&lt; label</code>: Here-document; see text.</li>
<li><code>n &gt; file</code>: Direct file descriptor n to file.</li>
<li><code>n &lt; file</code>: Take file descriptor n from file.</li>
<li><code>n &gt;&gt; file</code>: Direct file descriptor n to file; append to file if it already exists.</li>
<li><code>n&gt;&amp;</code>: Duplicate standard output to file descriptor n.</li>
<li><code>n&lt;&amp;</code>: Duplicate standard input from file descriptor n.</li>
<li><code>n&gt;&amp;m</code>: File descriptor  n is made to be a copy of the output file descriptor.</li>
<li><code>n&lt;&amp;m</code>: File descriptor  n is made to be a copy of the input file descriptor.</li>
<li><code>&amp;&gt;file</code>: Directs standard output and standard error to file.</li>
<li><code>&lt;&amp;-</code>: Close the standard input.</li>
<li><code>&gt;&amp;-</code>: Close the standard output.</li>
<li><code>n&gt;&amp;-</code>: Close the output from file descriptor  n.</li>
<li><code>n&lt;&amp;-</code>: Close the input from file descriptor  n.</li>
<li><code>n&gt;&amp;word</code>: If  n is not specified, the standard output (file descriptor 1) is used. If the digits in word do not specify a file descriptor open for output, a redirection error occurs. As a special case, if n is omitted, and word does not expand to one or more digits, the standard output and standard error are redirected as described previously.</li>
<li><code>n&lt;&amp;word</code>: If word expands to one or more digits, the file descriptor denoted by  n is made to be a copy of that file descriptor. If the digits in word do not specify a file descriptor open for input, a redirection error occurs. If word evaluates to -, file descriptor n is closed. If n is not specified, the standard input (file descriptor 0) is used.</li>
<li><code>n&gt;&amp;digit-</code>: Moves the file descriptor digit to file descriptor  n, or the standard output (file descriptor 1) if n is not specified.</li>
<li><code>n&lt;&amp;digit-</code>: Moves the file descriptor digit to file descriptor  n, or the standard input (file descriptor 0) if n is not specified. digit is closed after being duplicated to n.</li>
</ul>
<p><code>&gt;</code> 用来将标准输出重定向到指定文件。</p>
<div><pre><code><span>ls</span> -l /usr/bin <span>></span> ls-output.txt
</code></pre>
<div><span>1</span><br></div></div><p>如果重定向后的指定文件已经存在，就会被覆盖，不会有任何提示。</p>
<p>如果命令没有任何输出，那么重定向之后，得到的是一个长度为 <code>0</code> 的文件。因此，<code>&gt;</code> 具有创建新文件或改写现存文件、将其改为长度 <code>0</code> 的作用。</p>
<div><pre><code><span>></span> ls-output.txt
</code></pre>
<div><span>1</span><br></div></div><p><code>&gt;&gt;</code> 用来将标准输出重定向追加到指定文件。</p>
<div><pre><code><span>ls</span> -l /usr/bin <span>>></span> ls-output.txt
</code></pre>
<div><span>1</span><br></div></div><p><code>2&gt;</code> 用来将标准错误重定向到指定文件。</p>
<div><pre><code><span>ls</span> -l /bin/usr <span><span>2</span>></span> ls-error.txt
</code></pre>
<div><span>1</span><br></div></div><p>标准输出和标准错误，可以重定向到同一个文件。</p>
<div><pre><code>$ <span>ls</span> -l /bin/usr <span>></span> ls-output.txt <span><span>2</span>></span><span>&amp;1</span>
<span># 或者</span>
$ <span>ls</span> -l /bin/usr <span>&amp;></span> ls-output.txt

<span># 追加到同一个文件</span>
$ <span>ls</span> -l /bin/usr <span>&amp;>></span> ls-output.txt
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>如果不希望输出错误信息，可以将它重定向到一个特殊文件<code>/dev/null</code>。</p>
<div><pre><code><span>ls</span> -l /bin/usr <span><span>2</span>></span> /dev/null
</code></pre>
<div><span>1</span><br></div></div><p><code>|</code> 用于将一个命令的标准输出，重定向到另一个命令的标准输入。</p>
<div><pre><code><span>ls</span> -l /usr/bin <span>|</span> <span>less</span>
</code></pre>
<div><span>1</span><br></div></div><p>不要将<code>&gt;</code> 与 <code>|</code> 混淆。</p>
<div><pre><code><span>ls</span> <span>></span> <span>less</span>
</code></pre>
<div><span>1</span><br></div></div><p>上面命令会在当前目录，生成一个名为 <code>less</code> 的文本文件。</p>
<p>下面是标准错误重定向的一个例子。</p>
<div><pre><code><span>invalid_input</span> <span>(</span><span>)</span> <span>{</span>
    <span>echo</span> <span>"Invalid input '<span>$REPLY</span>'"</span> <span>></span><span>&amp;2</span>
    <span>exit</span> <span>1</span>
<span>}</span>
<span>read</span> -p <span>"Enter a single item > "</span>
<span>[</span><span>[</span> -z <span>$REPLY</span> <span>]</span><span>]</span> <span>&amp;&amp;</span> invalid_input
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h2 id="tee"> tee</h2>
<p><code>tee</code> 命令用于同时将标准输出重定向到文件，以及另一个命令的标准输入。</p>
<div><pre><code><span>ls</span> /usr/bin <span>|</span> <span>tee</span> ls.txt <span>|</span> <span>grep</span> <span>zip</span>
</code></pre>
<div><span>1</span><br></div></div><h2 id="命令替换"> 命令替换</h2>
<p>命令替换(command substitution)指的是将一个命令的输出，替换进入另一个命令。<code>$(command)</code> 表示命令替换，另一种写法是使用反引号。</p>
<div><pre><code>$ <span>echo</span> <span><span>$(</span><span>ls</span><span>)</span></span>
<span># 或者</span>
$ <span>echo</span> <span><span>`</span><span>ls</span><span>`</span></span>

$ <span>ls</span> -l <span><span>$(</span><span>which</span> <span>cp</span><span>)</span></span>
<span># 或者</span>
$ <span>ls</span> -l <span><span>`</span><span>which</span> <span>cp</span><span>`</span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h2 id="basename"> basename</h2>
<p><code>basename</code> 命令清除 一个路径名的开头部分，只留下一个文件的基本名称。</p>
<div><pre><code><span>#!/bin/bash</span>
<span># file_info: simple file information program</span>
<span>PROGNAME</span><span>=</span><span><span>$(</span><span>basename</span> $0<span>)</span></span>
<span>if</span> <span>[</span><span>[</span> -e <span>$1</span> <span>]</span><span>]</span><span>;</span> <span>then</span>
    <span>echo</span> -e <span>"<span title="\n">\n</span>File Type:"</span>
    <span>file</span> <span>$1</span>
    <span>echo</span> -e <span>"<span title="\n">\n</span>File Status:"</span>
    <span>stat</span> <span>$1</span>
<span>else</span>
    <span>echo</span> <span>"<span>$PROGNAME</span>: usage: <span>$PROGNAME</span> file"</span> <span>></span><span>&amp;2</span>
    <span>exit</span> <span>1</span>
<span>fi</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div>]]></content>
    <author>
      <name>南辞</name>
    </author>
    <contributor>
      <name>南辞</name>
    </contributor>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">正则表达式</title>
    <id>http://qiqi.dreamagain.top/software/linux/bash/archives/regex/</id>
    <link href="http://qiqi.dreamagain.top/software/linux/bash/archives/regex/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<h1 id="正则表达式"> 正则表达式</h1>
<p><code>正则表达式</code>是表达文本模式的方法。</p>
<ul>
<li><code>.</code>: 匹配任何单个字符。</li>
<li><code>?</code>: 上一项是可选的，最多匹配一次。</li>
<li><code>*</code>: 前一项将被匹配零次或多次。</li>
<li><code>+</code>: 前一项将被匹配一次或多次。</li>
<li><code>{N}</code>: 上一项完全匹配 N 次。</li>
<li><code>{N，}</code>: 前一项匹配 N 次或多次。</li>
<li><code>{N，M}</code>: 前一项至少匹配 N 次，但不超过 M 次。</li>
<li><code>--</code>: 表示范围，如果它不是列表中的第一个或最后一个，也不是列表中某个范围的终点。</li>
<li><code>^</code>: 匹配行首的空字符串；也代表不在列表范围内的字符。</li>
<li><code>$</code>: 匹配行尾的空字符串。</li>
<li><code>\b</code>: 匹配单词边缘的空字符串。</li>
<li><code>\B</code>: 匹配空字符串，前提是它不在单词的边缘。</li>
<li><code>\&lt;</code>: 匹配单词开头的空字符串。</li>
<li><code>\&gt;</code>: 匹配单词末尾的空字符串。</li>
</ul>
<h2 id="元字符"> 元字符</h2>
<p><code>元字符</code>是表示特殊函数的字符，包括以下这些 <code>^ $ . [ ] { } - ? * + ( ) | \\</code>。除了元字符，其他字符在正则表达式中，都表示原来的含义。</p>
<ul>
<li><code>.</code> 匹配任意字符，但不含空字符</li>
<li><code>^</code> 匹配文本行开头</li>
<li><code>$</code> 匹配文本行结尾</li>
</ul>
<div><pre><code><span>grep</span> -h <span>'.zip'</span> dirlist*.txt
</code></pre>
<div><span>1</span><br></div></div><p>上面命令在文件中查找包含正则表达式“.zip”的文本行。注意，上面命令不会匹配 <code>zip</code> 程序，因为 <code>zip</code> 只有三个字符，而 <code>.zip</code> 要求四个字符。</p>
<div><pre><code><span>grep</span> -h <span>'^zip'</span> dirlist*.txt
<span>grep</span> -h <span>'zip$'</span> dirlist*.txt
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>上面命令分别在文件列表中搜索行首，行尾以及行首和行尾同时包含字符串“zip”(例如，zip 独占一行)的匹配行。注意正则表达式‘^$’(行首和行尾之间没有字符)会匹配空行。</p>
<h2 id="方括号"> 方括号</h2>
<p>方括号之中的字符，表示可以任意匹配其中的一个。</p>
<div><pre><code><span>grep</span> -h <span>'[bg]zip'</span> dirlist*.txt
</code></pre>
<div><span>1</span><br></div></div><p>上面命令匹配包含字符串“bzip”或者“gzip”的任意行。</p>
<p>注意，元字符放入方括号之中，会失去其特殊含义。但有两种情况除外，<code>^</code> 在方括号的开头，表示否定，否则只是一个普通字符，表示原义。</p>
<div><pre><code><span>grep</span> -h <span>'[^bg]zip'</span> dirlist*.txt
</code></pre>
<div><span>1</span><br></div></div><p>上面命令匹配不以 <code>b</code> 或 <code>g</code> 开头的 <code>zip</code> 字符串。注意，上面命令不会匹配 <code>zip</code>，因为一个否定的字符集仍然要求存在一个字符。</p>
<p><code>-</code> 在方括号之中表示一个字符区域。</p>
<div><pre><code><span>grep</span> -h <span>'^[A-Z]'</span> dirlist*.txt
</code></pre>
<div><span>1</span><br></div></div><p>上面命令匹配所有以大写字母开头的文本行。类似的，<code>^[A-Za-z0-9]</code> 表示以大写字母、小写字母、数字开头的文本行。</p>
<p>注意，连字号如果不构成一个字符区域，则表示其本来的含义。</p>
<div><pre><code><span>grep</span> -h <span>'[-AZ]'</span> dirlist*.txt
</code></pre>
<div><span>1</span><br></div></div><p>上面命令匹配包含一个连字符，或一个大写字母“A”，或一个大写字母“Z”的文件名。</p>
<h2 id="预定义字符类"> 预定义字符类</h2>
<p>由于 <code>locale</code> 设置不同，Shell 展开正则表达式 <code>[A-Z]</code> 时，可能不是解释为所有大写字母，而是解释为包括所有字母的字典顺序。</p>
<div><pre><code><span>ls</span> /usr/sbin/<span>[</span>A-Z<span>]</span>*
</code></pre>
<div><span>1</span><br></div></div><p>上面命令在某些发行版里面，会返回所有大写字母或小写字母开头的文件。</p>
<p>为了避免这个问题，可以使用正则表达式的预定义字符类。</p>
<ul>
<li><code>[:alnum:]</code> 字母数字字符。在 ASCII 中，等价于: <code>[A-Za-z0-9]</code></li>
<li><code>[:word:]</code> 与 <code>[:alnum:]</code> 相同, 但增加了下划线字符。</li>
<li><code>[:alpha:]</code> 字母字符。在 ASCII 中，等价于 <code>[A-Za-z]</code></li>
<li><code>[:blank:]</code> 包含空格和 tab 字符。</li>
<li><code>[:cntrl:]</code> ASCII 的控制码。包含了 0 到 31，和 127 的 ASCII 字符。</li>
<li><code>[:digit:]</code> 数字 0 到 9</li>
<li><code>[:graph:]</code> 可视字符。在 ASCII 中，它包含 33 到 126 的字符。</li>
<li><code>[:lower:]</code> 小写字母。</li>
<li><code>[:punct:]</code> 标点符号字符。</li>
<li><code>[:print:]</code> 可打印的字符。等于 <code>[:graph:]</code> 中的所有字符，再加上空格字符。</li>
<li><code>[:space:]</code> 空白字符，包括空格，tab，回车，换行，vertical tab, 和 form feed.在 ASCII 中， 等价于 <code>[ \t\r\n\v\f]</code></li>
<li><code>[:upper:]</code> 大写字母。</li>
<li><code>[:xdigit:]</code> 用来表示十六进制数字的字符。在 ASCII 中，等价于 <code>[0-9A-Fa-f]</code></li>
</ul>
<div><pre><code><span>ls</span> /usr/sbin/<span>[</span><span>[</span>:upper:<span>]</span><span>]</span>*
</code></pre>
<div><span>1</span><br></div></div><p>上面命令返回所有大写字母开头的文件名。</p>
<h2 id="选择"> 选择</h2>
<p><code>|</code> 表示匹配一系列字符串之中的一个。注意与方括号区分，方括号表示匹配一系列字符之中的一个。</p>
<div><pre><code>$ <span>echo</span> <span>"AAA"</span> <span>|</span> <span>grep</span> -E <span>'AAA|BBB'</span>
AAA
$ <span>echo</span> <span>"BBB"</span> <span>|</span> <span>grep</span> -E <span>'AAA|BBB'</span>
BBB
$ <span>echo</span> <span>"CCC"</span> <span>|</span> <span>grep</span> -E <span>'AAA|BBB'</span>
$
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>上面代码中，<code>AAA|BBB</code> 表示匹配字符串 <code>AAA</code> 或者是字符串 <code>BBB</code>。<code>grep</code> 程序使用 <code>-E</code> 参数，表示按照正则表达式规则匹配。并且，这个正则表达式放在单引号之中，为的是阻止 Shell 把 <code>|</code> 解释为管道操作符。</p>
<p><code>|</code> 可以多个连用，也可以与其他正则规则结合使用。</p>
<div><pre><code><span>echo</span> <span>"AAA"</span> <span>|</span> <span>grep</span> -E <span>'AAA|BBB|CCC'</span>

<span>grep</span> -Eh <span>'^(bz|gz|zip)'</span> dirlist*.txt
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id="量词操作符"> 量词操作符</h2>
<p>量词操作符表示一个元素被匹配的次数。</p>
<ul>
<li><code>?</code> 匹配前面的元素出现 0 次或 1 次</li>
<li><code>*</code> 匹配前面的元素出现 0 次或多次</li>
<li><code>+</code> 匹配前面的元素出现 1 次或多次</li>
<li><code>{n}</code> 匹配前面的元素出现了 <code>n</code> 次</li>
<li><code>{n,m}</code> 匹配前面的元素它至少出现了 <code>n</code> 次，但是不多于 <code>m</code> 次</li>
<li><code>{n,}</code> 匹配前面的元素至少出现了 <code>n</code> 次</li>
<li><code>{,m}</code> 匹配前面的元素，如果它出现的次数不多于 m 次。</li>
</ul>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <contributor>
      <name>南辞</name>
    </contributor>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">系统信息</title>
    <id>http://qiqi.dreamagain.top/software/linux/bash/archives/system/</id>
    <link href="http://qiqi.dreamagain.top/software/linux/bash/archives/system/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<h1 id="系统信息"> 系统信息</h1>
<h2 id="uname"> uname</h2>
<p><code>uname</code> 命令返回当前机器的信息。</p>
<div><pre><code><span># 内核的版本</span>
$ <span>uname</span> -r
<span>3.2</span>.0-24-virtual

<span># CPU 架构</span>
$ <span>uname</span> -m
x86_64
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>如果要了解操作系统的版本，可以查看<code>/etc/issue</code> 文件。</p>
<div><pre><code>$ <span>cat</span> /etc/issue
Debian GNU/Linux <span>9</span> <span>\</span>n <span>\</span>l
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h2 id="service"> service</h2>
<p><code>service</code> 命令可以查看当前正在运行的服务。</p>
<div><pre><code>$ <span>service</span> --status-all
 <span>[</span> + <span>]</span>  apache2
 <span>[</span> ? <span>]</span>  atd
 <span>[</span> - <span>]</span>  bootlogd
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>上面代码中，<code>+</code> 表示正在运行，<code>-</code> 表示已经停止，<code>?</code>表示 <code>service</code> 命令不了解相关信息。</p>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <contributor>
      <name>南辞</name>
    </contributor>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">文本处理</title>
    <id>http://qiqi.dreamagain.top/software/linux/bash/archives/text/</id>
    <link href="http://qiqi.dreamagain.top/software/linux/bash/archives/text/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<h1 id="文本处理"> 文本处理</h1>
<h2 id="cat"> cat</h2>
<p><code>cat</code> 可以文件的内容，显示在标准输出。</p>
<div><pre><code>$ <span>cat</span> text1
<span>1</span> apple
<span>2</span> pear
<span>3</span> banana
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>它也可以同时输出多个文件内容。</p>
<div><pre><code><span>cat</span> text1 text2
</code></pre>
<div><span>1</span><br></div></div><p>它与重定向结合，就可以合并多个文件。</p>
<div><pre><code><span># 合并文本文件</span>
$ <span>cat</span> text* <span>></span> text.all

<span># 合并二进制文件</span>
$ <span>cat</span> movie.mpeg.0* <span>></span> movie.mpeg
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>如果调用 <code>cat</code> 命令时没有任何参数，它将读取标准输入，然后显示到标准输出。按下 <code>Ctrl + d</code>，将会结束 <code>cat</code> 读取标准输入。利用这一点，可以将键盘输入写入指定文件，按下 <code>Ctrl + d</code> 结束输入。</p>
<div><pre><code><span>cat</span> <span>></span> lazy_dog.txt
</code></pre>
<div><span>1</span><br></div></div><p>它的参数如下。</p>
<ul>
<li><code>-n</code> 输出结果显示行号</li>
<li><code>-s</code> 将多个连续的空白行，输出为一行</li>
<li><code>-A</code> 输出结果中显示控制符，比如 Tab 键显示为 <code>^I</code>，行尾显示<code>$</code></li>
</ul>
<p><code>cat</code> 支持 Here document，显示多行文本。</p>
<div><pre><code><span>cat</span> <span>&lt;&lt;</span> <span>_EOF_
&lt;HTML>
         &lt;HEAD>
                &lt;TITLE><span>$TITLE</span>&lt;/TITLE>
         &lt;/HEAD>
         &lt;BODY>
                &lt;H1><span>$TITLE</span>&lt;/H1>
                &lt;P><span>$TIME_STAMP</span>&lt;/P>
         &lt;/BODY>
&lt;/HTML>
_EOF_</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>Here document 常在脚本当中作为输入的手段。</p>
<div><pre><code>$ <span>sort</span> -k2 <span>&lt;&lt;</span>END
<span>></span> <span>1</span> apple
<span>></span> <span>2</span> pear
<span>></span> <span>3</span> banana
<span>></span> END
<span>1</span> apple
<span>3</span> banana
<span>2</span> pear
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>如果使用 <code>&lt;&lt;-</code> 代替 <code>&lt;&lt;</code>，行首的 tab 键将被剥离。</p>
<h2 id="nl"> nl</h2>
<p><code>nl</code> 命令为文本文件添加行号，显示在标准输出。</p>
<div><pre><code><span>nl</span> example.txt
</code></pre>
<div><span>1</span><br></div></div><h2 id="sort"> sort</h2>
<p><code>sort</code> 命令将文本文件的所有行排序后输出。</p>
<div><pre><code><span>sort</span> file1.txt file2.txt file3.txt <span>></span> final_sorted_list.txt
</code></pre>
<div><span>1</span><br></div></div><p>它的参数如下。</p>
<ul>
<li><code>-b</code> <code>--ignore-leading-blanks</code> 默认情况下，排序用的是每行的第一个字符。这个参数忽略每行开头的空格，从第一个非空白字符开始排序。</li>
<li><code>-f</code> <code>--ignore-case</code> 让排序不区分大小写。</li>
<li><code>-n</code> <code>--numeric-sort</code> 按照数值排序，而不是字符值，用于行首是数值的情况。</li>
<li><code>-r</code> <code>--reverse</code> 按相反顺序排序。结果按照降序排列，而不是升序。</li>
<li><code>-k</code> <code>--key=field1[,field2]</code> 指定按照每行的第几个字段(从 1 开始)排序，而不是按照行首字符排序。该属性可以多个连用，用于指定多重排序标准，还可以指定每个字段指定排序标准，这些值与全局属性一致，比如 b(忽略开头的空格)，n(数值排序)，r(逆向排序)等等。</li>
<li><code>-m</code> <code>--merge</code> 把每个参数看作是一个预先排好序的文件。把多个文件合并成一个排好序的文件，而没有执行额外的排序。</li>
<li><code>-o</code> <code>--output=file</code> 把排好序的输出结果发送到文件，而不是标准输出。</li>
<li><code>-t</code> <code>--field-separator=char</code> 定义字段分隔字符。默认情况下，字段由空格或制表符分隔。</li>
<li><code>-u</code> 输出结果中删除重复行</li>
</ul>
<div><pre><code><span>sort</span> --key<span>=</span><span>1,1</span> --key<span>=</span>2n distros.txt
</code></pre>
<div><span>1</span><br></div></div><p>上面命令中，第一个 <code>--key</code> 指定第一排序标准是只用第一字段(<code>1,1</code>)，也可以指定使用第一字段第一个字符(<code>1.1</code>)；第二排序标准是第二字段，按数值排序。</p>
<h2 id="uniq"> uniq</h2>
<p><code>uniq</code> 命令在排序后的行中，删除所有重复的行，保证所有输出没有重复。</p>
<div><pre><code><span>ls</span> /bin /usr/bin <span>|</span> <span>sort</span> <span>|</span> <span>uniq</span>
</code></pre>
<div><span>1</span><br></div></div><p>它的参数如下。</p>
<ul>
<li><code>-c</code> 输出所有的重复行，并且每行开头显示重复的次数。</li>
<li><code>-d</code> 只输出重复行，而不是不重复的文本行。</li>
<li><code>-f n</code> 忽略每行开头的 n 个字段，字段之间由空格分隔，正如 sort 程序中的空格分隔符；然而， 不同于 sort 程序，uniq 没有选项来设置备用的字段分隔符。</li>
<li><code>-i</code> 在比较文本行的时候忽略大小写。</li>
<li><code>-s n</code> 跳过(忽略)每行开头的 n 个字符。</li>
<li><code>-u</code> 只是输出独有的文本行。这是默认的。</li>
<li><code>-V</code> 按照版本号排序。</li>
</ul>
<p><code>-V</code> 参数可以按版本号排列(从小到大)。</p>
<div><pre><code>$ <span>sort</span> -V input.txt
<span>1.0</span>.15
<span>1.3</span>.0
<span>2.1</span>.2
<span>3.0</span>.0
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p><code>-rV</code> 参数可以按版本号逆序排列。</p>
<div><pre><code>$ <span>sort</span> -rV input.txt
<span>3.0</span>.0
<span>2.1</span>.2
<span>1.3</span>.0
<span>1.0</span>.15
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h2 id="cut"> cut</h2>
<p><code>cut</code> 程序用来从文本行中抽取文本，并把其输出到标准输出。它能够接受多个文件参数或者标准输入。</p>
<p>它的参数如下。</p>
<ul>
<li><code>-c char_list</code> 抽取指定范围的文本</li>
<li><code>-f field_list</code> 抽取指定字段，字段之间可以 tab 分隔也可以逗号分隔</li>
<li><code>-d delim_char</code> 指定字段分隔符，默认是 tab 键</li>
<li><code>--complement</code> 抽取整个文本行，除了那些由-c 和／或-f 选项指定的文本。</li>
</ul>
<div><pre><code><span># 抽取每行的第三个字段</span>
$ <span>cut</span> -f <span>3</span> distros.txt

<span># 抽取每行的第7到第10个字符</span>
$ <span>cut</span> -c <span>7</span>-10 distros.txt

<span># 抽取每行的第23个到结尾的字符1</span>
$ <span>cut</span> -c <span>23</span>- distros.txt

<span># 指定字段分隔符为冒号</span>
$ <span>cut</span> -d <span>':'</span> -f <span>1</span> /etc/passwd
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h2 id="paste"> paste</h2>
<p><code>paste</code> 程序将多个文本文件按行合并，即每一行都由原来文本文件的每一行组成，显示在标准输出。</p>
<div><pre><code><span>paste</span> distros-dates.txt distros-versions.txt
</code></pre>
<div><span>1</span><br></div></div><h2 id="wc"> wc</h2>
<p><code>wc</code> 命令输出一个文本文件的统计信息(word count)，一共有三个值，分别为行数、词数和字节数。</p>
<div><pre><code>$ <span>wc</span> ls-output.txt
 <span>7902</span> <span>64566</span> <span>503634</span> ls-output.txt
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>如果使用 <code>-l</code> 参数，则只输出行数。</p>
<div><pre><code>$ <span>ls</span> /bin /usr/bin <span>|</span> <span>sort</span> <span>|</span> <span>uniq</span> <span>|</span> <span>wc</span> -l
 <span>2728</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h2 id="head"> head</h2>
<p><code>head</code> 命令返回文本文件的头部，默认显示 10 行。</p>
<p><code>-n</code> 参数指定显示的行数。</p>
<div><pre><code><span>head</span> -n <span>5</span> ls-output.txt
</code></pre>
<div><span>1</span><br></div></div><h2 id="tail"> tail</h2>
<p><code>tail</code> 命令返回文本文件的尾部，默认显示 10 行。</p>
<p><code>-n</code> 参数指定显示的行数。</p>
<div><pre><code><span>tail</span> -n <span>5</span> ls-output.txt
</code></pre>
<div><span>1</span><br></div></div><p><code>-f</code> 会实时追加显示新增的内容，常用于实时监控日志，按 <code>Ctrl + c</code> 停止。</p>
<div><pre><code><span>tail</span> -f /var/log/messages
</code></pre>
<div><span>1</span><br></div></div><h2 id="grep"> grep</h2>
<p><code>grep</code> 程序用于在指定文件之中，搜索符合某个模式的行，并把搜索结果输出到标准输出。</p>
<div><pre><code><span>grep</span> keyword foo.txt
</code></pre>
<div><span>1</span><br></div></div><p>上面命令输出 <code>foo.txt</code> 之中匹配 <code>keyword</code> 的行。</p>
<p><code>grep</code> 程序可以同时搜索多个文件。</p>
<div><pre><code><span>grep</span> keyword f*.txt
</code></pre>
<div><span>1</span><br></div></div><p>上面命令输出多个文件中匹配 <code>keyword</code> 的行。</p>
<p><code>-l</code> 参数输出匹配的文件名，而不是文件行。</p>
<div><pre><code><span>grep</span> -l bzip dirlist*.txt
</code></pre>
<div><span>1</span><br></div></div><p>如果想搜索文件名，而不是文件内容，可以使用重定向。</p>
<div><pre><code><span>ls</span> /usr/bin <span>|</span> <span>grep</span> <span>zip</span>
</code></pre>
<div><span>1</span><br></div></div><p>上面命令会输出<code>/usr/bin</code> 目录中，文件名中包含子字符串 <code>zip</code> 的所有文件。</p>
<p>参数的含义。</p>
<ul>
<li><code>-c</code> 或 <code>--count</code> 输出匹配的数量，而不是匹配的文本行。如果使用了 <code>-v</code>，则输出不匹配的数量。</li>
<li><code>-h</code> 或 <code>--no-filename</code> 应用于多文件搜索，不在每行匹配的文本前，输出文件名</li>
<li><code>-i</code> 或 <code>--ignore-case</code> 忽略大小写</li>
<li><code>-l</code> 或 <code>--files-with-matches</code> 输出包含匹配项的文件名，而不是文本行本身</li>
<li><code>-L</code> 或 <code>--files-without-match</code> 类似于 <code>-l</code>，但输出不包含匹配项的文件名</li>
<li><code>-n</code> 或 <code>--line-number</code> 每个匹配行之前输出其对应的行号</li>
<li><code>-v</code> 或 <code>--invert-match</code> 只返回不符合模式的行</li>
</ul>
<h2 id="sed"> sed</h2>
<p><code>sed</code> 是一个强大的文本编辑工具。</p>
<div><pre><code><span># 输出前5行</span>
$ <span>sed</span> -n <span>'1,5p'</span> distros.txt

<span># 输出包含指定内容的行</span>
$ <span>sed</span> -n <span>'/SUSE/p'</span> distros.txt

<span># 输出不包含指定内容的行</span>
$ <span>sed</span> -n <span>'/SUSE/!p'</span> distros.txt

<span># 替换内容(只替换第一个)</span>
$ <span>sed</span> <span>'s/regexp/replacement/'</span> distros.txt

<span># 替换内容(全局替换)</span>
$ <span>sed</span> <span>'s/regexp/replacement/g'</span> distros.txt
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div>]]></content>
    <author>
      <name>南辞</name>
    </author>
    <contributor>
      <name>南辞</name>
    </contributor>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">时间管理</title>
    <id>http://qiqi.dreamagain.top/software/linux/bash/archives/time/</id>
    <link href="http://qiqi.dreamagain.top/software/linux/bash/archives/time/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<h1 id="时间管理"> 时间管理</h1>
<h2 id="date-命令"> date 命令</h2>
<p><code>date</code> 命令用于输出当前时间</p>
<div><pre><code>$ <span>date</span>
<span>2016</span>年 03月 <span>14</span>日 星期一 <span>17</span>:32:35 CST
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><code>date</code> 命令后面用加号(<code>+</code>)指定显示的格式。</p>
<div><pre><code>$ <span>date</span> +%d_%b_%Y
10_Sep_2018

$ <span>date</span> +%D
09/10/18

$ <span>date</span> +%F-%T
<span>2018</span>-09-10-11:09:51
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>完整的格式参数如下。</p>
<ul>
<li>%a 星期名的缩写(Sun)</li>
<li>%A 星期名的全称(Sunday)</li>
<li>%b 月份的缩写(Jan)</li>
<li>%B 月份的全称(January)</li>
<li>%c 日期和时间(Thu Mar 3 23:05:25 2005)</li>
<li>%C 世纪，就是年份数省略后两位(20)</li>
<li>%d 一个月的第几天(01)</li>
<li>%D 日期，等同于<code>%m/%d/%y</code></li>
<li>%e 一个月的第几天，用空格补零，等同于<code>%_d</code></li>
<li>%F 完整的日期，等同于<code>%Y-%m-%d</code></li>
<li>%g last two digits of year of ISO week number (see %G)</li>
<li>%G year of ISO week number (see %V); normally useful only with %V</li>
<li>%h 等同于<code>%b</code></li>
<li>%H 小时(00..23)</li>
<li>%I 小时(01..12)</li>
<li>%j day of year (001..366)</li>
<li>%k hour ( 0..23)</li>
<li>%l hour ( 1..12)</li>
<li>%m month (01..12)</li>
<li>%M minute (00..59)</li>
<li>%N nanoseconds (000000000..999999999)</li>
<li>%p locale’s equivalent of either AM or PM; blank if not known</li>
<li>%P like %p, but lower case</li>
<li>%r locale’s 12-hour clock time (e.g., 11:11:04 PM)</li>
<li>%R 24-hour hour and minute; same as %H:%M</li>
<li>%s seconds since 1970-01-01 00:00:00 UTC</li>
<li>%S second (00..60)</li>
<li>%T time; same as %H:%M:%S</li>
<li>%u day of week (1..7); 1 is Monday</li>
<li>%U week number of year, with Sunday as first day of week (00..53)</li>
<li>%V ISO week number, with Monday as first day of week (01..53)</li>
<li>%w day of week (0..6); 0 is Sunday</li>
<li>%W week number of year, with Monday as first day of week (00..53)</li>
<li>%x locale’s date representation (e.g., 12/31/99)</li>
<li>%X locale’s time representation (e.g., 23:13:48)</li>
<li>%y last two digits of year (00..99)</li>
<li>%Y year</li>
<li>%z +hhmm numeric timezone (e.g., -0400)</li>
<li>%😒 +hh:mm numeric timezone (e.g., -04:00)</li>
<li>%:😒 +hh:mm:ss numeric time zone (e.g., -04:00:00)</li>
<li>%Z alphabetic time zone abbreviation (e.g., EDT)</li>
</ul>
<h2 id="cal-命令"> cal 命令</h2>
<p><code>cal</code> 命令用于显示日历。不带有参数时，显示的是当前月份。</p>
<div><pre><code>$ <span>cal</span>
      三月 <span>2016</span>
日 一 二 三 四 五 六
       <span>1</span>  <span>2</span>  <span>3</span>  <span>4</span>  <span>5</span>
 <span>6</span>  <span>7</span>  <span>8</span>  <span>9</span> <span>10</span> <span>11</span> <span>12</span>
<span>13</span> <span>14</span> <span>15</span> <span>16</span> <span>17</span> <span>18</span> <span>19</span>
<span>20</span> <span>21</span> <span>22</span> <span>23</span> <span>24</span> <span>25</span> <span>26</span>
<span>27</span> <span>28</span> <span>29</span> <span>30</span> <span>31</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div>]]></content>
    <author>
      <name>南辞</name>
    </author>
    <contributor>
      <name>南辞</name>
    </contributor>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">用户管理</title>
    <id>http://qiqi.dreamagain.top/software/linux/bash/archives/user/</id>
    <link href="http://qiqi.dreamagain.top/software/linux/bash/archives/user/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<h1 id="用户管理"> 用户管理</h1>
<h2 id="id"> id</h2>
<p><code>id</code> 命令用于查看指定用户的用户名和组名。</p>
<div><pre><code>$ <span>id</span>
<span>uid</span><span>=</span><span>500</span><span>(</span>me<span>)</span> <span>gid</span><span>=</span><span>500</span><span>(</span>me<span>)</span> <span>groups</span><span>=</span><span>500</span><span>(</span>me<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><code>id</code> 输出结果分为三个部分，分别是 UID(用户编号和用户名)、GID(组编号和组名)，groups(用户所在的所有组)。</p>
<p>用户帐户的信息，存放在<code>/etc/passwd</code> 文件里面；用户组的信息，存放在<code>/etc/group</code> 文件里面。</p>
<div><pre><code><span># 返回UID</span>
$ <span>id</span> -u <span>[</span>UserName<span>]</span>

<span># 返回GID</span>
$ <span>id</span> -g <span>[</span>UserName<span>]</span>

<span># 返回用户名</span>
$ <span>id</span> -un <span>[</span>UserName<span>]</span>

<span># 返回组名</span>
$ <span>id</span> -gn <span>[</span>UserName<span>]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>上面的命令，如果省略用户名，则返回当前用户的信息。</p>
<h2 id="su"> su</h2>
<p><code>su</code> 命令允许您以另一个用户的身份，启动一个新的 shell 会话，或者是以这个用户的身份来发布一个命令。</p>
<div><pre><code><span>su</span> otherUser
</code></pre>
<div><span>1</span><br></div></div><p>执行上面的命令以后，系统会提示输入密码。通过以后，就以另一个用户身份在执行命令了。</p>
<p>如果不加用户名，则表示切换到 root 用户。</p>
<div><pre><code><span>su</span>
</code></pre>
<div><span>1</span><br></div></div><p><code>-l</code> 参数表示启动一个需要登录的新的 Shell，这意味着工作目录会切换到该用户的主目录。它的缩写形式是 <code>-</code>。</p>
<div><pre><code><span>su</span> -
</code></pre>
<div><span>1</span><br></div></div><p>上面命令表示，切换到 root 用户的身份，且工作目录也切换到 root 用户的主目录。</p>
<p><code>-c</code> 参数表示只以其他用户的身份，执行单个命令，而不是启动一个新的 Session。</p>
<div><pre><code>$ <span>su</span> -c <span>'command'</span>

<span># 实例</span>
$ <span>su</span> -c <span>'ls -l /root/*'</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h2 id="sudo"> sudo</h2>
<p><code>sudo</code> 命令很类似 <code>su</code> 命令，但有几点差别。</p>
<ul>
<li>对于管理员来说，<code>sudo</code> 命令的可配置性更高</li>
<li><code>sudo</code> 命令通常只用于执行单个命令，而不是开启另一个 Session。</li>
<li><code>sudo</code> 命令不要求超级用户的密码，而是用户使自己的密码来认证。</li>
</ul>
<p><code>sudo</code> 的设置在文件<code>/etc/sudoers</code> 之中。</p>
<p><code>-l</code> 参数列出用户拥有的所有权限。</p>
<div><pre><code><span>sudo</span> -l
</code></pre>
<div><span>1</span><br></div></div><h2 id="chown"> chown</h2>
<p><code>chown</code> 命令用来更改文件或目录的所有者和用户组。使用这个命令需要超级用户权限。</p>
<div><pre><code><span>chown</span> <span>[</span>owner<span>]</span><span>[</span>:<span>[</span>group<span>]</span><span>]</span> <span>file</span>
</code></pre>
<div><span>1</span><br></div></div><p>下面是一些例子。</p>
<div><pre><code><span># 更改文件所有者</span>
$ <span>sudo</span> <span>chown</span> bob foo.txt

<span># 更改文件所有者和用户组</span>
$ <span>sudo</span> <span>chown</span> bob:users foo.txt

<span># 更改用户组</span>
$ <span>sudo</span> <span>chown</span> :admins foo.txt

<span># 更改文件所有者和用户组(用户 bob 登录系统时，所属的用户组)</span>
$ <span>sudo</span> <span>chown</span> bob: foo.txt
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h2 id="chgrp"> chgrp</h2>
<p><code>chgrp</code> 命令更改用户组，用法与 <code>chown</code> 命令类似。</p>
<h2 id="useradd"> useradd</h2>
<p><code>useradd</code> 命令用来新增用户。</p>
<div><pre><code><span>useradd</span> -G admin -d /home/bill -s /bin/bash -m bill
</code></pre>
<div><span>1</span><br></div></div><p>上面命令新增用户 <code>bill</code>，参数 <code>-G</code> 指定用户所在的组，参数 <code>d</code> 指定用户的主目录，参数 <code>s</code> 指定用户的 Shell，参数 <code>m</code> 表示如果该目录不存在，则创建该目录。</p>
<h2 id="usermod"> usermod</h2>
<p><code>usermod</code> 命令用来修改用户的各项属性。</p>
<div><pre><code><span>usermod</span> -g sales jerry
</code></pre>
<div><span>1</span><br></div></div><p>上面的命令修改用户 <code>jerry</code> 属于的主要用户组为 <code>sales</code>。</p>
<div><pre><code><span>usermod</span> -G sales jerry
</code></pre>
<div><span>1</span><br></div></div><p>上面的命令修改用户 <code>jerry</code> 属于的次要用户组为 <code>sales</code>。</p>
<h2 id="adduser"> adduser</h2>
<p><code>adduser</code> 命令用来将一个用户加入用户组。</p>
<div><pre><code><span>sudo</span> adduser username grouptoadd
</code></pre>
<div><span>1</span><br></div></div><h2 id="groupadd"> groupadd</h2>
<p><code>groupadd</code> 命令用来新建一个用户组。</p>
<div><pre><code><span>sudo</span> <span>groupadd</span> group1
<span>sudo</span> adduser foobar group1
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h2 id="groupdel"> groupdel</h2>
<p><code>groupdel</code> 命令用来删除一个用户组。</p>
<div><pre><code><span>sudo</span> <span>groupdel</span> group1
</code></pre>
<div><span>1</span><br></div></div><h2 id="passwd"> passwd</h2>
<p><code>passwd</code> 命令用于修改密码。</p>
<div><pre><code><span># 修改自己的密码</span>
$ <span>passwd</span>

<span># 修改其他用户的密码</span>
$ <span>sudo</span> <span>passwd</span> <span>[</span>user<span>]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div>]]></content>
    <author>
      <name>南辞</name>
    </author>
    <contributor>
      <name>南辞</name>
    </contributor>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">Bash 的算术运算</title>
    <id>http://qiqi.dreamagain.top/software/linux/bash/arithmetic/</id>
    <link href="http://qiqi.dreamagain.top/software/linux/bash/arithmetic/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<h2 id="算术表达式"> 算术表达式</h2>
<p><code>((...))</code> 语法可以进行整数的算术运算。</p>
<div><pre><code>$ <span><span>((</span>foo <span>=</span> <span>5</span> <span>+</span> <span>5</span><span>))</span></span>
$ <span>echo</span> <span>$foo</span>
<span>10</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><code>((...))</code> 会自动忽略内部的空格，所以下面的写法都正确，得到同样的结果。</p>
<div><pre><code><span><span>((</span><span>2</span><span>+</span><span>2</span><span>))</span></span>
<span><span>((</span> <span>2</span><span>+</span><span>2</span> <span>))</span></span>
<span><span>((</span> <span>2</span> <span>+</span> <span>2</span> <span>))</span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>这个语法不返回值，命令执行的结果根据算术运算的结果而定。只要算术结果不是 <code>0</code>，命令就算执行成功。</p>
<div><pre><code>$ <span><span>((</span> <span>3</span> <span>+</span> <span>2</span> <span>))</span></span>
$ <span>echo</span> <span>$?</span>
<span>0</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>上面例子中，<code>3 + 2</code> 的结果是 5，命令就算执行成功，环境变量 <code>$?</code> 为 <code>0</code>。</p>
<p>如果算术结果为 <code>0</code>，命令就算执行失败。</p>
<div><pre><code>$ <span><span>((</span> <span>3</span> <span>-</span> <span>3</span> <span>))</span></span>
$ <span>echo</span> <span>$?</span>
<span>1</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>上面例子中，<code>3 - 3</code> 的结果是 <code>0</code>，环境变量 <code>$?</code> 为 <code>1</code>，表示命令执行失败。</p>
<p>如果要读取算术运算的结果，需要在 <code>((...))</code> 前面加上美元符号 <code>$((...))</code>，使其变成算术表达式，返回算术运算的值。</p>
<div><pre><code>$ <span>echo</span> <span><span>$((</span><span>2</span> <span>+</span> <span>2</span><span>))</span></span>
<span>4</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><code>((...))</code> 语法支持的算术运算符如下。</p>
<ul>
<li><code>+</code>: 加法</li>
<li><code>-</code>: 减法</li>
<li><code>*</code>: 乘法</li>
<li><code>/</code>: 除法(整除)</li>
<li><code>%</code>: 余数</li>
<li><code>**</code>: 指数</li>
<li><code>++</code>: 自增运算(前缀或后缀)</li>
<li><code>--</code>: 自减运算(前缀或后缀)</li>
</ul>
<p>注意，除法运算符的返回结果总是整数，比如 <code>5</code> 除以 <code>2</code>，得到的结果是 <code>2</code>，而不是 <code>2.5</code>。</p>
<div><pre><code>$ <span>echo</span> <span><span>$((</span><span>5</span> <span>/</span> <span>2</span><span>))</span></span>
<span>2</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><code>++</code> 和 <code>--</code> 这两个运算符有前缀和后缀的区别。作为前缀是先运算后返回值，作为后缀是先返回值后运算。</p>
<div><pre><code>$ <span>i</span><span>=</span><span>0</span>
$ <span>echo</span> <span>$i</span>
<span>0</span>
$ <span>echo</span> <span><span>$((</span>i<span>++</span><span>))</span></span>
<span>0</span>
$ <span>echo</span> <span>$i</span>
<span>1</span>
$ <span>echo</span> <span><span>$((</span><span>++</span>i<span>))</span></span>
<span>2</span>
$ <span>echo</span> <span>$i</span>
<span>2</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>上面例子中，<code>++</code> 作为后缀是先返回值，执行 <code>echo</code> 命令，再进行自增运算；作为前缀则是先进行自增运算，再返回值执行 <code>echo</code> 命令。</p>
<p><code>$((...))</code> 内部可以用圆括号改变运算顺序。</p>
<div><pre><code>$ <span>echo</span> <span><span>$((</span> <span>(</span><span>2</span> <span>+</span> <span>3</span><span>)</span> <span>*</span> <span>4</span> <span>))</span></span>
<span>20</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>上面例子中，内部的圆括号让加法先于乘法执行。</p>
<p><code>$((...))</code> 结构可以嵌套。</p>
<div><pre><code>$ <span>echo</span> <span><span>$((</span><span>(</span><span>5</span><span>**</span><span>2</span><span>)</span> <span>*</span> <span>3</span><span>))</span></span>
<span>75</span>
<span># 等同于</span>
$ <span>echo</span> <span><span>$((</span><span>$((</span><span>5</span><span>**</span><span>2</span><span>))</span></span> * <span>3</span><span>))</span>
<span>75</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>这个语法只能计算整数，否则会报错。</p>
<div><pre><code><span># 报错</span>
$ <span>echo</span> <span><span>$((</span><span>1.5</span> <span>+</span> <span>1</span><span>))</span></span>
bash: 语法错误
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><code>$((...))</code> 的圆括号之中，不需要在变量名之前加上 <code>$</code>，不过加上也不报错。</p>
<div><pre><code>$ <span>number</span><span>=</span><span>2</span>
$ <span>echo</span> <span><span>$((</span>$number <span>+</span> <span>1</span><span>))</span></span>
<span>3</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>上面例子中，变量 <code>number</code> 前面有没有美元符号，结果都是一样的。</p>
<p>如果在 <code>$((...))</code> 里面使用字符串，Bash 会认为那是一个变量名。如果不存在同名变量，Bash 就会将其作为空值，因此不会报错。</p>
<div><pre><code>$ <span>echo</span> <span><span>$((</span> "hello" <span>+</span> <span>2</span><span>))</span></span>
<span>2</span>
$ <span>echo</span> <span><span>$((</span> "hello" <span>*</span> <span>2</span><span>))</span></span>
<span>0</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>上面例子中，<code>&quot;hello&quot;</code> 会被当作变量名，返回空值，而 <code>$((...))</code> 会将空值当作 <code>0</code>，所以乘法的运算结果就是 <code>0</code>。同理，如果 <code>$((...))</code> 里面使用不存在的变量，也会当作 <code>0</code> 处理。</p>
<p>如果一个变量的值为字符串，跟上面的处理逻辑是一样的。即该字符串如果不对应已存在的变量，在 <code>$((...))</code> 里面会被当作空值。</p>
<div><pre><code>$ <span>foo</span><span>=</span>hello
$ <span>echo</span> <span><span>$((</span> foo <span>+</span> <span>2</span><span>))</span></span>
<span>2</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>上面例子中，变量 <code>foo</code> 的值是 <code>hello</code>，而 <code>hello</code> 也会被看作变量名。这使得有可能写出动态替换的代码。</p>
<div><pre><code>$ <span>foo</span><span>=</span>hello
$ <span>hello</span><span>=</span><span>3</span>
$ <span>echo</span> <span><span>$((</span> foo <span>+</span> <span>2</span> <span>))</span></span>
<span>5</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>上面代码中，<code>foo + 2</code> 取决于变量 <code>hello</code> 的值。</p>
<p>最后，<code>$[...]</code> 是以前的语法，也可以做整数运算，不建议使用。</p>
<div><pre><code>$ <span>echo</span> $<span>[</span><span>2</span>+2<span>]</span>
<span>4</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h2 id="数值的进制"> 数值的进制</h2>
<p>Bash 的数值默认都是十进制，但是在算术表达式中，也可以使用其他进制。</p>
<ul>
<li><code>number</code>: 没有任何特殊表示法的数字是十进制数(以 10 为底)。</li>
<li><code>0number</code>: 八进制数。</li>
<li><code>0xnumber</code>: 十六进制数。</li>
<li><code>base#number</code>: <code>base</code> 进制的数。</li>
</ul>
<p>下面是一些例子。</p>
<div><pre><code>$ <span>echo</span> <span><span>$((</span><span>0xff</span><span>))</span></span>
<span>255</span>
$ <span>echo</span> <span><span>$((</span><span>2</span>#<span>11111111</span><span>))</span></span>
<span>255</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>上面例子中，<code>0xff</code> 是十六进制数，<code>2#11111111</code> 是二进制数。</p>
<h2 id="位运算"> 位运算</h2>
<p><code>$((...))</code> 支持以下的二进制位运算符。</p>
<ul>
<li><code>&lt;&lt;</code>: 位左移运算，把一个数字的所有位向左移动指定的位。</li>
<li><code>&gt;&gt;</code>: 位右移运算，把一个数字的所有位向右移动指定的位。</li>
<li><code>&amp;</code>: 位的“与”运算，对两个数字的所有位执行一个 <code>AND</code> 操作。</li>
<li><code>|</code>: 位的“或”运算，对两个数字的所有位执行一个 <code>OR</code> 操作。</li>
<li><code>~</code>: 位的“否”运算，对一个数字的所有位取反。</li>
<li><code>^</code>: 位的异或运算(exclusive or)，对两个数字的所有位执行一个异或操作。</li>
</ul>
<p>下面是右移运算符 <code>&gt;&gt;</code> 的例子。</p>
<div><pre><code>$ <span>echo</span> <span><span>$((</span><span>16</span><span>>></span><span>2</span><span>))</span></span>
<span>4</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>下面是左移运算符 <code>&lt;&lt;</code> 的例子。</p>
<div><pre><code>$ <span>echo</span> <span><span>$((</span><span>16</span><span>&lt;&lt;</span><span>2</span><span>))</span></span>
<span>64</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>下面是 <code>17</code> (二进制 <code>10001</code>)和 <code>3</code> (二进制 <code>11</code>)的各种二进制运算的结果。</p>
<div><pre><code>$ <span>echo</span> <span><span>$((</span><span>17</span><span>&amp;</span><span>3</span><span>))</span></span>
<span>1</span>
$ <span>echo</span> <span><span>$((</span><span>17</span><span>|</span><span>3</span><span>))</span></span>
<span>19</span>
$ <span>echo</span> <span><span>$((</span><span>17</span><span>^</span><span>3</span><span>))</span></span>
<span>18</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h2 id="逻辑运算"> 逻辑运算</h2>
<p><code>$((...))</code> 支持以下的逻辑运算符。</p>
<ul>
<li><code>&lt;</code>: 小于</li>
<li><code>&gt;</code>: 大于</li>
<li><code>&lt;=</code>: 小于或相等</li>
<li><code>&gt;=</code>: 大于或相等</li>
<li><code>==</code>: 相等</li>
<li><code>!=</code>: 不相等</li>
<li><code>&amp;&amp;</code>: 逻辑与</li>
<li><code>||</code>: 逻辑或</li>
<li><code>!</code>: 逻辑否</li>
<li><code>expr1?expr2:expr3</code>: 三元条件运算符。若表达式 <code>expr1</code> 的计算结果为非零值(算术真)，则执行表达式 <code>expr2</code>，否则执行表达式 <code>expr3</code>。</li>
</ul>
<p>如果逻辑表达式为真，返回 <code>1</code>，否则返回 <code>0</code>。</p>
<div><pre><code>$ <span>echo</span> <span><span>$((</span><span>3</span> <span>></span> <span>2</span><span>))</span></span>
<span>1</span>
$ <span>echo</span> <span><span>$((</span> <span>(</span><span>3</span> <span>></span> <span>2</span><span>)</span> <span>||</span> <span>(</span><span>4</span> <span>&lt;=</span> <span>1</span><span>)</span> <span>))</span></span>
<span>1</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>三元运算符执行一个单独的逻辑测试。它用起来类似于 <code>if/then/else</code> 语句。</p>
<div><pre><code>$ <span>a</span><span>=</span><span>0</span>
$ <span>echo</span> <span><span>$((</span>a<span>&lt;</span><span>1</span> <span>?</span> <span>1</span> <span>:</span> <span>0</span><span>))</span></span>
<span>1</span>
$ <span>echo</span> <span><span>$((</span>a<span>></span><span>1</span> <span>?</span> <span>1</span> <span>:</span> <span>0</span><span>))</span></span>
<span>0</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>上面例子中，第一个表达式为真时，返回第二个表达式的值，否则返回第三个表达式的值。</p>
<h2 id="赋值运算"> 赋值运算</h2>
<p>算术表达式 <code>$((...))</code> 可以执行赋值运算。</p>
<div><pre><code>$ <span>echo</span> <span><span>$((</span>a<span>=</span><span>1</span><span>))</span></span>
<span>1</span>
$ <span>echo</span> <span>$a</span>
<span>1</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>上面例子中，<code>a=1</code> 对变量 <code>a</code> 进行赋值。这个式子本身也是一个表达式，返回值就是等号右边的值。</p>
<p><code>$((...))</code> 支持的赋值运算符，有以下这些。</p>
<ul>
<li><code>parameter = value</code>: 简单赋值。</li>
<li><code>parameter += value</code>: 等价于 <code>parameter = parameter + value</code>。</li>
<li><code>parameter -= value</code>: 等价于 <code>parameter = parameter – value</code>。</li>
<li><code>parameter *= value</code>: 等价于 <code>parameter = parameter * value</code>。</li>
<li><code>parameter /= value</code>: 等价于 <code>parameter = parameter / value</code>。</li>
<li><code>parameter %= value</code>: 等价于 <code>parameter = parameter % value</code>。</li>
<li><code>parameter &lt;&lt;= value</code>: 等价于 <code>parameter = parameter &lt;&lt; value</code>。</li>
<li><code>parameter &gt;&gt;= value</code>: 等价于 <code>parameter = parameter &gt;&gt; value</code>。</li>
<li><code>parameter &amp;= value</code>: 等价于 <code>parameter = parameter &amp; value</code>。</li>
<li><code>parameter |= value</code>: 等价于 <code>parameter = parameter | value</code>。</li>
<li><code>parameter ^= value</code>: 等价于 <code>parameter = parameter ^ value</code>。</li>
</ul>
<p>下面是一个例子。</p>
<div><pre><code>$ <span>foo</span><span>=</span><span>5</span>
$ <span>echo</span> <span><span>$((</span>foo<span>*</span><span>=</span><span>2</span><span>))</span></span>
<span>10</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>如果在表达式内部赋值，可以放在圆括号中，否则会报错。</p>
<div><pre><code><span>echo</span> <span><span>$((</span> a<span>&lt;</span><span>1</span> <span>?</span> <span>(</span>a<span>+</span><span>=</span><span>1</span><span>)</span> <span>:</span> <span>(</span>a<span>-</span><span>=</span><span>1</span><span>)</span> <span>))</span></span>
</code></pre>
<div><span>1</span><br></div></div><h2 id="求值运算"> 求值运算</h2>
<p>逗号 <code>,</code> 在 <code>$((...))</code> 内部是求值运算符，执行前后两个表达式，并返回后一个表达式的值。</p>
<div><pre><code>$ <span>echo</span> <span><span>$((</span>foo <span>=</span> <span>1</span> <span>+</span> <span>2</span><span>,</span> <span>3</span> <span>*</span> <span>4</span><span>))</span></span>
<span>12</span>
$ <span>echo</span> <span>$foo</span>
<span>3</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>上面例子中，逗号前后两个表达式都会执行，然后返回后一个表达式的值 <code>12</code>。</p>
<h2 id="expr-命令"> expr 命令</h2>
<p><code>expr</code> 命令支持算术运算，可以不使用 <code>((...))</code> 语法。</p>
<div><pre><code>$ <span>expr</span> <span>3</span> + <span>2</span>
<span>5</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><code>expr</code> 命令支持变量替换。</p>
<div><pre><code>$ <span>foo</span><span>=</span><span>3</span>
$ <span>expr</span> <span>$foo</span> + <span>2</span>
<span>5</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><code>expr</code> 命令也不支持非整数参数。</p>
<div><pre><code>$ <span>expr</span> <span>3.5</span> + <span>2</span>
expr: 非整数参数
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>上面例子中，如果有非整数的运算，<code>expr</code> 命令就报错了。</p>
]]></content>
    <author>
      <name>阮一峰</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>阮一峰</name>
    </contributor>
    <rights>本教程采用&lt;a href="https://creativecommons.org/licenses/by-sa/3.0/deed.zh"&gt;知识共享 署名-相同方式共享 3.0协议&lt;/a&gt;</rights>
  </entry>
  <entry>
    <title type="html">数组</title>
    <id>http://qiqi.dreamagain.top/software/linux/bash/array/</id>
    <link href="http://qiqi.dreamagain.top/software/linux/bash/array/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <summary type="html"><![CDATA[<p>数组(array)是一个包含多个值的变量。成员的编号从 0 开始，数量没有上限，也没有要求成员被连续索引。</p>
]]></summary>
    <content type="html"><![CDATA[<p>数组(array)是一个包含多个值的变量。成员的编号从 0 开始，数量没有上限，也没有要求成员被连续索引。</p>

<h2 id="创建数组"> 创建数组</h2>
<p>数组可以采用逐个赋值的方法创建。</p>
<div><pre><code>ARRAY<span>[</span>INDEX<span>]</span><span>=</span>value
</code></pre>
<div><span>1</span><br></div></div><p>上面语法中，<code>ARRAY</code> 是数组的名字，可以是任意合法的变量名。<code>INDEX</code> 是一个大于或等于零的整数，也可以是算术表达式。注意数组第一个元素的下标是 0， 而不是 1。</p>
<p>下面创建一个三个成员的数组。</p>
<div><pre><code>array<span>[</span><span>0</span><span>]</span><span>=</span>val
array<span>[</span><span>1</span><span>]</span><span>=</span>val
array<span>[</span><span>2</span><span>]</span><span>=</span>val
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>数组也可以采用一次性赋值的方式创建。</p>
<div><pre><code><span>ARRAY</span><span>=</span><span>(</span>value1 value2 <span>..</span>. valueN<span>)</span>

<span># 等同于</span>

<span>ARRAY</span><span>=</span><span>(</span>
  value1
  value2
  value3
<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>采用上面方式创建数组时，可以按照默认顺序赋值，也可以在每个值前面指定位置。</p>
<div><pre><code><span>array</span><span>=</span><span>(</span>a b c<span>)</span>
<span>array</span><span>=</span><span>(</span><span>[</span><span>2</span><span>]</span><span>=</span>c <span>[</span><span>0</span><span>]</span><span>=</span>a <span>[</span><span>1</span><span>]</span><span>=</span>b<span>)</span>

<span>days</span><span>=</span><span>(</span>Sun Mon Tue Wed Thu Fri Sat<span>)</span>
<span>days</span><span>=</span><span>(</span><span>[</span><span>0</span><span>]</span><span>=</span>Sun <span>[</span><span>1</span><span>]</span><span>=</span>Mon <span>[</span><span>2</span><span>]</span><span>=</span>Tue <span>[</span><span>3</span><span>]</span><span>=</span>Wed <span>[</span><span>4</span><span>]</span><span>=</span>Thu <span>[</span><span>5</span><span>]</span><span>=</span>Fri <span>[</span><span>6</span><span>]</span><span>=</span>Sat<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>只为某些值指定位置，也是可以的。</p>
<div><pre><code><span>names</span><span>=</span><span>(</span>hatter <span>[</span><span>5</span><span>]</span><span>=</span>duchess alice<span>)</span>
</code></pre>
<div><span>1</span><br></div></div><p>上面例子中，<code>hatter</code> 是数组的 0 号位置，<code>duchess</code> 是 5 号位置，<code>alice</code> 是 6 号位置。</p>
<p>没有赋值的数组元素的默认值是空字符串。</p>
<p>定义数组的时候，可以使用通配符。</p>
<div><pre><code><span>mp3s</span><span>=</span><span>(</span> *.mp3 <span>)</span>
</code></pre>
<div><span>1</span><br></div></div><p>上面例子中，将当前目录的所有 MP3 文件，放进一个数组。</p>
<p>先用 <code>declare -a</code> 命令声明一个数组，也是可以的。</p>
<div><pre><code><span>declare</span> -a ARRAYNAME
</code></pre>
<div><span>1</span><br></div></div><p><code>read -a</code> 命令则是将用户的命令行输入，读入一个数组。</p>
<div><pre><code><span>read</span> -a dice
</code></pre>
<div><span>1</span><br></div></div><p>上面命令将用户的命令行输入，读入数组 <code>dice</code>。</p>
<h2 id="读取数组"> 读取数组</h2>
<h3 id="读取单个元素"> 读取单个元素</h3>
<p>读取数组指定位置的成员，要使用下面的语法。</p>
<div><pre><code><span>echo</span> <span>${array<span>[</span>i<span>]</span>}</span>     <span># i 是索引</span>
</code></pre>
<div><span>1</span><br></div></div><p>上面语法里面的大括号是必不可少的，否则 Bash 会把索引部分 <code>[i]</code> 按照原样输出。</p>
<div><pre><code>$ array<span>[</span><span>0</span><span>]</span><span>=</span>a

$ <span>echo</span> <span>${array<span>[</span>0<span>]</span>}</span>
a

$ <span>echo</span> <span>$array</span><span>[</span><span>0</span><span>]</span>
a<span>[</span><span>0</span><span>]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>上面例子中，数组的第一个元素是 <code>a</code>。如果不加大括号，Bash 会直接读取 <code>$array</code> 首成员的值，然后将 <code>[0]</code> 按照原样输出。</p>
<h3 id="读取所有成员"> 读取所有成员</h3>
<p><code>@</code> 和 <code>*</code> 是数组的特殊索引，表示返回数组的所有成员。</p>
<div><pre><code>$ <span>foo</span><span>=</span><span>(</span>a b c d e f<span>)</span>
$ <span>echo</span> <span>${foo<span>[</span>@<span>]</span>}</span>
a b c d e f
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>这两个特殊索引配合 <code>for</code> 循环，就可以用来遍历数组。</p>
<div><pre><code><span>for</span> <span>i</span> <span>in</span> <span>"<span>${names<span>[</span>@<span>]</span>}</span>"</span><span>;</span> <span>do</span>
  <span>echo</span> <span>$i</span>
<span>done</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><code>@</code> 和 <code>*</code> 放不放在双引号之中，是有差别的。</p>
<div><pre><code>$ <span>activities</span><span>=</span><span>(</span> swimming <span>"water skiing"</span> canoeing <span>"white-water rafting"</span> surfing <span>)</span>
$ <span>for</span> <span>act</span> <span>in</span> <span>${activities<span>[</span>@<span>]</span>}</span><span>;</span> <span>\</span>
<span>do</span> <span>\</span>
<span>echo</span> <span>"Activity: <span>$act</span>"</span><span>;</span> <span>\</span>
<span>done</span>

Activity: swimming
Activity: water
Activity: skiing
Activity: canoeing
Activity: white-water
Activity: rafting
Activity: surfing
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>上面的例子中，数组 <code>activities</code> 实际包含 5 个元素，但是 <code>for...in</code> 循环直接遍历 <code>${activities[@]}</code>，会导致返回 7 个结果。为了避免这种情况，一般把 <code>${activities[@]}</code> 放在双引号之中。</p>
<div><pre><code>$ <span>for</span> <span>act</span> <span>in</span> <span>"<span>${activities<span>[</span>@<span>]</span>}</span>"</span><span>;</span> <span>\</span>
<span>do</span> <span>\</span>
<span>echo</span> <span>"Activity: <span>$act</span>"</span><span>;</span> <span>\</span>
<span>done</span>

Activity: swimming
Activity: water skiing
Activity: canoeing
Activity: white-water rafting
Activity: surfing
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>上面例子中，<code>${activities[@]}</code> 放在双引号之中，遍历就会返回正确的结果。</p>
<p><code>${activities[*]}</code> 不放在双引号之中，跟 <code>${activities[@]}</code> 不放在双引号之中是一样的。</p>
<div><pre><code>$ <span>for</span> <span>act</span> <span>in</span> <span>${activities<span>[</span>*<span>]</span>}</span><span>;</span> <span>\</span>
<span>do</span> <span>\</span>
<span>echo</span> <span>"Activity: <span>$act</span>"</span><span>;</span> <span>\</span>
<span>done</span>

Activity: swimming
Activity: water
Activity: skiing
Activity: canoeing
Activity: white-water
Activity: rafting
Activity: surfing
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p><code>${activities[*]}</code> 放在双引号之中，所有元素就会变成单个字符串返回。</p>
<div><pre><code>$ <span>for</span> <span>act</span> <span>in</span> <span>"<span>${activities<span>[</span>*<span>]</span>}</span>"</span><span>;</span> <span>\</span>
<span>do</span> <span>\</span>
<span>echo</span> <span>"Activity: <span>$act</span>"</span><span>;</span> <span>\</span>
<span>done</span>

Activity: swimming water skiing canoeing white-water rafting surfing
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>所以，拷贝一个数组的最方便方法，就是写成下面这样。</p>
<div><pre><code><span>hobbies</span><span>=</span><span>(</span> <span>"<span>${activities<span>[</span>@<span>]</span>}</span>"</span> <span>)</span>
</code></pre>
<div><span>1</span><br></div></div><p>上面例子中，数组 <code>activities</code> 被拷贝给了另一个数组 <code>hobbies</code>。</p>
<p>这种写法也可以用来为新数组添加成员。</p>
<div><pre><code><span>hobbies</span><span>=</span><span>(</span> <span>"${activities[@]"</span> diving <span>)</span>
</code></pre>
<div><span>1</span><br></div></div><p>上面例子中，新数组 <code>hobbies</code> 在数组 <code>activities</code> 的所有成员之后，又添加了一个成员。</p>
<h3 id="默认位置"> 默认位置</h3>
<p>如果读取数组成员时，没有读取指定哪一个位置的成员，默认使用 <code>0</code> 号位置。</p>
<div><pre><code>$ <span>declare</span> -a foo
$ <span>foo</span><span>=</span>A
$ <span>echo</span> <span>${foo<span>[</span>0<span>]</span>}</span>
A
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>上面例子中，<code>foo</code> 是一个数组，赋值的时候不指定位置，实际上是给 <code>foo[0]</code> 赋值。</p>
<p>引用一个不带下标的数组变量，则引用的是 <code>0</code> 号位置的数组元素。</p>
<div><pre><code>$ <span>foo</span><span>=</span><span>(</span>a b c d e f<span>)</span>
$ <span>echo</span> <span>${foo}</span>
a
$ <span>echo</span> <span>$foo</span>
a
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>上面例子中，引用数组元素的时候，没有指定位置，结果返回的是 <code>0</code> 号位置。</p>
<h2 id="数组的长度"> 数组的长度</h2>
<p>要想知道数组的长度(即一共包含多少成员)，可以使用下面两种语法。</p>
<div><pre><code><span>${<span>#</span>array<span>[</span>*<span>]</span>}</span>
<span>${<span>#</span>array<span>[</span>@<span>]</span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>下面是一个例子。</p>
<div><pre><code>$ a<span>[</span><span>100</span><span>]</span><span>=</span>foo

$ <span>echo</span> <span>${<span>#</span>a<span>[</span>*<span>]</span>}</span>
<span>1</span>

$ <span>echo</span> <span>${<span>#</span>a<span>[</span>@<span>]</span>}</span>
<span>1</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>上面例子中，把字符串赋值给 <code>100</code> 位置的数组元素，这时的数组只有一个元素。</p>
<p>注意，如果用这种语法去读取具体的数组成员，就会返回该成员的字符串长度。这一点必须小心。</p>
<div><pre><code>$ a<span>[</span><span>100</span><span>]</span><span>=</span>foo
$ <span>echo</span> <span>${<span>#</span>a<span>[</span>100<span>]</span>}</span>
<span>3</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>上面例子中，<code>${#a[100]}</code> 实际上是返回数组第 100 号成员 <code>a[100]</code> 的值(<code>foo</code>)的字符串长度。</p>
<h2 id="提取数组序号"> 提取数组序号</h2>
<p><code>${!array[@]}</code> 或 <code>${!array[*]}</code>，可以返回数组的成员序号，即哪些位置是有值的。</p>
<div><pre><code>$ <span>arr</span><span>=</span><span>(</span><span>[</span><span>5</span><span>]</span><span>=</span>a <span>[</span><span>9</span><span>]</span><span>=</span>b <span>[</span><span>23</span><span>]</span><span>=</span>c<span>)</span>
$ <span>echo</span> <span>${<span>!</span>arr<span>[</span>@<span>]</span>}</span>
<span>5</span> <span>9</span> <span>23</span>
$ <span>echo</span> <span>${<span>!</span>arr<span>[</span>*<span>]</span>}</span>
<span>5</span> <span>9</span> <span>23</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>上面例子中，数组的 5、9、23 号位置有值。</p>
<p>利用这个语法，也可以通过 <code>for</code> 循环遍历数组。</p>
<div><pre><code><span>arr</span><span>=</span><span>(</span>a b c d<span>)</span>

<span>for</span> <span>i</span> <span>in</span> <span>${<span>!</span>arr<span>[</span>@<span>]</span>}</span><span>;</span><span>do</span>
  <span>echo</span> <span>${arr<span>[</span>i<span>]</span>}</span>
<span>done</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h2 id="提取数组成员"> 提取数组成员</h2>
<p><code>${array[@]:position:length}</code> 的语法可以提取数组成员。</p>
<div><pre><code>$ <span>food</span><span>=</span><span>(</span> apples bananas cucumbers dates eggs fajitas grapes <span>)</span>
$ <span>echo</span> <span>${food<span>[</span>@<span>]</span><span>:</span>1<span>:</span>1}</span>
bananas
$ <span>echo</span> <span>${food<span>[</span>@<span>]</span><span>:</span>1<span>:</span>3}</span>
bananas cucumbers dates
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>上面例子中，<code>${food[@]:1:1}</code> 返回从数组 1 号位置开始的 1 个成员，<code>${food[@]:1:3}</code> 返回从 1 号位置开始的 3 个成员。</p>
<p>如果省略长度参数 <code>length</code>，则返回从指定位置开始的所有成员。</p>
<div><pre><code>$ <span>echo</span> <span>${food<span>[</span>@<span>]</span><span>:</span>4}</span>
eggs fajitas grapes
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>上面例子返回从 4 号位置开始到结束的所有成员。</p>
<h2 id="追加数组成员"> 追加数组成员</h2>
<p>数组末尾追加成员，可以使用 <code>+=</code> 赋值运算符。它能够自动地把值追加到数组末尾。否则，就需要知道数组的最大序号，比较麻烦。</p>
<div><pre><code>$ <span>foo</span><span>=</span><span>(</span>a b c<span>)</span>
$ <span>echo</span> <span>${foo<span>[</span>@<span>]</span>}</span>
a b c

$ <span>foo</span><span>+=</span><span>(</span>d e f<span>)</span>
$ <span>echo</span> <span>${foo<span>[</span>@<span>]</span>}</span>
a b c d e f
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h2 id="删除数组"> 删除数组</h2>
<p>删除一个数组成员，使用 <code>unset</code> 命令。</p>
<div><pre><code>$ <span>foo</span><span>=</span><span>(</span>a b c d e f<span>)</span>
$ <span>echo</span> <span>${foo<span>[</span>@<span>]</span>}</span>
a b c d e f

$ <span>unset</span> foo<span>[</span><span>2</span><span>]</span>
$ <span>echo</span> <span>${foo<span>[</span>@<span>]</span>}</span>
a b d e f
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>上面例子中，删除了数组中的第三个元素，下标为 2。</p>
<p>删除成员也可以将这个成员设为空值。</p>
<div><pre><code>$ <span>foo</span><span>=</span><span>(</span>a b c d e f<span>)</span>
$ foo<span>[</span><span>1</span><span>]</span><span>=</span><span>''</span>
$ <span>echo</span> <span>${foo<span>[</span>@<span>]</span>}</span>
a c d e f
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>上面例子中，将数组的第二个成员设为空字符串，就删除了这个成员。</p>
<p>由于空值就是空字符串，所以下面这样写也可以，但是不建议这种写法。</p>
<div><pre><code>foo<span>[</span><span>1</span><span>]</span><span>=</span>
</code></pre>
<div><span>1</span><br></div></div><p>上面的写法也相当于删除了数组的第二个成员。</p>
<p>直接将数组变量赋值为空字符串，相当于删除数组的第一个成员。</p>
<div><pre><code>$ <span>foo</span><span>=</span><span>(</span>a b c d e f<span>)</span>
$ <span>foo</span><span>=</span><span>''</span>
$ <span>echo</span> <span>${foo<span>[</span>@<span>]</span>}</span>
b c d e f
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>上面的写法相当于删除了数组的第一个成员。</p>
<p><code>unset ArrayName</code> 可以清空整个数组。</p>
<div><pre><code>$ <span>unset</span> ARRAY

$ <span>echo</span> <span>${ARRAY<span>[</span>*<span>]</span>}</span>
<span>&lt;</span>--no output--<span>></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h2 id="关联数组"> 关联数组</h2>
<p>Bash 的新版本支持关联数组。关联数组使用字符串而不是整数作为数组索引。</p>
<p><code>declare -A</code> 可以声明关联数组。</p>
<div><pre><code><span>declare</span> -A colors
colors<span>[</span><span>"red"</span><span>]</span><span>=</span><span>"#ff0000"</span>
colors<span>[</span><span>"green"</span><span>]</span><span>=</span><span>"#00ff00"</span>
colors<span>[</span><span>"blue"</span><span>]</span><span>=</span><span>"#0000ff"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>整数索引的数组，可以直接使用变量名创建数组，关联数组则必须用带有 <code>-A</code> 选项的 <code>declare</code> 命令声明创建。</p>
<p>访问关联数组成员的方式，几乎与整数索引数组相同。</p>
<div><pre><code><span>echo</span> <span>${colors<span>[</span>"blue"<span>]</span>}</span>
</code></pre>
<div><span>1</span><br></div></div>]]></content>
    <author>
      <name>阮一峰</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>阮一峰</name>
    </contributor>
    <rights>本教程采用&lt;a href="https://creativecommons.org/licenses/by-sa/3.0/deed.zh"&gt;知识共享 署名-相同方式共享 3.0协议&lt;/a&gt;</rights>
  </entry>
  <entry>
    <title type="html">条件判断</title>
    <id>http://qiqi.dreamagain.top/software/linux/bash/condition/</id>
    <link href="http://qiqi.dreamagain.top/software/linux/bash/condition/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <summary type="html"><![CDATA[<p>本章介绍 Bash 脚本的条件判断语法。</p>
]]></summary>
    <content type="html"><![CDATA[<p>本章介绍 Bash 脚本的条件判断语法。</p>

<h2 id="if-结构"> if 结构</h2>
<p><code>if</code> 是最常用的条件判断结构，只有符合给定条件时，才会执行指定的命令。它的语法如下。</p>
<div><pre><code><span>if</span> commands<span>;</span> <span>then</span>
  commands
<span>[</span>elif commands<span>;</span> <span>then</span>
  commands<span>..</span>.<span>]</span>
<span>[</span>else
  commands<span>]</span>
<span>fi</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>这个命令分成三个部分: <code>if</code>、<code>elif</code> 和 <code>else</code>。其中，后两个部分是可选的。</p>
<p><code>if</code> 关键字后面是主要的判断条件，<code>elif</code> 用来添加在主条件不成立时的其他判断条件，<code>else</code> 则是所有条件都不成立时要执行的部分。</p>
<div><pre><code><span>if</span> <span>test</span> <span>$USER</span> <span>=</span> <span>"foo"</span><span>;</span> <span>then</span>
  <span>echo</span> <span>"Hello foo."</span>
<span>else</span>
  <span>echo</span> <span>"You are not foo."</span>
<span>fi</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>上面的例子中，判断条件是环境变量 <code>$USER</code> 是否等于 <code>foo</code>，如果等于就输出 <code>Hello foo.</code>，否则输出其他内容。</p>
<p><code>if</code> 和 <code>then</code> 写在同一行时，需要分号分隔。分号是 Bash 的命令分隔符。它们也可以写成两行，这时不需要分号。</p>
<div><pre><code><span>if</span> <span>true</span>
<span>then</span>
  <span>echo</span> <span>'hello world'</span>
<span>fi</span>

<span>if</span> <span>false</span>
<span>then</span>
  <span>echo</span> <span>'it is false'</span> <span># 本行不会执行</span>
<span>fi</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>上面的例子中，<code>true</code> 和 <code>false</code> 是两个特殊命令，前者代表操作成功，后者代表操作失败。<code>if true</code> 意味着命令部分总是会执行，<code>if false</code> 意味着命令部分永远不会执行。</p>
<p>除了多行的写法，<code>if</code> 结构也可以写成单行。</p>
<div><pre><code>$ <span>if</span> <span>true</span><span>;</span> <span>then</span> <span>echo</span> <span>'hello world'</span><span>;</span> <span>fi</span>
hello world

$ <span>if</span> <span>false</span><span>;</span> <span>then</span> <span>echo</span> <span>"It's true."</span><span>;</span> <span>fi</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>注意，<code>if</code> 关键字后面也可以是一条命令，该条命令执行成功(返回值 <code>0</code>)，就意味着判断条件成立。</p>
<div><pre><code>$ <span>if</span> <span>echo</span> <span>'hi'</span><span>;</span> <span>then</span> <span>echo</span> <span>'hello world'</span><span>;</span> <span>fi</span>
hi
hello world
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>上面命令中，<code>if</code> 后面是一条命令 <code>echo 'hi'</code>。该命令会执行，如果返回值是 <code>0</code>，则执行 <code>then</code> 的部分。</p>
<p><code>if</code> 后面可以跟任意数量的命令。这时，所有命令都会执行，但是判断真伪只看最后一个命令，即使前面所有命令都失败，只要最后一个命令返回 <code>0</code>，就会执行 <code>then</code> 的部分。</p>
<div><pre><code>$ <span>if</span> <span>false</span><span>;</span> <span>true</span><span>;</span> <span>then</span> <span>echo</span> <span>'hello world'</span><span>;</span> <span>fi</span>
hello world
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>上面例子中，<code>if</code> 后面有两条命令 (<code>false;true;</code>)，第二条命令 (<code>true</code>) 决定了 <code>then</code> 的部分是否会执行。</p>
<p><code>elif</code> 部分可以有多个。</p>
<div><pre><code><span>#!/bin/bash</span>

<span>echo</span> -n <span>"输入一个 1 到 3 之间的数字(包含两端)> "</span>
<span>read</span> character
<span>if</span> <span>[</span> <span>"<span>$character</span>"</span> <span>=</span> <span>"1"</span> <span>]</span><span>;</span> <span>then</span>
    <span>echo</span> <span>1</span>
<span>elif</span> <span>[</span> <span>"<span>$character</span>"</span> <span>=</span> <span>"2"</span> <span>]</span><span>;</span> <span>then</span>
    <span>echo</span> <span>2</span>
<span>elif</span> <span>[</span> <span>"<span>$character</span>"</span> <span>=</span> <span>"3"</span> <span>]</span><span>;</span> <span>then</span>
    <span>echo</span> <span>3</span>
<span>else</span>
    <span>echo</span> 输入不符合要求
<span>fi</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>上面例子中，如果用户输入 <code>3</code>，就会连续判断 3 次。</p>
<h2 id="test-命令"> test 命令</h2>
<p><code>if</code> 结构的判断条件，一般使用 <code>test</code> 命令，有三种形式。</p>
<div><pre><code><span># 写法一</span>
<span>test</span> expression

<span># 写法二</span>
<span>[</span> expression <span>]</span>

<span># 写法三</span>
<span>[</span><span>[</span> expression <span>]</span><span>]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>上面三种形式是等价的，但是第三种形式还支持正则判断，前两种不支持。</p>
<p>上面的 <code>expression</code> 是一个表达式。这个表达式为真，<code>test</code> 命令执行成功(返回值为 <code>0</code>)；表达式为伪，<code>test</code> 命令执行失败(返回值为 <code>1</code>)。注意，第二种和第三种写法，<code>[</code> 和 <code>]</code> 与内部的表达式之间必须有空格。</p>
<div><pre><code>$ <span>test</span> -f /etc/hosts
$ <span>echo</span> <span>$?</span>
<span>0</span>

$ <span>[</span> -f /etc/hosts <span>]</span>
$  <span>echo</span> <span>$?</span>
<span>0</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>上面的例子中，<code>test</code> 命令采用两种写法，判断 <code>/etc/hosts</code> 文件是否存在，这两种写法是等价的。命令执行后，返回值为 <code>0</code>，表示该文件确实存在。</p>
<p>实际上，<code>[</code> 这个字符是 <code>test</code> 命令的一种简写形式，可以看作是一个独立的命令，这解释了为什么它后面必须有空格。</p>
<p>下面把 <code>test</code> 命令的三种形式，用在 <code>if</code> 结构中，判断一个文件是否存在。</p>
<div><pre><code><span># 写法一</span>
<span>if</span> <span>test</span> -e /tmp/foo.txt <span>;</span> <span>then</span>
  <span>echo</span> <span>"Found foo.txt"</span>
<span>fi</span>

<span># 写法二</span>
<span>if</span> <span>[</span> -e /tmp/foo.txt <span>]</span> <span>;</span> <span>then</span>
  <span>echo</span> <span>"Found foo.txt"</span>
<span>fi</span>

<span># 写法三</span>
<span>if</span> <span>[</span><span>[</span> -e /tmp/foo.txt <span>]</span><span>]</span> <span>;</span> <span>then</span>
  <span>echo</span> <span>"Found foo.txt"</span>
<span>fi</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><h2 id="判断表达式"> 判断表达式</h2>
<p><code>if</code> 关键字后面，跟的是一个命令。这个命令可以是 <code>test</code> 命令，也可以是其他命令。命令的返回值为 <code>0</code> 表示判断成立，否则表示不成立。因为这些命令主要是为了得到返回值，所以可以视为表达式。</p>
<p>常用的判断表达式有下面这些。</p>
<h3 id="文件判断"> 文件判断</h3>
<p>以下表达式用来判断文件状态。</p>
<ul>
<li><code>[ -a file ]</code>: 如果 file 存在，则为 <code>true</code>。</li>
<li><code>[ -b file ]</code>: 如果 file 存在并且是一个块(设备)文件，则为 <code>true</code>。</li>
<li><code>[ -c file ]</code>: 如果 file 存在并且是一个字符(设备)文件，则为 <code>true</code>。</li>
<li><code>[ -d file ]</code>: 如果 file 存在并且是一个目录，则为 <code>true</code>。</li>
<li><code>[ -e file ]</code>: 如果 file 存在，则为 <code>true</code>。</li>
<li><code>[ -f file ]</code>: 如果 file 存在并且是一个普通文件，则为 <code>true</code>。</li>
<li><code>[ -g file ]</code>: 如果 file 存在并且设置了组 ID，则为 <code>true</code>。</li>
<li><code>[ -G file ]</code>: 如果 file 存在并且属于有效的组 ID，则为 <code>true</code>。</li>
<li><code>[ -h file ]</code>: 如果 file 存在并且是符号链接，则为 <code>true</code>。</li>
<li><code>[ -k file ]</code>: 如果 file 存在并且设置了它的“sticky bit”，则为 <code>true</code>。</li>
<li><code>[ -L file ]</code>: 如果 file 存在并且是一个符号链接，则为 <code>true</code>。</li>
<li><code>[ -N file ]</code>: 如果 file 存在并且自上次读取后已被修改，则为 <code>true</code>。</li>
<li><code>[ -O file ]</code>: 如果 file 存在并且属于有效的用户 ID，则为 <code>true</code>。</li>
<li><code>[ -p file ]</code>: 如果 file 存在并且是一个命名管道，则为 <code>true</code>。</li>
<li><code>[ -r file ]</code>: 如果 file 存在并且可读(当前用户有可读权限)，则为 <code>true</code>。</li>
<li><code>[ -s file ]</code>: 如果 file 存在且其长度大于零，则为 <code>true</code>。</li>
<li><code>[ -S file ]</code>: 如果 file 存在且是一个网络 socket，则为 <code>true</code>。</li>
<li><code>[ -t fd ]</code>: 如果 fd 是一个文件描述符，并且重定向到终端，则为 <code>true</code>。这可以用来判断是否重定向了标准输入／输出错误。</li>
<li><code>[ -u file ]</code>: 如果 file 存在并且设置了 setuid 位，则为 <code>true</code>。</li>
<li><code>[ -w file ]</code>: 如果 file 存在并且可写(当前用户拥有可写权限)，则为 <code>true</code>。</li>
<li><code>[ -x file ]</code>: 如果 file 存在并且可执行(有效用户有执行／搜索权限)，则为 <code>true</code>。</li>
<li><code>[ file1 -nt file2 ]</code>: 如果 FILE1 比 FILE2 的更新时间最近，或者 FILE1 存在而 FILE2 不存在，则为 <code>true</code>。</li>
<li><code>[ file1 -ot file2 ]</code>: 如果 FILE1 比 FILE2 的更新时间更旧，或者 FILE2 存在而 FILE1 不存在，则为 <code>true</code>。</li>
<li><code>[ FILE1 -ef FILE2 ]</code>: 如果 FILE1 和 FILE2 引用相同的设备和 inode 编号，则为 <code>true</code>。</li>
</ul>
<p>下面是一个示例。</p>
<div><pre><code><span>#!/bin/bash</span>

<span>FILE</span><span>=</span>~/.bashrc

<span>if</span> <span>[</span> -e <span>"<span>$FILE</span>"</span> <span>]</span><span>;</span> <span>then</span>
  <span>if</span> <span>[</span> -f <span>"<span>$FILE</span>"</span> <span>]</span><span>;</span> <span>then</span>
    <span>echo</span> <span>"<span>$FILE</span> is a regular file."</span>
  <span>fi</span>
  <span>if</span> <span>[</span> -d <span>"<span>$FILE</span>"</span> <span>]</span><span>;</span> <span>then</span>
    <span>echo</span> <span>"<span>$FILE</span> is a directory."</span>
  <span>fi</span>
  <span>if</span> <span>[</span> -r <span>"<span>$FILE</span>"</span> <span>]</span><span>;</span> <span>then</span>
    <span>echo</span> <span>"<span>$FILE</span> is readable."</span>
  <span>fi</span>
  <span>if</span> <span>[</span> -w <span>"<span>$FILE</span>"</span> <span>]</span><span>;</span> <span>then</span>
    <span>echo</span> <span>"<span>$FILE</span> is writable."</span>
  <span>fi</span>
  <span>if</span> <span>[</span> -x <span>"<span>$FILE</span>"</span> <span>]</span><span>;</span> <span>then</span>
    <span>echo</span> <span>"<span>$FILE</span> is executable/searchable."</span>
  <span>fi</span>
<span>else</span>
  <span>echo</span> <span>"<span>$FILE</span> does not exist"</span>
  <span>exit</span> <span>1</span>
<span>fi</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><p>上面代码中，<code>$FILE</code> 要放在双引号之中。这样可以防止 <code>$FILE</code> 为空，因为这时 <code>[ -e ]</code> 会判断为真。而放在双引号之中，返回的就总是一个空字符串，<code>[ -e &quot;&quot; ]</code> 会判断为伪。</p>
<h3 id="字符串判断"> 字符串判断</h3>
<p>以下表达式用来判断字符串。</p>
<ul>
<li><code>[ string ]</code>: 如果 <code>string</code> 不为空(长度大于 0)，则判断为真。</li>
<li><code>[ -n string ]</code>: 如果字符串 <code>string</code> 的长度大于零，则判断为真。</li>
<li><code>[ -z string ]</code>: 如果字符串 <code>string</code> 的长度为零，则判断为真。</li>
<li><code>[ string1 = string2 ]</code>: 如果 <code>string1</code> 和 <code>string2</code> 相同，则判断为真。</li>
<li><code>[ string1 == string2 ]</code> 等同于 <code>[ string1 = string2 ]</code>。</li>
<li><code>[ string1 != string2 ]</code>: 如果 <code>string1</code> 和 <code>string2</code> 不相同，则判断为真。</li>
<li><code>[ string1 '&gt;' string2 ]</code>: 如果按照字典顺序 <code>string1</code> 排列在 <code>string2</code> 之后，则判断为真。</li>
<li><code>[ string1 '&lt;' string2 ]</code>: 如果按照字典顺序 <code>string1</code> 排列在 <code>string2</code> 之前，则判断为真。</li>
</ul>
<p>注意，<code>test</code> 命令内部的 <code>&gt;</code> 和 <code>&lt;</code>，必须用引号引起来(或者是用反斜杠转义)。否则，它们会被 shell 解释为重定向操作符。</p>
<p>下面是一个示例。</p>
<div><pre><code><span>#!/bin/bash</span>

<span>ANSWER</span><span>=</span>maybe

<span>if</span> <span>[</span> -z <span>"<span>$ANSWER</span>"</span> <span>]</span><span>;</span> <span>then</span>
  <span>echo</span> <span>"There is no answer."</span> <span>></span><span>&amp;2</span>
  <span>exit</span> <span>1</span>
<span>fi</span>
<span>if</span> <span>[</span> <span>"<span>$ANSWER</span>"</span> <span>=</span> <span>"yes"</span> <span>]</span><span>;</span> <span>then</span>
  <span>echo</span> <span>"The answer is YES."</span>
<span>elif</span> <span>[</span> <span>"<span>$ANSWER</span>"</span> <span>=</span> <span>"no"</span> <span>]</span><span>;</span> <span>then</span>
  <span>echo</span> <span>"The answer is NO."</span>
<span>elif</span> <span>[</span> <span>"<span>$ANSWER</span>"</span> <span>=</span> <span>"maybe"</span> <span>]</span><span>;</span> <span>then</span>
  <span>echo</span> <span>"The answer is MAYBE."</span>
<span>else</span>
  <span>echo</span> <span>"The answer is UNKNOWN."</span>
<span>fi</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p>上面代码中，首先确定 <code>$ANSWER</code> 字符串是否为空。如果为空，就终止脚本，并把退出状态设为 <code>1</code>。注意，这里的 <code>echo</code> 命令把错误信息 <code>There is no answer.</code> 重定向到标准错误，这是处理错误信息的常用方法。如果 <code>$ANSWER</code> 字符串不为空，就判断它的值是否等于 <code>yes</code>、<code>no</code> 或者 <code>maybe</code>。</p>
<p>注意，字符串判断时，变量要放在双引号之中，比如 <code>[ -n &quot;$COUNT&quot; ]</code>，否则变量替换成字符串以后，<code>test</code> 命令可能会报错，提示参数过多。另外，如果不放在双引号之中，变量为空时，命令会变成 <code>[ -n ]</code>，这时会判断为真。如果放在双引号之中，<code>[ -n &quot;&quot; ]</code> 就判断为伪。</p>
<h3 id="整数判断"> 整数判断</h3>
<p>下面的表达式用于判断整数。</p>
<ul>
<li><code>[ integer1 -eq integer2 ]</code>: 如果 <code>integer1</code> 等于 <code>integer2</code>，则为 <code>true</code>。</li>
<li><code>[ integer1 -ne integer2 ]</code>: 如果 <code>integer1</code> 不等于 <code>integer2</code>，则为 <code>true</code>。</li>
<li><code>[ integer1 -le integer2 ]</code>: 如果 <code>integer1</code> 小于或等于 <code>integer2</code>，则为 <code>true</code>。</li>
<li><code>[ integer1 -lt integer2 ]</code>: 如果 <code>integer1</code> 小于 <code>integer2</code>，则为 <code>true</code>。</li>
<li><code>[ integer1 -ge integer2 ]</code>: 如果 <code>integer1</code> 大于或等于 <code>integer2</code>，则为 <code>true</code>。</li>
<li><code>[ integer1 -gt integer2 ]</code>: 如果 <code>integer1</code> 大于 <code>integer2</code>，则为 <code>true</code>。</li>
</ul>
<p>下面是一个用法的例子。</p>
<div><pre><code><span>#!/bin/bash</span>

<span>INT</span><span>=</span>-5

<span>if</span> <span>[</span> -z <span>"<span>$INT</span>"</span> <span>]</span><span>;</span> <span>then</span>
  <span>echo</span> <span>"INT is empty."</span> <span>></span><span>&amp;2</span>
  <span>exit</span> <span>1</span>
<span>fi</span>
<span>if</span> <span>[</span> <span>$INT</span> -eq <span>0</span> <span>]</span><span>;</span> <span>then</span>
  <span>echo</span> <span>"INT is zero."</span>
<span>else</span>
  <span>if</span> <span>[</span> <span>$INT</span> -lt <span>0</span> <span>]</span><span>;</span> <span>then</span>
    <span>echo</span> <span>"INT is negative."</span>
  <span>else</span>
    <span>echo</span> <span>"INT is positive."</span>
  <span>fi</span>
  <span>if</span> <span>[</span> <span><span>$((</span>INT <span>%</span> <span>2</span><span>))</span></span> -eq <span>0</span> <span>]</span><span>;</span> <span>then</span>
    <span>echo</span> <span>"INT is even."</span>
  <span>else</span>
    <span>echo</span> <span>"INT is odd."</span>
  <span>fi</span>
<span>fi</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><p>上面例子中，先判断变量 <code>$INT</code> 是否为空，然后判断是否为 <code>0</code>，接着判断正负，最后通过求余数判断奇偶。</p>
<h3 id="正则判断"> 正则判断</h3>
<p><code>[[ expression ]]</code> 这种判断形式，支持正则表达式。</p>
<div><pre><code><span>[</span><span>[</span> string1 <span>=</span>~ regex <span>]</span><span>]</span>
</code></pre>
<div><span>1</span><br></div></div><p>上面的语法中，<code>regex</code> 是一个正则表示式，<code>=~</code> 是正则比较运算符。</p>
<p>下面是一个例子。</p>
<div><pre><code><span>#!/bin/bash</span>

<span>INT</span><span>=</span>-5

<span>if</span> <span>[</span><span>[</span> <span>"<span>$INT</span>"</span> <span>=</span>~ ^-?<span>[</span><span>0</span>-9<span>]</span>+$ <span>]</span><span>]</span><span>;</span> <span>then</span>
  <span>echo</span> <span>"INT is an integer."</span>
  <span>exit</span> <span>0</span>
<span>else</span>
  <span>echo</span> <span>"INT is not an integer."</span> <span>></span><span>&amp;2</span>
  <span>exit</span> <span>1</span>
<span>fi</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>上面代码中，先判断变量 <code>INT</code> 的字符串形式，是否满足 <code>^-?[0-9]+$</code> 的正则模式，如果满足就表明它是一个整数。</p>
<h3 id="test-判断的逻辑运算"> test 判断的逻辑运算</h3>
<p>通过逻辑运算，可以把多个 <code>test</code> 判断表达式结合起来，创造更复杂的判断。三种逻辑运算 <code>AND</code>，<code>OR</code>，和 <code>NOT</code>，都有自己的专用符号。</p>
<ul>
<li><code>AND</code> 运算: 符号 <code>&amp;&amp;</code>，也可使用参数 <code>-a</code>。</li>
<li><code>OR</code> 运算: 符号 <code>||</code>，也可使用参数 <code>-o</code>。</li>
<li><code>NOT</code> 运算: 符号 <code>!</code>。</li>
</ul>
<p>下面是一个 <code>AND</code> 的例子，判断整数是否在某个范围之内。</p>
<div><pre><code><span>#!/bin/bash</span>

<span>MIN_VAL</span><span>=</span><span>1</span>
<span>MAX_VAL</span><span>=</span><span>100</span>

<span>INT</span><span>=</span><span>50</span>

<span>if</span> <span>[</span><span>[</span> <span>"<span>$INT</span>"</span> <span>=</span>~ ^-?<span>[</span><span>0</span>-9<span>]</span>+$ <span>]</span><span>]</span><span>;</span> <span>then</span>
  <span>if</span> <span>[</span><span>[</span> <span>$INT</span> -ge <span>$MIN_VAL</span> <span>&amp;&amp;</span> <span>$INT</span> -le <span>$MAX_VAL</span> <span>]</span><span>]</span><span>;</span> <span>then</span>
    <span>echo</span> <span>"<span>$INT</span> is within <span>$MIN_VAL</span> to <span>$MAX_VAL</span>."</span>
  <span>else</span>
    <span>echo</span> <span>"<span>$INT</span> is out of range."</span>
  <span>fi</span>
<span>else</span>
  <span>echo</span> <span>"INT is not an integer."</span> <span>></span><span>&amp;2</span>
  <span>exit</span> <span>1</span>
<span>fi</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p>上面例子中，<code>&amp;&amp;</code> 用来连接两个判断条件: 大于等于 <code>$MIN_VAL</code>，并且小于等于 <code>$MAX_VAL</code>。</p>
<p>使用否定操作符 <code>!</code> 时，最好用圆括号确定转义的范围。</p>
<div><pre><code><span>if</span> <span>[</span> <span>!</span> <span>\</span><span>(</span> <span>$INT</span> -ge <span>$MIN_VAL</span> -a <span>$INT</span> -le <span>$MAX_VAL</span> <span>\</span><span>)</span> <span>]</span><span>;</span> <span>then</span>
    <span>echo</span> <span>"<span>$INT</span> is outside <span>$MIN_VAL</span> to <span>$MAX_VAL</span>."</span>
<span>else</span>
    <span>echo</span> <span>"<span>$INT</span> is in range."</span>
<span>fi</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>上面例子中，<code>test</code> 命令内部使用的圆括号，必须使用引号或者转义，否则会被 Bash 解释。</p>
<h3 id="算术判断"> 算术判断</h3>
<p>Bash 还提供了 <code>((...))</code> 作为算术条件，进行算术运算的判断。</p>
<div><pre><code><span>if</span> <span><span>((</span><span>3</span> <span>></span> <span>2</span><span>))</span></span><span>;</span> <span>then</span>
  <span>echo</span> <span>"true"</span>
<span>fi</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>上面代码执行后，会打印出 <code>true</code>。</p>
<p>注意，算术判断不需要使用 <code>test</code> 命令，而是直接使用 <code>((...))</code> 结构。这个结构的返回值，决定了判断的真伪。</p>
<p>如果算术计算的结果是非零值，则表示判断成立。这一点跟命令的返回值正好相反，需要小心。</p>
<div><pre><code>$ <span>if</span> <span><span>((</span><span>1</span><span>))</span></span><span>;</span> <span>then</span> <span>echo</span> <span>"It is true."</span><span>;</span> <span>fi</span>
It is true.
$ <span>if</span> <span><span>((</span><span>0</span><span>))</span></span><span>;</span> <span>then</span> <span>echo</span> <span>"It is true."</span><span>;</span> <span>else</span> <span>echo</span> <span>"it is false."</span><span>;</span> <span>fi</span>
It is false.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>上面例子中，<code>((1))</code> 表示判断成立，<code>((0))</code> 表示判断不成立。</p>
<p>算术条件 <code>((...))</code> 也可以用于变量赋值。</p>
<div><pre><code>$ <span>if</span> <span><span>((</span> foo <span>=</span> <span>5</span> <span>))</span></span><span>;</span><span>then</span> <span>echo</span> <span>"foo is <span>$foo</span>"</span><span>;</span> <span>fi</span>
foo is <span>5</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>上面例子中，<code>(( foo = 5 ))</code> 完成了两件事情。首先把 <code>5</code> 赋值给变量 <code>foo</code>，然后根据返回值 <code>5</code>，判断条件为真。</p>
<p>注意，赋值语句返回等号右边的值，如果返回的是 <code>0</code>，则判断为假。</p>
<div><pre><code>$ <span>if</span> <span><span>((</span> foo <span>=</span> <span>0</span> <span>))</span></span><span>;</span><span>then</span> <span>echo</span> <span>"It is true."</span><span>;</span><span>else</span> <span>echo</span> <span>"It is false."</span><span>;</span> <span>fi</span>
It is false.
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>下面是用算术条件改写的数值判断脚本。</p>
<div><pre><code><span>#!/bin/bash</span>

<span>INT</span><span>=</span>-5

<span>if</span> <span>[</span><span>[</span> <span>"<span>$INT</span>"</span> <span>=</span>~ ^-?<span>[</span><span>0</span>-9<span>]</span>+$ <span>]</span><span>]</span><span>;</span> <span>then</span>
  <span>if</span> <span><span>((</span>INT <span>==</span> <span>0</span><span>))</span></span><span>;</span> <span>then</span>
    <span>echo</span> <span>"INT is zero."</span>
  <span>else</span>
    <span>if</span> <span><span>((</span>INT <span>&lt;</span> <span>0</span><span>))</span></span><span>;</span> <span>then</span>
      <span>echo</span> <span>"INT is negative."</span>
    <span>else</span>
      <span>echo</span> <span>"INT is positive."</span>
    <span>fi</span>
    <span>if</span> <span><span>((</span> <span>((</span>INT <span>%</span> <span>2</span><span>))</span></span> <span>==</span> <span>0</span><span>))</span><span>;</span> <span>then</span>
      <span>echo</span> <span>"INT is even."</span>
    <span>else</span>
      <span>echo</span> <span>"INT is odd."</span>
    <span>fi</span>
  <span>fi</span>
<span>else</span>
  <span>echo</span> <span>"INT is not an integer."</span> <span>></span><span>&amp;2</span>
  <span>exit</span> <span>1</span>
<span>fi</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><p>只要是算术表达式，都能用于 <code>((...))</code> 语法，详见 <a href="./src/software/linux/bash/arithmetic.html">Bash 的算术运算</a> 一章。</p>
<h3 id="普通命令的逻辑运算"> 普通命令的逻辑运算</h3>
<p>如果 <code>if</code> 结构使用的不是 <code>test</code> 命令，而是普通命令，比如上一节的 <code>((...))</code> 算术运算，或者 <code>test</code> 命令与普通命令混用，那么可以使用 Bash 的命令控制操作符 <code>&amp;&amp;</code>(AND)和 <code>||</code>(OR)，进行多个命令的逻辑运算。</p>
<div><pre><code>command1 <span>&amp;&amp;</span> command2
command1 <span>||</span> command2
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>对于 <code>&amp;&amp;</code> 操作符，先执行 <code>command1</code>，只有 <code>command1</code> 执行成功后， 才会执行 <code>command2</code>。对于 <code>||</code> 操作符，先执行 <code>command1</code>，只有 <code>command1</code> 执行失败后， 才会执行 <code>command2</code>。</p>
<div><pre><code><span>mkdir</span> temp <span>&amp;&amp;</span> <span>cd</span> temp
</code></pre>
<div><span>1</span><br></div></div><p>上面的命令会创建一个名为 <code>temp</code> 的目录，执行成功后，才会执行第二个命令，进入这个目录。</p>
<div><pre><code><span>[</span> -d temp <span>]</span> <span>||</span> <span>mkdir</span> temp
</code></pre>
<div><span>1</span><br></div></div><p>上面的命令会测试目录 <code>temp</code> 是否存在，如果不存在，就会执行第二个命令，创建这个目录。这种写法非常有助于在脚本中处理错误。</p>
<div><pre><code><span>[</span> <span>!</span> -d temp <span>]</span> <span>&amp;&amp;</span> <span>exit</span> <span>1</span>
</code></pre>
<div><span>1</span><br></div></div><p>上面的命令中，如果 <code>temp</code> 子目录不存在，脚本会终止，并且返回值为 <code>1</code>。</p>
<p>下面就是 <code>if</code> 与 <code>&amp;&amp;</code> 结合使用的写法。</p>
<div><pre><code><span>if</span> <span>[</span> condition <span>]</span> <span>&amp;&amp;</span> <span>[</span> condition <span>]</span><span>;</span> <span>then</span>
  <span>command</span>
<span>fi</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>下面是一个示例。</p>
<div><pre><code><span>#! /bin/bash</span>

<span>filename</span><span>=</span><span>$1</span>
<span>word1</span><span>=</span><span>$2</span>
<span>word2</span><span>=</span><span>$3</span>

<span>if</span> <span>grep</span> <span>$word1</span> <span>$filename</span> <span>&amp;&amp;</span> <span>grep</span> <span>$word2</span> <span>$filename</span>
<span>then</span>
  <span>echo</span> <span>"<span>$word1</span> and <span>$word2</span> are both in <span>$filename</span>."</span>
<span>fi</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>上面的例子只有在指定文件里面，同时存在搜索词 <code>word1</code> 和 <code>word2</code>，就会执行 <code>if</code> 的命令部分。</p>
<p>下面的示例演示如何将一个 <code>&amp;&amp;</code> 判断表达式，改写成对应的 <code>if</code> 结构。</p>
<div><pre><code><span>[</span><span>[</span> -d <span>"<span>$dir_name</span>"</span> <span>]</span><span>]</span> <span>&amp;&amp;</span> <span>cd</span> <span>"<span>$dir_name</span>"</span> <span>&amp;&amp;</span> <span>rm</span> *

<span># 等同于</span>

<span>if</span> <span>[</span><span>[</span> <span>!</span> -d <span>"<span>$dir_name</span>"</span> <span>]</span><span>]</span><span>;</span> <span>then</span>
  <span>echo</span> <span>"No such directory: '<span>$dir_name</span>'"</span> <span>></span><span>&amp;2</span>
  <span>exit</span> <span>1</span>
<span>fi</span>
<span>if</span> <span>!</span> <span>cd</span> <span>"<span>$dir_name</span>"</span><span>;</span> <span>then</span>
  <span>echo</span> <span>"Cannot cd to '<span>$dir_name</span>'"</span> <span>></span><span>&amp;2</span>
  <span>exit</span> <span>1</span>
<span>fi</span>
<span>if</span> <span>!</span> <span>rm</span> *<span>;</span> <span>then</span>
  <span>echo</span> <span>"File deletion failed. Check results"</span> <span>></span><span>&amp;2</span>
  <span>exit</span> <span>1</span>
<span>fi</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><h2 id="case-结构"> case 结构</h2>
<p><code>case</code> 结构用于多值判断，可以为每个值指定对应的命令，跟包含多个 <code>elif</code> 的 <code>if</code> 结构等价，但是语义更好。它的语法如下。</p>
<div><pre><code><span>case</span> expression <span>in</span>
  pattern <span>)</span>
    commands <span>;</span><span>;</span>
  pattern <span>)</span>
    commands <span>;</span><span>;</span>
  <span>..</span>.
<span>esac</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>上面代码中，<code>expression</code> 是一个表达式，<code>pattern</code> 是表达式的值或者一个模式，可以有多条，用来匹配多个值，每条以两个分号 (<code>;</code>) 结尾。</p>
<div><pre><code><span>#!/bin/bash</span>

<span>echo</span> -n <span>"输入一个 1 到 3 之间的数字(包含两端)> "</span>
<span>read</span> character
<span>case</span> <span>$character</span> <span>in</span>
  <span>1</span> <span>)</span> <span>echo</span> <span>1</span>
    <span>;</span><span>;</span>
  <span>2</span> <span>)</span> <span>echo</span> <span>2</span>
    <span>;</span><span>;</span>
  <span>3</span> <span>)</span> <span>echo</span> <span>3</span>
    <span>;</span><span>;</span>
  * <span>)</span> <span>echo</span> 输入不符合要求
<span>esac</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>上面例子中，最后一条匹配语句的模式是 <code>*</code>，这个通配符可以匹配其他字符和没有输入字符的情况，类似 <code>if</code> 的 <code>else</code> 部分。</p>
<p>下面是另一个例子。</p>
<div><pre><code><span>#!/bin/bash</span>

<span>OS</span><span>=</span><span><span>$(</span><span>uname</span> -s<span>)</span></span>

<span>case</span> <span>"<span>$OS</span>"</span> <span>in</span>
  FreeBSD<span>)</span> <span>echo</span> <span>"This is FreeBSD"</span> <span>;</span><span>;</span>
  Darwin<span>)</span> <span>echo</span> <span>"This is Mac OSX"</span> <span>;</span><span>;</span>
  AIX<span>)</span> <span>echo</span> <span>"This is AIX"</span> <span>;</span><span>;</span>
  Minix<span>)</span> <span>echo</span> <span>"This is Minix"</span> <span>;</span><span>;</span>
  Linux<span>)</span> <span>echo</span> <span>"This is Linux"</span> <span>;</span><span>;</span>
  *<span>)</span> <span>echo</span> <span>"Failed to identify this OS"</span> <span>;</span><span>;</span>
<span>esac</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>上面的例子判断当前是什么操作系统。</p>
<p><code>case</code> 的匹配模式可以使用各种通配符，下面是一些例子。</p>
<ul>
<li><code>a)</code>: 匹配 <code>a</code>。</li>
<li><code>a|b)</code>: 匹配 <code>a</code> 或 <code>b</code>。</li>
<li><code>[[:alpha:]])</code>: 匹配单个字母。</li>
<li><code>???)</code>: 匹配 3 个字符的单词。</li>
<li><code>*.txt)</code>: 匹配 <code>.txt</code> 结尾。</li>
<li><code>*)</code>: 匹配任意输入，通过作为 <code>case</code> 结构的最后一个模式。</li>
</ul>
<div><pre><code><span>#!/bin/bash</span>

<span>echo</span> -n <span>"输入一个字母或数字 > "</span>
<span>read</span> character
<span>case</span> <span>$character</span> <span>in</span>
  <span>[</span><span>[</span>:lower:<span>]</span><span>]</span> <span>|</span> <span>[</span><span>[</span>:upper:<span>]</span><span>]</span> <span>)</span> <span>echo</span> <span>"输入了字母 <span>$character</span>"</span>
                              <span>;</span><span>;</span>
  <span>[</span><span>0</span>-9<span>]</span> <span>)</span>                     <span>echo</span> <span>"输入了数字 <span>$character</span>"</span>
                              <span>;</span><span>;</span>
  * <span>)</span>                         <span>echo</span> <span>"输入不符合要求"</span>
<span>esac</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>上面例子中，使用通配符 <code>[[:lower:]] | [[:upper:]]</code> 匹配字母，<code>[0-9]</code> 匹配数字。</p>
<p>Bash 4.0 之前，<code>case</code> 结构只能匹配一个条件，然后就会退出 <code>case</code> 结构。Bash 4.0 之后，允许匹配多个条件，这时可以用 <code>;;&amp;</code> 终止每个条件块。</p>
<div><pre><code><span>#!/bin/bash</span>
<span># test.sh</span>

<span>read</span> -n <span>1</span> -p <span>"Type a character > "</span>
<span>echo</span>
<span>case</span> <span>$REPLY</span> <span>in</span>
  <span>[</span><span>[</span>:upper:<span>]</span><span>]</span><span>)</span>    <span>echo</span> <span>"'<span>$REPLY</span>' is upper case."</span> <span>;</span><span>;</span><span>&amp;</span>
  <span>[</span><span>[</span>:lower:<span>]</span><span>]</span><span>)</span>    <span>echo</span> <span>"'<span>$REPLY</span>' is lower case."</span> <span>;</span><span>;</span><span>&amp;</span>
  <span>[</span><span>[</span>:alpha:<span>]</span><span>]</span><span>)</span>    <span>echo</span> <span>"'<span>$REPLY</span>' is alphabetic."</span> <span>;</span><span>;</span><span>&amp;</span>
  <span>[</span><span>[</span>:digit:<span>]</span><span>]</span><span>)</span>    <span>echo</span> <span>"'<span>$REPLY</span>' is a digit."</span> <span>;</span><span>;</span><span>&amp;</span>
  <span>[</span><span>[</span>:graph:<span>]</span><span>]</span><span>)</span>    <span>echo</span> <span>"'<span>$REPLY</span>' is a visible character."</span> <span>;</span><span>;</span><span>&amp;</span>
  <span>[</span><span>[</span>:punct:<span>]</span><span>]</span><span>)</span>    <span>echo</span> <span>"'<span>$REPLY</span>' is a punctuation symbol."</span> <span>;</span><span>;</span><span>&amp;</span>
  <span>[</span><span>[</span>:space:<span>]</span><span>]</span><span>)</span>    <span>echo</span> <span>"'<span>$REPLY</span>' is a whitespace character."</span> <span>;</span><span>;</span><span>&amp;</span>
  <span>[</span><span>[</span>:xdigit:<span>]</span><span>]</span><span>)</span>   <span>echo</span> <span>"'<span>$REPLY</span>' is a hexadecimal digit."</span> <span>;</span><span>;</span><span>&amp;</span>
<span>esac</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>执行上面的脚本，会得到下面的结果。</p>
<div><pre><code>$ test.sh
Type a character <span>></span> a
<span>'a'</span> is lower case.
<span>'a'</span> is alphabetic.
<span>'a'</span> is a visible character.
<span>'a'</span> is a hexadecimal digit.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>可以看到条件语句结尾添加了 <code>;;&amp;</code> 以后，在匹配一个条件之后，并没有退出 <code>case</code> 结构，而是继续判断下一个条件。</p>
<h2 id="参考链接"> 参考链接</h2>
<ul>
<li><a href="http://linuxcommand.org/tlcl.php" target="_blank" rel="noopener noreferrer">The Linux command-line</a>, William Shotts</li>
</ul>
]]></content>
    <author>
      <name>阮一峰</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>阮一峰</name>
    </contributor>
    <rights>本教程采用&lt;a href="https://creativecommons.org/licenses/by-sa/3.0/deed.zh"&gt;知识共享 署名-相同方式共享 3.0协议&lt;/a&gt;</rights>
  </entry>
  <entry>
    <title type="html">脚本除错</title>
    <id>http://qiqi.dreamagain.top/software/linux/bash/debug/</id>
    <link href="http://qiqi.dreamagain.top/software/linux/bash/debug/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <summary type="html"><![CDATA[<p>本章介绍如何对 Shell 脚本除错。</p>
]]></summary>
    <content type="html"><![CDATA[<p>本章介绍如何对 Shell 脚本除错。</p>

<h2 id="常见错误"> 常见错误</h2>
<p>编写 Shell 脚本的时候，一定要考虑到命令失败的情况，否则很容易出错。</p>
<div><pre><code><span>#! /bin/bash</span>

<span>dir_name</span><span>=</span>/path/not/exist

<span>cd</span> <span>$dir_name</span>
<span>rm</span> *
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>上面脚本中，如果目录 <code>$dir_name</code> 不存在，<code>cd $dir_name</code> 命令就会执行失败。这时，就不会改变当前目录，脚本会继续执行下去，导致 <code>rm *</code> 命令删光当前目录的文件。</p>
<p>如果改成下面的样子，也会有问题。</p>
<div><pre><code><span>cd</span> <span>$dir_name</span> <span>&amp;&amp;</span> <span>rm</span> *
</code></pre>
<div><span>1</span><br></div></div><p>上面脚本中，只有 <code>cd $dir_name</code> 执行成功，才会执行 <code>rm *</code>。但是，如果变量 <code>$dir_name</code> 为空，<code>cd</code> 就会进入用户主目录，从而删光用户主目录的文件。</p>
<p>下面的写法才是正确的。</p>
<div><pre><code><span>[</span><span>[</span> -d <span>$dir_name</span> <span>]</span><span>]</span> <span>&amp;&amp;</span> <span>cd</span> <span>$dir_name</span> <span>&amp;&amp;</span> <span>rm</span> *
</code></pre>
<div><span>1</span><br></div></div><p>上面代码中，先判断目录 <code>$dir_name</code> 是否存在，然后才执行其他操作。</p>
<p>如果不放心删除什么文件，可以先打印出来看一下。</p>
<div><pre><code><span>[</span><span>[</span> -d <span>$dir_name</span> <span>]</span><span>]</span> <span>&amp;&amp;</span> <span>cd</span> <span>$dir_name</span> <span>&amp;&amp;</span> <span>echo</span> <span>rm</span> *
</code></pre>
<div><span>1</span><br></div></div><p>上面命令中，<code>echo rm *</code> 不会删除文件，只会打印出来要删除的文件。</p>
<h2 id="bash-的-x-参数"> <code>bash</code> 的 <code>-x</code> 参数</h2>
<p><code>bash</code> 的 <code>-x</code> 参数可以在执行每一行命令之前，打印该命令。这样就不用自己输出执行的命令，一旦出错，比较容易追查。</p>
<p>下面是一个脚本 <code>script.sh</code>。</p>
<div><pre><code><span># script.sh</span>
<span>echo</span> hello world
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>加上 <code>-x</code> 参数，执行每条命令之前，都会显示该命令。</p>
<div><pre><code>$ <span>bash</span> -x script.sh
+ <span>echo</span> hello world
hello world
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>上面例子中，行首为 <code>+</code> 的行，显示该行是所要执行的命令，下一行才是该命令的执行结果。</p>
<p>下面再看一个 <code>-x</code> 写在脚本内部的例子。</p>
<div><pre><code><span>#! /bin/bash -x</span>
<span># trouble: script to demonstrate common errors</span>

<span>number</span><span>=</span><span>1</span>
<span>if</span> <span>[</span> <span>$number</span> <span>=</span> <span>1</span> <span>]</span><span>;</span> <span>then</span>
  <span>echo</span> <span>"Number is equal to 1."</span>
<span>else</span>
  <span>echo</span> <span>"Number is not equal to 1."</span>
<span>fi</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>上面的脚本执行之后，会输出每一行命令。</p>
<div><pre><code>$ trouble
+ <span>number</span><span>=</span><span>1</span>
+ <span>'['</span> <span>1</span> <span>=</span> <span>1</span> <span>']'</span>
+ <span>echo</span> <span>'Number is equal to 1.'</span>
Number is equal to <span>1</span>.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>输出的命令之前的 <code>+</code> 号，是由系统变量 <code>PS4</code> 决定，可以修改这个变量。</p>
<div><pre><code>$ <span>export</span> <span><span>PS4</span></span><span>=</span><span>'<span>$LINENO</span> + '</span>
$ trouble
<span>5</span> + <span>number</span><span>=</span><span>1</span>
<span>7</span> + <span>'['</span> <span>1</span> <span>=</span> <span>1</span> <span>']'</span>
<span>8</span> + <span>echo</span> <span>'Number is equal to 1.'</span>
Number is equal to <span>1</span>.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>另外，<code>set</code> 命令也可以设置 Shell 的行为参数，有利于脚本除错，详见 <a href="./src/software/linux/bash/set.html">set 命令</a> 一章。</p>
<h2 id="环境变量"> 环境变量</h2>
<p>有一些环境变量常用于除错。</p>
<h3 id="lineno"> LINENO</h3>
<p>变量 <code>LINENO</code> 返回它在脚本里面的行号。</p>
<div><pre><code><span>#!/bin/bash</span>

<span>echo</span> <span>"This is line <span>$LINENO</span>"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>执行上面的脚本 <code>test.sh</code>，<code>$LINENO</code> 会返回 <code>3</code>。</p>
<div><pre><code>$ ./test.sh
This is line <span>3</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h3 id="funcname"> FUNCNAME</h3>
<p>变量 <code>FUNCNAME</code> 返回一个数组，内容是当前的函数调用堆栈。该数组的 0 号成员是当前调用的函数，1 号成员是调用当前函数的函数，以此类推。</p>
<div><pre><code><span>#!/bin/bash</span>

<span>function</span> <span>func1</span><span>(</span><span>)</span>
<span>{</span>
  <span>echo</span> <span>"func1: FUNCNAME0 is <span>${FUNCNAME<span>[</span>0<span>]</span>}</span>"</span>
  <span>echo</span> <span>"func1: FUNCNAME1 is <span>${FUNCNAME<span>[</span>1<span>]</span>}</span>"</span>
  <span>echo</span> <span>"func1: FUNCNAME2 is <span>${FUNCNAME<span>[</span>2<span>]</span>}</span>"</span>
  func2
<span>}</span>

<span>function</span> <span>func2</span><span>(</span><span>)</span>
<span>{</span>
  <span>echo</span> <span>"func2: FUNCNAME0 is <span>${FUNCNAME<span>[</span>0<span>]</span>}</span>"</span>
  <span>echo</span> <span>"func2: FUNCNAME1 is <span>${FUNCNAME<span>[</span>1<span>]</span>}</span>"</span>
  <span>echo</span> <span>"func2: FUNCNAME2 is <span>${FUNCNAME<span>[</span>2<span>]</span>}</span>"</span>
<span>}</span>

func1
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><p>执行上面的脚本 <code>test.sh</code>，结果如下。</p>
<div><pre><code>$ ./test.sh
func1: FUNCNAME0 is func1
func1: FUNCNAME1 is main
func1: FUNCNAME2 is
func2: FUNCNAME0 is func2
func2: FUNCNAME1 is func1
func2: FUNCNAME2 is main
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>上面例子中，执行 <code>func1</code> 时，变量 <code>FUNCNAME</code> 的 0 号成员是 <code>func1</code>，1 号成员是调用 <code>func1</code> 的主脚本 <code>main</code>。执行 <code>func2</code> 时，变量 <code>FUNCNAME</code> 的 0 号成员是 <code>func2</code>，1 号成员是调用 <code>func2</code> 的 <code>func1</code>。</p>
<h3 id="bash-source"> BASH_SOURCE</h3>
<p>变量 <code>BASH_SOURCE</code> 返回一个数组，内容是当前的脚本调用堆栈。该数组的 0 号成员是当前执行的脚本，1 号成员是调用当前脚本的脚本，以此类推，跟变量 <code>FUNCNAME</code> 是一一对应关系。</p>
<p>下面有两个子脚本 <code>lib1.sh</code> 和 <code>lib2.sh</code>。</p>
<div><pre><code><span># lib1.sh</span>
<span>function</span> <span>func1</span><span>(</span><span>)</span>
<span>{</span>
  <span>echo</span> <span>"func1: BASH_SOURCE0 is <span>${<span>BASH_SOURCE</span><span>[</span>0<span>]</span>}</span>"</span>
  <span>echo</span> <span>"func1: BASH_SOURCE1 is <span>${<span>BASH_SOURCE</span><span>[</span>1<span>]</span>}</span>"</span>
  <span>echo</span> <span>"func1: BASH_SOURCE2 is <span>${<span>BASH_SOURCE</span><span>[</span>2<span>]</span>}</span>"</span>
  func2
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><div><pre><code><span># lib2.sh</span>
<span>function</span> <span>func2</span><span>(</span><span>)</span>
<span>{</span>
  <span>echo</span> <span>"func2: BASH_SOURCE0 is <span>${<span>BASH_SOURCE</span><span>[</span>0<span>]</span>}</span>"</span>
  <span>echo</span> <span>"func2: BASH_SOURCE1 is <span>${<span>BASH_SOURCE</span><span>[</span>1<span>]</span>}</span>"</span>
  <span>echo</span> <span>"func2: BASH_SOURCE2 is <span>${<span>BASH_SOURCE</span><span>[</span>2<span>]</span>}</span>"</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>然后，主脚本 <code>main.sh</code> 调用上面两个子脚本。</p>
<div><pre><code><span>#!/bin/bash</span>
<span># main.sh</span>

<span>source</span> lib1.sh
<span>source</span> lib2.sh

func1
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>执行主脚本 <code>main.sh</code>，会得到下面的结果。</p>
<div><pre><code>$ ./main.sh
func1: BASH_SOURCE0 is lib1.sh
func1: BASH_SOURCE1 is ./main.sh
func1: BASH_SOURCE2 is
func2: BASH_SOURCE0 is lib2.sh
func2: BASH_SOURCE1 is lib1.sh
func2: BASH_SOURCE2 is ./main.sh
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>上面例子中，执行函数 <code>func1</code> 时，变量 <code>BASH_SOURCE</code> 的 0 号成员是 <code>func1</code> 所在的脚本 <code>lib1.sh</code>，1 号成员是主脚本 <code>main.sh</code>；执行函数 <code>func2</code> 时，变量 <code>BASH_SOURCE</code> 的 0 号成员是 <code>func2</code> 所在的脚本 <code>lib2.sh</code>，1 号成员是调用 <code>func2</code> 的脚本 <code>lib1.sh</code>。</p>
<h3 id="bash-lineno"> BASH_LINENO</h3>
<p>变量 <code>BASH_LINENO</code> 返回一个数组，内容是每一轮调用对应的行号。<code>${BASH_LINENO[$i]}</code> 跟 <code>${FUNCNAME[$i]}</code> 是一一对应关系，表示 <code>${FUNCNAME[$i]}</code> 在调用它的脚本文件 <code>${BASH_SOURCE[$i+1]}</code> 里面的行号。</p>
<p>下面有两个子脚本 <code>lib1.sh</code> 和 <code>lib2.sh</code>。</p>
<div><pre><code><span># lib1.sh</span>
<span>function</span> <span>func1</span><span>(</span><span>)</span>
<span>{</span>
  <span>echo</span> <span>"func1: BASH_LINENO is <span>${<span>BASH_LINENO</span><span>[</span>0<span>]</span>}</span>"</span>
  <span>echo</span> <span>"func1: FUNCNAME is <span>${FUNCNAME<span>[</span>0<span>]</span>}</span>"</span>
  <span>echo</span> <span>"func1: BASH_SOURCE is <span>${<span>BASH_SOURCE</span><span>[</span>1<span>]</span>}</span>"</span>

  func2
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><div><pre><code><span># lib2.sh</span>
<span>function</span> <span>func2</span><span>(</span><span>)</span>
<span>{</span>
  <span>echo</span> <span>"func2: BASH_LINENO is <span>${<span>BASH_LINENO</span><span>[</span>0<span>]</span>}</span>"</span>
  <span>echo</span> <span>"func2: FUNCNAME is <span>${FUNCNAME<span>[</span>0<span>]</span>}</span>"</span>
  <span>echo</span> <span>"func2: BASH_SOURCE is <span>${<span>BASH_SOURCE</span><span>[</span>1<span>]</span>}</span>"</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>然后，主脚本 <code>main.sh</code> 调用上面两个子脚本。</p>
<div><pre><code><span>#!/bin/bash</span>
<span># main.sh</span>

<span>source</span> lib1.sh
<span>source</span> lib2.sh

func1
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>执行主脚本 <code>main.sh</code>，会得到下面的结果。</p>
<div><pre><code>$ ./main.sh
func1: <span>BASH_LINENO</span> is <span>7</span>
func1: FUNCNAME is func1
func1: <span>BASH_SOURCE</span> is main.sh
func2: <span>BASH_LINENO</span> is <span>8</span>
func2: FUNCNAME is func2
func2: <span>BASH_SOURCE</span> is lib1.sh
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>上面例子中，函数 <code>func1</code> 是在 <code>main.sh</code> 的第 7 行调用，函数 <code>func2</code> 是在 <code>lib1.sh</code> 的第 8 行调用的。</p>
]]></content>
    <author>
      <name>阮一峰</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>阮一峰</name>
    </contributor>
    <rights>本教程采用&lt;a href="https://creativecommons.org/licenses/by-sa/3.0/deed.zh"&gt;知识共享 署名-相同方式共享 3.0协议&lt;/a&gt;</rights>
  </entry>
  <entry>
    <title type="html">Bash 的模式扩展</title>
    <id>http://qiqi.dreamagain.top/software/linux/bash/expansion/</id>
    <link href="http://qiqi.dreamagain.top/software/linux/bash/expansion/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<h2 id="简介"> 简介</h2>
<p>Shell 接收到用户输入的命令以后，会根据空格将用户的输入，拆分成一个个词元(token)。然后，Shell 会扩展词元里面的特殊字符，扩展完成后才会调用相应的命令。</p>
<p>这种特殊字符的扩展，称为模式扩展(globbing)。其中有些用到通配符，又称为通配符扩展(wildcard expansion)。Bash 一共提供八种扩展。</p>
<ul>
<li>波浪线扩展</li>
<li><code>?</code> 字符扩展</li>
<li><code>*</code> 字符扩展</li>
<li>方括号扩展</li>
<li>大括号扩展</li>
<li>变量扩展</li>
<li>子命令扩展</li>
<li>算术扩展</li>
</ul>
<p>本章介绍这八种扩展。</p>
<p>Bash 是先进行扩展，再执行命令。因此，扩展的结果是由 Bash 负责的，与所要执行的命令无关。命令本身并不存在参数扩展，收到什么参数就原样执行。这一点务必需要记住。</p>
<p><code>globbing</code> 这个词，来自于早期的 Unix 系统有一个 <code>/etc/glob</code> 文件，保存扩展的模板。后来 Bash 内置了这个功能，但是这个名字就保留了下来。</p>
<p>模式扩展与正则表达式的关系是，模式扩展早于正则表达式出现，可以看作是原始的正则表达式。它的功能没有正则那么强大灵活，但是优点是简单和方便。</p>
<p>Bash 允许用户关闭扩展。</p>
<div><pre><code>$ <span>set</span> -o noglob
<span># 或者</span>
$ <span>set</span> -f
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>下面的命令可以重新打开扩展。</p>
<div><pre><code>$ <span>set</span> +o noglob
<span># 或者</span>
$ <span>set</span> +f
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id="波浪线扩展"> 波浪线扩展</h2>
<p>波浪线 <code>~</code> 会自动扩展成当前用户的主目录。</p>
<div><pre><code>$ <span>echo</span> ~
/home/me
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><code>~/dir</code> 表示扩展成主目录的某个子目录，<code>dir</code> 是主目录里面的一个子目录名。</p>
<div><pre><code><span># 进入 /home/me/foo 目录</span>
$ <span>cd</span> ~/foo
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><code>~user</code> 表示扩展成用户 <code>user</code> 的主目录。</p>
<div><pre><code>$ <span>echo</span> ~foo
/home/foo

$ <span>echo</span> ~root
/root
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>上面例子中，Bash 会根据波浪号后面的用户名，返回该用户的主目录。</p>
<p>如果 <code>~user</code> 的 <code>user</code> 是不存在的用户名，则波浪号扩展不起作用。</p>
<div><pre><code>$ <span>echo</span> ~nonExistedUser
~nonExistedUser
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><code>~+</code> 会扩展成当前所在的目录，等同于 <code>pwd</code> 命令。</p>
<div><pre><code>$ <span>cd</span> ~/foo
$ <span>echo</span> ~+
/home/me/foo
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id="字符扩展"> <code>?</code> 字符扩展</h2>
<p><code>?</code> 字符代表文件路径里面的任意单个字符，不包括空字符。比如，<code>Data???</code> 匹配所有 <code>Data</code> 后面跟着三个字符的文件名。</p>
<div><pre><code><span># 存在文件 a.txt 和 b.txt</span>
$ <span>ls</span> ?.txt
a.txt b.txt
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>上面命令中，<code>?</code> 表示单个字符，所以会同时匹配 <code>a.txt</code> 和 <code>b.txt</code>。</p>
<p>如果匹配多个字符，就需要多个 <code>?</code> 连用。</p>
<div><pre><code><span># 存在文件 a.txt、b.txt 和 ab.txt</span>
$ <span>ls</span> ??.txt
ab.txt
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>上面命令中，<code>??</code> 匹配了两个字符。</p>
<p><code>?</code> 字符扩展属于文件名扩展，只有文件确实存在的前提下，才会发生扩展。如果文件不存在，扩展就不会发生。</p>
<div><pre><code><span># 当前目录有 a.txt 文件</span>
$ <span>echo</span> ?.txt
a.txt

<span># 当前目录为空目录</span>
$ <span>echo</span> ?.txt
?.txt
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>上面例子中，如果 <code>?.txt</code> 可以扩展成文件名，<code>echo</code> 命令会输出扩展后的结果；如果不能扩展成文件名，<code>echo</code> 就会原样输出 <code>?.txt</code>。</p>
<h2 id="字符扩展-2"> <code>*</code> 字符扩展</h2>
<p><code>*</code> 字符代表文件路径里面的任意数量的任意字符，包括零个字符。</p>
<div><pre><code><span># 存在文件 a.txt、b.txt 和 ab.txt</span>
$ <span>ls</span> *.txt
a.txt b.txt ab.txt
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>上面例子中，<code>*.txt</code> 代表后缀名为 <code>.txt</code> 的所有文件。</p>
<p>如果想输出当前目录的所有文件，直接用 <code>*</code> 即可。</p>
<div><pre><code><span>ls</span> *
</code></pre>
<div><span>1</span><br></div></div><p><code>*</code> 可以匹配空字符，下面是一个例子。</p>
<div><pre><code><span># 存在文件 a.txt、b.txt 和 ab.txt</span>
$ <span>ls</span> a*.txt
a.txt ab.txt

$ <span>ls</span> *b*
b.txt ab.txt
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>注意，<code>*</code> 不会匹配隐藏文件(以 <code>.</code> 开头的文件)，即 <code>ls *</code> 不会输出隐藏文件。</p>
<p>如果要匹配隐藏文件，需要写成 <code>.*</code>。</p>
<div><pre><code><span># 显示所有隐藏文件</span>
$ <span>echo</span> .*
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>如果要匹配隐藏文件，同时要排除 <code>.</code> 和 <code>..</code> 这两个特殊的隐藏文件，可以与方括号扩展结合使用，写成 <code>.[!.]*</code>。</p>
<div><pre><code><span>echo</span> .<span>[</span><span>!</span>.<span>]</span>*
</code></pre>
<div><span>1</span><br></div></div><p>注意，<code>*</code> 字符扩展属于文件名扩展，只有文件确实存在的前提下才会扩展。如果文件不存在，就会原样输出。</p>
<div><pre><code><span># 当前目录不存在 c 开头的文件</span>
$ <span>echo</span> c*.txt
c*.txt
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>上面例子中，当前目录里面没有 <code>c</code> 开头的文件，导致 <code>c*.txt</code> 会原样输出。</p>
<p><code>*</code> 只匹配当前目录，不会匹配子目录。</p>
<div><pre><code><span># 子目录有一个 a.txt</span>
<span># 无效的写法</span>
$ <span>ls</span> *.txt

<span># 有效的写法</span>
$ <span>ls</span> */*.txt
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>上面的例子，文本文件在子目录，<code>*.txt</code> 不会产生匹配，必须写成 <code>*/*.txt</code>。有几层子目录，就必须写几层星号。</p>
<p>Bash 4.0 引入了一个参数 <code>globstar</code>，当该参数打开时，允许 <code>**</code> 匹配零个或多个子目录。因此，<code>**/*.txt</code> 可以匹配顶层的文本文件和任意深度子目录的文本文件。详细介绍请看后面 <code>shopt</code> 命令的介绍。</p>
<h2 id="方括号扩展"> 方括号扩展</h2>
<p>方括号扩展的形式是 <code>[...]</code>，只有文件确实存在的前提下才会扩展。如果文件不存在，就会原样输出。括号之中的任意一个字符。比如，<code>[aeiou]</code> 可以匹配五个元音字母中的任意一个。</p>
<div><pre><code><span># 存在文件 a.txt 和 b.txt</span>
$ <span>ls</span> <span>[</span>ab<span>]</span>.txt
a.txt b.txt

<span># 只存在文件 a.txt</span>
$ <span>ls</span> <span>[</span>ab<span>]</span>.txt
a.txt
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>上面例子中，<code>[ab]</code> 可以匹配 <code>a</code> 或 <code>b</code>，前提是确实存在相应的文件。</p>
<p>方括号扩展属于文件名匹配，即扩展后的结果必须符合现有的文件路径。如果不存在匹配，就会保持原样，不进行扩展。</p>
<div><pre><code><span># 不存在文件 a.txt 和 b.txt</span>
$ <span>ls</span> <span>[</span>ab<span>]</span>.txt
ls: 无法访问<span>'[ab].txt'</span><span>:</span> 没有那个文件或目录
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>上面例子中，由于扩展后的文件不存在，<code>[ab].txt</code> 就原样输出了，导致 <code>ls</code> 命名报错。</p>
<p>方括号扩展还有两种变体: <code>[^...]</code> 和 <code>[!...]</code>。它们表示匹配不在方括号里面的字符，这两种写法是等价的。比如，<code>[^abc]</code> 或 <code>[!abc]</code> 表示匹配除了 <code>a</code>、<code>b</code>、<code>c</code> 以外的字符。</p>
<div><pre><code><span># 存在 aaa、bbb、aba 三个文件</span>
$ <span>ls</span> ?<span>[</span><span>!</span>a<span>]</span>?
aba bbb
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>上面命令中，<code>[!a]</code> 表示文件名第二个字符不是 <code>a</code> 的文件名，所以返回了 <code>aba</code> 和 <code>bbb</code> 两个文件。</p>
<p>注意，如果需要匹配 <code>[</code> 字符，可以放在方括号内，比如 <code>[[aeiou]</code>。如果需要匹配连字号 <code>-</code>，只能放在方括号内部的开头或结尾，比如 <code>[-aeiou]</code> 或 <code>[aeiou-]</code>。</p>
<h2 id="start-end-扩展"> [start-end] 扩展</h2>
<p>方括号扩展有一个简写形式 <code>[start-end]</code>，表示匹配一个连续的范围。比如，<code>[a-c]</code> 等同于 <code>[abc]</code>，<code>[0-9]</code> 匹配 <code>[0123456789]</code>。</p>
<div><pre><code><span># 存在文件 a.txt、b.txt 和 c.txt</span>
$ <span>ls</span> <span>[</span>a-c<span>]</span>.txt
a.txt
b.txt
c.txt

<span># 存在文件 report1.txt、report2.txt 和 report3.txt</span>
$ <span>ls</span> report<span>[</span><span>0</span>-9<span>]</span>.txt
report1.txt
report2.txt
report3.txt
<span>..</span>.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>下面是一些常用简写的例子。</p>
<ul>
<li><code>[a-z]</code>: 所有小写字母。</li>
<li><code>[a-zA-Z]</code>: 所有小写字母与大写字母。</li>
<li><code>[a-zA-Z0-9]</code>: 所有小写字母、大写字母与数字。</li>
<li><code>[abc]*</code>: 所有以 <code>a</code>、<code>b</code>、<code>c</code> 字符之一开头的文件名。</li>
<li><code>program.[co]</code>: 文件 <code>program.c</code> 与文件 <code>program.o</code>。</li>
<li><code>BACKUP.[0-9][0-9][0-9]</code>: 所有以 <code>BACKUP.</code> 开头，后面是三个数字的文件名。</li>
</ul>
<p>这种简写形式有一个否定形式 <code>[!start-end]</code>，表示匹配不属于这个范围的字符。比如，<code>[!a-zA-Z]</code> 表示匹配非英文字母的字符。</p>
<div><pre><code>$ <span>echo</span> report<span>[</span><span>!</span><span>1</span>–3<span>]</span>.txt
report4.txt report5.txt
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>上面代码中，<code>[!1-3]</code> 表示排除 1、2 和 3。</p>
<h2 id="大括号扩展"> 大括号扩展</h2>
<p>大括号扩展 <code>{...}</code> 表示分别扩展成大括号里面的所有值，各个值之间使用逗号分隔。比如，<code>{1,2,3}</code> 扩展成 <code>1 2 3</code>。</p>
<div><pre><code>$ <span>echo</span> <span>{</span><span>1,2</span>,3<span>}</span>
<span>1</span> <span>2</span> <span>3</span>

$ <span>echo</span> d<span>{</span>a,e,i,u,o<span>}</span>g
dag deg <span>dig</span> dug dog

$ <span>echo</span> Front-<span>{</span>A,B,C<span>}</span>-Back
Front-A-Back Front-B-Back Front-C-Back
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>注意，大括号扩展不是文件名扩展。它会扩展成所有给定的值，而不管是否有对应的文件存在。</p>
<div><pre><code>$ <span>ls</span> <span>{</span>a,b,c<span>}</span>.txt
ls: 无法访问<span>'a.txt'</span><span>:</span> 没有那个文件或目录
ls: 无法访问<span>'b.txt'</span><span>:</span> 没有那个文件或目录
ls: 无法访问<span>'c.txt'</span><span>:</span> 没有那个文件或目录
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>上面例子中，即使不存在对应的文件，<code>{a,b,c}</code> 依然扩展成三个文件名，导致 <code>ls</code> 命令报了三个错误。</p>
<p>另一个需要注意的地方是，大括号内部的逗号前后不能有空格。否则，大括号扩展会失效。</p>
<div><pre><code>$ <span>echo</span> <span>{</span><span>1</span> , <span>2</span><span>}</span>
<span>{</span><span>1</span> , <span>2</span><span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>上面例子中，逗号前后有空格，Bash 就会认为这不是大括号扩展，而是三个独立的参数。</p>
<p>逗号前面可以没有值，表示扩展的第一项为空。</p>
<div><pre><code>$ <span>cp</span> a.log<span>{</span>,.bak<span>}</span>

<span># 等同于</span>
<span># cp a.log a.log.bak</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>大括号可以嵌套。</p>
<div><pre><code>$ <span>echo</span> <span>{</span>j<span>{</span>p,pe<span>}</span>g,png<span>}</span>
jpg jpeg png

$ <span>echo</span> a<span>{</span>A<span>{</span><span>1,2</span><span>}</span>,B<span>{</span><span>3,4</span><span>}</span><span>}</span>b
aA1b aA2b aB3b aB4b
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>大括号也可以与其他模式联用，并且总是先于其他模式进行扩展。</p>
<div><pre><code>$ <span>echo</span> <span>{</span>cat,d*<span>}</span>
<span>cat</span> dawg dg <span>dig</span> dog doug dug
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>上面例子中，会先进行大括号扩展，然后进行 <code>*</code> 扩展。</p>
<p>大括号可以用于多字符的模式，方括号不行(只能匹配单字符)。</p>
<div><pre><code>$ <span>echo</span> <span>{</span>cat,dog<span>}</span>
<span>cat</span> dog
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>由于大括号扩展 <code>{...}</code> 不是文件名扩展，所以它总是会扩展的。这与方括号扩展 <code>[...]</code> 完全不同，如果匹配的文件不存在，方括号就不会扩展。这一点要注意区分。</p>
<div><pre><code><span># 不存在 a.txt 和 b.txt</span>
$ <span>echo</span> <span>[</span>ab<span>]</span>.txt
<span>[</span>ab<span>]</span>.txt

$ <span>echo</span> <span>{</span>a,b<span>}</span>.txt
a.txt b.txt
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>上面例子中，如果不存在 <code>a.txt</code> 和 <code>b.txt</code>，那么 <code>[ab].txt</code> 就会变成一个普通的文件名，而 <code>{a,b}.txt</code> 可以照样扩展。</p>
<h2 id="start-end-扩展-2"> {start..end} 扩展</h2>
<p>大括号扩展有一个简写形式 <code>{start..end}</code>，表示扩展成一个连续序列。比如，<code>{a..z}</code> 可以扩展成 26 个小写英文字母。</p>
<div><pre><code>$ <span>echo</span> <span>{</span>a<span>..</span>c<span>}</span>
a b c

$ <span>echo</span> d<span>{</span>a<span>..</span>d<span>}</span>g
dag dbg dcg ddg

$ <span>echo</span> <span>{</span><span>1</span><span>..</span><span>4</span><span>}</span>
<span>1</span> <span>2</span> <span>3</span> <span>4</span>

$ <span>echo</span> Number_<span>{</span><span>1</span><span>..</span><span>5</span><span>}</span>
Number_1 Number_2 Number_3 Number_4 Number_5
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>这种简写形式支持逆序。</p>
<div><pre><code>$ <span>echo</span> <span>{</span>c<span>..</span>a<span>}</span>
c b a

$ <span>echo</span> <span>{</span><span>5</span><span>..</span><span>1</span><span>}</span>
<span>5</span> <span>4</span> <span>3</span> <span>2</span> <span>1</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>注意，如果遇到无法理解的简写，大括号模式就会原样输出，不会扩展。</p>
<div><pre><code>$ <span>echo</span> <span>{</span>a1<span>..</span>3c<span>}</span>
<span>{</span>a1<span>..</span>3c<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>这种简写形式可以嵌套使用，形成复杂的扩展。</p>
<div><pre><code>$ <span>echo</span> .<span>{</span>mp<span>{</span><span>3</span><span>..</span><span>4</span><span>}</span>,m4<span>{</span>a,b,p,v<span>}</span><span>}</span>
.mp3 .mp4 .m4a .m4b .m4p .m4v
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>大括号扩展的常见用途为新建一系列目录。</p>
<div><pre><code><span>mkdir</span> <span>{</span><span>2007</span><span>..</span><span>2009</span><span>}</span>-<span>{</span>01<span>..</span><span>12</span><span>}</span>
</code></pre>
<div><span>1</span><br></div></div><p>上面命令会新建 36 个子目录，每个子目录的名字都是”年份-月份“。</p>
<p>这个写法的另一个常见用途，是直接用于 <code>for</code> 循环。</p>
<div><pre><code><span>for</span> <span>i</span> <span>in</span> <span>{</span><span>1</span><span>..</span><span>4</span><span>}</span>
<span>do</span>
  <span>echo</span> <span>$i</span>
<span>done</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>上面例子会循环 4 次。</p>
<p>如果整数前面有前导 <code>0</code>，扩展输出的每一项都有前导 <code>0</code>。</p>
<div><pre><code>$ <span>echo</span> <span>{</span>01<span>..</span><span>5</span><span>}</span>
01 02 03 04 05

$ <span>echo</span> <span>{</span>001<span>..</span><span>5</span><span>}</span>
001 002 003 004 005
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>这种简写形式还可以使用第二个双点号(<code>start..end..step</code>)，用来指定扩展的步长。</p>
<div><pre><code>$ <span>echo</span> <span>{</span><span>0</span><span>..</span><span>8</span><span>..</span><span>2</span><span>}</span>
<span>0</span> <span>2</span> <span>4</span> <span>6</span> <span>8</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>上面代码将 <code>0</code> 扩展到 <code>8</code>，每次递增的长度为 <code>2</code>，所以一共输出 5 个数字。</p>
<p>多个简写形式连用，会有循环处理的效果。</p>
<div><pre><code>$ <span>echo</span> <span>{</span>a<span>..</span>c<span>}</span><span>{</span><span>1</span><span>..</span><span>3</span><span>}</span>
a1 a2 a3 b1 b2 b3 c1 c2 c3
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h2 id="变量扩展"> 变量扩展</h2>
<p>Bash 将美元符号 <code>$</code> 开头的词元视为变量，将其扩展成变量值，详见<a href="./src/software/linux/bash/variable.html">Bash 变量</a> 一章。</p>
<div><pre><code>$ <span>echo</span> <span>$SHELL</span>
/bin/bash
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>变量名除了放在美元符号后面，也可以放在 <code>${}</code> 里面。</p>
<div><pre><code>$ <span>echo</span> <span>${<span>SHELL</span>}</span>
/bin/bash
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><code>${!string*}</code> 或 <code>${!string@}</code> 返回所有匹配给定字符串 <code>string</code> 的变量名。</p>
<div><pre><code>$ <span>echo</span> <span>${<span>!</span>S*}</span>
<span>SECONDS</span> <span>SHELL</span> <span>SHELLOPTS</span> <span>SHLVL</span> SSH_AGENT_PID <span>SSH_AUTH_SOCK</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>上面例子中，<code>${!S*}</code> 扩展成所有以 <code>S</code> 开头的变量名。</p>
<h2 id="子命令扩展"> 子命令扩展</h2>
<p><code>$(...)</code> 可以扩展成另一个命令的运行结果，该命令的所有输出都会作为返回值。</p>
<div><pre><code>$ <span>echo</span> <span><span>$(</span><span>date</span><span>)</span></span>
Tue Jan <span>28</span> 00:01:13 CST <span>2020</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>上面例子中，<code>$(date)</code> 返回 <code>date</code> 命令的运行结果。</p>
<p>还有另一种较老的语法，子命令放在反引号之中，也可以扩展成命令的运行结果。</p>
<div><pre><code>$ <span>echo</span> <span><span>`</span><span>date</span><span>`</span></span>
Tue Jan <span>28</span> 00:01:13 CST <span>2020</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><code>$(...)</code> 可以嵌套，比如 <code>$(ls $(pwd))</code>。</p>
<h2 id="算术扩展"> 算术扩展</h2>
<p><code>$((...))</code> 可以扩展成整数运算的结果，详见 <a href="./src/software/linux/bash/arithmetic.html">Bash 的算术运算</a> 一章。</p>
<div><pre><code>$ <span>echo</span> <span><span>$((</span><span>2</span> <span>+</span> <span>2</span><span>))</span></span>
<span>4</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h2 id="字符类"> 字符类</h2>
<p><code>[[:class:]]</code> 表示一个字符类，扩展成某一类特定字符之中的一个。常用的字符类如下。</p>
<ul>
<li><code>[[:alnum:]]</code>: 匹配任意英文字母与数字</li>
<li><code>[[:alpha:]]</code>: 匹配任意英文字母</li>
<li><code>[[:blank:]]</code>: 空格和 Tab 键。</li>
<li><code>[[:cntrl:]]</code>: ASCII 码 0-31 的不可打印字符。</li>
<li><code>[[:digit:]]</code>: 匹配任意数字 0-9。</li>
<li><code>[[:graph:]]</code>: A-Z、a-z、0-9 和标点符号。</li>
<li><code>[[:lower:]]</code>: 匹配任意小写字母 a-z。</li>
<li><code>[[:print:]]</code>: ASCII 码 32-127 的可打印字符。</li>
<li><code>[[:punct:]]</code>: 标点符号(除了 A-Z、a-z、0-9 的可打印字符)。</li>
<li><code>[[:space:]]</code>: 空格、Tab、LF(10)、VT(11)、FF(12)、CR(13)。</li>
<li><code>[[:upper:]]</code>: 匹配任意大写字母 A-Z。</li>
<li><code>[[:xdigit:]]</code>: 16 进制字符(A-F、a-f、0-9)。</li>
</ul>
<p>请看下面的例子。</p>
<div><pre><code><span>echo</span> <span>[</span><span>[</span>:upper:<span>]</span><span>]</span>*
</code></pre>
<div><span>1</span><br></div></div><p>上面命令输出所有大写字母开头的文件名。</p>
<p>字符类的第一个方括号后面，可以加上感叹号 <code>!</code>，表示否定。比如，<code>[![:digit:]]</code> 匹配所有非数字。</p>
<div><pre><code><span>echo</span> <span>[</span><span>!</span><span>[</span>:digit:<span>]</span><span>]</span>*
</code></pre>
<div><span>1</span><br></div></div><p>上面命令输出所有不以数字开头的文件名。</p>
<p>字符类也属于文件名扩展，如果没有匹配的文件名，字符类就会原样输出。</p>
<div><pre><code><span># 不存在以大写字母开头的文件</span>
$ <span>echo</span> <span>[</span><span>[</span>:upper:<span>]</span><span>]</span>*
<span>[</span><span>[</span>:upper:<span>]</span><span>]</span>*
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>上面例子中，由于没有可匹配的文件，字符类就原样输出了。</p>
<h2 id="使用注意点"> 使用注意点</h2>
<p>通配符有一些使用注意点，不可不知。</p>
<p>(1)<strong>通配符是先解释，再执行。</strong></p>
<p>Bash 接收到命令以后，发现里面有通配符，会进行通配符扩展，然后再执行命令。</p>
<div><pre><code>$ <span>ls</span> a*.txt
ab.txt
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>上面命令的执行过程是，Bash 先将 <code>a*.txt</code> 扩展成 <code>ab.txt</code>，然后再执行 <code>ls ab.txt</code>。</p>
<p>(2)<strong>文件名扩展在不匹配时，会原样输出。</strong></p>
<p>文件名扩展在没有可匹配的文件时，会原样输出。</p>
<div><pre><code><span># 不存在 r 开头的文件名</span>
$ <span>echo</span> r*
r*
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>上面代码中，由于不存在 <code>r</code> 开头的文件名，<code>r*</code> 会原样输出。</p>
<p>下面是另一个例子。</p>
<div><pre><code>$ <span>ls</span> *.csv
ls: *.csv: No such <span>file</span> or directory
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>另外，前面已经说过，大括号扩展 <code>{...}</code> 不是文件名扩展。</p>
<p>(3)<strong>只适用于单层路径。</strong></p>
<p>所有文件名扩展只匹配单层路径，不能跨目录匹配，即无法匹配子目录里面的文件。或者说，<code>?</code> 或 <code>*</code> 这样的通配符，不能匹配路径分隔符 (<code>/</code>)。</p>
<p>如果要匹配子目录里面的文件，可以写成下面这样。</p>
<div><pre><code><span>ls</span> */*.txt
</code></pre>
<div><span>1</span><br></div></div><p>Bash 4.0 新增了一个 <code>globstar</code> 参数，允许 <code>**</code> 匹配零个或多个子目录，详见后面 <code>shopt</code> 命令的介绍。</p>
<p>(4)<strong>文件名可以使用通配符。</strong></p>
<p>Bash 允许文件名使用通配符，即文件名包括特殊字符。这时引用文件名，需要把文件名放在单引号里面。</p>
<div><pre><code>$ <span>touch</span> <span>'fo*'</span>
$ <span>ls</span>
fo*
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>上面代码创建了一个 <code>fo*</code> 文件，这时 <code>*</code> 就是文件名的一部分。</p>
<h2 id="量词语法"> 量词语法</h2>
<p>量词语法用来控制模式匹配的次数。它只有在 Bash 的 <code>extglob</code> 参数打开的情况下才能使用，不过一般是默认打开的。下面的命令可以查询。</p>
<div><pre><code>$ <span>shopt</span> extglob
extglob         on
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>量词语法有下面几个。</p>
<ul>
<li><code>?(pattern-list)</code>: 匹配零个或一个模式。</li>
<li><code>*(pattern-list)</code>: 匹配零个或多个模式。</li>
<li><code>+(pattern-list)</code>: 匹配一个或多个模式。</li>
<li><code>@(pattern-list)</code>: 只匹配一个模式。</li>
<li><code>!(pattern-list)</code>: 匹配零个或一个以上的模式，但不匹配单独一个的模式。</li>
</ul>
<div><pre><code>$ <span>ls</span> abc?<span>(</span>.<span>)</span>txt
abctxt abc.txt
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>上面例子中，<code>?(.)</code> 匹配零个或一个点。</p>
<div><pre><code>$ <span>ls</span> abc?<span>(</span>def<span>)</span>
abc abcdef
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>上面例子中，<code>?(def)</code> 匹配零个或一个 <code>def</code>。</p>
<div><pre><code>$ <span>ls</span> abc+<span>(</span>.txt<span>|</span>.php<span>)</span>
abc.php abc.txt
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>上面例子中，<code>+(.txt|.php)</code> 匹配文件有一个 <code>.txt</code> 或 <code>.php</code> 后缀名。</p>
<div><pre><code>$ <span>ls</span> abc+<span>(</span>.txt<span>)</span>
abc.txt abc.txt.txt
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>上面例子中，<code>+(.txt)</code> 匹配文件有一个或多个 <code>.txt</code> 后缀名。</p>
<p>量词语法也属于文件名扩展，如果不存在可匹配的文件，就会原样输出。</p>
<div><pre><code><span># 没有 abc 开头的文件名</span>
$ <span>ls</span> abc?<span>(</span>def<span>)</span>
ls: 无法访问<span>'abc?(def)'</span><span>:</span> 没有那个文件或目录
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>上面例子中，由于没有可匹配的文件，<code>abc?(def)</code> 就原样输出，导致 <code>ls</code> 命令报错。</p>
<h2 id="shopt-命令"> shopt 命令</h2>
<p><code>shopt</code> 命令可以调整 Bash 的行为。它有好几个参数跟通配符扩展有关。</p>
<p><code>shopt</code> 命令的使用方法如下。</p>
<div><pre><code><span># 打开某个参数</span>
$ <span>shopt</span> -s <span>[</span>optionname<span>]</span>

<span># 关闭某个参数</span>
$ <span>shopt</span> -u <span>[</span>optionname<span>]</span>

<span># 查询某个参数关闭还是打开</span>
$ <span>shopt</span> <span>[</span>optionname<span>]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><ol>
<li>
<p><strong>dotglob 参数</strong></p>
<p><code>dotglob</code> 参数可以让扩展结果包括隐藏文件(即点开头的文件)。</p>
<p>正常情况下，扩展结果不包括隐藏文件。</p>
<div><pre><code>$ <span>ls</span> *
abc.txt
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>打开 <code>dotglob</code>，就会包括隐藏文件。</p>
<div><pre><code>$ <span>shopt</span> -s dotglob
$ <span>ls</span> *
abc.txt .config
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div></li>
<li>
<p><strong>nullglob 参数</strong></p>
<p><code>nullglob</code> 参数可以让通配符不匹配任何文件名时，返回空字符。</p>
<p>默认情况下，通配符不匹配任何文件名时，会保持不变。</p>
<div><pre><code>$ <span>rm</span> b*
rm: 无法删除<span>'b*'</span><span>:</span> 没有那个文件或目录
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>上面例子中，由于当前目录不包括 <code>b</code> 开头的文件名，导致 <code>b*</code> 不会发生文件名扩展，保持原样不变，所以 <code>rm</code> 命令报错没有 <code>b*</code> 这个文件。</p>
<p>打开 <code>nullglob</code> 参数，就可以让不匹配的通配符返回空字符串。</p>
<div><pre><code>$ <span>shopt</span> -s nullglob
$ <span>rm</span> b*
rm: 缺少操作数
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>上面例子中，由于没有 <code>b*</code> 匹配的文件名，所以 <code>rm b*</code> 扩展成了 <code>rm</code>，导致报错变成了”缺少操作数“。</p>
</li>
<li>
<p><strong>failglob 参数</strong></p>
<p><code>failglob</code> 参数使得通配符不匹配任何文件名时，Bash 会直接报错，而不是让各个命令去处理。</p>
<div><pre><code>$ <span>shopt</span> -s failglob
$ <span>rm</span> b*
bash: 无匹配: b*
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>上面例子中，打开 <code>failglob</code> 以后，由于 <code>b*</code> 不匹配任何文件名，Bash 直接报错了，不再让 <code>rm</code> 命令去处理。</p>
</li>
<li>
<p><strong>extglob 参数</strong></p>
<p><code>extglob</code> 参数使得 Bash 支持 ksh 的一些扩展语法。它默认应该是打开的。</p>
<div><pre><code>$ <span>shopt</span> extglob
extglob         on
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>它的主要应用是支持量词语法。如果不希望支持量词语法，可以用下面的命令关闭。</p>
<div><pre><code><span>shopt</span> -u extglob
</code></pre>
<div><span>1</span><br></div></div></li>
<li>
<p><strong>nocaseglob 参数</strong></p>
<p><code>nocaseglob</code> 参数可以让通配符扩展不区分大小写。</p>
<div><pre><code>$ <span>shopt</span> -s nocaseglob
$ <span>ls</span> /windows/program*
/windows/ProgramData
/windows/Program Files
/windows/Program Files <span>(</span>x86<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>上面例子中，打开 <code>nocaseglob</code> 以后，<code>program*</code> 就不区分大小写了，可以匹配 <code>ProgramData</code> 等。</p>
</li>
<li>
<p><strong>globstar 参数</strong></p>
<p><code>globstar</code> 参数可以使得 <code>**</code> 匹配零个或多个子目录。该参数默认是关闭的。</p>
<p>假设有下面的文件结构。</p>
<div><pre><code>a.txt
sub1/b.txt
sub1/sub2/c.txt
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>上面的文件结构中，顶层目录、第一级子目录 <code>sub1</code>、第二级子目录 <code>sub1\sub2</code> 里面各有一个文本文件。请问怎样才能使用通配符，将它们显示出来?</p>
<p>默认情况下，只能写成下面这样。</p>
<div><pre><code>$ <span>ls</span> *.txt */*.txt */*/*.txt
a.txt  sub1/b.txt  sub1/sub2/c.txt
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>这是因为 <code>*</code> 只匹配当前目录，如果要匹配子目录，只能一层层写出来。</p>
<p>打开 <code>globstar</code> 参数以后，<code>**</code> 匹配零个或多个子目录。因此，<code>**/*.txt</code> 就可以得到想要的结果。</p>
<div><pre><code>$ <span>shopt</span> -s globstar
$ <span>ls</span> **/*.txt
a.txt  sub1/b.txt  sub1/sub2/c.txt
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div></li>
</ol>
<h2 id="参考链接"> 参考链接</h2>
<ul>
<li><a href="https://medium.com/@leedowthwaite/why-most-people-only-think-they-understand-wildcards-63bb9c2024ab" target="_blank" rel="noopener noreferrer">Think You Understand Wildcards? Think Again</a></li>
<li><a href="https://appcodelabs.com/advanced-wildcard-patterns-most-people-dont-know" target="_blank" rel="noopener noreferrer">Advanced Wildcard Patterns Most People Don’t Know</a></li>
</ul>
]]></content>
    <author>
      <name>阮一峰</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>阮一峰</name>
    </contributor>
    <rights>本教程采用&lt;a href="https://creativecommons.org/licenses/by-sa/3.0/deed.zh"&gt;知识共享 署名-相同方式共享 3.0协议&lt;/a&gt;</rights>
  </entry>
  <entry>
    <title type="html">Bash 函数</title>
    <id>http://qiqi.dreamagain.top/software/linux/bash/function/</id>
    <link href="http://qiqi.dreamagain.top/software/linux/bash/function/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <summary type="html"><![CDATA[<p>本章介绍 Bash 函数的用法。</p>
]]></summary>
    <content type="html"><![CDATA[<p>本章介绍 Bash 函数的用法。</p>

<h2 id="简介"> 简介</h2>
<p>函数(function)是可以重复使用的代码片段，有利于代码的复用。它与别名(alias)的区别是，别名只适合封装简单的单个命令，函数则可以封装复杂的多行命令。</p>
<p>函数总是在当前 Shell 执行，这是跟脚本的一个重大区别，Bash 会新建一个子 Shell 执行脚本。如果函数与脚本同名，函数会优先执行。但是，函数的优先级不如别名，即如果函数与别名同名，那么别名优先执行。</p>
<p>Bash 函数定义的语法有两种。</p>
<div><pre><code><span># 第一种</span>
<span>fn</span><span>(</span><span>)</span> <span>{</span>
  <span># codes</span>
<span>}</span>

<span># 第二种</span>
<span>function</span> <span>fn</span><span>(</span><span>)</span> <span>{</span>
  <span># codes</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>上面代码中，<code>fn</code> 是自定义的函数名，函数代码就写在大括号之中。这两种写法是等价的。</p>
<p>下面是一个简单函数的例子。</p>
<div><pre><code><span>hello</span><span>(</span><span>)</span> <span>{</span>
  <span>echo</span> <span>"Hello <span>$1</span>"</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>上面代码中，函数体里面的 <code>$1</code> 表示函数调用时的第一个参数。</p>
<p>调用时，就直接写函数名，参数跟在函数名后面。</p>
<div><pre><code>$ hello world
hello world
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>下面是一个多行函数的例子，显示当前日期时间。</p>
<div><pre><code><span>today</span><span>(</span><span>)</span> <span>{</span>
  <span>echo</span> -n <span>"Today's date is: "</span>
  <span>date</span> +<span>"%A, %B %-d, %Y"</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>删除一个函数，可以使用 <code>unset</code> 命令。</p>
<div><pre><code><span>unset</span> -f functionName
</code></pre>
<div><span>1</span><br></div></div><p>查看当前 Shell 已经定义的所有函数，可以使用 <code>declare</code> 命令。</p>
<div><pre><code><span>declare</span> -f
</code></pre>
<div><span>1</span><br></div></div><p>上面的 <code>declare</code> 命令不仅会输出函数名，还会输出所有定义。输出顺序是按照函数名的字母表顺序。由于会输出很多内容，最好通过管道命令配合 <code>more</code> 或 <code>less</code> 使用。</p>
<p><code>declare</code> 命令还支持查看单个函数的定义。</p>
<div><pre><code><span>declare</span> -f functionName
</code></pre>
<div><span>1</span><br></div></div><p><code>declare -F</code> 可以输出所有已经定义的函数名，不含函数体。</p>
<div><pre><code><span>declare</span> -F
</code></pre>
<div><span>1</span><br></div></div><h2 id="参数变量"> 参数变量</h2>
<p>函数体内可以使用参数变量，获取函数参数。函数的参数变量，与脚本参数变量是一致的。</p>
<ul>
<li><code>$1</code> ~ <code>$9</code>: 函数的第一个到第 9 个的参数。</li>
<li><code>$0</code>: 函数所在的脚本名。</li>
<li><code>$#</code>: 函数的参数总数。</li>
<li><code>$@</code>: 函数的全部参数，参数之间使用空格分隔。</li>
<li><code>$*</code>: 函数的全部参数，参数之间使用变量 <code>$IFS</code> 值的第一个字符分隔，默认为空格，但是可以自定义。</li>
</ul>
<p>如果函数的参数多于 9 个，那么第 10 个参数可以用 <code>${10}</code> 的形式引用，以此类推。</p>
<p>下面是一个示例脚本 <code>test.sh</code>。</p>
<div><pre><code><span>#!/bin/bash</span>
<span># test.sh</span>

<span>function</span> <span>alice</span> <span>{</span>
  <span>echo</span> <span>"alice: <span>$@</span>"</span>
  <span>echo</span> <span>"<span>$0</span>: <span>$1</span> <span>$2</span> <span>$3</span> <span>$4</span>"</span>
  <span>echo</span> <span>"<span>$#</span> arguments"</span>

<span>}</span>

alice <span>in</span> wonderland
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>运行该脚本，结果如下。</p>
<div><pre><code>$ <span>bash</span> test.sh
alice: <span>in</span> wonderland
test.sh: <span>in</span> wonderland
<span>2</span> arguments
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>上面例子中，由于函数 <code>alice</code> 只有第一个和第二个参数，所以第三个和第四个参数为空。</p>
<p>下面是一个日志函数的例子。</p>
<div><pre><code><span>function</span> <span>log_msg</span> <span>{</span>
  <span>echo</span> <span>"[<span><span>`</span><span>date</span> <span>'+ %F %T'</span><span>`</span></span> ]: <span>$@</span>"</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>使用方法如下。</p>
<div><pre><code>$ log_msg <span>"This is sample log message"</span>
<span>[</span> <span>2018</span>-08-16 <span>19</span>:56:34 <span>]</span>: This is sample log message
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h2 id="return-命令"> return 命令</h2>
<p><code>return</code> 命令用于从函数返回一个值。函数执行到这条命令，就不再往下执行了，直接返回了。</p>
<div><pre><code><span>function</span> <span>func_return_value</span> <span>{</span>
  <span>return</span> <span>10</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>函数将返回值返回给调用者。如果命令行直接执行函数，下一个命令可以用 <code>$?</code> 拿到返回值。</p>
<div><pre><code>$ func_return_value
$ <span>echo</span> <span>"Value returned by function is: <span>$?</span>"</span>
Value returned by <span>function</span> is: <span>10</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><code>return</code> 后面不跟参数，只用于返回也是可以的。</p>
<div><pre><code><span>function</span> <span>name</span> <span>{</span>
  commands
  <span>return</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h2 id="全局变量和局部变量-local-命令"> 全局变量和局部变量，local 命令</h2>
<p>Bash 函数体内直接声明的变量，属于全局变量，整个脚本都可以读取。这一点需要特别小心。</p>
<div><pre><code><span># 脚本 test.sh</span>
<span>fn</span> <span>(</span><span>)</span> <span>{</span>
  <span>foo</span><span>=</span><span>1</span>
  <span>echo</span> <span>"fn: foo = <span>$foo</span>"</span>
<span>}</span>

fn
<span>echo</span> <span>"global: foo = <span>$foo</span>"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>上面脚本的运行结果如下。</p>
<div><pre><code>$ <span>bash</span> test.sh
fn: foo <span>=</span> <span>1</span>
global: foo <span>=</span> <span>1</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>上面例子中，变量 <code>$foo</code> 是在函数 <code>fn</code> 内部声明的，函数体外也可以读取。</p>
<p>函数体内不仅可以声明全局变量，还可以修改全局变量。</p>
<div><pre><code><span>foo</span><span>=</span><span>1</span>

<span>fn</span> <span>(</span><span>)</span> <span>{</span>
  <span>foo</span><span>=</span><span>2</span>
<span>}</span>

<span>echo</span> <span>$foo</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>上面代码执行后，输出的变量 <code>$foo</code> 值为 2。</p>
<p>函数里面可以用 <code>local</code> 命令声明局部变量。</p>
<div><pre><code><span># 脚本 test.sh</span>
<span>fn</span> <span>(</span><span>)</span> <span>{</span>
  <span>local</span> foo
  <span>foo</span><span>=</span><span>1</span>
  <span>echo</span> <span>"fn: foo = <span>$foo</span>"</span>
<span>}</span>

fn
<span>echo</span> <span>"global: foo = <span>$foo</span>"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>上面脚本的运行结果如下。</p>
<div><pre><code>$ <span>bash</span> test.sh
fn: foo <span>=</span> <span>1</span>
global: foo <span>=</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>上面例子中，<code>local</code> 命令声明的 <code>$foo</code> 变量，只在函数体内有效，函数体外没有定义。</p>
<h2 id="参考链接"> 参考链接</h2>
<ul>
<li><a href="https://www.linuxtechi.com/define-use-functions-linux-shell-script/" target="_blank" rel="noopener noreferrer">How to define and use functions in Linux Shell Script</a>, by Pradeep Kumar</li>
</ul>
]]></content>
    <author>
      <name>阮一峰</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>阮一峰</name>
    </contributor>
    <rights>本教程采用&lt;a href="https://creativecommons.org/licenses/by-sa/3.0/deed.zh"&gt;知识共享 署名-相同方式共享 3.0协议&lt;/a&gt;</rights>
  </entry>
  <entry>
    <title type="html">Bash 的基本语法</title>
    <id>http://qiqi.dreamagain.top/software/linux/bash/grammar/</id>
    <link href="http://qiqi.dreamagain.top/software/linux/bash/grammar/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <summary type="html"><![CDATA[<p>本章介绍 Bash 的最基本语法。</p>
]]></summary>
    <content type="html"><![CDATA[<p>本章介绍 Bash 的最基本语法。</p>

<h2 id="echo-命令"> echo 命令</h2>
<p>由于后面的例子会大量用到 <code>echo</code> 命令，这里先介绍这个命令。</p>
<p><code>echo</code> 命令的作用是在屏幕输出一行文本，可以将该命令的参数原样输出。</p>
<div><pre><code>$ <span>echo</span> hello world
hello world
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>上面例子中，<code>echo</code> 的参数是 <code>hello world</code>，可以原样输出。</p>
<p>如果想要输出的是多行文本，即包括换行符。这时需要把多行文本放在引号里面。</p>
<div><pre><code>$ <span>echo</span> <span>"&lt;HTML>
    &lt;HEAD>
          &lt;TITLE>Page Title&lt;/TITLE>
    &lt;/HEAD>
    &lt;BODY>
          Page body.
    &lt;/BODY>
&lt;/HTML>"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>上面例子中，<code>echo</code> 可以原样输出多行文本。</p>
<h3 id="n-参数"> <code>-n</code> 参数</h3>
<p>默认情况下，<code>echo</code> 输出的文本末尾会有一个回车符。<code>-n</code> 参数可以取消末尾的回车符，使得下一个提示符紧跟在输出内容的后面。</p>
<div><pre><code>$ <span>echo</span> -n hello world
hello world$
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>上面例子中，<code>world</code> 后面直接就是下一行的提示符 <code>$</code>。</p>
<div><pre><code>$ <span>echo</span> a<span>;</span><span>echo</span> b
a
b

$ <span>echo</span> -n a<span>;</span><span>echo</span> b
ab
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>上面例子中，<code>-n</code> 参数可以让两个 <code>echo</code> 命令的输出连在一起，出现在同一行。</p>
<h3 id="e-参数"> <code>-e</code> 参数</h3>
<p><code>-e</code> 参数会解释引号(双引号和单引号)里面的特殊字符(比如换行符 <code>\n</code>)。如果不使用 <code>-e</code> 参数，即默认情况下，引号会让特殊字符变成普通字符，<code>echo</code> 不解释它们，原样输出。</p>
<div><pre><code>$ <span>echo</span> <span>"Hello<span title="\n">\n</span>World"</span>
Hello<span>\</span>nWorld

<span># 双引号的情况</span>
$ <span>echo</span> -e <span>"Hello<span title="\n">\n</span>World"</span>
Hello
World

<span># 单引号的情况</span>
$ <span>echo</span> -e <span>'Hello<span title="\n">\n</span>World'</span>
Hello
World
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>上面代码中，<code>-e</code> 参数使得 <code>\n</code> 解释为换行符，导致输出内容里面出现换行。</p>
<h2 id="命令格式"> 命令格式</h2>
<p>命令行环境中，主要通过使用 Shell 命令，进行各种操作。Shell 命令基本都是下面的格式。</p>
<div><pre><code><span>command</span> <span>[</span> arg1 <span>..</span>. <span>[</span> argN <span>]</span><span>]</span>
</code></pre>
<div><span>1</span><br></div></div><p>上面代码中，<code>command</code> 是具体的命令或者一个可执行文件，<code>arg1 ... argN</code> 是传递给命令的参数，它们是可选的。</p>
<div><pre><code><span>ls</span> -l
</code></pre>
<div><span>1</span><br></div></div><p>上面这个命令中，<code>ls</code> 是命令，<code>-l</code> 是参数。</p>
<p>有些参数是命令的配置项，这些配置项一般都以一个连词线开头，比如上面的 <code>-l</code>。同一个配置项往往有长和短两种形式，比如 <code>-l</code> 是短形式，<code>--list</code> 是长形式，它们的作用完全相同。短形式便于手动输入，长形式一般用在脚本之中，可读性更好，利于解释自身的含义。</p>
<div><pre><code><span># 短形式</span>
$ <span>ls</span> -r

<span># 长形式</span>
$ <span>ls</span> --reverse
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>上面命令中，<code>-r</code> 是短形式，<code>--reverse</code> 是长形式，作用完全一样。前者便于输入，后者便于理解。</p>
<p>Bash 单个命令一般都是一行，用户按下回车键，就开始执行。有些命令比较长，写成多行会有利于阅读和编辑，这时可以在每一行的结尾加上反斜杠，Bash 就会将下一行跟当前行放在一起解释。</p>
<div><pre><code>$ <span>echo</span> foo bar

<span># 等同于</span>
$ <span>echo</span> foo <span>\</span>
bar
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h2 id="空格"> 空格</h2>
<p>Bash 使用空格(或 Tab 键)区分不同的参数。</p>
<div><pre><code><span>command</span> foo bar
</code></pre>
<div><span>1</span><br></div></div><p>上面命令中，<code>foo</code> 和 <code>bar</code> 之间有一个空格，所以 Bash 认为它们是两个参数。</p>
<p>如果参数之间有多个空格，Bash 会自动忽略多余的空格。</p>
<div><pre><code>$ <span>echo</span> this is a     <span>test</span>
this is a <span>test</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>上面命令中，<code>a</code> 和 <code>test</code> 之间有多个空格，Bash 会忽略多余的空格。</p>
<h2 id="分号"> 分号</h2>
<p>分号(<code>;</code>)是命令的结束符，使得一行可以放置多个命令，上一个命令执行结束后，再执行第二个命令。</p>
<div><pre><code><span>clear</span><span>;</span> <span>ls</span>
</code></pre>
<div><span>1</span><br></div></div><p>上面例子中，Bash 先执行 <code>clear</code> 命令，执行完成后，再执行 <code>ls</code> 命令。</p>
<p>注意，使用分号时，第二个命令总是接着第一个命令执行，不管第一个命令执行成功或失败。</p>
<h2 id="命令的组合符-和"> 命令的组合符 <code>&amp;&amp;</code> 和 <code>||</code></h2>
<p>除了分号，Bash 还提供两个命令组合符 <code>&amp;&amp;</code> 和 <code>||</code>，允许更好地控制多个命令之间的继发关系。</p>
<div><pre><code>Command1 <span>&amp;&amp;</span> Command2
</code></pre>
<div><span>1</span><br></div></div><p>上面命令的意思是，如果 <code>Command1</code> 命令运行成功，则继续运行 <code>Command2</code> 命令。</p>
<div><pre><code>Command1 <span>||</span> Command2
</code></pre>
<div><span>1</span><br></div></div><p>上面命令的意思是，如果 <code>Command1</code> 命令运行失败，则继续运行 <code>Command2</code> 命令。</p>
<p>下面是一些例子。</p>
<div><pre><code><span>cat</span> filelist.txt <span>;</span> <span>ls</span> -l filelist.txt
</code></pre>
<div><span>1</span><br></div></div><p>上面例子中，只要 <code>cat</code> 命令执行结束，不管成功或失败，都会继续执行 <code>ls</code> 命令。</p>
<div><pre><code><span>cat</span> filelist.txt <span>&amp;&amp;</span> <span>ls</span> -l filelist.txt
</code></pre>
<div><span>1</span><br></div></div><p>上面例子中，只有 <code>cat</code> 命令执行成功，才会继续执行 <code>ls</code> 命令。如果 <code>cat</code> 执行失败(比如不存在文件 <code>flielist.txt</code>)，那么 <code>ls</code> 命令就不会执行。</p>
<div><pre><code><span>mkdir</span> foo <span>||</span> <span>mkdir</span> bar
</code></pre>
<div><span>1</span><br></div></div><p>上面例子中，只有 <code>mkdir foo</code> 命令执行失败(比如 <code>foo</code> 目录已经存在)，才会继续执行 <code>mkdir bar</code> 命令。如果 <code>mkdir foo</code> 命令执行成功，就不会创建 <code>bar</code> 目录了。</p>
<h2 id="type-命令"> type 命令</h2>
<p>Bash 本身内置了很多命令，同时也可以执行外部程序。怎么知道一个命令是内置命令，还是外部程序呢?</p>
<p><code>type</code> 命令用来判断命令的来源。</p>
<div><pre><code>$ <span>type</span> <span>echo</span>
<span>echo</span> is a shell <span>builtin</span>
$ <span>type</span> <span>ls</span>
<span>ls</span> is hashed <span>(</span>/bin/ls<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>上面代码中，<code>type</code> 命令告诉我们，<code>echo</code> 是内部命令，<code>ls</code> 是外部程序 (<code>/bin/ls</code>)。</p>
<p><code>type</code> 命令本身也是内置命令。</p>
<div><pre><code>$ <span>type</span> <span>type</span>
<span>type</span> is a shell <span>builtin</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>如果要查看一个命令的所有定义，可以使用 <code>type</code> 命令的 <code>-a</code> 参数。</p>
<div><pre><code>$ <span>type</span> -a <span>echo</span>
<span>echo</span> is shell <span>builtin</span>
<span>echo</span> is /usr/bin/echo
<span>echo</span> is /bin/echo
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>上面代码表示，<code>echo</code> 命令即是内置命令，也有对应的外部程序。</p>
<p><code>type</code> 命令的 <code>-t</code> 参数，可以返回一个命令的类型: 别名(alias)，关键词(keyword)，函数(function)，内置命令(builtin)和文件(file)。</p>
<div><pre><code>$ <span>type</span> -t <span>bash</span>
<span>file</span>
$ <span>type</span> -t <span>if</span>
keyword
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>上面例子中，<code>bash</code> 是文件，<code>if</code> 是关键词。</p>
<h2 id="快捷键"> 快捷键</h2>
<p>Bash 提供很多快捷键，可以大大方便操作。下面是一些最常用的快捷键，完整的介绍参见 <a href="./src/software/linux/bash/readline.html">行操作</a> 一章。</p>
<ul>
<li><code>Ctrl + L</code>: 清除屏幕并将当前行移到页面顶部。</li>
<li><code>Ctrl + C</code>: 中止当前正在执行的命令。</li>
<li><code>Shift + PageUp</code>: 向上滚动。</li>
<li><code>Shift + PageDown</code>: 向下滚动。</li>
<li><code>Ctrl + U</code>: 从光标位置删除到行首。</li>
<li><code>Ctrl + K</code>: 从光标位置删除到行尾。</li>
<li><code>Ctrl + D</code>: 关闭 Shell 会话。</li>
<li><code>↑</code>，<code>↓</code>: 浏览已执行命令的历史记录。</li>
</ul>
<p>除了上面的快捷键，Bash 还具有自动补全功能。命令输入到一半的时候，可以按下 Tab 键，Bash 会自动完成剩下的部分。比如，输入 <code>pw</code>，然后按一下 Tab 键，Bash 会自动补上 <code>d</code>。</p>
<p>除了命令的自动补全，Bash 还支持路径的自动补全。有时，需要输入很长的路径，这时只需要输入前面的部分，然后按下 Tab 键，就会自动补全后面的部分。如果有多个可能的选择，按两次 Tab 键，Bash 会显示所有选项，让您选择。</p>
]]></content>
    <author>
      <name>阮一峰</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>阮一峰</name>
    </contributor>
    <rights>本教程采用&lt;a href="https://creativecommons.org/licenses/by-sa/3.0/deed.zh"&gt;知识共享 署名-相同方式共享 3.0协议&lt;/a&gt;</rights>
  </entry>
  <entry>
    <title type="html">Bash 简介</title>
    <id>http://qiqi.dreamagain.top/software/linux/bash/intro/</id>
    <link href="http://qiqi.dreamagain.top/software/linux/bash/intro/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <summary type="html"><![CDATA[<p>Bash 是 Unix 系统和 Linux 系统的一种 Shell(命令行环境)，是目前绝大多数 Linux 发行版的默认 Shell。</p>
]]></summary>
    <content type="html"><![CDATA[<p>Bash 是 Unix 系统和 Linux 系统的一种 Shell(命令行环境)，是目前绝大多数 Linux 发行版的默认 Shell。</p>

<h2 id="shell-的含义"> Shell 的含义</h2>
<p>学习 Bash，首先需要理解 Shell 是什么。Shell 这个单词的原意是“外壳”，跟 kernel(内核)相对应，比喻内核外面的一层，即用户跟内核交互的对话界面。</p>
<p>具体来说，Shell 这个词有多种含义。</p>
<p>首先，Shell 是一个程序，提供一个与用户对话的环境。这个环境只有一个命令提示符，让用户从键盘输入命令，所以又称为命令行环境(commandline，简写为 CLI)。Shell 接收到用户输入的命令，将命令送入操作系统执行，并将结果返回给用户。本书中，除非特别指明，Shell 指的就是命令行环境。</p>
<p>其次，Shell 是一个命令解释器，解释用户输入的命令。它支持变量、条件判断、循环操作等语法，所以用户可以用 Shell 命令写出各种小程序，又称为脚本(script)。这些脚本都通过 Shell 的解释执行，而不通过编译。</p>
<p>最后，Shell 是一个工具箱，提供了各种小工具，供用户方便地使用操作系统的功能。</p>
<h2 id="shell-的种类"> Shell 的种类</h2>
<p>Shell 有很多种，只要能给用户提供命令行环境的程序，都可以看作是 Shell。</p>
<p>历史上，主要的 Shell 有下面这些。</p>
<ul>
<li>Bourne Shell(sh)</li>
<li>Bourne Again shell(bash)</li>
<li>C Shell(csh)</li>
<li>TENEX C Shell(tcsh)</li>
<li>Korn shell(ksh)</li>
<li>Z Shell(zsh)</li>
<li>Friendly Interactive Shell(fish)</li>
</ul>
<p>Bash 是目前最常用的 Shell，除非特别指明，下文的 Shell 和 Bash 当作同义词使用，可以互换。</p>
<p>下面的命令可以查看当前运行的 Shell。</p>
<div><pre><code>$ <span>echo</span> <span>$SHELL</span>
/bin/bash
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>下面的命令可以查看当前的 Linux 系统安装的所有 Shell。</p>
<div><pre><code><span>cat</span> /etc/shells
</code></pre>
<div><span>1</span><br></div></div><p>上面两个命令中，<code>$</code> 是命令行环境的提示符，用户只需要输入提示符后面的内容。</p>
<p>Linux 允许每个用户使用不同的 Shell，用户的默认 Shell 一般都是 Bash，或者与 Bash 兼容。</p>
<h2 id="命令行环境"> 命令行环境</h2>
<h3 id="终端模拟器"> 终端模拟器</h3>
<p>如果是不带有图形环境的 Linux 系统(比如专用于服务器的系统)，启动后就直接是命令行环境。</p>
<p>不过，现在大部分的 Linux 发行版，尤其是针对普通用户的发行版，都是图形环境。用户登录系统后，自动进入图形环境，需要自己启动终端模拟器，才能进入命令行环境。</p>
<p>所谓“终端模拟器”(terminal emulator)就是一个模拟命令行窗口的程序，让用户在一个窗口中使用命令行环境，并且提供各种附加功能，比如调整颜色、字体大小、行距等等。</p>
<p>不同 Linux 发行版(准确地说是不同的桌面环境)带有的终端程序是不一样的，比如 KDE 桌面环境的终端程序是 konsole，Gnome 桌面环境的终端程序是 gnome-terminal，用户也可以安装第三方的终端程序。所有终端程序，尽管名字不同，基本功能都是一样的，就是让用户可以进入命令行环境，使用 Shell。</p>
<h3 id="命令行提示符"> 命令行提示符</h3>
<p>进入命令行环境以后，用户会看到 Shell 的提示符。提示符往往是一串前缀，最后以一个美元符号 <code>$</code> 结尾，用户可以在这个符号后面输入各种命令。</p>
<div><pre><code><span>[</span>user@hostname<span>]</span> $
</code></pre>
<div><span>1</span><br></div></div><p>上面例子中，完整的提示符是 <code>[user@hostname] $</code>，其中前缀是用户名(<code>user</code>)加上 <code>@</code>，再加主机名(<code>hostname</code>)。比如，用户名是 <code>bill</code>，主机名是 <code>home-machine</code>，前缀就是 <code>bill@home-machine</code>。</p>
<p>注意，根用户(root)的提示符，不以美元符号 (<code>$</code>) 结尾，而以井号 (<code>#</code>) 结尾，用来提醒用户，现在具有根权限，可以执行各种操作，务必小心，不要出现误操作。这个符号是可以自己定义的，详见《命令提示符》一章。</p>
<p>为了简洁，后文的命令行提示符都只使用 <code>$</code> 表示。</p>
<h3 id="进入和退出方法"> 进入和退出方法</h3>
<p>进入命令行环境以后，一般就已经打开 Bash 了。如果您的 Shell 不是 Bash，可以输入 <code>bash</code> 命令启动 Bash。</p>
<div><pre><code><span>bash</span>
</code></pre>
<div><span>1</span><br></div></div><p>退出 Bash 环境，可以使用 <code>exit</code> 命令，也可以同时按下 <code>Ctrl + d</code>。</p>
<div><pre><code><span>exit</span>
</code></pre>
<div><span>1</span><br></div></div><p>Bash 的基本用法就是在命令行输入各种命令，非常直观。作为练习，可以试着输入 <code>pwd</code> 命令。按下回车键，就会显示当前所在的目录。</p>
<div><pre><code>$ <span>pwd</span>
/home/me
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>如果不小心输入了 <code>pwe</code>，会返回一个提示，表示输入出错，没有对应的可执行程序。</p>
<div><pre><code>$ pwe
bash: pwe: 未找到命令
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h2 id="shell-和-bash-的历史"> Shell 和 Bash 的历史</h2>
<p>Shell 伴随着 Unix 系统的诞生而诞生。</p>
<p>1969 年，Ken Thompson 和 Dennis Ritchie 开发了第一版的 Unix。</p>
<p>1971 年，Ken Thompson 编写了最初的 Shell，称为 Thompson shell，程序名是 <code>sh</code>，方便用户使用 Unix。</p>
<p>1973 年至 1975 年间，John R. Mashey 扩展了最初的 Thompson shell，添加了编程功能，使得 Shell 成为一种编程语言。这个版本的 Shell 称为 Mashey shell。</p>
<p>1976 年，Stephen Bourne 结合 Mashey shell 的功能，重写一个新的 Shell，称为 Bourne shell。</p>
<p>1978 年，加州大学伯克利分校的 Bill Joy 开发了 C shell，为 Shell 提供 C 语言的语法，程序名是 <code>csh</code>。它是第一个真正替代 <code>sh</code> 的 UNIX shell，被合并到 Berkeley UNIX 的 2BSD 版本中。</p>
<p>1979 年，UNIX 第七版发布，内置了 Bourne Shell，导致它成为 Unix 的默认 Shell。注意，Thompson shell、Mashey shell 和 Bourne shell 都是贝尔实验室的产品，程序名都是 <code>sh</code>。对于用户来说，它们是同一个东西，只是底层代码不同而已。</p>
<p>1983 年，David Korn 开发了 Korn shell，程序名是 <code>ksh</code>。</p>
<p>1985 年，Richard Stallman 成立了自由软件基金会(FSF)，由于 Shell 的版权属于贝尔公司，所以他决定写一个自由版权的、使用 GNU 许可证的 Shell 程序，避免 Unix 的版权争议。</p>
<p>1988 年，自由软件基金会的第一个付薪程序员 Brian Fox 写了一个 Shell，功能基本上是 Bourne shell 的克隆，叫做 Bourne-Again SHell，简称 Bash，程序名为 <code>bash</code>，任何人都可以免费使用。后来，它逐渐成为 Linux 系统的标准 Shell。</p>
<p>1989 年，Bash 发布 1.0 版。</p>
<p>1996 年，Bash 发布 2.0 版。</p>
<p>2004 年，Bash 发布 3.0 版。</p>
<p>2009 年，Bash 发布 4.0 版。</p>
<p>2019 年，Bash 发布 5.0 版。</p>
<p>用户可以通过 <code>bash</code> 命令的 <code>--version</code> 参数或者环境变量 <code>$BASH_VERSION</code>，查看本机的 Bash 版本。</p>
<div><pre><code>$ <span>bash</span> --version
GNU bash，版本 <span>5.0</span>.3<span>(</span><span>1</span><span>)</span>-release <span>(</span>x86_64-pc-linux-gnu<span>)</span>

<span># 或者</span>
$ <span>echo</span> <span>$BASH_VERSION</span>
<span>5.0</span>.3<span>(</span><span>1</span><span>)</span>-release
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div>]]></content>
    <author>
      <name>阮一峰</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>阮一峰</name>
    </contributor>
    <rights>本教程采用&lt;a href="https://creativecommons.org/licenses/by-sa/3.0/deed.zh"&gt;知识共享 署名-相同方式共享 3.0协议&lt;/a&gt;</rights>
  </entry>
  <entry>
    <title type="html">循环</title>
    <id>http://qiqi.dreamagain.top/software/linux/bash/loop/</id>
    <link href="http://qiqi.dreamagain.top/software/linux/bash/loop/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <summary type="html"><![CDATA[<p>Bash 提供三种循环语法 <code>for</code>、<code>while</code> 和 <code>until</code>。</p>
]]></summary>
    <content type="html"><![CDATA[<p>Bash 提供三种循环语法 <code>for</code>、<code>while</code> 和 <code>until</code>。</p>

<h2 id="while-循环"> while 循环</h2>
<p><code>while</code> 循环有一个判断条件，只要符合条件，就不断循环执行指定的语句。</p>
<div><pre><code><span>while</span> condition<span>;</span> <span>do</span>
  commands
<span>done</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>上面代码中，只要满足条件 <code>condition</code>，就会执行命令 <code>commands</code>。然后，再次判断是否满足条件 <code>condition</code>，只要满足，就会一直执行下去。只有不满足条件，才会退出循环。</p>
<p>循环条件 <code>condition</code> 可以使用 <code>test</code> 命令，跟 <code>if</code> 结构的判断条件写法一致。</p>
<div><pre><code><span>#!/bin/bash</span>

<span>number</span><span>=</span><span>0</span>
<span>while</span> <span>[</span> <span>"<span>$number</span>"</span> -lt <span>10</span> <span>]</span><span>;</span> <span>do</span>
  <span>echo</span> <span>"Number = <span>$number</span>"</span>
  <span>number</span><span>=</span><span><span>$((</span>number <span>+</span> <span>1</span><span>))</span></span>
<span>done</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>上面例子中，只要变量 <code>$number</code> 小于 10，就会不断加 1，直到 <code>$number</code> 等于 10，然后退出循环。</p>
<p>关键字 <code>do</code> 可以跟 <code>while</code> 不在同一行，这时两者之间不需要使用分号分隔。</p>
<div><pre><code><span>while</span> <span>true</span>
<span>do</span>
  <span>echo</span> <span>'Hi, while looping ...'</span><span>;</span>
<span>done</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>上面的例子会无限循环，可以按下 <code>Ctrl + c</code> 停止。</p>
<p><code>while</code> 循环写成一行，也是可以的。</p>
<div><pre><code><span>while</span> <span>true</span><span>;</span> <span>do</span> <span>echo</span> <span>'Hi, while looping ...'</span><span>;</span> <span>done</span>
</code></pre>
<div><span>1</span><br></div></div><p><code>while</code> 的条件部分也可以是执行一个命令。</p>
<div><pre><code><span>while</span> <span>echo</span> <span>'ECHO'</span><span>;</span> <span>do</span> <span>echo</span> <span>'Hi, while looping ...'</span><span>;</span> <span>done</span>
</code></pre>
<div><span>1</span><br></div></div><p>上面例子中，判断条件是 <code>echo 'ECHO'</code>。由于这个命令总是执行成功，所以上面命令会产生无限循环。</p>
<p><code>while</code> 的条件部分可以执行任意数量的命令，但是执行结果的真伪只看最后一个命令的执行结果。</p>
<div><pre><code><span>while</span> <span>true</span><span>;</span> <span>false</span><span>;</span> <span>do</span> <span>echo</span> <span>'Hi, looping ...'</span><span>;</span> <span>done</span>
</code></pre>
<div><span>1</span><br></div></div><p>上面代码运行后，不会有任何输出，因为 <code>while</code> 的最后一个命令是 <code>false</code>。</p>
<h2 id="until-循环"> until 循环</h2>
<p><code>until</code> 循环与 <code>while</code> 循环恰好相反，只要不符合判断条件(判断条件失败)，就不断循环执行指定的语句。一旦符合判断条件，就退出循环。</p>
<div><pre><code><span>until</span> condition<span>;</span> <span>do</span>
  commands
<span>done</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>关键字 <code>do</code> 可以与 <code>until</code> 不写在同一行，这时两者之间不需要分号分隔。</p>
<div><pre><code><span>until</span> condition
<span>do</span>
  commands
<span>done</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>下面是一个例子。</p>
<div><pre><code>$ <span>until</span> <span>false</span><span>;</span> <span>do</span> <span>echo</span> <span>'Hi, until looping ...'</span><span>;</span> <span>done</span>
Hi, <span>until</span> looping <span>..</span>.
Hi, <span>until</span> looping <span>..</span>.
Hi, <span>until</span> looping <span>..</span>.
^C
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>上面代码中，<code>until</code> 的部分一直为 <code>false</code>，导致命令无限运行，必须按下 <code>Ctrl + c</code> 终止。</p>
<div><pre><code><span>#!/bin/bash</span>

<span>number</span><span>=</span><span>0</span>
<span>until</span> <span>[</span> <span>"<span>$number</span>"</span> -ge <span>10</span> <span>]</span><span>;</span> <span>do</span>
  <span>echo</span> <span>"Number = <span>$number</span>"</span>
  <span>number</span><span>=</span><span><span>$((</span>number <span>+</span> <span>1</span><span>))</span></span>
<span>done</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>上面例子中，只要变量 <code>number</code> 小于 10，就会不断加 1，直到 <code>number</code> 大于等于 10，就退出循环。</p>
<p><code>until</code> 的条件部分也可以是一个命令，表示在这个命令执行成功之前，不断重复尝试。</p>
<div><pre><code><span>until</span> <span>cp</span> <span>$1</span> <span>$2</span><span>;</span> <span>do</span>
  <span>echo</span> <span>'Attempt to copy failed. waiting...'</span>
  <span>sleep</span> <span>5</span>
<span>done</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>上面例子表示，只要 <code>cp $1 $2</code> 这个命令执行不成功，就 5 秒钟后再尝试一次，直到成功为止。</p>
<p><code>until</code> 循环都可以转为 <code>while</code> 循环，只要把条件设为否定即可。上面这个例子可以改写如下。</p>
<div><pre><code><span>while</span> <span>!</span> <span>cp</span> <span>$1</span> <span>$2</span><span>;</span> <span>do</span>
  <span>echo</span> <span>'Attempt to copy failed. waiting...'</span>
  <span>sleep</span> <span>5</span>
<span>done</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>一般来说，<code>until</code> 用得比较少，完全可以统一都使用 <code>while</code>。</p>
<h2 id="for-in-循环"> <code>for...in</code> 循环</h2>
<p><code>for...in</code> 循环用于遍历列表的每一项。</p>
<div><pre><code><span>for</span> <span>variable</span> <span>in</span> list
<span>do</span>
  commands
<span>done</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>上面语法中，<code>for</code> 循环会依次从 <code>list</code> 列表中取出一项，作为变量 <code>variable</code>，然后在循环体中进行处理。</p>
<p>关键词 <code>do</code> 可以跟 <code>for</code> 写在同一行，两者使用分号分隔。</p>
<div><pre><code><span>for</span> <span>variable</span> <span>in</span> list<span>;</span> <span>do</span>
  commands
<span>done</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>下面是一个例子。</p>
<div><pre><code><span>#!/bin/bash</span>

<span>for</span> <span>i</span> <span>in</span> word1 word2 word3<span>;</span> <span>do</span>
  <span>echo</span> <span>$i</span>
<span>done</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>上面例子中，<code>word1 word2 word3</code> 是一个包含三个单词的列表，变量 <code>i</code> 依次等于 <code>word1</code>、<code>word2</code>、<code>word3</code>，命令 <code>echo $i</code> 则会相应地执行三次。</p>
<p>列表可以由通配符产生。</p>
<div><pre><code><span>for</span> <span>i</span> <span>in</span> *.png<span>;</span> <span>do</span>
  <span>ls</span> -l <span>$i</span>
<span>done</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>上面例子中，<code>*.png</code> 会替换成当前目录中所有 PNG 图片文件，变量 <code>i</code> 会依次等于每一个文件。</p>
<p>列表也可以通过子命令产生。</p>
<div><pre><code><span>#!/bin/bash</span>

<span>count</span><span>=</span><span>0</span>
<span>for</span> <span>i</span> <span>in</span> <span><span>$(</span><span>cat</span> ~/.bash_profile<span>)</span></span><span>;</span> <span>do</span>
  <span>count</span><span>=</span><span><span>$((</span>count <span>+</span> <span>1</span><span>))</span></span>
  <span>echo</span> <span>"Word <span>$count</span> (<span>$i</span>) contains <span><span>$(</span><span>echo</span> -n $i <span>|</span> <span>wc</span> -c<span>)</span></span> characters"</span>
<span>done</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>上面例子中，<code>cat ~/.bash_profile</code> 命令会输出 <code>~/.bash_profile</code> 文件的内容，然后通过遍历每一个词，计算该文件一共包含多少个词，以及每个词有多少个字符。</p>
<p><code>in list</code> 的部分可以省略，这时 <code>list</code> 默认等于脚本的所有参数 <code>$@</code>。但是，为了可读性，最好还是不要省略，参考下面的例子。</p>
<div><pre><code><span>for</span> filename<span>;</span> <span>do</span>
  <span>echo</span> <span>"<span>$filename</span>"</span>
<span>done</span>

<span># 等同于</span>

<span>for</span> <span>filename</span> <span>in</span> <span>"<span>$@</span>"</span> <span>;</span> <span>do</span>
  <span>echo</span> <span>"<span>$filename</span>"</span>
<span>done</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>在函数体中也是一样的，<code>for...in</code> 循环省略 <code>in list</code> 的部分，则 <code>list</code> 默认等于函数的所有参数。</p>
<h2 id="for-循环"> for 循环</h2>
<p><code>for</code> 循环还支持 C 语言的循环语法。</p>
<div><pre><code><span>for</span> <span><span>((</span> expression1<span>;</span> expression2<span>;</span> expression3 <span>))</span></span><span>;</span> <span>do</span>
  commands
<span>done</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>上面代码中，<code>expression1</code> 用来初始化循环条件，<code>expression2</code> 用来决定循环结束的条件，<code>expression3</code> 在每次循环迭代的末尾执行，用于更新值。</p>
<p>注意，循环条件放在双重圆括号之中。另外，圆括号之中使用变量，不必加上美元符号 <code>$</code>。</p>
<p>它等同于下面的 <code>while</code> 循环。</p>
<div><pre><code><span><span>((</span> expression1 <span>))</span></span>
<span>while</span> <span><span>((</span> expression2 <span>))</span></span><span>;</span> <span>do</span>
  commands
  <span><span>((</span> expression3 <span>))</span></span>
<span>done</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>下面是一个例子。</p>
<div><pre><code><span>for</span> <span><span>((</span> i<span>=</span><span>0</span><span>;</span> i<span>&lt;</span><span>5</span><span>;</span> i<span>=</span>i<span>+</span><span>1</span> <span>))</span></span><span>;</span> <span>do</span>
  <span>echo</span> <span>$i</span>
<span>done</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>上面代码中，初始化变量 <code>i</code> 的值为 0，循环执行的条件是 <code>i</code> 小于 5。每次循环迭代结束时，<code>i</code> 的值加 1。</p>
<p><code>for</code> 条件部分的三个语句，都可以省略。</p>
<div><pre><code><span>for</span> <span><span>((</span><span>;</span><span>;</span><span>))</span></span>
<span>do</span>
  <span>read</span> var
  <span>if</span> <span>[</span> <span>"<span>$var</span>"</span> <span>=</span> <span>"."</span> <span>]</span><span>;</span> <span>then</span>
    <span>break</span>
  <span>fi</span>
<span>done</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>上面脚本会反复读取命令行输入，直到用户输入了一个点(<code>.</code>)位为止，才会跳出循环。</p>
<h2 id="break-continue"> break，continue</h2>
<p>Bash 提供了两个内部命令 <code>break</code> 和 <code>continue</code>，用来在循环内部跳出循环。</p>
<p><code>break</code> 命令立即终止循环，程序继续执行循环块之后的语句，即不再执行剩下的循环。</p>
<div><pre><code><span>#!/bin/bash</span>

<span>for</span> <span>number</span> <span>in</span> <span>1</span> <span>2</span> <span>3</span> <span>4</span> <span>5</span> <span>6</span>
<span>do</span>
  <span>echo</span> <span>"number is <span>$number</span>"</span>
  <span>if</span> <span>[</span> <span>"<span>$number</span>"</span> <span>=</span> <span>"3"</span> <span>]</span><span>;</span> <span>then</span>
    <span>break</span>
  <span>fi</span>
<span>done</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>上面例子只会打印 3 行结果。一旦变量 <code>$number</code> 等于 3，就会跳出循环，不再继续执行。</p>
<p><code>continue</code> 命令立即终止本轮循环，开始执行下一轮循环。</p>
<div><pre><code><span>#!/bin/bash</span>

<span>while</span> <span>read</span> -p <span>"What file do you want to test?"</span> filename
<span>do</span>
  <span>if</span> <span>[</span> <span>!</span> -e <span>"<span>$filename</span>"</span> <span>]</span><span>;</span> <span>then</span>
    <span>echo</span> <span>"The file does not exist."</span>
    <span>continue</span>
  <span>fi</span>

  <span>echo</span> <span>"You entered a valid file.."</span>
<span>done</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>上面例子中，只要用户输入的文件不存在，<code>continue</code> 命令就会生效，直接进入下一轮循环(让用户重新输入文件名)，不再执行后面的打印语句。</p>
<h2 id="select-结构"> select 结构</h2>
<p><code>select</code> 结构主要用来生成简单的菜单。它的语法与 <code>for...in</code> 循环基本一致。</p>
<div><pre><code><span>select</span> name
<span>[</span>in list<span>]</span>
<span>do</span>
  commands
<span>done</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>Bash 会对 <code>select</code> 依次进行下面的处理。</p>
<ol>
<li><code>select</code> 生成一个菜单，内容是列表 <code>list</code> 的每一项，并且每一项前面还有一个数字编号。</li>
<li>Bash 提示用户选择一项，输入它的编号。</li>
<li>用户输入以后，Bash 会将该项的内容存在变量 <code>name</code>，该项的编号存入环境变量 <code>REPLY</code>。如果用户没有输入，就按回车键，Bash 会重新输出菜单，让用户选择。</li>
<li>执行命令体 <code>commands</code>。</li>
<li>执行结束后，回到第一步，重复这个过程。</li>
</ol>
<p>下面是一个例子。</p>
<div><pre><code><span>#!/bin/bash</span>
<span># select.sh</span>

<span>select</span> <span>brand</span> <span>in</span> Samsung Sony iphone symphony Walton
<span>do</span>
  <span>echo</span> <span>"You have chosen <span>$brand</span>"</span>
<span>done</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>执行上面的脚本，Bash 会输出一个品牌的列表，让用户选择。</p>
<div><pre><code>$ ./select.sh
<span>1</span><span>)</span> Samsung
<span>2</span><span>)</span> Sony
<span>3</span><span>)</span> iphone
<span>4</span><span>)</span> symphony
<span>5</span><span>)</span> Walton
<span>#?</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>如果用户没有输入编号，直接按回车键。Bash 就会重新输出一遍这个菜单，直到用户按下 <code>Ctrl + c</code>，退出执行。</p>
<p><code>select</code> 可以与 <code>case</code> 结合，针对不同项，执行不同的命令。</p>
<div><pre><code><span>#!/bin/bash</span>

<span>echo</span> <span>"Which Operating System do you like?"</span>

<span>select</span> <span>os</span> <span>in</span> Ubuntu LinuxMint Windows8 Windows7 WindowsXP
<span>do</span>
  <span>case</span> <span>$os</span> <span>in</span>
    <span>"Ubuntu"</span><span>|</span><span>"LinuxMint"</span><span>)</span>
      <span>echo</span> <span>"I also use <span>$os</span>."</span>
    <span>;</span><span>;</span>
    <span>"Windows8"</span> <span>|</span> <span>"Windows10"</span> <span>|</span> <span>"WindowsXP"</span><span>)</span>
      <span>echo</span> <span>"Why don't you try Linux?"</span>
    <span>;</span><span>;</span>
    *<span>)</span>
      <span>echo</span> <span>"Invalid entry."</span>
      <span>break</span>
    <span>;</span><span>;</span>
  <span>esac</span>
<span>done</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><p>上面例子中，<code>case</code> 针对用户选择的不同项，执行不同的命令。</p>
<h2 id="参考链接"> 参考链接</h2>
<ul>
<li><a href="https://linuxhint.com/bash_select_command/" target="_blank" rel="noopener noreferrer">Bash Select Command</a>, Fahmida Yesmin</li>
</ul>
]]></content>
    <author>
      <name>阮一峰</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>阮一峰</name>
    </contributor>
    <rights>本教程采用&lt;a href="https://creativecommons.org/licenses/by-sa/3.0/deed.zh"&gt;知识共享 署名-相同方式共享 3.0协议&lt;/a&gt;</rights>
  </entry>
  <entry>
    <title type="html">mktemp 命令，trap 命令</title>
    <id>http://qiqi.dreamagain.top/software/linux/bash/mktemp/</id>
    <link href="http://qiqi.dreamagain.top/software/linux/bash/mktemp/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <summary type="html"><![CDATA[<p>Bash 脚本有时需要创建临时文件或临时目录。常见的做法是，在 <code>/tmp</code> 目录里面创建文件或目录，这样做有很多弊端，使用 <code>mktemp</code> 命令是最安全的做法。</p>
]]></summary>
    <content type="html"><![CDATA[<p>Bash 脚本有时需要创建临时文件或临时目录。常见的做法是，在 <code>/tmp</code> 目录里面创建文件或目录，这样做有很多弊端，使用 <code>mktemp</code> 命令是最安全的做法。</p>

<h2 id="临时文件的安全问题"> 临时文件的安全问题</h2>
<p>直接创建临时文件，尤其在 <code>/tmp</code> 目录里面，往往会导致安全问题。</p>
<p>首先，<code>/tmp</code> 目录是所有人可读写的，任何用户都可以往该目录里面写文件。创建的临时文件也是所有人可读的。</p>
<div><pre><code>$ <span>touch</span> /tmp/info.txt
$ <span>ls</span> -l /tmp/info.txt
-rw-r--r-- <span>1</span> ruanyf ruanyf <span>0</span> <span>12</span>月 <span>28</span> <span>17</span>:12 /tmp/info.txt
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>上面命令在 <code>/tmp</code> 目录直接创建文件，该文件默认是所有人可读的。</p>
<p>其次，如果攻击者知道临时文件的文件名，他可以创建符号链接，链接到临时文件，可能导致系统运行异常。攻击者也可能向脚本提供一些恶意数据。因此，临时文件最好使用不可预测、每次都不一样的文件名，防止被利用。</p>
<p>最后，临时文件使用完毕，应该删除。但是，脚本意外退出时，往往会忽略清理临时文件。</p>
<p>生成临时文件应该遵循下面的规则。</p>
<blockquote>
<ul>
<li>创建前检查文件是否已经存在。</li>
<li>确保临时文件已成功创建。</li>
<li>临时文件必须有权限的限制。</li>
<li>临时文件要使用不可预测的文件名。</li>
<li>脚本退出时，要删除临时文件(使用 <code>trap</code> 命令)。</li>
</ul>
</blockquote>
<h2 id="mktemp-命令的用法"> mktemp 命令的用法</h2>
<p><code>mktemp</code> 命令就是为安全创建临时文件而设计的。虽然在创建临时文件之前，它不会检查临时文件是否存在，但是它支持唯一文件名和清除机制，因此可以减轻安全攻击的风险。</p>
<p>直接运行 <code>mktemp</code> 命令，就能生成一个临时文件。</p>
<div><pre><code>$ mktemp
/tmp/tmp.4GcsWSG4vj

$ <span>ls</span> -l /tmp/tmp.4GcsWSG4vj
-rw------- <span>1</span> ruanyf ruanyf <span>0</span> <span>12</span>月 <span>28</span> <span>12</span>:49 /tmp/tmp.4GcsWSG4vj
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>上面命令中，<code>mktemp</code> 命令生成的临时文件名是随机的，而且权限是只有用户本人可读写。</p>
<p>Bash 脚本使用 <code>mktemp</code> 命令的用法如下。</p>
<div><pre><code><span>#!/bin/bash</span>

<span>TMPFILE</span><span>=</span><span><span>$(</span>mktemp<span>)</span></span>
<span>echo</span> <span>"Our temp file is <span>$TMPFILE</span>"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>为了确保临时文件创建成功，<code>mktemp</code> 命令后面最好使用 OR 运算符 (<code>||</code>)，保证创建失败时退出脚本。</p>
<div><pre><code><span>#!/bin/bash</span>

<span>TMPFILE</span><span>=</span><span><span>$(</span>mktemp<span>)</span></span> <span>||</span> <span>exit</span> <span>1</span>
<span>echo</span> <span>"Our temp file is <span>$TMPFILE</span>"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>为了保证脚本退出时临时文件被删除，可以使用 <code>trap</code> 命令指定退出时的清除操作。</p>
<div><pre><code><span>#!/bin/bash</span>

<span>trap</span> <span>'rm -f "<span>$TMPFILE</span>"'</span> EXIT

<span>TMPFILE</span><span>=</span><span><span>$(</span>mktemp<span>)</span></span> <span>||</span> <span>exit</span> <span>1</span>
<span>echo</span> <span>"Our temp file is <span>$TMPFILE</span>"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h2 id="mktemp-命令的参数"> mktemp 命令的参数</h2>
<p><code>-d</code> 参数可以创建一个临时目录。</p>
<div><pre><code>$ mktemp -d
/tmp/tmp.Wcau5UjmN6
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><code>-p</code> 参数可以指定临时文件所在的目录。默认是使用 <code>$TMPDIR</code> 环境变量指定的目录，如果这个变量没设置，那么使用 <code>/tmp</code> 目录。</p>
<div><pre><code>$ mktemp -p /home/ruanyf/
/home/ruanyf/tmp.FOKEtvs2H3
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><code>-t</code> 参数可以指定临时文件的文件名模板，模板的末尾必须至少包含三个连续的 <code>X</code> 字符，表示随机字符，建议至少使用六个 <code>X</code>。默认的文件名模板是 <code>tmp.</code> 后接十个随机字符。</p>
<div><pre><code>$ mktemp -t mytemp.XXXXXXX
/tmp/mytemp.yZ1HgZV
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h2 id="trap-命令"> trap 命令</h2>
<p><code>trap</code> 命令用来在 Bash 脚本中响应系统信号。</p>
<p>最常见的系统信号就是 SIGINT(中断)，即按 <code>Ctrl + C</code> 所产生的信号。<code>trap</code> 命令的 <code>-l</code> 参数，可以列出所有的系统信号。</p>
<div><pre><code>$ <span>trap</span> -l
 <span>1</span><span>)</span> SIGHUP  <span>2</span><span>)</span> SIGINT  <span>3</span><span>)</span> SIGQUIT  <span>4</span><span>)</span> SIGILL  <span>5</span><span>)</span> SIGTRAP
 <span>6</span><span>)</span> SIGABRT  <span>7</span><span>)</span> SIGBUS  <span>8</span><span>)</span> SIGFPE  <span>9</span><span>)</span> SIGKILL <span>10</span><span>)</span> SIGUSR1
<span>11</span><span>)</span> SIGSEGV <span>12</span><span>)</span> SIGUSR2 <span>13</span><span>)</span> SIGPIPE <span>14</span><span>)</span> SIGALRM <span>15</span><span>)</span> SIGTERM
<span>16</span><span>)</span> SIGSTKFLT <span>17</span><span>)</span> SIGCHLD <span>18</span><span>)</span> SIGCONT <span>19</span><span>)</span> SIGSTOP <span>20</span><span>)</span> SIGTSTP
<span>21</span><span>)</span> SIGTTIN <span>22</span><span>)</span> SIGTTOU <span>23</span><span>)</span> SIGURG <span>24</span><span>)</span> SIGXCPU <span>25</span><span>)</span> SIGXFSZ
<span>26</span><span>)</span> SIGVTALRM <span>27</span><span>)</span> SIGPROF <span>28</span><span>)</span> SIGWINCH <span>29</span><span>)</span> SIGIO <span>30</span><span>)</span> SIGPWR
<span>31</span><span>)</span> SIGSYS <span>34</span><span>)</span> SIGRTMIN <span>35</span><span>)</span> SIGRTMIN+1 <span>36</span><span>)</span> SIGRTMIN+2 <span>37</span><span>)</span> SIGRTMIN+3
<span>38</span><span>)</span> SIGRTMIN+4 <span>39</span><span>)</span> SIGRTMIN+5 <span>40</span><span>)</span> SIGRTMIN+6 <span>41</span><span>)</span> SIGRTMIN+7 <span>42</span><span>)</span> SIGRTMIN+8
<span>43</span><span>)</span> SIGRTMIN+9 <span>44</span><span>)</span> SIGRTMIN+10 <span>45</span><span>)</span> SIGRTMIN+11 <span>46</span><span>)</span> SIGRTMIN+12 <span>47</span><span>)</span> SIGRTMIN+13
<span>48</span><span>)</span> SIGRTMIN+14 <span>49</span><span>)</span> SIGRTMIN+15 <span>50</span><span>)</span> SIGRTMAX-14 <span>51</span><span>)</span> SIGRTMAX-13 <span>52</span><span>)</span> SIGRTMAX-12
<span>53</span><span>)</span> SIGRTMAX-11 <span>54</span><span>)</span> SIGRTMAX-10 <span>55</span><span>)</span> SIGRTMAX-9 <span>56</span><span>)</span> SIGRTMAX-8 <span>57</span><span>)</span> SIGRTMAX-7
<span>58</span><span>)</span> SIGRTMAX-6 <span>59</span><span>)</span> SIGRTMAX-5 <span>60</span><span>)</span> SIGRTMAX-4 <span>61</span><span>)</span> SIGRTMAX-3 <span>62</span><span>)</span> SIGRTMAX-2
<span>63</span><span>)</span> SIGRTMAX-1 <span>64</span><span>)</span> SIGRTMAX
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p><code>trap</code> 的命令格式如下。</p>
<div><pre><code><span>trap</span> <span>[</span>动作<span>]</span> <span>[</span>信号1<span>]</span> <span>[</span>信号2<span>]</span> <span>..</span>.
</code></pre>
<div><span>1</span><br></div></div><p>上面代码中，“动作”是一个 Bash 命令，“信号”常用的有以下几个。</p>
<blockquote>
<ul>
<li>HUP: 编号 1，脚本与所在的终端脱离联系。</li>
<li>INT: 编号 2，用户按下 Ctrl + C，意图让脚本中止运行。</li>
<li>QUIT: 编号 3，用户按下 Ctrl + 斜杠，意图退出脚本。</li>
<li>KILL: 编号 9，该信号用于杀死进程。</li>
<li>TERM: 编号 15，这是 <code>kill</code> 命令发出的默认信号。</li>
<li>EXIT: 编号 0，这不是系统信号，而是 Bash 脚本特有的信号，不管什么情况，只要退出脚本就会产生。</li>
</ul>
</blockquote>
<p><code>trap</code> 命令响应 <code>EXIT</code> 信号的写法如下。</p>
<div><pre><code><span>trap</span> <span>'rm -f "<span>$TMPFILE</span>"'</span> EXIT
</code></pre>
<div><span>1</span><br></div></div><p>上面命令中，脚本遇到 <code>EXIT</code> 信号时，就会执行 <code>rm -f &quot;$TMPFILE&quot;</code>。</p>
<p>trap 命令的常见使用场景，就是在 Bash 脚本中指定退出时执行的清理命令。</p>
<div><pre><code><span>#!/bin/bash</span>

<span>trap</span> <span>'rm -f "<span>$TMPFILE</span>"'</span> EXIT

<span>TMPFILE</span><span>=</span><span><span>$(</span>mktemp<span>)</span></span> <span>||</span> <span>exit</span> <span>1</span>
<span>ls</span> /etc <span>></span> <span>$TMPFILE</span>
<span>if</span> <span>grep</span> -qi <span>"kernel"</span> <span>$TMPFILE</span><span>;</span> <span>then</span>
  <span>echo</span> <span>'find'</span>
<span>fi</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>上面代码中，不管是脚本正常执行结束，还是用户按 <code>Ctrl + C</code> 终止，都会产生 <code>EXIT</code> 信号，从而触发删除临时文件。</p>
<p>注意，<code>trap</code> 命令必须放在脚本的开头。否则，它上方的任何命令导致脚本退出，都不会被它捕获。</p>
<p>如果 <code>trap</code> 需要触发多条命令，可以封装一个 Bash 函数。</p>
<div><pre><code><span>function</span> <span>egress</span> <span>{</span>
  command1
  command2
  command3
<span>}</span>

<span>trap</span> egress EXIT
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h2 id="参考链接"> 参考链接</h2>
<ul>
<li><a href="https://www.putorius.net/working-with-temporary-files.html" target="_blank" rel="noopener noreferrer">Working with Temporary Files and Directories in Shell Scripts</a>, Steven Vona</li>
<li><a href="https://www.putorius.net/using-trap-to-exit-bash-scripts-cleanly.html" target="_blank" rel="noopener noreferrer">Using Trap to Exit Bash Scripts Cleanly</a></li>
<li><a href="https://mywiki.wooledge.org/SignalTrap" target="_blank" rel="noopener noreferrer">Sending and Trapping Signals</a></li>
</ul>
]]></content>
    <author>
      <name>阮一峰</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>阮一峰</name>
    </contributor>
    <rights>本教程采用&lt;a href="https://creativecommons.org/licenses/by-sa/3.0/deed.zh"&gt;知识共享 署名-相同方式共享 3.0协议&lt;/a&gt;</rights>
  </entry>
  <entry>
    <title type="html">命令提示符</title>
    <id>http://qiqi.dreamagain.top/software/linux/bash/prompt/</id>
    <link href="http://qiqi.dreamagain.top/software/linux/bash/prompt/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <summary type="html"><![CDATA[<p>用户进入 Bash 以后，Bash 会显示一个命令提示符，用来提示用户在该位置后面输入命令。</p>
]]></summary>
    <content type="html"><![CDATA[<p>用户进入 Bash 以后，Bash 会显示一个命令提示符，用来提示用户在该位置后面输入命令。</p>

<h2 id="环境变量-ps1"> 环境变量 PS1</h2>
<p>命令提示符通常是美元符号 <code>$</code>，对于根用户则是井号 <code>#</code>。这个符号是环境变量 <code>PS1</code> 决定的，执行下面的命令，可以看到当前命令提示符的定义。</p>
<div><pre><code><span>echo</span> <span>$PS1</span>
</code></pre>
<div><span>1</span><br></div></div><p>Bash 允许用户自定义命令提示符，只要改写这个变量即可。改写后 的 <code>PS1</code>，可以放在用户的 Bash 配置文件 <code>.bashrc</code> 里面，以后新建 Bash 对话时，新的提示符就会生效。要在当前窗口看到修改后的提示符，可以执行下面的命令。</p>
<div><pre><code><span>source</span> ~/.bashrc
</code></pre>
<div><span>1</span><br></div></div><p>命令提示符的定义，可以包含特殊的转义字符，表示特定内容。</p>
<ul>
<li><code>\a</code>: 响铃，计算机发出一记声音。</li>
<li><code>\d</code>: 以星期、月、日格式表示当前日期，例如“Mon May 26”。</li>
<li><code>\h</code>: 本机的主机名。</li>
<li><code>\H</code>: 完整的主机名。</li>
<li><code>\j</code>: 运行在当前 Shell 会话的工作数。</li>
<li><code>\l</code>: 当前终端设备名。</li>
<li><code>\n</code>: 一个换行符。</li>
<li><code>\r</code>: 一个回车符。</li>
<li><code>\s</code>: Shell 的名称。</li>
<li><code>\t</code>: 24 小时制的 <code>hours:minutes:seconds</code> 格式表示当前时间。</li>
<li><code>\T</code>: 12 小时制的当前时间。</li>
<li><code>\@</code>: 12 小时制的 <code>AM/PM</code> 格式表示当前时间。</li>
<li><code>\A</code>: 24 小时制的 <code>hours:minutes</code> 表示当前时间。</li>
<li><code>\u</code>: 当前用户名。</li>
<li><code>\v</code>: Shell 的版本号。</li>
<li><code>\V</code>: Shell 的版本号和发布号。</li>
<li><code>\w</code>: 当前的工作路径。</li>
<li><code>\W</code>: 当前目录名。</li>
<li><code>\!</code>: 当前命令在命令历史中的编号。</li>
<li><code>\#</code>: 当前 shell 会话中的命令数。</li>
<li><code>\$</code>: 普通用户显示为 <code>$</code> 字符，根用户显示为 <code>#</code> 字符。</li>
<li><code>\[</code>: 非打印字符序列的开始标志。</li>
<li><code>\]</code>: 非打印字符序列的结束标志。</li>
</ul>
<p>举例来说，<code>[\u@\h \W]\$</code> 这个提示符定义，显示出来就是 <code>[user@host ~]$</code> (具体的显示内容取决于您的系统)。</p>
<div><pre><code><span>[</span>user@host ~<span>]</span>$ <span>echo</span> <span>$PS1</span>
<span>[</span><span>\</span>u@<span>\</span>h <span>\</span>W<span>]</span><span>\</span>$
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>改写 <code>PS1</code> 变量，就可以改变这个命令提示符。</p>
<div><pre><code>$ <span><span>PS1</span></span><span>=</span><span>"\A \h \$ "</span>
<span>17</span>:33 <span>host</span> $
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>注意，<code>$</code> 后面最好跟一个空格，这样的话，用户的输入与提示符就不会连在一起。</p>
<h2 id="颜色"> 颜色</h2>
<p>默认情况下，命令提示符是显示终端预定义的颜色。Bash 允许自定义提示符颜色。</p>
<p>使用下面的代码，可以设定其后文本的颜色。</p>
<ul>
<li><code>\033[0;30m</code>: 黑色</li>
<li><code>\033[1;30m</code>: 深灰色</li>
<li><code>\033[0;31m</code>: 红色</li>
<li><code>\033[1;31m</code>: 浅红色</li>
<li><code>\033[0;32m</code>: 绿色</li>
<li><code>\033[1;32m</code>: 浅绿色</li>
<li><code>\033[0;33m</code>: 棕色</li>
<li><code>\033[1;33m</code>: 黄色</li>
<li><code>\033[0;34m</code>: 蓝色</li>
<li><code>\033[1;34m</code>: 浅蓝色</li>
<li><code>\033[0;35m</code>: 粉红</li>
<li><code>\033[1;35m</code>: 浅粉色</li>
<li><code>\033[0;36m</code>: 青色</li>
<li><code>\033[1;36m</code>: 浅青色</li>
<li><code>\033[0;37m</code>: 浅灰色</li>
<li><code>\033[1;37m</code>: 白色</li>
</ul>
<p>举例来说，如果要将提示符设为红色，可以将 <code>PS1</code> 设成下面的代码。</p>
<div><pre><code><span><span>PS1</span></span><span>=</span><span>'\[<span title="\033">\033</span>[0;31m\]&lt;\u@\h \W>\$'</span>
</code></pre>
<div><span>1</span><br></div></div><p>但是，上面这样设置以后，用户在提示符后面输入的文本也是红色的。为了解决这个问题， 可以在结尾添加另一个特殊代码 <code>\[\033[00m\]</code>，表示将其后的文本恢复到默认颜色。</p>
<div><pre><code><span><span>PS1</span></span><span>=</span><span>'\[<span title="\033">\033</span>[0;31m\]&lt;\u@\h \W>\$\[<span title="\033">\033</span>[00m\]'</span>
</code></pre>
<div><span>1</span><br></div></div><p>除了设置前景颜色，Bash 还允许设置背景颜色。</p>
<ul>
<li><code>\033[0;40m</code>: 蓝色</li>
<li><code>\033[1;44m</code>: 黑色</li>
<li><code>\033[0;41m</code>: 红色</li>
<li><code>\033[1;45m</code>: 粉红</li>
<li><code>\033[0;42m</code>: 绿色</li>
<li><code>\033[1;46m</code>: 青色</li>
<li><code>\033[0;43m</code>: 棕色</li>
<li><code>\033[1;47m</code>: 浅灰色</li>
</ul>
<p>下面是一个带有红色背景的提示符。</p>
<div><pre><code><span><span>PS1</span></span><span>=</span><span>'\[<span title="\033">\033</span>[0;41m\]&lt;\u@\h \W>\$\[<span title="\033">\033</span>[0m\] '</span>
</code></pre>
<div><span>1</span><br></div></div><h2 id="环境变量-ps2-ps3-ps4"> 环境变量 PS2，PS3，PS4</h2>
<p>除了 <code>PS1</code>，Bash 还提供了提示符相关的另外三个环境变量。</p>
<p>环境变量 <code>PS2</code> 是命令行折行输入时系统的提示符，默认为 <code>&gt;</code>。</p>
<div><pre><code>$ <span>echo</span> <span>"hello
> world"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>上面命令中，输入 <code>hello</code> 以后按下回车键，系统会提示继续输入。这时，第二行显示的提示符就是 <code>PS2</code> 定义的 <code>&gt;</code>。</p>
<p>环境变量 <code>PS3</code> 是使用 <code>select</code> 命令时，系统输入菜单的提示符。</p>
<p>环境变量 <code>PS4</code> 默认为 <code>+</code>。它是使用 Bash 的 <code>-x</code> 参数执行脚本时，每一行命令在执行前都会先打印出来，并且在行首出现的那个提示符。</p>
<p>比如下面是脚本 <code>test.sh</code>。</p>
<div><pre><code><span>#!/bin/bash</span>

<span>echo</span> <span>"hello world"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>使用 <code>-x</code> 参数执行这个脚本。</p>
<div><pre><code>$ <span>bash</span> -x test.sh
+ <span>echo</span> <span>'hello world'</span>
hello world
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>上面例子中，输出的第一行前面有一个 <code>+</code>，这就是变量 <code>PS4</code> 定义的。</p>
]]></content>
    <author>
      <name>阮一峰</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>阮一峰</name>
    </contributor>
    <rights>本教程采用&lt;a href="https://creativecommons.org/licenses/by-sa/3.0/deed.zh"&gt;知识共享 署名-相同方式共享 3.0协议&lt;/a&gt;</rights>
  </entry>
  <entry>
    <title type="html">引号和转义</title>
    <id>http://qiqi.dreamagain.top/software/linux/bash/quotation/</id>
    <link href="http://qiqi.dreamagain.top/software/linux/bash/quotation/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <summary type="html"><![CDATA[<p>Bash 只有一种数据类型，就是字符串。不管用户输入什么数据，Bash 都视为字符串。因此，字符串相关的引号和转义，对 Bash 来说就非常重要。</p>
]]></summary>
    <content type="html"><![CDATA[<p>Bash 只有一种数据类型，就是字符串。不管用户输入什么数据，Bash 都视为字符串。因此，字符串相关的引号和转义，对 Bash 来说就非常重要。</p>

<h2 id="转义"> 转义</h2>
<p>某些字符在 Bash 里面有特殊含义(比如<code>$</code>、<code>&amp;</code>、<code>*</code>)。</p>
<div><pre><code>$ <span>echo</span> <span>$date</span>

$
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>上面例子中，输出 <code>$date</code> 不会有任何结果，因为 <code>$</code> 是一个特殊字符。</p>
<p>如果想要原样输出这些特殊字符，就必须在它们前面加上反斜杠，使其变成普通字符。这就叫做“转义”(escape)。</p>
<div><pre><code>$ <span>echo</span> <span>\</span><span>$date</span>
<span>$date</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>上面命令中，只有在特殊字符 <code>$</code> 前面加反斜杠，才能原样输出。</p>
<p>反斜杠本身也是特殊字符，如果想要原样输出反斜杠，就需要对它自身转义，连续使用两个反斜线 (<code>\\</code>)。</p>
<div><pre><code>$ <span>echo</span> <span>\</span><span>\</span>
<span>\</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>上面例子输出了反斜杠本身。</p>
<p>反斜杠除了用于转义，还可以表示一些不可打印的字符。</p>
<ul>
<li><code>\a</code>: 响铃</li>
<li><code>\b</code>: 退格</li>
<li><code>\n</code>: 换行</li>
<li><code>\r</code>: 回车</li>
<li><code>\t</code>: 制表符</li>
</ul>
<p>如果想要在命令行使用这些不可打印的字符，可以把它们放在引号里面，然后使用 <code>echo</code> 命令的 <code>-e</code> 参数。</p>
<div><pre><code>$ <span>echo</span> a<span>\</span>tb
atb

$ <span>echo</span> -e <span>"a<span title="\t">\t</span>b"</span>
a        b
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>上面例子中，命令行直接输出不可打印字符，Bash 不能正确解释。必须把它们放在引号之中，然后使用 <code>echo</code> 命令的 <code>-e</code> 参数。</p>
<p>由于反斜杠可以对换行符转义，使得 Bash 认为换行符是一个普通字符，从而可以将一行命令写成多行。</p>
<div><pre><code>$ <span>mv</span> <span>\</span>
/path/to/foo <span>\</span>
/path/to/bar

<span># 等同于</span>
$ <span>mv</span> /path/to/foo /path/to/bar
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>上面例子中，如果一条命令过长，就可以在行尾使用反斜杠，将其改写成多行。这是常见的多行命令的写法。</p>
<h2 id="单引号"> 单引号</h2>
<p>Bash 允许字符串放在单引号或双引号之中，加以引用。</p>
<p>单引号用于保留字符的字面含义，各种特殊字符在单引号里面，都会变为普通字符，比如星号 (<code>*</code>)、美元符号( <code>$</code>)、反斜杠 (<code>\</code>)等。</p>
<div><pre><code>$ <span>echo</span> <span>'*'</span>
*

$ <span>echo</span> <span>'<span>$USER</span>'</span>
<span>$USER</span>

$ <span>echo</span> <span>'<span><span>$((</span><span>2</span><span>+</span><span>2</span><span>))</span></span>'</span>
<span><span>$((</span><span>2</span><span>+</span><span>2</span><span>))</span></span>

$ <span>echo</span> <span>'<span><span>$(</span><span>echo</span> foo<span>)</span></span>'</span>
<span><span>$(</span><span>echo</span> foo<span>)</span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>上面命令中，单引号使得 Bash 扩展、变量引用、算术运算和子命令，都失效了。如果不使用单引号，它们都会被 Bash 自动扩展。</p>
<p>由于反斜杠在单引号里面变成了普通字符，所以如果单引号之中，还要使用单引号，不能使用转义，需要在外层的单引号前面加上一个美元符号 (<code>$</code>)，然后再对里层的单引号转义。</p>
<div><pre><code><span># 不正确</span>
$ <span>echo</span> it<span>'s

# 不正确
$ echo '</span>it<span>\</span>'s<span>'

# 正确
$ echo $'</span>it<span>\</span>'s'
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>不过，更合理的方法是改在双引号之中使用单引号。</p>
<div><pre><code>$ <span>echo</span> <span>"it's"</span>
it's
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h2 id="双引号"> 双引号</h2>
<p>双引号比单引号宽松，可以保留大部分特殊字符的本来含义，但是三个字符除外: 美元符号(<code>$</code>)、反引号(<code>`</code>)和反斜杠(<code>\</code>)。也就是说，这三个字符在双引号之中，会被 Bash 自动扩展。</p>
<div><pre><code>$ <span>echo</span> <span>"*"</span>
*
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>上面例子中，通配符 <code>*</code> 放在双引号之中，就变成了普通字符，会原样输出。这一点需要特别留意，双引号里面不会进行文件名扩展。</p>
<div><pre><code>$ <span>echo</span> <span>"<span>$SHELL</span>"</span>
/bin/bash

$ <span>echo</span> <span>"<span><span>`</span><span>date</span><span>`</span></span>"</span>
Mon Jan <span>27</span> <span>13</span>:33:18 CST <span>2020</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>上面例子中，美元符号和反引号在双引号中，都保持特殊含义。美元符号用来引用变量，反引号则是执行子命令。</p>
<div><pre><code>$ <span>echo</span> <span>"I'd say: <span title="\&quot;">\"</span>hello!<span title="\&quot;">\"</span>"</span>
I'd say: <span>"hello!"</span>

$ <span>echo</span> <span>"<span title="\\">\\</span>"</span>
<span>\</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>上面例子中，反斜杠在双引号之中保持特殊含义，用来转义。所以，可以使用反斜杠，在双引号之中插入双引号，或者插入反斜杠本身。</p>
<p>由于双引号将换行符解释为普通字符，所以可以利用双引号，在命令行输入多行文本。</p>
<div><pre><code>$ <span>echo</span> <span>"hello
world"</span>
hello
world
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>上面命令中，Bash 正常情况下会将换行符解释为命令结束，但是换行符在双引号之中就是普通字符，所以可以输入多行。<code>echo</code> 命令会将换行符原样输出，显示的时候正常解释为换行。</p>
<p>双引号的另一个常见的使用场合是，文件名包含空格。这时就必须使用双引号，将文件名放在里面。</p>
<div><pre><code><span>ls</span> <span>"two words.txt"</span>
</code></pre>
<div><span>1</span><br></div></div><p>上面命令中，<code>two words.txt</code> 是一个包含空格的文件名，否则就会被 Bash 当作两个文件。</p>
<p>双引号会原样保存多余的空格。</p>
<div><pre><code>$ <span>echo</span> <span>"this is a     test"</span>
this is a     <span>test</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>双引号还有一个作用，就是保存原始命令的输出格式。</p>
<div><pre><code><span># 单行输出</span>
$ <span>echo</span> <span><span>$(</span><span>cal</span><span>)</span></span>
一月 <span>2020</span> 日 一 二 三 四 五 六 <span>1</span> <span>2</span> <span>3</span> <span>..</span>. <span>31</span>

<span># 原始格式输出</span>
$ <span>echo</span> <span>"<span><span>$(</span><span>cal</span><span>)</span></span>"</span>
      一月 <span>2020</span>
日 一 二 三 四 五 六
          <span>1</span>  <span>2</span>  <span>3</span>  <span>4</span>
 <span>5</span>  <span>6</span>  <span>7</span>  <span>8</span>  <span>9</span> <span>10</span> <span>11</span>
<span>12</span> <span>13</span> <span>14</span> <span>15</span> <span>16</span> <span>17</span> <span>18</span>
<span>19</span> <span>20</span> <span>21</span> <span>22</span> <span>23</span> <span>24</span> <span>25</span>
<span>26</span> <span>27</span> <span>28</span> <span>29</span> <span>30</span> <span>31</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>上面例子中，如果 <code>$(cal)</code> 不放在双引号之中，<code>echo</code> 就会将所有结果以单行输出，丢弃了所有原始的格式。</p>
<h2 id="here-文档"> Here 文档</h2>
<p>Here 文档(here document)是一种输入多行字符串的方法，格式如下。</p>
<div><pre><code><span>&lt;&lt;</span> <span>token
text
token</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>它的格式分成开始标记(<code>&lt;&lt; token</code>)和结束标记(<code>token</code>)。开始标记是两个小于号 + Here 文档的名称，名称可以随意取，后面必须是一个换行符；结束标记是单独一行顶格写的 Here 文档名称，如果不是顶格，结束标记不起作用。两者之间就是多行字符串的内容。</p>
<p>下面是一个通过 Here 文档输出 HTML 代码的例子。</p>
<div><pre><code>$ <span>cat</span> <span>&lt;&lt;</span> <span>_EOF_
&lt;html>
&lt;head>
    &lt;title>
    The title of your page
    &lt;/title>
&lt;/head>

&lt;body>
    Your page content goes here.
&lt;/body>
&lt;/html>
_EOF_</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>Here 文档内部会发生变量替换，同时支持反斜杠转义，但是不支持通配符扩展，双引号和单引号也失去语法作用，变成了普通字符。</p>
<div><pre><code>$ <span>foo</span><span>=</span><span>'hello world'</span>
$ <span>cat</span> <span>&lt;&lt;</span> <span>_example_
<span>$foo</span>
"<span>$foo</span>"
'<span>$foo</span>'
_example_</span>

hello world
<span>"hello world"</span>
<span>'hello world'</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>上面例子中，变量 <code>$foo</code> 发生了替换，但是双引号和单引号都原样输出了，表明它们已经失去了引用的功能。</p>
<p>如果不希望发生变量替换，可以把 Here 文档的开始标记放在单引号之中。</p>
<div><pre><code>$ <span>foo</span><span>=</span><span>'hello world'</span>
$ <span>cat</span> <span>&lt;&lt;</span> <span>'_example_'
$foo
"$foo"
'$foo'
_example_</span>

<span>$foo</span>
<span>"<span>$foo</span>"</span>
<span>'<span>$foo</span>'</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>上面例子中，Here 文档的开始标记(<code>_example_</code>)放在单引号之中，导致变量替换失效了。</p>
<p>Here 文档的本质是重定向，它将字符串重定向输出给某个命令，相当于包含了 <code>echo</code> 命令。</p>
<div><pre><code>$ <span>command</span> <span>&lt;&lt;</span> <span>token
  string
token</span>

<span># 等同于</span>

$ <span>echo</span> string <span>|</span> <span>command</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>上面代码中，Here 文档相当于 <code>echo</code> 命令的重定向。</p>
<p>所以，Here 字符串只适合那些可以接受标准输入作为参数的命令，对于其他命令无效，比如 <code>echo</code> 命令就不能用 Here 文档作为参数。</p>
<div><pre><code>$ <span>echo</span> <span>&lt;&lt;</span> <span>_example_
hello
_example_</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>上面例子不会有任何输出，因为 Here 文档对于 <code>echo</code> 命令无效。</p>
<p>此外，Here 文档也不能作为变量的值，只能用于命令的参数。</p>
<h2 id="here-字符串"> Here 字符串</h2>
<p>Here 文档还有一个变体，叫做 Here 字符串(Here string)，使用三个小于号(<code>&lt;&lt;&lt;</code>)表示。</p>
<div><pre><code><span>&lt;&lt;&lt;</span> string
</code></pre>
<div><span>1</span><br></div></div><p>它的作用是将字符串通过标准输入，传递给命令。</p>
<p>有些命令直接接受给定的参数，与通过标准输入接受参数，结果是不一样的。所以才有了这个语法，使得将字符串通过标准输入传递给命令更方便，比如 <code>cat</code> 命令只接受标准输入传入的字符串。</p>
<div><pre><code>$ <span>cat</span> <span>&lt;&lt;&lt;</span> <span>'hi there'</span>
<span># 等同于</span>
$ <span>echo</span> <span>'hi there'</span> <span>|</span> <span>cat</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>上面的第一种语法使用了 Here 字符串，要比第二种语法看上去语义更好，也更简洁。</p>
<div><pre><code>$ md5sum <span>&lt;&lt;&lt;</span> <span>'ddd'</span>
<span># 等同于</span>
$ <span>echo</span> <span>'ddd'</span> <span>|</span> md5sum
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>上面例子中，<code>md5sum</code> 命令只能接受标准输入作为参数，不能直接将字符串放在命令后面，会被当作文件名，即 <code>md5sum ddd</code> 里面的 <code>ddd</code> 会被解释成文件名。这时就可以用 Here 字符串，将字符串传给 <code>md5sum</code> 命令。</p>
]]></content>
    <author>
      <name>阮一峰</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>阮一峰</name>
    </contributor>
    <rights>本教程采用&lt;a href="https://creativecommons.org/licenses/by-sa/3.0/deed.zh"&gt;知识共享 署名-相同方式共享 3.0协议&lt;/a&gt;</rights>
  </entry>
  <entry>
    <title type="html">read 命令</title>
    <id>http://qiqi.dreamagain.top/software/linux/bash/read/</id>
    <link href="http://qiqi.dreamagain.top/software/linux/bash/read/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<h2 id="用法"> 用法</h2>
<p>有时，脚本需要在执行过程中，由用户提供一部分数据，这时可以使用 <code>read</code> 命令。它将用户的输入存入一个变量，方便后面的代码使用。用户按下回车键，就表示输入结束。</p>
<p><code>read</code> 命令的格式如下。</p>
<div><pre><code><span>read</span> <span>[</span>-options<span>]</span> <span>[</span>variable<span>..</span>.<span>]</span>
</code></pre>
<div><span>1</span><br></div></div><p>上面语法中，<code>options</code> 是参数选项，<code>variable</code> 是用来保存输入数值的一个或多个变量名。如果没有提供变量名，环境变量 <code>REPLY</code> 会包含用户输入的一整行数据。</p>
<p>下面是一个例子 <code>demo.sh</code>。</p>
<div><pre><code><span>#!/bin/bash</span>

<span>echo</span> -n <span>"输入一些文本 > "</span>
<span>read</span> text
<span>echo</span> <span>"您的输入: <span>$text</span>"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>上面例子中，先显示一行提示文本，然后会等待用户输入文本。用户输入的文本，存入变量 <code>text</code>，在下一行显示出来。</p>
<div><pre><code>$ <span>bash</span> demo.sh
输入一些文本 <span>></span> 您好，世界
您的输入: 您好，世界
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><code>read</code> 可以接受用户输入的多个值。</p>
<div><pre><code><span>#!/bin/bash</span>
<span>echo</span> Please, enter your firstname and lastname
<span>read</span> FN LN
<span>echo</span> <span>"Hi! <span>$LN</span>, <span>$FN</span> !"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>上面例子中，<code>read</code> 根据用户的输入，同时为两个变量赋值。</p>
<p>如果用户的输入项少于 <code>read</code> 命令给出的变量数目，那么额外的变量值为空。如果用户的输入项多于定义的变量，那么多余的输入项会包含到最后一个变量中。</p>
<p>如果 <code>read</code> 命令之后没有定义变量名，那么环境变量 <code>REPLY</code> 会包含所有的输入。</p>
<div><pre><code><span>#!/bin/bash</span>
<span># read-single: read multiple values into default variable</span>
<span>echo</span> -n <span>"Enter one or more values > "</span>
<span>read</span>
<span>echo</span> <span>"REPLY = '<span>$REPLY</span>'"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>上面脚本的运行结果如下。</p>
<div><pre><code>$ read-single
Enter one or <span>more</span> values <span>></span> a b c d
<span>REPLY</span> <span>=</span> <span>'a b c d'</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><code>read</code> 命令除了读取键盘输入，可以用来读取文件。</p>
<div><pre><code><span>while</span> <span>read</span> myline
<span>do</span>
  <span>echo</span> <span>"<span>$myline</span>"</span>
<span>done</span> <span>&lt;</span> <span>$filename</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>上面的例子通过 <code>read</code> 命令，读取一个文件的内容。<code>done</code> 命令后面的定向符 <code>&lt;</code>，将文件导向 <code>read</code> 命令，每次读取一行，存入变量 <code>myline</code>，直到文件读取完毕。</p>
<h2 id="参数"> 参数</h2>
<p><code>read</code> 命令的参数如下。</p>
<ol>
<li>
<p><strong><code>-t</code> 参数</strong></p>
<p><code>read</code> 命令的 <code>-t</code> 参数，设置了超时的秒数。如果超过了指定时间，用户仍然没有输入，脚本将放弃等待，继续向下执行。</p>
<div><pre><code><span>#!/bin/bash</span>

<span>echo</span> -n <span>"输入一些文本 > "</span>
<span>if</span> <span>read</span> -t <span>3</span> response<span>;</span> <span>then</span>
  <span>echo</span> <span>"用户已经输入了"</span>
<span>else</span>
  <span>echo</span> <span>"用户没有输入"</span>
<span>fi</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>上面例子中，输入命令会等待 3 秒，如果用户超过这个时间没有输入，这个命令就会执行失败。<code>if</code> 根据命令的返回值，转入 <code>else</code> 代码块，继续往下执行。</p>
<p>环境变量 <code>TMOUT</code> 也可以起到同样作用，指定 <code>read</code> 命令等待用户输入的时间(单位为秒)。</p>
<div><pre><code><span>TMOUT</span><span>=</span><span>3</span>
<span>read</span> response
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>上面例子也是等待 3 秒，如果用户还没有输入，就会超时。</p>
</li>
<li>
<p><strong><code>-p</code> 参数</strong></p>
<p><code>-p</code> 参数指定用户输入的提示信息。</p>
<div><pre><code><span>read</span> -p <span>"Enter one or more values > "</span>
<span>echo</span> <span>"REPLY = '<span>$REPLY</span>'"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>上面例子中，先显示 <code>Enter one or more values &gt;</code>，再接受用户的输入。</p>
</li>
<li>
<p><strong><code>-a</code> 参数</strong></p>
<p><code>-a</code> 参数把用户的输入赋值给一个数组，从零号位置开始。</p>
<div><pre><code>$ <span>read</span> -a people
alice duchess dodo
$ <span>echo</span> <span>${people<span>[</span>2<span>]</span>}</span>
dodo
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>上面例子中，用户输入被赋值给一个数组 <code>people</code>，这个数组的 2 号成员就是 <code>dodo</code>。</p>
</li>
<li>
<p><strong><code>-n</code> 参数</strong></p>
<p><code>-n</code> 参数指定只读取若干个字符作为变量值，而不是整行读取。</p>
<div><pre><code>$ <span>read</span> -n <span>3</span> letter
abcdefghij
$ <span>echo</span> <span>$letter</span>
abc
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>上面例子中，变量 <code>letter</code> 只包含 3 个字母。</p>
</li>
<li>
<p><strong>-e 参数</strong></p>
<p><code>-e</code> 参数允许用户输入的时候，使用 <code>readline</code> 库提供的快捷键，比如自动补全。具体的快捷键可以参阅《行操作》一章。</p>
<div><pre><code><span>#!/bin/bash</span>

<span>echo</span> Please input the path to the file:

<span>read</span> -e fileName

<span>echo</span> <span>$fileName</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>上面例子中，<code>read</code> 命令接受用户输入的文件名。这时，用户可能想使用 Tab 键的文件名“自动补全”功能，但是 <code>read</code> 命令的输入默认不支持 <code>readline</code> 库的功能。<code>-e</code> 参数就可以允许用户使用自动补全。</p>
</li>
<li>
<p><strong>其他参数</strong></p>
<ul>
<li><code>-d delimiter</code>: 定义字符串 <code>delimiter</code> 的第一个字符作为用户输入的结束，而不是一个换行符。</li>
<li><code>-r</code>: raw 模式，表示不把用户输入的反斜杠字符解释为转义字符。</li>
<li><code>-s</code>: 使得用户的输入不显示在屏幕上，这常常用于输入密码或保密信息。</li>
<li><code>-u fd</code>: 使用文件描述符 <code>fd</code> 作为输入。</li>
</ul>
</li>
</ol>
<h2 id="ifs-变量"> IFS 变量</h2>
<p><code>read</code> 命令读取的值，默认是以空格分隔。可以通过自定义环境变量 <code>IFS</code>(内部字段分隔符，Internal Field Separator 的缩写)，修改分隔标志。</p>
<p><code>IFS</code> 的默认值是空格、Tab 符号、换行符号，通常取第一个(即空格)。</p>
<p>如果把 <code>IFS</code> 定义成冒号(<code>:</code>)或分号(<code>;</code>)，就可以分隔以这两个符号分隔的值，这对读取文件很有用。</p>
<div><pre><code><span>#!/bin/bash</span>
<span># read-ifs: read fields from a file</span>

<span>FILE</span><span>=</span>/etc/passwd

<span>read</span> -p <span>"Enter a username > "</span> user_name
<span>file_info</span><span>=</span><span>"<span><span>$(</span><span>grep</span> <span>"^<span>$user_name</span>:"</span> $FILE<span>)</span></span>"</span>

<span>if</span> <span>[</span> -n <span>"<span>$file_info</span>"</span> <span>]</span><span>;</span> <span>then</span>
  <span><span>IFS</span></span><span>=</span><span>":"</span> <span>read</span> user pw uid gid name home shell <span>&lt;&lt;&lt;</span> <span>"<span>$file_info</span>"</span>
  <span>echo</span> <span>"User = '<span>$user</span>'"</span>
  <span>echo</span> <span>"UID = '<span>$uid</span>'"</span>
  <span>echo</span> <span>"GID = '<span>$gid</span>'"</span>
  <span>echo</span> <span>"Full Name = '<span>$name</span>'"</span>
  <span>echo</span> <span>"Home Dir. = '<span>$home</span>'"</span>
  <span>echo</span> <span>"Shell = '<span>$shell</span>'"</span>
<span>else</span>
  <span>echo</span> <span>"No such user '<span>$user_name</span>'"</span> <span>></span><span>&amp;2</span>
  <span>exit</span> <span>1</span>
<span>fi</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><p>上面例子中，<code>IFS</code> 设为冒号，然后用来分解 <code>/etc/passwd</code> 文件的一行。<code>IFS</code> 的赋值命令和 <code>read</code> 命令写在一行，这样的话，<code>IFS</code> 的改变仅对后面的命令生效，该命令执行后 <code>IFS</code> 会自动恢复原来的值。如果不写在一行，就要采用下面的写法。</p>
<div><pre><code><span>OLD_IFS</span><span>=</span><span>"<span>$IFS</span>"</span>
<span><span>IFS</span></span><span>=</span><span>":"</span>
<span>read</span> user pw uid gid name home shell <span>&lt;&lt;&lt;</span> <span>"<span>$file_info</span>"</span>
<span><span>IFS</span></span><span>=</span><span>"<span>$OLD_IFS</span>"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>另外，上面例子中，<code>&lt;&lt;&lt;</code> 是 Here 字符串，用于将变量值转为标准输入，因为 <code>read</code> 命令只能解析标准输入。</p>
<p>如果 <code>IFS</code> 设为空字符串，就等同于将整行读入一个变量。</p>
<div><pre><code><span>#!/bin/bash</span>
<span>input</span><span>=</span><span>"/path/to/txt/file"</span>
<span>while</span> <span><span>IFS</span></span><span>=</span> <span>read</span> -r line
<span>do</span>
  <span>echo</span> <span>"<span>$line</span>"</span>
<span>done</span> <span>&lt;</span> <span>"<span>$input</span>"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>上面的命令可以逐行读取文件，每一行存入变量 <code>line</code>，打印出来以后再读取下一行。</p>
]]></content>
    <author>
      <name>阮一峰</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>阮一峰</name>
    </contributor>
    <rights>本教程采用&lt;a href="https://creativecommons.org/licenses/by-sa/3.0/deed.zh"&gt;知识共享 署名-相同方式共享 3.0协议&lt;/a&gt;</rights>
  </entry>
  <entry>
    <title type="html">Bash 行操作</title>
    <id>http://qiqi.dreamagain.top/software/linux/bash/readline/</id>
    <link href="http://qiqi.dreamagain.top/software/linux/bash/readline/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<h2 id="简介"> 简介</h2>
<p>Bash 内置了 Readline 库，具有这个库提供的很多“行操作”功能，比如命令的自动补全，可以大大加快操作速度。</p>
<p>这个库默认采用 Emacs 快捷键，也可以改成 Vi 快捷键。</p>
<div><pre><code><span>set</span> -o <span>vi</span>
</code></pre>
<div><span>1</span><br></div></div><p>下面的命令可以改回 Emacs 快捷键。</p>
<div><pre><code><span>set</span> -o emacs
</code></pre>
<div><span>1</span><br></div></div><p>如果想永久性更改编辑模式(Emacs / Vi)，可以将命令写在 <code>~/.inputrc</code> 文件，这个文件是 Readline 的配置文件。</p>
<div><pre><code><span>set</span> editing-mode <span>vi</span>
</code></pre>
<div><span>1</span><br></div></div><p>本章介绍的快捷键都属于 Emacs 模式。Vi 模式的快捷键，读者可以参考 Vi 编辑器的教程。</p>
<p>Bash 默认开启这个库，但是允许关闭。</p>
<div><pre><code><span>bash</span> --noediting
</code></pre>
<div><span>1</span><br></div></div><p>上面命令中，<code>--noediting</code> 参数关闭了 Readline 库，启动的 Bash 就不带有行操作功能。</p>
<h2 id="光标移动"> 光标移动</h2>
<p>Readline 提供快速移动光标的快捷键。</p>
<ul>
<li><code>Ctrl + a</code>: 移到行首。</li>
<li><code>Ctrl + b</code>: 向行首移动一个字符，与左箭头作用相同。</li>
<li><code>Ctrl + e</code>: 移到行尾。</li>
<li><code>Ctrl + f</code>: 向行尾移动一个字符，与右箭头作用相同。</li>
<li><code>Alt + f</code>: 移动到当前单词的词尾。</li>
<li><code>Alt + b</code>: 移动到当前单词的词首。</li>
</ul>
<p>上面快捷键的 Alt 键，也可以用 ESC 键代替。</p>
<h2 id="清除屏幕"> 清除屏幕</h2>
<p><code>Ctrl + l</code> 快捷键可以清除屏幕，即将当前行移到屏幕的第一行，与 <code>clear</code> 命令作用相同。</p>
<h2 id="编辑操作"> 编辑操作</h2>
<p>下面的快捷键可以编辑命令行内容。</p>
<ul>
<li><code>Ctrl + d</code>: 删除光标位置的字符(delete)。</li>
<li><code>Ctrl + w</code>: 删除光标前面的单词。</li>
<li><code>Ctrl + t</code>: 光标位置的字符与它前面一位的字符交换位置(transpose)。</li>
<li><code>Alt + t</code>: 光标位置的词与它前面一位的词交换位置(transpose)。</li>
<li><code>Alt + l</code>: 将光标位置至词尾转为小写(lowercase)。</li>
<li><code>Alt + u</code>: 将光标位置至词尾转为大写(uppercase)。</li>
</ul>
<p>使用 <code>Ctrl + d</code> 的时候，如果当前行没有任何字符，会导致退出当前 Shell，所以要小心。</p>
<p>剪切和粘贴快捷键如下。</p>
<ul>
<li><code>Ctrl + k</code>: 剪切光标位置到行尾的文本。</li>
<li><code>Ctrl + u</code>: 剪切光标位置到行首的文本。</li>
<li><code>Alt + d</code>: 剪切光标位置到词尾的文本。</li>
<li><code>Alt + Backspace</code>: 剪切光标位置到词首的文本。</li>
<li><code>Ctrl + y</code>: 在光标位置粘贴文本。</li>
</ul>
<p>同样地，Alt 键可以用 Esc 键代替。</p>
<h2 id="自动补全"> 自动补全</h2>
<p>命令输入到一半的时候，可以按一下 Tab 键，Readline 会自动补全命令或路径。比如，输入 <code>cle</code>，再按下 Tab 键，Bash 会自动将这个命令补全为 <code>clear</code>。</p>
<p>如果符合条件的命令或路径有多个，就需要连续按两次 Tab 键，Bash 会提示所有符合条件的命令或路径。</p>
<p>除了命令或路径，Tab 还可以补全其他值。如果一个值以 <code>$</code> 开头，则按下 Tab 键会补全变量；如果以 <code>~</code> 开头，则补全用户名；如果以 <code>@</code> 开头，则补全主机名(hostname)，主机名以列在 <code>/etc/hosts</code> 文件里面的主机为准。</p>
<p>自动补全相关的快捷键如下。</p>
<ul>
<li>Tab: 完成自动补全。</li>
<li><code>Alt + ?</code>: 列出可能的补全，与连按两次 Tab 键作用相同。</li>
<li><code>Alt + /</code>: 尝试文件路径补全。</li>
<li><code>Ctrl + x /</code>: 先按 <code>Ctrl + x</code>，再按 <code>/</code>，等同于 <code>Alt + ?</code>，列出可能的文件路径补全。</li>
<li><code>Alt + !</code>: 命令补全。</li>
<li><code>Ctrl + x !</code>: 先按 <code>Ctrl + x</code>，再按 <code>!</code>，等同于 <code>Alt + !</code>，命令补全。</li>
<li><code>Alt + ~</code>: 用户名补全。</li>
<li><code>Ctrl + x ~</code>: 先按 <code>Ctrl + x</code>，再按 <code>~</code>，等同于 <code>Alt + ~</code>，用户名补全。</li>
<li><code>Alt + $</code>: 变量名补全。</li>
<li><code>Ctrl + x $</code>: 先按 <code>Ctrl + x</code>，再按 <code>$</code>，等同于 <code>Alt + $</code>，变量名补全。</li>
<li><code>Alt + @</code>: 主机名补全。</li>
<li><code>Ctrl + x @</code>: 先按 <code>Ctrl + x</code>，再按 <code>@</code>，等同于 <code>Alt + @</code>，主机名补全。</li>
<li><code>Alt + *</code>: 在命令行一次性插入所有可能的补全。</li>
<li><code>Alt + Tab</code>: 尝试用 <code>.bash_history</code> 里面以前执行命令，进行补全。</li>
</ul>
<p>上面的 <code>Alt</code> 键也可以用 ESC 键代替。</p>
<h2 id="操作历史"> 操作历史</h2>
<h3 id="基本用法"> 基本用法</h3>
<p>Bash 会保留用户的操作历史，即用户输入的每一条命令都会记录。退出当前 Shell 的时候，Bash 会将用户在当前 Shell 的操作历史写入 <code>~/.bash_history</code> 文件，该文件默认储存 500 个操作。</p>
<p>环境变量 <code>HISTFILE</code> 总是指向这个文件。</p>
<div><pre><code>$ <span>echo</span> <span>$HISTFILE</span>
/home/me/.bash_history
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>有了操作历史以后，就可以使用方向键的 <code>↑</code> 和 <code>↓</code>，快速浏览上一条和下一条命令。</p>
<p>下面的方法可以快速执行以前执行过的命令。</p>
<div><pre><code>$ <span>echo</span> Hello World
Hello World

$ <span>echo</span> Goodbye
Goodbye

$ <span>!</span>e
<span>echo</span> Goodbye
Goodbye
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>上面例子中，<code>!e</code> 表示找出操作历史之中，最近的那一条以 <code>e</code> 开头的命令并执行。Bash 会先输出那一条命令 <code>echo Goodbye</code>，然后直接执行。</p>
<p>同理，<code>!echo</code> 也会执行最近一条以 <code>echo</code> 开头的命令。</p>
<div><pre><code>$ <span>!</span>echo
<span>echo</span> Goodbye
Goodbye

$ <span>!</span>echo H
<span>echo</span> Goodbye H
Goodbye H

$ <span>!</span>echo H G
<span>echo</span> Goodbye H G
Goodbye H G
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>注意，<code>!string</code> 语法只会匹配命令，不会匹配参数。所以 <code>!echo H</code> 不会执行 <code>echo Hello World</code>，而是会执行 <code>echo Goodbye</code>，并把参数 <code>H</code> 附加在这条命令之后。同理，<code>!echo H G</code> 也是等同于 <code>echo Goodbye</code> 命令之后附加 <code>H G</code>。</p>
<p>最后，按下 <code>Ctrl + r</code> 会显示操作历史，可以用方向键上下移动，选择其中要执行的命令。也可以键入命令的首字母，Shell 就会自动在历史文件中，查询并显示匹配的结果。</p>
<h3 id="history-命令"> history 命令</h3>
<p><code>history</code> 命令能显示操作历史，即 <code>.bash_history</code> 文件的内容。</p>
<div><pre><code>$ <span>history</span>
<span>..</span>.
<span>498</span> <span>echo</span> Goodbye
<span>499</span> <span>ls</span> ~
<span>500</span> <span>cd</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>使用该命令，而不是直接读取 <code>.bash_history</code> 文件的好处是，它会在所有的操作前加上行号，最近的操作在最后面，行号最大。</p>
<p>通过定制环境变量 <code>HISTTIMEFORMAT</code>，可以显示每个操作的时间。</p>
<div><pre><code>$ <span>export</span> <span>HISTTIMEFORMAT</span><span>=</span><span>'%F %T  '</span>
$ <span>history</span>
<span>1</span>  <span>2013</span>-06-09 <span>10</span>:40:12   <span>cat</span> /etc/issue
<span>2</span>  <span>2013</span>-06-09 <span>10</span>:40:12   <span>clear</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>上面代码中，<code>%F</code> 相当于 <code>%Y - %m - %d</code>，<code>%T</code> 相当于 <code>%H : %M : %S</code>。</p>
<p>只要设置 <code>HISTTIMEFORMAT</code> 这个环境变量，就会在 <code>.bash_history</code> 文件保存命令的执行时间戳。如果不设置，就不会保存时间戳。</p>
<p>如果不希望保存本次操作的历史，可以设置环境变量 <code>HISTSIZE</code> 等于 0。</p>
<div><pre><code><span>export</span> <span><span>HISTSIZE</span></span><span>=</span><span>0</span>
</code></pre>
<div><span>1</span><br></div></div><p>如果 <code>HISTSIZE=0</code> 写入用户主目录的 <code>~/.bashrc</code> 文件，那么就不会保留该用户的操作历史。如果写入 <code>/etc/profile</code>，整个系统都不会保留操作历史。</p>
<p>如果想搜索某个以前执行的命令，可以配合 <code>grep</code> 命令搜索操作历史。</p>
<div><pre><code><span>history</span> <span>|</span> <span>grep</span> /usr/bin
</code></pre>
<div><span>1</span><br></div></div><p>上面命令返回 <code>.bash_history</code> 文件里面，那些包含 <code>/usr/bin</code> 的命令。</p>
<p>操作历史的每一条记录都有编号。知道了命令的编号以后，可以用 <code>感叹号 + 编号</code> 执行该命令。如果想要执行 <code>.bash_history</code> 里面的第 8 条命令，可以像下面这样操作。</p>
<div><pre><code><span>!</span><span>8</span>
</code></pre>
<div><span>1</span><br></div></div><p><code>history</code> 命令的 <code>-c</code> 参数可以清除操作历史。</p>
<div><pre><code><span>history</span> -c
</code></pre>
<div><span>1</span><br></div></div><h3 id="相关快捷键"> 相关快捷键</h3>
<p>下面是一些与操作历史相关的快捷键。</p>
<ul>
<li><code>Ctrl + p</code>: 显示上一个命令，与向上箭头效果相同(previous)。</li>
<li><code>Ctrl + n</code>: 显示下一个命令，与向下箭头效果相同(next)。</li>
<li><code>Alt + &lt;</code>: 显示第一个命令。</li>
<li><code>Alt + &gt;</code>: 显示最后一个命令，即当前的命令。</li>
<li><code>Ctrl + o</code>: 执行历史文件里面的当前条目，并自动显示下一条命令。这对重复执行某个序列的命令很有帮助。</li>
</ul>
<p>感叹号<code>!</code>的快捷键如下。</p>
<ul>
<li><code>!!</code>: 执行上一个命令。</li>
<li><code>!n</code>: 执行历史文件里面行号为 <code>n</code> 的命令。</li>
<li><code>!-n</code>: 执行当前命令之前 <code>n</code> 条的命令。</li>
<li><code>!string</code>: 执行最近一个以指定字符串 <code>string</code> 开头的命令。</li>
<li><code>!?string</code>: 执行最近一条包含字符串 <code>string</code> 的命令。</li>
<li><code>^string1^string2</code>: 执行最近一条包含 <code>string1</code> 的命令，将其替换成 <code>string2</code>。</li>
</ul>
<h2 id="其他快捷键"> 其他快捷键</h2>
<ul>
<li><code>Ctrl + j</code>: 等同于回车键(LINEFEED)。</li>
<li><code>Ctrl + m</code>: 等同于回车键(CARRIAGE RETURN)。</li>
<li><code>Ctrl + o</code>: 等同于回车键，并展示操作历史的下一个命令。</li>
<li><code>Ctrl + v</code>: 将下一个输入的特殊字符变成字面量，比如回车变成 <code>^M</code>。</li>
<li><code>Ctrl + [</code>: 等同于 ESC。</li>
<li><code>Alt + .</code>: 插入上一个命令的最后一个词。</li>
<li><code>Alt + _</code>: 等同于 <code>Alt + .</code>。</li>
</ul>
<p>上面的 <code>Alt + .</code> 快捷键，对于很长的文件路径，有时会非常方便。因为 Unix 命令的最后一个参数通常是文件路径。</p>
<div><pre><code><span>mkdir</span> foo_bar
<span>cd</span> <span>#按下 Alt + .</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>上面例子中，在 <code>cd</code> 命令后按下 <code>Alt + .</code>，就会自动插入 <code>foo_bar</code>。</p>
]]></content>
    <author>
      <name>阮一峰</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>阮一峰</name>
    </contributor>
    <rights>本教程采用&lt;a href="https://creativecommons.org/licenses/by-sa/3.0/deed.zh"&gt;知识共享 署名-相同方式共享 3.0协议&lt;/a&gt;</rights>
  </entry>
  <entry>
    <title type="html">Bash 教程</title>
    <id>http://qiqi.dreamagain.top/software/linux/bash/</id>
    <link href="http://qiqi.dreamagain.top/software/linux/bash/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<h2 id="目录"> 目录</h2>
<ul>
<li>
<p><a href="./src/software/linux/bash/intro.html">简介</a></p>
</li>
<li>
<p><a href="./src/software/linux/bash/grammar.html">基本语法</a></p>
</li>
<li>
<p><a href="./src/software/linux/bash/expansion.html">模式扩展</a></p>
</li>
<li>
<p><a href="./src/software/linux/bash/quotation.html">引号和转义</a></p>
</li>
<li>
<p><a href="./src/software/linux/bash/variable.html">变量</a></p>
</li>
<li>
<p><a href="./src/software/linux/bash/string.html">字符串操作</a></p>
</li>
<li>
<p><a href="./src/software/linux/bash/arithmetic.html">算术运算</a></p>
</li>
<li>
<p><a href="./src/software/linux/bash/readline.html">行操作</a></p>
</li>
<li>
<p><a href="./src/software/linux/bash/stack.html">目录堆栈</a></p>
</li>
<li>
<p><a href="./src/software/linux/bash/script.html">脚本入门</a></p>
</li>
<li>
<p><a href="./src/software/linux/bash/read.html">read 命令</a></p>
</li>
<li>
<p><a href="./src/software/linux/bash/condition.html">条件判断</a></p>
</li>
<li>
<p><a href="./src/software/linux/bash/loop.html">循环</a></p>
</li>
<li>
<p><a href="./src/software/linux/bash/function.html">函数</a></p>
</li>
<li>
<p><a href="./src/software/linux/bash/array.html">数组</a></p>
</li>
<li>
<p><a href="./src/software/linux/bash/set.html">set 命令</a></p>
</li>
<li>
<p><a href="./src/software/linux/bash/debug.html">脚本除错</a></p>
</li>
<li>
<p><a href="./src/software/linux/bash/mktemp.html">mktemp 命令，trap 命令</a></p>
</li>
<li>
<p><a href="./src/software/linux/bash/startup.html">启动环境</a></p>
</li>
<li>
<p><a href="./src/software/linux/bash/prompt.html">命令提示符</a></p>
</li>
</ul>
]]></content>
    <author>
      <name>阮一峰</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>阮一峰</name>
    </contributor>
    <rights>本教程采用&lt;a href="https://creativecommons.org/licenses/by-sa/3.0/deed.zh"&gt;知识共享 署名-相同方式共享 3.0协议&lt;/a&gt;</rights>
  </entry>
  <entry>
    <title type="html">Bash 脚本入门</title>
    <id>http://qiqi.dreamagain.top/software/linux/bash/script/</id>
    <link href="http://qiqi.dreamagain.top/software/linux/bash/script/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <summary type="html"><![CDATA[<p>脚本(script)就是包含一系列命令的一个文本文件。Shell 读取这个文件，依次执行里面的所有命令，就好像这些命令直接输入到命令行一样。所有能够在命令行完成的任务，都能够用脚本完成。</p>
<p>脚本的好处是可以重复使用，也可以指定在特定场合自动调用，比如系统启动或关闭时自动执行脚本。</p>
]]></summary>
    <content type="html"><![CDATA[<p>脚本(script)就是包含一系列命令的一个文本文件。Shell 读取这个文件，依次执行里面的所有命令，就好像这些命令直接输入到命令行一样。所有能够在命令行完成的任务，都能够用脚本完成。</p>
<p>脚本的好处是可以重复使用，也可以指定在特定场合自动调用，比如系统启动或关闭时自动执行脚本。</p>

<h2 id="shebang-行"> Shebang 行</h2>
<p>脚本的第一行通常是指定解释器，即这个脚本必须通过什么解释器执行。这一行以 <code>#!</code> 字符开头，这个字符称为 Shebang，所以这一行就叫做 Shebang 行。</p>
<p><code>#!</code> 后面就是脚本解释器的位置，Bash 脚本的解释器一般是 <code>/bin/sh</code> 或 <code>/bin/bash</code>。</p>
<div><pre><code><span>#!/bin/sh</span>
<span># 或者</span>
<span>#!/bin/bash</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><code>#!</code> 与脚本解释器之间有没有空格，都是可以的。</p>
<p>如果 Bash 解释器不放在目录 <code>/bin</code>，脚本就无法执行了。为了保险，可以写成下面这样。</p>
<div><pre><code><span>#!/usr/bin/env bash</span>
</code></pre>
<div><span>1</span><br></div></div><p>上面命令使用 <code>env</code> 命令(这个命令总是在 <code>/usr/bin</code> 目录)，返回 Bash 可执行文件的位置。<code>env</code> 命令的详细介绍，请看后文。</p>
<p>Shebang 行不是必需的，但是建议加上这行。如果缺少该行，就需要手动将脚本传给解释器。举例来说，脚本是 <code>script.sh</code>，有 Shebang 行的时候，可以直接调用执行。</p>
<div><pre><code>./script.sh
</code></pre>
<div><span>1</span><br></div></div><p>上面例子中，<code>script.sh</code> 是脚本文件名。脚本通常使用 <code>.sh</code> 后缀名，不过这不是必需的。</p>
<p>如果没有 Shebang 行，就只能手动将脚本传给解释器来执行。</p>
<div><pre><code>$ /bin/sh ./script.sh
<span># 或者</span>
$ <span>bash</span> ./script.sh
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id="执行权限和路径"> 执行权限和路径</h2>
<p>前面说过，只要指定了 Shebang 行的脚本，可以直接执行。这有一个前提条件，就是脚本需要有执行权限。可以使用下面的命令，赋予脚本执行权限。</p>
<div><pre><code><span># 给所有用户执行权限</span>
$ <span>chmod</span> +x script.sh

<span># 给所有用户读权限和执行权限</span>
$ <span>chmod</span> +rx script.sh
<span># 或者</span>
$ <span>chmod</span> <span>755</span> script.sh

<span># 只给脚本拥有者读权限和执行权限</span>
$ <span>chmod</span> u+rx script.sh
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>脚本的权限通常设为 <code>755</code> (拥有者有所有权限，其他人有读和执行权限)或者 <code>700</code>(只有拥有者可以执行)。</p>
<p>除了执行权限，脚本调用时，一般需要指定脚本的路径(比如 <code>path/script.sh</code>)。如果将脚本放在环境变量 <code>$PATH</code> 指定的目录中，就不需要指定路径了。因为 Bash 会自动到这些目录中，寻找是否存在同名的可执行文件。</p>
<p>建议在主目录新建一个 <code>~/bin</code> 子目录，专门存放可执行脚本，然后把 <code>~/bin</code> 加入 <code>$PATH</code>。</p>
<div><pre><code><span>export</span> <span><span>PATH</span></span><span>=</span><span>$PATH</span>:~/bin
</code></pre>
<div><span>1</span><br></div></div><p>上面命令改变环境变量 <code>$PATH</code>，将 <code>~/bin</code> 添加到 <code>$PATH</code> 的末尾。可以将这一行加到 <code>~/.bashrc</code> 文件里面，然后重新加载一次 <code>.bashrc</code>，这个配置就可以生效了。</p>
<div><pre><code><span>source</span> ~/.bashrc
</code></pre>
<div><span>1</span><br></div></div><p>以后不管在什么目录，直接输入脚本文件名，脚本就会执行。</p>
<div><pre><code>script.sh
</code></pre>
<div><span>1</span><br></div></div><p>上面命令没有指定脚本路径，因为 <code>script.sh</code> 在 <code>$PATH</code> 指定的目录中。</p>
<h2 id="env-命令"> env 命令</h2>
<p><code>env</code> 命令总是指向 <code>/usr/bin/env</code> 文件，或者说，这个二进制文件总是在目录 <code>/usr/bin</code>。</p>
<p><code>#!/usr/bin/env NAME</code> 这个语法的意思是，让 Shell 查找 <code>$PATH</code> 环境变量里面第一个匹配的 <code>NAME</code>。如果您不知道某个命令的具体路径，或者希望兼容其他用户的机器，这样的写法就很有用。</p>
<p><code>/usr/bin/env bash</code> 的意思就是，返回 <code>bash</code> 可执行文件的位置，前提是 <code>bash</code> 的路径是在 <code>$PATH</code> 里面。其他脚本文件也可以使用这个命令。比如 Node.js 脚本的 Shebang 行，可以写成下面这样。</p>
<div><pre><code><span>#!/usr/bin/env node</span>
</code></pre>
<div><span>1</span><br></div></div><p><code>env</code> 命令的参数如下。</p>
<ul>
<li><code>-i</code>, <code>--ignore-environment</code>: 不带环境变量启动。</li>
<li><code>-u</code>, <code>--unset=NAME</code>: 从环境变量中删除一个变量。</li>
<li><code>--help</code>: 显示帮助。</li>
<li><code>--version</code>: 输出版本信息。</li>
</ul>
<p>下面是一个例子，新建一个不带任何环境变量的 Shell。</p>
<div><pre><code><span>env</span> -i /bin/sh
</code></pre>
<div><span>1</span><br></div></div><h2 id="注释"> 注释</h2>
<p>Bash 脚本中，<code>#</code> 表示注释，可以放在行首，也可以放在行尾。</p>
<div><pre><code><span># 本行是注释</span>
<span>echo</span> <span>'Hello World!'</span>

<span>echo</span> <span>'Hello World!'</span> <span># 井号后面的部分也是注释</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>建议在脚本开头，使用注释说明当前脚本的作用，这样有利于日后的维护。</p>
<h2 id="脚本参数"> 脚本参数</h2>
<p>调用脚本的时候，脚本文件名后面可以带有参数。</p>
<div><pre><code>script.sh word1 word2 word3
</code></pre>
<div><span>1</span><br></div></div><p>上面例子中，<code>script.sh</code> 是一个脚本文件，<code>word1</code>、<code>word2</code> 和 <code>word3</code> 是三个参数。</p>
<p>脚本文件内部，可以使用特殊变量，引用这些参数。</p>
<ul>
<li><code>$0</code>: 脚本文件名，即 <code>script.sh</code>。</li>
<li><code>$1</code>~<code>$9</code>: 对应脚本的第一个参数到第九个参数。</li>
<li><code>$#</code>: 参数的总数。</li>
<li><code>$@</code>: 全部的参数，参数之间使用空格分隔。</li>
<li><code>$*</code>: 全部的参数，参数之间使用变量 <code>$IFS</code> 值的第一个字符分隔，默认为空格，但是可以自定义。</li>
</ul>
<p>如果脚本的参数多于 9 个，那么第 10 个参数可以用 <code>${10}</code> 的形式引用，以此类推。</p>
<p>注意，如果命令是 <code>command -o foo bar</code>，那么 <code>-o</code> 是 <code>$1</code>，<code>foo</code> 是 <code>$2</code>，<code>bar</code> 是 <code>$3</code>。</p>
<p>下面是一个脚本内部读取命令行参数的例子。</p>
<div><pre><code><span>#!/bin/bash</span>
<span># script.sh</span>

<span>echo</span> <span>"全部参数: "</span> <span>$@</span>
<span>echo</span> <span>"命令行参数数量: "</span> <span>$#</span>
<span>echo</span> <span>'<span>$0</span> = '</span> <span>$0</span>
<span>echo</span> <span>'<span>$1</span> = '</span> <span>$1</span>
<span>echo</span> <span>'<span>$2</span> = '</span> <span>$2</span>
<span>echo</span> <span>'<span>$3</span> = '</span> <span>$3</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>执行结果如下。</p>
<div><pre><code>$ ./script.sh a b c
全部参数: a b c
命令行参数数量: <span>3</span>
<span>$0</span> <span>=</span>  script.sh
<span>$1</span> <span>=</span>  a
<span>$2</span> <span>=</span>  b
<span>$3</span> <span>=</span>  c
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>用户可以输入任意数量的参数，利用 <code>for</code> 循环，可以读取每一个参数。</p>
<div><pre><code><span>#!/bin/bash</span>

<span>for</span> <span>i</span> <span>in</span> <span>"<span>$@</span>"</span><span>;</span> <span>do</span>
  <span>echo</span> <span>$i</span>
<span>done</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>上面例子中，<code>$@</code> 返回一个全部参数的列表，然后使用 <code>for</code> 循环遍历。</p>
<p>如果多个参数放在双引号里面，视为一个参数。</p>
<div><pre><code>./script.sh <span>"a b"</span>
</code></pre>
<div><span>1</span><br></div></div><p>上面例子中，Bash 会认为 <code>&quot;a b&quot;</code> 是一个参数，<code>$1</code> 会返回 <code>a b</code>。注意，返回时不包括双引号。</p>
<h2 id="shift-命令"> shift 命令</h2>
<p><code>shift</code> 命令可以改变脚本参数，每次执行都会移除脚本当前的第一个参数 (<code>$1</code>)，使得后面的参数向前一位，即 <code>$2</code> 变成 <code>$1</code>、<code>$3</code> 变成 <code>$2</code>、<code>$4</code> 变成 <code>$3</code>，以此类推。</p>
<p><code>while</code> 循环结合 <code>shift</code> 命令，也可以读取每一个参数。</p>
<div><pre><code><span>#!/bin/bash</span>

<span>echo</span> <span>"一共输入了 <span>$#</span> 个参数"</span>

<span>while</span> <span>[</span> <span>"<span>$1</span>"</span> <span>!=</span> <span>""</span> <span>]</span><span>;</span> <span>do</span>
  <span>echo</span> <span>"剩下 <span>$#</span> 个参数"</span>
  <span>echo</span> <span>"参数: <span>$1</span>"</span>
  <span>shift</span>
<span>done</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>上面例子中，<code>shift</code> 命令每次移除当前第一个参数，从而通过 <code>while</code> 循环遍历所有参数。</p>
<p><code>shift</code> 命令可以接受一个整数作为参数，指定所要移除的参数个数，默认为 <code>1</code>。</p>
<div><pre><code><span>shift</span> <span>3</span>
</code></pre>
<div><span>1</span><br></div></div><p>上面的命令移除前三个参数，原来的 <code>$4</code> 变成 <code>$1</code>。</p>
<h2 id="getopts-命令"> getopts 命令</h2>
<p><code>getopts</code> 命令用在脚本内部，可以解析复杂的脚本命令行参数，通常与 <code>while</code> 循环一起使用，取出脚本所有的带有前置连词线 (<code>-</code>) 的参数。</p>
<div><pre><code><span>getopts</span> optstring name
</code></pre>
<div><span>1</span><br></div></div><p>它带有两个参数。第一个参数 <code>optstring</code> 是字符串，给出脚本所有的连词线参数。比如，某个脚本可以有三个配置项参数 <code>-l</code>、<code>-h</code>、<code>-a</code>，其中只有 <code>-a</code> 可以带有参数值，而 <code>-l</code> 和 <code>-h</code> 是开关参数，那么 <code>getopts</code> 的第一个参数写成 <code>lha:</code>，顺序不重要。注意，<code>a</code> 后面有一个冒号，表示该参数带有参数值，<code>getopts</code> 规定带有参数值的配置项参数，后面必须带有一个冒号 (<code>:</code>)。<code>getopts</code> 的第二个参数 <code>name</code> 是一个变量名，用来保存当前取到的配置项参数，即 <code>l</code>、<code>h</code> 或 <code>a</code>。</p>
<p>下面是一个例子。</p>
<div><pre><code><span>while</span> <span>getopts</span> <span>'lha:'</span> OPTION<span>;</span> <span>do</span>
  <span>case</span> <span>"<span>$OPTION</span>"</span> <span>in</span>
    l<span>)</span>
      <span>echo</span> <span>"linuxconfig"</span>
      <span>;</span><span>;</span>

    h<span>)</span>
      <span>echo</span> <span>"h stands for h"</span>
      <span>;</span><span>;</span>

    a<span>)</span>
      <span>avalue</span><span>=</span><span>"<span>$OPTARG</span>"</span>
      <span>echo</span> <span>"The value provided is <span>$OPTARG</span>"</span>
      <span>;</span><span>;</span>
    ?<span>)</span>
      <span>echo</span> <span>"script usage: <span><span>$(</span><span>basename</span> $0<span>)</span></span> [-l] [-h] [-a somevalue]"</span> <span>></span><span>&amp;2</span>
      <span>exit</span> <span>1</span>
      <span>;</span><span>;</span>
  <span>esac</span>
<span>done</span>
<span>shift</span> <span>"<span><span>$((</span>$OPTIND <span>-</span> <span>1</span><span>))</span></span>"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><p>上面例子中，<code>while</code> 循环不断执行 <code>getopts 'lha:' OPTION</code> 命令，每次执行就会读取一个连词线参数(以及对应的参数值)，然后进入循环体。变量 <code>OPTION</code> 保存的是，当前处理的那一个连词线参数(即 <code>l</code>、<code>h</code> 或 <code>a</code>)。如果用户输入了没有指定的参数(比如 <code>-x</code>)，那么 <code>OPTION</code> 等于 <code>?</code>。循环体内使用 <code>case</code> 判断，处理这四种不同的情况。</p>
<p>如果某个连词线参数带有参数值，比如 <code>-a foo</code>，那么处理 <code>a</code> 参数的时候，环境变量 <code>$OPTARG</code> 保存的就是参数值。</p>
<p>注意，只要遇到不带连词线的参数，<code>getopts</code> 就会执行失败，从而退出 <code>while</code> 循环。比如，<code>getopts</code> 可以解析 <code>command -l foo</code>，但不可以解析 <code>command foo -l</code>。另外，多个连词线参数写在一起的形式，比如 <code>command -lh</code>，<code>getopts</code> 也可以正确处理。</p>
<p>变量 <code>$OPTIND</code> 在 <code>getopts</code> 开始执行前是 <code>1</code>，然后每次执行就会加 <code>1</code>。等到退出 <code>while</code> 循环，就意味着连词线参数全部处理完毕。这时，<code>$OPTIND - 1</code> 就是已经处理的连词线参数个数，使用 <code>shift</code> 命令将这些参数移除，保证后面的代码可以用 <code>$1</code>、<code>$2</code> 等处理命令的主参数。</p>
<h2 id="配置项参数终止符"> 配置项参数终止符 <code>--</code></h2>
<p>变量当作命令的参数时，有时希望指定变量只能作为实体参数，不能当作配置项参数，这时可以使用配置项参数终止符 <code>--</code>。</p>
<div><pre><code><span>myPath</span><span>=</span><span>"~/docs"</span>
<span>ls</span> -- <span>$myPath</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>上面例子中，<code>--</code> 强制变量 <code>$myPath</code> 只能当作实体参数(即路径名)解释。</p>
<p>如果变量不是路径名，就会报错。</p>
<div><pre><code>$ <span>myPath</span><span>=</span><span>"-l"</span>
$ <span>ls</span> -- <span>$myPath</span>
ls: 无法访问<span>'-l'</span><span>:</span> 没有那个文件或目录
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>上面例子中，变量 <code>myPath</code> 的值为 <code>-l</code>，不是路径。但是，<code>--</code> 强制 <code>$myPath</code> 只能作为路径解释，导致报错“不存在该路径”。</p>
<h2 id="exit-命令"> exit 命令</h2>
<p><code>exit</code> 命令用于终止当前脚本的执行，并向 Shell 返回一个退出值。</p>
<div><pre><code><span>exit</span>
</code></pre>
<div><span>1</span><br></div></div><p>上面命令中止当前脚本，将最后一条命令的退出状态，作为整个脚本的退出状态。</p>
<p><code>exit</code> 命令后面可以跟参数，该参数就是退出状态。</p>
<div><pre><code><span># 退出值为0(成功)</span>
$ <span>exit</span> <span>0</span>

<span># 退出值为1(失败)</span>
$ <span>exit</span> <span>1</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>退出时，脚本会返回一个退出值。脚本的退出值，<code>0</code> 表示正常，<code>1</code> 表示发生错误，<code>2</code> 表示用法不对，<code>126</code> 表示不是可执行脚本，<code>127</code> 表示命令没有发现。如果脚本被信号 <code>N</code> 终止，则退出值为 <code>128 + N</code>。简单来说，只要退出值非 0，就认为执行出错。</p>
<p>下面是一个例子。</p>
<div><pre><code><span>if</span> <span>[</span> <span><span>$(</span><span>id</span> -u<span>)</span></span> <span>!=</span> <span>"0"</span> <span>]</span><span>;</span> <span>then</span>
  <span>echo</span> <span>"根用户才能执行当前脚本"</span>
  <span>exit</span> <span>1</span>
<span>fi</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>上面的例子中，<code>id -u</code> 命令返回用户的 ID，一旦用户的 ID 不等于 <code>0</code>(根用户的 ID)，脚本就会退出，并且退出码为 <code>1</code>，表示运行失败。</p>
<p><code>exit</code> 与 <code>return</code> 命令的差别是，<code>return</code> 命令是函数的退出，并返回一个值给调用者，脚本依然执行。<code>exit</code> 是整个脚本的退出，如果在函数之中调用 <code>exit</code>，则退出函数，并终止脚本执行。</p>
<h2 id="命令执行结果"> 命令执行结果</h2>
<p>命令执行结束后，会有一个返回值。<code>0</code> 表示执行成功，非 <code>0</code> (通常是 <code>1</code>)表示执行失败。环境变量 <code>$?</code> 可以读取前一个命令的返回值。</p>
<p>利用这一点，可以在脚本中对命令执行结果进行判断。</p>
<div><pre><code><span>cd</span> <span>$some_directory</span>
<span>if</span> <span>[</span> <span>"<span>$?</span>"</span> <span>=</span> <span>"0"</span> <span>]</span><span>;</span> <span>then</span>
  <span>rm</span> *
<span>else</span>
  <span>echo</span> <span>"无法切换目录!"</span> <span><span>1</span>></span><span>&amp;2</span>
  <span>exit</span> <span>1</span>
<span>fi</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>上面例子中，<code>cd $some_directory</code> 这个命令如果执行成功(返回值等于 <code>0</code>)，就删除该目录里面的文件，否则退出脚本，整个脚本的返回值变为 <code>1</code>，表示执行失败。</p>
<p>由于 <code>if</code> 可以直接判断命令的执行结果，执行相应的操作，上面的脚本可以改写成下面的样子。</p>
<div><pre><code><span>if</span> <span>cd</span> <span>$some_directory</span><span>;</span> <span>then</span>
  <span>rm</span> *
<span>else</span>
  <span>echo</span> <span>"Could not change directory! Aborting."</span> <span><span>1</span>></span><span>&amp;2</span>
  <span>exit</span> <span>1</span>
<span>fi</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>更简洁的写法是利用两个逻辑运算符 <code>&amp;&amp;</code>(且)和 <code>||</code>(或)。</p>
<div><pre><code><span># 第一步执行成功，才会执行第二步</span>
<span>cd</span> <span>$some_directory</span> <span>&amp;&amp;</span> <span>rm</span> *

<span># 第一步执行失败，才会执行第二步</span>
<span>cd</span> <span>$some_directory</span> <span>||</span> <span>exit</span> <span>1</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h2 id="source-命令"> source 命令</h2>
<p><code>source</code> 命令用于执行一个脚本，通常用于重新加载一个配置文件。</p>
<div><pre><code><span>source</span> .bashrc
</code></pre>
<div><span>1</span><br></div></div><p><code>source</code> 命令最大的特点是在当前 Shell 执行脚本，不像直接执行脚本时，会新建一个子 Shell。所以，<code>source</code> 命令执行脚本时，不需要 <code>export</code> 变量。</p>
<div><pre><code><span>#!/bin/bash</span>
<span># test.sh</span>
<span>echo</span> <span>$foo</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>上面脚本输出 <code>$foo</code> 变量的值。</p>
<div><pre><code><span># 当前 Shell 新建一个变量 foo</span>
$ <span>foo</span><span>=</span><span>1</span>

<span># 打印输出 1</span>
$ <span>source</span> test.sh
<span>1</span>

<span># 打印输出空字符串</span>
$ <span>bash</span> test.sh
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>上面例子中，当前 Shell 的变量 <code>foo</code> 并没有 <code>export</code>，所以直接执行无法读取，但是 <code>source</code> 执行可以读取。</p>
<p><code>source</code> 命令的另一个用途，是在脚本内部加载外部库。</p>
<div><pre><code><span>#!/bin/bash</span>

<span>source</span> ./lib.sh

function_from_lib
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>上面脚本在内部使用 <code>source</code> 命令加载了一个外部库，然后就可以在脚本里面，使用这个外部库定义的函数。</p>
<p><code>source</code> 有一个简写形式，可以使用一个点 (<code>.</code>) 来表示。</p>
<div><pre><code><span>.</span> .bashrc
</code></pre>
<div><span>1</span><br></div></div><h2 id="别名-alias-命令"> 别名，alias 命令</h2>
<p><code>alias</code> 命令用来为一个命令指定别名，这样更便于记忆。下面是 <code>alias</code> 的格式。</p>
<div><pre><code><span>alias</span> <span>NAME</span><span>=</span>DEFINITION
</code></pre>
<div><span>1</span><br></div></div><p>上面命令中，<code>NAME</code> 是别名的名称，<code>DEFINITION</code> 是别名对应的原始命令。注意，等号两侧不能有空格，否则会报错。</p>
<p>一个常见的例子是为 <code>grep</code> 命令起一个 <code>search</code> 的别名。</p>
<div><pre><code><span>alias</span> <span>search</span><span>=</span>grep
</code></pre>
<div><span>1</span><br></div></div><p><code>alias</code> 也可以用来为长命令指定一个更短的别名。下面是通过别名定义一个 <code>today</code> 的命令。</p>
<div><pre><code>$ <span>alias</span> <span>today</span><span>=</span><span>'date +"%A, %B %-d, %Y"'</span>
$ today
星期一, 一月 <span>6</span>, <span>2020</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>有时为了防止误删除文件，可以指定 <code>rm</code> 命令的别名。</p>
<div><pre><code><span>alias</span> <span>rm</span><span>=</span><span>'rm -i'</span>
</code></pre>
<div><span>1</span><br></div></div><p>上面命令指定 <code>rm</code> 命令是 <code>rm -i</code>，每次删除文件之前，都会让用户确认。</p>
<p><code>alias</code> 定义的别名也可以接受参数，参数会直接传入原始命令。</p>
<div><pre><code>$ <span>alias</span> <span>echo</span><span>=</span><span>'echo It says: '</span>
$ <span>echo</span> hello world
It says: hello world
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>上面例子中，别名定义了 <code>echo</code> 命令的前两个参数，等同于修改了 <code>echo</code> 命令的默认行为。</p>
<p>指定别名以后，就可以像使用其他命令一样使用别名。一般来说，都会把常用的别名写在 <code>~/.bashrc</code> 的末尾。另外，只能为命令定义别名，为其他部分(比如很长的路径)定义别名是无效的。</p>
<p>直接调用 <code>alias</code> 命令，可以显示所有别名。</p>
<div><pre><code><span>alias</span>
</code></pre>
<div><span>1</span><br></div></div><p><code>unalias</code> 命令可以解除别名。</p>
<div><pre><code><span>unalias</span> lt
</code></pre>
<div><span>1</span><br></div></div><h2 id="参考链接"> 参考链接</h2>
<ul>
<li><a href="https://linuxconfig.org/how-to-use-getopts-to-parse-a-script-options" target="_blank" rel="noopener noreferrer">How to use getopts to parse a script options</a>, Egidio Docile</li>
</ul>
]]></content>
    <author>
      <name>阮一峰</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>阮一峰</name>
    </contributor>
    <rights>本教程采用&lt;a href="https://creativecommons.org/licenses/by-sa/3.0/deed.zh"&gt;知识共享 署名-相同方式共享 3.0协议&lt;/a&gt;</rights>
  </entry>
  <entry>
    <title type="html">set 命令</title>
    <id>http://qiqi.dreamagain.top/software/linux/bash/set/</id>
    <link href="http://qiqi.dreamagain.top/software/linux/bash/set/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <summary type="html"><![CDATA[<p><code>set</code> 命令是 Bash 脚本的重要环节，却常常被忽视，导致脚本的安全性和可维护性出问题。本章介绍 <code>set</code> 的基本用法，帮助您写出更安全的 Bash 脚本。</p>
]]></summary>
    <content type="html"><![CDATA[<p><code>set</code> 命令是 Bash 脚本的重要环节，却常常被忽视，导致脚本的安全性和可维护性出问题。本章介绍 <code>set</code> 的基本用法，帮助您写出更安全的 Bash 脚本。</p>

<h2 id="简介"> 简介</h2>
<p>我们知道，Bash 执行脚本时，会创建一个子 Shell。</p>
<div><pre><code><span>bash</span> script.sh
</code></pre>
<div><span>1</span><br></div></div><p>上面代码中，<code>script.sh</code> 是在一个子 Shell 里面执行。这个子 Shell 就是脚本的执行环境，Bash 默认给定了这个环境的各种参数。</p>
<p><code>set</code> 命令用来修改子 Shell 环境的运行参数，即定制环境。一共有十几个参数可以定制，<a href="https://www.gnu.org/software/bash/manual/html_node/The-Set-Builtin.html" target="_blank" rel="noopener noreferrer">官方手册</a>有完整清单，本章介绍其中最常用的几个。</p>
<p>顺便提一下，如果命令行下不带任何参数，直接运行 <code>set</code>，会显示所有的环境变量和 Shell 函数。</p>
<div><pre><code><span>set</span>
</code></pre>
<div><span>1</span><br></div></div><h2 id="set-u"> set -u</h2>
<p>执行脚本时，如果遇到不存在的变量，Bash 默认忽略它。</p>
<div><pre><code><span>#!/usr/bin/env bash</span>

<span>echo</span> <span>$a</span>
<span>echo</span> bar
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>上面代码中，<code>$a</code> 是一个不存在的变量。执行结果如下。</p>
<div><pre><code>$ <span>bash</span> script.sh

bar
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>可以看到，<code>echo $a</code> 输出了一个空行，Bash 忽略了不存在的 <code>$a</code>，然后继续执行 <code>echo bar</code>。大多数情况下，这不是开发者想要的行为，遇到变量不存在，脚本应该报错，而不是一声不响地往下执行。</p>
<p><code>set -u</code> 就用来改变这种行为。脚本在头部加上它，遇到不存在的变量就会报错，并停止执行。</p>
<div><pre><code><span>#!/usr/bin/env bash</span>
<span>set</span> -u

<span>echo</span> <span>$a</span>
<span>echo</span> bar
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>运行结果如下。</p>
<div><pre><code>$ <span>bash</span> script.sh
bash: script.sh:行4: a: 未绑定的变量
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>可以看到，脚本报错了，并且不再执行后面的语句。</p>
<p><code>-u</code> 还有另一种写法 <code>-o nounset</code>，两者是等价的。</p>
<div><pre><code><span>set</span> -o nounset
</code></pre>
<div><span>1</span><br></div></div><h2 id="set-x"> set -x</h2>
<p>默认情况下，脚本执行后，只输出运行结果，没有其他内容。如果多个命令连续执行，它们的运行结果就会连续输出。有时会分不清，某一段内容是什么命令产生的。</p>
<p><code>set -x</code> 用来在运行结果之前，先输出执行的那一行命令。</p>
<div><pre><code><span>#!/usr/bin/env bash</span>
<span>set</span> -x

<span>echo</span> bar
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>执行上面的脚本，结果如下。</p>
<div><pre><code>$ <span>bash</span> script.sh
+ <span>echo</span> bar
bar
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>可以看到，执行 <code>echo bar</code> 之前，该命令会先打印出来，行首以 <code>+</code> 表示。这对于调试复杂的脚本是很有用的。</p>
<p><code>-x</code> 还有另一种写法 <code>-o xtrace</code>。</p>
<div><pre><code><span>set</span> -o xtrace
</code></pre>
<div><span>1</span><br></div></div><p>脚本当中如果要关闭命令输出，可以使用 <code>set +x</code>。</p>
<div><pre><code><span>#!/bin/bash</span>

<span>number</span><span>=</span><span>1</span>

<span>set</span> -x
<span>if</span> <span>[</span> <span>$number</span> <span>=</span> <span>"1"</span> <span>]</span><span>;</span> <span>then</span>
  <span>echo</span> <span>"Number equals 1"</span>
<span>else</span>
  <span>echo</span> <span>"Number does not equal 1"</span>
<span>fi</span>
<span>set</span> +x
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>上面的例子中，只对特定的代码段打开命令输出。</p>
<h2 id="bash-的错误处理"> Bash 的错误处理</h2>
<p>如果脚本里面有运行失败的命令(返回值非 <code>0</code>)，Bash 默认会继续执行后面的命令。</p>
<div><pre><code><span>#!/usr/bin/env bash</span>

foo
<span>echo</span> bar
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>上面脚本中，<code>foo</code> 是一个不存在的命令，执行时会报错。但是，Bash 会忽略这个错误，继续往下执行。</p>
<div><pre><code>$ <span>bash</span> script.sh
script.sh:行3: foo: 未找到命令
bar
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>可以看到，Bash 只是显示有错误，并没有终止执行。</p>
<p>这种行为很不利于脚本安全和除错。实际开发中，如果某个命令失败，往往需要脚本停止执行，防止错误累积。这时，一般采用下面的写法。</p>
<div><pre><code><span>command</span> <span>||</span> <span>exit</span> <span>1</span>
</code></pre>
<div><span>1</span><br></div></div><p>上面的写法表示只要 <code>command</code> 有非零返回值，脚本就会停止执行。</p>
<p>如果停止执行之前需要完成多个操作，就要采用下面三种写法。</p>
<div><pre><code><span># 写法一</span>
<span>command</span> <span>||</span> <span>{</span> <span>echo</span> <span>"command failed"</span><span>;</span> <span>exit</span> <span>1</span><span>;</span> <span>}</span>

<span># 写法二</span>
<span>if</span> <span>!</span> <span>command</span><span>;</span> <span>then</span> <span>echo</span> <span>"command failed"</span><span>;</span> <span>exit</span> <span>1</span><span>;</span> <span>fi</span>

<span># 写法三</span>
<span>command</span>
<span>if</span> <span>[</span> <span>"<span>$?</span>"</span> -ne <span>0</span> <span>]</span><span>;</span> <span>then</span> <span>echo</span> <span>"command failed"</span><span>;</span> <span>exit</span> <span>1</span><span>;</span> <span>fi</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>另外，除了停止执行，还有一种情况。如果两个命令有继承关系，只有第一个命令成功了，才能继续执行第二个命令，那么就要采用下面的写法。</p>
<div><pre><code>command1 <span>&amp;&amp;</span> command2
</code></pre>
<div><span>1</span><br></div></div><h2 id="set-e"> set -e</h2>
<p>上面这些写法多少有些麻烦，容易疏忽。<code>set -e</code> 从根本上解决了这个问题，它使得脚本只要发生错误，就终止执行。</p>
<div><pre><code><span>#!/usr/bin/env bash</span>
<span>set</span> -e

foo
<span>echo</span> bar
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>执行结果如下。</p>
<div><pre><code>$ <span>bash</span> script.sh
script.sh:行4: foo: 未找到命令
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>可以看到，第 4 行执行失败以后，脚本就终止执行了。</p>
<p><code>set -e</code> 根据返回值来判断，一个命令是否运行失败。但是，某些命令的非零返回值可能不表示失败，或者开发者希望在命令失败的情况下，脚本继续执行下去。这时可以暂时关闭 <code>set -e</code>，该命令执行结束后，再重新打开 <code>set -e</code>。</p>
<div><pre><code><span>set</span> +e
command1
command2
<span>set</span> -e
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>上面代码中，<code>set +e</code> 表示关闭 <code>-e</code> 选项，<code>set -e</code> 表示重新打开 <code>-e</code> 选项。</p>
<p>还有一种方法是使用 <code>command || true</code>，使得该命令即使执行失败，脚本也不会终止执行。</p>
<div><pre><code><span>#!/bin/bash</span>
<span>set</span> -e

foo <span>||</span> <span>true</span>
<span>echo</span> bar
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>上面代码中，<code>true</code> 使得这一行语句总是会执行成功，后面的 <code>echo bar</code> 会执行。</p>
<p><code>-e</code> 还有另一种写法 <code>-o errexit</code>。</p>
<div><pre><code><span>set</span> -o errexit
</code></pre>
<div><span>1</span><br></div></div><h2 id="set-o-pipefail"> set -o pipefail</h2>
<p><code>set -e</code> 有一个例外情况，就是不适用于管道命令。</p>
<p>所谓管道命令，就是多个子命令通过管道运算符 (<code>|</code>) 组合成为一个大的命令。Bash 会把最后一个子命令的返回值，作为整个命令的返回值。也就是说，只要最后一个子命令不失败，管道命令总是会执行成功，因此它后面命令依然会执行，<code>set -e</code> 就失效了。</p>
<p>请看下面这个例子。</p>
<div><pre><code><span>#!/usr/bin/env bash</span>
<span>set</span> -e

foo <span>|</span> <span>echo</span> a
<span>echo</span> bar
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>执行结果如下。</p>
<div><pre><code>$ <span>bash</span> script.sh
a
script.sh:行4: foo: 未找到命令
bar
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>上面代码中，<code>foo</code> 是一个不存在的命令，但是 <code>foo | echo a</code> 这个管道命令会执行成功，导致后面的 <code>echo bar</code> 会继续执行。</p>
<p><code>set -o pipefail</code> 用来解决这种情况，只要一个子命令失败，整个管道命令就失败，脚本就会终止执行。</p>
<div><pre><code><span>#!/usr/bin/env bash</span>
<span>set</span> -eo pipefail

foo <span>|</span> <span>echo</span> a
<span>echo</span> bar
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>运行后，结果如下。</p>
<div><pre><code>$ <span>bash</span> script.sh
a
script.sh:行4: foo: 未找到命令
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>可以看到，<code>echo bar</code> 没有执行。</p>
<h2 id="其他参数"> 其他参数</h2>
<p><code>set</code> 命令还有一些其他参数。</p>
<ul>
<li><code>set -n</code>: 等同于 <code>set -o noexec</code>，不运行命令，只检查语法是否正确。</li>
<li><code>set -f</code>: 等同于 <code>set -o noglob</code>，表示不对通配符进行文件名扩展。</li>
<li><code>set -v</code>: 等同于 <code>set -o verbose</code>，表示打印 Shell 接收到的每一行输入。</li>
</ul>
<p>上面的 <code>-f</code> 和 <code>-v</code> 参数，可以分别使用 <code>set +f</code>、<code>set +v</code> 关闭。</p>
<h2 id="set-命令总结"> set 命令总结</h2>
<p>上面重点介绍的 <code>set</code> 命令的四个参数，一般都放在一起使用。</p>
<div><pre><code><span># 写法一</span>
<span>set</span> -euxo pipefail

<span># 写法二</span>
<span>set</span> -eux
<span>set</span> -o pipefail
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>这两种写法建议放在所有 Bash 脚本的头部。</p>
<p>另一种办法是在执行 Bash 脚本的时候，从命令行传入这些参数。</p>
<div><pre><code><span>bash</span> -euxo pipefail script.sh
</code></pre>
<div><span>1</span><br></div></div><h2 id="shopt-命令"> shopt 命令</h2>
<p><code>shopt</code> 命令用来调整 Shell 的参数，跟 <code>set</code> 命令的作用很类似。之所以会有这两个类似命令的主要原因是，<code>set</code> 是从 Ksh 继承的，属于 POSIX 规范的一部分，而 <code>shopt</code> 是 Bash 特有的。</p>
<p>直接输入 <code>shopt</code> 可以查看所有参数，以及它们各自打开和关闭的状态。</p>
<div><pre><code><span>shopt</span>
</code></pre>
<div><span>1</span><br></div></div><p><code>shopt</code> 命令后面跟着参数名，可以查询该参数是否打开。</p>
<div><pre><code>$ <span>shopt</span> globstar
globstar  off
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>上面例子表示 <code>globstar</code> 参数默认是关闭的。</p>
<ol>
<li>
<p><strong><code>-s</code></strong></p>
<p><code>-s</code> 用来打开某个参数。</p>
<div><pre><code><span>shopt</span> -s optionNameHere
</code></pre>
<div><span>1</span><br></div></div></li>
<li>
<p><strong><code>-u</code></strong></p>
<p><code>-u</code> 用来关闭某个参数。</p>
<div><pre><code><span>shopt</span> -u optionNameHere
</code></pre>
<div><span>1</span><br></div></div><p>举例来说，<code>histappend</code> 这个参数表示退出当前 Shell 时，将操作历史追加到历史文件中。这个参数默认是打开的，如果使用下面的命令将其关闭，那么当前 Shell 的操作历史将替换掉整个历史文件。</p>
<div><pre><code><span>shopt</span> -u histappend
</code></pre>
<div><span>1</span><br></div></div></li>
<li>
<p><strong><code>-q</code></strong></p>
<p><code>-q</code> 的作用也是查询某个参数是否打开，但不是直接输出查询结果，而是通过命令的执行状态 (<code>$?</code>) 表示查询结果。如果状态为 <code>0</code>，表示该参数打开；如果为 <code>1</code>，表示该参数关闭。</p>
<div><pre><code>$ <span>shopt</span> -q globstar
$ <span>echo</span> <span>$?</span>
<span>1</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>上面命令查询 <code>globstar</code> 参数是否打开。返回状态为 <code>1</code>，表示该参数是关闭的。</p>
<p>这个用法主要用于脚本，供 <code>if</code> 条件结构使用。</p>
<div><pre><code><span>if</span> <span>shopt</span> -q globstar<span>;</span> <span>then</span>
  <span>..</span>.
<span>if</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div></li>
</ol>
<h2 id="参考链接"> 参考链接</h2>
<ul>
<li><a href="https://www.gnu.org/software/bash/manual/html_node/The-Set-Builtin.html" target="_blank" rel="noopener noreferrer">The Set built-in</a></li>
<li><a href="https://vaneyckt.io/posts/safer_bash_scripts_with_set_euxo_pipefail/" target="_blank" rel="noopener noreferrer">Safer bash scripts with 'set -euxo pipefail’</a></li>
<li><a href="http://www.davidpashley.com/articles/writing-robust-shell-scripts/" target="_blank" rel="noopener noreferrer">Writing Robust Bash Shell Scripts</a></li>
</ul>
]]></content>
    <author>
      <name>阮一峰</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>阮一峰</name>
    </contributor>
    <rights>本教程采用&lt;a href="https://creativecommons.org/licenses/by-sa/3.0/deed.zh"&gt;知识共享 署名-相同方式共享 3.0协议&lt;/a&gt;</rights>
  </entry>
  <entry>
    <title type="html">目录堆栈</title>
    <id>http://qiqi.dreamagain.top/software/linux/bash/stack/</id>
    <link href="http://qiqi.dreamagain.top/software/linux/bash/stack/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <summary type="html"><![CDATA[<p>为了方便用户在不同目录之间切换，Bash 提供了目录堆栈功能。</p>
]]></summary>
    <content type="html"><![CDATA[<p>为了方便用户在不同目录之间切换，Bash 提供了目录堆栈功能。</p>

<h2 id="cd"> cd -</h2>
<p>Bash 可以记忆用户进入过的目录。默认情况下，只记忆前一次所在的目录，<code>cd -</code> 命令可以返回前一次的目录。</p>
<div><pre><code><span># 当前目录是 /path/to/foo</span>
$ <span>cd</span> bar

<span># 重新回到 /path/to/foo</span>
$ <span>cd</span> -
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>上面例子中，用户原来所在的目录是 <code>/path/to/foo</code>，进入子目录 <code>bar</code> 以后，使用 <code>cd -</code> 可以回到原来的目录。</p>
<h2 id="pushd-popd"> pushd，popd</h2>
<p>如果希望记忆多重目录，可以使用 <code>pushd</code> 命令和 <code>popd</code> 命令。它们用来操作目录堆栈。</p>
<p><code>pushd</code> 命令的用法类似 <code>cd</code> 命令，可以进入指定的目录。</p>
<div><pre><code><span>pushd</span> <span>dirname</span>
</code></pre>
<div><span>1</span><br></div></div><p>上面命令会进入目录 <code>dirname</code>，并将该目录放入堆栈。</p>
<p>第一次使用 <code>pushd</code> 命令时，会将当前目录先放入堆栈，然后将所要进入的目录也放入堆栈，位置在前一个记录的上方。以后每次使用 <code>pushd</code> 命令，都会将所要进入的目录，放在堆栈的顶部。</p>
<p><code>popd</code> 命令不带有参数时，会移除堆栈的顶部记录，并进入新的堆栈顶部目录(即原来的第二条目录)。</p>
<p>下面是一个例子。</p>
<div><pre><code><span># 当前处在主目录，堆栈为空</span>
$ <span>pwd</span>
/home/me

<span># 进入 /home/me/foo</span>
<span># 当前堆栈为 /home/me/foo /home/me</span>
$ <span>pushd</span> ~/foo

<span># 进入 /etc</span>
<span># 当前堆栈为 /etc /home/me/foo /home/me</span>
$ <span>pushd</span> /etc

<span># 进入 /home/me/foo</span>
<span># 当前堆栈为 /home/me/foo /home/me</span>
$ <span>popd</span>

<span># 进入 /home/me</span>
<span># 当前堆栈为 /home/me</span>
$ <span>popd</span>

<span># 目录不变，当前堆栈为空</span>
$ <span>popd</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><p>这两个命令的参数如下。</p>
<ol>
<li>
<p><strong><code>-n</code> 参数</strong></p>
<p><code>-n</code> 的参数表示仅操作堆栈，不改变目录。</p>
<div><pre><code><span>popd</span> -n
</code></pre>
<div><span>1</span><br></div></div><p>上面的命令仅删除堆栈顶部的记录，不改变目录，执行完成后还停留在当前目录。</p>
</li>
<li>
<p><strong>整数参数</strong></p>
<p>这两个命令还可以接受一个整数作为参数，该整数表示堆栈中指定位置的记录(从 0 开始)，作为操作对象。这时不会切换目录。</p>
<div><pre><code><span># 从栈顶算起的3号目录(从0开始)，移动到栈顶</span>
$ <span>pushd</span> +3

<span># 从栈底算起的3号目录(从0开始)，移动到栈顶</span>
$ <span>pushd</span> -3

<span># 删除从栈顶算起的3号目录(从0开始)</span>
$ <span>popd</span> +3

<span># 删除从栈底算起的3号目录(从0开始)</span>
$ <span>popd</span> -3
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>上面例子的整数编号都是从 0 开始计算，<code>popd +0</code> 是删除第一个目录，<code>popd +1</code> 是删除第二个，<code>popd -0</code> 是删除最后一个目录，，<code>popd -1</code> 是删除倒数第二个。</p>
</li>
<li>
<p><strong>目录参数</strong></p>
<p><code>pushd</code> 可以接受一个目录作为参数，表示将该目录放到堆栈顶部，并进入该目录。</p>
<div><pre><code><span>pushd</span> <span>dir</span>
</code></pre>
<div><span>1</span><br></div></div><p><code>popd</code> 没有这个参数。</p>
</li>
</ol>
<h2 id="dirs-命令"> dirs 命令</h2>
<p><code>dirs</code> 命令可以显示目录堆栈的内容，一般用来查看 <code>pushd</code> 和 <code>popd</code> 操作后的结果。</p>
<div><pre><code><span>dirs</span>
</code></pre>
<div><span>1</span><br></div></div><p>它有以下参数。</p>
<ul>
<li><code>-c</code>: 清空目录栈。</li>
<li><code>-l</code>: 用户主目录不显示波浪号前缀，而打印完整的目录。</li>
<li><code>-p</code>: 每行一个条目打印目录栈，默认是打印在一行。</li>
<li><code>-v</code>: 每行一个条目，每个条目之前显示位置编号(从 0 开始)。</li>
<li><code>+N</code>: <code>N</code> 为整数，表示显示堆顶算起的第 N 个目录，从零开始。</li>
<li><code>-N</code>: <code>N</code> 为整数，表示显示堆底算起的第 N 个目录，从零开始。</li>
</ul>
]]></content>
    <author>
      <name>阮一峰</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>阮一峰</name>
    </contributor>
    <rights>本教程采用&lt;a href="https://creativecommons.org/licenses/by-sa/3.0/deed.zh"&gt;知识共享 署名-相同方式共享 3.0协议&lt;/a&gt;</rights>
  </entry>
  <entry>
    <title type="html">Bash 启动环境</title>
    <id>http://qiqi.dreamagain.top/software/linux/bash/startup/</id>
    <link href="http://qiqi.dreamagain.top/software/linux/bash/startup/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<h2 id="session"> Session</h2>
<p>用户每次使用 Shell，都会开启一个与 Shell 的 Session(对话)。</p>
<p>Session 有两种类型: 登录 Session 和非登录 Session，也可以叫做 login shell 和 non-login shell。</p>
<h3 id="登录-session"> 登录 Session</h3>
<p>登录 Session 是用户登录系统以后，系统为用户开启的原始 Session，通常需要用户输入用户名和密码进行登录。</p>
<p>登录 Session 一般进行整个系统环境的初始化，启动的初始化脚本依次如下。</p>
<ul>
<li><code>/etc/profile</code>: 所有用户的全局配置脚本。</li>
<li><code>/etc/profile.d</code> 目录里面所有 <code>.sh</code> 文件</li>
<li><code>~/.bash_profile</code>: 用户的个人配置脚本。如果该脚本存在，则执行完就不再往下执行。</li>
<li><code>~/.bash_login</code>: 如果 <code>~/.bash_profile</code> 没找到，则尝试执行这个脚本(C shell 的初始化脚本)。如果该脚本存在，则执行完就不再往下执行。</li>
<li><code>~/.profile</code>: 如果<code>~/.bash_profile</code> 和 <code>~/.bash_login</code> 都没找到，则尝试读取这个脚本(Bourne shell 和 Korn shell 的初始化脚本)。</li>
</ul>
<p>Linux 发行版更新的时候，会更新 <code>/etc</code> 里面的文件，比如 <code>/etc/profile</code>，因此不要直接修改这个文件。如果想修改所有用户的登陆环境，就在 <code>/etc/profile.d</code> 目录里面新建 <code>.sh</code> 脚本。</p>
<p>如果想修改您个人的登录环境，一般是写在 <code>~/.bash_profile</code> 里面。下面是一个典型的 <code>.bash_profile</code> 文件。</p>
<div><pre><code><span># .bash_profile</span>
<span><span>PATH</span></span><span>=</span>/sbin:/usr/sbin:/bin:/usr/bin:/usr/local/bin
<span><span>PATH</span></span><span>=</span><span>$PATH</span><span>:</span><span>$HOME</span>/bin

<span><span>SHELL</span></span><span>=</span>/bin/bash
<span>MANPATH</span><span>=</span>/usr/man:/usr/X11/man
<span>EDITOR</span><span>=</span>/usr/bin/vi
<span><span>PS1</span></span><span>=</span><span>'\h:\w\$ '</span>
<span><span>PS2</span></span><span>=</span><span>'> '</span>

<span>if</span> <span>[</span> -f ~/.bashrc <span>]</span><span>;</span> <span>then</span>
<span>.</span> ~/.bashrc
<span>fi</span>

<span>export</span> <span>PATH</span>
<span>export</span> EDITOR
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>可以看到，这个脚本定义了一些最基本的环境变量，然后执行了 <code>~/.bashrc</code>。</p>
<p><code>bash</code> 命令的 <code>--login</code> 参数，会强制执行登录 Session 会执行的脚本。</p>
<div><pre><code><span>bash</span> --login
</code></pre>
<div><span>1</span><br></div></div><p><code>bash</code> 命令的 <code>--noprofile</code> 参数，会跳过上面这些 Profile 脚本。</p>
<div><pre><code><span>bash</span> --noprofile
</code></pre>
<div><span>1</span><br></div></div><h3 id="非登录-session"> 非登录 Session</h3>
<p>非登录 Session 是用户进入系统以后，手动新建的 Session，这时不会进行环境初始化。比如，在命令行执行 <code>bash</code> 命令，就会新建一个非登录 Session。</p>
<p>非登录 Session 的初始化脚本依次如下。</p>
<ul>
<li><code>/etc/bash.bashrc</code>: 对全体用户有效。</li>
<li><code>~/.bashrc</code>: 仅对当前用户有效。</li>
</ul>
<p>对用户来说，<code>~/.bashrc</code> 通常是最重要的脚本。非登录 Session 默认会执行它，而登陆 Session 一般也会通过调用执行它。由于每次执行 Bash 脚本，都会新建一个非登录 Session，所以 <code>~/.bashrc</code> 也是每次执行脚本都会执行的。</p>
<p><code>bash</code> 命令的 <code>--norc</code> 参数，可以禁止在非登录 Session 执行 <code>~/.bashrc</code> 脚本。</p>
<div><pre><code><span>bash</span> --norc
</code></pre>
<div><span>1</span><br></div></div><p><code>bash</code> 命令的 <code>--rcfile</code> 参数，指定另一个脚本代替 <code>.bashrc</code>。</p>
<div><pre><code><span>bash</span> --rcfile testrc
</code></pre>
<div><span>1</span><br></div></div><h3 id="bash-logout"> .bash_logout</h3>
<p><code>~/.bash_logout</code> 脚本在每次退出 Session 时执行，通常用来做一些清理工作和记录工作，比如删除临时文件，记录用户在本次 Session 花费的时间。</p>
<p>如果没有退出时要执行的命令，这个文件也可以不存在。</p>
<h2 id="启动选项"> 启动选项</h2>
<p>为了方便 Debug，有时在启动 Bash 的时候，可以加上启动参数。</p>
<ul>
<li><code>-n</code>: 不运行脚本，只检查是否有语法错误。</li>
<li><code>-v</code>: 输出每一行语句运行结果前，会先输出该行语句。</li>
<li><code>-x</code>: 每一个命令处理完以后，先输出该命令，再进行下一个命令的处理。</li>
</ul>
<div><pre><code><span>bash</span> -n scriptname
<span>bash</span> -v scriptname
<span>bash</span> -x scriptname
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id="键盘绑定"> 键盘绑定</h2>
<p>Bash 允许用户定义自己的快捷键。全局的键盘绑定文件默认为 <code>/etc/inputrc</code>，您可以在主目录创建自己的键盘绑定文件 <code>.inputrc</code> 文件。如果定义了这个文件，需要在其中加入下面这行，保证全局绑定不会被遗漏。</p>
<div><pre><code><span>$include</span> /etc/inputrc
</code></pre>
<div><span>1</span><br></div></div><p><code>.inputrc</code> 文件里面的快捷键，可以像这样定义，<code>&quot;\C-t&quot;:&quot;pwd\n&quot;</code> 表示将 <code>Ctrl + t</code> 绑定为运行 <code>pwd</code> 命令。</p>
]]></content>
    <author>
      <name>阮一峰</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>阮一峰</name>
    </contributor>
    <rights>本教程采用&lt;a href="https://creativecommons.org/licenses/by-sa/3.0/deed.zh"&gt;知识共享 署名-相同方式共享 3.0协议&lt;/a&gt;</rights>
  </entry>
  <entry>
    <title type="html">字符串操作</title>
    <id>http://qiqi.dreamagain.top/software/linux/bash/string/</id>
    <link href="http://qiqi.dreamagain.top/software/linux/bash/string/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <summary type="html"><![CDATA[<p>本章介绍 Bash 字符串操作的语法。</p>
]]></summary>
    <content type="html"><![CDATA[<p>本章介绍 Bash 字符串操作的语法。</p>

<h2 id="字符串的长度"> 字符串的长度</h2>
<p>获取字符串长度的语法如下。</p>
<div><pre><code><span>${<span>#</span>varname}</span>
</code></pre>
<div><span>1</span><br></div></div><p>下面是一个例子。</p>
<div><pre><code>$ <span>myPath</span><span>=</span>/home/cam/book/long.file.name
$ <span>echo</span> <span>${<span>#</span>myPath}</span>
<span>29</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>大括号 <code>{}</code> 是必需的，否则 Bash 会将 <code>$#</code> 理解成脚本的参数个数，将变量名理解成文本。</p>
<div><pre><code>$ <span>echo</span> <span>$#</span>myvar
0myvar
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>上面例子中，Bash 将 <code>$#</code> 和 <code>myvar</code> 分开解释了。</p>
<h2 id="子字符串"> 子字符串</h2>
<p>字符串提取子串的语法如下。</p>
<div><pre><code><span>${varname<span>:</span>offset<span>:</span>length}</span>
</code></pre>
<div><span>1</span><br></div></div><p>上面语法的含义是返回变量 <code>$varname</code> 的子字符串，从位置 <code>offset</code> 开始(从 <code>0</code> 开始计算)，长度为 <code>length</code>。</p>
<div><pre><code>$ <span>count</span><span>=</span>frogfootman
$ <span>echo</span> <span>${count<span>:</span>4<span>:</span>4}</span>
foot
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>上面例子返回字符串 <code>frogfootman</code> 从 4 号位置开始的长度为 4 的子字符串 <code>foot</code>。</p>
<p>这种语法不能直接操作字符串，只能通过变量来读取字符串，并且不会改变原始字符串。变量前面的美元符号可以省略。</p>
<div><pre><code><span># 报错</span>
$ <span>echo</span> <span>${"hello"<span>:</span>2<span>:</span>3}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>上面例子中，<code>&quot;hello&quot;</code> 不是变量名，导致 Bash 报错。</p>
<p>如果省略 <code>length</code>，则从位置 <code>offset</code> 开始，一直返回到字符串的结尾。</p>
<div><pre><code>$ <span>count</span><span>=</span>frogfootman
$ <span>echo</span> <span>${count<span>:</span>4}</span>
footman
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>上面例子是返回变量 <code>count</code> 从 4 号位置一直到结尾的子字符串。</p>
<p>如果 <code>offset</code> 为负值，表示从字符串的末尾开始算起。注意，负数前面必须有一个空格， 以防止与 <code>${variable:-word}</code> 的变量的设置默认值语法混淆。这时，如果还指定 <code>length</code>，则 <code>length</code> 不能小于零。</p>
<div><pre><code>$ <span>foo</span><span>=</span><span>"This string is long."</span>
$ <span>echo</span> <span>${foo<span>:</span> -5}</span>
long.
$ <span>echo</span> <span>${foo<span>:</span> -5<span>:</span>2}</span>
lo
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>上面例子中，<code>offset</code> 为 <code>-5</code>，表示从倒数第 5 个字符开始截取，所以返回 <code>long.</code>。如果指定长度为 <code>2</code>，则返回 <code>lo</code>。</p>
<h2 id="搜索和替换"> 搜索和替换</h2>
<p>Bash 提供字符串搜索和替换的多种方法。</p>
<h3 id="字符串头部的模式匹配"> 字符串头部的模式匹配</h3>
<p>以下两种语法可以检查字符串开头，是否匹配给定的模式。如果匹配成功，就删除匹配的部分，返回剩下的部分。原始变量不会发生变化。</p>
<div><pre><code><span># 如果 pattern 匹配变量 variable 的开头，</span>
<span># 删除最短匹配(非贪婪匹配)的部分，返回剩余部分</span>
<span>${variable<span>#</span>pattern}</span>

<span># 如果 pattern 匹配变量 variable 的开头，</span>
<span># 删除最长匹配(贪婪匹配)的部分，返回剩余部分</span>
<span>${variable<span>##</span>pattern}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>上面两种语法会删除变量字符串开头的匹配部分(将其替换为空)，返回剩下的部分。区别是一个是最短匹配(又称非贪婪匹配)，另一个是最长匹配(又称贪婪匹配)。</p>
<p>匹配模式 <code>pattern</code> 可以使用 <code>*</code>、<code>?</code>、<code>[]</code> 等通配符。</p>
<div><pre><code>$ <span>myPath</span><span>=</span>/home/cam/book/long.file.name

$ <span>echo</span> <span>${myPath<span>#</span><span>/</span>*<span>/</span>}</span>
cam/book/long.file.name

$ <span>echo</span> <span>${myPath<span>##</span><span>/</span>*<span>/</span>}</span>
long.file.name
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>上面例子中，匹配的模式是 <code>/*/</code>，其中 <code>*</code> 可以匹配任意数量的字符，所以最短匹配是 <code>/home/</code>，最长匹配是 <code>/home/cam/book/</code>。</p>
<p>下面写法可以删除文件路径的目录部分，只留下文件名。</p>
<div><pre><code>$ <span>path</span><span>=</span>/home/cam/book/long.file.name

$ <span>echo</span> <span>${path<span>##</span>*<span>/</span>}</span>
long.file.name
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>上面例子中，模式 <code>*/</code> 匹配目录部分，所以只返回文件名。</p>
<p>下面再看一个例子。</p>
<div><pre><code>$ <span>phone</span><span>=</span><span>"555-456-1414"</span>
$ <span>echo</span> <span>${phone<span>#</span>*-}</span>
<span>456</span>-1414
$ <span>echo</span> <span>${phone<span>##</span>*-}</span>
<span>1414</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>如果匹配不成功，则返回原始字符串。</p>
<div><pre><code>$ <span>phone</span><span>=</span><span>"555-456-1414"</span>
$ <span>echo</span> <span>${phone<span>#</span>444}</span>
<span>555</span>-456-1414
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>上面例子中，原始字符串里面无法匹配模式 <code>444</code>，所以原样返回。</p>
<p>如果要将头部匹配的部分，替换成其他内容，采用下面的写法。</p>
<div><pre><code><span># 模式必须出现在字符串的开头</span>
<span>${variable<span>/</span><span>#</span>pattern<span>/</span>string}</span>

<span># 示例</span>
$ <span>foo</span><span>=</span>JPG.JPG
$ <span>echo</span> <span>${foo<span>/</span><span>#</span>JPG<span>/</span>jpg}</span>
jpg.JPG
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>上面例子中，被替换的 <code>JPG</code> 必须出现在字符串头部，所以返回 <code>jpg.JPG</code>。</p>
<h3 id="字符串尾部的模式匹配"> 字符串尾部的模式匹配</h3>
<p>以下两种语法可以检查字符串结尾，是否匹配给定的模式。如果匹配成功，就删除匹配的部分，返回剩下的部分。原始变量不会发生变化。</p>
<div><pre><code><span># 如果 pattern 匹配变量 variable 的结尾，</span>
<span># 删除最短匹配(非贪婪匹配)的部分，返回剩余部分</span>
<span>${variable<span>%</span>pattern}</span>

<span># 如果 pattern 匹配变量 variable 的结尾，</span>
<span># 删除最长匹配(贪婪匹配)的部分，返回剩余部分</span>
<span>${variable<span>%%</span>pattern}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>上面两种语法会删除变量字符串结尾的匹配部分(将其替换为空)，返回剩下的部分。区别是一个是最短匹配(又称非贪婪匹配)，另一个是最长匹配(又称贪婪匹配)。</p>
<div><pre><code>$ <span>path</span><span>=</span>/home/cam/book/long.file.name

$ <span>echo</span> <span>${path<span>%</span>.*}</span>
/home/cam/book/long.file

$ <span>echo</span> <span>${path<span>%%</span>.*}</span>
/home/cam/book/long
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>上面例子中，匹配模式是 <code>.*</code>，其中 <code>*</code> 可以匹配任意数量的字符，所以最短匹配是 <code>.name</code>，最长匹配是 <code>.file.name</code>。</p>
<p>下面写法可以删除路径的文件名部分，只留下目录部分。</p>
<div><pre><code>$ <span>path</span><span>=</span>/home/cam/book/long.file.name

$ <span>echo</span> <span>${path<span>%</span><span>/</span>*}</span>
/home/cam/book
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>上面例子中，模式 <code>/*</code> 匹配文件名部分，所以只返回目录部分。</p>
<p>下面的写法可以替换文件的后缀名。</p>
<div><pre><code>$ <span>file</span><span>=</span>foo.png
$ <span>echo</span> <span>${file<span>%</span>.png}</span>.jpg
foo.jpg
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>上面的例子将文件的后缀名，从 <code>.png</code> 改成了 <code>.jpg</code>。</p>
<p>下面再看一个例子。</p>
<div><pre><code>$ <span>phone</span><span>=</span><span>"555-456-1414"</span>
$ <span>echo</span> <span>${phone<span>%</span>-*}</span>
<span>555</span>-456
$ <span>echo</span> <span>${phone<span>%%</span>-*}</span>
<span>555</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>如果匹配不成功，则返回原始字符串。</p>
<p>如果要将尾部匹配的部分，替换成其他内容，采用下面的写法。</p>
<div><pre><code><span># 模式必须出现在字符串的结尾</span>
<span>${variable<span>/</span><span>%</span>pattern<span>/</span>string}</span>

<span># 示例</span>
$ <span>foo</span><span>=</span>JPG.JPG
$ <span>echo</span> <span>${foo<span>/</span><span>%</span>JPG<span>/</span>jpg}</span>
JPG.jpg
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>上面例子中，被替换的 <code>JPG</code> 必须出现在字符串尾部，所以返回 <code>JPG.jpg</code>。</p>
<h3 id="任意位置的模式匹配"> 任意位置的模式匹配</h3>
<p>以下两种语法可以检查字符串内部，是否匹配给定的模式。如果匹配成功，就删除匹配的部分，换成其他的字符串返回。原始变量不会发生变化。</p>
<div><pre><code><span># 如果 pattern 匹配变量 variable 的一部分，</span>
<span># 最长匹配(贪婪匹配)的那部分被 string 替换，但仅替换第一个匹配</span>
<span>${variable<span>/</span>pattern<span>/</span>string}</span>

<span># 如果 pattern 匹配变量 variable 的一部分，</span>
<span># 最长匹配(贪婪匹配)的那部分被 string 替换，所有匹配都替换</span>
<span>${variable<span>/</span><span>/</span>pattern<span>/</span>string}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>上面两种语法都是最长匹配(贪婪匹配)下的替换，区别是前一个语法仅仅替换第一个匹配，后一个语法替换所有匹配。</p>
<div><pre><code>$ <span>path</span><span>=</span>/home/cam/foo/foo.name

$ <span>echo</span> <span>${path<span>/</span>foo<span>/</span>bar}</span>
/home/cam/bar/foo.name

$ <span>echo</span> <span>${path<span>/</span><span>/</span>foo<span>/</span>bar}</span>
/home/cam/bar/bar.name
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>上面例子中，前一个命令只替换了第一个 <code>foo</code>，后一个命令将两个 <code>foo</code> 都替换了。</p>
<p>下面的例子将分隔符从 <code>:</code> 换成换行符。</p>
<div><pre><code>$ <span>echo</span> -e <span>${<span>PATH</span><span>/</span><span>/</span><span>:</span><span>/</span>'\n'}</span>
/usr/local/bin
/usr/bin
/bin
<span>..</span>.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>上面例子中，<code>echo</code> 命令的 <code>-e</code> 参数，表示将替换后的字符串的 <code>\n</code> 字符，解释为换行符。</p>
<p>模式部分可以使用通配符。</p>
<div><pre><code>$ <span>phone</span><span>=</span><span>"555-456-1414"</span>
$ <span>echo</span> <span>${phone<span>/</span>5?4<span>/</span>-}</span>
<span>55</span>-56-1414
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>上面的例子将 <code>5-4</code> 替换成 <code>-</code>。</p>
<p>如果省略了 <code>string</code> 部分，那么就相当于匹配的部分替换成空字符串，即删除匹配的部分。</p>
<div><pre><code>$ <span>path</span><span>=</span>/home/cam/foo/foo.name

$ <span>echo</span> <span>${path<span>/</span>.*<span>/</span>}</span>
/home/cam/foo/foo
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>上面例子中，第二个斜杠后面的 <code>string</code> 部分省略了，所以模式 <code>.*</code> 匹配的部分 <code>.name</code> 被删除后返回。</p>
<p>前面提到过，这个语法还有两种扩展形式。</p>
<div><pre><code><span># 模式必须出现在字符串的开头</span>
<span>${variable<span>/</span><span>#</span>pattern<span>/</span>string}</span>

<span># 模式必须出现在字符串的结尾</span>
<span>${variable<span>/</span><span>%</span>pattern<span>/</span>string}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h2 id="改变大小写"> 改变大小写</h2>
<p>下面的语法可以改变变量的大小写。</p>
<div><pre><code><span># 转为大写</span>
<span>${varname<span>^^</span>}</span>

<span># 转为小写</span>
<span>${varname<span>,,</span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>下面是一个例子。</p>
<div><pre><code>$ <span>foo</span><span>=</span>heLLo
$ <span>echo</span> <span>${foo<span>^^</span>}</span>
HELLO
$ <span>echo</span> <span>${foo<span>,,</span>}</span>
hello
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div>]]></content>
    <author>
      <name>阮一峰</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>阮一峰</name>
    </contributor>
    <rights>本教程采用&lt;a href="https://creativecommons.org/licenses/by-sa/3.0/deed.zh"&gt;知识共享 署名-相同方式共享 3.0协议&lt;/a&gt;</rights>
  </entry>
  <entry>
    <title type="html">Bash 变量</title>
    <id>http://qiqi.dreamagain.top/software/linux/bash/variable/</id>
    <link href="http://qiqi.dreamagain.top/software/linux/bash/variable/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <summary type="html"><![CDATA[<p>Bash 变量分成环境变量和自定义变量两类。</p>
]]></summary>
    <content type="html"><![CDATA[<p>Bash 变量分成环境变量和自定义变量两类。</p>

<h2 id="简介"> 简介</h2>
<p>环境变量是 Bash 环境自带的变量，进入 Shell 时已经定义好了，可以直接使用。它们通常是系统定义好的，也可以由用户从父 Shell 传入子 Shell。</p>
<p><code>env</code> 命令或 <code>printenv</code> 命令，可以显示所有环境变量。</p>
<div><pre><code>$ <span>env</span>
<span># 或者</span>
$ <span>printenv</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>下面是一些常见的环境变量。</p>
<ul>
<li><code>BASHPID</code>: Bash 进程的进程 ID。</li>
<li><code>BASHOPTS</code>: 当前 Shell 的参数，可以用 <code>shopt</code> 命令修改。</li>
<li><code>DISPLAY</code>: 图形环境的显示器名字，通常是 <code>:0</code>，表示 X Server 的第一个显示器。</li>
<li><code>EDITOR</code>: 默认的文本编辑器。</li>
<li><code>HOME</code>: 用户的主目录。</li>
<li><code>HOST</code>: 当前主机的名称。</li>
<li><code>IFS</code>: 词与词之间的分隔符，默认为空格。</li>
<li><code>LANG</code>: 字符集以及语言编码，比如 <code>zh_CN.UTF-8</code>。</li>
<li><code>PATH</code>: 由冒号分开的目录列表，当输入可执行程序名后，会搜索这个目录列表。</li>
<li><code>PS1</code>: Shell 提示符。</li>
<li><code>PS2</code>: 输入多行命令时，次要的 Shell 提示符。</li>
<li><code>PWD</code>: 当前工作目录。</li>
<li><code>RANDOM</code>: 返回一个 0 到 32767 之间的随机数。</li>
<li><code>SHELL</code>: Shell 的名字。</li>
<li><code>SHELLOPTS</code>: 启动当前 Shell 的 <code>set</code> 命令的参数，参见《set 命令》一章。</li>
<li><code>TERM</code>: 终端类型名，即终端仿真器所用的协议。</li>
<li><code>UID</code>: 当前用户的 ID 编号。</li>
<li><code>USER</code>: 当前用户的用户名。</li>
</ul>
<p>很多环境变量很少发生变化，而且是只读的，可以视为常量。由于它们的变量名全部都是大写，所以传统上，如果用户要自己定义一个常量，也会使用全部大写的变量名。</p>
<p>注意，Bash 变量名区分大小写，<code>HOME</code> 和 <code>home</code> 是两个不同的变量。</p>
<p>查看单个环境变量的值，可以使用 <code>printenv</code> 命令或 <code>echo</code> 命令。</p>
<div><pre><code>$ <span>printenv</span> <span>PATH</span>
<span># 或者</span>
$ <span>echo</span> <span>$PATH</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>注意，<code>printenv</code> 命令后面的变量名，不用加前缀 <code>$</code>。</p>
<p>自定义变量是用户在当前 Shell 里面自己定义的变量，必须先定义后使用，而且仅在当前 Shell 可用。一旦退出当前 Shell，该变量就不存在了。</p>
<p><code>set</code> 命令可以显示所有变量(包括环境变量和自定义变量)，以及所有的 Bash 函数。</p>
<div><pre><code><span>set</span>
</code></pre>
<div><span>1</span><br></div></div><h2 id="创建变量"> 创建变量</h2>
<p>用户创建变量的时候，变量名必须遵守下面的规则。</p>
<ul>
<li>字母、数字和下划线字符组成。</li>
<li>第一个字符必须是一个字母或一个下划线，不能是数字。</li>
<li>不允许出现空格和标点符号。</li>
</ul>
<p>变量声明的语法如下。</p>
<div><pre><code><span>variable</span><span>=</span>value
</code></pre>
<div><span>1</span><br></div></div><p>上面命令中，等号左边是变量名，右边是变量。注意，等号两边不能有空格。</p>
<p>如果变量的值包含空格，则必须将值放在引号中。</p>
<div><pre><code><span>myvar</span><span>=</span><span>"hello world"</span>
</code></pre>
<div><span>1</span><br></div></div><p>Bash 没有数据类型的概念，所有的变量值都是字符串。</p>
<p>下面是一些自定义变量的例子。</p>
<div><pre><code><span>a</span><span>=</span>z                     <span># 变量 a 赋值为字符串 z</span>
<span>b</span><span>=</span><span>"a string"</span>            <span># 变量值包含空格，就必须放在引号里面</span>
<span>c</span><span>=</span><span>"a string and <span>$b</span>"</span>     <span># 变量值可以引用其他变量的值</span>
<span>d</span><span>=</span><span>"<span title="\t">\t</span><span title="\t">\t</span>a string<span title="\n">\n</span>"</span>      <span># 变量值可以使用转义字符</span>
<span>e</span><span>=</span><span><span>$(</span><span>ls</span> -l foo.txt<span>)</span></span>      <span># 变量值可以是命令的执行结果</span>
<span>f</span><span>=</span><span><span>$((</span><span>5</span> <span>*</span> <span>7</span><span>))</span></span>            <span># 变量值可以是数学运算的结果</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>变量可以重复赋值，后面的赋值会覆盖前面的赋值。</p>
<div><pre><code>$ <span>foo</span><span>=</span><span>1</span>
$ <span>foo</span><span>=</span><span>2</span>
$ <span>echo</span> <span>$foo</span>
<span>2</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>上面例子中，变量 <code>foo</code> 的第二次赋值会覆盖第一次赋值。</p>
<h2 id="读取变量"> 读取变量</h2>
<p>读取变量的时候，直接在变量名前加上 <code>$</code> 就可以了。</p>
<div><pre><code>$ <span>foo</span><span>=</span>bar
$ <span>echo</span> <span>$foo</span>
bar
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>每当 Shell 看到以 <code>$</code> 开头的单词时，就会尝试读取这个变量名对应的值。</p>
<p>如果变量不存在，Bash 不会报错，而会输出空字符。</p>
<p>由于 <code>$</code> 在 Bash 中有特殊含义，把它当作美元符号使用时，一定要非常小心，</p>
<div><pre><code>$ <span>echo</span> The total is <span>$100</span>.00
The total is 00.00
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>上面命令的原意是输入 <code>$100</code>，但是 Bash 将 <code>$1</code> 解释成了变量，该变量为空，因此输入就变成了 <code>00.00</code>。所以，如果要使用 <code>$</code> 的原义，需要在 <code>$</code> 前面放上反斜杠，进行转义。</p>
<div><pre><code>$ <span>echo</span> The total is <span>\</span><span>$100</span>.00
The total is <span>$100</span>.00
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>读取变量的时候，变量名也可以使用花括号 <code>{}</code> 包围，比如 <code>$a</code> 也可以写成 <code>${a}</code>。这种写法可以用于变量名与其他字符连用的情况。</p>
<div><pre><code>$ <span>a</span><span>=</span>foo
$ <span>echo</span> <span>$a_file</span>

$ <span>echo</span> <span>${a}</span>_file
foo_file
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>上面代码中，变量名 <code>a_file</code> 不会有任何输出，因为 Bash 将其整个解释为变量，而这个变量是不存在的。只有用花括号区分 <code>$a</code>，Bash 才能正确解读。</p>
<p>事实上，读取变量的语法 <code>$foo</code>，可以看作是 <code>${foo}</code> 的简写形式。</p>
<p>如果变量的值本身也是变量，可以使用 <code>${!varname}</code> 的语法，读取最终的值。</p>
<div><pre><code>$ <span>myvar</span><span>=</span><span>USER</span>
$ <span>echo</span> <span>${<span>!</span>myvar}</span>
ruanyf
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>上面的例子中，变量 <code>myvar</code> 的值是 <code>USER</code>，<code>${!myvar}</code> 的写法将其展开成最终的值。</p>
<h2 id="删除变量"> 删除变量</h2>
<p><code>unset</code> 命令用来删除一个变量。</p>
<div><pre><code><span>unset</span> NAME
</code></pre>
<div><span>1</span><br></div></div><p>这个命令不是很有用。因为不存在的 Bash 变量一律等于空字符串，所以即使 <code>unset</code> 命令删除了变量，还是可以读取这个变量，值为空字符串。</p>
<p>所以，删除一个变量，也可以将这个变量设成空字符串。</p>
<div><pre><code><span>foo</span><span>=</span><span>''</span>
<span>foo</span><span>=</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>上面两种写法，都是删除了变量 <code>foo</code>。由于不存在的值默认为空字符串，所以后一种写法可以在等号右边不写任何值。</p>
<h2 id="输出变量-export-命令"> 输出变量，export 命令</h2>
<p>用户创建的变量仅可用于当前 Shell，子 Shell 默认读取不到父 Shell 定义的变量。为了把变量传递给子 Shell，需要使用 <code>export</code> 命令。这样输出的变量，对于子 Shell 来说就是环境变量。</p>
<p><code>export</code> 命令用来向子 Shell 输出变量。</p>
<div><pre><code><span>NAME</span><span>=</span>foo
<span>export</span> NAME
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>上面命令输出了变量 <code>NAME</code>。变量的赋值和输出也可以在一个步骤中完成。</p>
<div><pre><code><span>export</span> <span>NAME</span><span>=</span>value
</code></pre>
<div><span>1</span><br></div></div><p>上面命令执行后，当前 Shell 及随后新建的子 Shell，都可以读取变量 <code>$NAME</code>。</p>
<p>子 Shell 如果修改继承的变量，不会影响父 Shell。</p>
<div><pre><code><span># 输出变量 $foo</span>
$ <span>export</span> <span>foo</span><span>=</span>bar

<span># 新建子 Shell</span>
$ <span>bash</span>

<span># 读取 $foo</span>
$ <span>echo</span> <span>$foo</span>
bar

<span># 修改继承的变量</span>
$ <span>foo</span><span>=</span>baz

<span># 退出子 Shell</span>
$ <span>exit</span>

<span># 读取 $foo</span>
$ <span>echo</span> <span>$foo</span>
bar
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><p>上面例子中，子 Shell 修改了继承的变量 <code>$foo</code>，对父 Shell 没有影响。</p>
<h2 id="特殊变量"> 特殊变量</h2>
<p>Bash 提供一些特殊变量。这些变量的值由 Shell 提供，用户不能进行赋值。</p>
<p>(1) <code>$?</code></p>
<p><code>$?</code> 为上一个命令的退出码，用来判断上一个命令是否执行成功。返回值是 <code>0</code>，表示上一个命令执行成功；如果是非零，上一个命令执行失败。</p>
<div><pre><code>$ <span>ls</span> doesnotexist
ls: doesnotexist: No such <span>file</span> or directory

$ <span>echo</span> <span>$?</span>
<span>1</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>上面例子中，<code>ls</code> 命令查看一个不存在的文件，导致报错。<code>$?</code> 为 1，表示上一个命令执行失败。</p>
<p>(2) <code>$$</code></p>
<p><code>$$</code> 为当前 Shell 的进程 ID。</p>
<div><pre><code>$ <span>echo</span> <span>$$</span>
<span>10662</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>这个特殊变量可以用来命名临时文件。</p>
<div><pre><code><span>LOGFILE</span><span>=</span>/tmp/output_log.<span>$$</span>
</code></pre>
<div><span>1</span><br></div></div><p>(3) <code>$_</code></p>
<p><code>$_</code> 为上一个命令的最后一个参数。</p>
<div><pre><code>$ <span>grep</span> dictionary /usr/share/dict/words
dictionary

$ <span>echo</span> <span>$_</span>
/usr/share/dict/words
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>(4) <code>$!</code></p>
<p><code>$!</code> 为最近一个后台执行的异步命令的进程 ID。</p>
<div><pre><code>$ firefox <span>&amp;</span>
<span>[</span><span>1</span><span>]</span> <span>11064</span>

$ <span>echo</span> <span>$!</span>
<span>11064</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>上面例子中，<code>firefox</code> 是后台运行的命令，<code>$!</code> 返回该命令的进程 ID。</p>
<p>(5) <code>$0</code></p>
<p><code>$0</code> 为当前 Shell 的名称(在命令行直接执行时)或者脚本名(在脚本中执行时)。</p>
<div><pre><code>$ <span>echo</span> <span>$0</span>
<span>bash</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>上面例子中，<code>$0</code> 返回当前运行的是 Bash。</p>
<p>(6) <code>$-</code></p>
<p><code>$-</code> 为当前 Shell 的启动参数。</p>
<div><pre><code>$ <span>echo</span> $-
himBHs
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>(7) <code>$@</code> 和 <code>$#</code></p>
<p><code>$@</code> 和 <code>$#</code> 表示脚本的参数数量，参见脚本一章。</p>
<h2 id="变量的默认值"> 变量的默认值</h2>
<p>Bash 提供四个特殊语法，跟变量的默认值有关，目的是保证变量不为空。</p>
<div><pre><code><span>${varname<span>:-</span>word}</span>
</code></pre>
<div><span>1</span><br></div></div><p>上面语法的含义是，如果变量 <code>varname</code> 存在且不为空，则返回它的值，否则返回 <code>word</code>。它的目的是返回一个默认值，比如 <code>${count:-0}</code> 表示变量 <code>count</code> 不存在时返回 <code>0</code>。</p>
<div><pre><code><span>${varname<span>:=</span>word}</span>
</code></pre>
<div><span>1</span><br></div></div><p>上面语法的含义是，如果变量 <code>varname</code> 存在且不为空，则返回它的值，否则将它设为 <code>word</code>，并且返回 <code>word</code>。它的目的是设置变量的默认值，比如 <code>${count:=0}</code> 表示变量 <code>count</code> 不存在时返回 <code>0</code>，且将 <code>count</code> 设为 <code>0</code>。</p>
<div><pre><code><span>${varname<span>:+</span>word}</span>
</code></pre>
<div><span>1</span><br></div></div><p>上面语法的含义是，如果变量名存在且不为空，则返回 <code>word</code>，否则返回空值。它的目的是测试变量是否存在，比如 <code>${count:+1}</code> 表示变量 <code>count</code> 存在时返回 <code>1</code>(表示 <code>true</code>)，否则返回空值。</p>
<div><pre><code><span>${varname<span>:?</span>message}</span>
</code></pre>
<div><span>1</span><br></div></div><p>上面语法的含义是，如果变量 <code>varname</code> 存在且不为空，则返回它的值，否则打印出 <code>varname: message</code>，并中断脚本的执行。如果省略了 <code>message</code>，则输出默认的信息“parameter null or not set.”。它的目的是防止变量未定义，比如 <code>${count:?&quot;undefined!&quot;}</code> 表示变量 <code>count</code> 未定义时就中断执行，抛出错误，返回给定的报错信息 <code>undefined!</code>。</p>
<p>上面四种语法如果用在脚本中，变量名的部分可以用到数字 <code>1</code> 到 <code>9</code>，表示脚本的参数。</p>
<div><pre><code><span>filename</span><span>=</span><span>${1<span>:?</span>"filename missing."}</span>
</code></pre>
<div><span>1</span><br></div></div><p>上面代码出现在脚本中，<code>1</code> 表示脚本的第一个参数。如果该参数不存在，就退出脚本并报错。</p>
<h2 id="declare-命令"> declare 命令</h2>
<p><code>declare</code> 命令可以声明一些特殊类型的变量，为变量设置一些限制，比如声明只读类型的变量和整数类型的变量。</p>
<p>它的语法形式如下。</p>
<div><pre><code><span>declare</span> OPTION <span>VARIABLE</span><span>=</span>value
</code></pre>
<div><span>1</span><br></div></div><p><code>declare</code> 命令的主要参数(OPTION)如下。</p>
<ul>
<li><code>-a</code>: 声明数组变量。</li>
<li><code>-f</code>: 输出所有函数定义。</li>
<li><code>-F</code>: 输出所有函数名。</li>
<li><code>-i</code>: 声明整数变量。</li>
<li><code>-l</code>: 声明变量为小写字母。</li>
<li><code>-p</code>: 查看变量信息。</li>
<li><code>-r</code>: 声明只读变量。</li>
<li><code>-u</code>: 声明变量为大写字母。</li>
<li><code>-x</code>: 该变量输出为环境变量。</li>
</ul>
<p><code>declare</code> 命令如果用在函数中，声明的变量只在函数内部有效，等同于 <code>local</code> 命令。</p>
<p>不带任何参数时，<code>declare</code> 命令输出当前环境的所有变量，包括函数在内，等同于不带有任何参数的 <code>set</code> 命令。</p>
<div><pre><code><span>declare</span>
</code></pre>
<div><span>1</span><br></div></div><p><strong>(1) <code>-i</code> 参数</strong></p>
<p><code>-i</code> 参数声明整数变量以后，可以直接进行数学运算。</p>
<div><pre><code>$ <span>declare</span> -i <span>val1</span><span>=</span><span>12</span> <span>val2</span><span>=</span><span>5</span>
$ <span>declare</span> -i result
$ <span>result</span><span>=</span>val1*val2
$ <span>echo</span> <span>$result</span>
<span>60</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>上面例子中，如果变量 <code>result</code> 不声明为整数，<code>val1*val2</code> 会被当作字面量，不会进行整数运算。另外，<code>val1</code> 和 <code>val2</code> 其实不需要声明为整数，因为只要 <code>result</code> 声明为整数，它的赋值就会自动解释为整数运算。</p>
<p>注意，一个变量声明为整数以后，依然可以被改写为字符串。</p>
<div><pre><code>$ <span>declare</span> -i <span>var</span><span>=</span><span>12</span>
$ <span>var</span><span>=</span>foo
$ <span>echo</span> <span>$var</span>
<span>0</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>上面例子中，变量 <code>var</code> 声明为整数，覆盖以后，Bash 不会报错，但会赋以不确定的值，上面的例子中可能输出 0，也可能输出的是 3。</p>
<p><strong>(2) <code>-x</code> 参数</strong></p>
<p><code>-x</code> 参数等同于 <code>export</code> 命令，可以输出一个变量为子 Shell 的环境变量。</p>
<div><pre><code>$ <span>declare</span> -x foo
<span># 等同于</span>
$ <span>export</span> foo
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><strong>(3) <code>-r</code> 参数</strong></p>
<p><code>-r</code> 参数可以声明只读变量，无法改变变量值，也不能 <code>unset</code> 变量。</p>
<div><pre><code>$ <span>declare</span> -r <span>bar</span><span>=</span><span>1</span>

$ <span>bar</span><span>=</span><span>2</span>
bash: bar: 只读变量
$ <span>echo</span> <span>$?</span>
<span>1</span>

$ <span>unset</span> bar
bash: bar: 只读变量
$ <span>echo</span> <span>$?</span>
<span>1</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>上面例子中，后两个赋值语句都会报错，命令执行失败。</p>
<p><strong>(4) <code>-u</code> 参数</strong></p>
<p><code>-u</code> 参数声明变量为大写字母，可以自动把变量值转成大写字母。</p>
<div><pre><code>$ <span>declare</span> -u foo
$ <span>foo</span><span>=</span>upper
$ <span>echo</span> <span>$foo</span>
UPPER
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p><strong>(5) <code>-l</code> 参数</strong></p>
<p><code>-l</code> 参数声明变量为小写字母，可以自动把变量值转成小写字母。</p>
<div><pre><code>$ <span>declare</span> -l bar
$ <span>bar</span><span>=</span>LOWER
$ <span>echo</span> <span>$bar</span>
lower
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p><strong>(6) <code>-p</code> 参数</strong></p>
<p><code>-p</code> 参数输出变量信息。</p>
<div><pre><code>$ <span>foo</span><span>=</span>hello
$ <span>declare</span> -p foo
<span>declare</span> -- <span>foo</span><span>=</span><span>"hello"</span>
$ <span>declare</span> -p bar
bar: 未找到
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>上面例子中，<code>declare -p</code> 可以输出已定义变量的值，对于未定义的变量，会提示找不到。</p>
<p>如果不提供变量名，<code>declare -p</code> 输出所有变量的信息。</p>
<div><pre><code><span>declare</span> -p
</code></pre>
<div><span>1</span><br></div></div><p><strong>(7) <code>-f</code> 参数</strong></p>
<p><code>-f</code> 参数输出当前环境的所有函数，包括它的定义。</p>
<div><pre><code><span>declare</span> -f
</code></pre>
<div><span>1</span><br></div></div><p><strong>(8) <code>-F</code> 参数</strong></p>
<p><code>-F</code> 参数输出当前环境的所有函数名，不包含函数定义。</p>
<div><pre><code><span>declare</span> -F
</code></pre>
<div><span>1</span><br></div></div><h2 id="readonly-命令"> readonly 命令</h2>
<p><code>readonly</code> 命令等同于 <code>declare -r</code>，用来声明只读变量，不能改变变量值，也不能 <code>unset</code> 变量。</p>
<div><pre><code>$ <span>readonly</span> <span>foo</span><span>=</span><span>1</span>
$ <span>foo</span><span>=</span><span>2</span>
bash: foo: 只读变量
$ <span>echo</span> <span>$?</span>
<span>1</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>上面例子中，更改只读变量 <code>foo</code> 会报错，命令执行失败。</p>
<p><code>readonly</code> 命令有三个参数。</p>
<ul>
<li><code>-f</code>: 声明的变量为函数名。</li>
<li><code>-p</code>: 打印出所有的只读变量。</li>
<li><code>-a</code>: 声明的变量为数组。</li>
</ul>
<h2 id="let-命令"> let 命令</h2>
<p><code>let</code> 命令声明变量时，可以直接执行算术表达式。</p>
<div><pre><code>$ <span>let</span> <span>foo</span><span>=</span><span>1</span>+2
$ <span>echo</span> <span>$foo</span>
<span>3</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>上面例子中，<code>let</code> 命令可以直接计算 <code>1 + 2</code>。</p>
<p><code>let</code> 命令的参数表达式如果包含空格，就需要使用引号。</p>
<div><pre><code><span>let</span> <span>"foo = 1 + 2"</span>
</code></pre>
<div><span>1</span><br></div></div><p><code>let</code> 可以同时对多个变量赋值，赋值表达式之间使用空格分隔。</p>
<div><pre><code>$ <span>let</span> <span>"v1 = 1"</span> <span>"v2 = v1++"</span>
$ <span>echo</span> <span>$v1</span>,<span>$v2</span>
<span>2,1</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>上面例子中，<code>let</code> 声明了两个变量 <code>v1</code> 和 <code>v2</code>，其中 <code>v2</code> 等于 <code>v1++</code>，表示先返回 <code>v1</code> 的值，然后 <code>v1</code> 自增。</p>
<p>这种语法支持的运算符，参考《Bash 的算术运算》一章。</p>
]]></content>
    <author>
      <name>阮一峰</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>阮一峰</name>
    </contributor>
    <rights>本教程采用&lt;a href="https://creativecommons.org/licenses/by-sa/3.0/deed.zh"&gt;知识共享 署名-相同方式共享 3.0协议&lt;/a&gt;</rights>
  </entry>
  <entry>
    <title type="html">CentOS 教程</title>
    <id>http://qiqi.dreamagain.top/software/linux/centos/</id>
    <link href="http://qiqi.dreamagain.top/software/linux/centos/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<h2 id="管理工具"> 管理工具</h2>
<ul>
<li>yum (Centos 7)</li>
<li>dnf (Centos 8)</li>
</ul>
<h2 id="yarn"> yarn</h2>
<div><pre><code><span>curl</span> --silent --location https://dl.yarnpkg.com/rpm/yarn.repo <span>|</span> <span>sudo</span> <span>tee</span> /etc/yum.repos.d/yarn.repo

<span>sudo</span> yum <span>install</span> <span>yarn</span>
<span>## OR ##</span>
<span>sudo</span> dnf <span>install</span> <span>yarn</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>测试是否安装成功:</p>
<div><pre><code><span>yarn</span> --version
</code></pre>
<div><span>1</span><br></div></div>]]></content>
    <author>
      <name>南辞</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>南辞</name>
    </contributor>
    <published>2019-11-23T00:00:00.000Z</published>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">命令补全</title>
    <id>http://qiqi.dreamagain.top/software/linux/command/add/</id>
    <link href="http://qiqi.dreamagain.top/software/linux/command/add/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <summary type="html"><![CDATA[<p>文件名(或者目录名)是执行 Linux 命令中最常见的参数，例如前面介绍的 <code>cd</code>、<code>mkdir</code>、<code>cp</code> 等命令，都涉及到了文件名。然而对初学者来说，输入完整的文件名感觉很麻烦，尤其面临文件名(目录名)特别长的时候。</p>
<p>考虑到这种情况，Shell (Bash) 提供了一种称为“命令行自动补全”的功能，即在输入文件名的时候，只需要输入该文件名的前几个字符，然后按 Tab 键，Shell 就可以自动将文件名补全。</p>
]]></summary>
    <content type="html"><![CDATA[<p>文件名(或者目录名)是执行 Linux 命令中最常见的参数，例如前面介绍的 <code>cd</code>、<code>mkdir</code>、<code>cp</code> 等命令，都涉及到了文件名。然而对初学者来说，输入完整的文件名感觉很麻烦，尤其面临文件名(目录名)特别长的时候。</p>
<p>考虑到这种情况，Shell (Bash) 提供了一种称为“命令行自动补全”的功能，即在输入文件名的时候，只需要输入该文件名的前几个字符，然后按 Tab 键，Shell 就可以自动将文件名补全。</p>

<p>举个例子，在 <code>/etc</code> 目录下，执行如下命令:</p>
<div><pre><code><span>[root@localhost ~]# cd /etc
[root@localhost etc]# cd fs &lt;-- 按一次 Tab 键
</span></code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>当按下 Tab 键时，您会发现 Shell 自动将 &quot;fs&quot; 补全成了 &quot;fatab&quot;，这是因为当前 <code>/etc</code> 目录中只有 fstab 是以 &quot;fs&quot; 开头，因此 Shell 可以确定这里想要输入的文件名称为 fstab。</p>
<p>那么，如果当前目录中含有多个以指定字符(或字符串)开头的目录或文件，Shell 还可以成功辨认吗? 答案是否定的，但它会以列表的形式给出所有以指定字符或字符串开头的文件或目录，供用户选择。</p>
<p>例如，还是在 <code>/etc</code> 目录下，执行如下命令:</p>
<div><pre><code><span>[root@localhost etc]# cd b &lt;-- 连续按两次 Tab 键
bash_completion.d/      blkid/          bonobo-activation/
bashrc                  bluetooth
</span></code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>可以看到，当按一次 Tab 键时，Shell 没有任何反映，原因就是当前目录下以 &quot;b&quot; 为开头的文件或目录有多个(2 个以上)，仅凭一个字符 &quot;b&quot; 无法精准判断出具体指的是哪个文件。而当再一次按下 Tab 键时，Shell 会列表的形式显示给用户当前目录下所有以 &quot;b&quot; 开头的文件或目录。</p>
<p>事实上，Shell 提供的命令行补全功能不仅适用于补全文件名，也同样适用于所有 Linux 命令。举个例子，当输入 <code>ca</code> 并连续按下 2 次 Tab 键时，Shell 会罗列出所有以 &quot;ca&quot; 开头的 Linux 命令，如下所示:</p>
<div><pre><code><span>[root@localhost etc]# ca &lt;--连续按两次 Tab 键
cacertdir_rehash    cache_restore       capsh       catchsegv
cache_check         cal                 captoinfo
cache_dump          caller              case
cache_repair        canberra-gtk-play   cat
</span></code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>另外，Shell 还有一套被称作通配符的转用符号，这些通配符可以搜索并匹配文件名的一部分，从而大大简化了文件名的输入。</p>
<ul>
<li><code>*</code>: 匹配任意数量的字符。</li>
<li><code>?</code>: 匹配任意一个字符。</li>
<li><code>[]</code>: 匹配括号内的任意一个字符，甚至 <code>[]</code> 中还可以包含用 <code>-</code>(短横线)连接的字符或数字，表示一定范围内的字符或数字。</li>
</ul>
<p>为了学习这些通配符的用法，首先需要建立一个空目录(如 test)，并在该目录中创建一些文件(供测试用)，执行命令如下:</p>
<div><pre><code><span>[root@localhost etc]# makdir test
[root@localhost etc]# cd test
[root@localhost test]# touch apple banana grape grapefruit watermelon
[root@localhost test]# ls
apple banana grape grapefruit watermelon
</span></code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>在此基础上，继续执行如下命令:</p>
<div><pre><code><span>[root@localhost test]# ls a* &lt;--匹配所有以 a 字符开头的文件名
apple
[root@localhost test]# ls g*t &lt;--匹配所有以 g 字符开头，以 t 字符结尾的文件名
grapefruit
[root@localhost test]# ls *e* &lt;--匹配所有包含 e 字符的文件名
apple grape grapefruit watermelon
[root@localhost test]# ls *n* &lt;--匹配所有包含 n 字符的文件名
banana watermelon
</span></code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>结合以上实例，因为 <code>*</code> 可以匹配任何数量的字符，因此可以一一实现实例中标注的功能。</p>
<p>接下来，列举一下使用 ? 匹配文件名的示例:</p>
<div><pre><code><span>[root@localhost test]# ls ????e
apple grape
[root@localhost test]# ls g???e*
grape grapefruit
</span></code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>因为 1 个 ? 只能匹配 1 个任意字符，因此该示例中第一个例子表示的是匹配任意包含 5 个字符但以 e 结尾的文件(apple 和 grape)，第二例子表示匹配任何以 g 开头且第 5 个字符为 e 的文件(grape 和 grapefruit)。</p>
<p>最后，列举一些使用括号 <code>[]</code> 匹配文件名的示例:</p>
<div><pre><code><span>[root@localhost test]# ls [abw]*
apple banana watermelon
[root@localhost test]# ls [agw]*[ne]
apple grape watermelon
</span></code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>此示例中，第一个例子表示匹配任何以 a、b 或 w 开头的文件；第二个例子中表示匹配任何以 a、g、w 开头，以 n 或 e 结尾的文件名。</p>
<p>不仅如此，<code>[]</code> 中还可以通过 -(短横线)表示一定范围内的任意字符(或数字)，例如:</p>
<div><pre><code><span>[root@localhost test]# ls [a-g]*
apple banana grape grapefruit
</span></code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>其中，<code>[a-g]*</code> 表示匹配以字母 a 到 g 之间任何一个字母开头的文件名。</p>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>南辞</name>
    </contributor>
    <published>2019-11-20T00:00:00.000Z</published>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">基本格式</title>
    <id>http://qiqi.dreamagain.top/software/linux/command/command/</id>
    <link href="http://qiqi.dreamagain.top/software/linux/command/command/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<h2 id="命令提示符"> 命令提示符</h2>
<p>登录系统后，第一眼看到的内容是:</p>
<div><pre><code><span>[root@localhost ~]#
</span></code></pre>
<div><span>1</span><br></div></div><p>这就是 Linux 系统的命令提示符。那么，这个提示符的含义是什么呢?</p>
<ul>
<li><code>[]</code>: 这是提示符的分隔符号，没有特殊含义。</li>
<li><code>root</code>: 显示的是当前的登录用户，笔者现在使用的是 root 用户登录。</li>
<li><code>@</code>: 分隔符号，没有特殊含义。</li>
<li><code>localhost</code>: 当前系统的简写主机名(完整主机名是 <code>localhost.localdomain</code>)。</li>
<li><code>~</code>: 代表用户当前所在的目录，此例中用户当前所在的目录是家目录。</li>
<li><code>#</code>: 命令提示符，Linux 用这个符号标识登录的用户权限等级。如果是超级用户，提示符就是 <code>#</code>；如果是普通用户，提示符就是 <code>$</code>。</li>
</ul>
<p>家目录(又称主目录)是什么? Linux 系统是纯字符界面，用户登录后，要有一个初始登录的位置，这个初始登录位置就称为用户的家:
超级用户的家目录: <code>/root</code>。
普通用户的家目录: <code>/home/用户名</code>。</p>
<p>用户在自己的家目录中拥有完整权限，所以我们也建议操作实验可以放在家目录中进行。我们切换一下用户所在目录，看看有什么效果。</p>
<div><pre><code><span>[root@localhost ~]# cd /usr/local
[root@localhost local]#
</span></code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>仔细看，如果切换用户所在目录，那么命令提示符中的会变成用户当前所在目录的最后一个目录(不显示完整的所在目录 <code>/usr/loca</code>l，只显示最后一个目录 <code>local</code>)。</p>
<h2 id="命令的基本格式"> 命令的基本格式</h2>
<p>接下来看看 Linux 命令的基本格式:</p>
<div><pre><code><span>[root@localhost ~]# 命令[选项][参数]
</span></code></pre>
<div><span>1</span><br></div></div><p>命令格式中的 <code>[]</code> 代表可选项，也就是有些命令可以不写选项或参数，也能执行。那么，我们就用 Linux 中最常见的 <code>ls</code> 命令来解释一下命令的格式(有关 <code>ls</code> 命令的具体用法，后续章节会详细介绍)。如果按照命令的分类，那么 <code>ls</code> 命令应该属于目录操作命令。</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># ls</span>
anaconda-ks.cfg install.log install.log.syslog
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><ol>
<li>
<p>选项的作用</p>
<p>选项的作用是调整命令功能。如果没有选项，那么命令只能执行最基本的功能；而一旦有选项，则可以显示更加丰富的数据。</p>
<p>Linux 的选项又分为短格式选项(<code>-l</code>)和长格式选项(-<code>-all</code>)。短格式选项是英文的简写，用一个减号调用，例如:</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># ls -l</span>
</code></pre>
<div><span>1</span><br></div></div><p>而长格式选项是英文完整单词，一般用两个减号调用，例如:</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># ls --all</span>
</code></pre>
<div><span>1</span><br></div></div><p>一般情况下，短格式选项是长格式选项的缩写，也就是一个短格式选项会有对应的长格式选项。当然也有例外，比如 <code>ls</code> 命令的短格式选项 <code>-l</code> 就没有对应的长格式选项。所以具体的命令选项可以通过后面我们要学习的帮助命令来进行査询。</p>
</li>
<li>
<p>参数的作用</p>
<p>参数是命令的操作对象，一般文件、目录、用户和进程等可以作为参数被命令操作。例如:</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># ls -l anaconda-ks.cfg</span>
-rw-------.1 root root <span>1207</span> <span>1</span> 月 <span>14</span> <span>18</span>:18 anaconda-ks.cfg
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>但是为什么一开始 <code>ls</code> 命令可以省略参数? 那是因为有默认参数。命令一般都需要加入参数，用于指定命令操作的对象是谁。如果可以省略参数，则一般都有默认参数。例如:</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># ls</span>
anaconda-ks.cfg install.log install.log.syslog
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>这个 <code>ls</code> 命令后面没有指定参数，默认参数是当前所在位置，所以会显示当前目录下的文件名。</p>
</li>
</ol>
<p>总结一下: <strong>命令的选项用于调整命令功能，而命令的参数是这个命令的操作对象。</strong></p>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>南辞</name>
    </contributor>
    <published>2019-11-18T00:00:00.000Z</published>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">命令执行</title>
    <id>http://qiqi.dreamagain.top/software/linux/command/excu/</id>
    <link href="http://qiqi.dreamagain.top/software/linux/command/excu/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<p>前面讲过，在 Linux 系统中“一切皆文件”，Linux 命令也不例外。那么，当编辑完成 Linux 命令并回车后，系统底层到底发生了什么事情呢?</p>
<p>简单来说，Linux 命令的执行过程分为如下 4 个步骤。</p>
<ol>
<li>
<p>判断路径</p>
<p>判断用户是否以绝对路径或相对路径的方式输入命令(如 <code>/bin/ls</code>)，如果是的话直接执行。</p>
</li>
<li>
<p>检查别名</p>
<p>Linux 系统会检查用户输入的命令是否为 “别名命令”。要知道，通过 alias 命令是可以给现有命令自定义别名的，即用一个自定义的命令名称来替换原本的命令名称。</p>
<p>例如，我们经常使用的 <code>rm</code> 命令，其实就是 <code>rm -i</code> 这个整体的别名:</p>
<div><pre><code><span>[root@localhost ~]# alias rm
alias rm='rm -i'
</span></code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>这使得当使用 rm 命令删除指定文件时，Linux 系统会要求我们再次确认是否执行删除操作。例如:</p>
<div><pre><code><span>[root@localhost ~]# rm a.txt &lt;-- 假定当前目录中已经存在 a.txt 文件
rm: remove regular file 'a.txt'? y  &lt;-- 手动输入 y，即确定删除
[root@localhost ~]#
</span></code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>这里可以使用 <code>unalias</code> 命令，将 Linux 系统设置的 <code>rm</code> 别名删除掉，执行命令如下:</p>
<div><pre><code><span>[root@localhost ~]# alias rm
alias rm='rm -i'
[root@localhost ~]# unalias rm
[root@localhost ~]# rm a.txt
[root@localhost ~]#  &lt;--直接删除，不再询问
</span></code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div></li>
<li>
<p>判断是内部命令还是外部命令</p>
<p>Linux 命令行解释器 (又称为 Shell) 会判断用户输入的命令是内部命令还是外部命令。其中，内部命令指的是解释器内部的命令，会被直接执行；而用户通常输入的命令都是外部命令，这些命令交给步骤四继续处理。
内部命令由 Shell 自带，会随着系统启动，可以直接从内存中读取；而外部命令仅是在系统中有对应的可执行文件，执行时需要读取该文件。</p>
<p>判断一个命令属于内部命令还是外部命令，可以使用 <code>type</code> 命令实现。例如:</p>
<div><pre><code><span>[root@localhost ~]# type pwd
pwd is a shell builtin  &lt;-- pwd是内部命令
[root@localhost ~]# type top
top is /usr/bin/top  &lt;-- top是外部命令
</span></code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div></li>
<li>
<p>查找外部命令对应的可执行文件</p>
<p>当用户执行的是外部命令时，系统会在指定的多个路径中查找该命令的可执行文件，而定义这些路径的变量，就称为 PATH 环境变量，其作用就是告诉 Shell 待执行命令的可执行文件可能存放的位置，也就是说，Shell 会在 PATH 变量包含的多个路径中逐个查找，直到找到为止(如果找不到，Shell 会提供用户“找不到此命令”)。</p>
</li>
</ol>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>南辞</name>
    </contributor>
    <published>2019-11-20T00:00:00.000Z</published>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">文件夹</title>
    <id>http://qiqi.dreamagain.top/software/linux/command/dir/</id>
    <link href="http://qiqi.dreamagain.top/software/linux/command/dir/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<h2 id="pwd-命令"> pwd 命令</h2>
<p>由于 Linux 文件系统中有许多目录，当用户执行一条 Linux 命令又没有指定该命令或参数所在的目录时，Linux 系统就会首先在当前目录(目前的工作目录)搜寻这个命令或它的参数。因此，用户在执行命令之前，常常需要确定目前所在的工作目录，即当前目录。</p>
<p>当用户登陆 Linux 系统之后，其当前目录就是它的主目录。那么，如何确定当前目录呢? 可以使用 Linux 系统的 pwd 命令来显示当前目录的绝对路径。</p>
<p>pwd 命令，是 Print Working Directory (打印工作目录)的缩写，功能是显示用户当前所处的工作目录。该命令的基本格式为:</p>
<div><pre><code><span>[root@localhost ~]# pwd
</span></code></pre>
<div><span>1</span><br></div></div><h2 id="cd-命令"> cd 命令</h2>
<p>cd 命令，是 Change Directory 的缩写，用来切换工作目录。</p>
<p>Linux 命令按照来源方式，可分为两种，分别是 Shell 内置命令和外部命令。所谓 Shell 内置命令，就是 Shell 自带的命令，这些命令是没有执行文件的；而外部命令就是由程序员单独开发的，所以会有命令的执行文件。Linux 中的绝大多数命令是外部命令，而 cd 命令是一个典型的 Shell 内置命令，所以 cd 命令没有执行文件所在路径。</p>
<p>cd 命令的基本格式如下:</p>
<div><pre><code><span>[root@localhost ~]# cd [相对路径或绝对路径]
</span></code></pre>
<div><span>1</span><br></div></div><p>除此之外，cd 命令后面可以跟一些特殊符号，表达固定的含义。</p>
<table>
<thead>
<tr>
<th>特殊符号</th>
<th>作 用</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>~</code></td>
<td>代表当前登录用户的主目录</td>
</tr>
<tr>
<td><code>~&lt;用户名&gt;</code></td>
<td>表示切换至指定用户的主目录</td>
</tr>
<tr>
<td><code>-</code></td>
<td>代表上次所在目录</td>
</tr>
<tr>
<td><code>.</code></td>
<td>代表当前目录</td>
</tr>
<tr>
<td><code>..</code></td>
<td>代表上级目录</td>
</tr>
</tbody>
</table>
<div><p>提示</p>
<p>在 Linux 系统中，根目录确实存在 <code>.</code>(当前目录)以及 <code>..</code>(当前目录的父目录)两个目录，但由于根目录是最顶级目录，因此根目录的 <code>..</code> 和 <code>.</code> 的属性和权限完全一致，也就是说，根目录的父目录是自身。</p>
</div>
<h2 id="ls-命令"> ls 命令</h2>
<p>ls 命令，list 的缩写，是最常见的目录操作命令，其主要功能是显示当前目录下的内容。此命令的基本格式为:</p>
<div><pre><code><span>[root@localhost ~]# ls [选项] 目录名称
</span></code></pre>
<div><span>1</span><br></div></div><table>
<thead>
<tr>
<th>选项</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>-a</td>
<td>显示全部的文件，包括隐藏文件(开头为 <code>.</code> 的文件)也一起罗列出来，这是最常用的选项之一。</td>
</tr>
<tr>
<td>-A</td>
<td>显示全部的文件，连同隐藏文件，但不包括 <code>.</code> 与 <code>..</code> 这两个目录。</td>
</tr>
<tr>
<td>-d</td>
<td>仅列出目录本身，而不是列出目录内的文件数据。</td>
</tr>
<tr>
<td>-f</td>
<td>ls 默认会以文件名排序，使用 <code>-f</code> 选项会直接列出结果，而不进行排序。</td>
</tr>
<tr>
<td>-F</td>
<td>在文件或目录名后加上文件类型的指示符号，例如，<code>*</code> 代表可运行文件，<code>/</code> 代表目录，= 代表 socket 文件，</td>
</tr>
<tr>
<td>-h</td>
<td>以人们易读的方式显示文件或目录大小，如 1KB、234MB、2GB 等。</td>
</tr>
<tr>
<td>-i</td>
<td>显示 inode 节点信息。</td>
</tr>
<tr>
<td>-l</td>
<td>使用长格式列出文件和目录信息。</td>
</tr>
<tr>
<td>-n</td>
<td>以 UID 和 GID 分别代替文件用户名和群组名显示出来。</td>
</tr>
<tr>
<td>-r</td>
<td>将排序结果反向输出，比如，若原本文件名由小到大，反向则为由大到小。</td>
</tr>
<tr>
<td>-R</td>
<td>连同子目录内容一起列出来，等於将该目录下的所有文件都显示出来。</td>
</tr>
<tr>
<td>-S</td>
<td>以文件容量大小排序，而不是以文件名排序。</td>
</tr>
<tr>
<td>-t</td>
<td>以时间排序，而不是以文件名排序。</td>
</tr>
<tr>
<td>--color=never<br />--color=always<br />--color=auto</td>
<td><code>never</code> 表示不依据文件特性给予颜色显示。<br /><code>always</code> 表示显示颜色，ls 默认采用这种方式。<br /><code>auto</code> 表示让系统自行依据配置来判断是否给予颜色。</td>
</tr>
<tr>
<td>--full-time</td>
<td>以完整时间模式 (包含年、月、日、时、分)输出</td>
</tr>
<tr>
<td>--time={atime,ctime}</td>
<td>输出 access 时间或改变权限属性时间(ctime)，而不是内容变更时间。</td>
</tr>
</tbody>
</table>
<div><p>提示</p>
<p>当 ls 命令不使用任何选项时，默认只会显示非隐藏文件的名称，并以文件名进行排序，同时会根据文件的具体类型给文件名配色(蓝色显示目录，白色显示一般文件)。</p>
</div>
<div><p>提示</p>
<p>ls 命令使用了 <code>-l</code> 选项，显示出文件的详细信息，此选项显示的这 7 列的含义分别是:</p>
<ul>
<li>第一列: 规定了不同的用户对文件所拥有的权限，具体权限的含义将在后续章节中讲解。</li>
<li>第二列: 引用计数，文件的引用计数代表该文件的硬链接个数，而目录的引用计数代表该目录有多少个一级子目录。</li>
<li>第三列: 所有者，也就是这个文件属于哪个用户。默认所有者是文件的建立用户。</li>
<li>第四列: 所属组，默认所属组是文件建立用户的有效组，一般情况下就是建立用户的所在组。</li>
<li>第五列: 大小，默认单位是字节。</li>
<li>第六列: 文件修改时间，文件状态修改时间或文件数据修改时间都会更改这个时间，注意这个时间不是文件的创建时间。</li>
<li>第七列: 文件名或目录名。</li>
</ul>
</div>
<h2 id="mkdir-命令"> mkdir 命令</h2>
<p>mkdir 命令，是 make directories 的缩写，用于创建新目录，此命令所有用户都可以使用。</p>
<p>mkdir 命令的基本格式为:</p>
<div><pre><code><span>[root@localhost ~]# mkdir [-mp] 目录名
</span></code></pre>
<div><span>1</span><br></div></div><ul>
<li>-m 选项用于手动配置所创建目录的权限，而不再使用默认权限。</li>
<li>-p 选项递归创建所有目录，以创建 <code>/home/test/demo</code> 为例，在默认情况下，您需要一层一层的创建各个目录，而使用 <code>-p</code> 选项，则系统会自动帮您创建 <code>/home</code>、<code>/home/test</code> 以及 <code>/home/test/demo</code>。</li>
</ul>
<h2 id="rmdir-命令"> rmdir 命令</h2>
<p>和 mkdir 命令(创建空目录)恰好相反，rmdir(remove empty directories 的缩写)命令用于删除空目录，此命令的基本格式为:</p>
<div><pre><code><span>[root@localhost ~]# rmdir [-p] 目录名
</span></code></pre>
<div><span>1</span><br></div></div><p>-p 选项用于递归删除空目录。</p>
<div><p>提示</p>
<p>rmdir 命令的作用十分有限，因为只能刪除空目录，所以一旦目录中有内容，就会报错。</p>
</div>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>南辞</name>
    </contributor>
    <published>2019-11-18T00:00:00.000Z</published>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">文件</title>
    <id>http://qiqi.dreamagain.top/software/linux/command/file/</id>
    <link href="http://qiqi.dreamagain.top/software/linux/command/file/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<h2 id="touch-命令"> touch 命令</h2>
<p>需要注意的是，touch 命令不光可以用来创建文件(当指定操作文件不存在时，该命令会在当前位置建立一个空文件)，此命令更重要的功能是修改文件的时间参数(但当文件存在时，会修改此文件的时间参数)。</p>
<p>Linux 系统中，每个文件主要拥有 3 个时间参数(通过 stat 命令进行查看)，分别是文件的访问时间、数据修改时间以及状态修改时间:</p>
<ul>
<li>访问时间 (Access Time，简称 atime): 只要文件的内容被读取，访问时间就会更新。例如，使用 <code>cat</code> 命令可以查看文件的内容，此时文件的访问时间就会发生改变。</li>
<li>数据修改时间 (Modify Time，简称 mtime): 当文件的内容数据发生改变，此文件的数据修改时间就会跟着相应改变。</li>
<li>状态修改时间 (Change Time，简称 ctime): 当文件的状态发生变化，就会相应改变这个时间。比如说，如果文件的权限或者属性发生改变，此时间就会相应改变。</li>
</ul>
<p>touch 命令的基本格式如下:</p>
<div><pre><code><span>[root@localhost ~]# touch [选项] 文件名
</span></code></pre>
<div><span>1</span><br></div></div><p>选项:</p>
<ul>
<li>-a: 只修改文件的访问时间；</li>
<li>-c: 仅修改文件的时间参数(3 个时间参数都改变)，如果文件不存在，则不建立新文件。</li>
<li>-d: 后面可以跟欲修订的日期，而不用当前的日期，即把文件的 atime 和 mtime 时间改为指定的时间。</li>
<li>-m: 只修改文件的数据修改时间。</li>
<li>-t: 命令后面可以跟欲修订的时间，而不用目前的时间，时间书写格式为 YYMMDDhhmm。</li>
</ul>
<p>可以看到，touch 命令可以只修改文件的访问时间，也可以只修改文件的数据修改时间，但是不能只修改文件的状态修改时间。因为，不论是修改访问时间，还是修改文件的数据时间，对文件来讲，状态都会发生改变，即状态修改时间会随之改变(更新为操作当前文件的真正时间)。</p>
<h2 id="ln-命令"> ln 命令</h2>
<p>如果要想说清楚 ln 命令，则必须先解释下 ext 文件系统(Linux 文件系统)是如何工作的。我们在前面讲解了分区的格式化就是写入文件系统，而我们的 Linux 目前使用的是 ext4 文件系统。</p>
<p>ext4 文件系统会把分区主要分为两大部分(暂时不提超级块): 小部分用于保存文件的 inode (i 节点)信息；剩余的大部分用于保存 block 信息。</p>
<p>inode 的默认大小为 128 Byte，用来记录文件的权限(r、w、x)、文件的所有者和属组、文件的大小、文件的状态改变时间(ctime)、文件的最近一次读取时间(atime)、文件的最近一次修改时间(mtime)、文件的数据真正保存的 block 编号。每个文件需要占用一个 inode。大家如果仔细查看，就会发现 inode 中是不记录文件名的，那是因为文件名记录在文件所在目录的 block 中。</p>
<p>block 的大小可以是 1KB、2KB、4KB，默认为 4KB。block 用于实际的数据存储，如果一个 block 放不下数据，则可以占用多个 block。例如，有一个 10KB 的文件需要存储，则会占用 3 个 block，虽然最后一个 block 不能占满，但也不能再放入其他文件的数据。这 3 个 block 有可能是连续的，也有可能是分散的。</p>
<p>由此，我们可以知道以下 2 个重要的信息:</p>
<ol>
<li>每个文件都独自占用一个 inode，文件内容由 inode 的记录来指向；</li>
<li>如果想要读取文件内容，就必须借助目录中记录的文件名找到该文件的 inode，才能成功找到文件内容所在的 block 块；</li>
</ol>
<p>了解了 Linux 系统底层文件的存储状态后，接下来学习 ln 命令。</p>
<p>ln 命令用于给文件创建链接，根据 Linux 系统存储文件的特点，链接的方式分为以下 2 种:</p>
<ul>
<li>软链接: 类似于 Windows 系统中给文件创建快捷方式，即产生一个特殊的文件，该文件用来指向另一个文件，此链接方式同样适用于目录。</li>
<li>硬链接: 我们知道，文件的基本信息都存储在 inode 中，而硬链接指的就是给一个文件的 inode 分配多个文件名，通过任何一个文件名，都可以找到此文件的 inode，从而读取该文件的数据信息。</li>
</ul>
<p>ln 命令的基本格式如下:</p>
<div><pre><code><span>[root@localhost ~]# ln [选项] 源文件 目标文件
</span></code></pre>
<div><span>1</span><br></div></div><p>选项:</p>
<ul>
<li>-s: 建立软链接文件。如果不加 <code>-s</code> 选项，则建立硬链接文件；</li>
<li>-f: 强制。如果目标文件已经存在，则删除目标文件后再建立链接文件；</li>
</ul>
<h3 id="ln-扩展介绍"> ln 扩展介绍</h3>
<ul>
<li><a href="./src/software/linux/command/ln.html">点击前往</a></li>
</ul>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>南辞</name>
    </contributor>
    <published>2019-11-19T00:00:00.000Z</published>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">链接</title>
    <id>http://qiqi.dreamagain.top/software/linux/command/ln/</id>
    <link href="http://qiqi.dreamagain.top/software/linux/command/ln/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <summary type="html"><![CDATA[<p>建立硬链接和软链接非常简单，那这两种链接有什么区别? 它们都有什么作用? 这才是链接文件最不容易理解的地方，我们分别来讲讲。</p>
]]></summary>
    <content type="html"><![CDATA[<p>建立硬链接和软链接非常简单，那这两种链接有什么区别? 它们都有什么作用? 这才是链接文件最不容易理解的地方，我们分别来讲讲。</p>

<h2 id="ln-创建硬链接"> ln 创建硬链接</h2>
<p>我们再来建立一个硬链接文件，然后看看这两个文件的特点。</p>
<div><pre><code><span>[root@localhost ~]# touch test
</span><span><span>#</span><span>建立源文件</span></span>
<span>[root@localhost ~]# ln /root/test /tmp/test-hard
</span><span><span>#</span><span>给源文件建立硬链接文件 /tmp/test-hard</span></span>
<span>[root@localhost ~]# ll -i /root/test /tmp/test-hard
262147 -rw-r--r-- 2 root root 0 6月 19 10:06 /root/test
hard
262147 -rw-r--r-- 2 root root 0 6月 19 10:06 /tmp/test-hard
</span><span><span>#</span><span>查看两个文件的详细信息，可以发现这两个文件的 inode 号是一样的，<span>"ll"</span>等同于<span>"ls -l"</span>。</span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>这里有一件很奇怪的事情，我们之前在讲 inode 号的时候说过，每个文件的 inode 号都应该是不一样的。inode 号就相当于文件 ID，我们在查找文件的时候，要先查找 inode 号，才能读取到文件的内容。</p>
<p>但是这里源文件和硬链接文件的 inode 号居然是一样的，那我们在查找文件的时候，到底找到的是哪一个文件呢? 我们来画一张示意图，如图 2 所示。</p>
<p><img src="src/software/linux/assets/hardlink.jpg" alt="Hardlink"></p>
<p>在 inode 信息中，是不会记录文件名称的，而是把文件名记录在上级目录的 block 中。也就是说，目录的 block 中记录的是这个目录下所有一级子文件和子目录的文件名及 inode 的对应；而文件的 block 中记录的才是文件实际的数据。</p>
<p>当我们查找一个文件，比如 <code>/root/test</code> 时，要经过以下步骤:</p>
<ul>
<li>首先找到根目录的 inode(根目录的 inode 是系统已知的，inode 号是 2)，然后判断用户是否有权限访问根目录的 block。</li>
<li>如果有权限，则可以在根目录的 block 中访问到 <code>/root</code> 的文件名及对应的 inode 号。</li>
<li>通过 <code>/root/</code> 目录的 inode 号，可以查找到 <code>/root/</code> 目录的 inode 信息，接着判断用户是否有权限访问 <code>/root/</code> 目录的 block。</li>
<li>如果有权限，则可以从 <code>/root/</code> 目录的 block 中读取到 test 文件的文件名及对应的 inode 号。</li>
<li>通过 test 文件的 inode 号，就可以找到 test 文件的 inode 信息，接着判断用户是否有权限访问 test 文件的 block。</li>
<li>如果有权限，则可以读取 block 中的数据，这样就完成了 <code>/root/test</code> 文件的读取与访问。</li>
</ul>
<p>按照这个步骤，在给源文件 <code>/root/test</code> 建立了硬链接文件 <code>/tmp/test-hard</code> 之后，在 <code>/root/</code> 目录和 <code>/tmp/</code> 目录的 block 中就会建立 test 和 test-hard 的信息，这个信息主要就是文件名和对应的 inode 号。但是我们会发现 test 和 test-hard 的 inode 信息居然是一样的，那么，我们无论访问哪个文件，最终都会访问 inode 号是 262147 的文件信息。</p>
<p>这就是硬链接的原理。硬链接的特点如下:</p>
<ul>
<li>不论是修改源文件(test 文件)，还是修改硬链接文件(test-hard 文件)，另一个文件中的数据都会发生改变。</li>
<li>不论是删除源文件，还是删除硬链接文件，只要还有一个文件存在，这个文件(inode 号是 262147 的文件)都可以被访问。</li>
<li>硬链接不会建立新的 inode 信息，也不会更改 inode 的总数。</li>
<li>硬链接不能跨文件系统(分区)建立，因为在不同的文件系统中，inode 号是重新计算的。</li>
<li>硬链接不能链接目录，因为如果给目录建立硬链接，那么不仅目录本身需要重新建立，目录下所有的子文件，包括子目录中的所有子文件都需要建立硬链接，这对当前的 Linux 来讲过于复杂。</li>
</ul>
<p>硬链接的限制比较多，既不能跨文件系统，也不能链接目录，而且源文件和硬链接文件之间除 inode 号是一样的之外，没有其他明显的特征。这些特征都使得硬链接并不常用，大家有所了解就好。</p>
<h2 id="ln-创建软链接"> ln 创建软链接</h2>
<p>软链接也称作符号链接，相比硬链接来讲，软链接就要常用多了。我们先建立一个软链接，再来看看软链接的特点。</p>
<div><pre><code><span>[root@localhost ~]# touch check
</span><span><span>#</span><span>建立源文件</span></span>
<span>[root@localhost ~]# ln -s /root/check /tmp/check-soft
</span><span><span>#</span><span>建立软链接文件</span></span>
<span>[root@localhost ~]# ll -id /root/check /tmp/check-soft
262154 -rw-r--r-- 1 root root 0 6月 19 11:30 /root/check
917507 lrwxrwxrwx 1 root root 11 6月 19 11:31 /tmp/ check-soft -> /root/check
</span><span><span>#</span><span>软链接和源文件的 inode 号不一致，软链接通过 -<span>></span> 明显地标识出源文件的位置</span></span>
<span><span>#</span><span>在软链接的权限位 lrwxrwxrwx 中，l 就代表软链接文件</span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>再强调一下，软链接的源文件必须写绝对路径，否则建立的软链接文件就会报错，无法正常使用。</p>
<p>软链接的标志非常明显，首先，权限位中&quot;l&quot;表示这是一个软链接文件；其次，在文件的后面通过 &quot;-&gt;&quot; 显示出源文件的完整名字。所以软链接比硬链接的标志要明显得多，而且软链接也不像硬链接的限制那样多，比如软链接可以链接目录，也可以跨分区来建立软链接。</p>
<p>软链接完全可以当作 Windows 的快捷方式来对待，它的特点和快捷方式一样，我们更推荐大家使用软链接，而不是硬链接。</p>
<p>大家在学习软链接的时候会有一些疑问: Windows 的快捷方式是由于源文件放置的位置过深，不容易找到，建立一个快捷方式放在桌面，方便查找，那 Linux 的软链接的作用是什么呢?</p>
<p>软链接主要是为了照顾管理员的使用习惯。比如，有些系统的自启动文件 <code>/etc/rc.local</code> 放置在 <code>/etc</code> 目录中，而有些系统却将其放置在 <code>/etc/rc.d/rc.local</code> 中，那么干脆对这两个文件建立软链接，不论您习惯操作哪一个文件，结果都是一样的。</p>
<p>如果您比较细心，则应该已经发现软链接和源文件的 inode 号是不一致的，我们也画一张示意图来看看软链接的原理，如图 3 所示。</p>
<p><img src="src/software/linux/assets/softlink.jpg" alt="软链接示意图"></p>
<p>软链接和硬链接在原理上最主要的不同在于: 硬链接不会建立自己的 inode 索引和 block(数据块)，而是直接指向源文件的 inode 信息和 block，所以硬链接和源文件的 inode 号是一致的；而软链接会真正建立自己的 inode 索引和 block，所以软链接和源文件的 inode 号是不一致的，而且在软链接的 block 中，写的不是真正的数据，而仅仅是源文件的文件名及 inode 号。</p>
<p>我们来看看访问软链接的步骤和访问硬链接的步骤有什么不同。</p>
<ul>
<li>首先找到根目录的 inode 索引信息，然后判断用户是否有权限访问根目录的 block。</li>
<li>如果有权限访问根目录的 block，就会在 block 中查找到 <code>/tmp/</code> 目录的 inode 号。</li>
<li>接着访问 <code>/tmp/</code> 目录的 inode 信息，判断用户是否有权限访问 <code>/tmp/</code> 目录的 block。</li>
<li>如果有权限，就会在 block 中读取到软链接文件 check-soft 的 inode 号。因为软链接文件会真正建立自己的 inode 索引和 block，所以软链接文件和源文件的 inode 号是不一样的。</li>
<li>通过软链接文件的 inode 号，找到了 check-soft 文件 inode 信息，判断用户是否有权限访问 block。</li>
<li>如果有权限，就会发现 check-soft 文件的 block 中没有实际数据，仅有源文件 check 的 inode 号。</li>
<li>接着通过源文件的 inode 号，访问到源文件 check 的 inode 信息，判断用户是否有权限访问 block。</li>
<li>如果有权限，就会在 check 文件的 block 中读取到真正的数据，从而完成数据访问。</li>
</ul>
<p>通过这个过程，我们就可以总结出软链接的特点(软链接的特点和 Windows 中的快捷方式完全一致)。</p>
<ul>
<li>不论是修改源文件(check)，还是修改硬链接文件(check-soft)，另一个文件中的数据都会发生改变。</li>
<li>删除软链接文件，源文件不受影响。而删除原文件，软链接文件将找不到实际的数据，从而显示文件不存在。</li>
<li>软链接会新建自己的 inode 信息和 block，只是在 block 中不存储实际文件数据，而存储的是源文件的文件名及 inode 号。</li>
<li>软链接可以链接目录。</li>
<li>软链接可以跨分区。</li>
</ul>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>南辞</name>
    </contributor>
    <published>2019-11-20T00:00:00.000Z</published>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">其他文件命令</title>
    <id>http://qiqi.dreamagain.top/software/linux/command/other/</id>
    <link href="http://qiqi.dreamagain.top/software/linux/command/other/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<h2 id="cp-命令"> cp 命令</h2>
<p>cp 命令，主要用来复制文件和目录，同时借助某些选项，还可以实现复制整个目录，以及比对两文件的新旧而予以升级等功能。</p>
<p>cp 命令的基本格式如下:</p>
<div><pre><code><span>[root@localhost ~]# cp [选项] 源文件 目标文件
</span></code></pre>
<div><span>1</span><br></div></div><p>选项:</p>
<ul>
<li>-a: 相当于 -d、-p、-r 选项的集合，这几个选项我们一一介绍；</li>
<li>-d: 如果源文件为软链接(对硬链接无效)，则复制出的目标文件也为软链接；</li>
<li>-i: 询问，如果目标文件已经存在，则会询问是否覆盖；</li>
<li>-l: 把目标文件建立为源文件的硬链接文件，而不是复制源文件；</li>
<li>-s: 把目标文件建立为源文件的软链接文件，而不是复制源文件；</li>
<li>-p: 复制后目标文件保留源文件的属性(包括所有者、所属组、权限和时间)；</li>
<li>-r: 递归复制，用于复制目录；</li>
<li>-u: 若目标文件比源文件有差异，则使用该选项可以更新目标文件，此选项可用于对文件的升级和备用。</li>
</ul>
<p>需要注意的是，源文件可以有多个，但这种情况下，目标文件必须是目录才可以。</p>
<h3 id="cp-命令基本用法"> cp 命令基本用法</h3>
<p>cp 命令既可以复制文件，也可以复制目录。我们先来看看如何复制文件，例如:</p>
<div><pre><code><span>[root@localhost ~]# touch cangls
</span><span><span>#</span><span>建立源文件</span></span>
<span>[root@localhost ~]# cp cangls /tmp/
</span><span><span>#</span><span>把源文件不改名复制到 /tmp/ 目录下</span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>如果需要改名复制，则命令如下:</p>
<div><pre><code><span>[root@localhost ~]# cp cangls /tmp/bols
</span><span><span>#</span><span>改名复制</span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>如果复制的目标位置已经存在同名的文件，则会提示是否覆盖，因为 cp 命令默认执行的是 <code>cp -i</code> 的别名，例如:</p>
<div><pre><code><span>[root@localhost ~]# cp cangls /tmp/
cp:是否覆盖"/tmp/cangls"?y
</span><span><span>#</span><span>目标位置有同名文件，所以会提示是否覆盖</span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>接下来我们看看如何复制目录，其实复制目录只需使用 <code>-r</code> 选项即可，例如:</p>
<div><pre><code><span>[root@localhost ~]# mkdir movie
</span><span><span>#</span><span>建立测试目录</span></span>
<span>[root@localhost ~]# cp -r /root/movie/ /tmp/
</span><span><span>#</span><span>目录原名复制</span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id="复制软链接文件"> 复制软链接文件</h3>
<p>如果源文件不是一个普通文件，而是一个软链接文件，那么是否可以复制软链接的属性呢? 我们试试:</p>
<div><pre><code><span>[root@localhost ~]# ln -s /root/cangls /tmp/cangls_slink
</span><span><span>#</span><span>建立一个测试软链接文件/tmp/cangls_slink</span></span>
<span>[root@localhost ~]# ll /tmp/cangls_slink
lrwxrwxrwx 1 root root 12 6 月 14 05:53 /tmp/cangls_slink -> /root/cangls
</span><span><span>#</span><span>源文件本身就是一个软链接文件</span></span>
<span>[root@localhost ~]# cp /tmp/cangls_slink /tmp/cangls_t1
</span><span><span>#</span><span>复制软链接文件，但是不加<span>"-d"</span>选项</span></span>
<span>[root@localhost ~]# cp -d /tmp/cangls_slink /tmp/cangls_t2
</span><span><span>#</span><span>复制软链接文件，加入<span>"-d"</span>选项</span></span>
<span>[root@localhost ~]# ll /tmp/cangls_t1 /tmp/cangls_t2
-rw-r--r-- 1 root root 0 6月 14 05:56 /tmp/cangls_t1
</span><span><span>#</span><span>会发现不加<span>"-d"</span>选项，实际复制的是软链接的源文件，而不是软链接文件</span></span>
<span>lrwxrwxrwx 1 root root 12 6 月 14 05:56/tmp/ cangls_t2-> /root/cangls
</span><span><span>#</span><span>而如果加入了<span>"-d"</span>选项，则会复制软链接文件</span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>这个例子说明，如果在复制软链接文件时不使用 <code>-d</code> 选项，则 <code>cp</code> 命令复制的是源文件，而不是软链接文件；只有加入了 <code>-d</code> 选项，才会复制软链接文件。请大家注意，<code>-d</code> 选项对硬链接是无效的。</p>
<h3 id="保留源文件属性复制"> 保留源文件属性复制</h3>
<p>我们发现，在执行复制命令后，目标文件的时间会变成复制命令的执行时间，而不是源文件的时间。例如:</p>
<div><pre><code><span>[root@localhost ~]# cp /var/lib/mlocate/mlocate.db /tmp/
[root@localhost ~]# ll /var/lib/mlocate/mlocate.db
-rw-r-----1 root slocate2328027 6月 14 02:08/var/lib/mlocate/mlocate.db
</span><span><span>#</span><span>注意源文件的时间和所属组</span></span>
<span>[root@localhost ~]#ll /tmp/mlocate.db
-rw-r----- 1 root root2328027 6 月 14 06:05/tmp/mlocate.db
</span><span><span>#</span><span>由于复制命令由root用户执行，所以目标文件的所属组为了root，而且时间也变成了复制命令的执行时间</span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>而当我们执行备份、曰志备份的时候，这些文件的时间可能是一个重要的参数，这就需执行 <code>-p</code> 选项了。这个选项会保留源文件的属性，包括所有者、所属组和时间。例如:</p>
<div><pre><code><span>[root@localhost ~]# cp -p /var/lib/mlocate/mlocate.db /tmp/mlocate.db_2
</span><span><span>#</span><span>使用<span>"-p"</span>选项</span></span>
<span>[root@localhost ~]# ll /var/lib/mlocate/mlocate.db /tmp/mlocate.db_2
-rw-r----- root slocate 2328027 6月 14 02:08 /tmp/mlocate.db_2
-rw-r----- root slocate 2328027 6月 14 02:08 /var/lib/mlocate/mlocate.db
</span><span><span>#</span><span>源文件和目标文件的所有属性都一致，包括时间</span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>我们之前讲过，<code>-a</code> 选项相当于 &quot;-d、-p、-r&quot; 选项，这几个选项我们已经分别讲过了。所以，当我们使用 <code>-a</code> 选项时，目标文件和源文件的所有属性都一致，包括源文件的所有者，所属组、时间和软链接性。使用 <code>-a</code> 选项来取代 &quot;-d、-p、-r&quot; 选项更加方便。</p>
<h3 id="l-和-s-选项"> &quot;-l&quot; 和 &quot;-s&quot; 选项</h3>
<p>我们如果使用 <code>-l</code> 选项，则目标文件会被建立为源文件的硬链接；而如果使用了 <code>-s</code> 选项，则目标文件会被建立为源文件的软链接。</p>
<p>这两个选项和 <code>-d</code> 选项是不同的，<code>d</code> 选项要求源文件必须是软链接，目标文件才会复制为软链接；而 <code>-l</code> 和 <code>-s</code> 选项的源文件只需是普通文件，目标文件就可以直接复制为硬链接和软链接。例如:</p>
<div><pre><code><span>[root@localhost ~]# touch bols
</span><span><span>#</span><span>建立测试文件</span></span>
<span>[root@localhost ~]# ll -i bols
262154-rw-r--r-- 1 root root 0 6月 14 06:26 bols
</span><span><span>#</span><span>源文件只是一个普通文件，而不是软链接文件</span></span>
<span>[root@localhost ~]# cp -l /root/bols /tmp/bols_h
[root@localhost ~]# cp -s /root/bols /tmp/bols_s
</span><span><span>#</span><span>使用<span>"-l"</span> 和<span>"-s"</span>选项复制</span></span>
<span>[root@localhost ~]# ll -i /tmp/bols_h /tmp/bols_s
262154-rw-r--r-- 2root root 0 6 月 14 06:26/tmp/bols_h
</span><span><span>#</span><span>目标文件 /tmp/bols_h 为源文件的硬链接文件</span></span>
<span>932113 lrwxrwxrwx 1 root root 10 6 月 14 06:27/tmp/bols_s -> /root/bols
</span><span><span>#</span><span>目标文件 /tmp/bols_s 为源文件的软链接文件</span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h2 id="rm-命令"> rm 命令</h2>
<p>当 Linux 系统使用很长时间之后，可能会有一些已经没用的文件(即垃圾)，这些文件不但会消耗宝贵的硬盘资源，还是降低系统的运行效率，因此需要及时地清理。</p>
<p>rm 是强大的删除命令，它可以永久性地删除文件系统中指定的文件或目录。在使用 rm 命令删除文件或目录时，系统不会产生任何提示信息。此命令的基本格式为:</p>
<div><pre><code><span>[root@localhost ~]# rm[选项] 文件或目录
</span></code></pre>
<div><span>1</span><br></div></div><p>选项:</p>
<ul>
<li>-f: 强制删除(force)，和 <code>-i</code> 选项相反，使用 <code>-f</code>，系统将不再询问，而是直接删除目标文件或目录。</li>
<li>-i: 和 <code>-f</code> 正好相反，在删除文件或目录之前，系统会给出提示信息，使用 <code>-i</code> 可以有效防止不小心删除有用的文件或目录。</li>
<li>-r: 递归删除，主要用于删除目录，可删除指定目录及包含的所有内容，包括所有的子目录和文件。</li>
</ul>
<div><p>提示</p>
<p>rm 命令是一个具有破坏性的命令，因为 rm 命令会永久性地删除文件或目录，这就意味着，如果没有对文件或目录进行备份，一旦使用 rm 命令将其删除，将无法恢复，因此，尤其在使用 rm 命令删除目录时，要慎之又慎。</p>
</div>
<h3 id="基本用法"> 基本用法</h3>
<p>rm 命令如果任何选项都不加，则默认执行的是 <code>rm -i 文件名</code>，也就是在删除一个文件之前会先询问是否删除。例如:</p>
<div><pre><code><span>[root@localhost ~]# touch cangls
[root@localhost ~]# rm cangls
rm:是否删除普通空文件"cangls"?y
</span><span><span>#</span><span>删除前会询问是否删除</span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id="删除目录"> 删除目录</h3>
<p>如果需要删除目录，则需要使用 <code>-r</code> 选项。例如:</p>
<div><pre><code><span>[root@localhost ~]# mkdir -p /test/lm/movie/jp
</span><span><span>#</span><span>递归建立测试目录</span></span>
<span>[root@localhost ~]# rm /test
rm:无法删除"/test/": 是一个目录
</span><span><span>#</span><span>如果不加<span>"-r"</span>选项，则会报错</span></span>
<span>[root@localhost ~]# rm -r /test
rm:是否进入目录"/test"?y
rm:是否进入目录"/test/lm/movie"?y
rm:是否删除目录"/test/lm/movie/jp"?y
rm:是否删除目录"/test/lm/movie"?y
rm:是否删除目录"/test/lm"?y
rm:是否删除目录"/test"?y
</span><span><span>#</span><span>会分别询问是否进入子目录、是否删除子目录</span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>大家会发现，如果每级目录和每个文件都需要确认，那么在实际使用中简直是灾难!</p>
<h3 id="强制删除"> 强制删除</h3>
<p>如果要删除的目录中有 1 万个子目录或子文件，那么普通的 rm 删除最少需要确认 1 万次。所以，在真正删除文件的时候，我们会选择强制删除。例如:</p>
<div><pre><code><span>[root@localhost ~]# mkdir -p /test/lm/movie/jp
</span><span><span>#</span><span>重新建立测试目录</span></span>
<span>[root@localhost ~]# rm -rf /test
</span><span><span>#</span><span>强制删除，一了百了</span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>加入了强制功能之后，删除就会变得很简单，但是需要注意，数据强制删除之后无法恢复，除非依赖第三方的数据恢复工具，如 extundelete 等。但要注意，数据恢复很难恢复完整的数据，一般能恢复 70%~80% 就很难得了。所以，与其把宝压在数据恢复上，不如养成良好的操作习惯。</p>
<p>虽然 <code>-rf</code> 选项是用来删除目录的，但是删除文件也不会报错。所以，为了使用方便，一般不论是删除文件还是删除目录，都会直接使用 <code>-rf</code> 选项。</p>
<h2 id="mv-命令"> mv 命令</h2>
<p>mv 命令(move 的缩写)，既可以在不同的目录之间移动文件或目录，也可以对文件和目录进行重命名。该命令的基本格式如下:</p>
<div><pre><code><span>[root@localhost ~]# mv 【选项】 源文件 目标文件
</span></code></pre>
<div><span>1</span><br></div></div><p>选项:</p>
<ul>
<li>-f: 强制覆盖，如果目标文件已经存在，则不询问，直接强制覆盖；</li>
<li>-i: 交互移动，如果目标文件已经存在，则询问用户是否覆盖(默认选项)；</li>
<li>-n: 如果目标文件已经存在，则不会覆盖移动，而且不询问用户；</li>
<li>-v: 显示文件或目录的移动过程；</li>
<li>-u: 若目标文件已经存在，但两者相比，源文件更新，则会对目标文件进行升级；</li>
</ul>
<p>需要注意的是，同 rm 命令类似，mv 命令也是一个具有破坏性的命令，如果使用不当，很可能给系统带来灾难性的后果。</p>
<h3 id="移动文件或目录"> 移动文件或目录</h3>
<div><pre><code><span>[root@localhost ~]# mv cangls /tmp
</span><span><span>#</span><span>移动之后，源文件会被删除，类似剪切</span></span>
<span>[root@localhost ~]# mkdir movie
[root@localhost ~]# mv movie/ /tmp
</span><span><span>#</span><span>也可以移动目录。和 rm、cp 不同的是，mv 移动目录不需要加入 <span>"-r"</span> 选项</span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>如果移动的目标位置已经存在同名的文件，则同样会提示是否覆盖，因为 mv 命令默认执行的也是 <code>mv -i</code> 的别名，例如:</p>
<div><pre><code><span>[root@localhost ~]# touch cangls
</span><span><span>#</span><span>重新建立文件</span></span>
<span>[root@localhost ~]# mv cangls /tmp
mv:县否覆盖"tmp/cangls"? y
</span><span><span>#</span><span>由于 /tmp 目录下已经存在 cangls 文件，所以会提示是否覆盖，需要手工输入 y 覆盖移动</span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h3 id="强制移动"> 强制移动</h3>
<p>之前说过，如果目标目录下已经存在同名文件，则会提示是否覆盖，需要手工确认。这时如果移动的同名文件较多，则需要一个一个文件进行确认，很不方便。</p>
<p>如果我们确认需要覆盖已经存在的同名文件，则可以使用 <code>-f</code> 选项进行强制移动，这就不再需要用户手工确认了。例如:</p>
<div><pre><code><span>[root@localhost ~]# touch cangls
</span><span><span>#</span><span>重新建立文件</span></span>
<span>[root@localhost ~]# mv -f cangls /tmp
</span><span><span>#</span><span>就算 /tmp/ 目录下已经存在同名的文件，由于<span>"-f"</span>选项的作用，所以会强制覆盖</span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id="不覆盖移动"> 不覆盖移动</h3>
<p>既然可以强制覆盖移动，那也有可能需要不覆盖的移动。如果需要移动几百个同名文件，但是不想覆盖，这时就需要 <code>-n</code> 选项的帮助了。例如:</p>
<div><pre><code><span>[root@localhost ~]# ls /tmp
/tmp/bols /tmp/cangls
</span><span><span>#</span><span>在/tmp/目录下已经存在bols、cangls文件了</span></span>
<span>[root@localhost ~]# mv -vn bols cangls lmls /tmp/、
"lmls"->"/tmp/lmls"
</span><span><span>#</span><span>再向 /tmp/ 目录中移动同名文件，如果使用了 <span>"-n"</span> 选项，则可以看到只移动了 lmls，而同名的 bols 和 cangls 并没有移动<span>(</span><span>"-v"</span> 选项用于显示移动过程<span>)</span></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h3 id="改名"> 改名</h3>
<p>如果源文件和目标文件在同一目录中，那就是改名。例如:</p>
<div><pre><code><span>[root@localhost ~]# mv bols lmls
</span><span><span>#</span><span>把 bols 改名为 lmls</span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>目录也可以按照同样的方法改名。</p>
<h3 id="显示移动过程"> 显示移动过程</h3>
<p>如果我们想要知道在移动过程中到底有哪些文件进行了移动，则可以使用 <code>-v</code> 选项来查看详细的移动信息。例如:</p>
<div><pre><code><span>[root@localhost ~]# touch test1.txt test2.txt test3.txt
</span><span><span>#</span><span>建立三个测试文件</span></span>
<span>[root@localhost ~]# mv -v *.txt /tmp
"test1.txt" -> "/tmp/test1.txt"
"test2.txt" -> "/tmp/test2.txt"
"test3.txt" -> "/tmp/test3.txt"
</span><span><span>#</span><span>加入<span>"-v"</span>选项，可以看到有哪些文件进行了移</span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div>]]></content>
    <author>
      <name>南辞</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>南辞</name>
    </contributor>
    <published>2019-11-19T00:00:00.000Z</published>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">环境变量</title>
    <id>http://qiqi.dreamagain.top/software/linux/command/path/</id>
    <link href="http://qiqi.dreamagain.top/software/linux/command/path/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<h1 id="环境变量"> 环境变量</h1>
<h2 id="变量"> 变量</h2>
<p>变量是计算机系统用于保存可变值的数据类型，我们可以直接通过变量名称来提取到对应的变量值。在 Linux 系统中，环境变量是用来定义系统运行环境的一些参数，比如每个用户不同的家目录 (HOME)、邮件存放位置 (MAIL)等。
值得一提的是，Linux 系统中环境变量的名称一般都是大写的，这是一种约定俗成的规范。</p>
<p>我们可以使用 env 命令来查看到 Linux 系统中所有的环境变量，执行命令如下:</p>
<div><pre><code><span>[root@localhost ~]# env
ORBIT_SOCKETDIR=/tmp/orbit-root
HOSTNAME=livecd.centos
GIO_LAUNCHED_DESKTOP_FILE_PID=2065
TERM=xterm
SHELL=/bin/bash
......
</span></code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>Linux 系统能够正常运行并且为用户提供服务，需要数百个环境变量来协同工作，但是，我们没有必要逐一学习每个变量。常见变量见下表:</p>
<table>
<thead>
<tr>
<th>环境变量名称</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>HOME</td>
<td>用户的主目录(也称家目录)</td>
</tr>
<tr>
<td>SHELL</td>
<td>用户使用的 Shell 解释器名称</td>
</tr>
<tr>
<td>PATH</td>
<td>定义命令行解释器搜索用户执行命令的路径</td>
</tr>
<tr>
<td>EDITOR</td>
<td>用户默认的文本解释器</td>
</tr>
<tr>
<td>RANDOM</td>
<td>生成一个随机数字</td>
</tr>
<tr>
<td>LANG</td>
<td>系统语言、语系名称</td>
</tr>
<tr>
<td>HISTSIZE</td>
<td>输出的历史命令记录条数</td>
</tr>
<tr>
<td>HISTFILESIZE</td>
<td>保存的历史命令记录条数</td>
</tr>
<tr>
<td>PS1</td>
<td>Bash 解释器的提示符</td>
</tr>
<tr>
<td>MAIL</td>
<td>邮件保存路径</td>
</tr>
</tbody>
</table>
<p>Linux 作为一个多用户多任务的操作系统，能够为每个用户提供独立的、合适的工作运行环境，因此，一个相同的环境变量会因为用户身份的不同而具有不同的值。</p>
<p>例如，使用下述命令来查看 <code>HOME</code> 变量在不同用户身份下都有哪些值:</p>
<div><pre><code><span>[root@localhost ~]# echo $HOME
/root
[root@localhost ~]# su - user1  &lt;--切换到 user1 用户身份
[user1@localhost ~]$ echo $HOME
/home/user1
</span></code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>这里的 <code>su</code> 命令可以临时切换用户身份，此命令的具体用法会在后续章节做详细介绍。</p>
<p>其实，环境变量是由固定的变量名与用户或系统设置的变量值两部分组成的，我们完全可以自行创建环境变量来满足工作需求。例如，设置一个名称为 <code>WORKDIR</code> 的环境变量，方便用户更轻松地进入一个层次较深的目录，执行命令如下:</p>
<div><pre><code><span>[root@localhost ~]# mkdir /home/work1
[root@localhost ~]# WORKDIR=/home/work1
[root@localhost ~]# cd $WORKDIR
[root@localhost work1]# pwd
/home/work1
</span></code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>但是，这样的环境变量不具有全局性，作用范围也有限，默认情况下不能被其他用户使用。如果工作需要，可以使用 <code>export</code> 命令将其提升为全局环境变量，这样其他用户就可以使用它了:</p>
<div><pre><code><span>[root@localhost work1]# su user1  &lt;-- 切换到 user1，发现无法使用 WORKDIR 自定义变量
[user1@localhost ~]$ cd $WORKDIR
[user1@localhost ~]$ echo $WORKDIR

[user1@localhost ~]$ exit &lt;--退出user1身份
[root@localhost work1]# export WORKDIR
[root@localhost work1]# su user1
[user1@localhost ~]$ cd $WORKDIR
[user1@localhost work1]$ pwd
/home/work1
</span></code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h2 id="path"> path</h2>
<p>在讲解 PATH 环境变量之前，首先介绍一下 <code>which</code> 命令，它用于查找某个命令所在的绝对路径。例如:</p>
<div><pre><code><span>[root@localhost ~]# which rm
/bin/rm
[root@localhost ~]# which rmdir
/bin/rmdir
[root@localhost ~]# which ls
alias ls='ls --color=auto'
        /bin/ls
</span></code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>注意，<code>ls</code> 是一个相对特殊的命令，它使用 alias 命令做了别名，也就是说，我们常用的 <code>ls</code> 实际上执行的是 <code>ls --color=auto</code>。</p>
<p>通过使用 <code>which</code> 命令，可以查找各个外部命令(和 Shell 内置命令相对)所在的绝对路径。学到这里，读者是否有这样一个疑问，为什么前面在使用 <code>rm</code>、<code>rmdir</code>、<code>ls</code> 等命令时，无论当前位于哪个目录，都可以直接使用，而无需指明命令的执行文件所在的位置 (绝对路径) 呢? 其实，这是 PATH 环境变量在起作用。</p>
<p>首先，执行如下命令:</p>
<div><pre><code><span>[root@localhost ~]# echo $PATH
/usr/local/sbin:/usr/sbin:/sbin:/usr/local/bin:/usr/bin:/bin:/root/bin
</span></code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>这里的 <code>echo</code> 命令用来输出 PATH 环境变量的值(这里的 <code>$</code> 是 PATH 的前缀符号)，PATH 环境变量的内容是由一堆目录组成的，各目录之间用冒号 <code>:</code> 隔开。当执行某个命令时，Linux 会依照 PATH 中包含的目录依次搜寻该命令的可执行文件，一旦找到，即正常执行；反之，则提示无法找到该命令。
如果在 PATH 包含的目录中，有多个目录都包含某命令的可执行文件，那么会执行先搜索到的可执行文件。</p>
<p>从执行结果中可以看到，<code>/bin</code> 目录已经包含在 PATH 环境变量中，因此在使用类似 <code>rm</code>、<code>rmdir</code>、<code>ls</code> 等命令时，即便直接使用其命令名，Linux 也可以找到该命令。</p>
<p>为了印证以上观点，下面举个反例，如果我们将 <code>ls</code> 命令移动到 <code>/root</code> 目录下，由于 PATH 环境变量中没有包含此目录，所有当直接使用 <code>ls</code> 命令名执行时，Linux 将无法找到此命令的可执行文件，并提示 <code>No such file or directory</code>，示例命令如下:</p>
<div><pre><code><span>[root@localhost ~]# mv /bin/ls /root
[root@localhost ~]# ls
bash: /bin/ls: No such file or directory
</span></code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>此时，如果仍想使用 <code>ls</code> 命令，有 2 种方法，一种是直接将 <code>/root</code> 添加到 PATH 环境变量中，例如:</p>
<div><pre><code><span>[root@localhost ~]# PATH=$PATH:/root
[root@localhost ~]# echo $PATH
/usr/local/sbin:/usr/sbin:/usr/local/bin:/usr/bin:/bin:/root/bin:/root
[root@localhost ~]# ls
Desktop    Downloads    Music    post-install     Public    Videos
Documents  ls           Pictures post-install.org Templates
</span></code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>注意，这种方式只是临时有效，一旦退出下次再登陆的时候，<code>$PATH</code> 就恢复成了默认值。</p>
<p>另一种方法是以绝对路径的方式使用此命令，例如:</p>
<div><pre><code><span>[root@localhost ~]# /root/ls
Desktop    Downloads    Music    post-install     Public    Videos
Documents  ls           Pictures post-install.org Templates
</span></code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>为了不影响系统的正常使用，强烈建议大家将移动后的 <code>ls</code> 文件还原，命令如下:</p>
<div><pre><code><span>[root@localhost ~]# mv /root/ls /bin
</span></code></pre>
<div><span>1</span><br></div></div>]]></content>
    <author>
      <name>南辞</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>南辞</name>
    </contributor>
    <published>2019-11-20T00:00:00.000Z</published>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">其他指令</title>
    <id>http://qiqi.dreamagain.top/software/linux/command/temp/</id>
    <link href="http://qiqi.dreamagain.top/software/linux/command/temp/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<h1 id="其他指令"> 其他指令</h1>
<h2 id="文件"> 文件</h2>
<h3 id="创建文件"> 创建文件</h3>
<ul>
<li>touch</li>
<li>vi</li>
</ul>
<h3 id="编辑文件"> 编辑文件</h3>
<ul>
<li>vi</li>
</ul>
<div><p>提示</p>
<p>使用 vi 命令后，默认进入浏览模式。</p>
<p>按 <code>i</code> 进入 insert 模式， 按 <code>ESC</code> 退出。</p>
<ol>
<li>
<p>命令模式下，输入: <code>/</code> 字符串</p>
<p>比如搜索 user, 输入 <code>/user</code></p>
<p>按下回车之后，可以看到 vim 已经把光标移动到该字符处和高亮了匹配的字符串</p>
</li>
<li>
<p>查看下一个匹配，按下 n(小写 n)</p>
</li>
<li>
<p>跳转到上一个匹配，按下 N(大写 N)</p>
</li>
<li>
<p>搜索后，我们打开别的文件，发现也被高亮了，怎么关闭高亮?</p>
</li>
</ol>
<p>命令模式下，输入 <code>:nohlsearch</code> 也可以 <code>:set nohlsearch</code>；当然，可以简写，<code>noh</code> 或者 <code>set noh</code>。</p>
</div>
<h3 id="重命名文件"> 重命名文件</h3>
<ul>
<li>rename</li>
</ul>
<h3 id="移动文件"> 移动文件</h3>
<ul>
<li>mv</li>
</ul>
<div><p>提示</p>
<p>该命令也可用于重命名</p>
</div>
<h3 id="文件浏览"> 文件浏览</h3>
<ul>
<li>pwd: 查看当前目录</li>
<li>cd: 移动当前目录</li>
<li>ls: 列出当前目录
<ul>
<li><code>-l</code>: 以表格列出当前目录详情</li>
<li><code>-a</code>: 包括隐藏文件</li>
</ul>
</li>
</ul>
<h2 id="权限"> 权限</h2>
<ul>
<li>chmod: 查看/更改文件或文件夹权限</li>
</ul>
<p><code>chmod</code> 是权限管理命令 <code>change the permissions mode of a file</code> 的缩写。</p>
<p><code>u</code> 代表所有者，<code>x</code> 代表执行权限。<code>+</code> 表示增加权限。</p>
<div><pre><code><span>chmod</span> u+x file.sh
</code></pre>
<div><span>1</span><br></div></div><div><pre><code><span>chmod</span> 权限数字 文件名
</code></pre>
<div><span>1</span><br></div></div><ul>
<li>
<p>r 读权限 read 4</p>
</li>
<li>
<p>w 写权限 write 2</p>
</li>
<li>
<p>x 操作权限 execute 1</p>
</li>
</ul>
<div><pre><code><span>chmod</span> <span>600</span> id_rsa
</code></pre>
<div><span>1</span><br></div></div><h2 id="用户组"> 用户组</h2>
<h3 id="管理用户组"> 管理用户组</h3>
<p>groupadd groupname 　　添加用户组</p>
<p>groupdel groupname 　　删除用户组</p>
<p>##　添加用户到用户组
将一个用户添加到用户组中，千万不能直接用:</p>
<div><pre><code><span>usermod</span> -G groupA
</code></pre>
<div><span>1</span><br></div></div><p>这样做会使您离开其他用户组，仅仅做为 这个用户组 groupA 的成员。</p>
<p>应该用 加上 <code>-a</code> 选项:</p>
<div><pre><code><span>usermod</span> -a -G groupA user
<span>(</span>FC4: <span>usermod</span> -G groupA,groupB,groupC user<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><code>-a</code> 代表 <code>append</code>， 也就是 将自己添加到 用户组 groupA 中，而不必离开 其他用户组。</p>
<p>命令的所有的选项，及其含义:</p>
<div><pre><code>Options:

-c, –comment COMMENT new value of the GECOS field
-d, –home HOME_DIR new home directory for the user account
-e, –expiredate EXPIRE_DATE set account expiration date to EXPIRE_DATE
-f, –inactive INACTIVE set password inactive after expiration
to INACTIVE
-g, –gid GROUP force use GROUP as new primary group
-G, –groups GROUPS new list of supplementary GROUPS
-a, –append append the user to the supplemental GROUPS
mentioned by the -G option without removing
him/her from other groups
-h, –help display this help message and exit
-l, –login NEW_LOGIN new value of the login name
-L, –lock lock the user account
-m, –move-home move contents of the home directory to the new
location (use only with -d)
-o, –non-unique allow using duplicate (non-unique) UID
-p, –password PASSWORD use encrypted password for the new password
-s, –shell SHELL new login shell for the user account
-u, –uid UID new UID for the user account
-U, –unlock unlock the user account
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><p>查看用户所属的组使用命令:</p>
<div><pre><code><span>groups</span> user
</code></pre>
<div><span>1</span><br></div></div><p>或者查看文件:</p>
<div><pre><code><span>cat</span> /etc/group
</code></pre>
<div><span>1</span><br></div></div><h2 id="用户"> 用户</h2>
<p><code>cat /etc/passwd</code> 查看用户列表</p>
<h3 id="添加用户"> 添加用户</h3>
<div><pre><code><span>sudo</span> <span>useradd</span> <span>[</span>用户名<span>]</span>
</code></pre>
<div><span>1</span><br></div></div><p>创建新用户: useradd</p>
<p><code>-d</code> 指定目录文件夹</p>
<p><code>-m</code> 新账号名</p>
<p>如:</p>
<div><pre><code><span>useradd</span> -d /www/abc -m abc
</code></pre>
<div><span>1</span><br></div></div><ul>
<li><code>-c</code>: comment 指定一段注释性描述。</li>
<li><code>-d</code>: 目录 指定用户主目录，如果此目录不存在，则同时使用-m 选项，可以创建主目录。</li>
<li><code>-g</code>: 用户组 指定用户所属的用户组。</li>
<li><code>-G</code>: 用户组，用户组 指定用户所属的附加组。</li>
<li><code>-s</code>: Shell 文件 指定用户的登录 Shell。</li>
<li><code>-u</code>: 用户号 指定用户的用户号，如果同时有-o 选项，则可以重复使用其他用户的标识号。</li>
</ul>
<h3 id="设置密码"> 设置密码</h3>
<div><pre><code><span>sudo</span> <span>passwd</span> <span>[</span>用户名<span>]</span>
</code></pre>
<div><span>1</span><br></div></div><h2 id="删除用户"> 删除用户</h2>
<div><pre><code><span>userdel</span> abc
</code></pre>
<div><span>1</span><br></div></div><div><p>提示</p>
<p>使用 userdel abc 命令删除该用户时，并不能删除该用户的所有信息，只是删除了/etc/passwd、/etc/shadow、/etc/group/、/etc/gshadow 四个文件里的该账户和组的信息。默认情况下创建一个用户账号，会创建一个家目录和一个用户邮箱(在/var/spool/mail 目录以用户名命名)</p>
<p>所以建议使用 <code>userdel -r abc</code> 删除用户。</p>
</div>
<h2 id="服务管理"> 服务管理</h2>
<p>Linux 服务管理两种方式 service 和 systemctl</p>
<ol>
<li>
<p>service 命令</p>
<p>service 命令其实是去 <code>/etc/init.d</code> 目录下，去执行相关程序</p>
<ul>
<li>service 命令启动 redis 脚本</li>
</ul>
<div><pre><code><span>service</span> redis start
</code></pre>
<div><span>1</span><br></div></div><ul>
<li>直接启动 redis 脚本</li>
</ul>
<div><pre><code>/etc/init.d/redis start
</code></pre>
<div><span>1</span><br></div></div><ul>
<li>开机自启动</li>
</ul>
<div><pre><code>update-rc.d redis defaults
</code></pre>
<div><span>1</span><br></div></div><p>其中脚本需要我们自己编写</p>
</li>
<li>
<p>systemctl 命令</p>
<p>systemd 是 Linux 系统最新的初始化系统(init),作用是提高系统的启动速度，尽可能启动较少的进程，尽可能更多进程并发启动。</p>
<p>systemd 对应的进程管理命令是 systemctl</p>
</li>
</ol>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>南辞</name>
    </contributor>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">Linux 命令格式</title>
    <id>http://qiqi.dreamagain.top/software/linux/command/</id>
    <link href="http://qiqi.dreamagain.top/software/linux/command/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<h2 id="目录"> 目录</h2>
<ul>
<li>
<p><a href="./src/software/linux/command/command.html">命令格式简介</a></p>
</li>
<li>
<p><a href="./src/software/linux/command/dir.html">目录相关</a></p>
</li>
<li>
<p><a href="./src/software/linux/command/file.html">文件相关</a></p>
</li>
<li>
<p><a href="./src/software/linux/command/other.html">其他命令</a></p>
</li>
<li>
<p><a href="./src/software/linux/command/add.html">命令的自动补全</a></p>
</li>
<li>
<p><a href="./src/software/linux/command/excu.html">命令的执行</a></p>
</li>
<li>
<p><a href="./src/software/linux/command/path.html">环境变量</a></p>
</li>
<li>
<p><a href="./src/software/linux/command/ln.html">创建链接</a></p>
</li>
</ul>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>南辞</name>
    </contributor>
    <published>2019-11-18T00:00:00.000Z</published>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">目录</title>
    <id>http://qiqi.dreamagain.top/software/linux/file/dir/</id>
    <link href="http://qiqi.dreamagain.top/software/linux/file/dir/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<h2 id="linux-文件目录结构"> Linux 文件目录结构</h2>
<p>学习 Linux，不仅限于学习各种命令，了解整个 Linux 文件系统的目录结构以及各个目录的功能同样至关重要。</p>
<p>使用 Linux 时，通过命令行输入 <code>ls -l /</code> 可以看到，在 Linux 根目录 (/) 下包含很多的子目录(称为一级目录)，例如 <code>bin</code>、<code>boot</code>、<code>dev</code> 等。同时，各一级目录下还含有很多子目录(称为二级目录)，比如 <code>/bin/bash</code>、<code>/bin/ed</code> 等。Linux 文件系统目录总体呈现树形结构，<code>/</code> 根目录就相当于树根。</p>
<p>由于 Linux 系统免费开源，使得 Linux 发行版本有很多，利用 Linux 开发产品的团队也有很多，如果任由每个人都按照自己的想法来配置 Linux 系统文件目录，后期可能会产生诸多的管理问题。试想，如果您进入一家公司，所用 Linux 系统的文件目录结构与所学的完全不同，实在令人头疼。</p>
<p>为了避免诸多使用者对 Linux 系统目录结构天马行空，Linux 基金会发布了 FHS 标准。多数 Linux 发行版系统都遵循这一标准。</p>
<div><p>提示</p>
<p>FHS(Filesystem Hierarchy Standard)，文件系统层次化标准，该标准规定了 Linux 系统中所有一级目录以及部分二级目录(<code>/usr</code> 和 <code>/var</code>)的用途。发布此标准的主要目的就是为了让用户清楚地了解每个目录应该存放什么类型的文件。</p>
</div>
<h2 id="linux-根目录"> Linux 根目录(/)</h2>
<p>FHS 认为，Linux 系统的根目录 (/) 最为重要(没有之一)，其原因有以下 2 点:</p>
<ul>
<li>所有目录都是由根目录衍生出来的；</li>
<li>根目录与系统的开机、修复、还原密切相关；</li>
</ul>
<p>因此，根目录必须包含开机软件、核心文件、开机所需程序、函数库、修复系统程序等文件。</p>
<table>
<thead>
<tr>
<th>一级目录</th>
<th>功能(作用)</th>
</tr>
</thead>
<tbody>
<tr>
<td>/bin/</td>
<td>存放系统命令，普通用户和 root 都可以执行。放在 <code>/bin</code> 下的命令在单用户模式下也可以执行</td>
</tr>
<tr>
<td>/boot/</td>
<td>系统启动目录，保存与系统启动相关的文件，如内核文件和启动引导程序(grub)文件等</td>
</tr>
<tr>
<td>/dev/</td>
<td>设备文件保存位置</td>
</tr>
<tr>
<td>/etc/</td>
<td>配置文件保存位置。系统内所有采用默认安装方式(rpm 安装)的服务配置文件全部保存在此目录中，如用户信息、服务的启动脚本、常用服务的配置文件等</td>
</tr>
<tr>
<td>/home/</td>
<td>普通用户的主目录(也称为家目录)。在创建用户时，每个用户要有一个默认登录和保存自己数据的位置，就是用户的主目录，所有普通用户的主目录是在 <code>/home/</code> 下建立一个和用户名相同的目录。如用户 liming 的主目录就是 <code>/home/liming</code></td>
</tr>
<tr>
<td>/lib/</td>
<td>系统调用的函数库保存位置</td>
</tr>
<tr>
<td>/media/</td>
<td>挂载目录。系统建议用来挂载媒体设备，如软盘和光盘</td>
</tr>
<tr>
<td>/mnt/</td>
<td>挂载目录。早期 Linux 中只有这一个挂载目录，并没有细分。系统建议这个目录用来挂载额外的设备，如 U 盘、移动硬盘和其他操作系统的分区</td>
</tr>
<tr>
<td>/misc/</td>
<td>挂载目录。系统建议用来挂载 NFS 服务的共享目录。虽然系统准备了三个默认挂载目录 <code>/media/</code>、<code>/mnt/</code>、<code>/misc/</code>，但是到底在哪个目录中挂载什么设备可以由管理员自己决定。例如，笔者在接触 Linux 的时候，默认挂载目录只有 /mnt/，所以养成了在 <code>/mnt/</code> 下建立不同目录挂载不同设备的习惯，如 <code>/mnt/cdrom/</code> 挂载光盘、<code>/mnt/usb/</code> 挂载 U 盘，都是可以的</td>
</tr>
<tr>
<td>/opt/</td>
<td>第三方安装的软件保存位置。这个目录是放置和安装其他软件的位置，手工安装的源码包软件都可以安装到这个目录中。不过笔者还是习惯把软件放到 <code>/usr/local/</code> 目录中，也就是说，<code>/usr/local/</code> 目录也可以用来安装软件</td>
</tr>
<tr>
<td>/root/</td>
<td>root 的主目录。普通用户主目录在 <code>/home/</code> 下，root 主目录直接在“/”下</td>
</tr>
<tr>
<td>/sbin/</td>
<td>保存与系统环境设置相关的命令，只有 root 可以使用这些命令进行系统环境设置，但也有些命令可以允许普通用户查看</td>
</tr>
<tr>
<td>/srv/</td>
<td>服务数据目录。一些系统服务启动之后，可以在这个目录中保存所需要的数据</td>
</tr>
<tr>
<td>/tmp/</td>
<td>临时目录。系统存放临时文件的目录，在该目录下，所有用户都可以访问和写入。建议此目录中不能保存重要数据，最好每次开机都把该目录清空</td>
</tr>
</tbody>
</table>
<p>FHS 针对根目录中包含的子目录仅限于上表，但除此之外，Linux 系统根目录下通常还包含下表中的几个一级目录。</p>
<table>
<thead>
<tr>
<th>一级目录</th>
<th>功能(作用)</th>
</tr>
</thead>
<tbody>
<tr>
<td>/lost+found/</td>
<td>当系统意外崩溃或意外关机时，产生的一些文件碎片会存放在这里。在系统启动的过程中，fsck 工具会检查这里，并修复已经损坏的文件系统。这个目录只在每个分区中出现，例如，<code>/lost+found</code> 就是根分区的备份恢复目录，<code>/boot/lost+found</code> 就是 <code>/boot</code> 分区的备份恢复目录</td>
</tr>
<tr>
<td>/proc/</td>
<td>虚拟文件系统。该目录中的数据并不保存在硬盘上，而是保存到内存中。主要保存系统的内核、进程、外部设备状态和网络状态等。如 <code>/proc/cpuinfo</code> 是保存 CPU 信息的，<code>/proc/devices</code> 是保存设备驱动的列表的，<code>/proc/filesystems</code> 是保存文件系统列表的，<code>/proc/net</code> 是保存网络协议信息的......</td>
</tr>
<tr>
<td>/sys/</td>
<td>虚拟文件系统。和 <code>/proc/</code> 目录相似，该目录中的数据都保存在内存中，主要保存与内核相关的信息</td>
</tr>
</tbody>
</table>
<h2 id="linux-usr-目录"> Linux /usr 目录</h2>
<p>usr(注意不是 user)，全称为 Unix Software Resource，此目录用于存储系统软件资源。FHS 建议所有开发者，应把软件产品的数据合理的放置在 <code>/usr</code> 目录下的各子目录中，而不是为他们的产品创建单独的目录。</p>
<p>Linux 系统中，所有系统默认的软件都存储在 <code>/usr</code> 目录下，<code>/usr</code> 目录类似 Windows 系统中 <code>C:\Windows\</code> + <code>C:\Program files\</code> 两个目录的综合体。</p>
<p>FHS 建议，<code>/usr</code> 目录应具备下表所示的子目录。</p>
<table>
<thead>
<tr>
<th>子目录</th>
<th>功能(作用)</th>
</tr>
</thead>
<tbody>
<tr>
<td>/usr/bin/</td>
<td>存放系统命令，普通用户和超级用户都可以执行。这些命令和系统启动无关，在单用户模式下不能执行</td>
</tr>
<tr>
<td>/usr/sbin/</td>
<td>存放根文件系统不必要的系统管理命令，如多数服务程序，只有 root 可以使用。</td>
</tr>
<tr>
<td>/usr/lib/</td>
<td>应用程序调用的函数库保存位置</td>
</tr>
<tr>
<td>/usr/XllR6/</td>
<td>图形界面系统保存位置</td>
</tr>
<tr>
<td>/usr/local/</td>
<td>手工安装的软件保存位置。我们一般建议源码包软件安装在这个位置</td>
</tr>
<tr>
<td>/usr/share/</td>
<td>应用程序的资源文件保存位置，如帮助文档、说明文档和字体目录</td>
</tr>
<tr>
<td>/usr/src/</td>
<td>源码包保存位置。我们手工下载的源码包和内核源码包都可以保存到这里。不过笔者更习惯把手工下载的源码包保存到 <code>/usr/local/src/</code> 目录中，把内核源码保存到 <code>/usr/src/linux/</code> 目录中</td>
</tr>
<tr>
<td>/usr/include</td>
<td>C/C++ 等编程语言头文件的放置目录</td>
</tr>
</tbody>
</table>
<h2 id="linux-var-目录"> Linux /var 目录</h2>
<p><code>/var</code> 目录用于存储动态数据，例如缓存、日志文件、软件运行过程中产生的文件等。通常，此目录下建议包含如下表所示的这些子目录。</p>
<table>
<thead>
<tr>
<th>/var 子目录</th>
<th>功能(作用)</th>
</tr>
</thead>
<tbody>
<tr>
<td>/var/lib/</td>
<td>程序运行中需要调用或改变的数据保存位置。如 MySQL 的数据库保存在 <code>/var/lib/mysql/</code> 目录中</td>
</tr>
<tr>
<td>/var/log/</td>
<td>登陆文件放置的目录，其中所包含比较重要的文件如 <code>/var/log/messages</code>, <code>/var/log/wtmp</code> 等。</td>
</tr>
<tr>
<td>/var/run/</td>
<td>一些服务和程序运行后，它们的 PID(进程 ID)保存位置</td>
</tr>
<tr>
<td>/var/spool/</td>
<td>里面主要都是一些临时存放，随时会被用户所调用的数据，例如 <code>/var/spool/mail/</code> 存放新收到的邮件，<code>/var/spool/cron/</code> 存放系统定时任务。</td>
</tr>
<tr>
<td>/var/www/</td>
<td>RPM 包安装的 Apache 的网页主目录</td>
</tr>
<tr>
<td>/var/nis 和/var/yp</td>
<td>NIS 服务机制所使用的目录，nis 主要记录所有网络中每一个 client 的连接信息；yp 是 linux 的 nis 服务的日志文件存放的目录</td>
</tr>
<tr>
<td>/var/tmp</td>
<td>一些应用程序在安装或执行时，需要在重启后使用的某些文件，此目录能将该类文件暂时存放起来，完成后再行删除</td>
</tr>
</tbody>
</table>
<p>根据以上各表列举的各目录及作用，如果我们要做一些实验和练习，需要创建一些临时文件，应该保存在哪里呢?</p>
<p>答案是用户的主目录或 <code>/tmp/</code> 临时目录。但是要小心有些目录中不能直接修改和保存数据，比如 <code>/proc/fn/sys/</code> 目录，因为它们是保存在内存中的，如果在这里写入数据，那么您的内存会越来越小，直至死机；<code>/boot/</code> 目录也不能保存额外数据，因为 <code>/boot/</code> 目录会单独分区作为启动分区，如果没有空闲空间，则会导致系统不能正常启动。</p>
<p>总之，Linux 要在合理的目录下进行操作和修改。</p>
<div><p>注意</p>
<p>目录名或文件名都是区分大小写的，如 dog、DOG 和 Dog 为 3 个不同的目录或文件。完整的目录或文件路径是由一连串的目录名所组成的，其中每一个目录由 <code>/</code> 来分隔。如 cat 的完整路径是 <code>/home/cat</code>。</p>
</div>
<h2 id="硬件设备名称"> 硬件设备名称</h2>
<table>
<thead>
<tr>
<th>硬件设备</th>
<th>文件名称</th>
</tr>
</thead>
<tbody>
<tr>
<td>IDE 设备</td>
<td><code>/dev/hd[a-d]</code>，现在的 IDE 设备已经很少见了，因此一般的硬盘设备会以 <code>/dev/sd</code> 开头。</td>
</tr>
<tr>
<td>SCSI/SATA/U 盘</td>
<td><code>/dev/sd[a-p]</code>，一台主机可以有多块硬盘，因此系统采用 a~p 代表 16 块不同的硬盘。</td>
</tr>
<tr>
<td>软驱</td>
<td><code>/dev/fd[0-1]</code></td>
</tr>
<tr>
<td>打印机</td>
<td><code>/dev/lp[0-15]</code></td>
</tr>
<tr>
<td>光驱</td>
<td><code>/dev/cdrom</code></td>
</tr>
<tr>
<td>鼠标</td>
<td><code>/dev/mouse</code></td>
</tr>
<tr>
<td>磁带机</td>
<td><code>/dev/st0</code> 或 <code>/dev/ht0</code></td>
</tr>
</tbody>
</table>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>南辞</name>
    </contributor>
    <published>2019-11-17T00:00:00.000Z</published>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">文件</title>
    <id>http://qiqi.dreamagain.top/software/linux/file/file/</id>
    <link href="http://qiqi.dreamagain.top/software/linux/file/file/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<h2 id="文件系统"> 文件系统</h2>
<p>目录就相当于 Windows 中的文件夹，目录中存放的既可以是文件，也可以是其他的子目录，而文件中存储的是真正的信息。</p>
<p>文件系统的最顶层是由根目录开始的，系统使用“<code>/</code>”来表示根目录，在根目录之下的既可以是目录，也可以是文件，而每一个目录中又可以包含(子)目录或文件。如此反复就可以构成一个庞大的文件系统。
其实，使用这种树状、具有层次的文件结构主要目的是方便文件系统的管理和维护，想象一下，如果所有的文件都放在一个目录下，其文件系统的管理和维护将变成一场噩梦。</p>
<p>现实中也有许多类似的例子，例如在整个行政管理体制中，村民就相当于文件，他们住在一个村庄中，村庄就是存储村民的目录。许多村又组成了个乡，这个乡就相当于存储村的目录，依此类推，最终就构建出了一个庞大的行政区域管理结构图。</p>
<p>注意，目录名或文件名都是区分大小写的，如 dog、DOG 和 Dog 为 3 个不同的目录或文件。完整的目录或文件路径是由一连串的目录名所组成的，其中每一个目录由“/”来分隔。如 cat 的完整路径是 <code>/home/cat</code>。</p>
<p>在文件系统中，有两个特殊的目录，一个是用户所在的工作目录，即当前目录，可用一个点“<code>.</code>”表示；另一个是当前目录的上一层目录，也叫父目录，用两个点“<code>..</code>”表示。</p>
<p>如果一个目录或文件名是以一个点开始，就表示这个目录或文件是一个隐藏目录或文件。即以默认方式査找(后续会讲查找命令)时，不显示该目录或文件。</p>
<p>为了方便管理和维护，Linux 系统采用了文件系统层次标准，也称为 FHS 标准，它规定了根目录下各个目录应该存在哪些类型的文件(或子目录)，比如说，在 <code>/bin</code> 和 <code>/sbin</code> 目录中存放的应该是可执行文件，有关各个目录存放文件的类型，已在《Linux 文件目录结构一览表》一节中作了详解介绍，这里不再过多赘述。</p>
<h2 id="文件"> 文件</h2>
<p>虽然从名称上不容易分辨，但是可以从颜色上进行区分。一般情况下，Linux 用蓝色代表目录，其他颜色则表示是文件。</p>
<p>和 Linux 不同，Windows 下带有 <code>&lt;DIR&gt;</code> 标记的行或使用中括号 <code>[]</code> 括起来的名称就是目录，其他的则是文件。</p>
<p>不仅如此，Linux 中还可以用不同的颜色来区分不同种类的文件，例如绿色代表可执行文件、红色代表压缩文件、浅绿色代表链接文件、白色代表其他文件、黄色代表设备文件等。</p>
<p>但是，不同颜色所代表的文件类型不一定是这样，更准确的对应方式还取决于配置文件 <code>/etc/DIR_COLORS</code> 中的规定。因此，如果想详细了解不同文件类型所对应的颜色，可以使用 <code>man</code> 命令，例如:</p>
<div><pre><code><span>[root@localhost ~]# man dir_colors
</span></code></pre>
<div><span>1</span><br></div></div><p>注意，有些 Linux 发行版单独使用 <code>ls</code> 命令，无法显示出带有不同颜色的文件和目录，此时就需要使用 <code>ls --color=auto</code> 命令，明确令其使用颜色来区分文件类型。</p>
<p>在此基础上，如果不想每次使用 <code>ls</code> 命令时，都显式附带 <code>--color=auto</code>，可以执行如下命令:</p>
<div><pre><code><span>[root@localhost ~]# alias ls = 'ls --color=auto'
</span></code></pre>
<div><span>1</span><br></div></div><p>通过给 <code>ls --color==auto</code> 这个整体设置一个别名 <code>ls</code>，这样当后续使用 <code>ls</code> 命令时，就等同于执行 <code>ls --color=auto</code> 命令。</p>
<p>同时，如果想使这个设置永远生效，还需要将其添加到 <code>/etc/bashrc</code> 或 <code>/home/&lt;user&gt;/.bashrc</code> 文件中，前者对所有用户有效，而后者仅对用户 <code>&lt;user&gt;</code> 有效。</p>
<p>其实，那些默认提供颜色功能的 Linux 发行版，也是通过这个方法开启的功能。</p>
<p>当然，通过颜色来区分文件类型，难免有些牵强，对于颜色不太敏感的读者来说，很容易搞错。Linux 中精确判断文件类型的方法，是通过文件本身所具有的属性进行判断。</p>
<p>通过 <code>ls -l</code> 命令，我们就可以查看当前目录下所有文件和目录各自的属性</p>
<h2 id="命名规则"> 命名规则</h2>
<ul>
<li>除了字符“/”之外，所有的字符都可以使用，但是要注意，在目录名或文件名中，使用某些特殊字符并不是明智之举。例如，在命名时应避免使用 <code>&lt;</code>、<code>&gt;</code>、<code>?</code>、<code>*</code> 和非打印字符等。如果一个文件名中包含了特殊字符，例如空格，那么在访问这个文件时就需要使用引号将文件名括起来。</li>
<li>目录名或文件名的长度不能超过 255 个字符。</li>
<li>目录名或文件名是区分大小写的。如 DOG、dog、Dog 和 DOg ，是互不相同的目录名或文件名，但使用字符大小写来区分不同的文件或目录，也是不明智的。</li>
</ul>
<h2 id="不同字符对应的文件类型"> 不同字符对应的文件类型</h2>
<table>
<thead>
<tr>
<th>第一个字符</th>
<th>文件类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>-</td>
<td>普通文件，包括纯文本文件、二进制文件、各种压缩文件等。</td>
</tr>
<tr>
<td>d</td>
<td>目录，类似 Windows 系统中的文件夹。</td>
</tr>
<tr>
<td>b</td>
<td>块设备文件，就是保存大块数据的设备，比如最常见的硬盘。</td>
</tr>
<tr>
<td>c</td>
<td>字符设备文件，例如键盘、鼠标等。</td>
</tr>
<tr>
<td>s</td>
<td>套接字文件，通常用在网络数据连接，可以启动一个程序开监听用户的要求，用户可以通过套接字进行数据通信。</td>
</tr>
<tr>
<td>p</td>
<td>管道文件，其主要作用是解决多个程序同时存取一个文件所造成的错误。</td>
</tr>
<tr>
<td>l</td>
<td>链接文件，类似 Windows 系统中的快捷方式。</td>
</tr>
</tbody>
</table>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>南辞</name>
    </contributor>
    <published>2019-11-17T00:00:00.000Z</published>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">Linux 挂载</title>
    <id>http://qiqi.dreamagain.top/software/linux/file/mount/</id>
    <link href="http://qiqi.dreamagain.top/software/linux/file/mount/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<h1 id="linux-挂载"> Linux 挂载</h1>
<p>前面讲过，Linux 系统中“一切皆文件”，所有文件都放置在以根目录为树根的树形目录结构中。在 Linux 看来，任何硬件设备也都是文件，它们各有自己的一套文件系统(文件目录结构)。</p>
<p>因此产生的问题是，当在 Linux 系统中使用这些硬件设备时，只有将 Linux 本身的文件目录与硬件设备的文件目录合二为一，硬件设备才能为我们所用。合二为一的过程称为“挂载”。</p>
<p>如果不挂载，通过 Linux 系统中的图形界面系统可以查看找到硬件设备，但命令行方式无法找到。</p>
<p>挂载，指的就是将设备文件中的顶级目录连接到 Linux 根目录下的某一目录(最好是空目录)，访问此目录就等同于访问设备文件。</p>
<p>纠正一个误区，并不是根目录下任何一个目录都可以作为挂载点，由于挂载操作会使得原有目录中文件被隐藏，因此根目录以及系统原有目录都不要作为挂载点，会造成系统异常甚至崩溃，挂载点最好是新建的空目录。</p>
<p>举个例子，我们想通过命令行访问某个 U 盘中的数据，我们要在根目录下新建一个目录 <code>/sdb-u</code>，通过挂载命令将 U 盘文件系统挂载到此目录，</p>
<p>前面讲过，根目录下的 <code>/dev/</code> 目录文件负责所有的硬件设备文件，事实上，当 U 盘插入 Linux 后，系统也确实会给 U 盘分配一个目录文件(比如 sdb1)，就位于 <code>/dev/</code> 目录下 (<code>/dev/sdb1</code>)，但无法通过 <code>/dev/sdb1/</code> 直接访问 U 盘数据，访问此目录只会提供给您此设备的一些基本信息(比如容量)。</p>
<p>总之，Linux 系统使用任何硬件设备，都必须将设备文件与已有目录文件进行挂载。</p>
<h2 id="linux-硬件设备文件名称"> Linux 硬件设备文件名称</h2>
<table>
<thead>
<tr>
<th>硬件设备</th>
<th>文件名称</th>
</tr>
</thead>
<tbody>
<tr>
<td>IDE 设备</td>
<td><code>/dev/hd\[a-d]</code>，现在的 IDE 设备已经很少见了，因此一般的硬盘设备会以 <code>/dev/sd</code> 开头。</td>
</tr>
<tr>
<td>SCSI / SATA / U 盘</td>
<td><code>/dev/sd\[a-p]</code>，一台主机可以有多块硬盘，因此系统采用 a~p 代表 16 块不同的硬盘。</td>
</tr>
<tr>
<td>软驱</td>
<td><code>/dev/fd\[0-1]</code></td>
</tr>
<tr>
<td>打印机</td>
<td><code>/dev/lp\[0-15]</code></td>
</tr>
<tr>
<td>光驱</td>
<td><code>/dev/cdrom</code></td>
</tr>
<tr>
<td>鼠标</td>
<td><code>/dev/mouse</code></td>
</tr>
<tr>
<td>磁带机</td>
<td><code>/dev/st0</code> 或 <code>/dev/ht0</code></td>
</tr>
</tbody>
</table>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>南辞</name>
    </contributor>
    <published>2019-11-17T00:00:00.000Z</published>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">文件</title>
    <id>http://qiqi.dreamagain.top/software/linux/file/</id>
    <link href="http://qiqi.dreamagain.top/software/linux/file/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<h2 id="目录"> 目录</h2>
<ul>
<li>
<p><a href="./src/software/linux/file/file.html">Linux 文件</a></p>
</li>
<li>
<p><a href="./src/software/linux/file/dir.html">Linux 目录</a></p>
</li>
<li>
<p><a href="./src/software/linux/file/mount.html">挂载</a></p>
</li>
</ul>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>南辞</name>
    </contributor>
    <published>2019-11-17T00:00:00.000Z</published>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">Linux 的优点</title>
    <id>http://qiqi.dreamagain.top/software/linux/intro/advantage/</id>
    <link href="http://qiqi.dreamagain.top/software/linux/intro/advantage/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<h1 id="linux-的优点"> Linux 的优点</h1>
<p>相比 Windows 系统，Linux 系统有更好的稳定性。此外，Linux 还有如下优点:</p>
<ol>
<li>
<p>大量的可用软件及免费软件</p>
<p>Linux 系统上有着大量的可用软件，且绝大多数是免费的，比如声名赫赫的 Apache、Samba、PHP、MySQL 等，构建成本低廉，是 Linux 被众多企业青睐的原因之一。当然，这和 Linux 出色的性能是分不开的，否则，节约成本就没有任何意义。</p>
<p>但不可否认的是，Linux 在办公应用和游戏娱乐方面的软件相比 Windows 系统还很匮乏，所以，即便打游戏、看影片用的也是 Windows，至于 Linux，就把它用在擅长的服务器领域吧。</p>
</li>
<li>
<p>良好的可移植性及灵活注
Linux 系统有良好的可移植性，它几乎支持所有的 CPU 平台，这使得它便于裁剪和定制。我们可以把 Linux 放在 U 盘、光盘等存储介质中，也可以在嵌入式领域广泛应用。</p>
<p>如果读者希望不进行安装就体验 Linux 系统，则可以在网上下载一个 Live DVD 版的 Linux 镜像，刻成光盘放入光驱或者用虚拟机软件直接载入镜像文件，设置 CMOS/BIOS 为光盘启动，系统就会自动载入光盘文件，启动进入 Linux 系统。</p>
</li>
<li>
<p>优良的稳定性和安全性</p>
<p>著名的黑客埃里克•雷蒙德(EricS.Raymond)有一句名言: “足够多的眼睛，就可让所有问题浮现”。举个例子，假如笔者在演讲，台下人山人海，明哥中午吃饭不小心，有几个饭粒粘在衣领上了，分分钟就会被大家发现，因为看的人太多了；如果台下就稀稀落落两三个人且离得很远，那就算明哥衣领上有一大块油渍也不会被发现。</p>
<p>Linux 开放源代码，将所有代码放在网上，全世界的程序员都看得到，有什么缺陷和漏洞，很快就会被发现，从而成就了它的稳定性和安全注。</p>
</li>
<li>
<p>支持几乎所有的网络协议及开发语言</p>
<p>经常有初学的朋友问我，Linux 是不是对 TCP/IP 协议支持不好、是不是 Java 开发环境不灵之类的问题。前面在 UNIX 发展史中已经介绍了，UNIX 系统是与 C 语言、TCP/IP 协议一同发展起来的，而 Linux 是 UNIX 的一种，C 语言又衍生出了现今主流的语言 PHP、Java、C++ 等，而哪一个网络协议与 TCP/IP 无关呢? 所以，Linux 对网络协议和开发语言的支持很好。</p>
</li>
</ol>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>南辞</name>
    </contributor>
    <published>2019-11-16T00:00:00.000Z</published>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">桌面系统</title>
    <id>http://qiqi.dreamagain.top/software/linux/intro/desktop/</id>
    <link href="http://qiqi.dreamagain.top/software/linux/intro/desktop/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<h1 id="桌面系统"> 桌面系统</h1>
<h2 id="kde-桌面系统"> KDE 桌面系统</h2>
<p>KDE 是 K Desktop Environment 的缩写，中文译为“K 桌面环境”。</p>
<p>KDE 是基于大名鼎鼎的 Qt 的，最初于 1996 年作为开源项目公布，并在 1998 年发布了第一个版本，现在 KDE 几乎是排名第一的桌面环境了。</p>
<p>许多流行的 Linux 发行版都提供了 KDE 桌面环境，比如 Ubuntu、Linux Mint、OpenSUSE、Fedora、Kubuntu、PC Linux OS 等。</p>
<p>KDE 和 Windows 比较类似，各位初学者相信都是 Windows 的用户，所以切换到 KDE 也不会有太大的障碍。</p>
<p>KDE 允许您把应用程序图标和文件图标放置在桌面的特定位置上。单击应用程序图标，Linux 系统就会运行该应用程序。单击文件图标，KDE 桌面就会确定使用哪种应用程序来处理该文件。</p>
<p>KDE 是所有桌面环境中最容易定制的。在其他桌面环境中，您需要几个插件、窗口组件和调整工具才可以定制环境，KDE 将所有工具和窗口组件都塞入到系统设置中。借助先进的设置管理器，可以控制一切，不需要任何第三方工具，就可以根据用户的喜好和要求来美化及调整桌面。</p>
<p>KDE 项目组还还发了大量的可运行在 KDE 环境中的应用程序，包括 Dolphin(文件管理工具)、Konsole(终端)、Kate(文本编辑工具)、Gwenview(图片查看工具)、Okular(文档及 PDF 查看工具)、Digikam(照片编辑和整理工具)、KMail(电子邮件客户软件)、Quassel(IRC 客户软件)、K3b(DVD 刻录程序)、Krunner(启动器)等，它们都是默认安装的。</p>
<p>对 KDE 优缺点的总结:</p>
<ul>
<li>优点: KDE 几乎是最先进最强大的桌面环境，它外观优美、高度可定制、兼容比较旧的硬件设备</li>
<li>缺点: Kmail 等一些组件的配置对新手来说过于复杂。</li>
</ul>
<h2 id="gnome-桌面环境"> GNOME 桌面环境</h2>
<p>GNOME 是 the GNU Network Object Model Environment 的缩写，中文译为“GNU 网络对象模型环境”。</p>
<p>GNOME 于 1999 年首次发布，现已成为许多 Linux 发行版默认的桌面环境(不过用得最多的是 Red Hat Linux)。</p>
<p>GNOME 的特点是简洁、运行速度快，但是没有太多的定制选项，用户需要安装第三方工具来实现。</p>
<p>GNOME 甚至不包括一些简单的调整选项，比如更改主题、更改字体等，就这两种基本的调整而言，用户都需要安装第三方工具。所以，GONME 适合那些不需要高度定制界面的用户。</p>
<p>GNOME 被用作 Fedora 中的默认桌面环境，提供在几款流行的 Linux 发行版中，比如 Ubuntu、Debian、OpenSUSE 等。</p>
<p>2011 年，GNOME 3 进行了重大更新，不再采用传统的 Windows 风格的界面，而是进行了全新的设计，惊艳了很多用户。GNOME 3 的这种行为也导致部分用户和开发人员不满，他们又开发了多款其他的桌面环境，比如 MATE 和 Cinnamon。</p>
<p>对 GNOME 优缺点的总结:</p>
<ul>
<li>优点: 简单易用，可通过插件来扩展功能。</li>
<li>缺点: 对插件的管理能力比较差，也缺少其它桌面环境拥有的许多功能。</li>
</ul>
<h2 id="unity"> Unity</h2>
<p>Unity 是由 Ubuntu 的母公司 Canonical 开发的一款外壳。之所以说它是外壳，是因为 Unity 运行在 GNOME 桌面环境之上，使用了所有 GNOME 的核心应用程序。</p>
<p>2010 年，Unity 第一个版本发布，此后经过数次改进，如今和其它的桌面环境一样，也可以安装到其它的 Linux 发行版上了。</p>
<p>Unity 使用了不同的界面风格，如果您用的是 Ubuntu Linux 发行版，您会注意到 Unity 与 KDE 和 GNOME 桌面环境有些不一样。</p>
<p>Unity 在左边有一个启动器，位于启动器顶部的是搜索图标，又叫“Dash”。在 Dash 上搜索文件时，不仅会给出来自硬盘的搜索结果，还会给出来自在线来源的搜索结果，比如 Google Drive、Facebook、Picasa、Flick 及其他。</p>
<p>Unity 还提供了隐藏启动器、触摸侧边栏就显示的选项，用户还可以调高/调低显示启动器菜单的灵敏度。</p>
<p>Unity 很简单、运行速度快，但 Unity 在系统设置下却没有定制桌面的太多选项，要想安装主题或者定制另外不同的选项，比如系统菜单是否应该总是可见，或者“从启动器图标一次点击最小化”，用户需要安装第三方工具。</p>
<p>CCSM 和 Unity Tweak Tool 是面向 Unity 桌面环境的非常流行的定制工具。</p>
<p>对 Unity 优缺点的总结:</p>
<ul>
<li>优点: 界面简洁直观，可以通过第三方工具来深度定制，而且使用了平视显示器(HUD)等新技术。</li>
<li>缺点: 默认的定制功能比较差劲，通知机制一般。</li>
</ul>
<h2 id="mate"> MATE</h2>
<p>上面我们提到，GNOME 3 进行了全新的界面设计，这招致一些用户的不满，他们推出了其它的桌面环境，MATE 就是其中之一。</p>
<p>MATE 是一种从现在无人维护的 GNOME 2 代码库派生出来的桌面环境。</p>
<p>MATE 让人觉得在使用旧的桌面环境，但是结合了历年来界面方面的诸多改进。MATE 还非常适用于低配计算机，所以如果您有一台旧的或速度较慢的计算机，可以使用 MATE。</p>
<p>MATE 还是许多流行的 Linux 发行版随带的，比如 Ubuntu、Linux Mint、Mageia、Debian 及另外更多发行版。Ubuntu MATE 头一回是官方版本。</p>
<p>“欢迎首次发布的 Ubuntu MATE 官方版本。现在，用户将更容易更新软件，因为所有组件现在都在 Ubuntu 软件库中。”</p>
<p>MATE 自带的应用程序包括 Caja(文件管理工具)、Pluma(文本编辑工具)、Atril(文档查看工具)、Eye of MATE(图像查看工具)等，如果用户不需要其他功能完备的桌面环境的所有额外功能，那么 MATE 对他们来说是一款简单的轻量级桌面环境。</p>
<p>对 META 优缺点的总结:</p>
<ul>
<li>优点: 轻量级的桌面环境，能够兼容教旧的硬件设备。</li>
<li>缺点: 我也不知道有什么明显的缺点，欢迎读者留言告知。</li>
</ul>
<h2 id="cinnamon"> Cinnamon</h2>
<p>与 MATE 类似，Cinnamon 是由 Linux Mint 团队因为不满 Gnome 3 的改进而开发的另一种桌面环境。但 Cinnamon 与 MATE 不同之处在于，Cinnamon 建立在 Gnome 3 的基础上。Cinnamon 是新的，而且在积极开发之中，但这款出色的桌面环境没有因新颖而在功能方面有所减弱。</p>
<p>Cinnamon 拥有 GNOME 和 Unity 等其它桌面环境所没有的种种功能。Cinnamon 是高度可定制的桌面环境，不需要任何外部插件、窗口组件和调整工具来定制桌面。Cinnamon 甚至可以通过设置管理器本身来下载并安装主题，甚至不需要打开互联网浏览器。</p>
<p>由于种种出色的所需功能，Cinnamon 对任何刚接触 Linux 的新用户来说都非常方便。许多用户放弃使用 Linux，是因为他们并不了解 Linux 的工作方式，但是我强烈建议新手应从 Cinnamon 桌面环境开始入手。</p>
<p>许多流行的 Linux 发行版提供了各自版本的 Cinnamon，比如 Ubuntu、Fedora、OpenSUSE、Gentoo、Arch Linux 等。Cinnamon 还是 Linux Mint 的默认桌面环境。</p>
<p>对 Cinnamon 优缺点的总结:</p>
<ul>
<li>优点: 成熟完美，高度可性质，适合 Linux 新手。</li>
<li>缺点: 有时候可能会有软件错误。</li>
</ul>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>南辞</name>
    </contributor>
    <published>2019-11-16T00:00:00.000Z</published>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">Linux 和 UNIX</title>
    <id>http://qiqi.dreamagain.top/software/linux/intro/history/</id>
    <link href="http://qiqi.dreamagain.top/software/linux/intro/history/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<h1 id="linux-和-unix"> Linux 和 UNIX</h1>
<p>UNIX 与 Linux 之间的关系是一个很有意思的话题。在目前主流的服务器端操作系统中，UNIX 诞生于 20 世纪 60 年代末，Windows 诞生于 20 世纪 80 年代中期，Linux 诞生于 20 世纪 90 年代初，可以说 UNIX 是操作系统中的&quot;老大哥&quot;，后来的 Windows 和 Linux 都参考了 UNIX。</p>
<div><p>提示</p>
<p>现代的 Windows 系统已经朝着“图形界面”的方向发展了，和 UNIX 系统有了巨大的差异，从表面上甚至看不出两者的关联。</p>
</div>
<h2 id="unix-的坎坷历史"> UNIX 的坎坷历史</h2>
<p>UNIX 操作系统由肯·汤普森(Ken Thompson)和丹尼斯·里奇(Dennis Ritchie)发明。它的部分技术来源可追溯到从 1965 年开始的 Multics 工程计划，该计划由贝尔实验室、美国麻省理工学院和通用电气公司联合发起，目标是开发一种交互式的、具有多道程序处理能力的分时操作系统，以取代当时广泛使用的批处理操作系统。</p>
<div><p>提示</p>
<p>分时操作系统使一台计算机可以同时为多个用户服务，连接计算机的终端用户交互式发出命令，操作系统采用时间片轮转的方式处理用户的服务请求并在终端上显示结果(操作系统将 CPU 的时间划分成若干个片段，称为时间片)。操作系统以时间片为单位，轮流为每个终端用户服务，每次服务一个时间片。</p>
</div>
<p>可惜，由于 Multics 工程计划所追求的目标太庞大、太复杂，以至于它的开发人员都不知道要做成什么样子，最终以失败收场。</p>
<p>以肯•汤普森为首的贝尔实验室研究人员吸取了 Multics 工程计划失败的经验教训，于 1969 年实现了一种分时操作系统的雏形，1970 年该系统正式取名为 UNIX。</p>
<p>想一下英文中的前缀 Multi 和 Uni，就明白了 UNIX 的隐意。Multi 是大的意思，大而且繁；而 Uni 是小的意思，小而且巧。这是 UNIX 开发者的设计初衷，这个理念一直影响至今。</p>
<p>有意思的是，肯•汤普森当年开发 UNIX 的初衷是运行他编写的一款计算机游戏 Space Travel，这款游戏模拟太阳系天体运动，由玩家驾驶飞船，观赏景色并尝试在各种行星和月亮上登陆。他先后在多个系统上试验，但运行效果不甚理想，于是决定自己开发操作系统，就这样，UNIX 诞生了。</p>
<p>自 1970 年后，UNIX 系统在贝尔实验室内部的程序员之间逐渐流行起来。1971-1972 年，肯•汤普森的同事丹尼斯•里奇发明了传说中的 C 语言，这是一种适合编写系统软件的高级语言，它的诞生是 UNIX 系统发展过程中的一个重要里程碑，它宣告了在操作系统的开发中，汇编语言不再是主宰。</p>
<p>到了 1973 年，UNIX 系统的绝大部分源代码都用 C 语言进行了重写，这为提高 UNIX 系统的可移植性打下了基础(之前操作系统多采用汇编语言，对硬件依赖性强)，也为提高系统软件的开发效率创造了条件。可以说，UNIX 系统与 C 语言是一对孪生兄弟，具有密不可分的关系。</p>
<p>20 世纪 70 年代初，计算机界还有一项伟大的发明——TCP/IP 协议，这是当年美国国防部接手 ARPAnet 后所开发的网络协议。美国国防部把 TCP/IP 协议与 UNIX 系统、C 语言捆绑在一起，由 AT&amp;T 发行给美国各个大学非商业的许可证，这为 UNIX 系统、C 语言、TCP/IP 协议的发展拉开了序幕，它们分别在操作系统、编程语言、网络协议这三个领域影响至今。肯•汤普森和丹尼斯•里奇因在计算机领域做出的杰出贡献，于 1983 年获得了计算机科学的最高奖——图灵奖。</p>
<p>随后出现了各种版本的 UNIX 系统，目前常见的有 Sun Solaris、FreeBSD、IBM AIX、HP-UX 等。</p>
<h2 id="solaris-和-freebsd"> Solaris 和 FreeBSD</h2>
<p>我们重点介绍一下 Solaris，它是 UNIX 系统的一个重要分支。Solaris 除可以运行在 SPARC CPU 平台上外，还可以运行在 x86 CPU 平台上。在服务器市场上，Sun 的硬件平台具有高可用性和高可靠性，是市场上处于支配地位的 UNIX 系统。</p>
<p>对于难以接触到 Sun SPARC 架构计算机的用户来说，可以通过使用 Solaris x86 来体验世界知名大厂的商业 UNIX 风采。当然，Solaris x86 也可以用于实际生产应用的服务器，在遵守 Sun 的有关许可条款的情况下，Solaris x86 可以免费用于学习研究或商业应用。</p>
<p>FreeBSD 源于美国加利福尼亚大学伯克利分校开发的 UNIX 版本，它由来自世界各地的志愿者开发和维护，为不同架构的计算机系统提供了不同程度的支持。FreeBSD 在 BSD 许可协议下发布，允许任何人在保留版权和许可协议信息的前提下随意使用和发行，并不限制将 FreeBSD 的代码在另一协议下发行，因此商业公司可以自由地将 FreeBSD 代码融入它们的产品中。苹果公司的 macOS 就是基于 FreeBSD 的操作系统。</p>
<p>FreeBSD 与 Linux 的用户群有相当一部分是重合的，二者支持的硬件环境也比较一致，所采用的软件也比较类似。FreeBSD 的最大特点就是稳定和高效，是作为服务器操作系统的不错选择；但其对硬件的支持没有 Linux 完备，所以并不适合作为桌面系统。</p>
<p>其他 UNIX 版本因应用范围相对有限，在此不做过多介绍。</p>
<h2 id="linux-的那些往事"> Linux 的那些往事</h2>
<p>Linux 内核最初是由李纳斯•托瓦兹(Linus Torvalds)在赫尔辛基大学读书时出于个人爱好而编写的，当时他觉得教学用的迷您版 UNIX 操作系统 Minix 太难用了，于是决定自己开发一个操作系统。第 1 版本于 1991 年 9 月发布，当时仅有 10 000 行代码。</p>
<p>李纳斯•托瓦兹没有保留 Linux 源代码的版权，公开了代码，并邀请他人一起完善 Linux。与 Windows 及其他有专利权的操作系统不同，Linux 开放源代码，任何人都可以免费使用它。</p>
<p>据估计，现在只有 2% 的 Linux 核心代码是由李纳斯•托瓦兹自己编写的，虽然他仍然拥有 Linux 内核(操作系统的核心部分)，并且保留了选择新代码和需要合并的新方法的最终裁定权。现在大家所使用的 Linux，我更倾向于说是由李纳斯•托瓦兹和后来陆续加入的众多 Linux 好者共同开发完成的。</p>
<p>李纳斯•托瓦兹无疑是这个世界上最伟大的程序员之一，何况，他还搞出了全世界最大的程序员交友社区 GitHub (开源代码库及版本控制系统)。</p>
<p>关于 Linux Logo 的由来是一个很有意思的话题，它是一只企鹅。企鹅是南极洲的标志性动物，根据国际公约，南极洲为全人类共同所有，不属于世界上的任何国家，任何国家都无权将南极洲纳入其版图。Linux 选择企鹅图案作为 Logo，其含义是: 开放源代码的 Linux 为全人类共同所有，任何公司无权将其私有。</p>
<h2 id="unix-与-linux-的关系"> UNIX 与 Linux 的关系</h2>
<p>二者的关系，不是大哥和小弟，&quot;UNIX 是 Linux 的父亲&quot;这个说法更怡当。之所以要介绍它们的关系，是因为要告诉读者，在学习的时候，其实 Linux 与 UNIX 有很多的共通之处，简单地说，如果您已经熟练掌握了 Linux，那么再上手使用 UNIX 会非常容易。</p>
<p>二者也有两个大的区别:</p>
<ul>
<li>
<p>UNIX 系统大多是与硬件配套的，也就是说，大多数 UNIX 系统如 AIX、HP-UX 等是无法安装在 x86 服务器和个人计算机上的，而 Linux 则可以运行在多种硬件平台上；</p>
</li>
<li>
<p>UNIX 是商业软件，而 Linux 是开源软件，是免费、公开源代码的。</p>
</li>
</ul>
<p>Linux 受至旷大计算机爱好者的喜爱，主要原因也有两个:</p>
<ul>
<li>
<p>它属于开源软件，用户不用支付可费用就可以获得它和它的源代码，并且可以根据自己的需要对它进行必要的修改，无偿使用，无约束地继续传播；</p>
</li>
<li>
<p>它具有 UNIX 的全部功能，任何使用 UNIX 操作系统或想要学习 UNIX 操作系统的人都可以从 Linux 中获益。</p>
</li>
</ul>
<p>开源软件是不同于商业软件的一种模式，从字面上理解，就是开放源代码，大家不用担心里面会搞什么猫腻，这会带来软件的革新和安全。</p>
<p>另外，开源其实并不等同于免费，而是一种新的软件盈利模式。目前很多软件都是开源软件，对计算机行业与互联网影响深远。</p>
<p>近年来，Linux 已经青出于蓝而胜于蓝，以超常的速度发展，从一个丑小鸭变成了一个拥有庞大用户群的真正优秀的、值得信赖的操作系统。历史的车轮让 Linux 成为 UNIX 最优秀的传承者。</p>
<div><p>总结</p>
<p>Linux 是一个类似 Unix 的操作系统，Unix 要早于 Linux，Linux 的初衷就是要替代 UNIX，并在功能和用户体验上进行优化，所以 Linux 模仿了 UNIX(但并没有抄袭 UNIX 的源码)，使得 Linux 在外观和交互上与 UNIX 非常类似。</p>
</div>
<p>相比于 UNIX，Linux 最大的创新是开源免费，这是它能够蓬勃发展的最重要原因；而目前的 UNIX 大部分都是收费的，小公司和个人都难以承受。</p>
<p>正是由于 Linux 和 UNIX 有着千丝万缕的联系，所以人们把 Linux 叫做“类 UNIX 系统”。</p>
<h2 id="unix-linux-系统结构"> UNIX/Linux 系统结构</h2>
<p>UNIX/Linux 系统可以粗糙地抽象为 3 个层次(所谓粗糙，就是不够细致、精准，但是便于初学者抓住重点理解)，如图 3 所示。底层是 UNIX/Linux 操作系统，即系统内核(Kernel)；中间层是 Shell 层，即命令解释层；高层则是应用层。</p>
<p><img src="src/software/linux/assets/structure.jpg" alt="Structrure"></p>
<ol>
<li>
<p>内核层</p>
<p>内核层是 UNIX/Linux 系统的核心和基础，它直接附着在硬件平台之上，控制和管理系统内各种资源(硬件资源和软件资源)，有效地组织进程的运行，从而扩展硬件的功能，提高资源的利用效率，为用户提供方便、高效、安全、可靠的应用环境。</p>
</li>
<li>
<p>Shell 层</p>
<p>Shell 层是与用户直接交互的界面。用户可以在提示符下输入命令行，由 Shell 解释执行并输出相应结果或者有关信息，所以我们也把 Shell 称作命令解释器，利用系统提供的丰富命令可以快捷而简便地完成许多工作。</p>
</li>
<li>
<p>应用层</p>
<p>应用层提供基于 X Window 协议的图形环境。X Window 协议定义了一个系统所必须具备的功能(就如同 TCP/IP 是一个协议，定义软件所应具备的功能)，可系统能满足此协议及符合 X 协会其他的规范，便可称为 X Window。</p>
</li>
</ol>
<p>现在大多数的 UNIX 系统上(包括 Solaris、HP-UX、AIX 等)都可以运行 CDE (Common Desktop Environment，通用桌面环境，是运行于 UNIX 的商业桌面环境) 的用户界面；而在 Linux 上广泛应用的有 Gnome、KDE 等。</p>
<h2 id="协议"> 协议</h2>
<p>早在 20 世纪 70 年代，UNIX 系统是开源而且免费的，但是在 1979 年时，AT&amp;T 公司宣布了对 UNIX 系统的商业化计划，随之开源软件业转变成了版权式软件产业，源代码被当作商业机密，成为专利产品，人们再也不能自由地享受科技成果。</p>
<p>于是在 1984 年，Richard Stallman 面对于如此封闭的软件创作环境，发起了 GNU 源代码开放计划并制定了著名的 GPL 许可协议。</p>
<p>1987 年时，GNU 计划获得了一项重大突破，即发布了 gcc 编译器，这使得程序员可以基于该编译器编写出属于自己的开源软件。随之，在 1991 年 10 月，芬兰赫尔辛基大学的在校生 Linus Torvalds 编写了一款名为 Linux 的操作系统，该系统因其较高的代码质量且基于 GNU GPL 许可协议的开放源代码特性，迅速得到了 GNU 计划和一大批黑客程序员的支持，随后 Linux 系统便进入了如火如荼的发展阶段。</p>
<p>1994 年 1 月，Bob Young(红帽创始人)在 Linux 系统内核的基础之上，集成了众多的源代码和程序软件，发布了红帽系统并开始出售技术服务，这进一步推动了 Linux 系统的普及。</p>
<p>1998 年以后，随着 GNU 源代码开放计划和 Linux 系统的继续火热，以 IBM 和 Intel 为首的多家 IT 企业巨头开始大力推动开放源代码软件的发展。</p>
<p>到了 2017 年年底，Linux 内核已经发展到了 4.13 版本，并且 Linux 系统版本也有数百个之多，但它们依然都使用 Linus Torvalds 开发、维护的 Linux 系统内核。RedHat 公司也成为了开源行业及 Linux 系统的带头公司。</p>
<p>初步接触 Linux 的读者，或者有这样一个疑问，Windows 系统也很好用，也能满足日常工作需求，为什么要学习 Linux 系统呢?</p>
<p>有些初学者会将“Linxu 系统是开源的”作为这个问题的答案，其实不然。开源的操作系统少说有 100 个，开源的软件至少也有十万个，为什么不去逐个学习? Linux 的开源特性只是一部分优势，并不是学习 Linux 的主要原因。</p>
<p>对于用户来讲，开源精神仅具备锦上添花的效果，真正的原因在于，Linux 系统是一款优秀的软件产品，具有类似 UNIX 的程序界面，而且继承了 UNIX 的稳定性，能够较好地满足工作需求。</p>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>南辞</name>
    </contributor>
    <published>2019-11-15T00:00:00.000Z</published>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">Linux 简介</title>
    <id>http://qiqi.dreamagain.top/software/linux/intro/intro/</id>
    <link href="http://qiqi.dreamagain.top/software/linux/intro/intro/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<h1 id="linux-简介"> Linux 简介</h1>
<p>Linux 内核最初只是由芬兰人林纳斯·托瓦兹 (Linus Torvalds) 在赫尔辛基大学上学时出于个人爱好而编写的。</p>
<p>Linux 是一套免费使用和自由传播的类 Unix 操作系统，是一个基于 POSIX 和 UNIX 的多用户、多任务、支持多线程和多 CPU 的操作系统。</p>
<p>Linux 能运行主要的 UNIX 工具软件、应用程序和网络协议。它支持 32 位和 64 位硬件。Linux 继承了 Unix 以网络为核心的设计思想，是一个性能稳定的多用户网络操作系统。</p>
<p>Linux 让开展各种实际有用且具有创造性的事情成为可能。例如，您可以在一个 U 盘上装载 Linux 的自生系统引导映像 (live boot image)，启动一台硬盘已经崩溃的计算机，之后査找并解决该问题。或者，因为 Linux 是一个真正的多用户操作系统，它具有非常好的私密性和稳定性，整个团队可以同时从本地或远程登录进行工作。</p>
<p>Linux 的构建采用了一些与 UNIX 操作系统相同的技术，并带有大多数与深度成熟的 UNIX 操作系统相一致的工具，这极大地增加了稳定性与安全性。</p>
<p>Linux 的发行版还提供了复杂的软件包管理系统，可以可靠地安装和维护每一个在线资源库中成千上万的免费软件应用。</p>
<p>Linux 不仅是免费的，更是开源的(open source)，这意味着任何人都可以获得其代码并根据自己的需求进行修改。</p>
<h2 id="linux-的发行版"> Linux 的发行版</h2>
<p>Linux 的发行版说简单点就是将 Linux 内核与应用软件做一个打包。</p>
<p><img src="src/software/linux/assets/intro.jpg" alt="intro"></p>
<p>事实上，已经孵化出专属 Linux 各发行版的巨大生态系统。一个发行版(distribution ，有时缩写为 distro)是一个定制的软件包，它将 Linux 内核以及用户计算机 Linux 运行版的安装工具一起发布。</p>
<p>在 Linux 内核的发展过程中，各种 Linux 发行版本起了巨大的作用，正是它们推动了 Linux 的应用，从而让更多的人开始关注 Linux。因此，把 Red Hat、Ubuntu、SUSE 等直接说成 Linux 其实是不确切的，它们是 Linux 的发行版本，更确切地说，应该叫作“以 Linux 为核心的操作系统软件包”。</p>
<p>Linux 的各个发行版本使用的是同一个 Linux 内核，因此在内核层不存在什么兼容性问题，每个版本有不一样的感觉，只是在发行版本的最外层(由发行商整合开发的应用)才有所体现。</p>
<p>目前市面上较知名的发行版有: Ubuntu、RedHat、CentOS、Debian、Fedora、SuSE、OpenSUSE、Arch Linux、SolusOS 等。</p>
<p>Linux 的发行版本可以大体分为两类:</p>
<ul>
<li>商业公司维护的发行版本，以著名的 Red Hat 为代表；</li>
<li>社区组织维护的发行版本，以 Debian 为代表。</li>
</ul>
<p>很难说大量 Linux 版本中哪一款更好，每个版本都有自己的特点。</p>
<h3 id="red-hat-linux"> Red Hat Linux</h3>
<p>Red Hat(红帽公司)创建于 1993 年，是目前世界上资深的 Linux 厂商，也是最获认可的 Linux 品牌。</p>
<p>Red Hat 公司的产品主要包括 RHEL(Red Hat Enterprise Linux，收费版本)和 CentOS(RHEL 的社区克隆版本，免费版本)、Fedora Core(由 Red Hat 桌面版发展而来，免费版本)。</p>
<p>Red Hat 是在我国国内使用人群最多的 Linux 版本，资料丰富，如果您有什么不明白的地方，则容易找到人来请教，而且大多数 Linux 教程是以 Red Hat 为例来讲解的(包括本教程)。</p>
<p>CentOS 是基于 Red Hat Enterprise Linux 源代码重新编译、去除 Red Hat 商标的产物，各种操作使用和付费版本没有区别，且完全免费。缺点是不向用户提供技术支持，也不负任何商业责任。</p>
<h3 id="ubuntu-linux"> Ubuntu Linux</h3>
<p>Ubuntu 基于知名的 Debian Linux 发展而来，界面友好，容易上手，对硬件的支持非常全面，是目前最适合做桌面系统的 Linux 发行版本，而且 Ubuntu 的所有发行版本都免费提供。</p>
<p>Ubuntu 的创始人 Mark Shuttleworth 是非常具有传奇色彩的人物。他在大学毕业后创建了一家安全咨询公司，1999 年以 5.75 亿美元被收购，由此一跃成为南非最年轻有为的本土富翁。作为一名狂热的天文爱好者，Mark Shuttleworth 于 2002 年自费乘坐俄罗斯联盟号飞船，在国际空间站中度过了 8 天的时光。之后，Mark Shuttleworth 创立了 Ubuntu 社区，2005 年 7 月 1 日建立了 Ubuntu 基金会，并为该基金会投资 1000 万美元。他说，太空的所见正是他创立 Ubuntu 的精神之所在。如今，他最热衷的事情就是到处为自由开源的 Ubuntu 进行宣传演讲。</p>
<h3 id="suse-linux"> SuSE Linux</h3>
<p>SuSE Linux 以 Slackware Linux 为基础，原来是德国的 SuSE Linux AG 公司发布的 Linux 版本，1994 年发行了第一版，早期只有商业版本，2004 年被 Novell 公司收购后，成立了 OpenSUSE 社区，推出了自己的社区版本 OpenSUSE。</p>
<p>SuSE Linux 在欧洲较为流行，在我国国内也有较多应用。值得一提的是，它吸取了 Red Hat Linux 的很多特质。</p>
<p>SuSE Linux 可以非常方便地实现与 Windows 的交互，硬件检测非常优秀，拥有界面友好的安装过程、图形管理工具，对于终端用户和管理员来说使用非常方便。</p>
<h3 id="gentoo"> Gentoo</h3>
<p>Gentoo 最初由 Daniel Robbins(FreeBSD 的开发者之一)创建，首个稳定版本发布于 2002 年。Gentoo 是所有 Linux 发行版本里安装最复杂的，到目前为止仍采用源码包编译安装操作系统。</p>
<p>不过，它是安装完成后最便于管理的版本，也是在相同硬件环境下运行最快的版本。自从 Gentoo 1.0 面世后，它就像一场风暴，给 Linux 世界带来了巨大的惊喜，同时也吸引了大量的用户和开发者投入 Gentoo Linux 的怀抱。</p>
<p>有人这样评价 Gentoo: 快速、设计干净而有弹性，它的出名是因为其高度的自定制性(基于源代码的发行版)。尽管安装时可以选择预先编译好的软件包，但是大部分使用 Gentoo 的用户都选择自己手动编译。这也是为什么 Gentoo 适合比较有 Linux 使用经验的老手使用。</p>
<h3 id="发行版选择"> 发行版选择</h3>
<p>Linux 的发行版本众多，在此不逐一介绍，下面给选择 Linux 发行版本犯愁的朋友一点建议:</p>
<ul>
<li>
<p>如果您需要的是一个服务器系统，而且已经厌烦了各种 Linux 的配置，只是想要一个比较稳定的服务器系统，那么建议您选择 CentOS 或 RHEL。</p>
</li>
<li>
<p>如果您只是需要一个桌面系统，而且既不想使用盗版，又不想花大价钱购买商业软件，不想自己定制，也不想在系统上浪费太多时间，则可以选择 Ubuntu。</p>
</li>
<li>
<p>如果您想深入摸索一下 Linux 各个方面的知识，而且还想非常灵活地定制自己的 Linux 系统，那就选择 Gentoo 吧，尽情享受 Gentoo 带来的自由快感。</p>
</li>
<li>
<p>如果您对系统稳定性要求很高，则可以考虑 FreeBSD。</p>
</li>
<li>
<p>如果您需要使用数据库高级服务和电子邮件网络应用，则可以选择 SuSE。</p>
</li>
</ul>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>南辞</name>
    </contributor>
    <published>2019-11-15T00:00:00.000Z</published>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">语言</title>
    <id>http://qiqi.dreamagain.top/software/linux/intro/language/</id>
    <link href="http://qiqi.dreamagain.top/software/linux/intro/language/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <summary type="html"><![CDATA[<p>Linux 中大量使用脚本语言，而不是 C 语言!</p>
]]></summary>
    <content type="html"><![CDATA[<p>Linux 中大量使用脚本语言，而不是 C 语言!</p>

<p>说到在 Linux 下的编程，很多人会想到用 C 语言，Linux 的内核、shell、基础命令程序，也的确是用 C 语言编写的，这首先证明了一点，C 语言很强很通用。</p>
<p>到目前为止，C 语言依然垄断着计算机工业中几乎所有的系统编程，而且也正因为是 C 语言，才使得 Unix 以及后来的 Linux 能够这么广泛地被人们去研究、去改进、去制作自己的分支，以至于我们能在各种硬件平台上使用它们。</p>
<p>但是细心的人会发现，Linux 启动过程中所涉及的各种程序，很少有 C 语言的痕迹。它们大多是脚本程序。不单单在启动过程中是这样，那些用于安装软件的工具 yum、apt-get，甚至是 configure 和 Makefile 也都是脚本程序。而且您可能还没注意到，那些用于系统管理的工具，如配置 ADSL 拨号上网的工具、配置守护进程的工具等，很多也都是脚本程序。</p>
<p>大量使用脚本程序，是所有类 Unix 系统不同于其他系统的一个显著特征，催生人们在 Linux 中大量使用脚本来编写程序，并不仅仅是因为脚本对人直观、容易修改这种显著特性所决定的。另外一个主要的原因就是 Linux 所支持的脚本语言种类十分丰富。</p>
<p>所有类 Unix 系统所必备的 shell，其本身就是一个强大的脚本解释器。所以从 shell 诞生的那一天起，shell 就是那些不懂 C 语言，又必须在 Unix 上编写程序的用户们的首选工具。</p>
<p>这就给了人们一种新的选择，使用 shell 编程不用去理会让人头晕的指针；shell 程序可以直接利用系统命令来完成一些需要用大量 C 代码的功能；shell 编程不用去理会数据类型，不用考虑烦人的数值和字符数据的转换问题；shell 程序同样提供顺序、选择分支和循环这三种能够构建任意算法的基础设施。因此，shell 很快就能够被非专业用户所接受、掌握，并编写出非常实用的程序。</p>
<p>随着时间的推移，这些非专业用户想往更高的方向发展，遇到了一些 shell 处理起来会很“蹩脚”的问题，比如分析文本和修改文本(别忘了“万般皆文本”)。这个时候他们会发现 有 awk 和 sed。也只需要写几行脚本就能将这些问题处理得很好。而且它们也跟 shell 配合得天衣无缝。或许这个时候会觉得加入了 awk 和 sed 的 shell 脚本有些难看，不过没关系，还有 Perl 和 TCL。Perl 天生就是为处理文本而存在的，TCL 也不含糊。</p>
<p>如果觉得这些语言都太老气了，有些过时了，不要紧，还有 Python、Ruby 等这些现代脚本语言，它们除了不能写操作系统内核之外，几乎什么都能干，而且还是面向对象的。</p>
<p>不管怎样，在 Linux 下能够选择的脚本语言都是极其丰富的。它们最大的特点就是简单、好学且资料丰富。简单就意味着容易维护，好学就容易吸引用户，资料丰富就不会在解决 bug 上出现障碍。即便是专业的程序员，也会因为这些特点而特别偏好脚本语言，导致的一个结果就是脚本程序在 Linux 中的大爆发。</p>
<p>为什么不选择 C 语言呢?</p>
<h2 id="c-语言并不是最佳选择"> C 语言并不是最佳选择</h2>
<p>C 语言是 Unix 的母语，这是毋庸罝疑的。前面也说过，正是因为有了 C 语言，才使得 Unix 有了今天的成就。但为什么在 Linux 中有这么多程序，甚至是关键程序，不用 C 语言编写呢?</p>
<p>脚本程序由于是解释执行的，在执行效率上自然是会有很大损失的。并且大家都知道，C 语言所编写的程序又是以效率著称的。但是 C 语言是一种编译型语言，要想让 C 语言的程序能够运行，必须经过编译和链接这两个步骤。</p>
<p>要知道，能够将由几十个源代码文件构成的 C 语言程序，有条不紊地编译完成并能最终链接成一个可执行程序，本身就是一件费时又费力的事情，如果一旦程序有问题，还必须使用专门的调试工具一点点地去跟踪判断，修正之后再重复那些复杂的编译和链接步骤，这又是一个极需技巧的事情。积累并掌握技巧又是一件费时又费力的事情。</p>
<p>在早些年，计算机性能不佳的时候，这些付出或许是值得的。但是放到现在，处理器的速度至少快了几千倍，内存大了几千倍，硬盘甚至大了几万倍，而价格却更低了。从经济角度分析，机器的时间成本早己远远低于人的时间成本了。那么 C 语言在机器效率上的优势根本没有任何意义。脚本程序能够给人节省下来的时间成本，则更具经济效益。
要论机器效率，汇编语言比 C 语言要好上几十倍，但是目前还有谁在用汇编语言编程呢?</p>
<p>C 语言在设计的时候，最主要的一个目标就是能够让程序员自己处理内存管理的问题。这使得 C 语言很强大但又太过于灵活，导致了很多陷阱的出现。稍微一不注意，程序中就会存在难以发觉的 Bug，甚至是严重的安全漏洞。程序员们大多是要以时间或失败为代价去积累经验，才能尽量避免这些问题的发生。而且效率在大多数应用中根本就不是问题，首要的是正确。脚本程序的简单和直观正是正确的起点，C 语言的灵活却是错误的根源。</p>
<p>但是，C 语言并不是一无是处，也是 Unix 的精华。C 语言作为通用程序设计语言是所向无敌的。C 语言本身也非常简洁和紧凑，资料丰富且容易学习。C 语言之后的少数语言设计，为了不被 C 语言所吞并，不得不进行大的改动，比如引进垃圾回收机制等，以和 C 语言能够在功能上保持足够距离。也正是因为这样，C 语言始终没有消失，只是它的光辉在 Linux 中稍稍地被脚本程序所遮挡了一下。</p>
<h2 id="脚本语言也有不足"> 脚本语言也有不足</h2>
<p>虽然效率并不是脚本程序的缺点，但是种类过于丰富却是一个极大不足。编写一个复杂的应用，往往很难使用一种脚本语言包杆到底，因为脚本语言都有自己适用的场景，为了能够快速有效地完成某个应用，就需扬长避短，利用多种脚本语言混合编程。</p>
<p>多脚本语言的混合编程是一种知识密集型的编程方法，但不是编码密集型的(这是能够被普遍接受的原因)。为了能够良好地使用这种方法，就要求程序员不仅仅要具备相当数量的多种语言知识，还必须具备能够判断这些语言的适用场景、以及如何将它们有效地组合在一起的经验。</p>
<p>实际上，混合编程并不是脚本语言的专利，任何编程语言都行，只要您能找准那些语言的特点。比如笔者就曾经使用过 Basic 和 C 进行混合编程，去完成一个 DOS 版万年历程序。为了支持鼠标点击操作，用 C 完成了鼠标中断的处理。余下的部分都用 Basic 来完成。</p>
<p>在 Linux 中大量应用脚本程序的场景，好多都是这种混合编程的典范。比如 Linux 的启动过程，主程序 init 是用 C 语言写的，具体到启动流程的各个环节则是 shell 脚本程序。</p>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>南辞</name>
    </contributor>
    <published>2019-11-16T00:00:00.000Z</published>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">Linux 简介</title>
    <id>http://qiqi.dreamagain.top/software/linux/intro/</id>
    <link href="http://qiqi.dreamagain.top/software/linux/intro/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<h1 id="linux-简介"> Linux 简介</h1>
<ul>
<li>
<p><a href="./src/software/linux/intro/intro.html">Linux 介绍</a></p>
</li>
<li>
<p><a href="./src/software/linux/intro/history.html">Linux 历史</a></p>
</li>
<li>
<p><a href="./src/software/linux/intro/language.html">Linux 编写语言</a></p>
</li>
<li>
<p><a href="./src/software/linux/intro/advantage.html">Linux 优势</a></p>
</li>
<li>
<p><a href="./src/software/linux/intro/desktop.html">Linux 桌面环境</a></p>
</li>
</ul>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>南辞</name>
    </contributor>
    <published>2019-11-15T00:00:00.000Z</published>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">Linux 系统启动过程</title>
    <id>http://qiqi.dreamagain.top/software/linux/intro/startup/</id>
    <link href="http://qiqi.dreamagain.top/software/linux/intro/startup/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<h1 id="linux-系统启动过程"> Linux 系统启动过程</h1>
<div><p>提示</p>
<p>本篇教程以 CentOS 为例介绍系统的启动过程。</p>
</div>
<p>Linux 启动时我们会看到许多启动信息。</p>
<p>Linux 系统的启动过程并不是大家想象中的那么复杂，其过程可以分为 5 个阶段:</p>
<ul>
<li>内核的引导。</li>
<li>运行 init。</li>
<li>系统初始化。</li>
<li>建立终端 。</li>
<li>用户登录系统。</li>
</ul>
<div><p>提示</p>
<p>init 程序的类型:</p>
<ul>
<li>SysV: init, CentOS 5 之前, 配置文件: /etc/inittab。</li>
<li>Upstart: init,CentOS 6, 配置文件: /etc/inittab, /etc/init/*.conf。</li>
<li>Systemd: systemd, CentOS 7,配置文件: /usr/lib/systemd/system、 /etc/systemd/system。</li>
</ul>
</div>
<h2 id="内核引导"> 内核引导</h2>
<p>当计算机打开电源后，首先是 BIOS 开机自检，按照 BIOS 中设置的启动设备(通常是硬盘)来启动。</p>
<p>操作系统接管硬件以后，首先读入 <code>/boot</code> 目录下的内核文件。</p>
<p><img src="src/software/linux/assets/boot.png" alt="boot"></p>
<h2 id="运行-init"> 运行 init</h2>
<p>init 进程是系统所有进程的起点，您可以把它比拟成系统所有进程的老祖宗，没有这个进程，系统中任何进程都不会启动。</p>
<p>init 程序首先是需要读取配置文件 <code>/etc/inittab</code>。</p>
<p><img src="src/software/linux/assets/init.png" alt="init"></p>
<h3 id="运行级别"> 运行级别</h3>
<p>许多程序需要开机启动。它们在 Windows 叫做&quot;服务&quot;(service)，在 Linux 就叫做&quot;守护进程&quot;(daemon)。</p>
<p>init 进程的一大任务，就是去运行这些开机启动的程序。</p>
<p>但是，不同的场合需要启动不同的程序，比如用作服务器时，需要启动 Apache，用作桌面就不需要。</p>
<p>Linux 允许为不同的场合，分配不同的开机启动程序，这就叫做&quot;运行级别&quot;(runlevel)。也就是说，启动时根据&quot;运行级别&quot;，确定要运行哪些程序。</p>
<p><img src="src/software/linux/assets/runlevel.png" alt="runlevel"></p>
<p>Linux 系统有 7 个运行级别(runlevel):</p>
<ul>
<li>运行级别 0: 系统停机状态，系统默认运行级别不能设为 0，否则不能正常启动</li>
<li>运行级别 1: 单用户工作状态，root 权限，用于系统维护，禁止远程登陆</li>
<li>运行级别 2: 多用户状态(没有 NFS)</li>
<li>运行级别 3: 完全的多用户状态(有 NFS)，登陆后进入控制台命令行模式</li>
<li>运行级别 4: 系统未使用，保留</li>
<li>运行级别 5: X11 控制台，登陆后进入图形 GUI 模式</li>
<li>运行级别 6: 系统正常关闭并重启，默认运行级别不能设为 6，否则不能正常启动</li>
</ul>
<h2 id="系统初始化"> 系统初始化</h2>
<p>在 init 的配置文件中有这么一行: <code>si::sysinit:/etc/rc.d/rc.sysinit</code>　它调用执行了 <code>/etc/rc.d/rc.sysinit</code>，而 <code>rc.sysinit</code> 是一个 bash shell 的脚本，它主要是完成一些系统初始化的工作，rc.sysinit 是每一个运行级别都要首先运行的重要脚本。</p>
<p>它主要完成的工作有: 激活交换分区，检查磁盘，加载硬件模块以及其它一些需要优先执行任务。</p>
<div><pre><code>l5:5:wait:/etc/rc.d/rc <span>5</span>
</code></pre>
<div><span>1</span><br></div></div><p>这一行表示以 5 为参数运行 <code>/etc/rc.d/rc</code>，<code>/etc/rc.d/rc</code> 是一个 Shell 脚本，它接受 5 作为参数，去执行 <code>/etc/rc.d/rc5.d/</code> 目录下的所有的 rc 启动脚本，<code>/etc/rc.d/rc5.d/</code> 目录中的这些启动脚本实际上都是一些连接文件，而不是真正的 rc 启动脚本，真正的 rc 启动脚本实际上都是放在 <code>/etc/rc.d/init.d/</code>目录下。</p>
<p>而这些 rc 启动脚本有着类似的用法，它们一般能接受 start、stop、restart、status 等参数。</p>
<p><code>/etc/rc.d/rc5.d/</code> 中的 rc 启动脚本通常是 K 或 S 开头的连接文件，对于以 S 开头的启动脚本，将以 start 参数来运行。</p>
<p>而如果发现存在相应的脚本也存在 K 打头的连接，而且已经处于运行态了(以 <code>/var/lock/subsys/</code> 下的文件作为标志)，则将首先以 stop 为参数停止这些已经启动了的守护进程，然后再重新运行。</p>
<p>这样做是为了保证是当 init 改变运行级别时，所有相关的守护进程都将重启。</p>
<p>至于在每个运行级中将运行哪些守护进程，用户可以通过 chkconfig 或 setup 中的 &quot;System Services&quot; 来自行设定。</p>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <contributor>
      <name>南辞</name>
    </contributor>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">Linux</title>
    <id>http://qiqi.dreamagain.top/software/linux/</id>
    <link href="http://qiqi.dreamagain.top/software/linux/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<h2 id="linux-教程"> Linux 教程</h2>
<ul>
<li>
<p><a href="./src/software/linux/intro/">Linux 介绍</a></p>
<ul>
<li>
<p><a href="./src/software/linux/intro/intro.html">Linux 介绍</a></p>
</li>
<li>
<p><a href="./src/software/linux/intro/history.html">Linux 历史</a></p>
</li>
<li>
<p><a href="./src/software/linux/intro/language.html">Linux 编写语言</a></p>
</li>
<li>
<p><a href="./src/software/linux/intro/advantage.html">Linux 优势</a></p>
</li>
<li>
<p><a href="./src/software/linux/intro/desktop.html">Linux 桌面环境</a></p>
</li>
</ul>
</li>
<li>
<p><a href="./src/software/linux/file/">Linux 文件</a></p>
<ul>
<li>
<p><a href="./src/software/linux/file/file.html">Linux 文件</a></p>
</li>
<li>
<p><a href="./src/software/linux/file/dir.html">Linux 目录</a></p>
</li>
<li>
<p><a href="./src/software/linux/file/mount.html">挂载</a></p>
</li>
</ul>
</li>
<li>
<p><a href="./src/software/linux/command/">Linux 命令</a></p>
<ul>
<li>
<p><a href="./src/software/linux/command/command.html">命令格式简介</a></p>
</li>
<li>
<p><a href="./src/software/linux/command/dir.html">目录相关</a></p>
</li>
<li>
<p><a href="./src/software/linux/command/file.html">文件相关</a></p>
</li>
<li>
<p><a href="./src/software/linux/command/other.html">其他命令</a></p>
</li>
<li>
<p><a href="./src/software/linux/command/add.html">命令的自动补全</a></p>
</li>
<li>
<p><a href="./src/software/linux/command/excu.html">命令的执行</a></p>
</li>
<li>
<p><a href="./src/software/linux/command/path.html">环境变量</a></p>
</li>
<li>
<p><a href="./src/software/linux/command/ln.html">创建链接</a></p>
</li>
</ul>
</li>
</ul>
<h2 id="ubuntu"> ubuntu</h2>
<ul>
<li><a href="./src/software/linux/ubuntu/">点击前往</a></li>
</ul>
<h2 id="centos"> CentOS</h2>
<ul>
<li><a href="./src/software/linux/centos.html">点击前往</a></li>
</ul>
<h2 id="wsl"> WSL</h2>
<ul>
<li><a href="./src/software/linux/WSL.html">点击前往</a></li>
</ul>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>南辞</name>
    </contributor>
    <published>2019-11-15T00:00:00.000Z</published>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">ssh</title>
    <id>http://qiqi.dreamagain.top/software/linux/ssh/</id>
    <link href="http://qiqi.dreamagain.top/software/linux/ssh/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<h2 id="使用密码登录"> 使用密码登录</h2>
<ol>
<li>
<p>执行以下命令，连接 Linux 云服务器。</p>
<div><pre><code><span>ssh</span> <span>&lt;</span>username<span>></span>@<span>&lt;</span>hostname or IP address<span>></span>
</code></pre>
<div><span>1</span><br></div></div><ul>
<li>username 即为前提条件中获得的默认帐号。</li>
<li>hostname or IP address 为您的 Linux 实例公网 IP 或自定义域名。</li>
</ul>
</li>
<li>
<p>输入已获取的密码，按 Enter，即可完成登录。</p>
</li>
</ol>
<h2 id="使用密钥登录"> 使用密钥登录</h2>
<ol>
<li>
<p>执行以下命令，赋予私钥文件仅本人可读权限。</p>
<div><pre><code><span>chmod</span> <span>400</span> <span>&lt;</span>下载的与云服务器关联的私钥的绝对路径<span>></span>
</code></pre>
<div><span>1</span><br></div></div></li>
<li>
<p>执行以下命令，进行远程登录。</p>
<div><pre><code><span>ssh</span> -i <span>&lt;</span>下载的与云服务器关联的私钥的绝对路径<span>></span> <span>&lt;</span>username<span>></span>@<span>&lt;</span>hostname or IP address<span>></span>
</code></pre>
<div><span>1</span><br></div></div><ul>
<li>username 即为前提条件中获得的默认帐号。</li>
<li>hostname or IP address 为您的 Linux 实例公网 IP 或自定义域名。</li>
</ul>
<p>例如，执行 <code>ssh -i &quot;id_rsa&quot; ubuntu@123.206.113.227</code> 命令，远程登录 Linux 云服务器。</p>
</li>
</ol>
<h2 id="断开链接"> 断开链接</h2>
<p><code>Ctrl + D</code> 或 输入 <code>logout</code>.</p>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <category term="基础"/>
    <contributor>
      <name>南辞</name>
    </contributor>
    <published>2019-11-23T00:00:00.000Z</published>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">语言切换</title>
    <id>http://qiqi.dreamagain.top/software/linux/ubuntu/lang/</id>
    <link href="http://qiqi.dreamagain.top/software/linux/ubuntu/lang/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<h1 id="语言切换"> 语言切换</h1>
<p>查看当前语言包: <code>locale -a</code></p>
<p>中文语言是: <code>zh_CN.utf8</code></p>
<h2 id="安装中文语言包"> 安装中文语言包</h2>
<div><pre><code><span>sudo</span> <span>apt-get</span> <span>install</span> language-pack-zh-hans
</code></pre>
<div><span>1</span><br></div></div><p>之后修改 <code>/etc/default/locale</code>，将 <code>LANG</code> 改为 <code>zh_CN.utf8</code></p>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>南辞</name>
    </contributor>
    <published>2019-11-22T00:00:00.000Z</published>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">开发软件</title>
    <id>http://qiqi.dreamagain.top/software/linux/ubuntu/debug/</id>
    <link href="http://qiqi.dreamagain.top/software/linux/ubuntu/debug/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<h1 id="开发软件"> 开发软件</h1>
<h2 id="安装-vs-code"> 安装 VS Code</h2>
<ul>
<li>
<p>使用 snap</p>
<div><pre><code><span>sudo</span> snap <span>install</span> --classic code
</code></pre>
<div><span>1</span><br></div></div></li>
<li>
<p>在 WSL 环境下 snap 无法使用，则使用以下命令安装 code 库。</p>
<div><pre><code><span>curl</span> https://packages.microsoft.com/keys/microsoft.asc <span>|</span> gpg --dearmor <span>></span> packages.microsoft.gpg
<span>sudo</span> <span>install</span> -o root -g root -m <span>644</span> packages.microsoft.gpg /usr/share/keyrings/
<span>sudo</span> <span>sh</span> -c <span>'echo "deb [arch=amd64 signed-by=/usr/share/keyrings/packages.microsoft.gpg] https://packages.microsoft.com/repos/vscode stable main" > /etc/apt/sources.list.d/vscode.list'</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>然后正常安装:</p>
<div><pre><code><span>sudo</span> <span>apt-get</span> <span>install</span> apt-transport-https
<span>sudo</span> <span>apt-get</span> update
<span>sudo</span> <span>apt-get</span> <span>install</span> code <span># or code-insiders</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div></li>
</ul>
<p>可能还需要安装</p>
<div><pre><code><span>sudo</span> <span>apt-get</span> <span>install</span> libx11-xcb1 libasound2
</code></pre>
<div><span>1</span><br></div></div><h3 id="remote-插件安装"> remote 插件安装</h3>
<div><pre><code>code --install-extension ms-vscode-remote.vscode-remote-extensionpack
</code></pre>
<div><span>1</span><br></div></div><h2 id="nvm"> nvm</h2>
<div><pre><code><span>curl</span> -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.35.1/install.sh <span>|</span> <span>bash</span>
</code></pre>
<div><span>1</span><br></div></div><p>在 Linux 上可能需要重新链接终端，命令才可用。</p>
<p>测试命令，输入 <code>nvm</code> 即安装成功:</p>
<div><pre><code><span>command</span> -v nvm
</code></pre>
<div><span>1</span><br></div></div><p>安装命令:</p>
<div><pre><code>nvm <span>install</span> <span>10</span>
</code></pre>
<div><span>1</span><br></div></div><p>切换命令:</p>
<div><pre><code>nvm use <span>10</span>
</code></pre>
<div><span>1</span><br></div></div><h2 id="安装-git"> 安装 Git</h2>
<div><pre><code><span>sudo</span> add-apt-repository ppa:git-core/ppa

<span>sudo</span> <span>apt-get</span> update

<span>sudo</span> <span>apt-get</span> <span>install</span> <span>git</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h2 id="yarn"> yarn</h2>
<div><pre><code><span>curl</span> -sS https://dl.yarnpkg.com/debian/pubkey.gpg <span>|</span> <span>sudo</span> apt-key <span>add</span> -
<span>echo</span> <span>"deb https://dl.yarnpkg.com/debian/ stable main"</span> <span>|</span> <span>sudo</span> <span>tee</span> /etc/apt/sources.list.d/yarn.list
<span>sudo</span> <span>apt-get</span> update <span>&amp;&amp;</span> <span>sudo</span> <span>apt-get</span> <span>install</span> <span>yarn</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>测试是否安装成功:</p>
<div><pre><code><span>yarn</span> --version
</code></pre>
<div><span>1</span><br></div></div>]]></content>
    <author>
      <name>南辞</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>南辞</name>
    </contributor>
    <published>2019-11-21T00:00:00.000Z</published>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">ubuntu</title>
    <id>http://qiqi.dreamagain.top/software/linux/ubuntu/</id>
    <link href="http://qiqi.dreamagain.top/software/linux/ubuntu/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<h1 id="ubuntu"> ubuntu</h1>
<ul>
<li>
<p><a href="./src/software/linux/ubuntu/manage.html">管理包</a></p>
</li>
<li>
<p><a href="./src/software/linux/ubuntu/debug.html">开发软件</a></p>
</li>
<li>
<p><a href="./src/software/linux/ubuntu/webserver.html">网络服务器相关</a></p>
</li>
<li>
<p><a href="./src/software/linux/ubuntu/lang.html">语言切换</a></p>
</li>
</ul>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>南辞</name>
    </contributor>
    <published>2019-11-21T00:00:00.000Z</published>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">管理工具</title>
    <id>http://qiqi.dreamagain.top/software/linux/ubuntu/manage/</id>
    <link href="http://qiqi.dreamagain.top/software/linux/ubuntu/manage/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<h1 id="管理工具"> 管理工具</h1>
<h2 id="apt-get"> apt-get</h2>
<p><code>apt-get</code> 命令默认的源在国内访问很慢，可以考虑换源。</p>
<ul>
<li>
<p>获取软件包更新:</p>
<div><pre><code><span>apt-get</span> update
</code></pre>
<div><span>1</span><br></div></div></li>
<li>
<p>更新软件包:</p>
<div><pre><code><span>apt-get</span> update
</code></pre>
<div><span>1</span><br></div></div></li>
<li>
<p>其他命令<sup></sup></p>
</li>
</ul>
<h2 id="snap"> Snap</h2>
<p>已经预装。</p>
<p>在中国大陆不建议使用 Snap</p>
<hr>
<section>
<ol>
<li id="fn1"><p>其他命令</p>
<div><pre><code><span>apt-cache</span> search <span># ------(package 搜索包)</span>

<span>apt-cache</span> show <span>#------(package 获取包的相关信息，如说明、大小、版本等)</span>

<span>sudo</span> <span>apt-get</span> <span>install</span> <span># ------(package 安装包)sudo apt-get install # -----(package - - reinstall 重新安装包)</span>

<span>sudo</span> <span>apt-get</span> -f <span>install</span> <span># -----(强制安装?#"-f = --fix-missing"当是修复安装吧...)</span>

<span>sudo</span> <span>apt-get</span> remove <span>#-----(package 删除包)</span>

<span>sudo</span> <span>apt-get</span> remove - - purge <span># ------(package 删除包，包括删除配置文件等)</span>

<span>sudo</span> <span>apt-get</span> autoremove --purge <span># ----(package 删除包及其依赖的软件包+配置文件等(只对6.10有效，强烈推荐))</span>

<span>sudo</span> <span>apt-get</span> update <span>#------更新源</span>

<span>sudo</span> <span>apt-get</span> upgrade <span>#------更新已安装的包</span>

<span>sudo</span> <span>apt-get</span> dist-upgrade <span># ---------升级系统</span>

<span>sudo</span> <span>apt-get</span> dselect-upgrade <span>#------使用 dselect 升级</span>

<span>apt-cache</span> depends <span>#-------(package 了解使用依赖)</span>

<span>apt-cache</span> rdepends <span># ------(package 了解某个具体的依赖?#当是查看该包被哪些包依赖吧...)</span>

<span>sudo</span> <span>apt-get</span> build-dep <span># ------(package 安装相关的编译环境)</span>

<span>apt-get</span> <span>source</span> <span>#------(package 下载该包的源代码)</span>

<span>sudo</span> <span>apt-get</span> clean <span>&amp;&amp;</span> <span>sudo</span> <span>apt-get</span> autoclean <span># --------清理下载文件的存档 &amp;&amp; 只清理过时的包</span>

<span>sudo</span> <span>apt-get</span> check <span>#-------检查是否有损坏的依赖</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br></div></div> </li>
</ol>
</section>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>南辞</name>
    </contributor>
    <published>2019-11-21T00:00:00.000Z</published>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">网络服务器相关</title>
    <id>http://qiqi.dreamagain.top/software/linux/ubuntu/webserver/</id>
    <link href="http://qiqi.dreamagain.top/software/linux/ubuntu/webserver/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<h1 id="网络服务器相关"> 网络服务器相关</h1>
<h2 id="ftp"> ftp</h2>
<h3 id="vsftpd"> vsftpd</h3>
<ul>
<li>
<p>安装</p>
<div><pre><code><span>apt-get</span> <span>install</span> vsftpd <span>ftp</span>
</code></pre>
<div><span>1</span><br></div></div></li>
<li>
<p>配置</p>
<div><pre><code><span>vim</span> /etc/vsftpd.conf
</code></pre>
<div><span>1</span><br></div></div><p>至少要更改:</p>
<div><pre><code><span>write_enable</span><span><span>=</span>YES</span>
<span>utf8_filesystem</span><span><span>=</span>YES</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div></li>
</ul>
<h2 id="nginx"> Nginx</h2>
<ul>
<li>
<p>安装</p>
<div><pre><code><span>sudo</span> <span>apt-get</span> <span>install</span> nginx
</code></pre>
<div><span>1</span><br></div></div><p>Nginx 默认安装在 <code>/etc/nginx</code> 目录下</p>
</li>
<li>
<p>配置</p>
<p>配置文件为 <code>nginx.conf</code>。</p>
<p>默认站点配置文件在 <code>/etc/nginx/sites-available/default</code></p>
<p>为了使得 Nginx 能使用 PHP，需要配置</p>
<div><pre><code>
<span>location</span> <span>~</span> \<span>.</span>php$ <span>{</span>
    <span>root</span>           <span>/</span>var<span>/</span>www<span>/</span>html<span>;</span>
    <span># 配置给 socks 应该可行，还在研究中</span>
    <span>fastcgi_pass</span>   <span>127.0</span><span>.0</span><span>.1</span><span>:</span><span>9000</span><span>;</span>
    <span>fastcgi_index</span>  <span>index</span><span>.</span>php<span>;</span>
    <span>fastcgi_param</span>  SCRIPT_FILENAME  <span>$document_root</span><span>$fastcgi_script_name</span><span>;</span>
    <span>include</span>        fastcgi_params<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div></li>
</ul>
<h2 id="php"> PHP</h2>
<div><pre><code><span># Apache</span>
<span>sudo</span> <span>apt-get</span> <span>install</span> php

<span># Ngnix</span>
<span>sudo</span> <span>apt-get</span> <span>install</span> php-fpm

<span># MySQL</span>
<span>sudo</span> <span>apt-get</span> <span>install</span> php-mysql
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h2 id="mysql"> MySQL</h2>
<h3 id="安装"> 安装</h3>
<div><pre><code><span>wget</span> https://dev.mysql.com/get/mysql-apt-config_0.8.14-1_all.deb
<span>sudo</span> dpkg -i mysql-apt-config_0.8.14-1_all.deb
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>配置版本(一般是 5.7)后安装</p>
<div><pre><code><span>sudo</span> <span>apt-get</span> <span>install</span> mysql-server
</code></pre>
<div><span>1</span><br></div></div><p>之后重启，完成配置</p>
<div><pre><code><span>sudo</span> <span>service</span> mysql restart
mysql -u root -p
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h2 id="nmp"> NMP</h2>
<p>需要对 Nginx 的配置文件进行修改: 主要改动的目标是把 Nginx 代理端口转发给 php-fpm。</p>
<p>首先配置 index:</p>
<div><pre><code><span>index</span> <span>index</span><span>.</span>php <span>index</span><span>.</span>html<span>;</span>
</code></pre>
<div><span>1</span><br></div></div><p>需要注意的是，Nginx 将端口转发给 php 默认的 9000 端口。而通过 apt-get 安装的 php 默认使用本地 sock 文件通信，需要对 php 的配置进行修改。要修改的文件位于: <code>/etc/php/7.2/fpm/pool.d/www.conf</code>，将</p>
<div><pre><code><span>listen</span> <span><span>=</span> /run/php/php7.0-fpm.sock</span>
</code></pre>
<div><span>1</span><br></div></div><p>改成:</p>
<div><pre><code><span>listen</span> <span><span>=</span> 127.0.0.1:9000</span>
</code></pre>
<div><span>1</span><br></div></div><div><p>提示</p>
<p>如果报了 permission limitted 的错误，说明 php 没法访问 html 文件夹，修改配置的 html 文件夹权限即可。</p>
</div>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <contributor>
      <name>南辞</name>
    </contributor>
    <published>2019-11-22T00:00:00.000Z</published>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">Nginx</title>
    <id>http://qiqi.dreamagain.top/software/nginx/</id>
    <link href="http://qiqi.dreamagain.top/software/nginx/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <summary type="html"><![CDATA[<p>Nginx 是一个高性能的 HTTP 和反向代理服务器，也是一个 IMAP / POP3 / SMTP 代理服务器。其特点是占有内存少，并发能力强，稳定性高，并且 Nginx 也拥有友好灵活的配置。</p>
]]></summary>
    <content type="html"><![CDATA[<p>Nginx 是一个高性能的 HTTP 和反向代理服务器，也是一个 IMAP / POP3 / SMTP 代理服务器。其特点是占有内存少，并发能力强，稳定性高，并且 Nginx 也拥有友好灵活的配置。</p>

<h2 id="启动-停止和重新加载配置"> 启动，停止和重新加载配置</h2>
<p>要启动 nginx，请运行可执行文件。一旦启动 nginx，就可以通过使用 <code>-s</code> 参数调用可执行文件来对其进行控制。使用以下语法:</p>
<div><pre><code>nginx -s signal
</code></pre>
<div><span>1</span><br></div></div><p>其中 <code>signal</code> 可能是以下之一:</p>
<ul>
<li>stop - 快速关机</li>
<li>quit — 正常关机</li>
<li>reload — 重新加载配置文件</li>
<li>reopen — 重新打开日志文件</li>
</ul>
<h2 id="配置文件的结构"> 配置文件的结构</h2>
<p>Nginx 由受配置文件中指定的指令控制的模块组成。指令分为简单指令和块指令。一个简单的指令由名称和参数组成，这些名称和参数之间用空格分隔，并以分号(<code>;</code>)结尾。块指令的结构与简单指令的结构相同，但是它不以分号结尾，而是带有一组用括号 (<code>{</code> 和 <code>}</code>) 括起来的附加指令。如果一个块指令在括号内可以有其他指令，则称为 context (例如: <code>events</code>, <code>http</code>, <code>server</code> 和 <code>location</code>)。</p>
<p>放置在任何 context 外部的配置文件中的指令都被视为在 main context 中。<code>events</code> 和 <code>http</code> 指令位于 <code>main</code> context 中，<code>server</code> 位于 <code>http</code> 中, 并且 <code>location</code> 在 <code>server</code> 中</p>
<p><code>#</code> 号后的其余行被视为注释。</p>
<h2 id="提供静态内容"> 提供静态内容</h2>
<p>Web 服务器的一项重要任务是分发文件(例如图像或静态 HTML 页面)。您将实现一个示例，其中将根据请求从不同的本地目录提供文件: <code>/data/www</code> (可能包含 HTML 文件)和 <code>/data/images</code>(包含图像)。这将需要编辑配置文件，并在带有两个位置块的 http 块内设置服务器块。</p>
<p>首先，创建 <code>/data/www</code> 目录，并将包含任何文本内容的 <code>index.html</code> 文件放入其中，并创建 <code>/data/images</code> 目录并将一些图像放入其中。</p>
<p>接下来，打开配置文件。默认配置文件已经包含了服务器块的几个示例，大部分已被注释掉。现在，注释掉所有这些块并启动一个新的服务器块:</p>
<div><pre><code><span>http</span> <span>{</span>
  <span>server</span> <span>{</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>通常，配置文件可以包括几个服务器块，这些服务器块通过它们侦听的端口和服务器名称来区分。一旦 nginx 决定了哪个服务器处理请求，它就会根据服务器块内定义的 location 指令的参数测试请求标头中指定的 URI。</p>
<p>将以下位置块添加到服务器块:</p>
<div><pre><code><span>location</span> <span>/</span> <span>{</span>
  <span>root</span> <span>/</span>data<span>/</span>www<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>与请求中的 URI 相比，此位置块指定 “<code>/</code>” 前缀。对于匹配的请求，URI 将被添加到 root 指令中指定的路径，即 <code>/data/www</code>，以形成本地文件系统上所请求文件的路径。如果有多个匹配的位置块，nginx 将选择前缀最长的位置块。上面的位置块提供了最短的前缀，长度为 1，因此，只有在所有其他位置块均未提供匹配项时，才会使用该块。</p>
<p>接下来，添加第二个位置块:</p>
<div><pre><code><span>location</span> <span>/</span>images<span>/</span> <span>{</span>
  <span>root</span> <span>/</span>data<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>这将匹配以 <code>/images/</code> 开头的请求(位置 <code>/</code> 也匹配此类请求，但前缀较短)。</p>
<p>服务器块的最终配置应如下所示:</p>
<div><pre><code><span>server</span> <span>{</span>
  <span>location</span> <span>/</span> <span>{</span>
    <span>root</span> <span>/</span>data<span>/</span>www<span>;</span>
  <span>}</span>

  <span>location</span> <span>/</span>images<span>/</span> <span>{</span>
    <span>root</span> <span>/</span>data<span>;</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>这已经是服务器的工作配置，可以在标准端口 <code>80</code> 上侦听，并且可以在本地计算机上的 <code>http://localhost/</code> 上访问。响应以 <code>/images/</code> 开头的 URI 请求，服务器将从 <code>/data/images</code> 目录中发送文件。例如，为响应 <code>http://localhost/images/example.png</code> 请求，nginx 将发送文件 <code>/data/images/example.png</code>。如果该文件不存在，nginx 将发送一个注明 404 错误的响应。URI 不以 <code>/images/</code> 开头的请求将被映射到 <code>/data/www</code> 目录。例如，nginx 会响应 <code>http://localhost/some/example.html</code> 请求发送 <code>/data/www/some/example.html</code> 文件。</p>
<p>要应用新配置，请启动 nginx (如果尚未启动)，或通过执行以下命令向 nginx 的主进程发送 <code>reload</code> 信号:</p>
<div><pre><code>nginx -s reload
</code></pre>
<div><span>1</span><br></div></div><p>如果某些东西无法按预期工作，则可以尝试在目录 <code>/usr/local/nginx/logs</code> 或目录 <code>/var/log/nginx</code> 中的 access.log 和 error.log 文件中找出原因。。</p>
<h2 id="设置简单的代理服务器"> 设置简单的代理服务器</h2>
<p>Nginx 的一种常用用法是将其设置为代理服务器，这意味着服务器可以接收请求，将请求传递给代理服务器，从请求中检索响应并将它们发送给客户端。</p>
<p>我们将配置一个基本的代理服务器，该服务器为图像请求和本地目录中的文件提供服务，并将所有其他请求发送到代理服务器。在此示例中，两个服务器都将在单个 nginx 实例上定义。</p>
<p>首先，通过向 nginx 的配置文件中添加另一个 <code>server</code> 块来定义代理服务器，其内容如下:</p>
<div><pre><code><span>server</span> <span>{</span>
  <span>listen</span> <span>8080</span><span>;</span>
  <span>root</span> <span>/</span>data<span>/</span>up1<span>;</span>

  <span>location</span> <span>/</span> <span>{</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>这将是一个简单的服务器，它在端口 8080 上侦听 (以前，自从使用标准端口 80 以来，未指定 listen 指令) 并将所有请求映射到本地文件系统的 <code>/data/up1</code> 目录中。创建此目录，并将 <code>index.html</code> 文件放入其中。请注意，根指令位于服务器上下文中。当选择用于服务请求的位置块不包括自己的根指令时，将使用这种根指令。</p>
<p>接下来，使用上一部分中的服务器配置并对其进行修改以使其成为代理服务器配置。在第一个位置块中，将 <code>proxy_pass</code> 指令与参数中指定的代理服务器的协议，名称和端口放在一起 (在本例中为 <code>http://localhost:8080</code> ):</p>
<div><pre><code><span>server</span> <span>{</span>
  <span>location</span> <span>/</span> <span>{</span>
    <span>proxy_pass</span> <span>http</span><span>:</span><span>/</span><span>/</span>localhost<span>:</span><span>8080</span><span>;</span>
  <span>}</span>

  <span>location</span> <span>/</span>images<span>/</span> <span>{</span>
    <span>root</span> <span>/</span>data<span>;</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>我们将修改第二个 location 块，该位置块当前将带有 <code>/images/</code> 前缀的请求映射到 <code>/data/images</code> 目录下的文件，以使其与具有典型文件扩展名的图像的请求相匹配。修改后的位置块如下所示:</p>
<div><pre><code><span>location</span> <span>~</span> \<span>.</span><span>(</span>gif<span>|</span>jpg<span>|</span>png<span>)</span>$ <span>{</span>
  <span>root</span> <span>/</span>data<span>/</span>images<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>该参数是一个正则表达式，它匹配以 <code>.gif</code>，<code>.jpg</code> 或 <code>.png</code> 结尾的所有 URI。正则表达式应以 <code>~</code> 开头。相应的请求将被映射到 <code>/ data/images</code> 目录。</p>
<p>当 nginx 选择一个 <code>location</code> 块来服务请求时，它首先检查指定前缀的 <code>location</code> 指令，记住带有最长前缀的 <code>location</code>，然后检查正则表达式。如果存在与正则表达式匹配的内容，nginx 会选择该 “<code>location</code>”，否则，它将选择之前记住的位置。</p>
<p>代理服务器的最终配置如下所示:</p>
<div><pre><code><span>server</span> <span>{</span>
  <span>location</span> <span>/</span> <span>{</span>
    <span>proxy_pass</span> <span>http</span><span>:</span><span>/</span><span>/</span>localhost<span>:</span><span>8080</span><span>/</span><span>;</span>
  <span>}</span>

  <span>location</span> <span>~</span> \<span>.</span><span>(</span>gif<span>|</span>jpg<span>|</span>png<span>)</span>$ <span>{</span>
    <span>root</span> <span>/</span>data<span>/</span>images<span>;</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>该服务器将过滤以 <code>.gif</code>，<code>.jpg</code> 或 <code>.png</code> 结尾的请求，并将它们映射到目录 <code>/data/images</code>(通过将 URI 添加到根指令的参数)，并将所有其他请求传递给上面配置的代理服务器。</p>
<p>要应用新配置，请按照前面几节的说明将重载信号发送到 nginx。</p>
<p>还有许多其他指令可用于进一步配置代理连接。</p>
<h2 id="设置-fastcgi-代理"> 设置 FastCGI 代理</h2>
<p>Nginx 可用于将请求路由到 FastCGI 服务器，该服务器运行使用各种框架和编程语言 (例如 PHP) 构建的应用程序。</p>
<p>与 FastCGI 服务器一起使用的最基本的 Nginx 配置包括使用 <code>fastcgi_pass</code> 指令而不是 <code>proxy_pass</code> 指令和 <code>fastcgi_param</code> 指令来设置传递给 FastCGI 服务器的参数。假设 FastCGI 服务器可以在 <code>localhost:9000</code> 上访问。以上一节中的代理配置为基础，用 <code>fastcgi_pass</code> 指令替换 <code>proxy_pass</code> 指令，并将参数更改为 <code>localhost:9000</code>。在 PHP 中， <code>SCRIPT_FILENAME</code> 参数用于确定脚本名称，而 <code>QUERY_STRING</code> 参数用于传递请求参数。配置的结果为:</p>
<div><pre><code><span>server</span> <span>{</span>
  <span>location</span> <span>/</span> <span>{</span>
    <span>fastcgi_pass</span>  localhost<span>:</span><span>9000</span><span>;</span>
    <span>fastcgi_param</span> SCRIPT_FILENAME <span>$document_root</span><span>$fastcgi_script_name</span><span>;</span>
    <span>fastcgi_param</span> QUERY_STRING    <span>$query_string</span><span>;</span>
  <span>}</span>

  <span>location</span> <span>~</span> \<span>.</span><span>(</span>gif<span>|</span>jpg<span>|</span>png<span>)</span>$ <span>{</span>
    <span>root</span> <span>/</span>data<span>/</span>images<span>;</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>这将设置一个服务器，该服务器将通过 FastCGI 协议将除静态图像请求以外的所有请求路由到运行在 <code>localhost:9000</code> 上的代理服务器。</p>
<h2 id="官方文档"> 官方文档</h2>
<ul>
<li><a href="https://docs.nginx.com/nginx/admin-guide/" target="_blank" rel="noopener noreferrer">点击此处</a></li>
</ul>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <category term="服务器"/>
    <contributor>
      <name>南辞</name>
    </contributor>
    <published>2019-12-13T00:00:00.000Z</published>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">windows下安装多版本Node.js</title>
    <id>http://qiqi.dreamagain.top/software/nvm/</id>
    <link href="http://qiqi.dreamagain.top/software/nvm/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <summary type="html"><![CDATA[<p>nvm Node.js npm yarn</p>
]]></summary>
    <content type="html"><![CDATA[<p>nvm Node.js npm yarn</p>

<p>对于Node.js的爱好者来说，必然希望能够在同一台机器上安装多个版本的Node.js(至少两个：稳定版和最新版)。稳定版用来在实际生产项目中使用，最新版本用来研究Node.js的新特性、踩坑。</p>
<p>以下将介绍在windows系统中如何通过nvm进行node多版本管理以及一些常用命令</p>
<h2 id="一、概念介绍"> 一、概念介绍</h2>
<p><code>nvm</code>：Node.js Version Manager，用来管理 node 的版本。</p>
<p><code>node</code>：Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。 Node.js使用了一个事件驱动、非阻塞式I/O的模型（ Node.js的特性），使其轻量级又高效。 Node.js 的包管理器 nmp 是全球最大的开源库生态系统。</p>
<p><code>npm</code>：Node Package Manager，npm 不需要单独安装。默认在安装 node 的时候，会连带一起安装 npm</p>
<p><code>cnpm</code>：淘宝镜像，自定义命令。介绍详见https://github.com/cnpm/cnpm</p>
<p><code>yarn</code>：Yarn 是 Facebook, Google, Exponent 和 Tilde 开发的一款新的 JavaScript 包管理工具。它的目的是解决这些团队使用 npm 面临的少数问题，即：</p>
<p>1、安装的时候无法保证速度、一致性；</p>
<p>2、安全问题，因为 npm 安装时允许运行代码；</p>
<p>3、more...</p>
<h2 id="二、安装及使用"> 二、安装及使用</h2>
<div><p>nvm-windows的地址</p>
<p>nvm-windows的github地址:https://github.com/coreybutler/nvm-windows</p>
<p>安装包下载地址：<a href="https://github.com/coreybutler/nvm-windows/releases" target="_blank" rel="noopener noreferrer">https://github.com/coreybutler/nvm-windows/releases</a></p>
</div>
<h3 id="一-安装包下载"> （一）安装包下载</h3>
<p>可以看到nvm已经很久没有更新了，目前最新版本也是2018年发布的，这也是长期支持的版本，可以选择安装版<code>nvm-setup.zip</code>和免安装版<code>nvm-noinstall.zip</code>，这里我选择的是<code>nvm-setup.zip</code></p>
<p><img src="./assets/nvm01.png" alt=""></p>
<h3 id="二-安装环境"> （二）安装环境</h3>
<p>Win10系统，64位</p>
<h3 id="三-安装"> （三）安装</h3>
<p>安装nvm-windows的时候会指定安装目录和当前所使用的Node.js的目录，这两个路径中不要带有特殊的字符以及空格，否则会在nvm use xxx的时候出错，无法正确解析指定的Node.js的版本的地址</p>
<p>在安装的时候，自动会把nvm和Node.js的目录添加到系统环境变量中，所以安装后可以直接测试安装是否成功。</p>
<blockquote>
<img src="./assets/nvm02.png" style="zoom:100%;" />
<img src="./assets/nvm03.png" style="zoom:90%;" />
</blockquote>
<h3 id="四-nvm命令"> （四）nvm命令</h3>
<img src="./assets/nvm04.png" alt="image-20210211112509359" style="zoom:70%;" />
<p>1、nvm list 是查找本电脑上所有的node版本</p>
<ul>
<li>
<p>nvm list 查看已经安装的版本</p>
</li>
<li>
<p>nvm list installed 查看已经安装的版本</p>
</li>
<li>
<p>nvm list available 查看网络可以安装的版本</p>
</li>
</ul>
<p>2、nvm install 安装最新版本nvm</p>
<ul>
<li>nvm install xxx 安装指定node版本，可模糊安装，nvm install v8.12.0 或 nvm install 8.12.0 或 nvm install 8.12</li>
</ul>
<p>3、nvm use <code>&lt;version&gt;</code> 切换使用指定的版本node</p>
<p>4、nvm ls 列出所有版本</p>
<p>5、nvm current显示当前版本</p>
<p>6、nvm alias<code>&lt;name&gt; &lt;version&gt;</code> 给不同的版本号添加别名</p>
<p>7、nvm unalias <code>&lt;name&gt;</code> 删除已定义的别名</p>
<p>8、nvm reinstall-packages <code>&lt;version&gt;</code> #在当前版本node环境下，重新全局安装指定版本号的npm包</p>
<p>9、nvm on 打开Node.js控制</p>
<p>10、nvm off 关闭Node.js控制</p>
<p>11、nvm proxy 查看设置与代理</p>
<p>12、nvm node_mirror [url] 设置或者查看setting.txt中的node_mirror，如果不设置的默认是 https://Node.js.org/dist/
　　       nvm npm_mirror [url] 设置或者查看setting.txt中的npm_mirror,如果不设置的话默认的是： https://github.com/npm/npm/archive/.</p>
<p>13、nvm uninstall <code>&lt;version&gt;</code> 卸载制定的版本</p>
<p>14、nvm use [version] [arch] 切换制定的node版本和位数</p>
<p>15、nvm root [path] 设置和查看root路径</p>
<p>16、nvm version 查看当前的版本</p>
<h3 id="五-安装-node-js"> （五）安装 Node.js</h3>
<p><strong>1、获取所有可安装的 Node.js 版本</strong></p>
<div><pre><code>nvm list available
</code></pre>
<div><span>1</span><br></div></div><p>以下也只是给我们列出部分较新的版本，根据环境需要找合适的版本安装。</p>
<p>比较贴心的告诉我们，要查看完整的系列版本访问 ：https://Node.js.org/download/release</p>
<p><code>LTS</code> 指最新稳定版本，<code>CURRENT</code> 指最新版本，一般安装 <code>LTS</code></p>
<p><img src="./assets/nvm05.png" alt=""></p>
<p><strong>2、安装指定版本的 Node.js</strong></p>
<div><pre><code>nvm <span>install</span> <span>10.16</span>.3
</code></pre>
<div><span>1</span><br></div></div><p><strong>3、列出所有已经安装的版本</strong></p>
<div><pre><code>nvm list
</code></pre>
<div><span>1</span><br></div></div><img src="./assets/nvm06.png" style="zoom:110%;" />
<p><strong>4、指定当前要使用的 Node.js 版本,只用指定使用的 Node.js 版本后，Node.js 的才真正安装了。</strong></p>
<div><pre><code>nvm use <span>10.16</span>.3
</code></pre>
<div><span>1</span><br></div></div><p>版本查看：</p>
<img src="./assets/nvm07.png" style="zoom:120%;" />
<div><p>提示</p>
<p>通过以上步骤安装的Node.js和单独安装Node.js没有太大的区别，所以可以和单独安装的Node.js一样放心的使用npm进行cordova、ionic、vue等等的安装</p>
<p>npm是Node.js自带的包管理工具，类似于Java开发中经常使用的maven</p>
</div>
<p><strong>5、卸载某个 Node.js 版本</strong></p>
<div><pre><code>nvm uninstall <span>12.20</span>.0
</code></pre>
<div><span>1</span><br></div></div><h2 id="三、node-js-包管理器"> 三、Node.js 包管理器</h2>
<p>Node.js 包管理器一览表</p>
<ul>
<li>npm</li>
<li>cnpm</li>
<li>yarn</li>
</ul>
<p>npm 是 Node.js 自带的包管理器，但是默认下载依赖包的地址是国外服务器，下载速度较慢。使用 npm ,下载包两小时，敲代码 5 分钟。所以使用的时候指定安装源为国内的镜像源。</p>
<p>阿里巴巴是 Node.js 前端非常重视 Node.js 的使用，于是，淘宝开发了 cnpm,使用与 npm 一致，默认下载是国内地址，下载速度快得飞起。下载地址<a href="https://npm.taobao.org/" target="_blank" rel="noopener noreferrer">https://npm.taobao.org</a></p>
<p><a href="https://yarnpkg.com/zh-Hans/" target="_blank" rel="noopener noreferrer">yarn</a> 是 facebook 开发的新一代包管理器，主要是解决依赖包的安装问题。支持离线安装依赖包，同时依赖包的安装顺序不会出错。</p>
<h3 id="一-国内npm镜像源设置"> （一）国内npm镜像源设置</h3>
<p><strong>1、国内npm镜像源</strong></p>
<ul>
<li>
<p>淘宝npm镜像</p>
<p>搜索地址：http://npm.taobao.org/</p>
<p>registry地址：http://registry.npm.taobao.org/</p>
</li>
<li>
<p>cnpmjs镜像</p>
<p>搜索地址：http://cnpmjs.org/</p>
<p>registry地址：http://r.cnpmjs.org/</p>
</li>
<li>
<p>使用方法：</p>
<p>临时使用<code>npm --registry https://registry.npm.taobao.org install express</code></p>
<p>持久使用<code>npm config set registry https://registry.npm.taobao.org</code></p>
</li>
</ul>
<p><strong>以配置淘宝镜像为例：</strong></p>
<p>1、修改下载仓库为淘宝镜像</p>
<div><pre><code><span>npm</span> config <span>set</span> registry http://registry.npm.taobao.org/
或 
<span>yarn</span> config <span>set</span> registry https://registry.npm.taobao.org
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>如果需要安装node-sass，最好设置变量 sass_binary_site，指向淘宝镜像地址，很多时候环境安装不成功就是sass安装失败</p>
<div><pre><code><span>npm</span> config <span>set</span> sass_binary_site https://npm.taobao.org/mirrors/node-sass/
或
<span>yarn</span> config <span>set</span> sass_binary_site http://cdn.npm.taobao.org/dist/node-sass -g
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>2、 如果需要修改回来</p>
<div><pre><code><span>npm</span> config <span>set</span> registry https://registry.npmjs.org/
或 
<span>yarn</span> config <span>set</span> registry https://registry.yarnpkg.com
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>3、或直接采用他们的cnpm</p>
<div><pre><code><span>npm</span> <span>install</span> -g cnpm --registry<span>=</span>https://registry.npm.taobao.org
</code></pre>
<div><span>1</span><br></div></div><p><strong>2、配置完成后可通过下面方式来验证是否成功</strong></p>
<div><pre><code><span>npm</span> config get registry
或npm info express
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h3 id="二-安装yarn"> （二）安装Yarn</h3>
<p><strong>通过npm安装</strong></p>
<div><pre><code><span># -g 全局安装</span>
<span># -d 局部安装</span>
<span>npm</span> <span>install</span> -g <span>yarn</span>
或者
<span>npm</span> i <span>yarn</span> -g
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p><strong>查看版本</strong></p>
<img src="./assets/nvm08.png" style="zoom:150%;" />
<p><strong>Yarn 淘宝源配置</strong></p>
<div><pre><code><span>yarn</span> config <span>set</span> registry https://registry.npm.taobao.org -g

<span>yarn</span> config <span>set</span> sass_binary_site http://cdn.npm.taobao.org/dist/node-sass -g
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id="二-npm-yarn-命令对照表"> （二）npm yarn 命令对照表</h3>
<table>
<thead>
<tr>
<th>npm</th>
<th>Yarn</th>
</tr>
</thead>
<tbody>
<tr>
<td>npm install</td>
<td>yarn install</td>
</tr>
<tr>
<td>(N/A)</td>
<td>yarn install --flat</td>
</tr>
<tr>
<td>(N/A)</td>
<td>yarn install --har</td>
</tr>
<tr>
<td>(N/A)</td>
<td>yarn install --no-lockfile</td>
</tr>
<tr>
<td>(N/A)</td>
<td>yarn install --pure-lockfile</td>
</tr>
<tr>
<td>npm install [package]</td>
<td>(N/A)</td>
</tr>
<tr>
<td>npm install --save [package]</td>
<td>yarn add [package]</td>
</tr>
<tr>
<td>npm install --save-dev [package]</td>
<td>yarn add [package] [--dev/-D]</td>
</tr>
<tr>
<td>(N/A)</td>
<td>yarn add [package] [--peer/-P]</td>
</tr>
<tr>
<td>npm install --save-optional [package]</td>
<td>yarn add [package] [--optional/-O]</td>
</tr>
<tr>
<td>npm install --save-exact [package]</td>
<td>yarn add [package] [--exact/-E]</td>
</tr>
<tr>
<td>(N/A)</td>
<td>yarn add [package] [--tilde/-T]</td>
</tr>
<tr>
<td>npm install --global [package]</td>
<td>yarn global add [package]</td>
</tr>
<tr>
<td>npm rebuild</td>
<td>yarn install --force</td>
</tr>
<tr>
<td>npm uninstall [package]</td>
<td>(N/A)</td>
</tr>
<tr>
<td>npm uninstall --save [package]</td>
<td>yarn remove [package]</td>
</tr>
<tr>
<td>npm uninstall --save-dev [package]</td>
<td>yarn remove [package]</td>
</tr>
<tr>
<td>npm uninstall --save-optional [package]</td>
<td>yarn remove [package]</td>
</tr>
<tr>
<td>npm cache clean</td>
<td>yarn cache clean</td>
</tr>
<tr>
<td>rm -rf node_modules &amp;&amp; npm install</td>
<td>yarn upgrade</td>
</tr>
</tbody>
</table>
<h2 id="四、常用指令"> 四、常用指令</h2>
<p>上面列出很多命令，仅供查阅使用，下面是经常用到的命令，也不用记，只是刚接触的时候要多看几眼，先熟练用这几个命令</p>
<p>nvm -v ： 查看已安装的nvm版本</p>
<p>nvm install xxx ： 安装指定node版本，可模糊安装</p>
<p>nvm ls ： 查看已安装的所有node版本</p>
<p>node -v ：查看已安装的node版本</p>
<p>npm -v ：查看已安装的npm 版本</p>
<p>yarn -v ：查看已安装的yarn 版本</p>
<p>npm config get registry：查看当前设置的npm镜像源</p>
<p>yarn config get registry ：查看当前设置的yarn镜像源</p>
<p>npm config set registry https://registry.npm.taobao.org</p>
<p>yarn config set registry https://registry.npm.taobao.org</p>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <category term="软件使用"/>
    <contributor>
      <name>南辞</name>
    </contributor>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">Postman</title>
    <id>http://qiqi.dreamagain.top/software/postman/</id>
    <link href="http://qiqi.dreamagain.top/software/postman/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<h1 id="postman"> Postman</h1>
<p>Postman 是一个强大的抓包与网络调试工具。</p>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <contributor>
      <name>南辞</name>
    </contributor>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">软件教程</title>
    <id>http://qiqi.dreamagain.top/software/</id>
    <link href="http://qiqi.dreamagain.top/software/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<h2 id="代码编辑器"> 代码编辑器</h2>
<ul>
<li><a href="./editor.html">编辑器介绍</a></li>
</ul>
<h2 id="团队协作"> 团队协作</h2>
<p>开发项目的代码版本管理以及多人协作使用 Git 软件</p>
<ul>
<li>
<p><a href="./git/">Git 教程</a></p>
</li>
<li>
<p><a href="./git/github/">GitHub 介绍</a></p>
</li>
</ul>
<h2 id="浏览器"> 浏览器</h2>
<p>在开发中，调试网页推荐使用 Chrome。</p>
<ul>
<li><a href="./Chrome/">Chrome 介绍</a></li>
</ul>
<h2 id="后端"> 后端</h2>
<h3 id="http-server"> Http Server</h3>
<p>网站已经停止使用 Apache Lounge 编译的 httpd Apache。目前迁移到更加轻量，并发性能更好的 Nginx 上。</p>
<ul>
<li>
<p><a href="./Apache.html">Apache</a> <i>Not supported content</i></p>
</li>
<li>
<p><a href="./nginx.html">Nginx</a></p>
</li>
</ul>
<h3 id="抓包与-api-调试"> 抓包与 API 调试</h3>
<ul>
<li><a href="./postman.html">Postman</a></li>
</ul>
<h2 id="工具软件"> 工具软件</h2>
<ul>
<li><a href="./tool/">查看详情</a></li>
</ul>
<h2 id="手机-app"> 手机 APP</h2>
<h3 id="w3cschool"> W3CSchool</h3>
<p>W3CSchool 网站出品的 APP，可以在手机上查看网站所整理的各语言的教程。</p>
<div><p>P.S.</p>
<p>会员没什么用别买。</p>
</div>
<h3 id="sololearn"> soloLearn</h3>
<p>一个代码在线学习社区，只有英文版。由于代码语义贴近英文原生逻辑，十分建议在编辑代码时 “think in English”。</p>
<p>软件中的 code playground 可以在线运行大部分代码，大家在手机上就可以进行练习与尝试。</p>
<h2 id="adobe-软件"> Adobe 软件</h2>
<p>Adobe 全系软件的获取，请见 <a href="https://www.weibo.com/vposy" target="_blank" rel="noopener noreferrer">vposy 的微博</a> 的置顶帖。</p>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <contributor>
      <name>南辞</name>
    </contributor>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">科学上网梯子</title>
    <id>http://qiqi.dreamagain.top/software/tool/accelerator/</id>
    <link href="http://qiqi.dreamagain.top/software/tool/accelerator/"/>
    <updated>2021-02-16T06:41:55.000Z</updated>
    <summary type="html"><![CDATA[<blockquote>
<p>🍎🍎🍎  梯子推荐：推荐好用的翻墙梯子，科学上网梯子，海外加速器梯子，国外靠谱梯子</p>
</blockquote>
]]></summary>
    <content type="html"><![CDATA[<blockquote>
<p>🍎🍎🍎  梯子推荐：推荐好用的翻墙梯子，科学上网梯子，海外加速器梯子，国外靠谱梯子</p>
</blockquote>

<table>
<thead>
<tr>
<th>VPN</th>
<th>特点</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://www.panhdpe.xyz/r/22216799" target="_blank" rel="noopener noreferrer">PandaVPN</a></td>
<td>海外华人开发，有免费试用</td>
</tr>
<tr>
<td><a href="https://go.nordlocker.net/aff_c?offer_id=15&amp;aff_id=38201&amp;url_id=6063&amp;aff_sub=github&amp;aff_click_id=supertz" target="_blank" rel="noopener noreferrer">NordVPN</a></td>
<td>顶级VPN品牌之一</td>
</tr>
<tr>
<td><a href="https://www.xvbelink.com/?a_fid=tizi_vpn&amp;chan=github&amp;data1=supertz" target="_blank" rel="noopener noreferrer">ExpressVPN</a></td>
<td>顶级品牌（需翻墙后购买）</td>
</tr>
<tr>
<td><a href="https://get.surfshark.net/aff_c?offer_id=6&amp;aff_id=3401" target="_blank" rel="noopener noreferrer">SurfShark</a></td>
<td>不限设备数（需翻墙后购买）</td>
</tr>
<tr>
<td><a href="https://www.ivacykodi.com/easter-deal-2020/?aff=91814&amp;data1=github&amp;data2=supertz" target="_blank" rel="noopener noreferrer">IvacyVPN</a></td>
<td>网速一流的VPN</td>
</tr>
</tbody>
</table>
<h2 id="_1、pandavpn-熊猫"> 1、PandaVPN（熊猫）</h2>
<p><strong>海外华人开发的VPN，在国内很好用</strong></p>
<p>熊猫VPN总部在美国，由海外华人团队开发，所以中文支持很好。</p>
<p>它的运营的时间并不长，是中国VPN市场的后期之秀，支持Windows，Mac，iOS，Android、Linux、Android TV几种主流设备。</p>
<p>熊猫VPN有国内可直接访问的镜像网站，购买后也可直接从那里下载客户端，无需访问应用商店。</p>
<p>在手机上测试了一个小时，非常好用，随机测了香港、美国的几个节点，连接非常快。试了试Youtube，视频的速度也很满意。</p>
<p>根据我的使用体验，PandaVPN在敏感时期的穿墙能力比较强，可能是它比较新的缘故，还没被墙特别“关照”。</p>
<p>PandaVPN建立连接的速度非常快，而且客户端里提供全局代理、分应用代理，很智能。</p>
<p>熊猫VPN支持银联、Paypal、信用卡等支付方式（以前支持支付宝，微信，可能支付被封了），付款7天内可退款。</p>
<p>目前有买一年送一年的优惠，到年底圣诞节可能有更大优惠，可以关注。</p>
<p><a href="https://www.panhdpe.xyz/r/22216799" target="_blank" rel="noopener noreferrer">熊猫VPN官网（中国区镜像），可直接打开</a></p>
<p>万一不能用，如何退款？</p>
<p>Panda有7天退款政策，但申请退款需要说明理由。如果你发现它在你的设备和网络环境下不能用，可以用下列方式联系客服，客服会协助你解决问题，如果确实为软件问题造成无法使用，会给你退款：</p>
<ol>
<li>打开镜像站，点击右下角的在线客服，就可以联系到客服，要在美国工作时间联系他们。</li>
<li>写邮件给 panda7x24@gmail.com，会工作日尽快回复你。</li>
<li>PandaVPN客服支持中文，所以你可以直接用中文沟通，非常方便。</li>
</ol>
<h2 id="_2、expressvpn"> 2、ExpressVPN</h2>
<p><strong>市场上最强跨设备通用翻墙软件</strong></p>
<p>最近一个重磅新闻，2020年9月起，ExpressVPN不再提供大陆用户可直接访问的镜像，但不影响客户端本身在国内使用，</p>
<p>ExpressVPN官方的说法是“受最近的政策原因影响”，不管厂商是什么想法，服务的退步都是我们的损失。</p>
<p>但是，ExpressVPN仍然是穿墙能力最强的翻墙软件之一。如果想购买，可以先用<a href="https://www.panhdpe.xyz/r/22216799" target="_blank" rel="noopener noreferrer">PandaVPN免费试用</a>，获得国外IP后，到<a href="https://www.xvbelink.com/?a_fid=tizi_vpn&amp;chan=github&amp;data1=supertz" target="_blank" rel="noopener noreferrer">ExpressVPN官网</a>购买。</p>
<p>虽然ExpressVPN在特殊时期也会有点问题，但一年中97%的时间里使用都很流畅。每年不能用的时间大致在2-3个星期，会有几天时间出现连不上，</p>
<p>ExpressVPN已经为中国网民服务了11年，是可以毫不犹豫购买的VPN，连通率应该是最高的，速度相比其他VPN软件也不慢，隐私保护技术最好，还有最重要的，客户端最好用，设备支持它最全。</p>
<p>客户端好用的VPN不少，但提供无需Google Play Store和苹果美国商店即可安装客户端的VPN厂商，恐怕ExpressVPN是仅有的几家之一，ExpressVPN还支持P2P下载，不限流量。</p>
<p>ExpressVPN真正实现全终端覆盖，包括：电脑Windows，MacOS，Linux，手机iPhone，iPad、Android，路由器Router，游戏主机PS2、XBox等。</p>
<p>ExpressVPN已通过普华永道隐私保护机制审计，ExpressVPN的无日志政策是实打实的无日志。</p>
<p>无硬盘服务器：技术上，这种服务器无法保留任何上网痕迹，重启或断掉所以信息都会被抹得一干二净。</p>
<p>智能连接：自动检测最快的服务器，自动匹配最佳节点。断线自动重连，防止流量无意间泄露，防止被监控。</p>
<p>DNS泄露保护：ExpressVPN在每台服务器上运行自己的私有加密DNS服务器，所有DNS请求都会通过这些私有的DNS服务器，严格保护隐私。</p>
<p>ExpresssVPN的缺点是它比较贵，但它是外国人在国内使用最多的软件，可见其稳定性和受信赖的程度，就好像iPhone，知道它贵，但仍然想买它。</p>
<p>ExpressVPN支持的付款方式很多，包括支付宝、银联。买一年送3个月，30天无理由退款，支持支付宝付款。</p>
<p>ExpressVPN同时支持5台设备，可配置Split Tunneling ，推荐香港、日本、新加坡、美国节点。</p>
<p><a href="https://www.xvbelink.com/?a_fid=tizi_vpn&amp;chan=github&amp;data1=supertz" target="_blank" rel="noopener noreferrer">ExpressVPN官网镜像，需翻墙后打开</a>，可以用<a href="https://www.panhdpe.xyz/r/22216799" target="_blank" rel="noopener noreferrer">PandaVPN免费试用</a>打开再购买</p>
<p>ExpressVPN提供30天内无理由退款，如果你发现它在你的设备和网络环境下用不了，你可以有两种方式联系退款：</p>
<ol>
<li>打开官网，看到右下方的“在线客服”入口，点进去就能联系客服，他们7天24小时都客服在线。</li>
<li>写邮件给 support@expressvpn.com，他们一般会在一个工作日内回复。</li>
</ol>
<p>客服不支持中文，你可以用简单一两句话来进行交流，例如：</p>
<blockquote>
<p>Hi，I would like to have a refund, because your service does not work for me. My account is xxx@xxx. Thank you.</p>
</blockquote>
<h2 id="_3、nordvpn"> 3、NordVPN</h2>
<p>NordVPN也是老牌的VPN，世界顶级的VPN厂商，之前有段时间在国内使用不稳定，不过经过一段时间的优化，NordVPN现在又非常好用了。</p>
<p>这个VPN有广泛的设备支持：Windows，Mac，Linux，Android，iOS … 没有ExpressVPN那么面面俱到，但能满足绝大多数用户的需要了。价格方面，比ExpressVPN要便宜不少。</p>
<p>在中国使用NordVPN不再需要特别操作，只需要点击快速连接（Quick Connect）按钮，客户端会自动连上最快连接。</p>
<p>NordVPN经常性的有促销活动，有些活动是官方说明“以后不会再有”，所以遇到活动就别犹豫了。</p>
<p>NordVPN官方还有所谓的优惠券，实际上赠送时长，一般是1个月，但与套餐绑定，必须买2年套餐才有用：</p>
<p><a href="https://go.nordlocker.net/aff_c?offer_id=15&amp;aff_id=38201&amp;url_id=6063&amp;aff_sub=github&amp;aff_click_id=supertz" target="_blank" rel="noopener noreferrer">NordVPN官网镜像，可直接打开</a></p>
<p>NordVPN支持30天无理由退款，如果你发现它在你的设备和网络环境下用不了，你可以写邮件 support@nordvpn.com 要求退款：</p>
<blockquote>
<p>Hi，I would like to have a refund, because your service does not work for me. My account is xxx@xxx. Thank you.</p>
</blockquote>
<h2 id="_4、surfshark"> 4、SurfShark</h2>
<p><strong>市场上少有的不限设备数量的VPN</strong></p>
<p>不限设备数量：这可能是SurfShark最大的优点，SurfShark允许用户在任意台设备上同时使用（可以分享给很多朋友了）。</p>
<p>支持设备： SurfShark支持Windows，MacOS，Linux，iOS，Android，FireTV等设备，也提供Chrome、Firefox浏览器插件。</p>
<p>智能连接： 允许按应用区分配置流量，例如迅雷正常下载，而Chrome浏览器看海外视频，很实用。</p>
<p>安全与隐私保护： SurfShark保证严格的务日志政策，提供连接时自动断网保护，能有效防止DNS泄露。</p>
<p>SurfShark目前只能通过官网购买，要先翻墙，可以用PandaVPN的免费试用，先获取国外IP，再进行购买。</p>
<p><a href="https://get.surfshark.net/aff_c?offer_id=6&amp;aff_id=3401" target="_blank" rel="noopener noreferrer">SurfShark官网地址，翻墙后打开</a>，可以用<a href="https://www.panhdpe.xyz/r/22216799" target="_blank" rel="noopener noreferrer">PandaVPN免费试用</a>打开再购买</p>
<p>SurfShark提供30天退款保证，并提供7天24小时客服，如果购买后你的设备或网络环境下无法使用，可以联系客服退款：</p>
<ol>
<li>打开官网，在右下角找到“Chat”按钮，与客服沟通</li>
<li>写邮件给 support@surfshark.com</li>
</ol>
<hr>
<div><p>转载</p>
<p><a href="https://github.com/shenqianzou" target="_blank" rel="noopener noreferrer">shenqianzou</a>/<strong><a href="https://github.com/shenqianzou/tizi" target="_blank" rel="noopener noreferrer">tizi</a></strong></p>
</div>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <category term="软件使用"/>
    <contributor>
      <name>南辞</name>
    </contributor>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">在线工具网站整理</title>
    <id>http://qiqi.dreamagain.top/software/tool/online/website/</id>
    <link href="http://qiqi.dreamagain.top/software/tool/online/website/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p><img src="https://img.shields.io/badge/%E5%9C%A8%E7%BA%BF%E5%B7%A5%E5%85%B7-blue.svg" alt=""> <img src="https://img.shields.io/badge/%E6%95%B4%E7%90%86%E7%AF%87-blue.svg" alt=""></p>
</blockquote>

<p>在学习一些技术的时候不免要安装一些必要的软件，值得高兴的是有很多网站提供了在线工具，有一些工具还是比较实用的，比如在线编译工具。我们可以打开浏览器直接在网页上运行代码，查看效果。</p>
<p>尤其在学习机器学习、神经网络的过程中搭建环境是一项费时伤神的体力活，利用网上一些搭建好基础环境的在线工具可以帮我们快速搭建好学习环境，避免在搭建学习环境的复杂流程上浪费太多时间，可以把更多精力投入到知识体系的学习中来。</p>
<p>类似的网站还是很多的，以下是觉得还不错的一些在线工具网站</p>
<h2 id="一、基础编程"> 一、基础编程</h2>
<ul>
<li>
<p><a href="https://c.runoob.com/" target="_blank" rel="noopener noreferrer">菜鸟工具</a></p>
</li>
<li>
<p><a href="https://tool.lu/" target="_blank" rel="noopener noreferrer">在线工具</a></p>
</li>
</ul>
<h2 id="二、人工智能"> 二、人工智能</h2>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <category term="在线工具"/>
    <contributor>
      <name>南辞</name>
    </contributor>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">常用工具</title>
    <id>http://qiqi.dreamagain.top/software/tool/online/common/</id>
    <link href="http://qiqi.dreamagain.top/software/tool/online/common/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<h2 id="搜索类在线工具"> 搜索类在线工具</h2>
<p>1、SearchCode（https://searchcode.com/）是一个源码搜索引擎，目前支持从 Github、Bitbucket、Google Code、CodePlex、SourceForge 和 Fedora Project 平台搜索公开的源码。</p>
<p>2、mvnrepository(<a href="http://mvnrepository.com/" target="_blank" rel="noopener noreferrer">http://mvnrepository.com</a>)这个不用详细解释了，就是查询maven的gav等信息。</p>
<p>3、Iconfont（<a href="https://www.iconfont.cn/" target="_blank" rel="noopener noreferrer">https://www.iconfont.cn</a>）国内功能很强大且图标内容很丰富的矢量图标库，提供矢量图标下载、在线存储、格式转换等功能。阿里巴巴体验团队倾力打造，设计和前端开发的便捷工具。</p>
<p>4、BinaryDoc for OpenJDK（https://openjdk.binarydoc.org/net.java/openjdk/）直接从OpenJDK二进制文件生成文档，二进制代码是最好的文档。</p>
<p>5、Unsplash（<a href="https://unsplash.com/" target="_blank" rel="noopener noreferrer">https://unsplash.com</a>）是一个免费的图片分享网站，可以在上面搜索无版权图片</p>
<p>6、鸠摩搜书（https://www.jiumodiary.com/）国内一款强大的电子书搜索引擎，整合了大部分电子书平台的资源，最重要的是他无需注册登录，可以直接下载。并且网站页面清新、且资源免费。</p>
<p>7、MySlide（https://myslide.cn/）是一个提供PPT分享服务的平台，在这里你可以找到你想要的PPT。</p>
<p>8、IT大咖说（https://www.itdks.com/）是IT垂直领域的大咖知识分享平台，分享行业TOP大咖干货，技术大会在线直播录播，在线直播知识分享平台。</p>
<h2 id="生成类在线工具"> 生成类在线工具</h2>
<p>1、BeJSON（http://www.bejson.com/json2javapojo）是一个比较好用将Json转成Java对象的工具。json是目前JavaWeb中数据传输的主要格式，很多时候会有把json转成Java对象的需求。有时候合作方会提供一个json的样例，需要我们自己定义Java类，这时候这个工具就派上用场了。</p>
<p>2、在线corn生成工具（https://cron.qqe2.com/），Cron 一般用于配置定时任务的执行。但是要想一次性的把一个corn表达式配置好确实很难的，需要程序员记住他的语法。有一些在线工具可以提供图形化的界面，只要输入想要定时执行的周期等，就可以自动生成corn表达式。</p>
<p>3、正则表达式的生成工具（http://tool.chinaz.com/tools/regexgenerate）正则表达式，又称规则表达式。（英语：Regular Expression，在代码中常简写为regex、regexp或RE），计算机科学的一个概念。正则表达式通常被用来检索、替换那些符合某个模式(规则)的文本。在使用正则表达式进行字符转过滤的时候，需要用事先定义好的一些特定字符、及这些特定字符的组合，组成一个“规则字符串”，这个“规则字符串”用来表达对字符串的一种过滤逻辑。通常，这个规则字符串的定义是比较麻烦和复杂的。也需要经过大量的测试和验证才能被采用。</p>
<p>4、 ASCII艺术生成工具（http://patorjk.com/software/taag/）可以将输入的字符快速转换成ASCII艺术文字的形式。</p>
<p>5、ProcessOn（https://www.processon.com/）是一个在线协作绘图平台，为用户提供最强大、易用的作图工具!支持在线创作流程图、BPMN、UML图、UI界面原型设计、iOS界面原型设计。</p>
<p>6、MarkDown编辑器，Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，深受广大程序员们的喜爱，推荐几款在线md编辑器：MaHua（https://mahua.jser.me/ ）
马克飞象（https://maxiang.io/ ）
Cmd(https://www.zybuluo.com/mdeditor )</p>
<h2 id="转换类在线工具"> 转换类在线工具</h2>
<p>1、站长工具的编码转换（http://tool.chinaz.com/tools/unicode.aspx ）比较全面，提供了Unicode编码、UFT8编码、URL编码/解码等功能。编码问题一直困扰着开发人员，尤其在Java 中更加明显，因为Java 是跨平台语言，不同平台之间编码之间的切换较多。计算中提拱了多种编码方式，常见的有 ASCII、ISO-8859-1、GB2312、GBK、UTF-8、UTF-16 等。有些时候开发人员需要通过编码转换的方式来查看不同编码下面的文件内容。</p>
<p>2、时间戳转换工具（http://tool.chinaz.com/Tools/unixtime.aspx），时间戳(英语：Timestamp）是指在一连串的资料中加入辨识文字，如时间或日期，用以保障本地端（local）资料更新顺序与远端（remote）一致。</p>
<p>3、Timebie（http://www.timebie.com/cn/easternbeijing.php ）提供了世界时间相互转换的功能。世界各地时间转换在做国际业务的时候会经常用到，比如北京时间转纽约时间，北京时间转洛杉矶时间。</p>
<p>4、加密解密也是JavaWeb可能会经常遇到的，有的时候我们需要验证加密算法是否正确，或者要解密等场景，就需要一个在线工具（http://tool.chinaz.com/tools/textencrypt.aspx ）来快速验证。</p>
<p>5、convertworld（https://www.convertworld.com/zh-hans/ ）是一个比较全的单位换算的网站。我经常用它进行时间单位和货币单位的换算。</p>
<p>6、Convertio（https://convertio.co/zh/flv-mp4/）是一个在线视频格式转换工具，支持多种常见视频格式，如 FLV、MOV 和 AVI 等。上传的视频文件不能超过 100 MB。</p>
<p>7、Docsmall（https://docsmall.com/image-compress）是一个在线图片压缩工具，可以批量压缩图片、Gif 图，一次最多上传 30 张图片，每张图片最大为 25 MB。</p>
<h2 id="检查类在线工具"> 检查类在线工具</h2>
<p>1、JSON格式化工具（https://www.json.cn/）是我尝试过很多同类工具之后最经常使用的一个，不仅支持json格式的验证及格式化，还可以将json格式压缩成普通文本等好用功能。有时候我们不确定这个文本是否完全符合JSON格式，有时候我们也想可以更清晰的查看这个JSON文本的格式关系。就可以使用这个工具来进行JSON格式的验证和格式化。</p>
<p>2、正则验证（http://tool.chinaz.com/regex），Java开发对正则表达式肯定不陌生。站长工具提供的这个正则验真工具还不错。</p>
<p>3、Diffchecker（<a href="http://tool.chinaz.com/regex" target="_blank" rel="noopener noreferrer">https://www.diffchecker.com/</a>）是一个使用很不错代码差异对比工具。使过svn或者git的人对diffcheck肯定不陌生，但有时候我们修改的文本内容并没有被版本控制，那么就可以使用在线的网站查看文件的修改情况。</p>
<h2 id="对照类工具"> 对照类工具</h2>
<p>1、ASCII对照表 ： http://tool.oschina.net/commons?type=4</p>
<p>2、HTTP状态码 ： http://tool.oschina.net/commons?type=5</p>
<p>3、HTTP Content-type ： http://tool.oschina.net/commons</p>
<p>4、TCP/UDP常见端口参考 ： http://tool.oschina.net/commons?type=7</p>
<p>5、HTML转义字符 ： http://tool.oschina.net/commons?type=2</p>
<p>6、RGB颜色参考 ： <a href="http://tool.oschina.net/commons?type=2" target="_blank" rel="noopener noreferrer">http://tool.oschina.net/commons?type=3</a></p>
<p>7、网页字体参考 ： http://tool.oschina.net/commons?type=8</p>
<h2 id="在线代码运行"> 在线代码运行</h2>
<p>1、在线工具的<a href="https://tool.lu/coderunner/" target="_blank" rel="noopener noreferrer">CodeRunner</a>可以在线运行php、c、c++、go、python、java、groovy等代码。</p>
<p>2、<a href="https://c.runoob.com/" target="_blank" rel="noopener noreferrer">菜鸟工具</a>  提供的编译工具支持的语言比CodeRunner多</p>
<h2 id="一个实用小插件"> 一个实用小插件</h2>
<p>最后，再给大家推荐一个chrome插件<code>FeHelper</code> ，这个插件中囊括了很多上面介绍的在线工具的功能，如JSON格式化、时间戳转换、Markdown工具、编码解码、加密解密、正则验证等。</p>
<div><p>转载</p>
<p><a href="https://www.hollischuang.com/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7" target="_blank" rel="noopener noreferrer">Holis</a></p>
</div>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <category term="在线工具"/>
    <contributor>
      <name>南辞</name>
    </contributor>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">PowerToys</title>
    <id>http://qiqi.dreamagain.top/software/tool/power-toys/</id>
    <link href="http://qiqi.dreamagain.top/software/tool/power-toys/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<h2 id="安装"> 安装</h2>
<p>您可以 <a href="https://github.com/microsoft/PowerToys/releases" target="_blank" rel="noopener noreferrer">直接下载 exe</a> 进行安装。</p>
<div><p>系统要求</p>
<p>Win10 版本 &gt; 1803，已安装 .NET Core 3.1 Desktop Runtime</p>
</div>
<p>或者使用 WinGet:</p>
<div><pre><code>WinGet <span>install</span> powertoys
</code></pre>
<div><span>1</span><br></div></div><h2 id="功能"> 功能</h2>
<p>Power toys 主要功能:</p>
<ul>
<li>图片取色</li>
<li>窗口布局管理</li>
<li>更多文件预览支持</li>
<li>图片尺寸调整</li>
<li>快捷键管理器</li>
<li>强大的文件重命名</li>
<li>快捷键指南</li>
<li>PowerToys Run</li>
</ul>
<h2 id="color-picker"> Color Picker</h2>
<p>Color Picker 是一个可以在 Win10 系统全场景下使用的颜色提取工具，通过按键 <code>Win + Shift + C</code> 启动。</p>
<p>您可以用光标在当前桌面上任意色块提取颜色，系统会自动复制颜色的 HEX 或 RGB 值。</p>
<p><img src="./assets/color-picker.gif" alt="取色器演示"></p>
<h3 id="fancyzones"> FancyZones</h3>
<p>FancyZones 是一个实用的窗口增强管理器，它能让您快速地将程序窗口按照设置好的布局来调整大小和位置排布，快捷键为 <code>Win + `</code>。</p>
<p>FancyZones 实现了更高效地利用屏幕的面积，管理切换大量窗口而不杂乱，是大屏幕用户必备的效率工具。</p>
<p>当首次启动时，FancyZones 会要求您为当前显示器选择一个默认的布局。</p>
<div><p>提示</p>
<p>请注意 FancyZones 布局是基于显示器的，所以如果您有多个显示器，您需要分别设置它们。</p>
</div>
<p><img src="./assets/layout-picker.png" alt="布局选择"></p>
<p>如果上述布局选择不能满足您的需求，您也可以点击 &quot;Custom&quot; 选项卡进行自定义。</p>
<p><img src="./assets/custom-layout.png" alt="自定义布局"></p>
<div><p>相关信息</p>
<p>更多详情，请见 <a href="https://github.com/microsoft/PowerToys/wiki/FancyZones-Overview" target="_blank" rel="noopener noreferrer">官方 Wiki</a></p>
</div>
<h2 id="资源管理器插件"> 资源管理器插件</h2>
<p>Preview Panel(预览窗格) 是一个轻量快速 Win10 的文件资源管理器插件，它能让您在无需打开文件的情况下，直接在文件资源管理器通过<strong>预览窗格</strong>预览文件内容，目前 <code>.svg</code> 与 <code>.md</code>。</p>
<p><img src="./assets/svg-preview.png" alt="SVG 预览"></p>
<p><img src="./assets/markdown-preview.png" alt="Markdown 预览"></p>
<div><p>提示</p>
<p>这两个文件的预览对开发者是十分有用的。</p>
</div>
<h2 id="图片尺寸调整"> 图片尺寸调整</h2>
<p>Image Resizer 是一个右键菜单的快速图片尺寸大小调整工具，您只需右键点击图片文件，即可选择修改一张或批量修改多张图片的大小尺寸、旋转图片方向或者转换图片格式。</p>
<p><img src="./assets/image-resizer.gif" alt="图片尺寸调整"></p>
<p>软件预设了大/中/小/手机等不同的常用模版，单击确定即可一键完成图片尺寸的批量调整。您也可以点击 Settings 进入设置，按自己需求的尺寸大小、是否转换格式等来配置自己的常用“模版”。</p>
<p><img src="./assets/image-resizer.png" alt="图片尺寸调整设置"></p>
<p>对于经常有多张图片的大小需要处理，而对专业性要求不高的用户来说，这款工具能替代专门的图像处理器软件。</p>
<p>同时，用户不仅可以导出为其他格式，也可以设置默认编码器(在不能保存为原始格式时)。</p>
<p>在导出时，也支持修改 PNG、JPEG 和 TIFF 的图片保存设置，与是否保留原来的最后修改日期。</p>
<h2 id="快捷键管理器"> 快捷键管理器</h2>
<p>Keyboard Manager 是一款简单而又实用的键盘键位修改小工具。</p>
<p>它的主要作用能帮您将键盘上的某个按键映射为另一个按键，甚至还能将一组快捷键映射为另一组。在一些特殊的情况下，它能帮您的大忙。</p>
<div><p>提示</p>
<p>Keyboard Manager 修改键位之后无需重启电脑即可立即生效。</p>
</div>
<h2 id="powerrename"> PowerRename</h2>
<p>PowerRename 是一个实用的右键菜单“批量重命名工具”，可以支持搜索/替换以及正则表达式匹配，可以添加文件名前缀后缀等。</p>
<p>为了避免出错，它在重命名之前可以让在界面上预览重命名后的结果，同时在重命名时，您可以很方便的选中全部您想要重命名的文件与文件夹，再排除指定的文件/文件夹。</p>
<div><p>一些设置选项的解释</p>
<ul>
<li><strong>使用正则表达式</strong>: 默认搜索框中为文字匹配，启用后将认为搜索框中为正则表达式。</li>
<li><strong>匹配所有出现的对象</strong>: 默认情况下只匹配项目中搜索文本的第一个实例，勾选后匹配所有。</li>
<li><strong>枚举项</strong>: 勾选后，会在在操作中修改的文件名后追加一个数字后缀。例如: <code>mrhope.jpg</code> -&gt; <code>mrhope (1).jpg</code></li>
</ul>
</div>
<h2 id="快捷键指南"> 快捷键指南</h2>
<p>该工具负责提示您当前页面可用的 Windows 快捷键。(并不包含软件内的快捷键)。</p>
<p>长按 Windows 键即可呼出此工具。</p>
<p><img src="./assets/shortcut-guide.png" alt="快捷键指南"></p>
<h2 id="powertoys-run"> PowerToys Run</h2>
<p>PowerToys Run 是一款快速启动器工具，按下 <code>Alt + Space</code> 即可随时呼出输入框。</p>
<h3 id="powertoys-run-功能"> PowerToys Run 功能</h3>
<ul>
<li>
<p>搜索</p>
<p>直接输入名字后，它能快速找到对应的软件、搜索文件/文件夹，并回车迅速打开它们。</p>
<p><img src="./assets/power-toys-search.png" alt="搜索"></p>
</li>
<li>
<p>运行软件切换</p>
<p>PowerToys Run 也支持快速搜索当前正在运行的软件，并切换到它们的窗口去。</p>
</li>
<li>
<p>终端</p>
<p>输入 <code>&gt;</code> 加您需要执行的命令，即可快速调用终端执行。</p>
<p><img src="./assets/shell-command.png" alt="终端命令"></p>
</li>
<li>
<p>简单计算</p>
<p>您可以直接输入简单的数学表达式，PowerToys Run 会直接返回结果。</p>
<p><img src="./assets/calculator.png" alt="简单计算"></p>
</li>
</ul>
<h3 id="快捷键"> 快捷键</h3>
<table>
<thead>
<tr>
<th>捷径</th>
<th>行动</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Alt + Space</code></td>
<td>打开或隐藏 PowerToys Run</td>
</tr>
<tr>
<td><code>Esc</code></td>
<td>隐藏 PowerToys Run</td>
</tr>
<tr>
<td><code>Ctrl + Shift + Enter</code></td>
<td>(仅适用于应用程序)以管理员身份打开所选的应用程序</td>
</tr>
<tr>
<td><code>Ctrl + Shift + E</code></td>
<td>(仅适用于应用程序和文件)在文件资源管理器中打开包含文件夹</td>
</tr>
<tr>
<td><code>Ctrl + C</code></td>
<td>(仅适用于文件夹和文件)复制路径位置</td>
</tr>
<tr>
<td><code>Tab</code></td>
<td>浏览搜索结果和上下文菜单按钮</td>
</tr>
</tbody>
</table>
<h3 id="过滤符"> 过滤符</h3>
<p>这些将迫使 PowerToys 只运行目标插件。</p>
<table>
<thead>
<tr>
<th>过滤符</th>
<th>行动</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>=</code></td>
<td>仅计算器。</td>
</tr>
<tr>
<td><code>?</code></td>
<td>仅文件搜索。</td>
</tr>
<tr>
<td><code>.</code></td>
<td>仅搜索安装应用</td>
</tr>
<tr>
<td><code>//</code></td>
<td>仅网址。</td>
</tr>
<tr>
<td><code>&lt;</code></td>
<td>仅运行进程。</td>
</tr>
<tr>
<td><code>&gt;</code></td>
<td>仅 Shell 命令。</td>
</tr>
</tbody>
</table>
<h2 id="视频音频静音"> 视频音频静音</h2>
<p>使用相机时，您会在屏幕上的特定位置看到一个摄像头与麦克风开启状态的对话框，您可以通过单机或一下快捷键改变它们的启用状态。</p>
<ul>
<li><code>Win + N</code>: 同时切换音频和视频</li>
<li><code>Win + Shift + O</code>: 切换视频</li>
<li><code>Win + Shift + A</code>: 切换麦克风</li>
</ul>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <contributor>
      <name>南辞</name>
    </contributor>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">Windows PowerShell</title>
    <id>http://qiqi.dreamagain.top/software/tool/powershell/</id>
    <link href="http://qiqi.dreamagain.top/software/tool/powershell/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <summary type="html"><![CDATA[<p>Powershell (Windows Powershell)是 Microsoft 为 Windows 设计的新的命令行程序，这个 Windows 内置的命令行 shell 包括交互式提示和脚本环境，它们可以独立使用也可以交互使用。</p>
]]></summary>
    <content type="html"><![CDATA[<p>Powershell (Windows Powershell)是 Microsoft 为 Windows 设计的新的命令行程序，这个 Windows 内置的命令行 shell 包括交互式提示和脚本环境，它们可以独立使用也可以交互使用。</p>

<p>我们平时所见的大多数的脚本(bat,perl,bash,sh)，接受(输入)和返回(输出)的都是文本。Powershell 是在 .Net 公共语言运行时(CLR-Common Language Runtime)和.Net Framework 的基础上构建的，所以 Powershell 可以接受和返回.Net 对象。也就是说，Powershell 是面向对象的脚本语言。</p>
<p>举个例子，如果其它的脚本语言是 C 语言(低级)，那么 Powershell 就是 Java 或是 C#(高级)。面向对象的能力使 Powershell 相比其它脚本语言有更高的开发效率，脚本更容易维护，更容易实现模块化和复用。</p>
<p>PowerShell 引入了 cmdlet 的概念(cmdlet 读作“command-let”,一看就是 cmd 的超集，事实也是如此，所有 cmd 命令都可以在 Powershell 中执行)，这是内置到 shell 中的一个简单的单一功能命令行工具。相比其它 shell，PowerShell 除了可以对计算机上文件系统的访问。还可以访问其他数据存储，如注册表和数字签名证书存储，就像访问文件系统一样容易。</p>
<h2 id="特点"> 特点</h2>
<p>Powershell 提供了丰富的内置命令，相比其它 shell 尤其独特的优势: 您不必抛弃自己惯用的工具、命令，在 Powershell 中可以使用所有的 cmd 命令。</p>
<p>Powershell 不处理文本(不把文本当做文本处理，当做.Net 对象处理)，相反，它处理基于 .Net Framework 平台的对象。</p>
<p>Powershell 附带了具有一致格式(动词-名词)的大量内置命令。</p>
<p>所有的 Powershell 命令都使用同一命令分析程序，而不是每个工具(命令)使用不同的分析程序，可以同时学习大量的命令。</p>
<h2 id="官方教程"> 官方教程</h2>
<ul>
<li><a href="https://docs.microsoft.com/zh-cn/powershell/scripting/learn/ps101/01-getting-started?view=powershell-7.1" target="_blank" rel="noopener noreferrer">官方教程</a></li>
</ul>
]]></content>
    <author>
      <name>沈启民</name>
    </author>
    <contributor>
      <name>沈启民</name>
    </contributor>
    <rights>Copyright by 沈启民</rights>
  </entry>
  <entry>
    <title type="html">工具软件</title>
    <id>http://qiqi.dreamagain.top/software/tool/</id>
    <link href="http://qiqi.dreamagain.top/software/tool/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<h2 id="目录"> 目录</h2>
<ul>
<li>
<p><a href="./power-toys.html">PowerToys</a>: Windows 实用工具合集</p>
</li>
<li>
<p><a href="https://github.com/huiyadanli/PasteEx" target="_blank" rel="noopener noreferrer">PasteEx</a>: Paste As File 把剪贴板的内容直接粘贴为文件</p>
</li>
<li>
<p><a href="https://www.typora.io/" target="_blank" rel="noopener noreferrer">typora</a>: 一个页面很漂亮的 Markdown 编辑器</p>
</li>
<li>
<p><a href="https://potplayer.daum.net/?lang=zh_CN" target="_blank" rel="noopener noreferrer">Potplayer</a>: 心目中最 NB 的视频播放器，没有之一</p>
</li>
<li>
<p><a href="./Terminal.html">Terminal</a>: Windows 终端</p>
</li>
<li>
<p><a href="./powershell.html">PowerShell</a>: Windows 的命令行外壳程序和脚本环境</p>
</li>
</ul>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <contributor>
      <name>南辞</name>
    </contributor>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">快速上手</title>
    <id>http://qiqi.dreamagain.top/software/tool/terminal/get-started/</id>
    <link href="http://qiqi.dreamagain.top/software/tool/terminal/get-started/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<h2 id="安装"> 安装</h2>
<p>您可以通过 <a href="https://aka.ms/terminal" target="_blank" rel="noopener noreferrer">Microsoft Store</a> 进行安装，同样您可以访问 <a href="https://github.com/microsoft/terminal/releases/" target="_blank" rel="noopener noreferrer">Github release</a> 下载任意版本可执行文件。</p>
<div><p>注意</p>
<p>从 GitHub 安装，终端将不会自动更新为新版本。</p>
</div>
<h2 id="使用"> 使用</h2>
<p>打开终端时，Windows Terminal 会在打开的选项卡中通过 PowerShell 作为默认配置文件启动。</p>
<p>如果已安装 WSL(Windows Subsystem for Linux) 发行版或多个版本的 PowerShell，终端将自动为您创建配置文件。</p>
<h3 id="打开新选项卡"> 打开新选项卡</h3>
<p>您可以使用 <code>Ctrl + Shift + T</code> 快捷键或选择 + (加号)按钮，打开默认配置文件的新选项卡。</p>
<p>若要打开其他配置文件，请选择 + 按钮旁的 ˅(箭头)打开下拉菜单，从中选择要打开的配置文件。</p>
<p><img src="../assets/terminal-dropdown.png" alt="下拉菜单"></p>
<h3 id="打开新窗格"> 打开新窗格</h3>
<p>可以使用窗格并行运行多个 shell。 若要打开窗格，可以使用 <code>Alt + Shift + D</code>。 此键绑定将打开焦点配置文件的重复窗格。</p>
<h3 id="配置"> 配置</h3>
<p>若要自定义 Windows Terminal 的设置，请在下拉菜单中选择“设置”。 这会在默认文本编辑器中打开 settings.json 文件。</p>
<p>终端支持自定义影响整个应用程序的全局属性、影响每个配置文件的设置的配置文件属性以及允许您使用键盘与终端交互的键绑定。</p>
<div><p>命令行参数</p>
<p>可以使用命令行参数在特定配置中启动终端。 这些参数允许通过自定义配置文件设置打开具有特定选项卡和窗格的终端。</p>
</div>
<p>详情请见 <a href="./settings.html">自定义设置</a>。</p>
<h2 id="命令行"> 命令行</h2>
<p>可以使用 <code>wt.exe</code> 从命令行打开 Windows 终端的新实例。 还可以改为使用执行别名 <code>wt</code>。</p>
<h3 id="语法"> 语法</h3>
<p><code>wt</code> 命令行接受两种类型的值: “选项”和“命令” 。 “选项”是一系列标志和其他参数，可以将 <code>wt</code> 命令行的行为作为一个整体来控制。 “命令”提供应该实现的操作或操作列表(以分号分隔)。 如果未指定命令，则默认情况下会将命令指定为 <code>new-tab</code>。</p>
<div><pre><code>wt <span>[</span>options<span>]</span> <span>[</span>command <span>;</span> <span>]</span>
</code></pre>
<div><span>1</span><br></div></div><div><p>提示</p>
<p>若要显示列出可用命令行参数的帮助消息，请输入 <code>wt -h</code></p>
</div>
<h3 id="选项和命令"> 选项和命令</h3>
<p>下面是 wt 命令行支持的命令和选项的完整列表。</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>--help</code>、<code>-h</code>、<code>-?</code>、<code>/?</code></td>
<td>显示帮助消息。</td>
</tr>
<tr>
<td><code>--maximized</code>、<code>-M</code></td>
<td>以最大化形式启动终端。</td>
</tr>
<tr>
<td><code>--fullscreen</code>、<code>-F</code></td>
<td>以全屏形式启动终端。</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>命令</th>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>new-tab</code></td>
<td><code>--profile, -p profile-name</code>、<code>--startingDirectory, -d starting-directory</code>、<code>commandline</code>、<code>--title</code></td>
<td>创建新选项卡。</td>
</tr>
<tr>
<td><code>split-pane</code></td>
<td><code>-H, --horizontal</code>、<code>-V, --vertical</code>、<code>--profile, -p profile-name</code>、<code>--startingDirectory, -d starting-directory</code>、<code>commandline</code>、<code>--title</code></td>
<td>拆分新窗格。</td>
</tr>
<tr>
<td><code>focus-tab</code></td>
<td><code>--target</code>, <code>-t</code> <code>tab-index</code></td>
<td>聚焦于特定选项卡。</td>
</tr>
</tbody>
</table>
<h3 id="参数"> 参数</h3>
<ul>
<li>
<p><code>-p</code> 标志用于指定应打开的 Windows 终端配置文件。</p>
<details><summary>例子</summary>
<p>打开 Ubuntu 20.04:</p>
<div><pre><code>wt -p <span>"Ubuntu-20.04"</span>
</code></pre>
<div><span>1</span><br></div></div></details>
</li>
<li>
<p><code>-d</code> 标志用于指定起始目录</p>
<details><summary>例子</summary>
<p>设置起始目录为 <code>D:\</code>:</p>
<div><pre><code>wt -d d:<span>\</span>
</code></pre>
<div><span>1</span><br></div></div></details>
</li>
</ul>
<h2 id="命令面板"> 命令面板</h2>
<p>通过命令面板，可以查看可以在Windows Terminal中运行的操作。</p>
<p>您可以通过键入 <code>Ctrl + Shift + P</code> 来调用命令面板。您可以将 <code>commandPalette</code> 命令添加到设置文件中的 <code>actions</code> 中进行自定义。</p>
<h3 id="向命令添加图标"> 向命令添加图标</h3>
<p>您可以通过在配置中添加 <code>icon</code> 为您的命令添加图标。图标可以是图像的路径，<a href="https://docs.microsoft.com/en-us/windows/uwp/design/style/segoe-ui-symbol-font" target="_blank" rel="noopener noreferrer">Segoe MDL2 Assets</a> 中的符号或任何字符，包括表情符号。</p>
<div><pre><code><span>{</span> <span>"icon"</span><span>:</span> <span>"C:\\Images\\my-icon.png"</span><span>,</span> <span>"name"</span><span>:</span> <span>"New tab"</span><span>,</span> <span>"command"</span><span>:</span> <span>"newTab"</span><span>,</span> <span>"keys"</span><span>:</span> <span>"ctrl+shift+t"</span> <span>}</span><span>,</span>
<span>{</span> <span>"icon"</span><span>:</span> <span>"\uE756"</span><span>,</span> <span>"name"</span><span>:</span> <span>"New tab"</span><span>,</span> <span>"command"</span><span>:</span> <span>"newTab"</span><span>,</span> <span>"keys"</span><span>:</span> <span>"ctrl+shift+t"</span> <span>}</span><span>,</span>
<span>{</span> <span>"icon"</span><span>:</span> <span>"⚡"</span><span>,</span> <span>"name"</span><span>:</span> <span>"New tab"</span><span>,</span> <span>"command"</span><span>:</span> <span>"newTab"</span><span>,</span> <span>"keys"</span><span>:</span> <span>"ctrl+shift+t"</span> <span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id="嵌套命令"> 嵌套命令</h3>
<p>嵌套命令使您可以将多个命令分组在命令面板中的一项下。下面的示例将字体大小调整命令归为一个名为“更改字体大小...”的命令选项板项。</p>
<div><pre><code><span>{</span>
    <span>"name"</span><span>:</span> <span>"Change font size..."</span><span>,</span>
    <span>"commands"</span><span>:</span> <span>[</span>
        <span>{</span> <span>"command"</span><span>:</span> <span>{</span> <span>"action"</span><span>:</span> <span>"adjustFontSize"</span><span>,</span> <span>"delta"</span><span>:</span> <span>1</span> <span>}</span> <span>}</span><span>,</span>
        <span>{</span> <span>"command"</span><span>:</span> <span>{</span> <span>"action"</span><span>:</span> <span>"adjustFontSize"</span><span>,</span> <span>"delta"</span><span>:</span> <span>-1</span> <span>}</span> <span>}</span><span>,</span>
        <span>{</span> <span>"command"</span><span>:</span> <span>"resetFontSize"</span> <span>}</span><span>,</span>
    <span>]</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h3 id="可迭代的命令"> 可迭代的命令</h3>
<p>可迭代的命令使您可以同时创建多个命令，这些命令是从设置中定义的其他对象生成的。当前，您可以为配置文件和配色方案创建可迭代的命令。在运行时，对于给定类型的每个对象，这些命令将扩展为一个命令。</p>
<p>当前，您可以遍历以下属性:</p>
<table>
<thead>
<tr>
<th>iterateOn</th>
<th>属性</th>
<th>属性语法</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>profiles</code></td>
<td><code>name</code></td>
<td><code>&quot;name&quot;: &quot;${profile.name}&quot;</code></td>
</tr>
<tr>
<td><code>profiles</code></td>
<td><code>icon</code></td>
<td><code>&quot;icon&quot;: &quot;${profile.icon}&quot;</code></td>
</tr>
<tr>
<td><code>schemes</code></td>
<td><code>name</code></td>
<td><code>&quot;name&quot;: &quot;${scheme.name}&quot;</code></td>
</tr>
</tbody>
</table>
<h3 id="隐藏命令"> 隐藏命令</h3>
<p>如果要将命令保留在键绑定列表中，但又不想让它出现在命令选项板中，则可以通过将 <code>name</code> 设置为 <code>null</code> 来隐藏它。</p>
<details><summary>例子</summary>
<p>在命令面板中隐藏“新建选项卡”操作:</p>
<div><pre><code><span>{</span> <span>"name"</span><span>:</span> <span>null</span><span>,</span> <span>"command"</span><span>:</span> <span>"newTab"</span><span>,</span> <span>"keys"</span><span>:</span> <span>"ctrl+shift+t"</span> <span>}</span>
</code></pre>
<div><span>1</span><br></div></div></details>
<h2 id="搜索"> 搜索</h2>
<p>您可以使用 <code>Ctrl + F</code> 快捷键在终端中进行搜索。</p>
<h2 id="窗格"> 窗格</h2>
<p>通过窗格，您可以在同一个选项卡中并行运行多个命令行应用程序。这可以最大程度地减少在选项卡之间切换的需求，以便您一次查看多个提示符。</p>
<h3 id="创建新窗格"> 创建新窗格</h3>
<ul>
<li><code>Alt + Shift+ +</code> 创建默认配置文件的新垂直窗格，</li>
<li><code>Alt + Shift+ -</code> 创建默认配置文件的新水平窗格，</li>
</ul>
<p>如果希望通过下拉菜单打开新窗格，可以按住 <code>Alt</code> 并单击所需的配置文件。 这会将活动窗口或窗格拆分为所选配置文件的新窗格。</p>
<blockquote>
<p>此拆分模式按具有最长边缘(可用于创建窗格)的方向进行拆分。</p>
</blockquote>
<h3 id="在窗格间进行切换"> 在窗格间进行切换</h3>
<p>按住 alt 键，则可以使用箭头键在窗格之间移动焦点。</p>
<h3 id="调整窗格大小"> 调整窗格大小</h3>
<p>可以按住 <code>Alt + Shift</code> 并使用箭头键调整焦点窗格的大小，从而调整窗格的大小。</p>
<h3 id="关闭窗格"> 关闭窗格</h3>
<p>可以键入 <code>Ctrl + Shift + W</code> 来关闭焦点窗格。</p>
<p>如果只有一个窗格，<code>Ctrl + Shift + W</code> 将关闭该选项卡。</p>
<p>与往常一样，关闭最后一个选项卡将关闭该窗口。</p>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <contributor>
      <name>南辞</name>
    </contributor>
    <published>2021-01-27T00:00:00.000Z</published>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">Windows Terminal</title>
    <id>http://qiqi.dreamagain.top/software/tool/terminal/</id>
    <link href="http://qiqi.dreamagain.top/software/tool/terminal/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <summary type="html"><![CDATA[<p>Windows Terminal 是一个面向命令行工具和 shell(如命令提示符、PowerShell 和适用于 Linux 的 Windows 子系统 (WSL))用户的新式终端应用程序。</p>
]]></summary>
    <content type="html"><![CDATA[<p>Windows Terminal 是一个面向命令行工具和 shell(如命令提示符、PowerShell 和适用于 Linux 的 Windows 子系统 (WSL))用户的新式终端应用程序。</p>

<p><img src="../assets/terminal-overview.png" alt="Windows Terminal"></p>
<h2 id="特点"> 特点</h2>
<ul>
<li>
<p>多选项卡与窗格</p>
<p>可以同时运行多个终端并自由布局与切换</p>
</li>
<li>
<p>自定义方案和配置</p>
<p>可在 Windows Terminal 中使用多种自定义命令，获得更加自然的体验。 如果不喜欢特定的键盘快捷方式，可以将其更改为您喜欢的方式。</p>
</li>
<li>
<p>强大的可配置主题</p>
<p>可以自由配置 Windows Terminal 的配色方案</p>
<p>可以在 Windows Terminal 窗口中显示背景图像和 GIF</p>
</li>
<li>
<p>扩展性，支持连接众多平台</p>
<p>任何具有命令行接口的应用程序都可以在 Windows Terminal 中运行。 这包括从 PowerShell 和命令提示符到 Azure Cloud Shell 和任何 WSL 分发 (如 Ubuntu 或 Oh-My-Zsh) 的所有应用程序。</p>
</li>
<li>
<p>Unicode 和 UTF-8 字符支持</p>
<p>Windows Terminal 可以显示 Unicode 和 UTF-8 字符，如各种语言的表情符号和字符。</p>
</li>
<li>
<p>GPU 加速文本呈现引擎</p>
<p>Windows Terminal 使用 GPU 来呈现其文本，从而提供比默认 Windows 命令行体验更好的性能。</p>
</li>
<li>
<p>开源</p>
</li>
</ul>
<h2 id="教程"> 教程</h2>
<ul>
<li><a href="./get-started.html">快速上手</a></li>
<li><a href="./settings.html">自定义设置</a></li>
</ul>
<h2 id="官方文档"> 官方文档</h2>
<ul>
<li><a href="https://aka.ms/terminal-documentation" target="_blank" rel="noopener noreferrer">官方文档</a></li>
</ul>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <contributor>
      <name>南辞</name>
    </contributor>
    <published>2021-01-27T00:00:00.000Z</published>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">自定义设置</title>
    <id>http://qiqi.dreamagain.top/software/tool/terminal/settings/</id>
    <link href="http://qiqi.dreamagain.top/software/tool/terminal/settings/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <summary type="html"><![CDATA[<p>配置文件代表着您可以在 Windows Terminal 中配置的不同的命令行环境。默认情况下，每个配置文件使用不同的命令行可执行程序，但是您可以根据自己的喜好，创建任意数量的使用同一可执行程序的配置文件。每个配置文件可以有自己的定制项以帮助您区分它们，并可以自由定制。</p>
<p>可以使用快捷键 <code>Ctrl + Shift + *</code> 来打开对应的配置文件，可使用 <code>Ctrl + ,</code> 打开 settings.json 文件，来进行个性化调整和默认设置更改等设置。</p>
]]></summary>
    <content type="html"><![CDATA[<p>配置文件代表着您可以在 Windows Terminal 中配置的不同的命令行环境。默认情况下，每个配置文件使用不同的命令行可执行程序，但是您可以根据自己的喜好，创建任意数量的使用同一可执行程序的配置文件。每个配置文件可以有自己的定制项以帮助您区分它们，并可以自由定制。</p>
<p>可以使用快捷键 <code>Ctrl + Shift + *</code> 来打开对应的配置文件，可使用 <code>Ctrl + ,</code> 打开 settings.json 文件，来进行个性化调整和默认设置更改等设置。</p>

<div><p>默认设置</p>
<p>您可以通过按住 Alt 键并点击下拉菜单中的 Settings 按钮打开 defaults.json。该文件由 Terminal 自动生成，展示了 Windows Terminal 所有默认设置及其值。更改此文件是无效的。</p>
</div>
<p>settings.json 文件分为四个主要部分:</p>
<ol>
<li>全局设置对象，它位于 JSON 文件的顶部。全局设置将影响整个应用程序。</li>
<li>配置文件设置，由 <code>profiles</code> 对象控制。负责控制每个配置文件。</li>
<li>配色方案，由 <code>schemes</code> 数组控制。</li>
<li>自定义操作，由 <code>actions</code> 数组控制</li>
</ol>
<h2 id="全局设置"> 全局设置</h2>
<p>全局设置会将影响整个终端窗口。</p>
<p>关于详细的配置项，请见 <a href="https://aka.ms/terminal-global-settings" target="_blank" rel="noopener noreferrer">全局设置</a>。</p>
<p><img src="../assets/terminal-global-settings.png" alt="全局设置"></p>
<h3 id="默认配置文件"> 默认配置文件</h3>
<p>默认配置文件为 Windows PowerShell。您可以通过在 settings.json 文件中将 <code>defaultProfile</code> 设置为首选配置文件的名称或 GUID 来更改默认配置文件。</p>
<div><pre><code><span>"defaultProfile"</span><span>:</span> <span>"PowerShell"</span>
</code></pre>
<div><span>1</span><br></div></div><h2 id="配置文件设置"> 配置文件设置</h2>
<p><code>profiles</code> 对象描述配置文件。它分为两个部分: <code>defaults</code> 和 <code>list</code>。</p>
<ul>
<li>
<p><code>defaults</code> 对象中的配置文件会应用于列表中的所有项目。</p>
</li>
<li>
<p><code>list</code> 包含代表配置文件的每个配置文件对象，这些是出现在 Windows Terminal 下拉菜单中的项目。应用于 <code>list</code> 中各个配置文件的设置会覆盖 <code>defaults</code> 部分中应用的设置。</p>
</li>
</ul>
<p>关于详细的配置项，请见 <a href="https://aka.ms/terminal-profile-settings" target="_blank" rel="noopener noreferrer">配置文件设置</a>。</p>
<p><img src="../assets/terminal-profiles.png" alt="配置文件设置"></p>
<div><p>提示</p>
<ul>
<li>
<p>您可以在 <code>defaults</code> 中设置 <code>fontFace</code> 控制终端的字体。</p>
</li>
<li>
<p>您可以在 Powershell 配置文件中添加 <code>commandline</code> 为 <code>&lt;PowerShell 地址&gt; -nologo</code> 来去除 powershell 启动时的 logo 显示。(默认地址为: <code>C:/Program Files/PowerShell/7/pwsh.exe</code>)</p>
</li>
<li>
<p>您可以通过设置 <code>backgroundImage</code> 自定义背景图片，通过 <code>backgroundImageOpacity</code> 自定义背景透明度，通过 <code>useAcrylic</code> 开启或关闭毛玻璃效果。</p>
</li>
</ul>
</div>
<h3 id="新增配置文件"> 新增配置文件</h3>
<p>Windows Terminal 会自动为 PowerShell 和 WSL 分发版创建配置文件。</p>
<p>您也可以手动添加新的配置文件: 只需生成一个新的 <code>guid</code>，提供一个 <code>name</code>，并为 <code>commandline</code> 属性提供可执行程序。</p>
<div><p>WSL</p>
<p>您可以通过 <a href="https://www.microsoft.com/zh-cn/p/ubuntu-2004-lts/9n6svws3rx71#activetab=pivot:overviewtab" target="_blank" rel="noopener noreferrer">Microsoft 应用商店</a> 安装 Ubuntu。之后便可以在 terminal 上运行 Ubuntu WSL 环境。</p>
</div>
<div><p>注意</p>
<p>您不能从动态生成的配置文件中复制 <code>source</code> 属性，否则 Windows Terminal 会忽略此配置文件。您必须使用 <code>commandline</code> 替换 <code>source</code> 并提供可执行程序，以便复制一个动态生成的配置文件。</p>
</div>
<h2 id="配色方案"> 配色方案</h2>
<p>您可以在 <code>schemes</code> 数组中配置自定义配色方案。它们是使用以下格式写入的:</p>
<div><pre><code><span>{</span>
  <span>"name"</span> <span>:</span> <span>"Campbell"</span><span>,</span>

  <span>"cursorColor"</span><span>:</span> <span>"#FFFFFF"</span><span>,</span>
  <span>"selectionBackground"</span><span>:</span> <span>"#FFFFFF"</span><span>,</span>

  <span>"background"</span> <span>:</span> <span>"#0C0C0C"</span><span>,</span>
  <span>"foreground"</span> <span>:</span> <span>"#CCCCCC"</span><span>,</span>

  <span>"black"</span> <span>:</span> <span>"#0C0C0C"</span><span>,</span>
  <span>"blue"</span> <span>:</span> <span>"#0037DA"</span><span>,</span>
  <span>"cyan"</span> <span>:</span> <span>"#3A96DD"</span><span>,</span>
  <span>"green"</span> <span>:</span> <span>"#13A10E"</span><span>,</span>
  <span>"purple"</span> <span>:</span> <span>"#881798"</span><span>,</span>
  <span>"red"</span> <span>:</span> <span>"#C50F1F"</span><span>,</span>
  <span>"white"</span> <span>:</span> <span>"#CCCCCC"</span><span>,</span>
  <span>"yellow"</span> <span>:</span> <span>"#C19C00"</span><span>,</span>
  <span>"brightBlack"</span> <span>:</span> <span>"#767676"</span><span>,</span>
  <span>"brightBlue"</span> <span>:</span> <span>"#3B78FF"</span><span>,</span>
  <span>"brightCyan"</span> <span>:</span> <span>"#61D6D6"</span><span>,</span>
  <span>"brightGreen"</span> <span>:</span> <span>"#16C60C"</span><span>,</span>
  <span>"brightPurple"</span> <span>:</span> <span>"#B4009E"</span><span>,</span>
  <span>"brightRed"</span> <span>:</span> <span>"#E74856"</span><span>,</span>
  <span>"brightWhite"</span> <span>:</span> <span>"#F2F2F2"</span><span>,</span>
  <span>"brightYellow"</span> <span>:</span> <span>"#F9F1A5"</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><p>关于详细的配置项，请见 <a href="https://aka.ms/terminal-color-schemes" target="_blank" rel="noopener noreferrer">配置文件设置</a>。</p>
<h3 id="自带的配色方案"> 自带的配色方案</h3>
<p>Windows Terminal 在 defaults.json 文件中包含了一些配色方案。如果要在一个命令行配置文件中设置配色方案，请添加 <code>colorScheme</code> 属性，并将配色方案的 <code>name</code> 作为值。</p>
<div><pre><code><span>"colorScheme"</span><span>:</span> <span>"COLOR SCHEME NAME"</span>
</code></pre>
<div><span>1</span><br></div></div><p>查看各配色方案效果，请见 <a href="https://aka.ms/terminal-color-schemes#included-color-schemes" target="_blank" rel="noopener noreferrer">包含的配色方案</a>。</p>
<h3 id="自定义配色方案"> 自定义配色方案</h3>
<p>下面提供几个主题色工具:</p>
<ul>
<li><a href="https://terminal.sexy/" target="_blank" rel="noopener noreferrer">terminal.sexy</a></li>
<li><a href="https://windowsterminalthemes.dev/" target="_blank" rel="noopener noreferrer">Windows Terminal Themes</a></li>
<li><a href="https://terminalsplash.com/" target="_blank" rel="noopener noreferrer">TerminalSplash</a>，</li>
</ul>
<h2 id="自定义操作"> 自定义操作</h2>
<p>您可以在Windows终端中创建自定义操作，以控制与终端的交互方式。这些操作将自动添加到命令面板。</p>
<p>关于详细的配置项，请见 <a href="https://aka.ms/terminal-keybindings" target="_blank" rel="noopener noreferrer">自定义操作设置</a>。</p>
<p><img src="../assets/terminal-actions.png" alt="自定义操作"></p>
<p>自定义操作可以设置为以下格式:</p>
<ul>
<li>
<p>无参数命令</p>
<div><pre><code><span>{</span> <span>"command"</span><span>:</span> <span>"命令名称"</span><span>,</span> <span>"keys"</span><span>:</span> <span>"快捷键"</span> <span>}</span>
</code></pre>
<div><span>1</span><br></div></div><details><summary>例子</summary>
<div><pre><code><span>{</span> <span>"command"</span><span>:</span> <span>"closeWindow"</span><span>,</span> <span>"keys"</span><span>:</span> <span>"alt+f4"</span> <span>}</span>
</code></pre>
<div><span>1</span><br></div></div></details>
</li>
<li>
<p>有参数命令</p>
<div><pre><code><span>{</span> <span>"command"</span><span>:</span> <span>{</span> <span>"action"</span><span>:</span> <span>"commandName"</span><span>,</span> <span>"argument"</span><span>:</span> <span>"value"</span> <span>}</span><span>,</span> <span>"keys"</span><span>:</span> <span>"modifiers+key"</span> <span>}</span>
</code></pre>
<div><span>1</span><br></div></div><details><summary>例子</summary>
<div><pre><code><span>{</span> <span>"command"</span><span>:</span> <span>{</span> <span>"action"</span><span>:</span> <span>"newTab"</span><span>,</span> <span>"index"</span><span>:</span> <span>0</span> <span>}</span><span>,</span> <span>"keys"</span><span>:</span> <span>"ctrl+shift+1"</span> <span>}</span>
</code></pre>
<div><span>1</span><br></div></div></details>
</li>
</ul>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <contributor>
      <name>南辞</name>
    </contributor>
    <published>2021-01-27T00:00:00.000Z</published>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">快速上手</title>
    <id>http://qiqi.dreamagain.top/software/vscode/get-started/</id>
    <link href="http://qiqi.dreamagain.top/software/vscode/get-started/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<h2 id="vs-code-界面"> VS Code 界面</h2>
<div><p>提示</p>
<p>在完成 VSCode 安装并首次打开 VSCode 的时候，右下角会提示安装简体中文扩展，请点击安装。</p>
<p>如果忘记点击或没有弹窗，请到侧边栏扩展搜索找到 &quot;Chinese (Simplified) Language Pack for Visual Studio Code&quot; 扩展进行安装，即可将 VSCode 改为中文页面。</p>
</div>
<p><img src="./assets/layout.png" alt="VSCode UI 页面"></p>
<p>VS Code 最上方有一排菜单栏，其中有大量的快捷操作，对应的组合键会标于快捷操作旁。如果不能记忆快捷键可以到最上方的菜单栏处查看。</p>
<p>最左侧是选项卡切换，从上至下依次是、、、和。</p>
<p>最下方的一条是状态栏。从左到右依次是分支名称、同步状态、错误和警告个数、光标位置、缩进大小、编码格式、行尾序列、文件格式、反馈和通知。</p>
<h3 id="资源管理器"> 资源管理器</h3>
<p>资源管理器是最常使用的界面，快捷键为 <code>Ctrl + Shift + E</code>。资源管理器会列出当前项目内的所有文档，支持大纲展示。</p>
<h3 id="搜索"> 搜索</h3>
<p>搜索界面可以方便的对打开文件夹内的所有文本型文件进行关键字的搜索。搜索结果会详细的列出来，快捷键为 <code>Ctrl + Shift + F</code>。</p>
<p>搜索内容支持大小写敏感/不敏感、全字匹配、指定目录/文件搜索、正则表达式等高级功能。</p>
<h3 id="源代码管理"> 源代码管理</h3>
<p>源代码管理提供快速暂存、提交并同步更改的功能，快捷键为 <code>Ctrl + Shift + G</code>。源代码可以快速对当前项目文件进行暂存、打包与推送。</p>
<p>使用源代码需要安装 Git，详情请见请见 <a href="./../git/">Git 使用说明</a>。</p>
<h3 id="调试"> 调试</h3>
<p>在这里可以调试代码，快捷键为 <code>Ctrl + Shift + D</code>。针对不同的语言，您可能需要安装不同的扩展。</p>
<p>按下 F5 开始进行调试。在初次调试前，您可能要选择当前的环境与调试的内容。</p>
<h3 id="扩展组件"> 扩展组件</h3>
<p>VS Code 强大就强大在其丰富的扩展。尽管 VS Code 在安装后是一个轻量的编辑器，但是如果您安装了您所需的合适扩展，您完全可以将其配置成 IDE。</p>
<p>在商店中可以找到大量的扩展，快捷键为 <code>Ctrl + Shift + X</code>。对于功能相近的插件，尽量选择一些 star 数比较高的插件安装。</p>
<p>每个插件的主页通常会有对应的说明文件，安装插件后请仔细阅读说明文档以了解插件的用法。</p>
<h2 id="强大的扩展内容"> 强大的扩展内容</h2>
<p>VS Code 扩展允许第三方添加对以下内容的支持:</p>
<ul>
<li>语言: 如 C++，C＃，Go，Java，Python，PHP，dart</li>
<li>工具: 如 ESLint，JSHint，PowerShell</li>
<li>调试器: Chrome，PHP XDebug，dart，Java</li>
<li>键盘映射: Vim，Sublime Text，IntelliJ，Emacs，Atom，Visual Studio，Eclipse</li>
</ul>
<p>扩展集成到 VS Code 的 UI，命令和任务运行系统中，因此您将发现通过 VS Code 的共享界面可以轻松使用不同的技术。</p>
<p>扩展可以通过按 <code>F1</code> 或者 <code>Ctrl + Shift + P</code> 来打开命令行窗口，并输入 <code>ext install 扩展名称</code> 来进行安装</p>
<div><p>提示</p>
<p>一些非常有用的扩展请见 <a href="./extension.html#推荐扩展">VS Code 推荐扩展</a></p>
</div>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <category term="VS Code"/>
    <contributor>
      <name>南辞</name>
    </contributor>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">基础内容介绍</title>
    <id>http://qiqi.dreamagain.top/software/vscode/guide/basic/</id>
    <link href="http://qiqi.dreamagain.top/software/vscode/guide/basic/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<h2 id="入门"> 入门</h2>
<p>打开 <strong>欢迎使用</strong> 页面，开始使用 VS Code 的基础知识。<strong>帮助 &gt; 欢迎</strong></p>
<p><img src="./assets/welcome.png" alt="欢迎使用"></p>
<p>在 <strong>欢迎</strong> 页面的右下角，有一个指向 <strong>交互式游乐场</strong> 的链接，您可以在其中交互式地试用 VS Code 的功能。<strong>帮助 &gt; 交互式游乐场</strong></p>
<p><img src="./assets/interactive-playground.png" alt="交互式游乐场"></p>
<h2 id="命令面板"> 命令面板</h2>
<p>根据您的当前上下文访问所有可用命令。</p>
<p>键盘快捷键: <code>Ctrl + Shift + P</code></p>
<p><img src="./assets/command-palette.png" alt="命令面板"></p>
<h2 id="默认键盘快捷键"> 默认键盘快捷键</h2>
<p>所有命令都在命令面板中，并带有关联的键绑定(如果存在)。如果您忘记了键盘快捷键，请使用 <strong>命令面板</strong> 来帮助您。</p>
<p><img src="./assets/command-check.png" alt="查看命令与对应快捷键"></p>
<h2 id="错误和警告"> 错误和警告</h2>
<p>键盘快捷键: <code>Ctrl + Shift + M</code></p>
<p><img src="./assets/error.png" alt="错误和警告"></p>
<p>快速跳转到项目中的错误和警告。</p>
<p>通过 <code>F8</code> 或 <code>Shift + F8</code> 在错误中循环</p>
<p>您可以在问题面板右上角的筛选器中按类型 (errors, warnings) 或文本匹配来过滤问题。</p>
<h2 id="集成终端"> 集成终端</h2>
<p>键盘快捷键: <code>Ctrl + `</code></p>
<div><p>深入了解</p>
<ul>
<li><a href="https://code.visualstudio.com/docs/editor/integrated-terminal" target="_blank" rel="noopener noreferrer">集成终端文档</a></li>
<li><a href="https://www.growingwiththeweb.com/2017/03/mastering-vscodes-terminal.html" target="_blank" rel="noopener noreferrer">精通 VS Code 终端的文章</a></li>
</ul>
</div>
<h2 id="键盘参考表"> 键盘参考表</h2>
<p><a href="./assets/vscodeKeyboardShortcutsWindows.pdf">Windows 下 VSCode 快捷键指南</a> (英文)</p>
<h2 id="快速打开"> 快速打开</h2>
<p>快速打开文件。</p>
<p>键盘快捷键: <code>Ctrl + P</code></p>
<p><img src="./assets/quick-open.png" alt="快速打开"></p>
<div><p>提示</p>
<p>键入 <code>?</code> 查看命令建议。</p>
<p><img src="./assets/suggestions.png" alt="命令建议"></p>
<p>键入命令，例如 <code>edt</code> 和 <code>term</code> 后跟一个空格，将显示下拉列表。</p>
</div>
<h2 id="最近打开的文件之间的浏览"> 最近打开的文件之间的浏览</h2>
<p>重复快速打开键盘快捷键，以在最近打开的文件之间快速循环。</p>
<h2 id="从快速打开打开多个文件"> 从快速打开打开多个文件</h2>
<p>您可以通过按向鼠标右键从 <strong>快速打开</strong> 中打开多个文件。这将在后台打开当前选择的文件，您可以继续从 <strong>快速打开</strong> 中选择文件。</p>
<h2 id="最近打开的文件夹和工作区之间导航"> 最近打开的文件夹和工作区之间导航</h2>
<p>键盘快捷键: <code>Ctrl + R</code></p>
<p>显示快速挑选下拉从列表 <code>文件 &gt; 打开最近</code>。优先使用最近打开的文件夹和工作空间，然后是文件。</p>
<p><img src="./assets/recent-open.png" alt="最近打开"></p>
<h2 id="更改语言模式"> 更改语言模式</h2>
<p>键盘快捷键: <code>Ctrl + K M</code></p>
<p><img src="./assets/ext-assosiate.png" alt="语言关联"></p>
<p>如果要保留特定文件类型的语言模式，则可以使用 <strong>XX 的配置文件关联</strong> 命令将当前文件扩展名与安装的语言相关联。</p>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <category term="VS Code"/>
    <contributor>
      <name>南辞</name>
    </contributor>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">命令行</title>
    <id>http://qiqi.dreamagain.top/software/vscode/guide/command/</id>
    <link href="http://qiqi.dreamagain.top/software/vscode/guide/command/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<p>VS Code 具有强大的命令行界面(CLI)，可让您自定义启动编辑器以支持各种情况的方式。</p>
<p>确保 VS Code 可执行文件已经添加到您的环境变量。只需键入 <code>code</code> 即可启动 VS Code。</p>
<div><pre><code><span># 使用 code 打开当前文件夹</span>
code <span>.</span>

<span># 在最近使用面板</span>
code -r <span>.</span>

<span># 打开新窗口</span>
code -n

<span># 改编当前语言</span>
code --locale<span>=</span>es

<span># 打开文件比较器</span>
code --diff <span>&lt;</span>file<span><span>1</span>></span> <span>&lt;</span>file<span><span>2</span>></span>

<span># 打开文件并跳转到指定的行(和列)</span>
code --goto package.json:10:5

<span># 查看帮助选项</span>
code --help

<span># 禁用所有扩展</span>
code --disable-extensions <span>.</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><h2 id="vscode-文件夹"> .vscode 文件夹</h2>
<p>基于工作区的 <code>.vscode</code> 文件夹位于根目录下。例如任务运行对应的 <code>tasks.json</code> 配置文件和调试器对应的 <code>launch.json</code> 文件。</p>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <category term="VS Code"/>
    <contributor>
      <name>南辞</name>
    </contributor>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">个性化</title>
    <id>http://qiqi.dreamagain.top/software/vscode/guide/customization/</id>
    <link href="http://qiqi.dreamagain.top/software/vscode/guide/customization/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<p>您可以做很多事情来个性化 VS Code。</p>
<ul>
<li>改变您的主题</li>
<li>改变您的文件图标</li>
<li>更改键盘快捷键</li>
<li>调整设置</li>
<li>安装扩展</li>
</ul>
<h2 id="更改主题"> 更改主题</h2>
<p>键盘快捷键: <code>Ctrl + K Ctrl + T</code></p>
<p>您可以从 VS Code 扩展市场中安装更多主题。</p>
<p>此外，您可以安装和更改文件图标主题。</p>
<div><p>提示</p>
<p>Mr.Hope 个人推荐 <code>One Dark Pro</code> 主题和 <code>Material Icon Theme</code> 文件图标主题。</p>
<p>您需要从扩展应用应用商店中安装它们。</p>
</div>
<h2 id="自定义键盘快捷键"> 自定义键盘快捷键</h2>
<p>键盘快捷键: <code>Ctrl + K Ctrl + S</code></p>
<p>您可以搜索快捷方式并将自己的键绑定添加到 <code>keybindings.json</code> 文件中。</p>
<p>有关更多信息，请参见 <a href="./../shortcut-key.html#快捷键编辑器">快捷键键绑定</a>。</p>
<h2 id="调整您的设置"> 调整您的设置</h2>
<p>默认情况下，VS Code 显示 <strong>设置</strong> 编辑器，您还可以通过使用 <strong>打开设置(JSON)</strong> 命令打开 <code>settings.json</code>。</p>
<p>键盘快捷键: <code>Ctrl + ,</code></p>
<p><strong>示例</strong>:</p>
<ul>
<li>
<p>更改各种 UI 元素的字体大小</p>
<div><pre><code><span>// Main editor</span>
<span>"editor.fontSize"</span><span>:</span> <span>18</span><span>,</span>
<span>// Terminal panel</span>
<span>"terminal.integrated.fontSize"</span><span>:</span> <span>14</span><span>,</span>
<span>// Output panel</span>
<span>"[Log]"</span><span>:</span> <span>{</span>
    <span>"editor.fontSize"</span><span>:</span> <span>15</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div></li>
<li>
<p>更改缩放等级</p>
<div><pre><code><span>"window.zoomLevel"</span><span>:</span> <span>5</span>
</code></pre>
<div><span>1</span><br></div></div></li>
<li>
<p>字体连字</p>
<div><pre><code><span>"editor.fontFamily"</span><span>:</span> <span>"Fira Code"</span><span>,</span>
<span>"editor.fontLigatures"</span><span>:</span> <span>true</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><div><p>提示</p>
<p>这需要安装支持字体连字的字体。FiraCode 是 VS Code 团队中流行的字体。</p>
<p>Mr.Hope 也强力推荐安装并使用这一字体 (字体详见云文档共享文件)</p>
</div>
</li>
<li>
<p>自动保存</p>
<div><pre><code><span>"files.autoSave"</span><span>:</span> <span>"afterDelay"</span>
</code></pre>
<div><span>1</span><br></div></div><p>您也可以使用 <code>文件 &gt; 自动保存</code> 从顶层菜单切换自动保存。</p>
</li>
<li>
<p>保存时格式化</p>
<div><pre><code><span>"editor.formatOnSave"</span><span>:</span> <span>true</span>
</code></pre>
<div><span>1</span><br></div></div></li>
<li>
<p>粘贴格式</p>
<div><pre><code><span>"editor.formatOnPaste"</span><span>:</span> <span>true</span>
</code></pre>
<div><span>1</span><br></div></div></li>
<li>
<p>更改制表符的大小</p>
<div><pre><code><span>"editor.tabSize"</span><span>:</span> <span>4</span>
</code></pre>
<div><span>1</span><br></div></div></li>
<li>
<p>空格或制表符</p>
<div><pre><code><span>"editor.insertSpaces"</span><span>:</span> <span>true</span>
</code></pre>
<div><span>1</span><br></div></div></li>
<li>
<p>渲染空白</p>
<div><pre><code><span>"editor.renderWhitespace"</span><span>:</span> <span>"all"</span>
</code></pre>
<div><span>1</span><br></div></div><p>默认情况下，在文本选择中呈现空白字符。</p>
</li>
<li>
<p>忽略文件/文件夹</p>
<p>从编辑器窗口中删除这些文件/文件夹。</p>
<div><pre><code><span>"files.exclude"</span><span>:</span> <span>{</span>
    <span>"somefolder/"</span><span>:</span> <span>true</span><span>,</span>
    <span>"somefile"</span><span>:</span> <span>true</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>从搜索结果中删除这些文件/文件夹。</p>
<div><pre><code><span>"search.exclude"</span><span>:</span> <span>{</span>
    <span>"someFolder/"</span><span>:</span> <span>true</span><span>,</span>
    <span>"somefile"</span><span>:</span> <span>true</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div></li>
</ul>
<p>以及许多其他定制。</p>
<h2 id="语言特定的设置"> 语言特定的设置</h2>
<p>您可以通过语言标识符来确定只需要特定语言的设置的范围。您可以在 <a href="https://code.visualstudio.com/docs/languages/identifiers" target="_blank" rel="noopener noreferrer">语言标识符</a> 参考中找到常用语言 ID 的列表。</p>
<div><pre><code><span>"[languageid]"</span><span>:</span> <span>{</span>

<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><div><p>提示</p>
<p>您还可以使用 <strong>配置语言特定的设置</strong> 命令来创建特定于语言的设置。</p>
</div>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <category term="VS Code"/>
    <contributor>
      <name>南辞</name>
    </contributor>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">调试</title>
    <id>http://qiqi.dreamagain.top/software/vscode/guide/debug/</id>
    <link href="http://qiqi.dreamagain.top/software/vscode/guide/debug/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<h2 id="配置调试器"> 配置调试器</h2>
<p>打开命令面板(<code>Ctrl + Shift + P</code>)，然后选择 <strong>调试: 打开 launch.json</strong>，这将提示您选择与项目(Node.js，Python，C ++等)匹配的环境。这将生成一个 <code>launch.json</code> 文件。Node.js 支持是内置的，其他环境要求安装适当的语言扩展。有关更多详细信息，请参见 <a href="https://code.visualstudio.com/docs/editor/debugging" target="_blank" rel="noopener noreferrer">调试文档</a>。</p>
<p><img src="./assets/configure-debug.gif" alt="配置调试"></p>
<h2 id="断点并逐步执行"> 断点并逐步执行</h2>
<p>在行号旁边放置断点。使用 <strong>调试</strong> 小部件向前导航。</p>
<p><img src="./assets/node-debug.gif" alt="调试"></p>
<h2 id="数据检查"> 数据检查</h2>
<p>在 <strong>运行</strong> 面板和控制台中检查变量。</p>
<p><img src="./assets/debug-data-inspection.gif" alt="数据检查"></p>
<h2 id="内嵌值"> 内嵌值</h2>
<p>您可以设置 <code>&quot;debug.inlineValues&quot;: true</code> 在调试器中内联查看变量值。此功能开销很大，并且可能会减慢步进速度，因此默认情况下禁用此功能。</p>
<h2 id="logpoints"> Logpoints</h2>
<p>日志点的行为很像断点，但它们不会在命中时暂停调试器，而是在控制台中记录一条消息。日志点对于调试无法修改或暂停的生产服务器时注入日志特别有用。</p>
<p>使用左侧编辑器装订线中的 <strong>添加日志点</strong> 命令添加日志点，该日志点将显示为 🔸 形状的图标。日志消息是纯文本，但可以包含要在花括号('{}')中计算的表达式。</p>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <category term="VS Code"/>
    <contributor>
      <name>南辞</name>
    </contributor>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">编辑技巧</title>
    <id>http://qiqi.dreamagain.top/software/vscode/guide/edit/</id>
    <link href="http://qiqi.dreamagain.top/software/vscode/guide/edit/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<p>这是编辑代码的一些常用功能。如果您不喜欢键盘快捷键，请考虑为旧的编辑器安装键盘映射扩展名。</p>
<h2 id="多光标选择"> 多光标选择</h2>
<p>要在任意位置添加光标，请用鼠标选择一个位置，然后使用 <code>Alt + Click</code>。</p>
<p>要将光标设置在当前位置之上或之下，请使用:</p>
<p>键盘快捷键: <code>Ctrl + Alt + ↑</code> 或 <code>Ctrl + Alt + ↓</code></p>
<p>您可以使用 <code>Ctrl + Shift + L</code> 将附加光标添加到当前选择的所有实例中。</p>
<p>如果不想添加所有当前选中项，则可以使用 <code>Ctrl + D</code> 代替。这只会选择您选择的选中项之后的下一个选中项，因此您可以一个一个地添加选择。</p>
<h2 id="列-盒-选择"> 列(盒)选择</h2>
<p>您可以在拖动鼠标时按住 <code>Shift + Alt</code>(在 macOS 上为 <code>Shift + Option</code>)来选择文本块。一个单独的光标将被添加到每一行的末尾。</p>
<p><img src="./assets/column-select.gif" alt="列文字选择"></p>
<p>您也可以使用键盘快捷键来触发列选择。</p>
<h2 id="直标尺"> 直标尺</h2>
<p>您可以使用该 <code>editor.rulers</code> 设置将垂直列标尺添加到编辑器中。</p>
<div><pre><code><span>{</span>
  <span>"editor.rulers"</span><span>:</span> <span>[</span><span>20</span><span>,</span> <span>40</span><span>,</span> <span>60</span><span>]</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id="快速滚动"> 快速滚动</h2>
<p>按 <code>Alt</code> 键可在编辑器和资源管理器中快速滚动。默认情况下，快速滚动使用 5 倍速倍增器，但是您可以使用 <code>editor.fastScrollSensitivity</code> 设置来控制倍增器。</p>
<h2 id="向上-向下复制行"> 向上 / 向下复制行</h2>
<p>键盘快捷键: <code>Shift + Alt + ↑</code> 或 <code>Shift + Alt + ↓</code></p>
<div><p>相关信息</p>
<p>由于按键冲突，在 Linux 上，向上 / 向下复制行没有默认的快捷键，您可以自行通过 <code>editor.action.copyLinesUpAction</code> 和 <code>editor.action.copyLinesDownAction</code> 设置自己的首选键盘快捷键。</p>
</div>
<h2 id="上下移动行号"> 上下移动行号</h2>
<p>键盘快捷键: <code>Alt + ↑</code> 或 <code>Alt + ↓</code></p>
<h2 id="缩小-扩大选择"> 缩小/扩大选择</h2>
<p>键盘快捷键: <code>Shift + Alt + ←</code> 或 <code>Shift + Alt + →</code></p>
<h2 id="转到文件中的符号"> 转到文件中的符号</h2>
<p>键盘快捷键: <code>Ctrl + Shift + O</code></p>
<p><img src="./assets/goto-file-symbol.png" alt="按符号查找"></p>
<p>您可以通过添加冒号将符号按种类分组 <code>@:</code>。</p>
<h2 id="转到工作区中的符号"> 转到工作区中的符号</h2>
<p>键盘快捷键: <code>Ctrl + T</code></p>
<p><img src="./assets/goto-workspace-symbol.png" alt="转到工作区中的符号"></p>
<h2 id="大纲视图"> 大纲视图</h2>
<p><strong>文件资源管理器</strong> 中的 <strong>大纲</strong> 视图(默认折叠在底部)显示了当前打开文件的符号。</p>
<p><img src="./assets/outlilne-view.png" alt="轮廓图"></p>
<p>您可以按符号名称，类别和文件中的位置进行排序，并可以快速导航到符号位置。</p>
<h2 id="导航到特定行"> 导航到特定行</h2>
<p>键盘快捷键: <code>Ctrl + G</code></p>
<h2 id="恢复光标位置"> 恢复光标位置</h2>
<p>键盘快捷键: <code>Ctrl + U</code></p>
<h2 id="修剪尾随空格"> 修剪尾随空格</h2>
<p>键盘快捷键: <code>Ctrl + K Ctrl + X</code></p>
<h2 id="转换文本命令"> 转换文本命令</h2>
<p>您可以使用 <strong>命令面板</strong> 中的 <strong>转换</strong> 命令将选定的文本更改为大写，小写和标题。</p>
<p><img src="./assets/transform.png" alt="转换文字指令"></p>
<h2 id="代码格式化"> 代码格式化</h2>
<p>当前选择的源代码: <code>Ctrl + K Ctrl + F</code></p>
<p>整个文档格式: <code>Shift + Alt + F</code></p>
<h2 id="代码折叠"> 代码折叠</h2>
<p>键盘快捷键: <code>Ctrl + Shift + [</code> 和 <code>Ctrl + Shift +]</code></p>
<p>您还可以使用全部折叠(<code>Ctrl + K Ctrl + 0</code>)和全部展开(<code>Ctrl + K Ctrl + J</code>)来折叠/展开编辑器中的所有区域。</p>
<p>您可以使用 <strong>折叠所有块注释</strong>(<code>Ctrl + K Ctrl + /</code>)折叠所有块注释。</p>
<h2 id="选择当前行"> 选择当前行</h2>
<p>键盘快捷键: <code>Ctrl + L</code></p>
<h2 id="导航到文件的开头和结尾"> 导航到文件的开头和结尾</h2>
<p>键盘快捷键: <code>Ctrl + Home</code> 和 <code>Ctrl + End</code></p>
<h2 id="打开-markdown-预览"> 打开 Markdown 预览</h2>
<p>在 Markdown 文件中，使用</p>
<p>键盘快捷键: <code>Ctrl + Shift + V</code></p>
<p><img src="./assets/markdown-preview.png" alt="Markdown 预览"></p>
<h2 id="并排-markdown-编辑和预览"> 并排 Markdown 编辑和预览</h2>
<p>在 Markdown 文件中，使用</p>
<p>键盘快捷键: <code>Ctrl + K V</code></p>
<p>预览和编辑器将与您在任一视图中的滚动同步。</p>
<p><img src="./assets/markdown-side-preview.png" alt="并排 Markdown 预览"></p>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <category term="VS Code"/>
    <contributor>
      <name>南辞</name>
    </contributor>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">扩展</title>
    <id>http://qiqi.dreamagain.top/software/vscode/guide/extension/</id>
    <link href="http://qiqi.dreamagain.top/software/vscode/guide/extension/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<p>键盘快捷键: <code>Ctrl + Shift + X</code></p>
<h2 id="查找扩展"> 查找扩展</h2>
<ol>
<li>在 VS Code 应用商店</li>
<li>在 VSCode 侧边栏中的 <strong>扩展</strong> 选项卡</li>
<li>查看扩展建议</li>
<li>社区策划的扩展列表，例如 awesome-vscode。</li>
</ol>
<p><img src="./assets/extension.png" alt="扩展选项卡"></p>
<h2 id="安装扩展"> 安装扩展</h2>
<p>在扩展视图中，您可以通过搜索栏进行搜索，或单击 <strong>更多(...)</strong> 按钮以按安装数量进行过滤和排序。</p>
<h2 id="扩展建议"> 扩展建议</h2>
<p>在 <strong>扩展</strong> 视图中，单击 <strong>更多(...)</strong> 按钮菜单中的 <strong>显示推荐的扩展</strong>。</p>
<h2 id="推荐扩展"> 推荐扩展</h2>
<p>以下是推荐的 VS Code 扩展:</p>
<h3 id="语言包"> 语言包</h3>
<h4 id="chinese-simplified-language-pack-for-visual-studio-code"> Chinese (Simplified) Language Pack for Visual Studio Code</h4>
<p>VS Code 原生为英文，本插件为 VS Code 提供简体中文支持，会更改页面为简体中文</p>
<h3 id="外观"> 外观</h3>
<h4 id="bracket-pair-colorizer-2"> Bracket Pair Colorizer 2</h4>
<p>为 VS Code 显示彩虹括号，在码代码时帮助判断匹配括号</p>
<h4 id="indent-rainbow"> indent-rainbow</h4>
<p>为代码中的缩进上色，更容易判断缩进层数</p>
<h4 id="material-icon-theme"> Material Icon Theme</h4>
<p>为 VS Code 文件图标应用安卓的 Material 主题</p>
<h4 id="one-dark-pro"> One Dark Pro</h4>
<p>为添加一款类 Atom 的一款暗色风格主题，配色会比 VS Code 默认风格好看一些</p>
<h4 id="todo-highlight"> TODO Highlight</h4>
<p>高光显示特定注释，如 <code>TODO:</code> 等</p>
<h3 id="工具"> 工具</h3>
<h4 id="bookmarks"> Bookmarks</h4>
<p>在代码中添加书签并支持快速跳转</p>
<h4 id="filesize"> filesize</h4>
<p>在 VS Code 底部状态栏显示文件大小</p>
<h4 id="project-manager"> Project Manager</h4>
<p>快速打开特定项目或在多个项目之间切换</p>
<h4 id="svg-viewer"> SVG Viewer</h4>
<p>提供在 VS Code 直接打开 SVG 的快捷菜单与支持</p>
<h4 id="visual-studio-intellicode"> Visual Studio IntelliCode</h4>
<p>基于 AI 的智能提示</p>
<h3 id="版本管理与多人协作"> 版本管理与多人协作</h3>
<div><p>提示</p>
<p>VS Code 不包含 Git，请自行安装 Git 并添加到 path 以实现版本管理。</p>
</div>
<h4 id="gitlens"> GitLens</h4>
<p>在文件中提供 Git 版本增强功能，包括但不限于行历史、文件历史、分支查看、本地与远程库提交查看与对比分析等</p>
<h4 id="live-share"> Live Share</h4>
<p>官方实时分享功能，可多人同时协作一份文件，也可做在线演示</p>
<h4 id="live-share-audio"> Live Share Audio</h4>
<p>官方实时语音通话，可在多人协作或演示中使用</p>
<h4 id="remote-development"> Remote Development</h4>
<p>远程链接与控制</p>
<h3 id="网页"> 网页</h3>
<h4 id="color-info"> Color Info</h4>
<p>为 CSS 颜色详情显示更多信息</p>
<h4 id="debugger-for-chrome"> Debugger for Chrome</h4>
<p>在 Chrome 中调试代码</p>
<h4 id="eslint"> ESLint</h4>
<p>需要 <code>eslint</code> 模块，进行 JS、TS 等文件的的错误检查、格式化</p>
<h4 id="javascript-es6-code-snippets"> JavaScript (ES6) code snippets</h4>
<p>ES6 快速补全，提升代码编写利器</p>
<h4 id="language-stylus"> language-stylus</h4>
<p>Stylus 格式化，高亮支持</p>
<h4 id="live-server"> Live Server</h4>
<p>快速启动本地开发服务器</p>
<h4 id="manta-s-stylus-supremacy"> Manta’s Stylus Supremacy</h4>
<p>Stylus 格式化支持</p>
<h4 id="quokka-js"> Quokka.js</h4>
<p>JavaScript TypeScript 及时运行与结果显示</p>
<h4 id="scss-intellisence"> SCSS IntelliSence</h4>
<p>SCSS 格式化、补全支持</p>
<h4 id="stylelint"> stylelint</h4>
<p>CSS / SCSS / Less 格式化</p>
<h4 id="vetur"> Vetur</h4>
<p>为 VS Code 添加 <code>.vue</code> 文件的支持</p>
<h3 id="小程序"> 小程序</h3>
<h4 id="minapp"> minapp</h4>
<p>小程序标签属性补全</p>
<h3 id="xml-与-json"> XML 与 JSON</h3>
<h4 id="json-organizer"> JSON Organizer</h4>
<p>提供 json 到 js object 的相互转换</p>
<h4 id="xml-tools"> XML Tools</h4>
<p>提供 XML 补全、格式化等</p>
<h3 id="php"> PHP</h3>
<h4 id="php-debug"> PHP Debug</h4>
<p>PHP 逐行调试，需要提前在 PHP 中配置好 XDebug</p>
<h4 id="php-intelephense"> PHP Intelephense</h4>
<p>提供 PHP 函数补全</p>
<h4 id="phpcs"> phpcs</h4>
<p>PHP 错误检查与修复</p>
<h3 id="app-开发"> APP 开发</h3>
<h4 id="dart"> Dart</h4>
<p>提供 dart 语言支持与调试</p>
<h4 id="flutter"> Flutter</h4>
<p>提供 Flutter 支持与调试</p>
<h4 id="gradle-language-support"> Gradle Language Support</h4>
<p>Gradle 语言支持</p>
<h3 id="编程"> 编程</h3>
<h4 id="c-c"> C/C++</h4>
<p>提供代码格式化、自动完成、逐行调试等功能等</p>
<h4 id="code-runner"> Code Runner</h4>
<p>提供多种编程语言的运行</p>
<h4 id="java-extension-pack"> Java Extension Pack</h4>
<p>Java 调试包</p>
<h4 id="python"> Python</h4>
<p>Python 格式化、调试支持</p>
<h3 id="markdown"> Markdown</h3>
<h4 id="markdown-all-in-one"> Markdown All in One</h4>
<p>提供快速添加 Markdown 标记的支持</p>
<h4 id="markdown-emoji"> Markdown Emoji</h4>
<p>为 Markdown 添加表情支持</p>
<h4 id="markdown-preview-github-style"> Markdown Preview GitHub Style</h4>
<p>为 Markdown 预览应用 GitHub 风格</p>
<h4 id="markdownlint"> markdownlint</h4>
<p>检查 Markdown 文法错误</p>
<h3 id="node-js"> Node.js</h3>
<h4 id="node-js-modules-intellisense"> Node.js Modules Intellisense</h4>
<p>提供 Node.js 模块智能提示</p>
<h4 id="npm-intellisense"> npm Intellisense</h4>
<p>为 VS Code 添加 npm 模块导入补全</p>
<h3 id="latex"> LaTeX</h3>
<h4 id="latex-workshop"> LaTeX Workshop</h4>
<p>LaTeX 插件，支持常见功能与编译</p>
<h4 id="latex-formatter"> latex-formatter</h4>
<p>提供 LaTeX 格式化</p>
<h3 id="其他"> 其他</h3>
<h4 id="yaml"> YAML</h4>
<p>提供 YAML 格式化，高亮支持</p>
<h4 id="leetcode"> LeetCode</h4>
<p>代码学习练习软件</p>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <category term="VS Code"/>
    <contributor>
      <name>南辞</name>
    </contributor>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">文件</title>
    <id>http://qiqi.dreamagain.top/software/vscode/guide/file/</id>
    <link href="http://qiqi.dreamagain.top/software/vscode/guide/file/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<h2 id="切换侧边栏"> 切换侧边栏</h2>
<p>键盘快捷键: <code>Ctrl + B</code></p>
<h2 id="切换面板"> 切换面板</h2>
<p>键盘快捷键: <code>Ctrl + J</code></p>
<h2 id="zen-模式"> Zen 模式</h2>
<p>键盘快捷键: <code>Ctrl + K Z</code></p>
<p>进入无干扰禅宗模式。</p>
<p>按两次 <code>Esc</code> 键退出 Zen 模式。</p>
<h2 id="并排编辑"> 并排编辑</h2>
<p>键盘快捷键: <code>Ctrl + \</code></p>
<p>您还可以拖放编辑器以创建新的编辑器组，并在组之间移动编辑器。</p>
<h2 id="编辑之间切换"> 编辑之间切换</h2>
<p>键盘快捷键: <code>Ctrl + 1</code>，<code>Ctrl + 2</code>，<code>Ctrl + 3</code></p>
<h2 id="移至资源管理器窗口"> 移至资源管理器窗口</h2>
<p>键盘快捷键: <code>Ctrl + Shift + E</code></p>
<h2 id="创建或打开一个文件"> 创建或打开一个文件</h2>
<p>键盘快捷键: <code>Ctrl + click</code></p>
<p>您可以通过将光标移动到文件链接并使用 <code>Ctrl + click</code> 来快速打开文件或图像或创建新文件。</p>
<h2 id="关闭当前打开的文件夹"> 关闭当前打开的文件夹</h2>
<p>键盘快捷键: <code>Ctrl + F4</code></p>
<h2 id="导航历史"> 导航历史</h2>
<p>浏览整个历史记录: <code>Ctrl + Tab</code></p>
<p>向后导航: <code>Alt + ←</code></p>
<p>向前导航: <code>Alt + →</code></p>
<h2 id="文件关联"> 文件关联</h2>
<p>为未正确检测到的文件创建语言关联。例如，许多带有自定义文件扩展名的配置文件实际上是 JSON。</p>
<div><pre><code><span>"files.associations"</span><span>:</span> <span>{</span>
  <span>".database"</span><span>:</span> <span>"json"</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id="防止脏写入"> 防止脏写入</h2>
<p>当您尝试保存已经再打开后再度在磁盘上发生更改的文件时，VS Code 将显示一条错误消息。VS Code 阻止保存文件，以防止覆盖在编辑器之外进行的更改。</p>
<p>为了解决保存冲突，请在错误消息中单击 <strong>比较</strong> 操作以打开差异编辑器，该差异编辑器将向您显示磁盘上文件的内容(左侧)，与 VS Code 中的内容(右侧)相比:</p>
<p>使用编辑器工具栏中的操作来解决保存冲突。您可以接受更改并覆盖磁盘上的所有更改，也可以还原为磁盘上的版本。还原意味着您的更改将丢失。</p>
<p>注意: 该文件将保持 <code>dirty</code> 状态，直到您选择两个解决冲突的操作之一后才能保存。</p>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <category term="VS Code"/>
    <contributor>
      <name>南辞</name>
    </contributor>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">智能提示</title>
    <id>http://qiqi.dreamagain.top/software/vscode/guide/intellisense/</id>
    <link href="http://qiqi.dreamagain.top/software/vscode/guide/intellisense/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<p>使用 <code>Ctrl + Space</code> 触发智能提示组件。</p>
<p><img src="./assets/intellisense.gif" alt="智能提示组件"></p>
<p>您可以查看可用的方法，参数提示，简短文档等。</p>
<h2 id="跳转"> 跳转</h2>
<p>选择一个符号然后输入 <code>Alt + F12</code>，您就可以使用上下文菜单了。</p>
<p><img src="./assets/context-menu.gif" alt="上下文菜单"></p>
<h2 id="跳转到定义"> 跳转到定义</h2>
<p>选择一个符号然后输入 <code>F12</code>，您也可以使用上下文菜单或 <code>Ctrl + Click</code></p>
<p><img src="./assets/goto-definition.gif" alt="跳转到定义"></p>
<p>您可以使用 <strong>转到 &gt; 返回</strong> 命令或快捷键 <code>Alt + ←</code> 来返回您的上个位置。</p>
<h2 id="跳转到引用"> 跳转到引用</h2>
<p>选择一个符号输入 <code>Shift + F12</code>，即可打开上下文菜单查看所有引用。</p>
<h2 id="查看所有引用"> 查看所有引用</h2>
<p>选择一个符号，然后按 <code>Shift + Alt + F12</code> 打开 <strong>引用</strong> 视图，在专用视图中显示文件的所有符号。</p>
<h2 id="重命名符号"> 重命名符号</h2>
<p>选择一个符号，然后按下 <code>F2</code>。或者，您可以使用上下文菜单。</p>
<p><img src="./assets/rename.gif" alt="重命名符号"></p>
<h2 id="搜索和修改"> 搜索和修改</h2>
<p>除了搜索和替换表达式之外，您还可以使用带有捕获组的正则表达式搜索和重用匹配的部分。通过单击 <strong>使用正则表达式</strong> <code>.*</code> 按钮(<code>Alt + R</code>)在搜索框中启用正则表达式，然后编写正则表达式并使用括号定义组。然后，您可以在替换字段使用 <code>$1</code>，<code>$2</code> 等来输入每个组中匹配的内容。</p>
<p><img src="./assets/replace.png" alt="搜索和修改"></p>
<h2 id="eslintrc-json"> .eslintrc.json</h2>
<p>安装 ESLint 扩展，并根据您的需要配置。请查阅 ESLint 规范以获取有关其格式化规则和选项的详细信息。</p>
<p>这是使用 ES6 的配置。</p>
<div><pre><code><span>{</span>
  <span>"env"</span><span>:</span> <span>{</span>
    <span>"browser"</span><span>:</span> <span>true</span><span>,</span>
    <span>"commonjs"</span><span>:</span> <span>true</span><span>,</span>
    <span>"es6"</span><span>:</span> <span>true</span><span>,</span>
    <span>"node"</span><span>:</span> <span>true</span>
  <span>}</span><span>,</span>
  <span>"parserOptions"</span><span>:</span> <span>{</span>
    <span>"ecmaVersion"</span><span>:</span> <span>6</span><span>,</span>
    <span>"sourceType"</span><span>:</span> <span>"module"</span><span>,</span>
    <span>"ecmaFeatures"</span><span>:</span> <span>{</span>
      <span>"jsx"</span><span>:</span> <span>true</span><span>,</span>
      <span>"classes"</span><span>:</span> <span>true</span><span>,</span>
      <span>"defaultParams"</span><span>:</span> <span>true</span>
    <span>}</span>
  <span>}</span><span>,</span>
  <span>"rules"</span><span>:</span> <span>{</span>
    <span>"no-const-assign"</span><span>:</span> <span>1</span><span>,</span>
    <span>"no-extra-semi"</span><span>:</span> <span>0</span><span>,</span>
    <span>"semi"</span><span>:</span> <span>0</span><span>,</span>
    <span>"no-fallthrough"</span><span>:</span> <span>0</span><span>,</span>
    <span>"no-empty"</span><span>:</span> <span>0</span><span>,</span>
    <span>"no-mixed-spaces-and-tabs"</span><span>:</span> <span>0</span><span>,</span>
    <span>"no-redeclare"</span><span>:</span> <span>0</span><span>,</span>
    <span>"no-this-before-super"</span><span>:</span> <span>1</span><span>,</span>
    <span>"no-undef"</span><span>:</span> <span>1</span><span>,</span>
    <span>"no-unreachable"</span><span>:</span> <span>1</span><span>,</span>
    <span>"no-use-before-define"</span><span>:</span> <span>0</span><span>,</span>
    <span>"constructor-super"</span><span>:</span> <span>1</span><span>,</span>
    <span>"curly"</span><span>:</span> <span>0</span><span>,</span>
    <span>"eqeqeq"</span><span>:</span> <span>0</span><span>,</span>
    <span>"func-names"</span><span>:</span> <span>0</span><span>,</span>
    <span>"valid-typeof"</span><span>:</span> <span>1</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br></div></div><h2 id="package-json"> package.json</h2>
<p>IntelliSense 会为 package.json 文件提供智能提示。</p>
<h2 id="emmet-语法"> Emmet 语法</h2>
<p>支持 <a href="./../../../code/website/emmet/">Emmet 语法</a>。</p>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <category term="VS Code"/>
    <contributor>
      <name>南辞</name>
    </contributor>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">Git 集成</title>
    <id>http://qiqi.dreamagain.top/software/vscode/guide/git/</id>
    <link href="http://qiqi.dreamagain.top/software/vscode/guide/git/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<p>键盘快捷键: <code>Ctrl + Shift + G</code></p>
<p>VS Code 有开箱即用的 Git 集成。您可以从扩展市场中安装其他 SCM 提供程序。本节描述了 Git 集成。</p>
<h2 id="差异"> 差异</h2>
<p>从 <strong>源代码管理</strong> 视图中，选择一个文件以打开差异。</p>
<p><img src="./assets/git-diff.png" alt="来自源代码管理的 git diff"></p>
<h3 id="视图布局"> 视图布局</h3>
<p>差异的默认视图是并排视图。</p>
<p>切换内嵌视图: 点击更多操作右上角(...)按钮，然后选择切换内嵌视图。</p>
<p>如果您喜欢嵌入式视图，可以设置 <code>&quot;diffEditor.renderSideBySide&quot;: false</code>。</p>
<h3 id="审查窗格"> 审查窗格</h3>
<p>使用 <code>F7</code> 和 <code>Shift + F7</code> 浏览差异。这将以统一的补丁格式显示它们。可以使用箭头键浏览行，然后按 Enter 键将在差异编辑器和所选行中跳回。</p>
<h3 id="编辑待处理的更改"> 编辑待处理的更改</h3>
<p>您可以直接在 diff 视图的等待更改试图中进行编辑。</p>
<h2 id="分支"> 分支</h2>
<p>通过状态栏轻松在 Git 分支之间切换。</p>
<p>切换分支</p>
<h2 id="暂存"> 暂存</h2>
<h3 id="暂存文件更改"> 暂存文件更改</h3>
<ul>
<li>
<p>将鼠标悬停在文件上，然后单击加号按钮。</p>
</li>
<li>
<p>单击减号按钮可以取消更改。</p>
</li>
</ul>
<h3 id="撤消最后提交"> 撤消最后提交</h3>
<p>单击(...)按钮，然后选择 <strong>提交 &gt; 撤消上一次提交</strong> 以撤消上一次提交。所做的更改将添加到 <strong>暂存的更改</strong> 部分。</p>
<p><img src="./assets/undo-last-commit.png" alt="撤消上一次提交"></p>
<h2 id="查看-git-输出"> 查看 Git 输出</h2>
<p>VS Code 使得查看实际运行的 Git 命令变得容易。在学习 Git 或调试困难的源代码管理问题时，这很有用。</p>
<p>使用 <strong>切换输出命令</strong> (<code>Ctrl + Shift + U</code>)，然后在下拉菜单中选择 Git。</p>
<h2 id="增删指示"> 增删指示</h2>
<p>在编辑器中查看差异提示。有关更多详细信息，请参见文档。</p>
<p><img src="./assets/gutter.png" alt="增删指示"></p>
<h2 id="解决合并冲突"> 解决合并冲突</h2>
<p>在合并过程中，转到 <strong>源代码管理</strong> 视图(<code>Ctrl + Shift + G</code>)，然后在 diff 视图中进行更改。</p>
<p>您可以使用内联 CodeLens 解决合并冲突，内联 CodeLens 允许您 <strong>接受当前更改</strong>，<strong>接受传入更改</strong>，<strong>接受两个更改</strong> 以及 <strong>比较更改</strong>。</p>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <category term="VS Code"/>
    <contributor>
      <name>南辞</name>
    </contributor>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">VS Code 指南</title>
    <id>http://qiqi.dreamagain.top/software/vscode/guide/</id>
    <link href="http://qiqi.dreamagain.top/software/vscode/guide/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<ul>
<li>
<p><a href="./basic.html">基础介绍</a></p>
</li>
<li>
<p><a href="./customization.html">个性化介绍</a></p>
</li>
<li>
<p><a href="./extension.html">扩展介绍</a></p>
</li>
<li>
<p><a href="./file.html">文件介绍</a></p>
</li>
<li>
<p><a href="./edit.html">编辑技巧</a></p>
</li>
<li>
<p><a href="./intellisense.html">智能补全</a></p>
</li>
<li>
<p><a href="./git.html">Git 支持</a></p>
</li>
<li>
<p><a href="./debug.html">调试介绍</a></p>
</li>
<li>
<p><a href="./task.html">任务介绍</a></p>
</li>
<li>
<p><a href="./command.html">命令行介绍</a></p>
</li>
</ul>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <category term="VS Code"/>
    <contributor>
      <name>南辞</name>
    </contributor>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">任务执行器</title>
    <id>http://qiqi.dreamagain.top/software/vscode/guide/task/</id>
    <link href="http://qiqi.dreamagain.top/software/vscode/guide/task/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<h2 id="自动检测任务"> 自动检测任务</h2>
<p>从顶层菜单中选择<strong>终端</strong>，运行命令<strong>配置任务</strong>，然后选择您要运行的任务类型。这将生成一个 <code>tasks.json</code> 文件。有关更多详细信息，请参见 <a href="https://code.visualstudio.com/docs/editor/debugging" target="_blank" rel="noopener noreferrer">任务文档</a>。</p>
<div><pre><code><span>{</span>
  <span>// See &lt;https://go.microsoft.com/fwlink/?LinkId=733558></span>
  <span>// for the documentation about the tasks.json format</span>
  <span>"version"</span><span>:</span> <span>"2.0.0"</span><span>,</span>
  <span>"tasks"</span><span>:</span> <span>[</span>
    <span>{</span>
      <span>"type"</span><span>:</span> <span>"npm"</span><span>,</span>
      <span>"script"</span><span>:</span> <span>"install"</span><span>,</span>
      <span>"group"</span><span>:</span> <span>{</span>
        <span>"kind"</span><span>:</span> <span>"build"</span><span>,</span>
        <span>"isDefault"</span><span>:</span> <span>true</span>
      <span>}</span>
    <span>}</span>
  <span>]</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>自动生成有时会出现问题。请查阅文档，以确保一切正常。</p>
<h2 id="从终端菜单运行任务"> 从终端菜单运行任务</h2>
<p>从顶层菜单中选择 <strong>终端 &gt; 运行任务</strong>，然后选择要运行的任务。通过运行命令 <strong>终止任务</strong> 终止正在运行的任务</p>
<p><img src="./assets/task-runner.gif" alt="任务执行器"></p>
<h2 id="定义任务的键盘快捷键"> 定义任务的键盘快捷键</h2>
<p>您可以为任何任务定义键盘快捷键。从命令面板(<code>Ctrl + Shift + P</code>)中，选择 <strong>首选项: 打开键盘快捷方式文件</strong>，将所需的快捷方式绑定到 <code>workbench.action.tasks.runTask</code> 命令，然后将 任务 定义为 <code>args</code>。</p>
<p>例如，要将 <code>Ctrl + H</code> 绑定到 <strong>运行任务</strong>，请添加以下内容:</p>
<div><pre><code><span>{</span>
  <span>"key"</span><span>:</span> <span>"ctrl+h"</span><span>,</span>
  <span>"command"</span><span>:</span> <span>"workbench.action.tasks.runTask"</span><span>,</span>
  <span>"args"</span><span>:</span> <span>"Run tests"</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h2 id="从资源管理器中将-npm-脚本作为任务运行"> 从资源管理器中将 npm 脚本作为任务运行</h2>
<p>使用该设置 <code>npm.enableScriptExplorer</code>，您可以启用一个浏览器，该浏览器显示在工作空间中定义的脚本。</p>
<p>在资源管理器中，您可以在编辑器中打开脚本，将其作为任务运行，然后使用节点调试器启动它(当脚本定义了诸如 <code>--inspect-brk</code> 的调试选项时)。单击时的默认操作是打开脚本。要单击运行脚本，请设置 <code>npm.scriptExplorerAction</code> 为 <strong>运行</strong>。使用 <code>npm.exclude</code> 设置可以排除 <code>package.json</code> 特定文件夹中包含的文件中的脚本。</p>
<p>通过设置 <code>npm.enableRunFromFolder</code>，您可以启用从文件资源管理器的上下文菜单中为文件夹运行 npm 脚本的功能。选择文件夹后，该设置将启用命令 <strong>在文件夹中运行 npm 脚本...</strong>。该命令显示此文件夹中包含的 npm 脚本的快速选择列表，您可以选择要作为任务执行的脚本。</p>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <category term="VS Code"/>
    <contributor>
      <name>南辞</name>
    </contributor>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">Shell 的命令</title>
    <id>http://qiqi.dreamagain.top/software/linux/bash/archives/command/</id>
    <link href="http://qiqi.dreamagain.top/software/linux/bash/archives/command/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<h1 id="shell-的命令"> Shell 的命令</h1>
<h2 id="命令的类别"> 命令的类别</h2>
<p>Bash 可以使用的命令分成四类。</p>
<ul>
<li>可执行程序</li>
<li>Shell 提供的命令</li>
<li>Shell 函数</li>
<li>前三类命令的别名</li>
</ul>
<h2 id="type-whatis"> type, whatis</h2>
<p><code>type</code> 命令可以显示命令类型。</p>
<div><pre><code><span>type</span> <span>command</span>
</code></pre>
<div><span>1</span><br></div></div><p>下面是几个例子。</p>
<div><pre><code>$ <span>type</span> <span>type</span>
<span>type</span> is a shell <span>builtin</span>

$ <span>type</span> <span>ls</span>
<span>ls</span> is aliased to `ls --color<span>=</span>tty'

$ <span>type</span> <span>cp</span>
<span>cp</span> is /bin/cp
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p><code>whatis</code> 命令显示指定命令的描述。</p>
<div><pre><code>$ whatis <span>ls</span>
<span>ls</span> <span>(</span><span>1</span><span>)</span> - list directory contents
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h2 id="apropos"> apropos</h2>
<p><code>apropos</code> 命令返回符合搜索条件的命令列表。</p>
<div><pre><code>$ <span>apropos</span> floppy
create_floppy_devices <span>(</span><span>8</span><span>)</span> - udev callout to create all possible
<span>fdformat</span> <span>(</span><span>8</span><span>)</span> - Low-level formats a floppy disk
floppy <span>(</span><span>8</span><span>)</span> - <span>format</span> floppy disks
gfloppy <span>(</span><span>1</span><span>)</span> - a simple floppy formatter <span>for</span> the GNOME
mbadblocks <span>(</span><span>1</span><span>)</span> - tests a floppy disk, and marks the bad
mformat <span>(</span><span>1</span><span>)</span> - <span>add</span> an MSDOS filesystem to a low-level
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h2 id="alias-unalias"> alias, unalias</h2>
<p><code>alias</code> 命令用来为命令起别名。</p>
<div><pre><code>$ <span>alias</span> <span>foo</span><span>=</span><span>'cd /usr; ls; cd -'</span>

$ <span>type</span> foo
foo is aliased to `cd /usr<span>;</span> <span>ls</span> <span>;</span> <span>cd</span> -'
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>上面命令指定 <code>foo</code> 为三个命令的别名。以后，执行 <code>foo</code> 就相当于一起执行这三条命令。</p>
<p>注意，默认情况下，别名只在当前 Session 有效。当前 Session 结束时，这些别名就会消失。</p>
<p><code>alias</code> 命令不加参数时，显示所有有效的别名。</p>
<div><pre><code>$ <span>alias</span>
<span>alias</span> l.<span>=</span><span>'ls -d .* --color=tty'</span>
<span>alias</span> <span>ll</span><span>=</span><span>'ls -l --color=tty'</span>
<span>alias</span> <span>ls</span><span>=</span><span>'ls --color=tty'</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p><code>unalias</code> 命令用来取消别名。</p>
<div><pre><code>$ <span>unalias</span> foo
$ <span>type</span> foo
bash: type: foo: not found
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id="which"> which</h2>
<p><code>which</code> 命令显示可执行程序的路径。</p>
<div><pre><code>$ <span>which</span> <span>ls</span>
/bin/ls
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><code>which</code> 命令用于 Shell 内置命令时(比如 <code>cd</code>)，将没有任何输出。</p>
<h2 id="help-man"> help，man</h2>
<p><code>help</code> 命令用于查看 Shell 内置命令的帮助信息，<code>man</code> 命令用于查看可执行命令的帮助信息。</p>
<div><pre><code><span>help</span> <span>cd</span>
<span>man</span> <span>ls</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><code>man</code> 里面的文档一共有 8 类，如果同一个命令，匹配多个文档，<code>man</code> 命令总是返回第一个匹配。如果想看指定类型的文档，命令可以采用下面的形式。</p>
<div><pre><code><span>man</span> <span>5</span> <span>passwd</span>
</code></pre>
<div><span>1</span><br></div></div><h2 id="script"> script</h2>
<p><code>script</code> 命令会将输入的命令和它的输出，都保存进一个文件。</p>
<div><pre><code>script <span>[</span>file<span>]</span>
</code></pre>
<div><span>1</span><br></div></div><p>如果没有指定文件名，则所有结果会保存进当前目录下 <code>typescript</code> 文件。结束录制的时候，可以按下 <code>Ctrl + d</code>。</p>
<h2 id="export"> export</h2>
<p><code>export</code> 命令用于将当前进程的变量，输出到所有子进程。</p>
<h2 id="命令的连续执行"> 命令的连续执行</h2>
<p>多个命令可以写在一起。</p>
<p>Bash 提供三种方式，定义它们如何执行。</p>
<div><pre><code><span># 第一个命令执行完，执行第二个命令</span>
command1<span>;</span> command2

<span># 只有第一个命令成功执行完(退出码0)，才会执行第二个命令</span>
command1 <span>&amp;&amp;</span> command2

<span># 只有第一个命令执行失败(退出码非0)，才会执行第二个命令</span>
command1 <span>||</span> command2
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>上面三种执行方法的退出码，都是最后一条执行的命令的退出码。</p>
<p>bash 允许把命令组合在一起。可以通过两种方式完成；要么用一个 group 命令，要么用一个子 shell。这里是每种方式的语法示例:</p>
<p>组命令:</p>
<div><pre><code><span>{</span> command1<span>;</span> command2<span>;</span> <span>[</span>command3<span>;</span> <span>..</span>.<span>]</span> <span>}</span>
</code></pre>
<div><span>1</span><br></div></div><p>子 shell</p>
<div><pre><code><span>(</span>command1<span>;</span> command2<span>;</span> <span>[</span>command3<span>;</span><span>..</span>.<span>]</span><span>)</span>
</code></pre>
<div><span>1</span><br></div></div><p>这两种形式的不同之处在于，组命令用花括号把它的命令包裹起来，而子 shell 用括号。值得注意的是，鉴于 bash 实现组命令的方式， 花括号与命令之间必须有一个空格，并且最后一个命令必须用一个分号或者一个换行符终止。</p>
<p>那么组命令和子 shell 命令对什么有好处呢? 它们都是用来管理重定向的。</p>
<div><pre><code><span>{</span> <span>ls</span> -l<span>;</span> <span>echo</span> <span>"Listing of foo.txt"</span><span>;</span> <span>cat</span> foo.txt<span>;</span> <span>}</span> <span>></span> output.txt
</code></pre>
<div><span>1</span><br></div></div><p>使用一个子 shell 是相似的。</p>
<div><pre><code><span>(</span>ls -l<span>;</span> <span>echo</span> <span>"Listing of foo.txt"</span><span>;</span> <span>cat</span> foo.txt<span>)</span> <span>></span> output.txt
</code></pre>
<div><span>1</span><br></div></div><p>组命令和子 shell 真正闪光的地方是与管道线相结合。当构建一个管道线命令的时候，通常把几个命令的输出结果合并成一个流是很有用的。组命令和子 shell 使这种操作变得很简单。</p>
<div><pre><code><span>{</span> <span>ls</span> -l<span>;</span> <span>echo</span> <span>"Listing of foo.txt"</span><span>;</span> <span>cat</span> foo.txt<span>;</span> <span>}</span> <span>|</span> <span>lpr</span>
</code></pre>
<div><span>1</span><br></div></div><p>这里我们已经把我们的三个命令的输出结果合并在一起，并把它们用管道输送给命令 lpr 的输入，以便产生一个打印报告。</p>
<p>虽然组命令和子 shell 看起来相似，并且它们都能用来在重定向中合并流，但是两者之间有一个很重要的不同。然而，一个组命令在当前 shell 中执行它的所有命令，而一个子 shell(顾名思义)在当前 shell 的一个 子副本中执行它的命令。这意味着运行环境被复制给了一个新的 shell 实例。当这个子 shell 退出时，环境副本会消失， 所以在子 shell 环境(包括变量赋值)中的任何更改也会消失。因此，在大多数情况下，除非脚本要求一个子 shell， 组命令比子 shell 更受欢迎。组命令运行很快并且占用的内存也少。</p>
<p>当我们发现管道线中的一个 read 命令 不按我们所期望的那样工作的时候。为了重现问题，我们构建一个像这样的管道线:</p>
<div><pre><code><span>echo</span> <span>"foo"</span> <span>|</span> <span>read</span>
<span>echo</span> <span>$REPLY</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>该 REPLY 变量的内容总是为空，是因为这个 read 命令在一个子 shell 中执行，所以它的 REPLY 副本会被毁掉， 当该子 shell 终止的时候。因为管道线中的命令总是在子 shell 中执行，任何给变量赋值的命令都会遭遇这样的问题。幸运地是，shell 提供了一种奇异的展开方式，叫做进程替换，它可以用来解决这种麻烦。进程替换有两种表达方式:</p>
<p>一种适用于产生标准输出的进程:</p>
<div><pre><code><span>&lt;</span><span>(</span>list<span>)</span>
</code></pre>
<div><span>1</span><br></div></div><p>另一种适用于接受标准输入的进程:</p>
<div><pre><code><span>></span><span>(</span>list<span>)</span>
</code></pre>
<div><span>1</span><br></div></div><p>这里的 list 是一串命令列表:</p>
<p>为了解决我们的 read 命令问题，我们可以雇佣进程替换，像这样。</p>
<div><pre><code><span>read</span> <span>&lt;</span> <span>&lt;</span><span>(</span><span>echo</span> <span>"foo"</span><span>)</span>
<span>echo</span> <span>$REPLY</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>进程替换允许我们把一个子 shell 的输出结果当作一个用于重定向的普通文件。事实上，因为它是一种展开形式，我们可以检验它的真实值:</p>
<div><pre><code><span>[</span>me@linuxbox ~<span>]</span>$ <span>echo</span> <span>&lt;</span><span>(</span><span>echo</span> <span>"foo"</span><span>)</span>
/dev/fd/63
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>通过使用 echo 命令，查看展开结果，我们看到子 shell 的输出结果，由一个名为 /dev/fd/63 的文件提供。</p>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <contributor>
      <name>南辞</name>
    </contributor>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">VS Code 安装</title>
    <id>http://qiqi.dreamagain.top/software/vscode/install/</id>
    <link href="http://qiqi.dreamagain.top/software/vscode/install/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<h1 id="vs-code-安装"> VS Code 安装</h1>
<h2 id="下载"> 下载</h2>
<p>在 <a href="https://code.visualstudio.com/Download" target="_blank" rel="noopener noreferrer">官网下载地址</a> 下载最新版安装包(Window User 64bit, 那个大的蓝色按钮就是)。</p>
<h2 id="安装"> 安装</h2>
<ul>
<li>
<p>双击安装包打开</p>
</li>
<li>
<p>同意用户协议。</p>
</li>
<li>
<p>安装选项中，请务必 <strong>全选</strong> 以下选项:</p>
<p><img src="./assets/install.png" alt="安装 VS Code"></p>
<p>勾选 <strong>添加到目录上下文菜单</strong>、<strong>添加到文件上下文菜单</strong>、<strong>将 code 注册为受支持的文件编辑器</strong>、<strong>添加到 path</strong>。</p>
</li>
<li>
<p>在 VS Code 初次启动后，若未提前安装 Git 可能会提示未找到 Git 软件，忽略即可</p>
</li>
<li>
<p>推荐立即执行简体中文扩展安装以保证界面语言为简体中文。</p>
<div><p>提示</p>
<p>当您安装 VSCode 并第一次打开的时候，VSCode 会自动检测当前系统语言并在右下角推荐您安装对应语言的扩展，点击按钮即可自动安装。</p>
</div>
</li>
</ul>
<h2 id="更新频率"> 更新频率</h2>
<p>VS Code 每月发布一个具有新功能和重要错误修复的新版本。大多数平台都支持自动更新，并且会在新版本发布时提示您安装新版本。您还可以通过运行左下角 <strong>管理 → 检查更新</strong> 来手动检查更新。</p>
<h2 id="用-vs-code-打开文件和文件夹"> 用 VS Code 打开文件和文件夹</h2>
<p>VS Code 支持打开文件和文件夹。</p>
<ul>
<li>
<p>打开文件时请在文件图标上单击右键—选择 <strong>使用 VS Code 打开</strong>；</p>
</li>
<li>
<p>打开文件夹请双击打开文件夹，在空白处单击右键——选择 <strong>用 VS Code 打开</strong>。</p>
</li>
</ul>
<h3 id="mac-添加-通过-code-打开"> Mac 添加 <strong>通过 Code 打开</strong></h3>
<p>在 Mac 系统上，Finder 选中一个目录，右键菜单并没有 <strong>通过 Code 打开</strong> 这个操作。不过我们可以通过 Automator 自己添加这个操作。</p>
<p>先运行 Automator，选择 <strong>服务</strong>:</p>
<p><img src="./assets/automator-service.png" alt="Automator Service"></p>
<p>然后，执行以下操作:</p>
<p><img src="./assets/automator.jpg" alt="Automator"></p>
<ol>
<li>
<p>在右侧面板选择 <strong>服务</strong> 收到选定的 <strong>文件夹</strong>，位于 “Finder.app”，该选项是为了从 Finder 中接收一个文件夹；</p>
</li>
<li>
<p>在左侧面板选择 <strong>实用工具</strong>，然后找到 <strong>运行 Shell 脚本</strong>，把它拽到右侧面板里；</p>
</li>
<li>
<p>在右侧 <strong>运行 Shell 脚本</strong> 的面板里，选择 Shell <strong>/bin/bash</strong>，传递输入 <strong>作为自变量</strong>，然后修改 Shell 脚本如下:</p>
</li>
</ol>
<div><pre><code><span>for</span> <span>f</span> <span>in</span> <span>"<span>$@</span>"</span>
<span>do</span>
    <span>open</span> -a <span>"Visual Studio Code"</span> <span>"<span>$f</span>"</span>
<span>done</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>保存为 <strong>Open With VS Code</strong> 后，打开 Finder，选中一个文件夹，点击右键， <strong>服务</strong>，就可以看到 <strong>Open With VS Code</strong> 菜单:</p>
<p><img src="./assets/open-with-vscode.png" alt="Open with VSCode"></p>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <category term="VS Code"/>
    <contributor>
      <name>南辞</name>
    </contributor>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">快捷键</title>
    <id>http://qiqi.dreamagain.top/software/vscode/shortcut-key/</id>
    <link href="http://qiqi.dreamagain.top/software/vscode/shortcut-key/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<p>通过快捷键，Visual Studio Code 可让您直接从键盘执行大多数任务。</p>
<h2 id="常用的快捷键"> 常用的快捷键</h2>
<div><p>提示</p>
<p>以下这些快捷键建议大家熟练掌握，能够很大程度提高开发效率。</p>
</div>
<h3 id="鼠标操作"> 鼠标操作</h3>
<ul>
<li>
<p>在当前行的位置，鼠标三击，可以选中当前行。</p>
</li>
<li>
<p>用鼠标单击文件的行号，可以选中当前行。</p>
</li>
<li>
<p>在某个行号的位置，上下移动鼠标，可以选中多行。</p>
</li>
</ul>
<h3 id="移动光标"> 移动光标</h3>
<ul>
<li>
<p>「方向键」: 在<strong>单个字符</strong>之间移动光标</p>
</li>
<li>
<p>「Ctrl + 左右方向键」: 在<strong>单词</strong>之间移动光标(很常用)。</p>
</li>
</ul>
<h3 id="快速选中"> 快速选中</h3>
<p>在任意位置单击放置光标，按住 <code>shift</code> 在第二个位置单击，即可选中两光标位置间的所有文字。</p>
<ul>
<li>
<p><code>Ctrl + Alt + ↑/↓</code>: 向方向键方向的相邻行放置一个光标；</p>
</li>
<li>
<p><code>Alt + Click</code>: 放置辅助游标；</p>
</li>
<li>
<p><code>Shift + Alt + ←/→</code>: 收缩/扩展选择；</p>
</li>
<li>
<p><code>Shift + Alt</code> 同时拖动到对角: 列(框)选择；</p>
</li>
</ul>
<h3 id="删除"> 删除</h3>
<ul>
<li>
<p><code>Ctrl + Backspace</code>: 删除光标之前的一个单词</p>
</li>
<li>
<p><code>Ctrl + delete</code>: 　删除光标之后的一个单词</p>
</li>
<li>
<p><code>Ctrl + Shift + K</code>: 删除整行</p>
</li>
</ul>
<h3 id="移动文字"> 移动文字</h3>
<ul>
<li>
<p><code>Alt + ↑</code>: 光标所在行或选中的文字的所有行整体上移一行；</p>
</li>
<li>
<p><code>Alt + ↓</code>: 光标所在行或选中文字的所有行整体下移一行</p>
</li>
</ul>
<h3 id="复制文字"> 复制文字</h3>
<ul>
<li>
<p><code>Alt + shift + ↑</code>: 光标所在行或选中的文字的所有行整体向下复制一行(如果选中了多行就是复制多行)；</p>
</li>
<li>
<p><code>Alt + shift + ↓</code>: 光标所在行或选中文字的所有行整体向上复制一行(如果选中了多行就是复制多行)；</p>
</li>
<li>
<p><code>Ctrl + D</code>: 选择光标处的单词，或下一次出现的当前选择；</p>
</li>
</ul>
<h3 id="代码操作"> 代码操作</h3>
<ul>
<li>
<p><code>Ctrl + /</code>: 添加单行注释</p>
</li>
<li>
<p><code>Alt + shift + F</code>: 代码格式化</p>
</li>
<li>
<p><code>Ctrl + U</code>: 将光标的移动回退到上一个位置、撤销光标的移动和选择</p>
</li>
<li>
<p><code>Ctrl + Enter</code>: 在当前行下面新增一行，然后跳至该行 (即使光标不在行尾，也能快速向下插入一行)</p>
</li>
<li>
<p><code>Ctrl + P</code>: 在当前的项目工程里，<strong>全局</strong>搜索文件</p>
</li>
<li>
<p><code>Ctrl + G</code>: 跳转到指定行</p>
</li>
<li>
<p><code>Ctrl + shift + O</code>: 在当前文件的各种<strong>方法之间</strong>进行跳转</p>
</li>
</ul>
<h4 id="搜索"> 搜索</h4>
<ul>
<li>
<p><code>Ctrl + F</code>: 查找，光标在搜索框里；</p>
</li>
<li>
<p><code>F3</code>: 在当前文件中搜索，光标仍在编辑器里</p>
</li>
<li>
<p><code>Ctrl + Shift +F</code>: 全局搜索</p>
</li>
<li>
<p><code>Ctrl + H</code>: 替换。</p>
</li>
</ul>
<h4 id="多光标的使用"> 多光标的使用</h4>
<ol>
<li>
<p>按住 Alt 键，然后在页面中希望中现光标的位置点击鼠标。</p>
</li>
<li>
<p>选中某个文本，然后反复按住快捷键 <code>Ctrl + D</code> 键， 即可将全文中与光标当前所在位置的词相同的词逐一加入选择。</p>
</li>
<li>
<p>选中一堆文本后，按住 <code>Alt + Shift + I</code> 键，既可在<strong>每一行的末尾</strong>都创建一个光标。</p>
</li>
</ol>
<h4 id="工作区快捷键"> 工作区快捷键</h4>
<ul>
<li>
<p><code>Ctrl + B</code>: 显示/隐藏侧边栏</p>
</li>
<li>
<p><code>Ctrl + \</code>: 创建多个编辑器</p>
</li>
<li>
<p><code>Ctrl + Pagedown/Pageup</code>: 在已经打开的文件之间进行<strong>切换</strong></p>
</li>
<li>
<p><code>Ctrl + `</code>: 打开终端</p>
</li>
</ul>
<h3 id="代码折叠"> 代码折叠</h3>
<p><code>Ctrl + Shift + [</code>: 折叠光标处最内部的未折叠区域；</p>
<p><code>Ctrl + Shift +]</code>: 展开光标处的折叠区域；</p>
<p><code>Ctrl + K Ctrl + [</code>: 折叠光标处最内部的未折叠区域以及该区域内的所有区域；</p>
<p><code>Ctrl + K Ctrl +]</code>: 展开光标处的区域以及该区域内的所有区域；</p>
<p><code>Ctrl + K Ctrl + 0</code>: 折叠编辑器中的所有区域；</p>
<p><code>Ctrl + K Ctrl + J</code>: 展开编辑器中的所有区域；</p>
<p><code>Ctrl + K</code> <code>Ctrl</code> + <code>X</code>: 折叠级别 <code>X</code> 的所有区域，但当前光标位置的区域除外；</p>
<p><code>Ctrl + K Ctrl + /</code>: 折叠以块注释标记开头的所有区域；</p>
<div><p>官方文档</p>
<p><a href="./assets/vscodeKeyboardShortcutsWindows.pdf">Windows 下 VSCode 快捷键指南</a> (英文)</p>
</div>
<h3 id="windows-快捷键"> Windows 快捷键</h3>
<p><code>Ctrl + X</code>: 剪切；</p>
<p><code>Ctrl + C</code>: 复制；</p>
<p><code>Ctrl + V</code>: 粘贴；</p>
<p><code>Ctrl + A</code>: 全选；</p>
<p><code>Ctrl + Z</code>: 撤销；</p>
<p><code>Ctrl + Y</code>: 恢复；</p>
<div><p>相关信息</p>
<p>更多请见 <a href="./../../code/windows/shortcut-key.html">Windows 快捷键介绍</a></p>
</div>
<hr>
<p>以下是一些高级内容</p>
<h2 id="快捷键编辑器"> 快捷键编辑器</h2>
<p>Visual Studio Code 使用 <strong>键盘快捷键编辑器</strong> 提供了丰富而便捷的键盘快捷键编辑体验。它列出了所有可用命令(无论是否已有快捷键绑定)，您可以轻松 更改 / 删除 / 重置 其键绑定。它还在顶部有一个搜索框，可帮助您查找命令或快捷键。您可以通过转到 <code>文件 &gt; 首选项 &gt; 键盘快捷方式</code> 下的菜单来打开此编辑器。(macOS 上为 <code>代码 &gt; 首选项 &gt; 键盘快捷键</code>)</p>
<h3 id="检测键绑定冲突"> 检测键绑定冲突</h3>
<p>如果您安装了许多扩展程序或自定义了键盘快捷键，则有时会将同一键盘快捷键映射到多个命令时会发生键绑定冲突。这可能导致混乱的行为，尤其是当您在编辑器中移动时，不同的键绑定进入和超出范围时。</p>
<p>该键盘快捷键编辑器有一个上下文菜单命令显示相同的按键组合，这将筛选基于键盘快捷键来显示冲突的键绑定。</p>
<p>选择一个您认为被覆盖掉的键绑定命令，您可以查看是否定义了多个命令，键绑定的来源以及它们何时处于活动状态。</p>
<h3 id="查看修改键绑定"> 查看修改键绑定</h3>
<p>您可以使用 <strong>更多操作(...)</strong> 菜单中的 <strong>显示用户按键绑定</strong>命令。</p>
<h3 id="高级定制"> 高级定制</h3>
<p>VS Code 中的所有键盘快捷键都可以通过该 <code>keybindings.json</code> 文件进行自定义。</p>
<ul>
<li>要通过 JSON 文件配置键盘快捷键，请打开 <strong>键盘快捷键</strong> 编辑器，然后选择编辑器标题栏右侧的 **打开键盘快捷键 (JSON)**按钮。</li>
<li>这将打开您的 <code>keybindings.json</code> 文件，您可以在其中覆盖默认的案件绑定。</li>
</ul>
<p>您也可以使用从命令面板(Ctrl + Shift + P)中选择 <strong>首选项: 打开键盘快捷方式 (JSON)</strong> 命令打开 <code>keybindings.json</code> 文件。</p>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <category term="VS Code"/>
    <contributor>
      <name>南辞</name>
    </contributor>
    <published>2020-09-17T00:00:00.000Z</published>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">VS Code 的简单介绍</title>
    <id>http://qiqi.dreamagain.top/software/vscode/simple/</id>
    <link href="http://qiqi.dreamagain.top/software/vscode/simple/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<h2 id="简介"> 简介</h2>
<p>这是一款微软的代码编辑器，因其开源，可扩展和众多插件成为全球最受欢迎的代码编辑器。</p>
<h2 id="vs-code-的安装"> VS Code 的安装</h2>
<p>在<a href="https://code.visualstudio.com/Download" target="_blank" rel="noopener noreferrer">官网下载地址</a>下载最新版 Win64User 安装包，双击安装包打开同意用户协议，一直下一步即可。</p>
<p>在 VS Code 初次启动后，若未提前安装 Git 可能会提示未找到 Git 软件，忽略即可；若提示安装简体中文扩展，请点击安装以保证界面语言为简体中文。</p>
<h2 id="关于-vs-code-界面"> 关于 VS Code 界面</h2>
<p>VS Code 上方有一排菜单栏，其中有大量的快捷操作，对应的组合键会标于快捷操作旁。如果不能记忆快捷键可以到最上方的菜单栏处查看。</p>
<p>最左侧是选项卡切换，从上至下依次是、搜索、源代码管理、调试和扩展。</p>
<p>最下方的一条是状态栏。从左到右依次是分支名称、同步状态、错误和警告个数、光标位置、缩进大小、编码格式、行尾序列、文件格式、反馈(没用)和通知。</p>
<h3 id="资源管理器"> 资源管理器</h3>
<p>资源管理器是最常使用的界面，快捷键为 <code>Ctrl + Shift + E</code>。</p>
<div><p>提示</p>
<p>请先点击扩展，搜索 JSON，安装 <strong>JSON organizer</strong> 和 <strong>JSON Tools</strong>，并按照界面提示重新加载 VS Code</p>
</div>
<hr>
<h2 id="用-vs-code-打开文件和文件夹"> 用 VS Code 打开文件和文件夹</h2>
<p>VS Code 支持打开文件和文件夹。</p>
<p>打开文件时请在文件图标上单击右键—选择使用 VS Code 打开；</p>
<p>打开文件夹请双击打开文件夹，在空白处单击右键——选择用 VS Code 打开。</p>
<h2 id="vs-code-快捷键"> VS Code 快捷键</h2>
<h3 id="快速选中"> 快速选中</h3>
<p>在任意位置单击放置光标，按住 <code>shift</code> 在第二个位置单击，即可选中两光标位置间的所有文字。</p>
<p><code>Ctrl + Alt + ↑/↓</code>: 向方向键方向的相邻行放置一个光标；</p>
<h3 id="移动文字"> 移动文字</h3>
<p><code>Alt + ↑</code>: 光标所在行或选中的文字的所有行整体上移一行；</p>
<p><code>Alt + ↓</code>: 光标所在行或选中文字的所有行整体下移一行</p>
<h3 id="复制文字"> 复制文字</h3>
<p><code>Alt + shift + ↑</code>: 光标所在行或选中的文字的所有行整体向下复制一行(如果选中了多行就是复制多行)；</p>
<p><code>Alt + shift + ↓</code>: 光标所在行或选中文字的所有行整体向上复制一行(如果选中了多行就是复制多行)；</p>
<h3 id="格式化代码"> 格式化代码</h3>
<p><code>Alt + shift + F</code></p>
<h3 id="缩进显示-json-由插件提供支持"> 缩进显示 json: (由插件提供支持)</h3>
<p><code>Ctrl + Alt + M</code> (在制作时使用，方便查看 json)</p>
<h3 id="其他-windows-快捷键"> 其他 Windows 快捷键</h3>
<p><code>Ctrl + X</code>: 剪切；</p>
<p><code>Ctrl + C</code>: 复制；</p>
<p><code>Ctrl + V</code>: 粘贴；</p>
<p><code>Ctrl + A</code>: 全选；</p>
<p><code>Ctrl + Z</code>: 撤销；</p>
<p><code>Ctrl + Y</code>: 恢复；</p>
<p><code>Ctrl + F</code>: 查找；</p>
<p><code>Ctrl + H</code>: 替换。</p>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <category term="VS Code"/>
    <contributor>
      <name>南辞</name>
    </contributor>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">用户界面</title>
    <id>http://qiqi.dreamagain.top/software/vscode/ui/</id>
    <link href="http://qiqi.dreamagain.top/software/vscode/ui/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<p>本质上，Visual Studio Code 是代码编辑器。像许多其他代码编辑器一样，VS Code 在左边采用通用的用户界面和资源管理器布局，以显示您有权访问的所有文件和文件夹，而在右边的编辑器则显示您已打开文件的内容。</p>
<h2 id="基本布局"> 基本布局</h2>
<p>VS Code 具有简单直观的布局，可最大程度地为编辑器提供空间，同时为浏览和访问文件夹或项目的整个上下文留出足够的空间。用户界面分为五个区域:</p>
<ul>
<li><strong>编辑器</strong>: 用于编辑文件的主要区域。您可以在垂直和水平方向上并排打开任意多个编辑器。</li>
<li><strong>侧边栏</strong>: 包含诸如资源管理器之类的不同视图，可在您处理项目时为您提供帮助。</li>
<li><strong>状态栏</strong>: 有关打开的项目和您编辑的文件的信息。</li>
<li><strong>任务栏</strong>: 位于最左侧，可让您在视图之间进行切换，并为您提供特定于上下文的其他指示符，例如启用 Git 时传出更改的数量。</li>
<li><strong>面板</strong>: 您可以在编辑器区域下方显示不同的面板，以获取输出或调试信息，错误和警告或集成终端。面板也可以向右移动以获得更多垂直空间。</li>
</ul>
<p>每次启动 VS Code 时，它的打开状态与上次关闭时的状态相同。文件夹，布局和打开的文件将保留。</p>
<p>在每个编辑器中打开的文件都显示在编辑器区域顶部，带有选项卡式标题(Tab)。要了解有关选项卡式标题的更多信息，请参见下面的  部分。</p>
<div><p>提示</p>
<p>您可以将侧栏移至右侧(<strong>查看 &gt; 外观 &gt; 向右移动侧边栏</strong>)或切换其可见性(<code>Ctrl + B</code>)。</p>
</div>
<h2 id="并排编辑"> 并排编辑</h2>
<p>您可以在垂直和水平方向上并排打开任意多个编辑器。如果您已经打开了一个编辑器，则可以通过多种方式在现有编辑器的一侧打开另一个编辑器:</p>
<ul>
<li><code>Alt</code>: 在资源管理器中单击一个文件。</li>
<li><code>Ctrl + \</code>: 将活动编辑器一分为二。</li>
<li>从文件的资源管理器上下文菜单中选择 <strong>在侧边打开</strong>(<code>Ctrl + Enter</code>)。</li>
<li>单击编辑器右上方的 <strong>向右拆分编辑器</strong> 按钮。</li>
<li>将文件拖放到编辑器区域的任何一侧。</li>
<li>在 <strong>快速打开</strong> (<code>Ctrl + P</code>)文件列表中，按 <code>Ctrl + Enter</code>(macOS: <code>Cmd + Enter</code>)。</li>
</ul>
<p>每当您打开另一个文件时，处于活动状态的编辑器都会显示该文件的内容。因此，如果您有两个并排的编辑器，并且想要将文件打开到右侧编辑器中，请在打开文件之前，确保该编辑器处于活动状态(通过在其中单击)。</p>
<p>默认情况下，编辑器将打开到活动窗口的右侧。您可以通过设置更改此行为，<code>workbench.editor.openSideBySideDirection</code> 并配置为在活动编辑器的底部打开新编辑器。</p>
<p>当您有一个以上的编辑器打开您可以按住 Ctrl 键的同时按 1、2、3 在它们之间迅速切换。</p>
<div><p>提示</p>
<p>您可以调整编辑器的大小并重新排序。拖放编辑器标题区域以重新定位编辑器或调整其大小。</p>
</div>
<h2 id="小地图"> 小地图</h2>
<p>Minimap(代码大纲)为您提供了源代码的高级概述，这对于快速导航和理解代码很有用。文件的小地图显示在编辑器的右侧。您可以单击或拖动阴影区域以快速跳转到文件的不同部分。</p>
<p><img src="./assets/minimap.png" alt="小地图"></p>
<div><p>提示</p>
<p>您可以通过分别设置 <code>&quot;editor.minimap.side&quot;: &quot;left&quot;</code> 或 <code>&quot;editor.minimap.enabled&quot;: false</code> 在用户或工作空间设置中将小地图移到左侧或完全禁用它。</p>
</div>
<h3 id="缩进指南"> 缩进指南</h3>
<p><img src="./assets/indent-raindow.png" alt="缩进提示"></p>
<p>上图还显示了压痕指南(垂直线)，可帮助您快速查看匹配的压痕级别。如果您要禁用缩进指南，则可以 <code>&quot;editor.renderIndentGuides&quot;: false</code> 在用户或工作空间设置中进行设置。</p>
<div><p>提示</p>
<p>请安装 <strong>Bracket Pair Colorizer 2</strong> 扩展来启用彩虹缩进</p>
</div>
<h2 id="导航痕迹"> 导航痕迹</h2>
<p>编辑器在其内容上方有一个导航栏，称为 <strong>导航痕迹</strong>。它显示当前位置，并允许您在文件夹，文件和符号之间快速导航。</p>
<p><img src="./assets/breadcrumb.png" alt="导航痕迹"></p>
<p>导航痕迹始终显示文件路径，如果当前文件类型支持符号的语言，则符号路径直至光标位置。您可以使用 <strong>查看 &gt; 显示导航痕迹</strong> 切换命令禁用导航痕迹。有关导航痕迹功能的更多信息，例如如何自定义其外观，请参见 <a href="https://code.visualstudio.com/docs/editor/editingevolved#_breadcrumbs" target="_blank" rel="noopener noreferrer">导航痕迹</a> 部分。</p>
<h2 id="资源管理器"> 资源管理器</h2>
<p>资源管理器用于浏览，打开和管理项目中的所有文件和文件夹。VS Code 基于文件和文件夹-您可以直接在 VS Code 中打开文件或文件夹并开始使用。</p>
<p>在 VS Code 中打开文件夹后，该文件夹的内容将显示在资源管理器中。您可以从这里做很多事情:</p>
<ul>
<li>创建，删除和重命名文件和文件夹。</li>
<li>通过拖放移动文件和文件夹。</li>
<li>使用上下文菜单浏览所有选项。</li>
</ul>
<div><p>提示</p>
<p>您可以从 VS Code 外部将文件拖放到资源管理器中以进行复制(如果资源管理器为空，则 VS Code 将打开它们)</p>
</div>
<p>VS Code 与您可能会使用的其他工具(特别是命令行工具)配合得很好。如果要在当前已在 VS Code 中打开的文件夹的上下文中运行命令行工具，请右键单击该文件夹，然后选择在命令提示符下打开(或在 macOS 或 Linux 上在终端中打开)。</p>
<p>您还可以通过右键单击本机资源管理器中的文件或文件夹，然后选择 <strong>在文件资源管理器中显示</strong> 来导航到文件或文件夹的位置。</p>
<div><p>提示</p>
<p>键入 <code>Ctrl + P</code>(快速打开)可按文件名快速搜索和打开文件。</p>
</div>
<p>默认情况下，VS Code 从资源管理器中排除某些文件夹(例如 .git)。使用 <code>files.exclude</code> 设置可配置用于从资源管理器隐藏文件和文件夹的规则。</p>
<div><p>提示</p>
<p>这对于隐藏派生的资源文件非常有用，例如 Unity 中的 <code>*.meta</code> 、TypeScript 项目中的 <code>*.js</code>。为了使 Unity 排除 <code>*.cs.meta</code> 文件，要选择的模式是: <code>&quot;**/*.cs.meta&quot;: true</code>。对于 TypeScript，可以使用以下命令排除为 TypeScript 文件生成的 JavaScript: <code>&quot;**/*.js&quot;: {&quot;when&quot;: &quot;$(basename).ts&quot;}</code>。</p>
</div>
<h3 id="多选"> 多选</h3>
<p>您可以在 <strong>文件资源管理器</strong> 和 <strong>打开的编辑器</strong> 视图中选择多个文件，以对多个项目运行动作( <strong>删除</strong>，<strong>拖放</strong>，<strong>在侧边打开</strong>)。使用 Ctrl / Cmd 键和单击选择单个文件，使用 <code>Shift + click</code> 选择范围。如果选择两个项目，则现在可以使用上下文菜单 <strong>将已选项进行比较</strong> 来快速比较两个文件。</p>
<h3 id="过滤文档树"> 过滤文档树</h3>
<p>您可以在文件资源管理器中键入以过滤当前可见的文件。以 <strong>文件资源管理器</strong> 为重点，开始键入要匹配的文件名的一部分。您将在文件资源管理器的右上方看到一个过滤器框，其中显示了您到目前为止所键入的内容，并且匹配的文件名将突出显示。当您按下光标键上下移动文件列表时，它将在匹配的文件或文件夹之间跳转。</p>
<p>将鼠标悬停在过滤器框上并选择 <strong>启用输入时筛选</strong> 将仅显示匹配的文件/文件夹。使用 <strong>X</strong> 清除按钮清除过滤器。</p>
<p><img src="./assets/filter-files.png" alt="在文件资源管理器中过滤文件"></p>
<h3 id="大纲视图"> 大纲视图</h3>
<p>大纲视图是文件资源管理器底部的单独部分。展开后，它将显示当前活动的编辑器的符号树。</p>
<p><img src="./assets/outline-view.png" alt="大纲视图"></p>
<p>大纲视图具有不同的 <strong>排序依据</strong> 模式，可选的光标跟踪，并支持通常的打开手势。它还包括一个输入框，可在您键入时查找或过滤符号。错误和警告也显示在 <strong>大纲</strong> 视图中，使您可以快速查看问题的位置。</p>
<p>该视图依赖于已安装的扩展针对不同文件类型计算出的信息来显示符号。例如，内置的 Markdown 支持会返回 Markdown 标题层次结构。</p>
<p>有几种 <strong>大纲</strong> 视图设置，可用于启用/禁用图标以及控制错误和警告显示(默认情况下全部启用):</p>
<ul>
<li><code>outline.icons</code>: 切换带有图标的渲染轮廓元素。</li>
<li><code>outline.problems.enabled</code>: 在大纲元素上显示错误和警告。</li>
<li><code>outline.problems.badges</code>: 切换使用徽章的错误和警告。</li>
<li><code>outline.problems.colors</code>: 切换颜色使用错误和警告。</li>
</ul>
<h2 id="打开的编辑器"> 打开的编辑器</h2>
<p>在资源管理器的顶部是一个标记为 <strong>打开的编辑器</strong> 的视图。这是活动文件或预览的列表。这些是您以前使用 VS Code 打开的文件。例如，如果您执行以下操作，文件将在 <strong>打开的编辑器</strong> 视图中列出:</p>
<ul>
<li>更改文件。</li>
<li>双击文件的标题。</li>
<li>在资源管理器中双击一个文件。</li>
<li>打开一个不属于当前文件夹的文件。</li>
</ul>
<p>只需在 <strong>打开的编辑器</strong> 中单击一个项目，该项目就会在 VS Code 中变为活动状态。</p>
<p>完成任务后，可以从 <strong>打开的编辑器</strong> 中单独删除文件，也可以使用 <strong>关闭所有编辑器</strong> 按钮来关闭所有文件。</p>
<h2 id="查看"> 查看</h2>
<p>文件浏览器只是 VS Code 中可用的视图之一。也有以下视图:</p>
<ul>
<li>搜索: 提供全局搜索并在打开的文件夹中进行替换。</li>
<li>源代码控制: VS Code 默认包含 Git 源代码控制。</li>
<li>运行: VS Code 的运行和调试视图显示变量，调用堆栈和断点。</li>
<li>扩展: 在 VS Code 中安装和管理扩展。</li>
<li>自定义视图: 扩展贡献的视图。</li>
</ul>
<div><p>提示</p>
<p>您可以使用 <strong>查看 &gt; 打开视图</strong> 命令打开任何视图。</p>
</div>
<p><img src="./assets/outline-view.png" alt="打开视图"></p>
<p>您可以在主视图中显示或隐藏视图，也可以通过拖放对其进行重新排序。</p>
<h3 id="任务栏"> 任务栏</h3>
<p>左侧的任务栏使您可以在视图之间快速切换。您还可以通过将视图拖放到任务栏上来重新排列视图，或完全删除视图(右键单击 &gt; 隐藏)。</p>
<p><img src="./assets/activity-bar.png" alt="任务栏"></p>
<h2 id="命令面板"> 命令面板</h2>
<p>同样可以从键盘访问 VS Code。要知道的最重要的组合键是 <code>Ctrl + Shift + P</code>，它会弹出 Command Palette。从这里，您可以访问 VS Code 的所有功能，包括最常用操作的键盘快捷键。</p>
<p><img src="./assets/command-palette.png" alt="命令面板"></p>
<p>该命令面板提供了访问很多命令。您可以使用相同的交互式窗口执行编辑器命令，打开文件，搜索符号以及查看文件的快速轮廓。这里有一些提示:</p>
<ul>
<li><code>Ctrl + P</code> 将允许您通过键入文件或符号的名称来导航到任何文件或符号</li>
<li><code>Ctrl + Tab</code> 将使您循环浏览打开的最后一组文件</li>
<li><code>Ctrl + Shift + P</code> 将直接带您进入编辑器命令</li>
<li><code>Ctrl + Shift + O</code> 将让您导航到文件中的特定符号</li>
<li><code>Ctrl + G</code> 将允许您导航到文件中的特定行</li>
</ul>
<p>在输入字段中键入 <code>?</code> 以获取可以从此处执行的可用命令的列表:</p>
<p><img src="./assets/help.png" alt="快速打开帮助"></p>
<h2 id="配置编辑器"> 配置编辑器</h2>
<p>VS Code 提供了许多用于配置编辑器的选项。在 <strong>查看</strong> 菜单中，您可以隐藏或切换用户界面的各个部分，例如侧栏，状态栏和任务栏。</p>
<h3 id="隐藏菜单栏-windows-和-linux"> 隐藏菜单栏(Windows 和 Linux)</h3>
<p>您可以使用 <strong>查看 &gt; 外观</strong> 命令隐藏 Windows 和 Linux 上的菜单栏。您仍然可以通过按 Alt 键(<code>window.menuBarVisibility</code> 设置)来访问菜单栏。</p>
<h3 id="设置"> 设置</h3>
<p>大多数编辑器配置保留在可以直接修改的设置中。您可以通过用户设置全局设置选项，也可以通过工作区设置针对每个项目/文件夹设置选项。设置值保存在 <code>settings.json</code> 文件中。</p>
<ul>
<li>选择 <strong>文件 &gt; 首选项 &gt; 设置</strong>(或按 <code>Ctrl + ,</code>) 来编辑用户 settings.json 文件。</li>
<li>要编辑工作区的设置，请选择 <strong>工作区设置</strong> 选项卡以编辑工作空间 settings.json 文件。</li>
</ul>
<p>您将在左侧窗口中看到 <strong>VS Code 默认设置</strong>，而 settings.json 在右侧则可编辑。您可以使用顶部的搜索框轻松过滤设置。<code>settings.json</code> 通过单击设置左侧的编辑图标，将设置复制到右侧的可编辑内容。具有固定值集的设置允许您选择一个值作为其编辑图标菜单的一部分。</p>
<p>编辑设置后，键入 <code>Ctrl + S</code> 保存更改。所做的更改将立即生效。</p>
<div><p>提示</p>
<p>工作区设置将覆盖用户设置，对于在团队中共享项目特定的设置很有用。</p>
</div>
<h3 id="禅模式"> 禅模式</h3>
<p>通过 Zen 模式，您可以隐藏除编辑器之外的所有 UI(没有任务栏，状态栏，侧边栏和面板)，然后全屏显示并集中编辑器布局，从而专注于代码。可以使用 <strong>查看</strong> 菜单，<strong>命令面板</strong> 或快捷键 <code>Ctrl + K Z</code> 来切换 Zen 模式。双击 <code>Esc</code> 退出 Zen 模式。可以通过 <code>zenMode.fullScreen</code> 禁用向全屏过渡。禅模式可以通过下面的设置来进一步调整: <code>zenMode.hideStatusBar</code>，<code>zenMode.hideTabs</code>，<code>zenMode.fullScreen</code>，<code>zenMode.restore</code> 和 <code>zenMode.centerLayout</code>。</p>
<h3 id="中心编辑布局"> 中心编辑布局</h3>
<p>居中的编辑器布局使您可以居中对齐编辑器区域。在大型监视器上使用单个编辑器时，这特别有用。您可以使用侧面的窗框调整视图的大小(按住 Alt 键以独立移动窗框)。</p>
<h2 id="选项卡"> 选项卡</h2>
<p>Visual Studio Code 在编辑器上方的标题区域中显示带有选项卡(带选项卡的标题)的打开的项目。</p>
<p>当您打开文件时，将为该文件添加一个新的选项卡。</p>
<p>选项卡使您可以在项目之间快速导航，并且可以拖放选项卡来重新排序它们。</p>
<p>如果打开的项目超出标题区域的容纳范围，则可以使用 <strong>显示打开的编辑器</strong> 命令(可通过 <code>...</code> 更多按钮使用)来显示选项卡式项目的下拉列表。</p>
<h3 id="tab-顺序"> tab 顺序</h3>
<p>默认情况下，新标签页会添加到现有标签页的右侧，但是您可以在设置中使用 <code>workbench.editor.openPositioning</code> 控制新标签页的显示位置。</p>
<p>例如，您可能希望新的选项卡式项目显示在左侧:</p>
<div><pre><code>    <span>"workbench.editor.openPositioning"</span><span>:</span> <span>"left"</span>
</code></pre>
<div><span>1</span><br></div></div><h2 id="预览模式"> 预览模式</h2>
<p>在资源管理器中单击或选择一个文件时，该文件以预览模式显示，并重复使用现有的选项卡。如果您正在快速浏览文件并且不希望每个访问的文件都有其自己的选项卡，则此功能很有用。当您开始编辑文件或使用双击从资源管理器中打开文件时，新的选项卡将专用于该文件。</p>
<p>预览模式在选项卡标题中以斜体表示:</p>
<p><img src="./assets/preview-mode.png" alt="预览模式"></p>
<p>如果您不想使用预览模式而总是创建一个新的选项卡，则可以使用以下设置来控制行为:</p>
<ul>
<li><code>workbench.editor.enablePreview</code>: 全局启用或禁用预览编辑器</li>
<li><code>workbench.editor.enablePreviewFromQuickOpen</code>: 从快速打开中启用或禁用预览编辑器</li>
</ul>
<h2 id="编辑器组"> 编辑器组</h2>
<p>拆分编辑器时(使用 <strong>拆分编辑器</strong> 或 <strong>在侧边打开</strong> 命令)，将创建一个新的编辑器区域，该区域可以容纳一组项目。您可以在垂直和水平方向上并排打开任意多个编辑器区域。</p>
<p>您可以在资源管理器视图顶部的 <strong>打开的编辑器</strong> 部分中清楚地看到这些内容:</p>
<p><img src="./assets/editor-group.png" alt="标签编辑器组"></p>
<p>您可以在工作台上拖放编辑器组，在组之间移动单个 Tab，然后快速关闭整个组( <strong>全部关闭</strong>)。</p>
<div><p>提示</p>
<p>无论您是否启用了选项卡，VS Code 都会使用编辑器组。如果没有选项卡，则编辑器组是您打开的项目的堆栈，在编辑器窗格中可见最近选择的项目。</p>
</div>
<h2 id="网格编辑器布局"> 网格编辑器布局</h2>
<p>默认情况下，编辑器组以垂直列布局(例如，当您拆分一个编辑器以将其打开到侧面时)。您可以轻松按自己喜欢的任何布局(垂直和水平)排列编辑器组:</p>
<p>为了支持灵活的布局，您可以创建空的编辑器组。默认情况下，关闭编辑器组的最后一个编辑器也会关闭该组本身，但是您可以使用新设置 <code>workbench.editor.closeEmptyGroups: false</code> 更改此行为。</p>
<p>在 <strong>查看 &gt; 编辑器布局</strong> 菜单中有一组预定义的编辑器布局。</p>
<p>默认情况下，打开到一侧的编辑器(例如，通过单击编辑器工具栏的 <strong>向右拆分编辑器</strong> 操作)将打开到活动编辑器的右侧。如果您希望在活动的编辑器下面打开编辑器，请配置新设置 <code>workbench.editor.openSideBySideDirection: down</code>。</p>
<p>有许多键盘命令可用于仅使用键盘来调整编辑器布局，但是如果您更喜欢使用鼠标，则拖放是将编辑器按任何方向划分的快速方法:</p>
<p><img src="./assets/drag-editor.gif" alt="网格编辑器拖放"></p>
<div><p>提示</p>
<p>如果在将鼠标悬停在工具栏上以拆分编辑器时按住 Alt 键，它将提供拆分为其他方向的功能。这是在右侧或底部拆分的快速方法。</p>
</div>
<h3 id="键盘快捷键"> 键盘快捷键</h3>
<p>这是一些方便的键盘快捷键，可在编辑器和编辑器组之间快速导航。</p>
<ul>
<li><code>Ctrl + PageDown</code>: 转到右侧的编辑器。</li>
<li><code>Ctrl + PageUp</code>: 转到左侧的编辑器。</li>
<li><code>Ctrl + Tab</code>: 打开编辑器组 MRU 列表中的上一个编辑器。</li>
<li><code>Ctrl + 1</code>: 转到最左边的编辑器组。</li>
<li><code>Ctrl + 2</code>: 转到中心编辑器组。</li>
<li><code>Ctrl + 3</code>: 转到最右边的编辑器组。</li>
<li><code>Ctrl + F4</code>: 关闭活动的编辑器。</li>
<li><code>Ctrl + K W</code>: 关闭编辑器组中的所有编辑器。</li>
<li><code>Ctrl + K Ctrl + W</code>: 关闭所有编辑器。</li>
</ul>
<h2 id="窗口管理"> 窗口管理</h2>
<p>VS Code 提供了一些选项来控制在会话之间应如何打开或还原窗口(实例)。</p>
<p><code>window.openFoldersInNewWindow</code> 和 <code>window.openFilesInNewWindow</code> 设置提供在打开新的窗口或者是在最后一个活动的窗口中打开文件或文件夹，可能得值有 <code>default</code>，<code>on</code> 和 <code>off</code>。</p>
<p>如果配置为 <code>default</code>，我们将根据发出打开请求的上下文来对是否重用窗口进行最佳猜测。将此设置为 <code>on</code> 或 <code>off</code> 始终表现相同。例如，如果您认为从 <strong>文件</strong> 菜单中选择文件或文件夹应始终打开到新窗口，请将其设置为 <code>on</code>。</p>
<p><code>window.restoreWindows</code> 设置告诉 VS Code 如何还原上一个会话的打开的窗口。默认情况下，VS Code 将还原您在上一个会话中使用过的所有窗口(设置为 <code>all</code> )。将此设置更改 <code>none</code> 为从不重新打开任何窗口，并始终以空的 VS Code 实例开头。更改为 <code>one</code> 则重新打开您上次打开的窗口的最后一个。</p>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <category term="VS Code"/>
    <contributor>
      <name>南辞</name>
    </contributor>
    <published>2020-09-17T00:00:00.000Z</published>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">环境变量的添加</title>
    <id>http://qiqi.dreamagain.top/software/windows/add-path/</id>
    <link href="http://qiqi.dreamagain.top/software/windows/add-path/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<p>以 Windows 10 系统为例，直接在左下角搜索栏中输入“系统变量”</p>
<p><img src="src/software/windows/assets/pathSearch.png" alt="搜索"></p>
<p>在弹出的框中点击环境变量</p>
<p><img src="src/software/windows/assets/path.png" alt="系统变量"></p>
<p>在弹出的新窗口中找到 path，选中并点击编辑</p>
<p><img src="src/software/windows/assets/pathDetail.png" alt="系统变量"></p>
<p>点击添加输入想要添加到 path 的路径或者执行文件名即可</p>
<p><img src="src/software/windows/assets/pathAdd.png" alt="系统变量"></p>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <category term="基础"/>
    <contributor>
      <name>南辞</name>
    </contributor>
    <published>2019-09-08T00:00:00.000Z</published>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">打开命令行</title>
    <id>http://qiqi.dreamagain.top/software/windows/cmd/</id>
    <link href="http://qiqi.dreamagain.top/software/windows/cmd/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <summary type="html"><![CDATA[<p>打开命令行 (命令提示符) 有多种方式。</p>
<ol>
<li>运行 - cmd: <code>Win + R</code> 打开运行，然后敲入 <code>cmd</code> 后回车。</li>
<li>搜索 - cmd: 点击左下角搜索，输入 cmd，然后单击命令提示符。</li>
<li>开始菜单 - Windows 系统 - 命令提示符。</li>
</ol>
<p>如果想要快速打开特定路径的 cmd，请打开对应的文件夹，在地址栏直接输入 <code>cmd</code> 并回车。</p>
]]></summary>
    <content type="html"><![CDATA[<p>打开命令行 (命令提示符) 有多种方式。</p>
<ol>
<li>运行 - cmd: <code>Win + R</code> 打开运行，然后敲入 <code>cmd</code> 后回车。</li>
<li>搜索 - cmd: 点击左下角搜索，输入 cmd，然后单击命令提示符。</li>
<li>开始菜单 - Windows 系统 - 命令提示符。</li>
</ol>
<p>如果想要快速打开特定路径的 cmd，请打开对应的文件夹，在地址栏直接输入 <code>cmd</code> 并回车。</p>

<p><img src="src/software/windows/assets/cmd.png" alt="示意图"></p>
<p>这样就会快速打开一个路径为当前文件夹的命令提示符窗口。</p>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <category term="基础"/>
    <contributor>
      <name>南辞</name>
    </contributor>
    <published>2019-09-08T00:00:00.000Z</published>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">显示隐藏的文件</title>
    <id>http://qiqi.dreamagain.top/software/windows/hidden-file/</id>
    <link href="http://qiqi.dreamagain.top/software/windows/hidden-file/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<p><img src="src/software/windows/assets/hidden-file.png" alt="如何显示隐藏的文件与文件夹"></p>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <category term="基础"/>
    <contributor>
      <name>南辞</name>
    </contributor>
    <published>2020-09-15T00:00:00.000Z</published>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">记事本的遗留问题</title>
    <id>http://qiqi.dreamagain.top/software/windows/notepad/</id>
    <link href="http://qiqi.dreamagain.top/software/windows/notepad/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<p>在编写代码的时候，临时的软件选择需要注意。</p>
<p>请注意，绝对不能用 Word 和写字板。Word 和写字板保存的不是纯文本文件。</p>
<p>千万不要使用 Windows 自带的记事本编辑任何文本文件。</p>
<p>原因是 Microsoft 开发记事本的团队使用了一个非常弱智的行为来保存 UTF-8 编码的文件，他们自作聪明地在每个文件开头添加了几个特殊字符(UTF-8 BOM，即 0xefbbbf)，您会遇到很多不可思议的问题，比如，网页第一行可能会显示一个“?”，明明正确的程序一编译就报语法错误，等等，都是由记事本的弱智行为带来的。</p>
<p>这个弱智行为从 Windows XP 影响到 Windows 10，在尚未发布的 Windows 10 版本(2009) 中，才得到解决。</p>
<div><p>提示</p>
<p>如果实在是临时急用，需要用记事本替代改一下代码，也要一定注意，保存文件时使用 ANSI 编码，并且暂时不要输入(包含)中文。</p>
</div>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <contributor>
      <name>南辞</name>
    </contributor>
    <published>2019-09-07T00:00:00.000Z</published>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">基础知识</title>
    <id>http://qiqi.dreamagain.top/software/windows/</id>
    <link href="http://qiqi.dreamagain.top/software/windows/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <summary type="html"><![CDATA[<p>以下是有关于 Windows 10 系统的一些基础知识。</p>
]]></summary>
    <content type="html"><![CDATA[<p>以下是有关于 Windows 10 系统的一些基础知识。</p>

<ul>
<li>
<p><a href="./src/software/windows/add-path.html">添加到 path</a></p>
</li>
<li>
<p><a href="./src/software/windows/shortcut-key.html">Windows 快捷键</a></p>
</li>
<li>
<p><a href="./src/software/windows/hidden-file.html">显示隐藏的文件</a></p>
</li>
<li>
<p><a href="./src/software/windows/cmd.html">快速打开 CMD</a></p>
</li>
<li>
<p><a href="./src/software/windows/notepad.html">记事本的遗留问题</a></p>
</li>
</ul>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <category term="基础"/>
    <contributor>
      <name>南辞</name>
    </contributor>
    <published>2019-09-07T00:00:00.000Z</published>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">常用快捷键</title>
    <id>http://qiqi.dreamagain.top/software/windows/shortcut-key/</id>
    <link href="http://qiqi.dreamagain.top/software/windows/shortcut-key/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <summary type="html"><![CDATA[<p>熟练掌握各种 Windows 快捷键，能够更加高效的使用 Windows。</p>
]]></summary>
    <content type="html"><![CDATA[<p>熟练掌握各种 Windows 快捷键，能够更加高效的使用 Windows。</p>

<h2 id="最常用且最有用的"> 最常用且最有用的</h2>
<ul>
<li><code>F2</code>: 重命名文件；</li>
<li><code>F5</code>: 刷新；</li>
<li><code>PRINT SCREEN</code>: 将当前屏幕截图拷贝到剪贴板；</li>
<li><code>Windows</code> + <code>Shift</code> + <code>S</code>: 打开截图工具；(仅在 Windows10 1809 及以上系统可用)</li>
<li><code>ALT</code> + <code>TAB</code> 切换当前程序(加 Shift 反向)；</li>
<li><code>ALT</code> + <code>F4</code>: 关闭当前应用程序；</li>
<li><code>Ctrl</code> + <code>Tab</code>: 在选项卡上向后移动(加 Shift 反向)；</li>
<li><code>CTRL</code> + <code>F4</code> 或 <code>CTRL</code> + <code>W</code>: 关闭当前选项卡；</li>
<li><code>CTRL</code> + <code>A</code>: 全选；</li>
<li><code>CTRL</code> + <code>X</code>: 剪切；</li>
<li><code>CTRL</code> + <code>C</code>: 复制；</li>
<li><code>CTRL</code> + <code>V</code>: 粘贴；</li>
<li><code>Ctrl</code> + <code>F</code>: 查找；</li>
<li><code>Ctrl</code> + <code>H</code>: 替换。</li>
<li><code>CTRL</code> + <code>Shift</code> + <code>N</code>: 新建文件夹或窗口</li>
</ul>
<h2 id="通用键"> 通用键</h2>
<ul>
<li><code>F1</code>: 显示帮助；</li>
<li><code>F2</code>: 重命名文件；</li>
<li><code>F5</code>: 刷新；</li>
<li><code>F11</code>: 全屏；</li>
<li><code>Shift</code> + <code>F10</code>: 打开当前活动项目的快捷菜单(相当于鼠标右键)；</li>
<li><code>ALT</code> 激活当前程序的菜单栏(使用对应字母选择)；</li>
<li><code>Backspace</code>: 退格——删除前一个字符、文件视图下——返回上一级；</li>
<li><code>Enter</code>: 执行或进入；</li>
<li><code>Win</code> 或 <code>CTRL</code> + <code>ESC</code>: 打开开始菜单；</li>
<li><code>DELETE</code>: 删除被选中的项目，如果是文件，将被放入回收站；</li>
<li><code>PRINT SCREEN</code>: 将当前屏幕截图拷贝到剪贴板；</li>
</ul>
<h2 id="程序窗口"> 程序窗口</h2>
<ul>
<li><code>Win</code> + <code>Tab</code>: 最近任务和多桌面视图；</li>
<li><code>ALT</code> + <code>TAB</code> 切换当前程序(加 Shift 反向)；</li>
<li><code>ALT</code> + <code>F4</code>: 关闭当前应用程序；</li>
<li><code>Ctrl</code> + <code>Tab</code>: 在选项卡上向后移动(加 Shift 反向)；</li>
<li><code>CTRL</code> + <code>F4</code> 或 <code>CTRL</code> + <code>W</code>: 关闭当前选项卡；</li>
<li><code>Alt</code> + <code>加下划线的字母</code> 执行与该字母匹配的命令(或选择选项)；</li>
<li><code>Win</code> + <code>↑</code>: 显示最小化的窗口 → 最大化窗口；</li>
<li><code>Win</code> + <code>←</code>: 将窗口最大化到屏幕的左侧；</li>
<li><code>Win</code> + <code>→</code>: 将窗口最大化到屏幕的右侧；</li>
<li><code>Win</code> + <code>↓</code>: 缩小窗口 → 最小化窗口；</li>
<li><code>Win</code> + <code>Home</code>: 最小化除活动窗口之外的所有窗口；</li>
<li><code>ALT</code> + <code>SPACEBAR</code>: 打开程序最左上角的菜单；</li>
<li><code>Win</code> + <code>Shift</code> + <code>↑</code>: 将窗口拉伸到屏幕的顶部和底部；</li>
<li><code>Win</code> + <code>Shift</code> + <code>←</code> 或 <code>Win</code> + <code>Shift</code> + <code>→</code>: 将窗口从一个监视器移动到另一个监视器；</li>
</ul>
<h2 id="文件浏览"> 文件浏览</h2>
<ul>
<li><code>F2</code>: 重命名文件；</li>
<li><code>Shift</code> + <code>DELETE</code>: 删除被选中的项目，如果是文件，将被直接删除而不是放入回收站；</li>
<li><code>CTRL</code> + <code>X</code>: 剪切；</li>
<li><code>CTRL</code> + <code>C</code>: 复制；</li>
<li><code>CTRL</code> + <code>V</code>: 粘贴；</li>
<li><code>CTRL</code> + <code>Shift</code> + <code>N</code>: 新建文件夹或窗口</li>
</ul>
<h2 id="编辑模式"> 编辑模式</h2>
<ul>
<li><code>CTRL</code> + <code>O</code>: 打开文件；</li>
<li><code>CTRL</code> + <code>S</code>: 保存；</li>
<li><code>CTRL</code> + <code>方向键</code>: 滚动屏幕；</li>
<li><code>CTRL</code> + <code>A</code>: 全选；</li>
<li><code>CTRL</code> + <code>X</code>: 剪切；</li>
<li><code>CTRL</code> + <code>C</code>: 复制；</li>
<li><code>CTRL</code> + <code>V</code>: 粘贴；</li>
<li><code>CTRL</code> + <code>Z</code>: 撤销；</li>
<li><code>CTRL</code> + <code>Y</code>: 重做；</li>
<li><code>Ctrl</code> + <code>F</code>: 查找；</li>
<li><code>Ctrl</code> + <code>H</code>: 替换。</li>
<li><code>CTRL</code> + <code>E</code>: 搜索/助理；</li>
<li><code>Ctrl</code> + <code>Tab</code>: 在选项卡上向后移动(加 Shift 反向)；</li>
<li><code>CTRL</code> + <code>F4</code> 或 <code>CTRL</code> + <code>W</code>: 关闭当前选项卡；</li>
<li><code>CTRL</code> + <code>P</code>: 打印；</li>
</ul>
<div><p>提示</p>
<p>单击鼠标左键选择光标位置，按住 <code>Shift</code> 再次在另一处单击鼠标左键，即可选中两光标间的所有文字。鼠标左键单击拖动选中内容即可移动选中内容在文档中的位置。</p>
</div>
<h2 id="系统"> 系统</h2>
<ul>
<li><code>CTRL</code> + <code>Shift</code> + <code>ESC</code>: 打开任务管理器;</li>
<li><code>CTRL</code> + <code>ALT</code> + <code>DELETE</code>: 进入安全选项；</li>
<li><code>Win</code> + <code>D</code>: 显示桌面；</li>
<li><code>Win</code> + <code>E</code>: 打开资源管理器；</li>
<li><code>Win</code> + <code>L</code>: 锁定计算机或切换用户；</li>
<li><code>Win</code> + <code>M</code>: 最小化所有窗口(和显示桌面不同，自行感受)；</li>
<li><code>Win</code> + <code>Shift</code> + <code>M</code>: 将最小化的窗口还原到桌面；</li>
<li><code>Win</code> + <code>R</code>: 打开“运行”对话框；</li>
<li><code>Win</code> + <code>A</code>: 打开通知中心；</li>
<li><code>Win</code> + <code>I</code>: 打开系统设置；</li>
<li><code>Win</code> + <code>X</code>: 打开 Windows 主选项菜单；</li>
<li><code>Win</code> + <code>P</code>: 选择投影模式；</li>
<li><code>Win</code> + <code>数字</code>: 启动任务栏上快捷启动项数字位置处的程序；</li>
<li><code>Win</code> + <code>B</code> 选中桌面右下方工具栏；</li>
<li><code>Win</code> + <code>BREAK</code>: 打开“系统属性”对话框</li>
<li><code>Win</code> + <code>T</code>: 循环切换任务栏上的程序；</li>
<li><code>Shift</code> + <code>Win</code> + <code>数字</code>: 打开任务栏上快捷启动项数字位置处程序的新实例；</li>
<li><code>Alt</code> + <code>Win</code> + <code>数字</code>: 显示任务栏上快捷启动项数字位置处程序的跳转列表；</li>
<li><code>ALT</code> + <code>ESC</code>: 保留程序的显示状态切换当前程序(最小化状态将被保留)(加 Shift 反向)；</li>
</ul>
<h2 id="输入法"> 输入法</h2>
<ul>
<li><code>CTRL</code> + <code>Space</code>: 切换中英文输入法；</li>
<li><code>Win</code> + <code>Space</code>: 切换输入法；</li>
</ul>
<h2 id="屏幕截图"> 屏幕截图</h2>
<ul>
<li><code>PRINT SCREEN</code>: 将当前屏幕截图拷贝到剪贴板；</li>
<li><code>Win</code> + <code>PRINT SCREEN</code>: 将当前屏幕截图保存在图片文件夹中；</li>
<li><code>ALT</code> + <code>PRINT SCREEN</code>: 将当前活动程序窗口以图像方式拷贝到剪贴板；</li>
<li><code>Windows</code> + <code>Shift</code> + <code>S</code>: 打开截图工具；(仅在 Windows10 1809 及以上系统可用)</li>
</ul>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <category term="基础"/>
    <contributor>
      <name>南辞</name>
    </contributor>
    <published>2019-09-07T00:00:00.000Z</published>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">alias</title>
    <id>http://qiqi.dreamagain.top/software/linux/bash/archives/commands/alias/</id>
    <link href="http://qiqi.dreamagain.top/software/linux/bash/archives/commands/alias/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<h1 id="alias"> alias</h1>
<p><code>alias</code> 命令用于设置别名。通常用于在 Bash 设置文件中，设置别名。</p>
<div><pre><code><span>alias</span> <span>dockerlogin</span><span>=</span><span>'ssh www-data@adnan.local -p2222'</span>
</code></pre>
<div><span>1</span><br></div></div>]]></content>
    <author>
      <name>南辞</name>
    </author>
    <contributor>
      <name>南辞</name>
    </contributor>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">VS Code</title>
    <id>http://qiqi.dreamagain.top/software/vscode/</id>
    <link href="http://qiqi.dreamagain.top/software/vscode/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<p>Visual Studio Code 是一个轻量级但功能强大的源代码编辑器，可在您的桌面上运行，并且可用于 Windows，macOS 和 Linux。它具有对 JavaScript，TypeScript 和 Node.js 的内置支持，并具有丰富的其他语言 (例如 C ++，C＃，Java，Python，PHP，Go) 和运行时 (例如 .NET 和 Unity) 扩展的生态系统。由微软出品，因其开源，可扩展和众多插件成为全球最受欢迎的代码编辑器。</p>
<h2 id="特点"> 特点</h2>
<ul>
<li>
<p>智能代码补全</p>
<p>使用 IntelliSense 可以更智能地编写代码、变量，方法和导入模块的完成。</p>
</li>
<li>
<p>热门扩展</p>
<p>启用其他语言，主题，调试器，命令等。</p>
</li>
</ul>
<h2 id="目录"> 目录</h2>
<ul>
<li>
<p><a href="./install.html">安装</a></p>
</li>
<li>
<p><a href="./get-started.html">快速上手</a></p>
</li>
<li>
<p><a href="./guide/">指南</a></p>
<ul>
<li>
<p><a href="./guide/basic.html">基础介绍</a></p>
</li>
<li>
<p><a href="./guide/customization.html">个性化介绍</a></p>
</li>
<li>
<p><a href="./guide/extension.html">扩展介绍</a></p>
</li>
<li>
<p><a href="./guide/file.html">文件介绍</a></p>
</li>
<li>
<p><a href="./guide/edit.html">编辑技巧</a></p>
</li>
<li>
<p><a href="./guide/intellisense.html">智能补全</a></p>
</li>
<li>
<p><a href="./guide/git.html">Git 支持</a></p>
</li>
<li>
<p><a href="./guide/debug.html">调试介绍</a></p>
</li>
<li>
<p><a href="./guide/task.html">任务介绍</a></p>
</li>
<li>
<p><a href="./guide/command.html">命令行介绍</a></p>
</li>
</ul>
</li>
<li>
<p><a href="./ui.html">VS Code 用户界面</a></p>
</li>
<li>
<p><a href="./shortcut-key.html">VS Code 快捷键</a></p>
</li>
<li>
<p><a href="./settings.html">VS Code 设置</a></p>
</li>
<li>
<p><a href="./extension.html">VS Code 推荐扩展</a></p>
</li>
</ul>
<h2 id="官方文档"> 官方文档</h2>
<ul>
<li>
<p><a href="https://code.visualstudio.com/" target="_blank" rel="noopener noreferrer">VS Code 官网</a></p>
</li>
<li>
<p><a href="https://code.visualstudio.com/docs" target="_blank" rel="noopener noreferrer">官方文档</a></p>
</li>
<li>
<p><a href="https://code.visualstudio.com/docs/getstarted/introvideos" target="_blank" rel="noopener noreferrer">官方视频</a></p>
</li>
</ul>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <category term="VS Code"/>
    <contributor>
      <name>南辞</name>
    </contributor>
    <rights>Copyright by 南辞</rights>
  </entry>
  <entry>
    <title type="html">配置 VSCode</title>
    <id>http://qiqi.dreamagain.top/software/vscode/settings/</id>
    <link href="http://qiqi.dreamagain.top/software/vscode/settings/"/>
    <updated>2021-02-15T17:48:57.000Z</updated>
    <content type="html"><![CDATA[<p>这是 Mr.Hope 个人使用的 VS Code 设置，部分设置是<a href="./extension.html">这里</a>的插件配置</p>
<p>将下面内容拷贝至 setting.json 以更改 VS Code 设置</p>
<div><pre><code><span>{</span>
  <span>// 编辑器配置</span>
  <span>"editor.cursorSmoothCaretAnimation"</span><span>:</span> <span>true</span><span>,</span>
  <span>"editor.detectIndentation"</span><span>:</span> <span>false</span><span>,</span>
  <span>"editor.fontFamily"</span><span>:</span> <span>"'Fira Code' ,Consolas, 'Courier New', monospace"</span><span>,</span>
  <span>"editor.fontLigatures"</span><span>:</span> <span>true</span><span>,</span>
  <span>"editor.formatOnSave"</span><span>:</span> <span>true</span><span>,</span>
  <span>"editor.formatOnPaste"</span><span>:</span> <span>true</span><span>,</span>
  <span>"editor.mouseWheelZoom"</span><span>:</span> <span>true</span><span>,</span>
  <span>"editor.rulers"</span><span>:</span> <span>[</span><span>80</span><span>]</span><span>,</span>
  <span>"editor.codeActionsOnSave"</span><span>:</span> <span>{</span>
    <span>// markdownlint 自动修复</span>
    <span>"source.fixAll.markdownlint"</span><span>:</span> <span>true</span>
  <span>}</span><span>,</span>
  <span>"editor.quickSuggestions"</span><span>:</span> <span>{</span>
    <span>"strings"</span><span>:</span> <span>true</span>
  <span>}</span><span>,</span>
  <span>"editor.renderControlCharacters"</span><span>:</span> <span>true</span><span>,</span>
  <span>"editor.renderWhitespace"</span><span>:</span> <span>"boundary"</span><span>,</span>
  <span>"editor.smoothScrolling"</span><span>:</span> <span>true</span><span>,</span>
  <span>"editor.suggestSelection"</span><span>:</span> <span>"first"</span><span>,</span>
  <span>"editor.tabSize"</span><span>:</span> <span>2</span><span>,</span>
  <span>"editor.wordWrap"</span><span>:</span> <span>"on"</span><span>,</span>
  <span>// emmet 包含 wxml 视为 html</span>
  <span>"emmet.includeLanguages"</span><span>:</span> <span>{</span>
    <span>"wxml"</span><span>:</span> <span>"html"</span> <span>// 为 wxml 开启 HTML emmet 支持</span>
  <span>}</span><span>,</span>
  <span>"emmet.variables"</span><span>:</span> <span>{</span>
    <span>"lang"</span><span>:</span> <span>"zh-CN"</span><span>,</span>
    <span>"charset"</span><span>:</span> <span>"UTF-8"</span>
  <span>}</span><span>,</span>
  <span>// 文件相关</span>
  <span>"explorer.confirmDelete"</span><span>:</span> <span>false</span><span>,</span>
  <span>"files.associations"</span><span>:</span> <span>{</span>
    <span>"*.cjson"</span><span>:</span> <span>"jsonc"</span><span>,</span> <span>// 将 .cjson 设为 jsonc</span>
    <span>"*.wxss"</span><span>:</span> <span>"css"</span><span>,</span> <span>// 将 wxss 视为 css</span>
    <span>"*.wxs"</span><span>:</span> <span>"javascript"</span> <span>// 将 wxs 视为 JavaScript</span>
  <span>}</span><span>,</span>
  <span>"files.autoSave"</span><span>:</span> <span>"off"</span><span>,</span>
  <span>"files.eol"</span><span>:</span> <span>"\n"</span><span>,</span>
  <span>"files.exclude"</span><span>:</span> <span>{</span>
    <span>"**/.classpath"</span><span>:</span> <span>true</span><span>,</span>
    <span>"**/.project"</span><span>:</span> <span>true</span><span>,</span>
    <span>"**/.settings"</span><span>:</span> <span>true</span><span>,</span>
    <span>"**/.factorypath"</span><span>:</span> <span>true</span>
  <span>}</span><span>,</span>
  <span>"files.maxMemoryForLargeFilesMB"</span><span>:</span> <span>4096</span><span>,</span>
  <span>// 编辑器窗口设置</span>
  <span>"window.closeWhenEmpty"</span><span>:</span> <span>true</span><span>,</span>
  <span>"window.newWindowDimensions"</span><span>:</span> <span>"inherit"</span><span>,</span>
  <span>"window.zoomLevel"</span><span>:</span> <span>0</span><span>,</span>
  <span>"breadcrumbs.enabled"</span><span>:</span> <span>true</span><span>,</span>
  <span>// 工作台设置</span>
  <span>"workbench.colorTheme"</span><span>:</span> <span>"One Dark Pro"</span><span>,</span>
  <span>"workbench.commandPalette.preserveInput"</span><span>:</span> <span>true</span><span>,</span>
  <span>"workbench.enableExperiments"</span><span>:</span> <span>false</span><span>,</span>
  <span>"workbench.editor.scrollToSwitchTabs"</span><span>:</span> <span>true</span><span>,</span>
  <span>"workbench.iconTheme"</span><span>:</span> <span>"material-icon-theme"</span><span>,</span>
  <span>"workbench.startupEditor"</span><span>:</span> <span>"none"</span><span>,</span>
  <span>"material-icon-theme.folders.associations"</span><span>:</span> <span>{</span>
    <span>"about"</span><span>:</span> <span>"Command"</span><span>,</span>
    <span>"intro"</span><span>:</span> <span>"Command"</span><span>,</span>
    <span>"file"</span><span>:</span> <span>"Public"</span><span>,</span>
    <span>"service-worker"</span><span>:</span> <span>"config"</span><span>,</span>
    <span>"store"</span><span>:</span> <span>"Vuex-store"</span><span>,</span>
    <span>"vuex"</span><span>:</span> <span>"Vuex-store"</span><span>,</span>
    <span>"module"</span><span>:</span> <span>"plugin"</span><span>,</span>
    <span>"router"</span><span>:</span> <span>"Routes"</span><span>,</span>
    <span>".vuepress"</span><span>:</span> <span>"vue"</span><span>,</span>
    <span>"vuepress"</span><span>:</span> <span>"vue"</span><span>,</span>
    <span>"workflows"</span><span>:</span> <span>"Ci"</span><span>,</span>
    <span>"guide"</span><span>:</span> <span>"content"</span><span>,</span>
    <span>"en"</span><span>:</span> <span>"I18n"</span><span>,</span>
    <span>"zh"</span><span>:</span> <span>"I18n"</span><span>,</span>
    <span>"types"</span><span>:</span> <span>"typescript"</span>
  <span>}</span><span>,</span>
  <span>// 提示设置</span>
  <span>"vsintellicode.modify.editor.suggestSelection"</span><span>:</span> <span>"automaticallyOverrodeDefaultValue"</span><span>,</span>
  <span>"problems.showCurrentInStatus"</span><span>:</span> <span>true</span><span>,</span>
  <span>// 在线服务设置</span>
  <span>"extensions.showRecommendationsOnlyOnDemand"</span><span>:</span> <span>true</span><span>,</span>
  <span>"telemetry.enableCrashReporter"</span><span>:</span> <span>false</span><span>,</span>
  <span>"telemetry.enableTelemetry"</span><span>:</span> <span>false</span><span>,</span>
  <span>// 终端设置</span>
  <span>"terminal.integrated.confirmOnExit"</span><span>:</span> <span>false</span><span>,</span>
  <span>"terminal.integrated.copyOnSelection"</span><span>:</span> <span>true</span><span>,</span>
  <span>"terminal.integrated.enableBell"</span><span>:</span> <span>true</span><span>,</span>
  <span>"terminal.integrated.shell.windows"</span><span>:</span> <span>"C:/Program Files/PowerShell/7/pwsh.exe"</span><span>,</span>
  <span>"terminal.integrated.shellArgs.windows"</span><span>:</span> <span>"-nologo"</span><span>,</span>
  <span>"terminal.integrated.shell.linux"</span><span>:</span> <span>"/bin/bash"</span><span>,</span>
  <span>"terminal.external.linuxExec"</span><span>:</span> <span>"bash"</span><span>,</span>
  <span>// git设置</span>
  <span>"git.autofetch"</span><span>:</span> <span>true</span><span>,</span>
  <span>"git.confirmSync"</span><span>:</span> <span>false</span><span>,</span>
  <span>"git.enableSmartCommit"</span><span>:</span> <span>true</span><span>,</span>
  <span>"diffEditor.ignoreTrimWhitespace"</span><span>:</span> <span>false</span><span>,</span>
  <span>"diffEditor.renderSideBySide"</span><span>:</span> <span>true</span><span>,</span>
  <span>"merge-conflict.autoNavigateNextConflict.enabled"</span><span>:</span> <span>true</span><span>,</span>
  <span>// npm 设置</span>
  <span>"npm.enableRunFromFolder"</span><span>:</span> <span>true</span><span>,</span>
  <span>"npm.packageManager"</span><span>:</span> <span>"yarn"</span><span>,</span>
  <span>"npm.scriptExplorerAction"</span><span>:</span> <span>"run"</span><span>,</span>
  <span>"npm-intellisense.importQuotes"</span><span>:</span> <span>"\""</span><span>,</span>
  <span>"npm-intellisense.packageSubfoldersIntellisense"</span><span>:</span> <span>true</span><span>,</span>
  <span>"npm-intellisense.scanDevDependencies"</span><span>:</span> <span>true</span><span>,</span>
  <span>"npm-intellisense.showBuildInLibs"</span><span>:</span> <span>true</span><span>,</span>
  <span>"remote.SSH.remotePlatform"</span><span>:</span> <span>{</span>
    <span>"codeserver"</span><span>:</span> <span>"linux"</span>
  <span>}</span><span>,</span>
  <span>// 特定格式文件设置</span>
  <span>"[dart]"</span><span>:</span> <span>{</span>
    <span>"editor.formatOnType"</span><span>:</span> <span>true</span><span>,</span>
    <span>"editor.selectionHighlight"</span><span>:</span> <span>false</span><span>,</span>
    <span>"editor.suggest.snippetsPreventQuickSuggestions"</span><span>:</span> <span>true</span><span>,</span>
    <span>"editor.suggestSelection"</span><span>:</span> <span>"recentlyUsed"</span><span>,</span>
    <span>"editor.tabCompletion"</span><span>:</span> <span>"on"</span><span>,</span>
    <span>"editor.wordBasedSuggestions"</span><span>:</span> <span>true</span>
  <span>}</span><span>,</span>
  <span>"[cpp]"</span><span>:</span> <span>{</span>
    <span>"editor.defaultFormatter"</span><span>:</span> <span>"ms-vscode.cpptools"</span>
  <span>}</span><span>,</span>
  <span>"[html]"</span><span>:</span> <span>{</span>
    <span>"editor.defaultFormatter"</span><span>:</span> <span>"vscode.html-language-features"</span>
  <span>}</span><span>,</span>
  <span>"[javascript]"</span><span>:</span> <span>{</span>
    <span>"editor.defaultFormatter"</span><span>:</span> <span>"esbenp.prettier-vscode"</span>
  <span>}</span><span>,</span>
  <span>"[typescript]"</span><span>:</span> <span>{</span>
    <span>"editor.defaultFormatter"</span><span>:</span> <span>"esbenp.prettier-vscode"</span>
  <span>}</span><span>,</span>
  <span>"[yaml]"</span><span>:</span> <span>{</span>
    <span>"editor.defaultFormatter"</span><span>:</span> <span>"redhat.vscode-yaml"</span>
  <span>}</span><span>,</span>
  <span>"[json]"</span><span>:</span> <span>{</span>
    <span>"editor.defaultFormatter"</span><span>:</span> <span>"esbenp.prettier-vscode"</span>
  <span>}</span><span>,</span>
  <span>"[jsonc]"</span><span>:</span> <span>{</span>
    <span>"editor.defaultFormatter"</span><span>:</span> <span>"esbenp.prettier-vscode"</span>
  <span>}</span><span>,</span>
  <span>"[markdown]"</span><span>:</span> <span>{</span>
    <span>"editor.defaultFormatter"</span><span>:</span> <span>"yzhang.markdown-all-in-one"</span>
  <span>}</span><span>,</span>
  <span>"[vue]"</span><span>:</span> <span>{</span>
    <span>"editor.defaultFormatter"</span><span>:</span> <span>"octref.vetur"</span>
  <span>}</span><span>,</span>
  <span>"[typescriptreact]"</span><span>:</span> <span>{</span>
    <span>"editor.defaultFormatter"</span><span>:</span> <span>"vscode.typescript-language-features"</span>
  <span>}</span><span>,</span>
  <span>"[xml]"</span><span>:</span> <span>{</span>
    <span>"editor.defaultFormatter"</span><span>:</span> <span>"DotJoshJohnson.xml"</span>
  <span>}</span><span>,</span>
  <span>// typescript配置</span>
  <span>"typescript.locale"</span><span>:</span> <span>"zh-CN"</span><span>,</span>
  <span>"typescript.enablePromptUseWorkspaceTsdk"</span><span>:</span> <span>true</span><span>,</span>
  <span>"typescript.format.semicolons"</span><span>:</span> <span>"insert"</span><span>,</span>
  <span>"typescript.preferences.quoteStyle"</span><span>:</span> <span>"double"</span><span>,</span>
  <span>"typescript.referencesCodeLens.enabled"</span><span>:</span> <span>true</span><span>,</span>
  <span>"typescript.suggest.completeFunctionCalls"</span><span>:</span> <span>true</span><span>,</span>
  <span>"typescript.updateImportsOnFileMove.enabled"</span><span>:</span> <span>"always"</span><span>,</span>
  <span>"javascript.implicitProjectConfig.checkJs"</span><span>:</span> <span>true</span><span>,</span>
  <span>"javascript.implicitProjectConfig.experimentalDecorators"</span><span>:</span> <span>true</span><span>,</span>
  <span>"javascript.format.semicolons"</span><span>:</span> <span>"insert"</span><span>,</span>
  <span>"javascript.referencesCodeLens.enabled"</span><span>:</span> <span>true</span><span>,</span>
  <span>"javascript.suggest.completeFunctionCalls"</span><span>:</span> <span>true</span><span>,</span>
  <span>"javascript.preferences.quoteStyle"</span><span>:</span> <span>"double"</span><span>,</span>
  <span>"javascript.updateImportsOnFileMove.enabled"</span><span>:</span> <span>"always"</span><span>,</span>
  <span>// php设置</span>
  <span>"php.validate.enable"</span><span>:</span> <span>true</span><span>,</span>
  <span>"php.validate.run"</span><span>:</span> <span>"onType"</span><span>,</span>
  <span>// c++设置</span>
  <span>"C_Cpp.default.cppStandard"</span><span>:</span> <span>"c++20"</span><span>,</span>
  <span>"C_Cpp.clang_format_fallbackStyle"</span><span>:</span> <span>"Google"</span><span>,</span>
  <span>// dart</span>
  <span>"dart.debugExternalLibraries"</span><span>:</span> <span>false</span><span>,</span>
  <span>"dart.debugSdkLibraries"</span><span>:</span> <span>false</span><span>,</span>
  <span>// java</span>
  <span>"java.semanticHighlighting.enabled"</span><span>:</span> <span>true</span><span>,</span>
  <span>"java.help.firstView"</span><span>:</span> <span>"gettingStarted"</span><span>,</span>
  <span>// python</span>
  <span>"python.languageServer"</span><span>:</span> <span>"Pylance"</span><span>,</span>
  <span>// css颜色提示配置</span>
  <span>"colorInfo.fields"</span><span>:</span> <span>[</span><span>"hex"</span><span>,</span> <span>"rgb"</span><span>,</span> <span>"alpha"</span><span>,</span> <span>"css-color-name"</span><span>,</span> <span>"preview"</span><span>]</span><span>,</span>
  <span>"colorInfo.languages"</span><span>:</span> <span>[</span>
    <span>{</span>
      <span>"selector"</span><span>:</span> <span>"vue"</span><span>,</span>
      <span>"colors"</span><span>:</span> <span>"css"</span>
    <span>}</span><span>,</span>
    <span>{</span>
      <span>"selector"</span><span>:</span> <span>"css"</span><span>,</span>
      <span>"colors"</span><span>:</span> <span>"css"</span>
    <span>}</span><span>,</span>
    <span>{</span>
      <span>"selector"</span><span>:</span> <span>"sass"</span><span>,</span>
      <span>"colors"</span><span>:</span> <span>"css"</span>
    <span>}</span><span>,</span>
    <span>{</span>
      <span>"selector"</span><span>:</span> <span>"scss"</span><span>,</span>
      <span>"colors"</span><span>:</span> <span>"css"</span>
    <span>}</span><span>,</span>
    <span>{</span>
      <span>"selector"</span><span>:</span> <span>"less"</span><span>,</span>
      <span>"colors"</span><span>:</span> <span>"css"</span>
    <span>}</span>
  <span>]</span><span>,</span>
  <span>// eslint</span>
  <span>"eslint.packageManager"</span><span>:</span> <span>"yarn"</span><span>,</span>
  <span>"eslint.validate"</span><span>:</span> <span>[</span>
    <span>"javascript"</span><span>,</span>
    <span>"javascriptreact"</span><span>,</span>
    <span>"vue"</span><span>,</span>
    <span>"typescript"</span><span>,</span>
    <span>"typescriptreact"</span>
  <span>]</span><span>,</span>
  <span>// gitLens设置</span>
  <span>"gitlens.advanced.messages"</span><span>:</span> <span>{</span>
    <span>"suppressLineUncommittedWarning"</span><span>:</span> <span>true</span><span>,</span>
    <span>"suppressSupportGitLensNotification"</span><span>:</span> <span>true</span>
  <span>}</span><span>,</span>
  <span>"gitlens.gitCommands.closeOnFocusOut"</span><span>:</span> <span>true</span><span>,</span>
  <span>"gitlens.views.repositories.branches.layout"</span><span>:</span> <span>"list"</span><span>,</span>
  <span>// live server</span>
  <span>"liveServer.settings.donotShowInfoMsg"</span><span>:</span> <span>true</span><span>,</span>
  <span>// markdown设置</span>
  <span>"markdown.extension.orderedList.marker"</span><span>:</span> <span>"one"</span><span>,</span>
  <span>"markdown.extension.print.imgToBase64"</span><span>:</span> <span>true</span><span>,</span>
  <span>// markdownlint 设置</span>
  <span>"markdownlint.config"</span><span>:</span> <span>{</span>
    <span>"default"</span><span>:</span> <span>true</span><span>,</span>
    <span>"MD003"</span><span>:</span> <span>{</span>
      <span>"style"</span><span>:</span> <span>"atx"</span>
    <span>}</span><span>,</span>
    <span>"MD004"</span><span>:</span> <span>{</span>
      <span>"style"</span><span>:</span> <span>"dash"</span>
    <span>}</span><span>,</span>
    <span>"MD013"</span><span>:</span> <span>false</span><span>,</span>
    <span>"MD024"</span><span>:</span> <span>{</span>
      <span>"allow_different_nesting"</span><span>:</span> <span>true</span>
    <span>}</span><span>,</span>
    <span>"MD035"</span><span>:</span> <span>{</span>
      <span>"style"</span><span>:</span> <span>"---"</span>
    <span>}</span>
  <span>}</span><span>,</span>
  <span>// vetur 设置</span>
  <span>"vetur.format.defaultFormatter.html"</span><span>:</span> <span>"prettier"</span><span>,</span>
  <span>"vetur.format.defaultFormatter.js"</span><span>:</span> <span>"prettier"</span><span>,</span>
  <span>"vetur.format.defaultFormatter.ts"</span><span>:</span> <span>"prettier"</span><span>,</span>
  <span>"vetur.useWorkspaceDependencies"</span><span>:</span> <span>true</span><span>,</span>
  <span>// vetur stylus 设置</span>
  <span>"stylusSupremacy.insertColons"</span><span>:</span> <span>false</span><span>,</span>
  <span>"stylusSupremacy.insertSemicolons"</span><span>:</span> <span>false</span><span>,</span>
  <span>"stylusSupremacy.insertBraces"</span><span>:</span> <span>false</span><span>,</span>
  <span>// XML工具设置</span>
  <span>"xmlTools.enforcePrettySelfClosingTagOnFormat"</span><span>:</span> <span>true</span><span>,</span>
  <span>"xmlTools.removeCommentsOnMinify"</span><span>:</span> <span>true</span><span>,</span>
  <span>// 微信小程序</span>
  <span>"minapp-vscode.disableAutoConfig"</span><span>:</span> <span>true</span><span>,</span>
  <span>"minapp-vscode.wxmlFormatter"</span><span>:</span> <span>"prettier"</span><span>,</span> <span>//指定格式化工具</span>
  <span>// liveshare 设置</span>
  <span>"liveshare.audio.joinCallBehavior"</span><span>:</span> <span>"accept"</span><span>,</span>
  <span>// 项目管理器</span>
  <span>"projectManager.sortList"</span><span>:</span> <span>"Saved"</span><span>,</span>
  <span>// todoHightlight配置</span>
  <span>"todohighlight.keywords"</span><span>:</span> <span>[</span><span>"WARNING: "</span><span>]</span><span>,</span>

  <span>// leetcode</span>
  <span>"leetcode.hint.commentDescription"</span><span>:</span> <span>false</span><span>,</span>
  <span>"leetcode.hint.commandShortcut"</span><span>:</span> <span>false</span><span>,</span>
  <span>"leetcode.hint.configWebviewMarkdown"</span><span>:</span> <span>false</span><span>,</span>
  <span>"leetcode.hint.setDefaultLanguage"</span><span>:</span> <span>false</span><span>,</span>
  <span>"leetcode.enableStatusBar"</span><span>:</span> <span>false</span><span>,</span>
  <span>"leetcode.endpoint"</span><span>:</span> <span>"leetcode"</span><span>,</span>
  <span>"leetcode.showDescription"</span><span>:</span> <span>"In Webview"</span><span>,</span>

  <span>// prettier</span>
  <span>"prettier.packageManager"</span><span>:</span> <span>"yarn"</span><span>,</span>

  <span>// ProjectManager</span>
  <span>"projectManager.any.ignoredFolders"</span><span>:</span> <span>[</span>
    <span>"dist"</span><span>,</span>
    <span>"node_modules"</span><span>,</span>
    <span>"out"</span><span>,</span>
    <span>"typings"</span><span>,</span>
    <span>"test"</span>
  <span>]</span><span>,</span>

  <span>// stylelint 设置</span>
  <span>"stylelint.packageManager"</span><span>:</span> <span>"yarn"</span><span>,</span>
  <span>"stylelint.validate"</span><span>:</span> <span>[</span>
    <span>"css"</span><span>,</span>
    <span>"html"</span><span>,</span>
    <span>"javascript"</span><span>,</span>
    <span>"javascriptreact"</span><span>,</span>
    <span>"less"</span><span>,</span>
    <span>"markdown"</span><span>,</span>
    <span>"postcss"</span><span>,</span>
    <span>"sass"</span><span>,</span>
    <span>"scss"</span><span>,</span>
    <span>"source.css.styled"</span><span>,</span>
    <span>"source.markdown.math"</span><span>,</span>
    <span>"styled-css"</span><span>,</span>
    <span>"sugarss"</span><span>,</span>
    <span>"svelte"</span><span>,</span>
    <span>"typescript"</span><span>,</span>
    <span>"typescriptreact"</span><span>,</span>
    <span>// "vue",</span>
    <span>"vue-html"</span><span>,</span>
    <span>"vue-postcss"</span><span>,</span>
    <span>"xml"</span><span>,</span>
    <span>"xsl"</span><span>,</span>
    <span>"wxss"</span>
  <span>]</span><span>,</span>
  <span>"codespaces.accountProvider"</span><span>:</span> <span>"Microsoft"</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br><span>96</span><br><span>97</span><br><span>98</span><br><span>99</span><br><span>100</span><br><span>101</span><br><span>102</span><br><span>103</span><br><span>104</span><br><span>105</span><br><span>106</span><br><span>107</span><br><span>108</span><br><span>109</span><br><span>110</span><br><span>111</span><br><span>112</span><br><span>113</span><br><span>114</span><br><span>115</span><br><span>116</span><br><span>117</span><br><span>118</span><br><span>119</span><br><span>120</span><br><span>121</span><br><span>122</span><br><span>123</span><br><span>124</span><br><span>125</span><br><span>126</span><br><span>127</span><br><span>128</span><br><span>129</span><br><span>130</span><br><span>131</span><br><span>132</span><br><span>133</span><br><span>134</span><br><span>135</span><br><span>136</span><br><span>137</span><br><span>138</span><br><span>139</span><br><span>140</span><br><span>141</span><br><span>142</span><br><span>143</span><br><span>144</span><br><span>145</span><br><span>146</span><br><span>147</span><br><span>148</span><br><span>149</span><br><span>150</span><br><span>151</span><br><span>152</span><br><span>153</span><br><span>154</span><br><span>155</span><br><span>156</span><br><span>157</span><br><span>158</span><br><span>159</span><br><span>160</span><br><span>161</span><br><span>162</span><br><span>163</span><br><span>164</span><br><span>165</span><br><span>166</span><br><span>167</span><br><span>168</span><br><span>169</span><br><span>170</span><br><span>171</span><br><span>172</span><br><span>173</span><br><span>174</span><br><span>175</span><br><span>176</span><br><span>177</span><br><span>178</span><br><span>179</span><br><span>180</span><br><span>181</span><br><span>182</span><br><span>183</span><br><span>184</span><br><span>185</span><br><span>186</span><br><span>187</span><br><span>188</span><br><span>189</span><br><span>190</span><br><span>191</span><br><span>192</span><br><span>193</span><br><span>194</span><br><span>195</span><br><span>196</span><br><span>197</span><br><span>198</span><br><span>199</span><br><span>200</span><br><span>201</span><br><span>202</span><br><span>203</span><br><span>204</span><br><span>205</span><br><span>206</span><br><span>207</span><br><span>208</span><br><span>209</span><br><span>210</span><br><span>211</span><br><span>212</span><br><span>213</span><br><span>214</span><br><span>215</span><br><span>216</span><br><span>217</span><br><span>218</span><br><span>219</span><br><span>220</span><br><span>221</span><br><span>222</span><br><span>223</span><br><span>224</span><br><span>225</span><br><span>226</span><br><span>227</span><br><span>228</span><br><span>229</span><br><span>230</span><br><span>231</span><br><span>232</span><br><span>233</span><br><span>234</span><br><span>235</span><br><span>236</span><br><span>237</span><br><span>238</span><br><span>239</span><br><span>240</span><br><span>241</span><br><span>242</span><br><span>243</span><br><span>244</span><br><span>245</span><br><span>246</span><br><span>247</span><br><span>248</span><br><span>249</span><br><span>250</span><br><span>251</span><br><span>252</span><br><span>253</span><br><span>254</span><br><span>255</span><br><span>256</span><br><span>257</span><br><span>258</span><br><span>259</span><br><span>260</span><br><span>261</span><br><span>262</span><br><span>263</span><br><span>264</span><br><span>265</span><br><span>266</span><br><span>267</span><br><span>268</span><br><span>269</span><br><span>270</span><br><span>271</span><br><span>272</span><br><span>273</span><br><span>274</span><br><span>275</span><br><span>276</span><br><span>277</span><br><span>278</span><br><span>279</span><br><span>280</span><br><span>281</span><br><span>282</span><br><span>283</span><br><span>284</span><br><span>285</span><br><span>286</span><br><span>287</span><br><span>288</span><br><span>289</span><br><span>290</span><br><span>291</span><br><span>292</span><br><span>293</span><br><span>294</span><br><span>295</span><br><span>296</span><br><span>297</span><br><span>298</span><br><span>299</span><br><span>300</span><br><span>301</span><br><span>302</span><br><span>303</span><br><span>304</span><br><span>305</span><br><span>306</span><br><span>307</span><br><span>308</span><br><span>309</span><br><span>310</span><br><span>311</span><br><span>312</span><br><span>313</span><br></div></div><p>用鼠标在对应属性值上悬停时，VS Code 会自动给出属性的说明。</p>
]]></content>
    <author>
      <name>南辞</name>
    </author>
    <category term="VS Code"/>
    <contributor>
      <name>南辞</name>
    </contributor>
    <rights>Copyright by 南辞</rights>
  </entry>
</feed>