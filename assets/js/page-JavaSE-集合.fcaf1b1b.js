(window.webpackJsonp=window.webpackJsonp||[]).push([[20],{503:function(t,e,v){t.exports=v.p+"assets/img/collection-01.4a68972d.png"},504:function(t,e,v){t.exports=v.p+"assets/img/image-20210208121434678.3a42f696.png"},505:function(t,e,v){t.exports=v.p+"assets/img/image-20210208122857060.8a24dbf1.png"},591:function(t,e,v){"use strict";v.r(e);var a=v(1),s=Object(a.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("blockquote",[a("p",[a("img",{attrs:{src:"https://img.shields.io/badge/collection-blue.svg",alt:""}}),t._v(" "),a("img",{attrs:{src:"https://img.shields.io/badge/List-blue.svg",alt:""}}),t._v(" "),a("img",{attrs:{src:"https://img.shields.io/badge/Set-blue.svg",alt:""}}),t._v(" "),a("img",{attrs:{src:"https://img.shields.io/badge/Map-blue.svg",alt:""}})])]),t._v(" "),a("h2",{attrs:{id:"集合概要"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#集合概要"}},[t._v("#")]),t._v(" 集合概要")]),t._v(" "),a("p",[a("img",{attrs:{src:v(503),alt:""}})]),t._v(" "),a("p",[t._v("Java的"),a("code",[t._v("java.util")]),t._v("包主要提供了以下三种类型的集合（也可以叫作容器，用来存储对象）")]),t._v(" "),a("ul",[a("li",[a("code",[t._v("List")]),t._v("：一种有序列表的集合")]),t._v(" "),a("li",[a("code",[t._v("Set")]),t._v("：一种保证没有重复元素的集合")]),t._v(" "),a("li",[a("code",[t._v("Map")]),t._v("：一种通过键值（key-value）查找的映射表集合")])]),t._v(" "),a("p",[t._v("Java集合的设计有几个特点：")]),t._v(" "),a("ol",[a("li",[a("p",[t._v("一是实现了接口和实现类相分离，例如，有序表的接口是"),a("code",[t._v("List")]),t._v("，具体的实现类有"),a("code",[t._v("ArrayList")]),t._v("，"),a("code",[t._v("LinkedList")]),t._v("等，")])]),t._v(" "),a("li",[a("p",[t._v("二是支持泛型，我们可以限制在一个集合中只能放入同一种数据类型的元素，如：")]),t._v(" "),a("div",{staticClass:"language-java line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("List")]),a("span",{pre:!0,attrs:{class:"token generics"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("String")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v(" list "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ArrayList")]),a("span",{pre:!0,attrs:{class:"token generics"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 只能放入String类型")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br")])])]),t._v(" "),a("li",[a("p",[t._v("三是Java访问集合总是通过统一的方式——迭代器（Iterator）来实现，它最明显的好处在于无需知道集合内部元素是按什么方式存储")])])]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("提示")]),t._v(" "),a("p",[t._v("由于Java的集合设计非常久远，中间经历过大规模改进，我们要注意到有一小部分集合类是遗留类，不应该继续使用：")]),t._v(" "),a("ul",[a("li",[a("code",[t._v("Hashtable")]),t._v("：一种线程安全的"),a("code",[t._v("Map")]),t._v("实现；")]),t._v(" "),a("li",[a("code",[t._v("Vector")]),t._v("：一种线程安全的"),a("code",[t._v("List")]),t._v("实现；")]),t._v(" "),a("li",[a("code",[t._v("Stack")]),t._v("：基于"),a("code",[t._v("Vector")]),t._v("实现的"),a("code",[t._v("LIFO")]),t._v("的栈。")])]),t._v(" "),a("p",[t._v("还有一小部分接口是遗留接口，也不应该继续使用：")]),t._v(" "),a("ul",[a("li",[a("code",[t._v("Enumeration<E>")]),t._v("：已被"),a("code",[t._v("Iterator<E>")]),t._v("取代。")])])]),t._v(" "),a("h2",{attrs:{id:"泛型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#泛型"}},[t._v("#")]),t._v(" 泛型")]),t._v(" "),a("p",[t._v("泛型是JDK1.5以后增加的，它可以帮助我们建立类型安全的集合。在使用了泛型的集合中，遍历时不必进行强制类型转换。JDK提供了支持泛型的编译器，将运行时的类型检查提前到了编译时执行，提高了代码可读性和安全性。")]),t._v(" "),a("p",[t._v("泛型的本质就是“数据类型的参数化”。 我们可以把“泛型”理解为数据类型的一个占位符(形式参数)，即告诉编译器，在调用泛型时必须传入实际类型。")]),t._v(" "),a("p",[t._v("为了能够更好的学习集合，建议先学习"),a("strong",[t._v("泛型")]),t._v("。")]),t._v(" "),a("ul",[a("li",[a("RouterLink",{attrs:{to:"/program/backend/java/generics.html"}},[t._v("Java泛型学习笔记")])],1),t._v(" "),a("li",[a("a",{attrs:{href:"https://www.w3cschool.cn/java/java-generics.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("w3cschool教程"),a("OutboundLink")],1)])]),t._v(" "),a("h2",{attrs:{id:"collection接口"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#collection接口"}},[t._v("#")]),t._v(" Collection接口")]),t._v(" "),a("p",[t._v("Collection 表示一组对象，它是集中、收集的意思。Collection接口是List、Set接口的父接口，也就是List、Set都包含Collection中的方法，可以在List、Set接口的实现类中进行测试。")]),t._v(" "),a("p",[a("img",{attrs:{src:v(504),alt:"image-20210208121434678"}})]),t._v(" "),a("p",[t._v("Collection的功能:")]),t._v(" "),a("p",[t._v("1、添加功能")]),t._v(" "),a("p",[a("code",[t._v("boolean add (objcet obj)")]),t._v(":添加一个元素")]),t._v(" "),a("p",[a("code",[t._v("boolean addAll(Collection c)")]),t._v(":添加一个集合的元素")]),t._v(" "),a("p",[t._v("2、删除功能:")]),t._v(" "),a("p",[a("code",[t._v("void clear ()")]),t._v(":清除所有的元素")]),t._v(" "),a("p",[a("code",[t._v("boolean remove (object)")]),t._v(":移除一个元素")]),t._v(" "),a("p",[a("code",[t._v("boolean removeAll(Collection c)")]),t._v(":移除本集合和集合c中都包含的元素")]),t._v(" "),a("p",[t._v("3、判断功能:")]),t._v(" "),a("p",[a("code",[t._v("boolean contains (0bject o)")]),t._v(":判断集合是否包含该元素")]),t._v(" "),a("p",[a("code",[t._v("boolean containsAll(Collection c)")]),t._v(":判断集合中是否包含指定的集合元素，只有包含所有的元素,才叫包含")]),t._v(" "),a("p",[a("code",[t._v("boolean isEmpty()")]),t._v(":判断集合是否为空")]),t._v(" "),a("p",[t._v("4、获取功能:")]),t._v(" "),a("p",[a("code",[t._v("Iterator<E>iterator()")]),t._v(":迭代器")]),t._v(" "),a("p",[a("code",[t._v("Object[] toArray()")]),t._v(":转化成Object数组")]),t._v(" "),a("p",[t._v("5、长度功能:")]),t._v(" "),a("p",[a("code",[t._v("int size()")]),t._v(":元素的个数")]),t._v(" "),a("p",[t._v("6、交集功能:")]),t._v(" "),a("p",[a("code",[t._v("boolean retainAll(Collection c)")]),t._v(":取本集合和集合c都包含的元素")]),t._v(" "),a("p",[t._v("Collection 类图（工作中需要掌握一些常用的集合类就行了）")]),t._v(" "),a("p",[a("img",{attrs:{src:v(505),alt:"image-20210208122857060"}})]),t._v(" "),a("h2",{attrs:{id:"list接口及其实现类"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#list接口及其实现类"}},[t._v("#")]),t._v(" List接口及其实现类")]),t._v(" "),a("p",[t._v("List是有序、可重复的容器。")]),t._v(" "),a("p",[a("strong",[t._v("有序")]),t._v("：List中每个元素都有索引标记。可以根据元素的索引标记(在List中的位置)访问元素，从而精确控制这些元素。")]),t._v(" "),a("p",[a("strong",[t._v("可重复")]),t._v("：List允许加入重复的元素。更确切地讲，List通常允许满足 e1.equals(e2) 的元素重复加入容器。")]),t._v(" "),a("p",[t._v("除了Collection接口中的方法，List多了一些跟顺序(索引)有关的方法")]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",[t._v("方法")]),t._v(" "),a("th",[t._v("说明")])])]),t._v(" "),a("tbody",[a("tr",[a("td",[t._v("void add (int index, Object element)")]),t._v(" "),a("td",[t._v("在指定位置插入元素，以前元素全部后移一位")])]),t._v(" "),a("tr",[a("td",[t._v("Object set (int index,Object element)")]),t._v(" "),a("td",[t._v("修改指定位置的元素")])]),t._v(" "),a("tr",[a("td",[t._v("Object get (int index)")]),t._v(" "),a("td",[t._v("返回指定位置的元素")])]),t._v(" "),a("tr",[a("td",[t._v("Object remove (int index)")]),t._v(" "),a("td",[t._v("删除指定位置的元素，后面元素全部前移一位")])]),t._v(" "),a("tr",[a("td",[t._v("int indexOf (Object o)")]),t._v(" "),a("td",[t._v("返回第一个匹配元素的索引，如果没有该元素，返回-1.")])]),t._v(" "),a("tr",[a("td",[t._v("int lastIndexOf (Object o)")]),t._v(" "),a("td",[t._v("返回最后一个匹配元素的索引，如果没有该元素，返回-1")])])])])])}),[],!1,null,null,null);e.default=s.exports}}]);